YARN-7262. Add a hierarchy into the ZKRMStateStore for delegation token znodes to prevent jute buffer overflow (rkanter)

+ *        |       |----- 1
+ *        |       |      |----- (#TokenId barring last character)
+ *        |       |      |       |----- (#Last character of TokenId)
+ *        |       |      ....
+ *        |       |----- 2
+ *        |       |      |----- (#TokenId barring last 2 characters)
+ *        |       |      |       |----- (#Last 2 characters of TokenId)
+ *        |       |      ....
+ *        |       |----- 3
+ *        |       |      |----- (#TokenId barring last 3 characters)
+ *        |       |      |       |----- (#Last 3 characters of TokenId)
+ *        |       |      ....
+ *        |       |----- 4
+ *        |       |      |----- (#TokenId barring last 4 characters)
+ *        |       |      |       |----- (#Last 4 characters of TokenId)
+ *        |       |      ....
+ *
+ * Changes from 1.4 to 1.5 - Change the structure of delegation token znode by
+ * splitting it in 2 parts, depending on a configurable split index. This limits
+ * the number of delegation token znodes returned in a single call while loading
+ * tokens state.
-      .newInstance(1, 4);
+      .newInstance(1, 5);
+  private Map<Integer, String> rmDelegationTokenHierarchies;
+  @VisibleForTesting
+  protected int delegationTokenNodeSplitIndex = 0;
-   * Encapsulates full app node path and corresponding split index.
+   * Encapsulates znode path and corresponding split index for hierarchical
+   * znode layouts.
-  private final static class AppNodeSplitInfo {
+  private final static class ZnodeSplitInfo {
-    AppNodeSplitInfo(String path, int splitIndex) {
+    ZnodeSplitInfo(String path, int splitIndex) {
-    if (appIdNodeSplitIndex < 1 || appIdNodeSplitIndex > 4) {
+    if (appIdNodeSplitIndex < 0 || appIdNodeSplitIndex > 4) {
+    rmDelegationTokenHierarchies = new HashMap<>(5);
+    rmDelegationTokenHierarchies.put(0, delegationTokensRootPath);
+    for (int splitIndex = 1; splitIndex <= 4; splitIndex++) {
+      rmDelegationTokenHierarchies.put(splitIndex,
+          getNodePath(delegationTokensRootPath, Integer.toString(splitIndex)));
+    }
+    delegationTokenNodeSplitIndex =
+        conf.getInt(YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX,
+            YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);
+    if (delegationTokenNodeSplitIndex < 0
+        || delegationTokenNodeSplitIndex > 4) {
+      LOG.info("Invalid value " + delegationTokenNodeSplitIndex + " for config "
+          + YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX
+          + " specified.  Resetting it to " +
+          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);
+      delegationTokenNodeSplitIndex =
+          YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX;
+    }
+    for (int splitIndex = 1; splitIndex <= 4; splitIndex++) {
+      create(rmDelegationTokenHierarchies.get(splitIndex));
+    }
-    List<String> childNodes =
-        getChildren(delegationTokensRootPath);
-
-    for (String childNodeName : childNodes) {
-      String childNodePath =
-          getNodePath(delegationTokensRootPath, childNodeName);
-      byte[] childData = getData(childNodePath);
-
-      if (childData == null) {
-        LOG.warn("Content of " + childNodePath + " is broken.");
+    for (int splitIndex = 0; splitIndex <= 4; splitIndex++) {
+      String tokenRoot = rmDelegationTokenHierarchies.get(splitIndex);
+      if (tokenRoot == null) {
-
-      ByteArrayInputStream is = new ByteArrayInputStream(childData);
-
-      try (DataInputStream fsIn = new DataInputStream(is)) {
+      List<String> childNodes = getChildren(tokenRoot);
+      boolean dtNodeFound = false;
+      for (String childNodeName : childNodes) {
-          RMDelegationTokenIdentifierData identifierData =
-              new RMDelegationTokenIdentifierData();
-          identifierData.readFields(fsIn);
-          RMDelegationTokenIdentifier identifier =
-              identifierData.getTokenIdentifier();
-          long renewDate = identifierData.getRenewDate();
-          rmState.rmSecretManagerState.delegationTokenState.put(identifier,
-              renewDate);
-
-          if (LOG.isDebugEnabled()) {
-            LOG.debug("Loaded RMDelegationTokenIdentifier: " + identifier
-                + " renewDate=" + renewDate);
+          dtNodeFound = true;
+          String parentNodePath = getNodePath(tokenRoot, childNodeName);
+          if (splitIndex == 0) {
+            loadDelegationTokenFromNode(rmState, parentNodePath);
+          } else {
+            // If znode is partitioned.
+            List<String> leafNodes = getChildren(parentNodePath);
+            for (String leafNodeName : leafNodes) {
+              loadDelegationTokenFromNode(rmState,
+                  getNodePath(parentNodePath, leafNodeName));
+            }
+        } else if (splitIndex == 0
+            && !(childNodeName.equals("1") || childNodeName.equals("2")
+            || childNodeName.equals("3") || childNodeName.equals("4"))) {
+          LOG.debug("Unknown child node with name " + childNodeName + " under" +
+              tokenRoot);
+        }
+      }
+      if (splitIndex != delegationTokenNodeSplitIndex && !dtNodeFound) {
+        // If no loaded delegation token exists for a particular split index and
+        // the split index for which tokens are being loaded is not the one
+        // configured, then we do not need to keep track of this hierarchy for
+        // storing/updating/removing delegation token znodes.
+        rmDelegationTokenHierarchies.remove(splitIndex);
+      }
+    }
+  }
+
+  private void loadDelegationTokenFromNode(RMState rmState, String path)
+      throws Exception {
+    byte[] data = getData(path);
+    if (data == null) {
+      LOG.warn("Content of " + path + " is broken.");
+    } else {
+      ByteArrayInputStream is = new ByteArrayInputStream(data);
+      try (DataInputStream fsIn = new DataInputStream(is)) {
+        RMDelegationTokenIdentifierData identifierData =
+            new RMDelegationTokenIdentifierData();
+        identifierData.readFields(fsIn);
+        RMDelegationTokenIdentifier identifier =
+            identifierData.getTokenIdentifier();
+        long renewDate = identifierData.getRenewDate();
+        rmState.rmSecretManagerState.delegationTokenState.put(identifier,
+            renewDate);
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Loaded RMDelegationTokenIdentifier: " + identifier
+              + " renewDate=" + renewDate);
-        } else {
-          LOG.info("Unknown child node with name: " + childNodeName);
+        } else if (!childNodeName.equals(RM_APP_ROOT_HIERARCHIES)){
+          LOG.debug("Unknown child node with name " + childNodeName + " under" +
+              appRoot);
-   * Get parent app node path based on full path and split index supplied.
-   * @param appIdPath App id path for which parent needs to be returned.
+   * Get znode path based on full path and split index supplied.
+   * @param path path for which parent needs to be returned.
-  private String getSplitAppNodeParent(String appIdPath, int splitIndex) {
-    // Calculated as string upto index (appIdPath Length - split index - 1). We
+  private String getSplitZnodeParent(String path, int splitIndex) {
+    // Calculated as string up to index (path Length - split index - 1). We
-    return appIdPath.substring(0, appIdPath.length() - splitIndex - 1);
+    return path.substring(0, path.length() - splitIndex - 1);
-   * Checks if parent app node has no leaf nodes and if it does not have,
-   * removes it. Called while removing application.
-   * @param appIdPath path of app id to be removed.
+   * Checks if parent znode has no leaf nodes and if it does not have,
+   * removes it.
+   * @param path path of znode to be removed.
-  private void checkRemoveParentAppNode(String appIdPath, int splitIndex)
+  private void checkRemoveParentZnode(String path, int splitIndex)
-      String parentAppNode = getSplitAppNodeParent(appIdPath, splitIndex);
+      String parentZnode = getSplitZnodeParent(path, splitIndex);
-        children = getChildren(parentAppNode);
+        children = getChildren(parentZnode);
-        // It should be fine to swallow this exception as the parent app node we
+        // It should be fine to swallow this exception as the parent znode we
-          LOG.debug("Unable to remove app parent node " + parentAppNode +
+          LOG.debug("Unable to remove parent node " + parentZnode +
-          zkManager.safeDelete(parentAppNode, zkAcl, fencingNodePath);
+          zkManager.safeDelete(parentZnode, zkAcl, fencingNodePath);
-            LOG.debug("No leaf app node exists. Removing parent node " +
-                parentAppNode);
+            LOG.debug("No leaf znode exists. Removing parent node " +
+                parentZnode);
-          // It should be fine to swallow this exception as the parent app node
+          // It should be fine to swallow this exception as the parent znode
-            LOG.debug("Unable to remove app parent node " + parentAppNode +
+            LOG.debug("Unable to remove app parent node " + parentZnode +
-      AppNodeSplitInfo alternatePathInfo = getAlternatePath(appId.toString());
+      ZnodeSplitInfo alternatePathInfo = getAlternateAppPath(appId.toString());
-              getSplitAppNodeParent(nodeUpdatePath, appIdNodeSplitIndex);
+              getSplitZnodeParent(nodeUpdatePath, appIdNodeSplitIndex);
-      AppNodeSplitInfo alternatePathInfo = getAlternatePath(appId);
+      ZnodeSplitInfo alternatePathInfo = getAlternateAppPath(appId);
-      AppNodeSplitInfo alternatePathInfo = getAlternatePath(removeAppId);
+      ZnodeSplitInfo alternatePathInfo = getAlternateAppPath(removeAppId);
-    checkRemoveParentAppNode(appIdRemovePath, splitIndex);
+    checkRemoveParentZnode(appIdRemovePath, splitIndex);
-    SafeTransaction trx = zkManager.createTransaction(zkAcl, fencingNodePath);
-    addStoreOrUpdateOps(trx, rmDTIdentifier, renewDate, false);
-    trx.commit();
+    String nodeCreatePath = getLeafDelegationTokenNodePath(
+        rmDTIdentifier.getSequenceNumber(), true);
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Storing " + DELEGATION_TOKEN_PREFIX
+          + rmDTIdentifier.getSequenceNumber());
+    }
+
+    RMDelegationTokenIdentifierData identifierData =
+        new RMDelegationTokenIdentifierData(rmDTIdentifier, renewDate);
+    ByteArrayOutputStream seqOs = new ByteArrayOutputStream();
+    try (DataOutputStream seqOut = new DataOutputStream(seqOs)) {
+      SafeTransaction trx = zkManager.createTransaction(zkAcl,
+          fencingNodePath);
+      trx.create(nodeCreatePath, identifierData.toByteArray(), zkAcl,
+          CreateMode.PERSISTENT);
+      // Update Sequence number only while storing DT
+      seqOut.writeInt(rmDTIdentifier.getSequenceNumber());
+
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Storing " + dtSequenceNumberPath + ". SequenceNumber: "
+            + rmDTIdentifier.getSequenceNumber());
+      }
+
+      trx.setData(dtSequenceNumberPath, seqOs.toByteArray(), -1);
+      trx.commit();
+    }
-    String nodeRemovePath =
-        getNodePath(delegationTokensRootPath, DELEGATION_TOKEN_PREFIX
-            + rmDTIdentifier.getSequenceNumber());
+    String nodeRemovePath = getLeafDelegationTokenNodePath(
+        rmDTIdentifier.getSequenceNumber(), false);
+    int splitIndex = delegationTokenNodeSplitIndex;
+    // Look for paths based on other split indices if path as per configured
+    // split index does not exist.
+    if (!exists(nodeRemovePath)) {
+      ZnodeSplitInfo alternatePathInfo =
+          getAlternateDTPath(rmDTIdentifier.getSequenceNumber());
+      if (alternatePathInfo != null) {
+        nodeRemovePath = alternatePathInfo.path;
+        splitIndex = alternatePathInfo.splitIndex;
+      } else {
+        // Alternate path not found so return.
+        return;
+      }
+    }
+
+    // Check if we should remove the parent app node as well.
+    checkRemoveParentZnode(nodeRemovePath, splitIndex);
-    SafeTransaction trx = zkManager.createTransaction(zkAcl, fencingNodePath);
-    String nodeRemovePath =
-        getNodePath(delegationTokensRootPath, DELEGATION_TOKEN_PREFIX
-            + rmDTIdentifier.getSequenceNumber());
-
-    if (exists(nodeRemovePath)) {
-      // in case znode exists
-      addStoreOrUpdateOps(trx, rmDTIdentifier, renewDate, true);
-    } else {
-      // in case znode doesn't exist
-      addStoreOrUpdateOps(trx, rmDTIdentifier, renewDate, false);
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Attempted to update a non-existing znode " + nodeRemovePath);
+    String nodeUpdatePath = getLeafDelegationTokenNodePath(
+        rmDTIdentifier.getSequenceNumber(), false);
+    boolean pathExists = true;
+    // Look for paths based on other split indices if path as per split index
+    // does not exist.
+    if (!exists(nodeUpdatePath)) {
+      ZnodeSplitInfo alternatePathInfo =
+          getAlternateDTPath(rmDTIdentifier.getSequenceNumber());
+      if (alternatePathInfo != null) {
+        nodeUpdatePath = alternatePathInfo.path;
+      } else {
+        pathExists = false;
-    trx.commit();
-  }
-
-  private void addStoreOrUpdateOps(SafeTransaction trx,
-      RMDelegationTokenIdentifier rmDTIdentifier, Long renewDate,
-      boolean isUpdate) throws Exception {
-    // store RM delegation token
-    String nodeCreatePath = getNodePath(delegationTokensRootPath,
-        DELEGATION_TOKEN_PREFIX + rmDTIdentifier.getSequenceNumber());
-    RMDelegationTokenIdentifierData identifierData =
-        new RMDelegationTokenIdentifierData(rmDTIdentifier, renewDate);
-    ByteArrayOutputStream seqOs = new ByteArrayOutputStream();
-
-    try (DataOutputStream seqOut = new DataOutputStream(seqOs)) {
-
-      if (isUpdate) {
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Updating RMDelegationToken_"
-              + rmDTIdentifier.getSequenceNumber());
-        }
-        trx.setData(nodeCreatePath, identifierData.toByteArray(), -1);
-      } else {
-        trx.create(nodeCreatePath, identifierData.toByteArray(), zkAcl,
-            CreateMode.PERSISTENT);
-        // Update Sequence number only while storing DT
-        seqOut.writeInt(rmDTIdentifier.getSequenceNumber());
-
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Storing " + dtSequenceNumberPath + ". SequenceNumber: "
-              + rmDTIdentifier.getSequenceNumber());
-        }
-
-        trx.setData(dtSequenceNumberPath, seqOs.toByteArray(), -1);
+    if (pathExists) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Updating " + DELEGATION_TOKEN_PREFIX
+            + rmDTIdentifier.getSequenceNumber());
+      RMDelegationTokenIdentifierData identifierData =
+          new RMDelegationTokenIdentifierData(rmDTIdentifier, renewDate);
+      zkManager.safeSetData(nodeUpdatePath, identifierData.toByteArray(), -1,
+          zkAcl, fencingNodePath);
+    } else {
+      storeRMDelegationTokenState(rmDTIdentifier, renewDate);
-   * @return a {@link AppNodeSplitInfo} object containing the path and split
+   * @return a {@link ZnodeSplitInfo} object containing the path and split
-  private AppNodeSplitInfo getAlternatePath(String appId) throws Exception {
+  private ZnodeSplitInfo getAlternateAppPath(String appId) throws Exception {
-            getLeafAppIdNodePath(appId, entry.getValue(), splitIndex, false);
+            getLeafZnodePath(appId, entry.getValue(), splitIndex, false);
-          return new AppNodeSplitInfo(alternatePath, splitIndex);
+          return new ZnodeSplitInfo(alternatePath, splitIndex);
-   * Returns leaf app node path based on app id and passed split index. If the
-   * passed flag createParentIfNotExists is true, also creates the parent app
-   * node if it does not exist.
-   * @param appId application id.
+   * Returns leaf znode path based on node name and passed split index. If the
+   * passed flag createParentIfNotExists is true, also creates the parent znode
+   * if it does not exist.
+   * @param nodeName the node name.
-   * @param appIdNodeSplitIdx split index.
-   * @param createParentIfNotExists flag which determines if parent app node
+   * @param splitIdx split index.
+   * @param createParentIfNotExists flag which determines if parent znode
-   * @return leaf app node path.
+   * @return leaf znode path.
-  private String getLeafAppIdNodePath(String appId, String rootNode,
-      int appIdNodeSplitIdx, boolean createParentIfNotExists) throws Exception {
-    if (appIdNodeSplitIdx == 0) {
-      return getNodePath(rootNode, appId);
+  private String getLeafZnodePath(String nodeName, String rootNode,
+      int splitIdx, boolean createParentIfNotExists) throws Exception {
+    if (splitIdx == 0) {
+      return getNodePath(rootNode, nodeName);
-    String nodeName = appId;
-    int splitIdx = nodeName.length() - appIdNodeSplitIdx;
+    int split = nodeName.length() - splitIdx;
-        getNodePath(rootNode, nodeName.substring(0, splitIdx));
+        getNodePath(rootNode, nodeName.substring(0, split));
-    return getNodePath(rootNodePath, nodeName.substring(splitIdx));
+    return getNodePath(rootNodePath, nodeName.substring(split));
-    return getLeafAppIdNodePath(appId, rmAppRootHierarchies.get(
+    return getLeafZnodePath(appId, rmAppRootHierarchies.get(
+  /**
+   * Returns leaf delegation token node path based on sequence number and
+   * configured split index. If the passed flag createParentIfNotExists is true,
+   * also creates the parent znode if it does not exist.  The sequence number
+   * is padded to be at least 4 digits wide to ensure consistency with the split
+   * indexing.
+   * @param rmDTSequenceNumber delegation token sequence number.
+   * @param createParentIfNotExists flag which determines if parent znode
+   *     needs to be created(as per split) if it does not exist.
+   * @return leaf delegation token node path.
+   * @throws Exception if any problem occurs while performing ZK operation.
+   */
+  private String getLeafDelegationTokenNodePath(int rmDTSequenceNumber,
+      boolean createParentIfNotExists) throws Exception {
+    return getLeafDelegationTokenNodePath(rmDTSequenceNumber,
+        createParentIfNotExists, delegationTokenNodeSplitIndex);
+  }
+
+  /**
+   * Returns leaf delegation token node path based on sequence number and
+   * passed split index. If the passed flag createParentIfNotExists is true,
+   * also creates the parent znode if it does not exist.  The sequence number
+   * is padded to be at least 4 digits wide to ensure consistency with the split
+   * indexing.
+   * @param rmDTSequenceNumber delegation token sequence number.
+   * @param createParentIfNotExists flag which determines if parent znode
+   *     needs to be created(as per split) if it does not exist.
+   * @param split the split index to use
+   * @return leaf delegation token node path.
+   * @throws Exception if any problem occurs while performing ZK operation.
+   */
+  private String getLeafDelegationTokenNodePath(int rmDTSequenceNumber,
+      boolean createParentIfNotExists, int split) throws Exception {
+    String nodeName = DELEGATION_TOKEN_PREFIX;
+    if (split == 0) {
+      nodeName += rmDTSequenceNumber;
+    } else {
+      nodeName += String.format("%04d", rmDTSequenceNumber);
+    }
+    return getLeafZnodePath(nodeName, rmDelegationTokenHierarchies.get(split),
+        split, createParentIfNotExists);
+  }
+
+  /**
+   * Get alternate path for delegation token if path according to configured
+   * split index does not exist. We look for path based on all possible split
+   * indices.
+   * @param rmDTSequenceNumber delegation token sequence number.
+   * @return a {@link ZnodeSplitInfo} object containing the path and split
+   *    index if it exists, null otherwise.
+   * @throws Exception if any problem occurs while performing ZK operation.
+   */
+  private ZnodeSplitInfo getAlternateDTPath(int rmDTSequenceNumber)
+      throws Exception {
+    // Check all possible paths until we find it
+    for (int splitIndex : rmDelegationTokenHierarchies.keySet()) {
+      if (splitIndex != delegationTokenNodeSplitIndex) {
+        String alternatePath = getLeafDelegationTokenNodePath(
+            rmDTSequenceNumber, false, splitIndex);
+        if (exists(alternatePath)) {
+          return new ZnodeSplitInfo(alternatePath, splitIndex);
+        }
+      }
+    }
+    return null;
+  }
+

MOV31 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS74 INS59 INS78 INS83 INS39 INS59 UPD42 INS83 INS39 INS42 INS44 INS43 INS8 UPD42 INS44 MOV8 UPD42 INS44 UPD42 MOV78 UPD83 INS83 INS42 MOV8 MOV78 MOV83 MOV83 MOV39 UPD42 MOV42 MOV44 MOV43 INS8 MOV78 INS83 INS83 INS39 INS42 MOV44 MOV44 MOV43 MOV8 UPD43 UPD42 UPD42 INS29 UPD83 INS43 INS42 INS44 INS44 INS43 INS29 UPD83 MOV83 INS43 INS42 INS44 INS44 INS44 MOV43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS43 INS43 INS43 INS42 INS42 INS42 INS34 UPD42 INS21 INS21 INS24 INS21 INS25 INS24 INS43 INS42 INS42 INS24 INS43 INS42 INS60 INS43 INS42 INS43 UPD42 INS60 MOV25 MOV60 MOV60 INS54 MOV60 INS60 INS25 MOV25 MOV21 INS21 MOV60 INS60 INS25 INS25 UPD42 MOV43 INS42 UPD42 INS65 INS65 INS65 INS65 INS65 INS42 INS39 INS42 INS39 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS60 INS25 INS41 INS65 INS65 INS65 INS65 INS42 INS39 INS42 INS42 INS70 INS41 UPD34 INS42 INS42 INS42 UPD66 INS66 INS7 INS32 INS58 INS27 INS37 INS8 INS7 INS27 INS8 INS58 INS27 INS37 INS8 INS42 INS58 INS27 INS37 INS8 INS42 MOV5 INS59 INS27 INS8 INS8 UPD66 UPD42 UPD66 INS42 UPD66 UPD66 UPD42 UPD66 INS42 MOV43 INS59 MOV58 MOV8 MOV43 INS39 INS59 INS38 INS8 INS32 MOV43 INS39 INS59 INS38 INS8 INS42 INS8 INS8 UPD66 UPD66 UPD66 UPD42 UPD66 UPD42 UPD66 UPD66 MOV43 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS32 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS43 INS59 INS27 INS8 MOV8 INS32 INS66 INS66 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS44 INS32 INS8 INS33 INS42 INS14 INS42 INS42 INS34 INS42 INS39 INS59 INS42 INS34 INS42 INS21 INS42 INS32 INS27 INS27 INS21 INS21 INS39 INS59 INS42 INS34 INS42 INS21 INS39 INS59 INS42 INS34 INS42 INS60 INS25 MOV60 INS60 INS70 INS25 INS42 INS32 INS42 INS33 INS21 MOV60 INS54 UPD42 UPD42 INS42 MOV32 MOV60 MOV21 UPD42 INS42 INS42 MOV32 MOV60 INS25 INS42 INS42 INS42 UPD42 INS42 INS9 INS32 MOV60 INS25 INS25 INS60 MOV21 MOV21 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS39 INS42 UPD42 MOV42 INS42 INS25 UPD34 INS74 INS34 INS42 INS34 INS32 INS42 INS42 INS40 INS40 INS42 INS34 INS42 INS34 INS32 INS7 INS42 INS34 INS32 INS42 INS34 MOV43 INS59 INS27 INS8 INS39 INS59 MOV44 INS42 INS8 INS27 INS8 INS42 INS42 INS32 MOV43 MOV58 MOV8 MOV43 UPD43 UPD43 UPD43 UPD42 MOV32 INS9 INS32 UPD42 MOV32 INS9 INS43 INS27 INS8 INS8 UPD42 MOV32 INS9 INS42 INS42 UPD43 INS27 INS8 INS8 MOV32 INS8 INS43 INS59 UPD42 UPD42 INS7 INS7 INS42 INS42 INS42 INS27 INS8 INS43 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS40 INS42 INS32 INS42 INS32 INS42 INS33 INS18 INS42 INS9 INS25 INS27 INS38 INS21 INS42 INS42 INS27 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS27 INS42 UPD42 INS42 INS33 INS21 INS21 INS41 UPD42 UPD42 INS42 INS33 INS21 INS21 MOV21 INS42 INS42 INS14 UPD42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS60 MOV25 INS42 INS42 INS42 INS32 INS45 INS42 INS45 INS40 INS45 INS40 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV32 INS8 INS25 INS42 INS42 INS42 INS32 INS45 INS42 INS45 MOV43 UPD42 INS25 UPD42 UPD42 UPD42 UPD42 UPD42 INS45 INS42 INS32 UPD42 MOV32 INS7 INS7 UPD42 INS32 INS7 INS7 INS43 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS45 UPD42 MOV42 INS43 INS59 INS32 INS42 INS42 INS42 INS21 INS60 INS25 INS27 INS8 INS42 INS42 INS42 INS38 MOV8 MOV32 INS42 INS42 INS42 INS40 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS42 INS40 INS42 INS9 UPD42 UPD42 INS27 INS42 INS42 INS42 INS32 INS42 INS42 INS41 INS7 MOV43 INS59 INS27 INS8 INS8 INS27 INS38 INS21 INS32 UPD42 MOV43 INS45 INS42 INS32 UPD42 INS42 INS42 MOV9 INS42 INS14 INS42 INS9 INS42 INS32 INS42 INS34 INS21 INS60 INS70 INS42 INS34 INS36 INS32 INS42 INS42 INS42 UPD42 MOV32 MOV42 UPD42 MOV42 UPD43 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS74 INS59 MOV44 INS42 INS8 INS27 INS42 INS42 INS27 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS32 UPD42 INS21 INS32 INS32 INS32 INS32 INS45 INS42 INS45 INS42 UPD45 INS45 INS42 UPD45 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 UPD45 UPD42 INS42 INS42 INS32 UPD42 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL18 DEL8 DEL25 DEL54 DEL8 DEL70 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL45 DEL27 DEL42 DEL8 DEL25 DEL54 DEL8 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL42 DEL9 DEL42 DEL43 DEL42 DEL42 DEL42 DEL59 DEL60 DEL83 DEL39 DEL42 DEL42 DEL9 DEL32 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21
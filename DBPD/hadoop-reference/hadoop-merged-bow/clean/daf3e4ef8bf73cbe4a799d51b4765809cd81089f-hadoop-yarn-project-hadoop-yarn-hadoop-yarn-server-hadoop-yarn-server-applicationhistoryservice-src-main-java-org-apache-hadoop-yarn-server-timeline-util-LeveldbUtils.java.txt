YARN-3448. Added a rolling time-to-live LevelDB timeline store implementation. Contributed by Jonathan Eagles.

-import java.io.ByteArrayOutputStream;
-import java.nio.charset.Charset;
+import static java.nio.charset.StandardCharsets.UTF_8;
+  /** A string builder utility for building timeline server leveldb keys. */
+    /** Maximum subkeys that can be added to construct a key. */
+    /** Instantiate a new key build with the given maximum subkes.
+     * @param size maximum subkeys that can be added to this key builder
+     * @return a newly constructed key builder */
+    public static KeyBuilder newInstance(final int size) {
+      return new KeyBuilder(size);
+    }
+
-      return add(s.getBytes(Charset.forName("UTF-8")), true);
+      return add(s.getBytes(UTF_8), true);
-    public byte[] getBytes() throws IOException {
-      ByteArrayOutputStream baos = new ByteArrayOutputStream(length);
+    /** Builds a byte array without the final string delimiter. */
+    public byte[] getBytes() {
+      // check the last valid entry to see the final length
+      int bytesLength = length;
+      if (useSeparator[index - 1]) {
+        bytesLength = length - 1;
+      }
+      byte[] bytes = new byte[bytesLength];
+      int curPos = 0;
-        baos.write(b[i]);
+        System.arraycopy(b[i], 0, bytes, curPos, b[i].length);
+        curPos += b[i].length;
-          baos.write(0x0);
+          bytes[curPos++] = 0x0;
-      return baos.toByteArray();
+      return bytes;
-    public byte[] getBytesForLookup() throws IOException {
-      ByteArrayOutputStream baos = new ByteArrayOutputStream(length);
+    /** Builds a byte array including the final string delimiter. */
+    public byte[] getBytesForLookup() {
+      byte[] bytes = new byte[length];
+      int curPos = 0;
-        baos.write(b[i]);
+        System.arraycopy(b[i], 0, bytes, curPos, b[i].length);
+        curPos += b[i].length;
-          baos.write(0x0);
+          bytes[curPos++] = 0x0;
-      return baos.toByteArray();
+      return bytes;
-    public KeyParser(byte[] b, int offset) {
+    public KeyParser(final byte[] b, final int offset) {
+    /** Returns a string from the offset until the next string delimiter. */
-      String s = new String(b, offset, i, Charset.forName("UTF-8"));
+      String s = new String(b, offset, i, UTF_8);
+    /** Moves current position until after the next end of string marker. */
+    public void skipNextString() throws IOException {
+      if (offset >= b.length) {
+        throw new IOException("tried to read nonexistent string from byte array");
+      }
+      while (offset < b.length && b[offset] != 0x0) {
+        ++offset;
+      }
+      ++offset;
+    }
+
+    /** Read the next 8 bytes in the byte buffer as a long. */
-      long l = readReverseOrderedLong(b, offset);
+      long value = readReverseOrderedLong(b, offset);
-      return l;
+      return value;
+
+    /** Returns a copy of the remaining bytes. */
+    public byte[] getRemainingBytes() {
+      byte[] bytes = new byte[b.length - offset];
+      System.arraycopy(b, offset, bytes, 0, b.length - offset);
+      return bytes;
+    }

UPD40 INS29 INS31 INS31 INS31 INS65 INS29 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS29 INS29 INS29 INS83 INS39 INS42 MOV43 INS8 INS29 INS29 INS83 INS5 INS42 INS8 INS66 INS65 INS65 INS65 INS65 INS42 INS83 INS39 INS42 INS41 INS65 INS60 INS25 INS60 INS60 INS41 INS65 INS60 INS83 INS83 INS65 INS65 INS25 INS61 INS21 INS65 INS65 INS39 INS85 INS60 INS21 INS41 INS66 INS66 INS42 INS66 INS66 INS14 INS66 INS39 INS59 INS2 INS8 INS5 INS59 INS39 INS59 INS42 INS66 INS5 INS39 INS59 INS42 INS66 MOV43 INS66 INS27 INS8 INS27 INS8 INS38 INS66 UPD42 INS66 INS5 INS59 INS32 INS42 INS43 INS42 INS42 UPD42 MOV42 INS42 INS27 INS21 INS39 INS85 INS42 INS3 INS42 INS34 INS21 INS39 INS85 UPD42 INS3 INS42 INS34 INS21 INS42 INS40 INS53 INS27 INS27 INS21 INS42 UPD42 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS42 INS42 INS34 INS27 INS42 UPD42 MOV42 INS42 INS34 INS7 INS5 INS42 INS7 INS5 INS42 INS7 MOV43 INS42 INS14 INS42 INS40 INS2 INS34 INS38 INS5 INS27 INS40 INS42 INS42 INS27 INS39 INS85 INS42 INS42 MOV2 INS34 UPD42 UPD42 INS22 INS42 INS22 INS39 INS85 INS42 INS42 MOV2 INS34 UPD42 UPD42 INS22 INS42 INS22 INS43 INS45 INS42 INS42 INS42 INS39 INS85 INS40 INS42 INS42 INS34 INS42 INS42 INS2 INS42 INS2 INS42 INS7 INS2 INS42 INS2 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS2 INS34 MOV42 MOV42 INS42 INS42 INS2 INS34 INS42 INS37 INS42 INS37 INS42 INS42 DEL40 DEL26 DEL42 DEL45 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL42 DEL42 DEL32 DEL41 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL34 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32
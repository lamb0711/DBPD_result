YARN-6734. Ensure sub-application user is extracted & sent to timeline service (Rohith Sharma K S via Varun Saxena)

+import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.yarn.server.timelineservice.collector.TimelineCollectorContext;
+import org.apache.hadoop.yarn.server.timelineservice.storage.subapplication.SubApplicationColumn;
+import org.apache.hadoop.yarn.server.timelineservice.storage.subapplication.SubApplicationColumnPrefix;
+import org.apache.hadoop.yarn.server.timelineservice.storage.subapplication.SubApplicationRowKey;
+import org.apache.hadoop.yarn.server.timelineservice.storage.subapplication.SubApplicationTable;
+  private TypedBufferedMutator<SubApplicationTable> subApplicationTable;
+  private enum Tables {
+    APPLICATION_TABLE, ENTITY_TABLE, SUBAPPLICATION_TABLE
+  };
+
+    subApplicationTable =
+        new SubApplicationTable().getTableMutator(hbaseConf, conn);
-  public TimelineWriteResponse write(String clusterId, String userId,
-      String flowName, String flowVersion, long flowRunId, String appId,
-      TimelineEntities data) throws IOException {
+  public TimelineWriteResponse write(TimelineCollectorContext context,
+      TimelineEntities data, UserGroupInformation callerUgi)
+      throws IOException {
+
+    String clusterId = context.getClusterId();
+    String userId = context.getUserId();
+    String flowName = context.getFlowName();
+    String flowVersion = context.getFlowVersion();
+    long flowRunId = context.getFlowRunId();
+    String appId = context.getAppId();
+    String subApplicationUser = callerUgi.getShortUserName();
+
+        store(rowKey, te, flowVersion, Tables.APPLICATION_TABLE);
+        store(rowKey, te, flowVersion, Tables.ENTITY_TABLE);
-      storeInfo(rowKey, te, flowVersion, isApplication);
-      storeEvents(rowKey, te.getEvents(), isApplication);
-      storeConfig(rowKey, te.getConfigs(), isApplication);
-      storeMetrics(rowKey, te.getMetrics(), isApplication);
-      storeRelations(rowKey, te, isApplication);
+      if (!isApplication && !userId.equals(subApplicationUser)) {
+        SubApplicationRowKey subApplicationRowKey =
+            new SubApplicationRowKey(subApplicationUser, clusterId,
+                te.getType(), te.getIdPrefix(), te.getId(), userId);
+        rowKey = subApplicationRowKey.getRowKey();
+        store(rowKey, te, flowVersion, Tables.SUBAPPLICATION_TABLE);
+      }
-  private void storeRelations(byte[] rowKey, TimelineEntity te,
-      boolean isApplication) throws IOException {
-    if (isApplication) {
-      storeRelations(rowKey, te.getIsRelatedToEntities(),
-          ApplicationColumnPrefix.IS_RELATED_TO, applicationTable);
-      storeRelations(rowKey, te.getRelatesToEntities(),
-          ApplicationColumnPrefix.RELATES_TO, applicationTable);
-    } else {
-      storeRelations(rowKey, te.getIsRelatedToEntities(),
-          EntityColumnPrefix.IS_RELATED_TO, entityTable);
-      storeRelations(rowKey, te.getRelatesToEntities(),
-          EntityColumnPrefix.RELATES_TO, entityTable);
-    }
-  }
-
-      Map<String, Set<String>> connectedEntities,
-      ColumnPrefix<T> columnPrefix, TypedBufferedMutator<T> table)
-          throws IOException {
-    for (Map.Entry<String, Set<String>> connectedEntity : connectedEntities
-        .entrySet()) {
-      // id3?id4?id5
-      String compoundValue =
-          Separator.VALUES.joinEncoded(connectedEntity.getValue());
-      columnPrefix.store(rowKey, table,
-          stringKeyConverter.encode(connectedEntity.getKey()), null,
-          compoundValue);
+      Map<String, Set<String>> connectedEntities, ColumnPrefix<T> columnPrefix,
+      TypedBufferedMutator<T> table) throws IOException {
+    if (connectedEntities != null) {
+      for (Map.Entry<String, Set<String>> connectedEntity : connectedEntities
+          .entrySet()) {
+        // id3?id4?id5
+        String compoundValue =
+            Separator.VALUES.joinEncoded(connectedEntity.getValue());
+        columnPrefix.store(rowKey, table,
+            stringKeyConverter.encode(connectedEntity.getKey()), null,
+            compoundValue);
+      }
-  private void storeInfo(byte[] rowKey, TimelineEntity te, String flowVersion,
-      boolean isApplication) throws IOException {
-
-    if (isApplication) {
+  private void store(byte[] rowKey, TimelineEntity te,
+      String flowVersion,
+      Tables table) throws IOException {
+    switch (table) {
+    case APPLICATION_TABLE:
-      Map<String, Object> info = te.getInfo();
-      if (info != null) {
-        for (Map.Entry<String, Object> entry : info.entrySet()) {
-          ApplicationColumnPrefix.INFO.store(rowKey, applicationTable,
-              stringKeyConverter.encode(entry.getKey()), null,
-              entry.getValue());
-        }
-      }
-    } else {
+      storeInfo(rowKey, te.getInfo(), flowVersion, ApplicationColumnPrefix.INFO,
+          applicationTable);
+      storeMetrics(rowKey, te.getMetrics(), ApplicationColumnPrefix.METRIC,
+          applicationTable);
+      storeEvents(rowKey, te.getEvents(), ApplicationColumnPrefix.EVENT,
+          applicationTable);
+      storeConfig(rowKey, te.getConfigs(), ApplicationColumnPrefix.CONFIG,
+          applicationTable);
+      storeRelations(rowKey, te.getIsRelatedToEntities(),
+          ApplicationColumnPrefix.IS_RELATED_TO, applicationTable);
+      storeRelations(rowKey, te.getRelatesToEntities(),
+          ApplicationColumnPrefix.RELATES_TO, applicationTable);
+      break;
+    case ENTITY_TABLE:
-      Map<String, Object> info = te.getInfo();
-      if (info != null) {
-        for (Map.Entry<String, Object> entry : info.entrySet()) {
-          EntityColumnPrefix.INFO.store(rowKey, entityTable,
-              stringKeyConverter.encode(entry.getKey()), null,
-              entry.getValue());
-        }
+      storeInfo(rowKey, te.getInfo(), flowVersion, EntityColumnPrefix.INFO,
+          entityTable);
+      storeMetrics(rowKey, te.getMetrics(), EntityColumnPrefix.METRIC,
+          entityTable);
+      storeEvents(rowKey, te.getEvents(), EntityColumnPrefix.EVENT,
+          entityTable);
+      storeConfig(rowKey, te.getConfigs(), EntityColumnPrefix.CONFIG,
+          entityTable);
+      storeRelations(rowKey, te.getIsRelatedToEntities(),
+          EntityColumnPrefix.IS_RELATED_TO, entityTable);
+      storeRelations(rowKey, te.getRelatesToEntities(),
+          EntityColumnPrefix.RELATES_TO, entityTable);
+      break;
+    case SUBAPPLICATION_TABLE:
+      SubApplicationColumn.ID.store(rowKey, subApplicationTable, null,
+          te.getId());
+      SubApplicationColumn.TYPE.store(rowKey, subApplicationTable, null,
+          te.getType());
+      SubApplicationColumn.CREATED_TIME.store(rowKey, subApplicationTable, null,
+          te.getCreatedTime());
+      SubApplicationColumn.FLOW_VERSION.store(rowKey, subApplicationTable, null,
+          flowVersion);
+      storeInfo(rowKey, te.getInfo(), flowVersion,
+          SubApplicationColumnPrefix.INFO, subApplicationTable);
+      storeMetrics(rowKey, te.getMetrics(), SubApplicationColumnPrefix.METRIC,
+          subApplicationTable);
+      storeEvents(rowKey, te.getEvents(), SubApplicationColumnPrefix.EVENT,
+          subApplicationTable);
+      storeConfig(rowKey, te.getConfigs(), SubApplicationColumnPrefix.CONFIG,
+          subApplicationTable);
+      storeRelations(rowKey, te.getIsRelatedToEntities(),
+          SubApplicationColumnPrefix.IS_RELATED_TO, subApplicationTable);
+      storeRelations(rowKey, te.getRelatesToEntities(),
+          SubApplicationColumnPrefix.RELATES_TO, subApplicationTable);
+      break;
+    default:
+      LOG.info("Invalid table name provided.");
+      break;
+    }
+  }
+
+  /**
+   * stores the info information from {@linkplain TimelineEntity}.
+   */
+  private <T> void storeInfo(byte[] rowKey, Map<String, Object> info,
+      String flowVersion, ColumnPrefix<T> columnPrefix,
+      TypedBufferedMutator<T> table) throws IOException {
+    if (info != null) {
+      for (Map.Entry<String, Object> entry : info.entrySet()) {
+        columnPrefix.store(rowKey, table,
+            stringKeyConverter.encode(entry.getKey()), null, entry.getValue());
-  private void storeConfig(byte[] rowKey, Map<String, String> config,
-      boolean isApplication) throws IOException {
-    if (config == null) {
-      return;
-    }
-    for (Map.Entry<String, String> entry : config.entrySet()) {
-      byte[] configKey = stringKeyConverter.encode(entry.getKey());
-      if (isApplication) {
-        ApplicationColumnPrefix.CONFIG.store(rowKey, applicationTable,
-            configKey, null, entry.getValue());
-      } else {
-        EntityColumnPrefix.CONFIG.store(rowKey, entityTable, configKey,
-            null, entry.getValue());
+  private <T> void storeConfig(byte[] rowKey, Map<String, String> config,
+      ColumnPrefix<T> columnPrefix, TypedBufferedMutator<T> table)
+      throws IOException {
+    if (config != null) {
+      for (Map.Entry<String, String> entry : config.entrySet()) {
+        byte[] configKey = stringKeyConverter.encode(entry.getKey());
+        columnPrefix.store(rowKey, table, configKey, null, entry.getValue());
-  private void storeMetrics(byte[] rowKey, Set<TimelineMetric> metrics,
-      boolean isApplication) throws IOException {
+  private <T> void storeMetrics(byte[] rowKey, Set<TimelineMetric> metrics,
+      ColumnPrefix<T> columnPrefix, TypedBufferedMutator<T> table)
+      throws IOException {
-          if (isApplication) {
-            ApplicationColumnPrefix.METRIC.store(rowKey, applicationTable,
-                metricColumnQualifier, timestamp, timeseriesEntry.getValue());
-          } else {
-            EntityColumnPrefix.METRIC.store(rowKey, entityTable,
-                metricColumnQualifier, timestamp, timeseriesEntry.getValue());
-          }
+          columnPrefix.store(rowKey, table, metricColumnQualifier, timestamp,
+              timeseriesEntry.getValue());
-  private void storeEvents(byte[] rowKey, Set<TimelineEvent> events,
-      boolean isApplication) throws IOException {
+  private <T> void storeEvents(byte[] rowKey, Set<TimelineEvent> events,
+      ColumnPrefix<T> columnPrefix, TypedBufferedMutator<T> table)
+      throws IOException {
-              if (isApplication) {
-                ApplicationColumnPrefix.EVENT.store(rowKey, applicationTable,
-                    columnQualifierBytes, null, Separator.EMPTY_BYTES);
-              } else {
-                EntityColumnPrefix.EVENT.store(rowKey, entityTable,
-                    columnQualifierBytes, null, Separator.EMPTY_BYTES);
-              }
+              columnPrefix.store(rowKey, table, columnQualifierBytes, null,
+                  Separator.EMPTY_BYTES);
-                if (isApplication) {
-                  ApplicationColumnPrefix.EVENT.store(rowKey, applicationTable,
-                      columnQualifierBytes, null, info.getValue());
-                } else {
-                  EntityColumnPrefix.EVENT.store(rowKey, entityTable,
-                      columnQualifierBytes, null, info.getValue());
-                }
+                columnPrefix.store(rowKey, table, columnQualifierBytes, null,
+                    info.getValue());
+    subApplicationTable.flush();
+    if (subApplicationTable != null) {
+      subApplicationTable.close();
+    }
-

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS71 MOV44 INS31 INS83 INS74 INS59 INS83 INS42 INS72 INS72 INS72 INS8 UPD42 INS29 INS83 INS73 INS39 INS42 MOV44 INS44 MOV44 INS44 INS44 MOV43 MOV8 INS73 INS44 INS8 INS73 INS44 INS73 INS44 INS43 INS43 INS42 INS42 INS42 INS42 INS21 INS43 UPD42 INS43 INS42 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS25 INS43 INS42 INS50 INS65 INS42 MOV74 INS42 INS74 INS42 INS74 INS42 INS42 INS74 INS42 INS74 INS42 INS25 INS42 INS74 INS42 INS74 INS42 INS42 INS74 INS42 INS74 INS42 INS21 INS25 INS42 UPD42 MOV42 INS7 INS42 INS42 MOV43 INS59 MOV43 INS59 MOV43 INS59 MOV43 INS59 INS39 INS59 INS43 INS59 INS43 INS59 INS27 MOV8 INS42 INS42 INS49 MOV21 MOV21 MOV21 INS21 MOV21 MOV21 MOV21 MOV21 MOV21 INS10 INS49 MOV21 MOV21 MOV21 MOV21 INS21 INS21 INS21 INS21 MOV21 MOV21 INS10 INS49 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS10 INS49 INS21 INS10 INS66 INS65 INS66 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS27 MOV8 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS32 INS27 INS8 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS25 INS42 INS33 INS42 INS32 INS42 INS32 INS32 INS32 INS32 INS42 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS42 INS42 MOV32 INS42 INS40 INS42 INS40 UPD42 INS40 UPD42 INS40 UPD42 INS42 INS42 MOV32 INS42 INS40 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS32 INS40 INS42 UPD42 MOV42 INS42 INS32 INS40 UPD42 MOV42 UPD40 MOV40 MOV42 MOV42 UPD42 MOV42 INS33 INS32 INS40 UPD42 MOV42 INS42 UPD42 MOV42 INS33 MOV32 INS40 INS42 INS42 INS42 MOV33 INS32 INS40 INS42 INS42 INS42 INS33 INS42 INS42 UPD42 MOV42 INS32 INS42 INS40 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS45 INS32 INS43 INS21 INS21 INS38 INS38 INS60 INS21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS43 INS59 INS7 INS8 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 UPD42 MOV42 INS42 INS42 INS14 INS42 INS32 UPD42 UPD42 INS40 INS42 UPD42 INS42 UPD42 MOV32 MOV60 MOV21 INS43 INS42 INS42 INS32 INS32 INS32 INS42 UPD42 MOV42 INS42 MOV42 INS42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV21 INS42 UPD42 MOV21 INS42 UPD42 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL8 DEL8 DEL25 DEL8 DEL31 DEL39 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL32 DEL32 DEL32 DEL32 DEL21 DEL8 DEL70 DEL8 DEL25 DEL8 DEL25 DEL42 DEL59 DEL60 DEL40 DEL39 DEL42 DEL42 DEL33 DEL27 DEL41 DEL8 DEL25 DEL40 DEL42 DEL40 DEL42 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL8 DEL25 DEL39 DEL42 DEL40 DEL42 DEL40 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL8 DEL25 DEL8 DEL39 DEL42 DEL40 DEL42 DEL40 DEL42 DEL42 DEL42 DEL42 DEL33 DEL40 DEL32 DEL21 DEL8 DEL8 DEL25 DEL40 DEL42 DEL40 DEL42 DEL42 DEL42 DEL42 DEL33 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL8 DEL25
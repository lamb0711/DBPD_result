HDDS-383. Ozone Client should discard preallocated blocks from closed containers.  Contributed by Shashikant Banerjee

+import java.util.ListIterator;
-  private List<OmKeyLocationInfo> locationInfoList;
-    locationInfoList = null;
-  @VisibleForTesting
-  public long getOpenID() {
-    return openID;
+  public List<OmKeyLocationInfo> getLocationInfoList() {
+    List<OmKeyLocationInfo> locationInfoList = new ArrayList<>();
+    for (ChunkOutputStreamEntry streamEntry : streamEntries) {
+      OmKeyLocationInfo info =
+          new OmKeyLocationInfo.Builder().setBlockID(streamEntry.blockID)
+              .setShouldCreateContainer(false)
+              .setLength(streamEntry.currentPosition).setOffset(0).build();
+      locationInfoList.add(info);
+    }
+    return locationInfoList;
-    this.locationInfoList = new ArrayList<>();
-    // reset the original length to zero here. It will be updated as and when
-    // the data gets written.
-    subKeyInfo.setLength(0);
-    locationInfoList.add(subKeyInfo);
-  }
-
-  private void incrementBlockLength(int index, long length) {
-    if (locationInfoList != null) {
-      OmKeyLocationInfo locationInfo = locationInfoList.get(index);
-      long originalLength = locationInfo.getLength();
-      locationInfo.setLength(originalLength + length);
-    }
-      incrementBlockLength(currentStreamIndex, writeLen);
-
-    // TODO : At this point of time, we also need to allocate new blocks
-    // from a different container and may need to nullify
-    // all the remaining pre-allocated blocks in case they were
-    // pre-allocated on the same container which got closed now.This needs
-    // caching the closed container list on the client itself.
+   * Discards the subsequent pre allocated blocks and removes the streamEntries
+   * from the streamEntries list for the container which is closed.
+   * @param containerID id of the closed container
+   */
+  private void discardPreallocatedBlocks(long containerID) {
+    // currentStreamIndex < streamEntries.size() signifies that, there are still
+    // pre allocated blocks available.
+    if (currentStreamIndex < streamEntries.size()) {
+      ListIterator<ChunkOutputStreamEntry> streamEntryIterator =
+          streamEntries.listIterator(currentStreamIndex);
+      while (streamEntryIterator.hasNext()) {
+        if (streamEntryIterator.next().blockID.getContainerID()
+            == containerID) {
+          streamEntryIterator.remove();
+        }
+      }
+    }
+  }
+
+  /**
+   * It might be possible that the blocks pre allocated might never get written
+   * while the stream gets closed normally. In such cases, it would be a good
+   * idea to trim down the locationInfoList by removing the unused blocks if any
+   * so as only the used block info gets updated on OzoneManager during close.
+   */
+  private void removeEmptyBlocks() {
+    if (currentStreamIndex < streamEntries.size()) {
+      ListIterator<ChunkOutputStreamEntry> streamEntryIterator =
+          streamEntries.listIterator(currentStreamIndex);
+      while (streamEntryIterator.hasNext()) {
+        if (streamEntryIterator.next().currentPosition == 0) {
+          streamEntryIterator.remove();
+        }
+      }
+    }
+  }
+  /**
-      locationInfoList.get(streamIndex).setLength(committedLength);
+      streamEntry.currentPosition = committedLength;
-      locationInfoList.remove(streamIndex);
+    // discard subsequent pre allocated blocks from the streamEntries list
+    // from the closed container
+    discardPreallocatedBlocks(streamEntry.blockID.getContainerID());
-    return locationInfoList.parallelStream().mapToLong(e -> e.getLength())
+    return streamEntries.parallelStream().mapToLong(e -> e.currentPosition)
-      Preconditions.checkState(streamEntries.size() == locationInfoList.size());
+      removeEmptyBlocks();
-      keyArgs.setLocationInfoList(locationInfoList);
+      keyArgs.setLocationInfoList(getLocationInfoList());
-      locationInfoList = null;

INS26 MOV31 INS40 INS31 INS31 INS83 MOV74 INS42 INS8 INS29 UPD42 INS29 INS83 INS39 INS42 INS8 INS60 INS70 INS41 INS65 INS65 UPD42 INS65 INS25 INS21 INS74 INS59 INS44 INS42 INS8 INS42 INS66 INS66 INS42 INS66 UPD27 INS66 INS66 INS66 INS66 UPD27 MOV27 INS8 INS32 INS43 INS43 MOV42 MOV14 INS43 INS42 INS60 INS21 UPD42 INS32 INS61 INS42 INS60 INS61 INS42 INS32 INS42 INS42 INS42 MOV43 INS59 INS32 INS42 INS42 INS74 INS32 INS8 INS74 INS59 INS32 INS8 INS7 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS43 UPD42 INS42 INS42 INS25 INS43 INS43 INS42 INS32 INS42 INS42 INS25 INS40 INS42 UPD42 INS40 UPD42 INS32 INS32 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS27 INS8 UPD42 MOV42 INS32 INS42 INS34 INS32 INS42 MOV21 INS22 INS34 INS21 INS32 INS42 INS40 INS22 UPD42 MOV42 INS32 INS42 INS32 INS32 INS42 INS9 INS32 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS40 INS42 INS42 INS43 INS40 DEL83 DEL59 DEL23 DEL42 DEL33 DEL7 DEL21 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL44 DEL33 DEL42 DEL42 DEL42 DEL27 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL33 DEL7 DEL21
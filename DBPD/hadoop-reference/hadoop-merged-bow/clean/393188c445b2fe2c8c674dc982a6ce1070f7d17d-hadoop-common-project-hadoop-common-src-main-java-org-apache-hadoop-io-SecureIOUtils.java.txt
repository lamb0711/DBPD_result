Merge r1477868 through r1479732 from trunk.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1479733 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.FileDescriptor;
+import java.io.RandomAccessFile;
+import org.apache.hadoop.fs.FSDataInputStream;
-import org.apache.hadoop.io.nativeio.Errno;
-import org.apache.hadoop.io.nativeio.NativeIOException;
+import com.google.common.annotations.VisibleForTesting;
+
+   * Open the given File for random read access, verifying the expected user/
+   * group constraints if security is enabled.
+   * 
+   * Note that this function provides no additional security checks if hadoop
+   * security is disabled, since doing the checks would be too expensive when
+   * native libraries are not available.
+   * 
+   * @param f file that we are trying to open
+   * @param mode mode in which we want to open the random access file
+   * @param expectedOwner the expected user owner for the file
+   * @param expectedGroup the expected group owner for the file
+   * @throws IOException if an IO error occurred or if the user/group does
+   * not match when security is enabled.
+   */
+  public static RandomAccessFile openForRandomRead(File f,
+      String mode, String expectedOwner, String expectedGroup)
+      throws IOException {
+    if (!UserGroupInformation.isSecurityEnabled()) {
+      return new RandomAccessFile(f, mode);
+    }
+    return forceSecureOpenForRandomRead(f, mode, expectedOwner, expectedGroup);
+  }
+
+  /**
+   * Same as openForRandomRead except that it will run even if security is off.
+   * This is used by unit tests.
+   */
+  @VisibleForTesting
+  protected static RandomAccessFile forceSecureOpenForRandomRead(File f,
+      String mode, String expectedOwner, String expectedGroup)
+      throws IOException {
+    RandomAccessFile raf = new RandomAccessFile(f, mode);
+    boolean success = false;
+    try {
+      Stat stat = NativeIO.POSIX.getFstat(raf.getFD());
+      checkStat(f, stat.getOwner(), stat.getGroup(), expectedOwner,
+          expectedGroup);
+      success = true;
+      return raf;
+    } finally {
+      if (!success) {
+        raf.close();
+      }
+    }
+  }
+
+  /**
+   * Opens the {@link FSDataInputStream} on the requested file on local file
+   * system, verifying the expected user/group constraints if security is
+   * enabled.
+   * @param file absolute path of the file
+   * @param expectedOwner the expected user owner for the file
+   * @param expectedGroup the expected group owner for the file
+   * @throws IOException if an IO Error occurred or the user/group does not
+   * match if security is enabled
+   */
+  public static FSDataInputStream openFSDataInputStream(File file,
+      String expectedOwner, String expectedGroup) throws IOException {
+    if (!UserGroupInformation.isSecurityEnabled()) {
+      return rawFilesystem.open(new Path(file.getAbsolutePath()));
+    }
+    return forceSecureOpenFSDataInputStream(file, expectedOwner, expectedGroup);
+  }
+
+  /**
+   * Same as openFSDataInputStream except that it will run even if security is
+   * off. This is used by unit tests.
+   */
+  @VisibleForTesting
+  protected static FSDataInputStream forceSecureOpenFSDataInputStream(
+      File file,
+      String expectedOwner, String expectedGroup) throws IOException {
+    final FSDataInputStream in =
+        rawFilesystem.open(new Path(file.getAbsolutePath()));
+    boolean success = false;
+    try {
+      Stat stat = NativeIO.POSIX.getFstat(in.getFileDescriptor());
+      checkStat(file, stat.getOwner(), stat.getGroup(), expectedOwner,
+          expectedGroup);
+      success = true;
+      return in;
+    } finally {
+      if (!success) {
+        in.close();
+      }
+    }
+  }
+
+  /**
-  static FileInputStream forceSecureOpenForRead(File f, String expectedOwner,
+  @VisibleForTesting
+  protected static FileInputStream forceSecureOpenForRead(File f, String expectedOwner,

MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS78 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS78 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS78 INS83 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS41 INS65 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS54 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS41 INS65 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS54 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS38 INS8 INS32 INS66 INS66 INS42 INS42 INS42 INS42 INS43 INS59 INS39 INS59 INS8 INS8 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS38 INS8 INS32 INS66 INS66 INS42 INS42 INS42 INS83 INS43 INS59 INS39 INS59 INS8 INS8 INS32 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS9 INS60 INS21 INS21 INS41 INS25 INS42 INS32 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS9 INS60 INS21 INS21 INS41 INS25 INS42 INS42 INS14 INS43 INS42 INS42 INS43 INS59 INS32 INS7 INS42 INS38 INS8 INS42 INS42 INS32 INS42 INS42 INS14 INS43 INS59 INS32 INS7 INS42 INS38 INS8 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS9 INS42 INS21 INS42 INS42 INS14 INS43 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS9 INS42 INS21 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS32 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42
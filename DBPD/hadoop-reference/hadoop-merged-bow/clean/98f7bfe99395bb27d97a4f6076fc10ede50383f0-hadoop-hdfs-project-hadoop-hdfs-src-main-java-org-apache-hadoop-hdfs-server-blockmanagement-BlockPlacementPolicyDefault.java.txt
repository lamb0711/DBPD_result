Merge branch 'HDFS-6584' into trunk

-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.TreeSet;
+import java.util.*;
+import org.apache.hadoop.hdfs.BlockStoragePolicy;
-  protected BlockPlacementPolicyDefault(Configuration conf, FSClusterStats stats,
-                           NetworkTopology clusterMap, 
-                           Host2NodesMap host2datanodeMap) {
-    initialize(conf, stats, clusterMap, host2datanodeMap);
-  }
-
-                                    StorageType storageType) {
+                                    final BlockStoragePolicy storagePolicy) {
-        excludedNodes, blocksize, storageType);
+        excludedNodes, blocksize, storagePolicy);
-      StorageType storageType) {
+      BlockStoragePolicy storagePolicy) {
-            excludedNodes, blocksize, storageType);
+            excludedNodes, blocksize, storagePolicy);
+      final List<StorageType> requiredStorageTypes = storagePolicy
+          .chooseStorageTypes((short)numOfReplicas);
+      final EnumMap<StorageType, Integer> storageTypes =
+          getRequiredStorageTypes(requiredStorageTypes);
-            results, avoidStaleNodes, storageType, false);
+            results, avoidStaleNodes, storageTypes, false);
-                false, favoriteAndExcludedNodes, blocksize, storageType);
+                false, favoriteAndExcludedNodes, blocksize, storagePolicy);
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Failed to choose with favored nodes (=" + favoredNodes
+            + "), disregard favored nodes hint and retry.", nr);
+      }
-          excludedNodes, blocksize, storageType);
+          excludedNodes, blocksize, storagePolicy);
-                                    StorageType storageType) {
+                                    final BlockStoragePolicy storagePolicy) {
-    Node localNode = chooseTarget(numOfReplicas, writer,
-        excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes, storageType);
+    final Node localNode = chooseTarget(numOfReplicas, writer, excludedNodes,
+        blocksize, maxNodesPerRack, results, avoidStaleNodes, storagePolicy,
+        EnumSet.noneOf(StorageType.class), results.isEmpty());
-    
+
+  private EnumMap<StorageType, Integer> getRequiredStorageTypes(
+      List<StorageType> types) {
+    EnumMap<StorageType, Integer> map = new EnumMap<StorageType,
+        Integer>(StorageType.class);
+    for (StorageType type : types) {
+      if (!map.containsKey(type)) {
+        map.put(type, 1);
+      } else {
+        int num = map.get(type);
+        map.put(type, num + 1);
+      }
+    }
+    return map;
+  }
+
-                                          Node writer,
-                                          Set<Node> excludedNodes,
-                                          long blocksize,
-                                          int maxNodesPerRack,
-                                          List<DatanodeStorageInfo> results,
-                                          final boolean avoidStaleNodes,
-                                          StorageType storageType) {
+                            Node writer,
+                            final Set<Node> excludedNodes,
+                            final long blocksize,
+                            final int maxNodesPerRack,
+                            final List<DatanodeStorageInfo> results,
+                            final boolean avoidStaleNodes,
+                            final BlockStoragePolicy storagePolicy,
+                            final EnumSet<StorageType> unavailableStorages,
+                            final boolean newBlock) {
-    int totalReplicasExpected = numOfReplicas + results.size();
-      
-    int numOfResults = results.size();
-    boolean newBlock = (numOfResults==0);
+    final int numOfResults = results.size();
+    final int totalReplicasExpected = numOfReplicas + numOfResults;
-    final Set<Node> oldExcludedNodes = avoidStaleNodes ? 
-        new HashSet<Node>(excludedNodes) : null;
+    final Set<Node> oldExcludedNodes = new HashSet<Node>(excludedNodes);
+
+    // choose storage types; use fallbacks for unavailable storages
+    final List<StorageType> requiredStorageTypes = storagePolicy
+        .chooseStorageTypes((short) totalReplicasExpected,
+            DatanodeStorageInfo.toStorageTypes(results),
+            unavailableStorages, newBlock);
+    final EnumMap<StorageType, Integer> storageTypes =
+        getRequiredStorageTypes(requiredStorageTypes);
+    if (LOG.isTraceEnabled()) {
+      LOG.trace("storageTypes=" + storageTypes);
+    }
+
+      if ((numOfReplicas = requiredStorageTypes.size()) == 0) {
+        throw new NotEnoughReplicasException(
+            "All required storage types are unavailable: "
+            + " unavailableStorages=" + unavailableStorages
+            + ", storagePolicy=" + storagePolicy);
+      }
+
-            maxNodesPerRack, results, avoidStaleNodes, storageType, true)
+            maxNodesPerRack, results, avoidStaleNodes, storageTypes, true)
-            results, avoidStaleNodes, storageType);
+            results, avoidStaleNodes, storageTypes);
-              results, avoidStaleNodes, storageType);
+              results, avoidStaleNodes, storageTypes);
-              results, avoidStaleNodes, storageType);
+              results, avoidStaleNodes, storageTypes);
-              results, avoidStaleNodes, storageType);
+              results, avoidStaleNodes, storageTypes);
-          maxNodesPerRack, results, avoidStaleNodes, storageType);
+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);
-          + totalReplicasExpected + ".";
+          + totalReplicasExpected
+          + " (unavailableStorages=" + unavailableStorages
+          + ", storagePolicy=" + storagePolicy
+          + ", newBlock=" + newBlock + ")";
+
-            maxNodesPerRack, results, false, storageType);
+            maxNodesPerRack, results, false, storagePolicy, unavailableStorages,
+            newBlock);
+      }
+
+      boolean retry = false;
+      // simply add all the remaining types into unavailableStorages and give
+      // another try. No best effort is guaranteed here.
+      for (StorageType type : storageTypes.keySet()) {
+        if (!unavailableStorages.contains(type)) {
+          unavailableStorages.add(type);
+          retry = true;
+        }
+      }
+      if (retry) {
+        for (DatanodeStorageInfo resultStorage : results) {
+          addToExcludedNodes(resultStorage.getDatanodeDescriptor(),
+              oldExcludedNodes);
+        }
+        numOfReplicas = totalReplicasExpected - results.size();
+        return chooseTarget(numOfReplicas, writer, oldExcludedNodes, blocksize,
+            maxNodesPerRack, results, false, storagePolicy, unavailableStorages,
+            newBlock);
-                                             Set<Node> excludedNodes,
-                                             long blocksize,
-                                             int maxNodesPerRack,
-                                             List<DatanodeStorageInfo> results,
-                                             boolean avoidStaleNodes,
-                                             StorageType storageType,
-                                             boolean fallbackToLocalRack)
+      Set<Node> excludedNodes, long blocksize, int maxNodesPerRack,
+      List<DatanodeStorageInfo> results, boolean avoidStaleNodes,
+      EnumMap<StorageType, Integer> storageTypes, boolean fallbackToLocalRack)
-          maxNodesPerRack, results, avoidStaleNodes, storageType);
+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);
-        for(DatanodeStorageInfo localStorage : DFSUtil.shuffle(
-            localDatanode.getStorageInfos())) {
-          if (addIfIsGoodTarget(localStorage, excludedNodes, blocksize,
-              maxNodesPerRack, false, results, avoidStaleNodes, storageType) >= 0) {
-            return localStorage;
+        for (Iterator<Map.Entry<StorageType, Integer>> iter = storageTypes
+            .entrySet().iterator(); iter.hasNext(); ) {
+          Map.Entry<StorageType, Integer> entry = iter.next();
+          for (DatanodeStorageInfo localStorage : DFSUtil.shuffle(
+              localDatanode.getStorageInfos())) {
+            StorageType type = entry.getKey();
+            if (addIfIsGoodTarget(localStorage, excludedNodes, blocksize,
+                maxNodesPerRack, false, results, avoidStaleNodes, type) >= 0) {
+              int num = entry.getValue();
+              if (num == 1) {
+                iter.remove();
+              } else {
+                entry.setValue(num - 1);
+              }
+              return localStorage;
+            }
-        maxNodesPerRack, results, avoidStaleNodes, storageType);
+        maxNodesPerRack, results, avoidStaleNodes, storageTypes);
-                                             Set<Node> excludedNodes,
-                                             long blocksize,
-                                             int maxNodesPerRack,
-                                             List<DatanodeStorageInfo> results,
-                                             boolean avoidStaleNodes,
-                                             StorageType storageType)
+                                                Set<Node> excludedNodes,
+                                                long blocksize,
+                                                int maxNodesPerRack,
+                                                List<DatanodeStorageInfo> results,
+                                                boolean avoidStaleNodes,
+                                                EnumMap<StorageType, Integer> storageTypes)
-          maxNodesPerRack, results, avoidStaleNodes, storageType);
+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);
+    final String localRack = localMachine.getNetworkLocation();
-    // choose one from the local rack
-      return chooseRandom(localMachine.getNetworkLocation(), excludedNodes,
-          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageType);
-    } catch (NotEnoughReplicasException e1) {
-      // find the second replica
-      DatanodeDescriptor newLocal=null;
+      // choose one from the local rack
+      return chooseRandom(localRack, excludedNodes,
+          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);
+    } catch (NotEnoughReplicasException e) {
+      // find the next replica and retry with its rack
-          newLocal = nextNode;
-          break;
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Failed to choose from local rack (location = " + localRack
+                + "), retry with the rack of the next replica (location = "
+                + nextNode.getNetworkLocation() + ")", e);
+          }
+          return chooseFromNextRack(nextNode, excludedNodes, blocksize,
+              maxNodesPerRack, results, avoidStaleNodes, storageTypes);
-      if (newLocal != null) {
-        try {
-          return chooseRandom(newLocal.getNetworkLocation(), excludedNodes,
-              blocksize, maxNodesPerRack, results, avoidStaleNodes, storageType);
-        } catch(NotEnoughReplicasException e2) {
-          //otherwise randomly choose one from the network
-          return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,
-              maxNodesPerRack, results, avoidStaleNodes, storageType);
-        }
-      } else {
-        //otherwise randomly choose one from the network
-        return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,
-            maxNodesPerRack, results, avoidStaleNodes, storageType);
+
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Failed to choose from local rack (location = " + localRack
+            + "); the second replica is not found, retry choosing ramdomly", e);
+      //the second replica is not found, randomly choose one from the network
+      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,
+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);
-    
+
+  private DatanodeStorageInfo chooseFromNextRack(Node next,
+      Set<Node> excludedNodes,
+      long blocksize,
+      int maxNodesPerRack,
+      List<DatanodeStorageInfo> results,
+      boolean avoidStaleNodes,
+      EnumMap<StorageType, Integer> storageTypes) throws NotEnoughReplicasException {
+    final String nextRack = next.getNetworkLocation();
+    try {
+      return chooseRandom(nextRack, excludedNodes, blocksize, maxNodesPerRack,
+          results, avoidStaleNodes, storageTypes);
+    } catch(NotEnoughReplicasException e) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Failed to choose from the next rack (location = " + nextRack
+            + "), retry choosing ramdomly", e);
+      }
+      //otherwise randomly choose one from the network
+      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,
+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);
+    }
+  }
+
-                                StorageType storageType)
+                                EnumMap<StorageType, Integer> storageTypes)
-          avoidStaleNodes, storageType);
+          avoidStaleNodes, storageTypes);
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Failed to choose remote rack (location = ~"
+            + localMachine.getNetworkLocation() + "), fallback to local rack", e);
+      }
-                   maxReplicasPerRack, results, avoidStaleNodes, storageType);
+                   maxReplicasPerRack, results, avoidStaleNodes, storageTypes);
-      StorageType storageType)
+      EnumMap<StorageType, Integer> storageTypes)
-        results, avoidStaleNodes, storageType);
+        results, avoidStaleNodes, storageTypes);
-                            StorageType storageType)
-                                throws NotEnoughReplicasException {
+                            EnumMap<StorageType, Integer> storageTypes)
+                            throws NotEnoughReplicasException {
+        if (LOG.isDebugEnabled()) {
+          builder.append("\nNode ").append(NodeBase.getPath(chosenNode)).append(" [");
+        }
-        int i;
-        for(i = 0; i < storages.length; i++) {
-          final int newExcludedNodes = addIfIsGoodTarget(storages[i],
-              excludedNodes, blocksize, maxNodesPerRack, considerLoad, results,
-              avoidStaleNodes, storageType);
-          if (newExcludedNodes >= 0) {
-            numOfReplicas--;
-            if (firstChosen == null) {
-              firstChosen = storages[i];
+        int i = 0;
+        boolean search = true;
+        for (Iterator<Map.Entry<StorageType, Integer>> iter = storageTypes
+            .entrySet().iterator(); search && iter.hasNext(); ) {
+          Map.Entry<StorageType, Integer> entry = iter.next();
+          for (i = 0; i < storages.length; i++) {
+            StorageType type = entry.getKey();
+            final int newExcludedNodes = addIfIsGoodTarget(storages[i],
+                excludedNodes, blocksize, maxNodesPerRack, considerLoad, results,
+                avoidStaleNodes, type);
+            if (newExcludedNodes >= 0) {
+              numOfReplicas--;
+              if (firstChosen == null) {
+                firstChosen = storages[i];
+              }
+              numOfAvailableNodes -= newExcludedNodes;
+              int num = entry.getValue();
+              if (num == 1) {
+                iter.remove();
+              } else {
+                entry.setValue(num - 1);
+              }
+              search = false;
+              break;
-            numOfAvailableNodes -= newExcludedNodes;
-            break;
+        if (LOG.isDebugEnabled()) {
+          builder.append("\n]");
+        }
-          detail = builder.append("]").toString();
+          detail = builder.toString();
-        } else detail = "";
+        } else {
+          detail = "";
+        }
-      final DatanodeDescriptor node = storage.getDatanodeDescriptor();
-          .append(node).append(": ")
-          .append("Storage ").append(storage)
-          .append("at node ").append(NodeBase.getPath(node))
-          .append(" is not chosen because ")
-          .append(reason);
+          .append("\n  Storage ").append(storage)
+          .append(" is not chosen since ").append(reason).append(".");
-                               StorageType storageType) {
-    if (storage.getStorageType() != storageType) {
-      logNodeIsNotChosen(storage,
-          "storage types do not match, where the expected storage type is "
-              + storageType);
+                               StorageType requiredStorageType) {
+    if (storage.getStorageType() != requiredStorageType) {
+      logNodeIsNotChosen(storage, "storage types do not match,"
+          + " where the required storage type is " + requiredStorageType);
-    final long scheduledSize = blockSize * node.getBlocksScheduled();
-    if (requiredSize > storage.getRemaining() - scheduledSize) {
-      logNodeIsNotChosen(storage, "the node does not have enough space ");
+    final long scheduledSize = blockSize * node.getBlocksScheduled(storage.getStorageType());
+    final long remaining = node.getRemaining(storage.getStorageType());
+    if (requiredSize > remaining - scheduledSize) {
+      logNodeIsNotChosen(storage, "the node does not have enough "
+          + storage.getStorageType() + " space"
+          + " (required=" + requiredSize
+          + ", scheduled=" + scheduledSize
+          + ", remaining=" + remaining + ")");
-        logNodeIsNotChosen(storage,
-            "the node is too busy (load:"+nodeLoad+" > "+maxLoad+") ");
+        logNodeIsNotChosen(storage, "the node is too busy (load: " + nodeLoad
+            + " > " + maxLoad + ") ");
-    
+
-      Collection<DatanodeStorageInfo> second) {
+      Collection<DatanodeStorageInfo> second,
+      final List<StorageType> excessTypes) {
+      if (!excessTypes.contains(storage.getStorageType())) {
+        continue;
+      }
+
-    return oldestHeartbeatStorage != null? oldestHeartbeatStorage
-        : minSpaceStorage;
+    final DatanodeStorageInfo storage;
+    if (oldestHeartbeatStorage != null) {
+      storage = oldestHeartbeatStorage;
+    } else if (minSpaceStorage != null) {
+      storage = minSpaceStorage;
+    } else {
+      return null;
+    }
+    excessTypes.remove(storage.getStorageType());
+    return storage;

MOV26 MOV31 UPD40 UPD40 INS31 INS31 UPD83 INS74 INS42 INS8 INS44 INS44 INS44 INS44 INS44 INS44 INS44 MOV60 MOV29 MOV83 MOV43 MOV42 MOV44 MOV44 MOV44 MOV44 MOV44 MOV44 MOV44 MOV43 INS8 INS83 INS43 INS42 INS44 MOV44 MOV44 MOV44 MOV44 INS44 INS44 MOV43 INS8 INS44 MOV44 INS44 INS83 INS43 UPD42 INS43 UPD42 INS83 INS43 UPD42 INS43 MOV43 INS43 INS74 UPD42 INS60 INS70 INS41 INS83 INS74 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS83 INS74 INS42 INS83 INS43 INS42 INS83 INS74 INS42 INS83 INS39 INS42 INS60 INS60 INS25 INS74 UPD42 INS74 UPD42 MOV25 INS60 INS54 INS42 MOV43 UPD42 MOV42 INS39 INS42 INS74 INS42 INS60 INS54 INS74 UPD42 INS74 UPD42 INS74 INS42 UPD42 INS60 INS83 INS74 INS42 INS60 INS25 INS21 INS41 INS42 INS42 INS42 INS83 INS43 INS42 UPD42 MOV42 INS43 INS43 INS74 INS59 MOV44 INS42 INS8 INS42 INS43 INS43 INS43 INS43 INS42 INS43 INS43 INS83 INS83 INS83 INS74 INS59 INS83 INS74 INS59 INS32 INS8 INS43 INS43 INS43 MOV27 INS43 MOV43 INS43 MOV27 INS83 INS43 INS59 MOV8 INS12 INS43 INS43 INS43 INS83 INS43 INS59 INS8 INS12 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS83 INS39 INS59 INS43 INS43 INS83 INS43 INS59 MOV27 INS8 INS25 INS32 INS42 UPD42 INS60 INS60 INS42 UPD42 MOV42 INS42 INS43 INS43 INS43 INS42 INS14 UPD42 INS25 INS42 INS42 INS42 INS42 INS42 INS42 MOV14 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS21 INS25 INS42 INS42 INS42 UPD42 UPD42 MOV42 INS42 INS42 INS42 MOV32 MOV44 INS8 INS42 INS42 INS42 INS42 INS42 INS32 MOV41 INS44 INS8 INS42 MOV42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 MOV41 INS42 INS32 INS42 INS42 INS25 INS42 INS42 INS21 INS27 INS8 INS8 INS42 INS42 INS32 INS83 INS74 INS59 INS83 INS74 INS59 INS25 UPD42 INS32 INS32 UPD42 MOV42 INS42 INS42 INS74 INS57 INS38 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS11 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS8 INS60 INS70 INS25 INS8 UPD42 MOV70 INS25 MOV41 INS42 INS42 INS43 INS42 INS25 MOV41 INS25 INS8 MOV32 INS42 INS42 INS32 INS42 INS38 INS8 INS7 INS42 INS33 INS21 INS41 INS42 INS42 INS43 INS43 INS42 INS32 INS43 MOV43 INS43 INS42 INS32 INS32 INS8 INS42 INS42 INS57 INS42 INS42 INS43 INS43 INS43 MOV43 INS32 INS21 INS60 MOV21 INS39 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS36 INS34 INS53 MOV25 MOV25 UPD42 INS39 INS59 INS44 INS32 INS8 INS42 INS8 UPD42 INS24 UPD42 INS42 UPD42 INS8 INS32 INS8 INS42 UPD42 INS42 INS32 INS8 UPD42 INS32 INS8 INS25 MOV21 MOV60 INS60 INS60 INS24 INS25 MOV21 UPD45 INS32 INS42 INS42 INS27 MOV41 INS32 INS18 INS42 INS42 INS7 INS33 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS21 UPD42 MOV43 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS32 INS39 INS59 INS45 UPD42 MOV42 INS7 INS14 INS42 INS9 MOV43 INS42 INS42 INS42 INS25 INS70 INS21 INS41 INS58 INS32 INS8 MOV60 INS25 INS42 INS42 INS21 INS40 UPD42 INS42 INS42 INS21 UPD42 INS42 INS42 INS21 UPD42 INS32 INS8 INS39 INS59 INS39 INS59 INS58 INS27 MOV8 INS32 INS8 INS8 UPD42 UPD45 INS45 UPD42 INS42 INS42 INS45 INS32 INS45 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS32 INS42 INS42 UPD42 INS39 INS42 INS32 INS42 INS42 INS42 INS34 INS42 INS32 UPD42 UPD42 UPD42 INS27 INS42 INS32 INS43 INS27 UPD42 INS45 INS42 INS45 INS42 INS45 INS42 UPD45 INS42 INS38 INS8 INS44 INS42 INS8 INS7 INS32 INS74 INS59 INS42 INS42 INS60 MOV70 MOV27 INS8 INS32 INS32 INS32 INS42 INS42 INS21 INS42 INS34 INS42 INS9 INS74 INS59 INS42 INS32 INS42 INS42 INS21 MOV21 UPD45 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS27 INS42 INS45 INS42 UPD42 INS42 INS42 INS32 INS21 INS21 INS43 INS42 INS21 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS43 INS74 INS42 INS32 INS74 INS59 MOV25 INS41 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS32 INS43 INS74 INS42 INS32 INS42 INS42 INS74 INS32 INS42 UPD45 INS45 INS42 INS45 INS45 INS45 UPD42 UPD42 INS42 INS42 INS42 INS32 INS7 INS42 INS32 INS42 INS32 INS42 INS43 INS43 INS43 INS32 INS42 INS43 INS43 INS43 INS42 INS32 INS60 INS32 INS32 INS45 UPD42 MOV42 INS45 INS45 INS42 INS45 INS45 INS32 INS45 INS32 INS42 INS45 INS42 INS43 INS43 INS43 INS32 INS42 INS43 INS43 INS43 INS42 INS32 INS60 INS42 INS42 INS45 INS45 UPD42 UPD42 INS42 INS42 INS42 INS42 INS9 INS42 INS32 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 MOV43 INS59 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 MOV43 INS59 MOV42 INS42 INS42 INS42 INS42 INS32 INS60 INS25 MOV41 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS60 INS25 INS21 INS42 INS42 UPD42 INS39 INS59 INS27 MOV8 INS8 INS42 INS42 INS27 INS42 INS42 INS42 UPD42 INS39 INS59 INS27 INS8 INS8 INS7 INS42 INS32 INS42 INS34 INS21 INS21 INS45 INS42 INS45 INS32 INS45 INS42 INS32 INS42 INS34 INS21 INS21 INS42 INS9 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS27 INS42 INS34 INS42 INS34 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL8 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL27 DEL36 DEL59 DEL60 DEL42 DEL33 DEL16 DEL8 DEL42 DEL42 DEL7 DEL10 DEL8 DEL42 DEL42 DEL32 DEL40 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL33 DEL27 DEL8 DEL44 DEL8 DEL12 DEL54 DEL8 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL31 DEL39 DEL42 DEL42 DEL45 DEL32 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL45 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL44 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL16 DEL41
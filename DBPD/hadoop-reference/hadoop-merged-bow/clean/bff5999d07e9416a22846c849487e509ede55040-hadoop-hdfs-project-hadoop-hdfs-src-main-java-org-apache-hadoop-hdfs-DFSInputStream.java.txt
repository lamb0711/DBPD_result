HDFS-8703. Merge refactor of DFSInputStream from ErasureCoding branch (Contributed by Vinayakumar B)

+import com.google.common.base.Preconditions;
-  private final DFSClient dfsClient;
-  private AtomicBoolean closed = new AtomicBoolean(false);
-  private final String src;
-  private final boolean verifyChecksum;
+  protected final DFSClient dfsClient;
+  protected AtomicBoolean closed = new AtomicBoolean(false);
+  protected final String src;
+  protected final boolean verifyChecksum;
-  private LocatedBlock currentLocatedBlock = null;
-  private long pos = 0;
-  private long blockEnd = -1;
+  protected LocatedBlock currentLocatedBlock = null;
+  protected long pos = 0;
+  protected long blockEnd = -1;
-  private LocatedBlocks locatedBlocks = null;
+  protected LocatedBlocks locatedBlocks = null;
-  private CachingStrategy cachingStrategy;
+  protected CachingStrategy cachingStrategy;
-  private final ReadStatistics readStatistics = new ReadStatistics();
+  protected final ReadStatistics readStatistics = new ReadStatistics();
-  private final Object infoLock = new Object();
+  protected final Object infoLock = new Object();
-  private int failures = 0;
+  protected int failures = 0;
-  DFSInputStream(DFSClient dfsClient, String src, boolean verifyChecksum
-                 ) throws IOException, UnresolvedLinkException {
+  DFSInputStream(DFSClient dfsClient, String src, boolean verifyChecksum,
+      LocatedBlocks locatedBlocks) throws IOException, UnresolvedLinkException {
-    openInfo();
+    this.locatedBlocks = locatedBlocks;
+    openInfo(false);
+   * @param refreshLocatedBlocks whether to re-fetch locatedblocks
-  void openInfo() throws IOException, UnresolvedLinkException {
+  void openInfo(boolean refreshLocatedBlocks) throws IOException,
+      UnresolvedLinkException {
-      lastBlockBeingWrittenLength = fetchLocatedBlocksAndGetLastBlockLength();
+      lastBlockBeingWrittenLength =
+          fetchLocatedBlocksAndGetLastBlockLength(refreshLocatedBlocks);
-          lastBlockBeingWrittenLength = fetchLocatedBlocksAndGetLastBlockLength();
+          lastBlockBeingWrittenLength =
+              fetchLocatedBlocksAndGetLastBlockLength(true);
-  private long fetchLocatedBlocksAndGetLastBlockLength() throws IOException {
-    final LocatedBlocks newInfo = dfsClient.getLocatedBlocks(src, 0);
+  private long fetchLocatedBlocksAndGetLastBlockLength(boolean refresh)
+      throws IOException {
+    LocatedBlocks newInfo = locatedBlocks;
+    if (locatedBlocks == null || refresh) {
+      newInfo = dfsClient.getLocatedBlocks(src, 0);
+    }
-  private LocatedBlock getBlockAt(long offset) throws IOException {
+  protected LocatedBlock getBlockAt(long offset) throws IOException {
-  private void fetchBlockAt(long offset) throws IOException {
+  protected void fetchBlockAt(long offset) throws IOException {
-    closeCurrentBlockReader();
+    closeCurrentBlockReaders();
-          DFSClient.LOG.info("Will fetch a new encryption key and retry, " 
+          DFSClient.LOG.info("Will fetch a new encryption key and retry, "
-          DFSClient.LOG.warn("Failed to connect to " + targetAddr + " for block "
-            +targetBlock.getBlock()+ ", add to deadNodes and continue. " + ex, ex);
+          DFSClient.LOG.warn("Failed to connect to " + targetAddr + " for block"
+            + ", add to deadNodes and continue. " + ex, ex);
-    closeCurrentBlockReader();
+    closeCurrentBlockReaders();
-  private interface ReaderStrategy {
+  interface ReaderStrategy {
+
+    /**
+     * Copy data from the src ByteBuffer into the read buffer.
+     * @param src The src buffer where the data is copied from
+     * @param offset Useful only when the ReadStrategy is based on a byte array.
+     *               Indicate the offset of the byte array for copy.
+     * @param length Useful only when the ReadStrategy is based on a byte array.
+     *               Indicate the length of the data to copy.
+     */
+    public int copyFrom(ByteBuffer src, int offset, int length);
-  private void updateReadStatistics(ReadStatistics readStatistics, 
+  protected void updateReadStatistics(ReadStatistics readStatistics,
+
+    @Override
+    public int copyFrom(ByteBuffer src, int offset, int length) {
+      ByteBuffer writeSlice = src.duplicate();
+      writeSlice.get(buf, offset, length);
+      return length;
+    }
-  private class ByteBufferStrategy implements ReaderStrategy {
+  protected class ByteBufferStrategy implements ReaderStrategy {
+        if (ret == 0) {
+          DFSClient.LOG.warn("zero");
+        }
+
+    @Override
+    public int copyFrom(ByteBuffer src, int offset, int length) {
+      ByteBuffer writeSlice = src.duplicate();
+      int remaining = Math.min(buf.remaining(), writeSlice.remaining());
+      writeSlice.limit(writeSlice.position() + remaining);
+      buf.put(writeSlice);
+      return remaining;
+    }
-  private synchronized int readWithStrategy(ReaderStrategy strategy, int off, int len) throws IOException {
+  protected synchronized int readWithStrategy(ReaderStrategy strategy, int off, int len) throws IOException {
-  private void addIntoCorruptedBlockMap(ExtendedBlock blk, DatanodeInfo node, 
+  protected void addIntoCorruptedBlockMap(ExtendedBlock blk, DatanodeInfo node,
-        openInfo();
-        block = getBlockAt(block.getStartOffset());
+        openInfo(true);
+        block = refreshLocatedBlock(block);
-  private DNAddrPair getBestNodeDNAddrPair(LocatedBlock block,
+  protected DNAddrPair getBestNodeDNAddrPair(LocatedBlock block,
-  private void fetchBlockByteRange(long blockStartOffset, long start, long end,
+  protected void fetchBlockByteRange(LocatedBlock block, long start, long end,
-    LocatedBlock block = getBlockAt(blockStartOffset);
+    block = refreshLocatedBlock(block);
-        actualGetFromOneDataNode(addressPair, blockStartOffset, start, end,
+        actualGetFromOneDataNode(addressPair, block, start, end,
-      final long blockStartOffset, final long start, final long end,
+      final LocatedBlock block, final long start, final long end,
-          actualGetFromOneDataNode(datanode, blockStartOffset, start, end, buf,
+          actualGetFromOneDataNode(datanode, block, start, end, buf,
+  /**
+   * Used when reading contiguous blocks
+   */
-      long blockStartOffset, final long start, final long end, byte[] buf,
+      LocatedBlock block, final long start, final long end, byte[] buf,
+    final int length = (int) (end - start + 1);
+    actualGetFromOneDataNode(datanode, block, start, end, buf,
+        new int[]{offset}, new int[]{length}, corruptedBlockMap);
+  }
+
+  /**
+   * Read data from one DataNode.
+   * @param datanode the datanode from which to read data
+   * @param block the located block containing the requested data
+   * @param startInBlk the startInBlk offset of the block
+   * @param endInBlk the endInBlk offset of the block
+   * @param buf the given byte array into which the data is read
+   * @param offsets the data may be read into multiple segments of the buf
+   *                (when reading a striped block). this array indicates the
+   *                offset of each buf segment.
+   * @param lengths the length of each buf segment
+   * @param corruptedBlockMap map recording list of datanodes with corrupted
+   *                          block replica
+   */
+  void actualGetFromOneDataNode(final DNAddrPair datanode,
+      LocatedBlock block, final long startInBlk, final long endInBlk,
+      byte[] buf, int[] offsets, int[] lengths,
+      Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap)
+      throws IOException {
+    final int len = (int) (endInBlk - startInBlk + 1);
+    checkReadPortions(offsets, lengths, len);
-      LocatedBlock block = getBlockAt(blockStartOffset);
+      block = refreshLocatedBlock(block);
-        int len = (int) (end - start + 1);
-        reader = getBlockReader(block, start, len, datanode.addr,
+        reader = getBlockReader(block, startInBlk, len, datanode.addr,
-        int nread = reader.readAll(buf, offset, len);
-        updateReadStatistics(readStatistics, nread, reader);
-
-        if (nread != len) {
-          throw new IOException("truncated return from reader.read(): " +
-                                "excpected " + len + ", got " + nread);
+        for (int i = 0; i < offsets.length; i++) {
+          int nread = reader.readAll(buf, offsets[i], lengths[i]);
+          updateReadStatistics(readStatistics, nread, reader);
+          if (nread != lengths[i]) {
+            throw new IOException("truncated return from reader.read(): " +
+                "excpected " + lengths[i] + ", got " + nread);
+          }
-   * Like {@link #fetchBlockByteRange} except we start up a second, parallel,
+   * Refresh cached block locations.
+   * @param block The currently cached block locations
+   * @return Refreshed block locations
+   * @throws IOException
+   */
+  protected LocatedBlock refreshLocatedBlock(LocatedBlock block)
+      throws IOException {
+    return getBlockAt(block.getStartOffset());
+  }
+
+  /**
+   * This method verifies that the read portions are valid and do not overlap
+   * with each other.
+   */
+  private void checkReadPortions(int[] offsets, int[] lengths, int totalLen) {
+    Preconditions.checkArgument(offsets.length == lengths.length && offsets.length > 0);
+    int sum = 0;
+    for (int i = 0; i < lengths.length; i++) {
+      if (i > 0) {
+        int gap = offsets[i] - offsets[i - 1];
+        // make sure read portions do not overlap with each other
+        Preconditions.checkArgument(gap >= lengths[i - 1]);
+      }
+      sum += lengths[i];
+    }
+    Preconditions.checkArgument(sum == totalLen);
+  }
+
+  /**
+   * Like {@link #fetchBlockByteRange}except we start up a second, parallel,
-  private void hedgedFetchBlockByteRange(long blockStartOffset, long start,
+  private void hedgedFetchBlockByteRange(LocatedBlock block, long start,
-    LocatedBlock block = getBlockAt(blockStartOffset);
+    block = refreshLocatedBlock(block);
-            chosenNode, block.getStartOffset(), start, end, bb,
+            chosenNode, block, start, end, bb,
-              chosenNode, block.getStartOffset(), start, end, bb,
+              chosenNode, block, start, end, bb,
-  private static boolean tokenRefetchNeeded(IOException ex,
+  protected static boolean tokenRefetchNeeded(IOException ex,
-          hedgedFetchBlockByteRange(blk.getStartOffset(), targetStart,
-              targetStart + bytesToRead - 1, buffer, offset,
-              corruptedBlockMap);
+          hedgedFetchBlockByteRange(blk, targetStart,
+              targetStart + bytesToRead - 1, buffer, offset, corruptedBlockMap);
-          fetchBlockByteRange(blk.getStartOffset(), targetStart,
-              targetStart + bytesToRead - 1, buffer, offset,
-              corruptedBlockMap);
+          fetchBlockByteRange(blk, targetStart, targetStart + bytesToRead - 1,
+              buffer, offset, corruptedBlockMap);
-  private void reportCheckSumFailure(
+  protected void reportCheckSumFailure(
-  public synchronized long getPos() throws IOException {
+  public synchronized long getPos() {
-  private static final class DNAddrPair {
+  static final class DNAddrPair {
-  private void closeCurrentBlockReader() {
+  protected void closeCurrentBlockReaders() {
-    closeCurrentBlockReader();
+    closeCurrentBlockReaders();
-    closeCurrentBlockReader();
+    closeCurrentBlockReaders();
-    closeCurrentBlockReader();
+    closeCurrentBlockReaders();

INS26 INS40 INS31 INS31 INS31 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 INS44 INS44 INS44 UPD83 UPD83 INS42 INS31 UPD83 INS31 UPD83 INS31 UPD83 UPD83 UPD83 UPD83 INS29 INS83 INS39 INS42 INS44 INS44 MOV44 MOV44 INS44 MOV44 INS44 INS43 INS8 INS29 INS44 INS44 INS44 INS44 INS29 INS83 MOV43 INS42 INS44 MOV43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 UPD83 UPD83 UPD83 UPD42 INS43 INS42 INS21 INS65 INS39 INS42 INS39 INS42 INS25 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS43 UPD42 INS21 MOV43 UPD42 INS65 INS83 INS43 INS42 INS43 INS42 INS5 INS42 INS74 INS42 INS42 INS60 INS21 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS83 UPD42 INS83 INS39 INS42 INS5 INS42 INS5 INS42 INS60 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS5 INS42 INS5 INS42 INS39 INS42 INS21 INS60 INS24 INS21 INS43 UPD42 INS21 INS42 INS7 INS42 INS66 INS27 INS8 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS60 INS21 INS41 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS60 INS60 INS21 INS21 INS41 INS42 INS7 INS66 INS42 INS42 INS39 INS85 INS43 INS43 INS74 INS83 INS39 INS59 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS39 INS85 INS39 INS85 INS83 INS39 INS59 INS32 INS66 INS42 INS66 INS66 INS42 INS42 MOV32 INS66 INS66 INS39 INS85 INS39 INS85 INS32 INS39 INS59 INS58 INS27 INS37 INS8 INS32 UPD66 INS42 INS7 INS22 INS42 INS9 INS42 INS27 INS42 INS21 UPD42 UPD42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS43 INS59 INS39 INS59 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS43 INS43 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS3 INS3 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS27 INS42 INS34 INS39 INS59 INS42 INS40 INS42 INS25 INS21 INS42 INS42 INS27 INS42 INS32 UPD42 UPD42 UPD42 INS52 INS42 INS42 INS33 INS7 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS25 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS39 INS36 INS5 INS4 INS5 INS4 INS39 INS36 INS7 INS27 INS27 INS42 INS34 INS27 INS8 INS7 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 MOV32 INS42 INS42 INS27 INS8 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS27 INS39 INS85 INS42 INS39 INS85 INS42 INS27 INS42 INS32 INS24 INS40 INS40 INS40 INS34 INS42 INS34 INS60 INS21 INS42 INS2 INS42 INS42 INS34 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS34 INS27 INS34 UPD42 MOV42 UPD42 MOV42 INS58 INS27 INS37 INS8 INS39 INS59 INS32 INS42 INS42 MOV74 INS32 INS9 INS32 UPD42 INS42 INS42 INS42 INS42 INS39 INS59 INS42 INS40 INS42 MOV60 MOV21 MOV25 INS42 INS27 INS42 INS42 INS27 INS40 INS42 INS45 INS42 INS42 UPD42 INS42 INS34 INS2 INS2 INS42 INS2 MOV42 MOV37 MOV74 INS2 INS42 INS42 INS42 INS27 INS42 INS27 MOV42 MOV27 MOV42 MOV27 INS9 UPD42 INS2 INS2 INS42 INS42 INS42 INS34 INS42 INS34 MOV42 MOV37 INS42 INS42 INS42 INS42 UPD45 INS2 INS42 INS42 DEL83 DEL42 DEL42 DEL32 DEL83 DEL42 DEL39 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL39 DEL83 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL39 DEL42 DEL42 DEL27 DEL34 DEL27 DEL36 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL39 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL83
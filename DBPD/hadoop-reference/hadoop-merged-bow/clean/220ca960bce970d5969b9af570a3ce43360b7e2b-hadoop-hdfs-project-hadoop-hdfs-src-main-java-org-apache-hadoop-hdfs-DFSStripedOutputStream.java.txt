HDFS-7672. Handle write failure for stripping blocks and refactor the existing code in DFSStripedOutputStream and StripedDataStreamer.

+import java.util.concurrent.TimeUnit;
-import org.apache.hadoop.hdfs.protocol.ECInfo;
+import org.apache.hadoop.io.MultipleIOException;
+import org.apache.hadoop.io.erasurecode.ECSchema;
+import com.google.common.base.Preconditions;
+
+  /** Coordinate the communication between the streamers. */
+  static class Coordinator {
+    private final List<BlockingQueue<ExtendedBlock>> endBlocks;
+    private final List<BlockingQueue<LocatedBlock>> stripedBlocks;
+    private volatile boolean shouldLocateFollowingBlock = false;
+    Coordinator(final int numDataBlocks, final int numAllBlocks) {
+      endBlocks = new ArrayList<>(numDataBlocks);
+      for (int i = 0; i < numDataBlocks; i++) {
+        endBlocks.add(new LinkedBlockingQueue<ExtendedBlock>(1));
+      }
+
+      stripedBlocks = new ArrayList<>(numAllBlocks);
+      for (int i = 0; i < numAllBlocks; i++) {
+        stripedBlocks.add(new LinkedBlockingQueue<LocatedBlock>(1));
+      }
+    }
+
+    boolean shouldLocateFollowingBlock() {
+      return shouldLocateFollowingBlock;
+    }
+
+    void putEndBlock(int i, ExtendedBlock block) {
+      shouldLocateFollowingBlock = true;
+
+      final boolean b = endBlocks.get(i).offer(block);
+      Preconditions.checkState(b, "Failed to add " + block
+          + " to endBlocks queue, i=" + i);
+    }
+
+    ExtendedBlock getEndBlock(int i) throws InterruptedIOException {
+      try {
+        return endBlocks.get(i).poll(30, TimeUnit.SECONDS);
+      } catch (InterruptedException e) {
+        throw DFSUtil.toInterruptedIOException(
+            "getEndBlock interrupted, i=" + i, e);
+      }
+    }
+
+    void setBytesEndBlock(int i, long newBytes, ExtendedBlock block) {
+      ExtendedBlock b = endBlocks.get(i).peek();
+      if (b == null) {
+        // streamer just has failed, put end block and continue
+        b = block;
+        putEndBlock(i, b);
+      }
+      b.setNumBytes(newBytes);
+    }
+
+    void putStripedBlock(int i, LocatedBlock block) throws IOException {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("putStripedBlock " + block + ", i=" + i);
+      }
+      final boolean b = stripedBlocks.get(i).offer(block);
+      if (!b) {
+        throw new IOException("Failed: " + block + ", i=" + i);
+      }
+    }
+
+    LocatedBlock getStripedBlock(int i) throws IOException {
+      final LocatedBlock lb;
+      try {
+        lb = stripedBlocks.get(i).poll(90, TimeUnit.SECONDS);
+      } catch (InterruptedException e) {
+        throw DFSUtil.toInterruptedIOException("getStripedBlock interrupted", e);
+      }
+
+      if (lb == null) {
+        throw new IOException("Failed: i=" + i);
+      }
+      return lb;
+    }
+  }
+
+  /** Buffers for writing the data and parity cells of a strip. */
+  class CellBuffers {
+    private final ByteBuffer[] buffers;
+    private final byte[][] checksumArrays;
+
+    CellBuffers(int numParityBlocks) throws InterruptedException{
+      if (cellSize % bytesPerChecksum != 0) {
+        throw new HadoopIllegalArgumentException("Invalid values: "
+            + DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY + " (="
+            + bytesPerChecksum + ") must divide cell size (=" + cellSize + ").");
+      }
+
+      checksumArrays = new byte[numParityBlocks][];
+      final int size = getChecksumSize() * (cellSize / bytesPerChecksum);
+      for (int i = 0; i < checksumArrays.length; i++) {
+        checksumArrays[i] = new byte[size];
+      }
+
+      buffers = new ByteBuffer[numAllBlocks];
+      for (int i = 0; i < buffers.length; i++) {
+        buffers[i] = ByteBuffer.wrap(byteArrayManager.newByteArray(cellSize));
+      }
+    }
+
+    private ByteBuffer[] getBuffers() {
+      return buffers;
+    }
+
+    byte[] getChecksumArray(int i) {
+      return checksumArrays[i - numDataBlocks];
+    }
+
+    private int addTo(int i, byte[] b, int off, int len) {
+      final ByteBuffer buf = buffers[i];
+      final int pos = buf.position() + len;
+      Preconditions.checkState(pos <= cellSize);
+      buf.put(b, off, len);
+      return pos;
+    }
+
+    private void clear() {
+      for (int i = 0; i< numAllBlocks; i++) {
+        buffers[i].clear();
+        if (i >= numDataBlocks) {
+          Arrays.fill(buffers[i].array(), (byte) 0);
+        }
+      }
+    }
+
+    private void release() {
+      for (int i = 0; i < numAllBlocks; i++) {
+        byteArrayManager.release(buffers[i].array());
+      }
+    }
+
+    private void flipDataBuffers() {
+      for (int i = 0; i < numDataBlocks; i++) {
+        buffers[i].flip();
+      }
+    }
+  }
+
+  private final Coordinator coordinator;
+  private final CellBuffers cellBuffers;
+  private final RawErasureEncoder encoder;
-  /**
-   * Size of each striping cell, must be a multiple of bytesPerChecksum
-   */
-  private final ECInfo ecInfo;
+
+  /** Size of each striping cell, must be a multiple of bytesPerChecksum */
-  // checksum buffer, we only need to calculate checksum for parity blocks
-  private byte[] checksumBuf;
-  private ByteBuffer[] cellBuffers;
-
-  private final short numAllBlocks;
-  private final short numDataBlocks;
-
-  private int curIdx = 0;
-  /* bytes written in current block group */
-  //private long currentBlockGroupBytes = 0;
-
-  //TODO: Use ErasureCoder interface (HDFS-7781)
-  private RawErasureEncoder encoder;
+  private final int numAllBlocks;
+  private final int numDataBlocks;
-  private long getBlockGroupSize() {
-    return blockSize * numDataBlocks;
-  }
-
-    DFSClient.LOG.info("Creating striped output stream");
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Creating DFSStripedOutputStream for " + src);
+    }
-    ecInfo = dfsClient.getErasureCodingInfo(src);
-    cellSize = ecInfo.getSchema().getChunkSize();
-    numAllBlocks = (short)(ecInfo.getSchema().getNumDataUnits()
-        + ecInfo.getSchema().getNumParityUnits());
-    numDataBlocks = (short)ecInfo.getSchema().getNumDataUnits();
+    //TODO reduce an rpc call HDFS-8289
+    final ECSchema schema = dfsClient.getErasureCodingInfo(src).getSchema();
+    final int numParityBlocks = schema.getNumParityUnits();
+    cellSize = schema.getChunkSize();
+    numDataBlocks = schema.getNumDataUnits();
+    numAllBlocks = numDataBlocks + numParityBlocks;
-    checkConfiguration();
-
-    checksumBuf = new byte[getChecksumSize() * (cellSize / bytesPerChecksum)];
-    cellBuffers = new ByteBuffer[numAllBlocks];
-    List<BlockingQueue<LocatedBlock>> stripeBlocks = new ArrayList<>();
-
-    for (int i = 0; i < numAllBlocks; i++) {
-      stripeBlocks.add(new LinkedBlockingQueue<LocatedBlock>(numAllBlocks));
-      try {
-        cellBuffers[i] = ByteBuffer.wrap(byteArrayManager.newByteArray(cellSize));
-      } catch (InterruptedException ie) {
-        final InterruptedIOException iioe = new InterruptedIOException(
-            "create cell buffers");
-        iioe.initCause(ie);
-        throw iioe;
-      }
-    }
-    encoder.initialize(numDataBlocks,
-        numAllBlocks - numDataBlocks, cellSize);
+    encoder.initialize(numDataBlocks, numParityBlocks, cellSize);
+
+    coordinator = new Coordinator(numDataBlocks, numAllBlocks);
+    try {
+      cellBuffers = new CellBuffers(numParityBlocks);
+    } catch (InterruptedException ie) {
+      throw DFSUtil.toInterruptedIOException("Failed to create cell buffers", ie);
+    }
-      StripedDataStreamer streamer = new StripedDataStreamer(stat, null,
+      StripedDataStreamer streamer = new StripedDataStreamer(stat,
-          i, stripeBlocks, favoredNodes);
+          favoredNodes, i, coordinator);
-
-    refreshStreamer();
+    setCurrentStreamer(0);
-  private void checkConfiguration() {
-    if (cellSize % bytesPerChecksum != 0) {
-      throw new HadoopIllegalArgumentException("Invalid values: "
-          + DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY + " (=" + bytesPerChecksum
-          + ") must divide cell size (=" + cellSize + ").");
-    }
+  StripedDataStreamer getStripedDataStreamer(int i) {
+    return streamers.get(i);
-  private void refreshStreamer() {
-    streamer = streamers.get(curIdx);
+  int getCurrentIndex() {
+    return getCurrentStreamer().getIndex();
-  private void moveToNextStreamer() {
-    curIdx = (curIdx + 1) % numAllBlocks;
-    refreshStreamer();
+  StripedDataStreamer getCurrentStreamer() {
+    return (StripedDataStreamer)streamer;
+  }
+
+  private StripedDataStreamer setCurrentStreamer(int i) {
+    streamer = streamers.get(i);
+    return getCurrentStreamer();
-   * encode the buffers.
-   * After encoding, flip each buffer.
+   * Encode the buffers, i.e. compute parities.
-  private void encode(ByteBuffer[] buffers) {
-    ByteBuffer[] dataBuffers = new ByteBuffer[numDataBlocks];
-    ByteBuffer[] parityBuffers = new ByteBuffer[numAllBlocks - numDataBlocks];
-    for (int i = 0; i < numAllBlocks; i++) {
-      if (i < numDataBlocks) {
-        dataBuffers[i] = buffers[i];
-      } else {
-        parityBuffers[i - numDataBlocks] = buffers[i];
+  private static void encode(RawErasureEncoder encoder, int numData,
+      ByteBuffer[] buffers) {
+    final ByteBuffer[] dataBuffers = new ByteBuffer[numData];
+    final ByteBuffer[] parityBuffers = new ByteBuffer[buffers.length - numData];
+    System.arraycopy(buffers, 0, dataBuffers, 0, dataBuffers.length);
+    System.arraycopy(buffers, numData, parityBuffers, 0, parityBuffers.length);
+
+    encoder.encode(dataBuffers, parityBuffers);
+  }
+
+
+  private void checkStreamers() throws IOException {
+    int count = 0;
+    for(StripedDataStreamer s : streamers) {
+      if (!s.isFailed()) {
+        count++;
-    encoder.encode(dataBuffers, parityBuffers);
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("checkStreamers: " + streamers);
+      LOG.debug("count=" + count);
+    }
+    if (count < numDataBlocks) {
+      throw new IOException("Failed: the number of remaining blocks = "
+          + count + " < the number of data blocks = " + numDataBlocks);
+    }
+  }
+
+  private void handleStreamerFailure(String err, Exception e) throws IOException {
+    LOG.warn("Failed: " + err + ", " + this, e);
+    getCurrentStreamer().setIsFailed(true);
+    checkStreamers();
+    currentPacket = null;
+   * @param checksumBuf the checksum buffer
-  private List<DFSPacket> generatePackets(ByteBuffer byteBuffer)
-      throws IOException{
+  private List<DFSPacket> generatePackets(
+      ByteBuffer byteBuffer, byte[] checksumBuf) throws IOException{
-  protected synchronized void writeChunk(byte[] b, int offset, int len,
+  protected synchronized void writeChunk(byte[] bytes, int offset, int len,
-    super.writeChunk(b, offset, len, checksum, ckoff, cklen);
+    final int index = getCurrentIndex();
+    final StripedDataStreamer current = getCurrentStreamer();
+    final int pos = cellBuffers.addTo(index, bytes, offset, len);
+    final boolean cellFull = pos == cellSize;
-    if (getSizeOfCellnBuffer(curIdx) <= cellSize) {
-      addToCellBuffer(b, offset, len);
-    } else {
-      String msg = "Writing a chunk should not overflow the cell buffer.";
-      DFSClient.LOG.info(msg);
-      throw new IOException(msg);
+    final long oldBytes = current.getBytesCurBlock();
+    if (!current.isFailed()) {
+      try {
+        super.writeChunk(bytes, offset, len, checksum, ckoff, cklen);
+
+        // cell is full and current packet has not been enqueued,
+        if (cellFull && currentPacket != null) {
+          enqueueCurrentPacketFull();
+        }
+      } catch(Exception e) {
+        handleStreamerFailure("offset=" + offset + ", length=" + len, e);
+      }
-    // If current packet has not been enqueued for transmission,
-    // but the cell buffer is full, we need to enqueue the packet
-    if (currentPacket != null && getSizeOfCellnBuffer(curIdx) == cellSize) {
-      if (DFSClient.LOG.isDebugEnabled()) {
-        DFSClient.LOG.debug("DFSClient writeChunk cell buffer full seqno=" +
-            currentPacket.getSeqno() +
-            ", curIdx=" + curIdx +
-            ", src=" + src +
-            ", bytesCurBlock=" + streamer.getBytesCurBlock() +
-            ", blockSize=" + blockSize +
-            ", appendChunk=" + streamer.getAppendChunk());
-      }
-      streamer.waitAndQueuePacket(currentPacket);
-      currentPacket = null;
-      adjustChunkBoundary();
-      endBlock();
+    if (current.isFailed()) {
+      final long newBytes = oldBytes + len;
+      coordinator.setBytesEndBlock(index, newBytes, current.getBlock());
+      current.setBytesCurBlock(newBytes);
-    if (getSizeOfCellnBuffer(curIdx) == cellSize) {
-      //move curIdx to next cell
-      moveToNextStreamer();
+    if (cellFull) {
+      int next = index + 1;
-      if (curIdx == numDataBlocks) {
-        //encode the data cells
-        for (int k = 0; k < numDataBlocks; k++) {
-          cellBuffers[k].flip();
-        }
-        encode(cellBuffers);
-        for (int i = numDataBlocks; i < numAllBlocks; i++) {
-          ByteBuffer parityBuffer = cellBuffers[i];
-          List<DFSPacket> packets = generatePackets(parityBuffer);
-          for (DFSPacket p : packets) {
-            currentPacket = p;
-            streamer.waitAndQueuePacket(currentPacket);
-            currentPacket = null;
-          }
-          endBlock();
-          moveToNextStreamer();
-        }
-        //read next stripe to cellBuffers
-        clearCellBuffers();
+      if (next == numDataBlocks) {
+        cellBuffers.flipDataBuffers();
+        writeParityCells();
+        next = 0;
-    }
-  }
-
-  private void addToCellBuffer(byte[] b, int off, int len) {
-    cellBuffers[curIdx].put(b, off, len);
-  }
-
-  private int getSizeOfCellnBuffer(int cellIndex) {
-    return cellBuffers[cellIndex].position();
-  }
-
-  private void clearCellBuffers() {
-    for (int i = 0; i< numAllBlocks; i++) {
-      cellBuffers[i].clear();
-      if (i >= numDataBlocks) {
-        Arrays.fill(cellBuffers[i].array(), (byte) 0);
-      }
+      setCurrentStreamer(next);
-  private void notSupported(String headMsg)
-      throws IOException{
-      throw new IOException(
-          headMsg + " is now not supported for striping layout.");
+  @Override
+  public void hflush() {
+    throw new UnsupportedOperationException();
-  public void hflush() throws IOException {
-    notSupported("hflush");
-  }
-
-  @Override
-  public void hsync() throws IOException {
-    notSupported("hsync");
+  public void hsync() {
+    throw new UnsupportedOperationException();
-  // shutdown datastreamer and responseprocessor threads.
-  // interrupt datastreamer if force is true
-    int index = 0;
-    boolean exceptionOccurred = false;
+    final MultipleIOException.Builder b = new MultipleIOException.Builder();
-      } catch (InterruptedException | IOException e) {
-        DFSClient.LOG.error("Failed to shutdown streamer: name="
-            + streamer.getName() + ", index=" + index + ", file=" + src, e);
-        exceptionOccurred = true;
+      } catch(Exception e) {
+        try {
+          handleStreamerFailure("force=" + force, e);
+        } catch(IOException ioe) {
+          b.add(ioe);
+        }
-        index++;
-    if (exceptionOccurred) {
-      throw new IOException("Failed to shutdown streamer");
+    final IOException ioe = b.build();
+    if (ioe != null) {
+      throw ioe;
-    long firstCellSize = getLeadingStreamer().getBytesCurBlock() % cellSize;
-    long parityCellSize = firstCellSize > 0 && firstCellSize < cellSize ?
+
+    final int firstCellSize = (int)(getStripedDataStreamer(0).getBytesCurBlock() % cellSize);
+    final int parityCellSize = firstCellSize > 0 && firstCellSize < cellSize?
+    final ByteBuffer[] buffers = cellBuffers.getBuffers();
-      int position = cellBuffers[i].position();
+      final int position = buffers[i].position();
-        cellBuffers[i].put((byte) 0);
+        buffers[i].put((byte) 0);
-      cellBuffers[i].flip();
+      buffers[i].flip();
-    encode(cellBuffers);
-    // write parity cells
-    curIdx = numDataBlocks;
-    refreshStreamer();
+    writeParityCells();
+  }
+
+  void writeParityCells() throws IOException {
+    final ByteBuffer[] buffers = cellBuffers.getBuffers();
+    //encode the data cells
+    encode(encoder, numDataBlocks, buffers);
-      ByteBuffer parityBuffer = cellBuffers[i];
-      List<DFSPacket> packets = generatePackets(parityBuffer);
-      for (DFSPacket p : packets) {
-        currentPacket = p;
-        streamer.waitAndQueuePacket(currentPacket);
-        currentPacket = null;
+      writeParity(i, buffers[i], cellBuffers.getChecksumArray(i));
+    }
+    cellBuffers.clear();
+  }
+
+  void writeParity(int index, ByteBuffer buffer, byte[] checksumBuf
+      ) throws IOException {
+    final StripedDataStreamer current = setCurrentStreamer(index);
+    final int len = buffer.limit();
+
+    final long oldBytes = current.getBytesCurBlock();
+    if (!current.isFailed()) {
+      try {
+        for (DFSPacket p : generatePackets(buffer, checksumBuf)) {
+          streamer.waitAndQueuePacket(p);
+        }
+        endBlock();
+      } catch(Exception e) {
+        handleStreamerFailure("oldBytes=" + oldBytes + ", len=" + len, e);
-      endBlock();
-      moveToNextStreamer();
-    clearCellBuffers();
+    if (current.isFailed()) {
+      final long newBytes = oldBytes + len;
+      current.setBytesCurBlock(newBytes);
+    }
-      byteArrayManager.release(cellBuffers[i].array());
+    cellBuffers.release();
-      flushBuffer();
-      if (currentPacket != null) {
-        streamer.waitAndQueuePacket(currentPacket);
-        currentPacket = null;
+      try {
+        flushBuffer();
+        if (currentPacket != null) {
+          enqueueCurrentPacket();
+        }
+      } catch(Exception e) {
+        handleStreamerFailure("closeImpl", e);
+
-        curIdx = i;
-        refreshStreamer();
-        if (streamer.getBytesCurBlock() > 0) {
-          // send an empty packet to mark the end of the block
-          currentPacket = createPacket(0, 0, streamer.getBytesCurBlock(),
-              streamer.getAndIncCurrentSeqno(), true);
-          currentPacket.setSyncBlock(shouldSyncBlock);
+        final StripedDataStreamer s = setCurrentStreamer(i);
+        if (!s.isFailed()) {
+          try {
+            if (s.getBytesCurBlock() > 0) {
+              setCurrentPacket2Empty();
+            }
+            // flush all data to Datanode
+            flushInternal();
+          } catch(Exception e) {
+            handleStreamerFailure("closeImpl", e);
+          }
-        // flush all data to Datanode
-        flushInternal();

MOV26 INS26 INS26 INS26 MOV23 MOV31 INS40 INS40 UPD40 INS40 INS55 INS55 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS42 INS23 MOV23 MOV23 INS31 INS31 MOV31 INS31 MOV31 MOV31 MOV31 INS29 INS42 INS23 INS23 INS31 INS31 INS31 INS31 MOV31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS83 INS43 MOV59 INS83 INS29 INS83 INS83 INS39 MOV59 INS83 INS83 INS39 MOV59 INS83 INS83 INS39 MOV59 MOV21 INS43 INS42 INS44 INS8 INS39 INS42 INS8 INS43 INS42 INS8 INS83 INS43 INS42 INS44 INS8 MOV29 INS83 INS83 INS39 INS42 INS44 INS44 MOV44 INS8 INS83 INS39 INS42 MOV43 INS8 INS83 INS39 INS42 MOV44 INS44 MOV43 INS8 INS44 MOV78 INS83 INS83 INS39 INS42 INS44 MOV44 MOV44 MOV44 MOV44 MOV44 MOV43 INS8 MOV78 UPD83 UPD42 UPD42 MOV78 UPD83 UPD42 MOV44 MOV43 INS8 INS39 INS42 INS43 INS8 MOV39 INS42 INS44 INS44 INS44 INS43 MOV8 MOV65 MOV83 MOV83 INS74 MOV59 MOV74 INS59 INS83 INS39 INS42 INS44 INS44 INS8 INS39 INS42 INS8 INS39 INS42 INS44 INS44 INS8 INS43 INS42 INS44 MOV43 INS8 UPD42 INS44 INS44 INS44 INS8 UPD42 INS44 INS44 MOV43 INS43 INS42 INS44 INS43 INS65 INS83 INS83 INS5 INS59 INS83 INS83 INS5 INS59 INS42 INS44 INS43 MOV8 UPD83 MOV83 MOV5 INS42 INS8 MOV5 INS42 INS44 MOV8 UPD83 MOV83 UPD39 MOV39 UPD42 MOV42 MOV44 MOV44 MOV44 MOV44 INS8 UPD42 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS42 INS42 INS42 INS65 INS25 INS60 INS60 INS54 INS42 INS39 INS42 INS41 INS41 INS42 INS41 INS42 INS39 INS42 MOV21 INS41 INS43 INS42 INS39 INS42 MOV60 INS60 MOV21 INS21 MOV21 INS60 INS70 INS25 INS25 UPD42 INS43 INS42 MOV21 INS21 INS21 MOV21 INS65 INS5 INS42 INS5 INS42 INS60 INS60 MOV60 INS60 INS60 INS25 INS25 INS25 INS53 INS60 INS70 INS60 INS25 MOV60 INS42 INS60 INS21 INS24 INS21 INS39 INS42 MOV43 INS42 INS5 INS42 INS42 INS60 INS25 INS21 UPD66 INS43 INS74 UPD42 INS42 UPD42 INS9 INS83 INS39 INS42 INS83 INS39 INS42 INS21 INS24 INS21 INS24 INS41 INS39 INS42 INS43 INS42 INS21 INS60 INS21 INS42 INS39 INS42 INS54 INS39 INS42 INS39 INS42 INS43 INS42 INS60 INS25 INS21 INS39 INS42 INS43 INS42 INS25 INS60 INS25 INS42 INS39 INS42 INS42 INS60 INS54 INS25 INS41 INS66 INS43 INS85 INS42 INS39 INS85 INS85 INS42 INS39 INS42 INS42 MOV25 INS21 INS60 MOV21 MOV24 INS41 INS39 INS42 INS41 INS39 UPD42 INS60 INS60 INS21 MOV21 INS41 INS24 INS24 INS66 INS32 INS8 INS83 INS43 INS59 INS83 INS39 INS59 INS8 INS12 INS32 INS32 INS11 INS7 INS32 UPD66 INS42 INS83 MOV5 INS83 MOV5 INS59 INS32 INS39 INS59 INS44 INS42 INS8 INS32 INS8 INS27 INS8 INS42 INS32 INS32 INS42 INS66 INS39 INS85 INS39 INS85 INS83 INS39 INS59 INS83 INS43 INS59 INS83 INS39 INS83 INS39 INS59 INS83 INS39 MOV59 INS38 INS8 INS32 INS8 INS42 INS8 INS14 INS83 INS43 INS59 MOV44 INS42 INS8 INS83 MOV43 INS59 INS27 INS8 INS83 UPD39 INS83 UPD39 INS83 INS5 INS83 INS5 INS59 INS32 MOV58 MOV27 MOV37 INS8 INS32 INS39 INS85 INS83 INS43 INS59 INS83 INS83 UPD39 INS38 INS8 INS32 INS32 INS42 INS43 INS43 INS7 INS58 INS27 INS37 INS8 INS7 INS58 MOV27 INS37 INS8 INS42 INS42 INS7 INS83 INS39 INS59 INS32 INS8 INS12 INS42 INS43 INS59 INS27 INS8 INS32 INS42 INS32 INS8 INS83 INS39 INS59 INS38 INS8 INS83 INS43 INS59 INS8 INS12 INS27 INS8 INS42 INS42 INS7 INS83 INS39 INS59 INS27 INS8 INS27 MOV8 INS42 MOV2 INS83 MOV43 INS59 INS83 INS39 INS59 INS32 INS42 INS58 MOV27 INS37 INS8 INS58 MOV27 MOV37 INS8 INS42 INS42 MOV21 INS42 INS42 INS32 INS42 INS32 UPD42 INS32 UPD42 INS27 INS42 INS42 INS42 INS42 UPD42 UPD42 INS14 INS21 MOV44 INS8 UPD42 INS34 UPD42 MOV42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 INS43 INS42 INS42 INS32 UPD42 MOV42 UPD42 INS42 INS3 UPD42 INS42 INS42 INS34 INS42 INS34 INS40 INS42 INS42 INS42 INS42 INS42 INS34 INS40 UPD42 MOV42 MOV34 INS43 INS42 INS25 INS42 INS42 MOV21 INS21 INS42 INS42 INS53 INS42 INS42 INS27 UPD42 INS32 INS42 INS9 INS42 UPD42 MOV42 INS32 INS42 INS42 INS32 UPD42 INS32 INS42 INS27 UPD42 INS32 INS54 UPD42 MOV42 INS42 INS60 MOV21 INS21 INS60 INS25 INS21 INS43 INS43 INS40 INS42 INS14 INS54 INS42 INS32 INS42 INS33 INS53 INS11 INS43 INS85 UPD42 UPD42 INS43 INS85 INS42 INS32 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS32 UPD42 INS32 INS42 INS32 INS32 MOV54 INS42 INS42 INS60 INS21 INS42 INS42 INS54 INS42 UPD42 MOV42 INS42 INS14 INS39 INS59 INS42 INS42 INS42 INS21 INS42 MOV14 INS39 INS59 INS42 MOV21 INS42 INS9 INS42 INS32 INS42 INS42 INS42 INS27 INS41 INS44 INS8 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS32 INS42 INS53 INS42 INS42 MOV21 INS44 INS8 INS42 INS33 MOV53 INS42 INS3 INS42 MOV27 INS42 INS40 MOV21 UPD42 INS42 INS40 UPD42 INS42 MOV2 INS42 INS27 INS42 INS42 INS27 UPD42 INS42 UPD42 INS39 INS59 INS42 MOV21 INS39 INS59 INS21 MOV32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS43 INS42 INS42 INS7 INS53 MOV43 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 MOV5 INS27 INS42 INS38 INS8 INS32 INS14 INS45 INS42 INS45 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS8 INS12 INS83 INS39 INS59 INS32 INS39 INS59 INS27 INS8 INS32 INS42 INS42 INS43 MOV8 INS12 MOV8 INS42 INS42 INS42 INS39 INS36 UPD42 MOV42 UPD42 UPD42 INS83 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS8 INS83 INS39 INS59 INS32 INS8 INS12 INS74 INS42 UPD42 MOV42 MOV34 INS32 INS42 INS42 INS34 INS32 INS42 INS42 INS45 UPD42 MOV42 INS45 UPD42 MOV42 INS32 INS43 INS42 INS53 INS32 INS42 INS7 INS32 INS32 INS32 INS42 INS42 INS14 MOV43 INS42 INS53 INS5 UPD42 MOV42 INS32 INS42 INS42 MOV42 UPD42 MOV42 INS34 INS32 INS42 INS34 INS32 UPD42 INS42 INS27 INS42 INS42 INS14 INS32 INS40 INS42 INS32 INS21 INS42 INS42 INS27 INS42 INS42 INS27 MOV43 INS27 INS21 INS25 INS44 INS8 INS42 INS27 INS42 INS42 UPD42 UPD42 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS21 INS21 INS21 INS42 INS42 INS40 INS44 INS8 INS27 INS42 INS42 MOV2 INS32 INS70 MOV21 INS42 INS27 INS42 INS42 INS42 MOV21 INS25 INS44 INS8 INS60 INS43 INS42 INS42 INS14 UPD42 INS42 INS42 INS42 INS32 INS42 INS34 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 UPD42 MOV42 MOV42 UPD42 MOV42 INS43 INS27 UPD42 INS32 INS32 INS27 INS39 INS85 INS85 INS3 INS42 INS42 INS42 INS42 INS32 INS2 INS42 INS45 INS42 INS43 INS42 INS42 INS42 INS45 UPD42 MOV42 MOV43 INS42 UPD42 INS42 INS42 INS37 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS48 MOV27 INS8 INS43 INS42 MOV21 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS34 INS32 INS32 INS7 INS43 INS42 INS54 MOV32 MOV42 UPD42 INS42 INS42 INS42 MOV44 INS32 INS8 INS43 INS42 INS42 MOV27 INS8 INS43 INS42 MOV21 INS83 INS43 INS59 INS38 INS8 INS42 INS74 INS34 INS34 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS45 INS42 INS45 INS42 INS42 INS45 INS42 INS45 INS42 INS32 INS42 INS34 INS40 UPD42 MOV42 INS42 INS45 INS42 INS45 INS42 UPD42 MOV5 INS42 UPD42 UPD42 INS2 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV21 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS8 INS12 UPD42 INS42 INS42 INS42 INS21 INS42 MOV21 INS42 INS32 INS42 INS42 INS32 INS32 INS54 INS43 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS27 INS42 MOV21 INS44 INS8 UPD42 INS34 UPD42 INS32 UPD42 INS42 INS45 INS42 UPD42 MOV42 INS42 INS42 INS42 INS8 INS12 INS42 INS42 UPD42 INS45 INS42 INS45 INS42 MOV43 INS42 INS21 INS42 INS42 INS42 UPD45 UPD42 UPD45 UPD42 UPD42 INS25 MOV21 INS44 INS8 UPD42 UPD42 INS27 INS42 INS32 MOV27 INS8 INS43 INS42 MOV21 INS45 INS42 INS42 INS42 INS42 INS21 INS42 UPD42 INS32 UPD42 INS45 UPD42 UPD42 MOV42 DEL39 DEL42 DEL83 DEL39 DEL42 DEL27 DEL41 DEL8 DEL83 DEL8 DEL83 DEL42 DEL32 DEL7 DEL21 DEL83 DEL39 DEL42 DEL42 DEL34 DEL27 DEL36 DEL42 DEL27 DEL42 DEL32 DEL21 DEL42 DEL3 DEL59 DEL60 DEL8 DEL25 DEL8 DEL83 DEL42 DEL42 DEL43 DEL45 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL7 DEL21 DEL39 DEL85 DEL5 DEL40 DEL42 DEL32 DEL29 DEL43 DEL23 DEL83 DEL23 DEL83 DEL83 DEL39 DEL23 DEL83 DEL83 DEL39 DEL23 DEL83 DEL39 DEL59 DEL23 DEL40 DEL45 DEL42 DEL7 DEL21 DEL42 DEL32 DEL39 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL36 DEL11 DEL39 DEL42 DEL42 DEL32 DEL42 DEL32 DEL11 DEL3 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL33 DEL42 DEL32 DEL66 DEL42 DEL42 DEL27 DEL42 DEL42 DEL2 DEL42 DEL42 DEL83 DEL39 DEL42 DEL31 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL2 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL48 DEL21 DEL42 DEL42 DEL32 DEL27 DEL8 DEL42 DEL43 DEL45 DEL59 DEL60 DEL8 DEL25 DEL40 DEL42 DEL32 DEL40 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL42 DEL45 DEL32 DEL45 DEL42 DEL45 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL42 DEL27 DEL39 DEL59 DEL58 DEL42 DEL42 DEL27 DEL37 DEL8 DEL24 DEL39 DEL42 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL70 DEL8 DEL24 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL2 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL45 DEL27 DEL42 DEL45 DEL32 DEL21 DEL45 DEL42 DEL37 DEL21 DEL8 DEL83 DEL42 DEL31 DEL27 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL70 DEL42 DEL32 DEL21 DEL8 DEL24 DEL34 DEL42 DEL9 DEL84 DEL40 DEL45 DEL42 DEL42 DEL32 DEL42 DEL9 DEL7 DEL21 DEL42 DEL8 DEL70 DEL42 DEL45 DEL14 DEL53 DEL42 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL33 DEL7 DEL8 DEL25 DEL42 DEL42 DEL7 DEL21 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL34 DEL42 DEL32 DEL42 DEL42 DEL32 DEL9 DEL32 DEL7 DEL21 DEL8
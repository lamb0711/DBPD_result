HDFS-5053. NameNode should invoke DataNode APIs to coordinate caching. (Andrew Wang)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1523145 13f79535-47bb-0310-9956-ffa450edef68

-import com.google.common.base.Preconditions;
-public class BlockManager {
+public class BlockManager extends ReportProcessor {
-  private final InvalidateBlocks invalidateBlocks;
+  private final InvalidateStoredBlocks invalidateBlocks;
-  private final long maxNumBlocksToLog;
+    super(conf);
-    invalidateBlocks = new InvalidateBlocks(datanodeManager);
+    invalidateBlocks = new InvalidateStoredBlocks(datanodeManager);
-    
-    this.maxNumBlocksToLog =
-        conf.getLong(DFSConfigKeys.DFS_MAX_NUM_BLOCKS_TO_LOG_KEY,
-            DFSConfigKeys.DFS_MAX_NUM_BLOCKS_TO_LOG_DEFAULT);
-    
+
+  @Override  // ReportProcessor
-  private void markBlockAsCorrupt(BlockToMarkCorrupt b,
+  @Override // ReportProcessor
+  void markBlockAsCorrupt(BlockToMarkCorrupt b,
-      blockLog.info("BLOCK markBlockAsCorrupt: " + b
+      blockLogInfo("#markBlockAsCorrupt: " + b
+  public boolean shouldPostponeBlocksFromFuture() {
+    return this.shouldPostponeBlocksFromFuture;
+  }
-  
-  /**
-   * StatefulBlockInfo is used to build the "toUC" list, which is a list of
-   * updates to the information about under-construction blocks.
-   * Besides the block in question, it provides the ReplicaState
-   * reported by the datanode in the block report. 
-   */
-  private static class StatefulBlockInfo {
-    final BlockInfoUnderConstruction storedBlock;
-    final ReplicaState reportedState;
-    
-    StatefulBlockInfo(BlockInfoUnderConstruction storedBlock, 
-        ReplicaState reportedState) {
-      this.storedBlock = storedBlock;
-      this.reportedState = reportedState;
-    }
-  }
-  
-  /**
-   * BlockToMarkCorrupt is used to build the "toCorrupt" list, which is a
-   * list of blocks that should be considered corrupt due to a block report.
-   */
-  private static class BlockToMarkCorrupt {
-    /** The corrupted block in a datanode. */
-    final BlockInfo corrupted;
-    /** The corresponding block stored in the BlockManager. */
-    final BlockInfo stored;
-    /** The reason to mark corrupt. */
-    final String reason;
-    
-    BlockToMarkCorrupt(BlockInfo corrupted, BlockInfo stored, String reason) {
-      Preconditions.checkNotNull(corrupted, "corrupted is null");
-      Preconditions.checkNotNull(stored, "stored is null");
-
-      this.corrupted = corrupted;
-      this.stored = stored;
-      this.reason = reason;
-    }
-
-    BlockToMarkCorrupt(BlockInfo stored, String reason) {
-      this(stored, stored, reason);
-    }
-
-    BlockToMarkCorrupt(BlockInfo stored, long gs, String reason) {
-      this(new BlockInfo(stored), stored, reason);
-      //the corrupted block in datanode has a different generation stamp
-      corrupted.setGenerationStamp(gs);
-    }
-
-    @Override
-    public String toString() {
-      return corrupted + "("
-          + (corrupted == stored? "same as stored": "stored=" + stored) + ")";
-    }
-  }
-   * The given datanode is reporting all of its cached blocks.
-   * Update the cache state of blocks in the block map.
-   */
-  public void processCacheReport(final DatanodeID nodeID, final String poolId,
-      final BlockListAsLongs newReport) throws IOException {
-    // TODO: Implement me!
-  }
-
-  /**
-  private void processReport(final DatanodeDescriptor node,
-      final BlockListAsLongs report) throws IOException {
-    // Normal case:
-    // Modify the (block-->datanode) map, according to the difference
-    // between the old and new block report.
-    //
-    Collection<BlockInfo> toAdd = new LinkedList<BlockInfo>();
-    Collection<Block> toRemove = new LinkedList<Block>();
-    Collection<Block> toInvalidate = new LinkedList<Block>();
-    Collection<BlockToMarkCorrupt> toCorrupt = new LinkedList<BlockToMarkCorrupt>();
-    Collection<StatefulBlockInfo> toUC = new LinkedList<StatefulBlockInfo>();
-    reportDiff(node, report, toAdd, toRemove, toInvalidate, toCorrupt, toUC);
-
-    // Process the blocks on each queue
-    for (StatefulBlockInfo b : toUC) { 
-      addStoredBlockUnderConstruction(b.storedBlock, node, b.reportedState);
-    }
-    for (Block b : toRemove) {
-      removeStoredBlock(b, node);
-    }
-    int numBlocksLogged = 0;
-    for (BlockInfo b : toAdd) {
-      addStoredBlock(b, node, null, numBlocksLogged < maxNumBlocksToLog);
-      numBlocksLogged++;
-    }
-    if (numBlocksLogged > maxNumBlocksToLog) {
-      blockLog.info("BLOCK* processReport: logged info for " + maxNumBlocksToLog
-          + " of " + numBlocksLogged + " reported.");
-    }
-    for (Block b : toInvalidate) {
-      blockLog.info("BLOCK* processReport: "
-          + b + " on " + node + " size " + b.getNumBytes()
-          + " does not belong to any file");
-      addToInvalidates(b, node);
-    }
-    for (BlockToMarkCorrupt b : toCorrupt) {
-      markBlockAsCorrupt(b, node);
-    }
-  }
-
-  private void reportDiff(DatanodeDescriptor dn, 
-      BlockListAsLongs newReport, 
-      Collection<BlockInfo> toAdd,              // add to DatanodeDescriptor
-      Collection<Block> toRemove,           // remove from DatanodeDescriptor
-      Collection<Block> toInvalidate,       // should be removed from DN
-      Collection<BlockToMarkCorrupt> toCorrupt, // add to corrupt replicas list
-      Collection<StatefulBlockInfo> toUC) { // add to under-construction list
-    // place a delimiter in the list which separates blocks 
-    // that have been reported from those that have not
-    BlockInfo delimiter = new BlockInfo(new Block(), 1);
-    boolean added = dn.addBlock(delimiter);
-    assert added : "Delimiting block cannot be present in the node";
-    int headIndex = 0; //currently the delimiter is in the head of the list
-    int curIndex;
-
-    if (newReport == null)
-      newReport = new BlockListAsLongs();
-    // scan the report and process newly reported blocks
-    BlockReportIterator itBR = newReport.getBlockReportIterator();
-    while(itBR.hasNext()) {
-      Block iblk = itBR.next();
-      ReplicaState iState = itBR.getCurrentReplicaState();
-      BlockInfo storedBlock = processReportedBlock(dn, iblk, iState,
-                                  toAdd, toInvalidate, toCorrupt, toUC);
-      // move block to the head of the list
-      if (storedBlock != null && (curIndex = storedBlock.findDatanode(dn)) >= 0) {
-        headIndex = dn.moveBlockToHead(storedBlock, curIndex, headIndex);
-      }
-    }
-    // collect blocks that have not been reported
-    // all of them are next to the delimiter
-    Iterator<? extends Block> it = new DatanodeDescriptor.BlockIterator(
-        delimiter.getNext(0), dn);
-    while(it.hasNext())
-      toRemove.add(it.next());
-    dn.removeBlock(delimiter);
-  }
-
-  private BlockInfo processReportedBlock(final DatanodeDescriptor dn, 
+  @Override // ReportProcessor
+  BlockInfo processReportedBlock(final DatanodeDescriptor dn, 
+  @Override // ReportProcessor
-  private Block addStoredBlock(final BlockInfo block,
+  @Override // ReportProcessor
+  Block addStoredBlock(final BlockInfo block,
-      blockLog.info("BLOCK* addStoredBlock: " + block + " on "
+      blockLogInfo("#addStoredBlock: " + block + " on "
-      blockLog.warn("BLOCK* addStoredBlock: "
+      blockLogWarn("#addStoredBlock: "
-  private void logAddStoredBlock(BlockInfo storedBlock, DatanodeDescriptor node) {
-    if (!blockLog.isInfoEnabled()) {
-      return;
-    }
-    
-    StringBuilder sb = new StringBuilder(500);
-    sb.append("BLOCK* addStoredBlock: blockMap updated: ")
-      .append(node)
-      .append(" is added to ");
-    storedBlock.appendStringTo(sb);
-    sb.append(" size " )
-      .append(storedBlock.getNumBytes());
-    blockLog.info(sb);
-  }
+
+  @Override // ReportProcessor
+  int moveBlockToHead(DatanodeDescriptor dn, BlockInfo storedBlock,
+      int curIndex, int headIndex) {
+    return dn.moveBlockToHead(storedBlock, curIndex, headIndex);
+  }
+
+  @Override // ReportProcessor
+  boolean addBlock(DatanodeDescriptor dn, BlockInfo block) {
+    return dn.addBlock(block);
+  }
+
+  @Override // ReportProcessor
+  boolean removeBlock(DatanodeDescriptor dn, BlockInfo block) {
+    return dn.removeBlock(block);
+  }
+

MOV31 MOV31 MOV31 INS43 MOV31 UPD42 MOV42 UPD43 INS78 INS78 INS39 INS42 INS78 MOV78 INS78 INS78 INS39 INS42 MOV44 MOV44 INS44 INS44 MOV8 INS78 INS39 INS42 INS44 INS44 INS8 INS78 UPD39 UPD42 INS44 INS8 UPD42 INS46 INS42 INS42 INS42 INS42 INS42 INS39 INS42 INS39 INS42 INS41 INS42 INS43 INS42 MOV43 INS42 INS41 INS42 UPD42 MOV43 INS42 INS41 INS42 INS22 MOV32 UPD42 MOV42 INS32 INS32 INS52 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD45 UPD45 UPD45 DEL40 DEL26 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL42 DEL40 DEL40 DEL32 DEL7 DEL21 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL45 DEL42 DEL42 DEL27 DEL45 DEL45 DEL42 DEL27 DEL16 DEL36 DEL45 DEL27 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL43 DEL42 DEL59 DEL23 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL55 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL45 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL17 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL17 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL55 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL8 DEL31 DEL83 DEL83 DEL42 DEL42 DEL42 DEL7 DEL21 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL40 DEL42 DEL40 DEL32 DEL21 DEL8 DEL70 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL33 DEL42 DEL42 DEL27 DEL32 DEL21 DEL42 DEL37 DEL21 DEL8 DEL70 DEL42 DEL42 DEL27 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL34 DEL14 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL45 DEL6 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL25 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL34 DEL27 DEL27 DEL25 DEL8 DEL61 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL40 DEL43 DEL42 DEL42 DEL34 DEL32 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL61 DEL32 DEL21 DEL8 DEL83 DEL42 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL34 DEL14 DEL59 DEL60 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL45 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8
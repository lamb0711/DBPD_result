HADOOP-13010. Refactor raw erasure coders. Contributed by Kai Zheng

+import org.apache.hadoop.io.erasurecode.ErasureCoderOptions;
- * RawErasureEncoder performs encoding given chunks of input data and generates
- * parity outputs that corresponds to an erasure code scheme, like XOR and
- * Reed-Solomon.
+ * An abstract raw erasure encoder that's to be inherited by new encoders.
- * It extends the {@link RawErasureCoder} interface.
+ * Raw erasure coder is part of erasure codec framework, where erasure coder is
+ * used to encode/decode a group of blocks (BlockGroup) according to the codec
+ * specific BlockGroup layout and logic. An erasure coder extracts chunks of
+ * data from the blocks and can employ various low level raw erasure coders to
+ * perform encoding/decoding against the chunks.
+ *
+ * To distinguish from erasure coder, here raw erasure coder is used to mean the
+ * low level constructs, since it only takes care of the math calculation with
+ * a group of byte buffers.
+ *
+ * Note it mainly provides encode() calls, which should be stateless and may be
+ * made thread-safe in future.
-public interface RawErasureEncoder extends RawErasureCoder {
+public abstract class RawErasureEncoder {
+
+  private final ErasureCoderOptions coderOptions;
+
+  public RawErasureEncoder(ErasureCoderOptions coderOptions) {
+    this.coderOptions = coderOptions;
+  }
-  void encode(ByteBuffer[] inputs, ByteBuffer[] outputs);
+  public void encode(ByteBuffer[] inputs, ByteBuffer[] outputs) {
+    ByteBufferEncodingState bbeState = new ByteBufferEncodingState(
+        this, inputs, outputs);
+
+    boolean usingDirectBuffer = bbeState.usingDirectBuffer;
+    int dataLen = bbeState.encodeLength;
+    if (dataLen == 0) {
+      return;
+    }
+
+    int[] inputPositions = new int[inputs.length];
+    for (int i = 0; i < inputPositions.length; i++) {
+      if (inputs[i] != null) {
+        inputPositions[i] = inputs[i].position();
+      }
+    }
+
+    if (usingDirectBuffer) {
+      doEncode(bbeState);
+    } else {
+      ByteArrayEncodingState baeState = bbeState.convertToByteArrayState();
+      doEncode(baeState);
+    }
+
+    for (int i = 0; i < inputs.length; i++) {
+      if (inputs[i] != null) {
+        // dataLen bytes consumed
+        inputs[i].position(inputPositions[i] + dataLen);
+      }
+    }
+  }
+
+  /**
+   * Perform the real encoding work using direct ByteBuffer.
+   * @param encodingState the encoding state
+   */
+  protected abstract void doEncode(ByteBufferEncodingState encodingState);
-  void encode(byte[][] inputs, byte[][] outputs);
+  public void encode(byte[][] inputs, byte[][] outputs) {
+    ByteArrayEncodingState baeState = new ByteArrayEncodingState(
+        this, inputs, outputs);
+
+    int dataLen = baeState.encodeLength;
+    if (dataLen == 0) {
+      return;
+    }
+
+    doEncode(baeState);
+  }
+
+  /**
+   * Perform the real encoding work using bytes array, supporting offsets
+   * and lengths.
+   * @param encodingState the encoding state
+   */
+  protected abstract void doEncode(ByteArrayEncodingState encodingState);
-  void encode(ECChunk[] inputs, ECChunk[] outputs);
+  public void encode(ECChunk[] inputs, ECChunk[] outputs) {
+    ByteBuffer[] newInputs = ECChunk.toBuffers(inputs);
+    ByteBuffer[] newOutputs = ECChunk.toBuffers(outputs);
+    encode(newInputs, newOutputs);
+  }
+  public int getNumDataUnits() {
+    return coderOptions.getNumDataUnits();
+  }
+
+  public int getNumParityUnits() {
+    return coderOptions.getNumParityUnits();
+  }
+
+  public int getNumAllUnits() {
+    return coderOptions.getNumAllUnits();
+  }
+
+  /**
+   * Tell if direct buffer is preferred or not. It's for callers to
+   * decide how to allocate coding chunk buffers, using DirectByteBuffer or
+   * bytes array. It will return false by default.
+   * @return true if native buffer is preferred for performance consideration,
+   * otherwise false.
+   */
+  public boolean preferDirectBuffer() {
+    return false;
+  }
+
+  /**
+   * Allow change into input buffers or not while perform encoding/decoding.
+   * @return true if it's allowed to change inputs, false otherwise
+   */
+  public boolean allowChangeInputs() {
+    return coderOptions.allowChangeInputs();
+  }
+
+  /**
+   * Allow to dump verbose info during encoding/decoding.
+   * @return true if it's allowed to do verbose dump, false otherwise.
+   */
+  public boolean allowVerboseDump() {
+    return coderOptions.allowVerboseDump();
+  }
+
+  /**
+   * Should be called when release this coder. Good chance to release encoding
+   * or decoding buffers
+   */
+  public void release() {
+    // Nothing to do here.
+  }

INS26 INS40 INS83 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS83 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS83 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS83 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS66 INS66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 INS66 UPD66 UPD42 MOV42 INS42 INS43 INS42 INS21 INS60 INS60 INS60 INS25 INS60 INS24 INS25 INS24 INS65 INS65 INS43 INS42 INS60 INS60 INS25 INS21 INS65 INS65 INS43 INS42 INS60 INS60 INS21 INS41 INS41 INS41 INS65 INS65 INS41 INS65 INS65 INS41 INS65 INS65 INS41 INS65 INS42 INS7 INS43 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS8 INS8 INS58 INS27 INS37 INS8 INS66 INS42 INS66 INS42 INS43 INS59 INS39 INS59 INS27 INS8 INS32 INS66 INS66 INS42 INS66 INS42 INS5 INS59 INS5 INS59 INS32 INS32 INS32 INS32 INS66 INS66 INS66 INS66 INS66 INS9 INS66 INS66 INS32 INS66 INS66 INS32 INS66 INS66 INS22 INS42 INS42 INS42 INS14 INS42 INS40 INS42 INS40 INS42 INS34 INS41 INS39 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS25 INS21 INS60 INS21 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS42 INS14 INS42 INS40 INS42 INS34 INS41 INS42 INS42 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS43 INS52 INS42 INS42 INS5 INS40 INS42 INS34 INS27 INS8 INS32 INS43 INS59 INS32 INS42 INS34 INS27 INS8 INS43 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS2 INS33 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS2 INS33 INS21 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS32 INS2 INS32 INS2 INS42 INS27 INS42 INS42 INS2 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS42 DEL42 DEL65 DEL43
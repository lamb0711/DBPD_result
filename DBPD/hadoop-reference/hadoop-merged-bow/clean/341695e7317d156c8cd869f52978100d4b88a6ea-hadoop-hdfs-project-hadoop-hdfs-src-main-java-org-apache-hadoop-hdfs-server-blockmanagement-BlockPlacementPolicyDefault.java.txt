Merge trunk into branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/MR-2841@1612742 13f79535-47bb-0310-9956-ffa450edef68

-      for (int i = 0; i < Math.min(favoredNodes.size(), numOfReplicas); i++) {
+      for (int i = 0; i < favoredNodes.size() && results.size() < numOfReplicas; i++) {
-            results, avoidStaleNodes, storageType);
+            results, avoidStaleNodes, storageType, false);
-            maxNodesPerRack, results, avoidStaleNodes, storageType)
+            maxNodesPerRack, results, avoidStaleNodes, storageType, true)
-                                             StorageType storageType)
+                                             StorageType storageType,
+                                             boolean fallbackToLocalRack)
-    if (localMachine == null)
+    if (localMachine == null) {
+    }
-    }      
+    }
+
+    if (!fallbackToLocalRack) {
+      return null;
+    }
-      double avgLoad = 0;
-      if (stats != null) {
-        int size = stats.getNumDatanodesInService();
-        if (size != 0) {
-          avgLoad = (double)stats.getTotalLoad()/size;
-        }
-      }
-      if (node.getXceiverCount() > (2.0 * avgLoad)) {
-        logNodeIsNotChosen(storage, "the node is too busy ");
+      final double maxLoad = 2.0 * stats.getInServiceXceiverAverage();
+      final int nodeLoad = node.getXceiverCount();
+      if (nodeLoad > maxLoad) {
+        logNodeIsNotChosen(storage,
+            "the node is too busy (load:"+nodeLoad+" > "+maxLoad+") ");
-  public DatanodeDescriptor chooseReplicaToDelete(BlockCollection bc,
+  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,
-      Collection<DatanodeDescriptor> first,
-      Collection<DatanodeDescriptor> second) {
+      Collection<DatanodeStorageInfo> first,
+      Collection<DatanodeStorageInfo> second) {
-    DatanodeDescriptor oldestHeartbeatNode = null;
+    DatanodeStorageInfo oldestHeartbeatStorage = null;
-    DatanodeDescriptor minSpaceNode = null;
+    DatanodeStorageInfo minSpaceStorage = null;
-    for(DatanodeDescriptor node : pickupReplicaSet(first, second)) {
+    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {
+      final DatanodeDescriptor node = storage.getDatanodeDescriptor();
-        oldestHeartbeatNode = node;
+        oldestHeartbeatStorage = storage;
-        minSpaceNode = node;
+        minSpaceStorage = storage;
-    return oldestHeartbeatNode != null ? oldestHeartbeatNode : minSpaceNode;
+
+    return oldestHeartbeatStorage != null? oldestHeartbeatStorage
+        : minSpaceStorage;
-  protected Collection<DatanodeDescriptor> pickupReplicaSet(
-      Collection<DatanodeDescriptor> first,
-      Collection<DatanodeDescriptor> second) {
+  protected Collection<DatanodeStorageInfo> pickupReplicaSet(
+      Collection<DatanodeStorageInfo> first,
+      Collection<DatanodeStorageInfo> second) {

MOV44 INS44 UPD43 UPD74 MOV74 INS39 INS42 INS25 UPD42 UPD74 UPD74 UPD43 UPD74 UPD42 UPD74 MOV74 UPD42 INS8 INS38 INS8 UPD43 INS43 UPD43 UPD43 UPD42 UPD43 UPD43 MOV41 INS42 INS41 MOV60 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 INS60 UPD42 UPD42 UPD42 UPD42 INS27 INS33 INS83 INS83 UPD42 INS83 MOV43 INS59 UPD42 MOV27 INS27 UPD42 INS27 INS42 MOV32 INS42 UPD42 MOV42 INS42 INS32 MOV32 INS32 INS42 INS34 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS27 UPD42 UPD42 UPD42 UPD42 INS9 INS45 INS42 INS45 INS42 INS45 INS9 DEL42 DEL42 DEL42 DEL32 DEL34 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL34 DEL27 DEL42 DEL39 DEL42 DEL42 DEL32 DEL11 DEL42 DEL27 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL34 DEL27 DEL36 DEL45
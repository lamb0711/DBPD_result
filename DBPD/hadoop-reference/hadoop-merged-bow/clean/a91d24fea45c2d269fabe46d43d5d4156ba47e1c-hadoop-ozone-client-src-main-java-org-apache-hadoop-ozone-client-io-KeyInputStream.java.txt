HDDS-1496. Support partial chunk reads and checksum verification (#804)


-import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos;
-import org.apache.hadoop.hdds.client.BlockID;
-import org.apache.hadoop.hdds.protocol.proto.HddsProtos;
-import org.apache.hadoop.hdds.scm.pipeline.Pipeline;
-import org.apache.hadoop.hdds.scm.protocol.StorageContainerLocationProtocol;
+import org.apache.hadoop.hdds.scm.XceiverClientManager;
+import org.apache.hadoop.hdds.scm.storage.BlockInputStream;
-import org.apache.hadoop.hdds.scm.XceiverClientManager;
-import org.apache.hadoop.hdds.scm.XceiverClientSpi;
-import org.apache.hadoop.hdds.scm.storage.BlockInputStream;
-import org.apache.hadoop.hdds.scm.storage.ContainerProtocolCalls;
-import org.apache.hadoop.security.UserGroupInformation;
-import org.apache.ratis.util.Preconditions;
-  private final ArrayList<ChunkInputStreamEntry> streamEntries;
-  // streamOffset[i] stores the offset at which blockInputStream i stores
-  // data in the key
-  private long[] streamOffset = null;
-  private int currentStreamIndex;
+  private String key;
-  private String key;
+
+  // List of BlockInputStreams, one for each block in the key
+  private final List<BlockInputStream> blockStreams;
+
+  // blockOffsets[i] stores the index of the first data byte in
+  // blockStream w.r.t the key data.
+  // For example, let’s say the block size is 200 bytes and block[0] stores
+  // data from indices 0 - 199, block[1] from indices 200 - 399 and so on.
+  // Then, blockOffset[0] = 0 (the offset of the first byte of data in
+  // block[0]), blockOffset[1] = 200 and so on.
+  private long[] blockOffsets = null;
+
+  // Index of the blockStream corresponding to the current position of the
+  // KeyInputStream i.e. offset of the data to be read next
+  private int blockIndex;
+
+  // Tracks the blockIndex corresponding to the last seeked position so that it
+  // can be reset if a new position is seeked.
+  private int blockIndexOfPrevPosition;
-    streamEntries = new ArrayList<>();
-    currentStreamIndex = 0;
-  }
-
-  @VisibleForTesting
-  public synchronized int getCurrentStreamIndex() {
-    return currentStreamIndex;
-  }
-
-  @VisibleForTesting
-  public long getRemainingOfIndex(int index) throws IOException {
-    return streamEntries.get(index).getRemaining();
+    blockStreams = new ArrayList<>();
+    blockIndex = 0;
-   * Append another stream to the end of the list.
-   *
-   * @param stream       the stream instance.
-   * @param streamLength the max number of bytes that should be written to this
-   *                     stream.
+   * For each block in keyInfo, add a BlockInputStream to blockStreams.
-  @VisibleForTesting
-  public synchronized void addStream(BlockInputStream stream,
-      long streamLength) {
-    streamEntries.add(new ChunkInputStreamEntry(stream, streamLength));
+  public static LengthInputStream getFromOmKeyInfo(OmKeyInfo keyInfo,
+      XceiverClientManager xceiverClientManager, String requestId,
+      boolean verifyChecksum) {
+    List<OmKeyLocationInfo> keyLocationInfos = keyInfo
+        .getLatestVersionLocations().getBlocksLatestVersionOnly();
+
+    KeyInputStream keyInputStream = new KeyInputStream();
+    keyInputStream.initialize(keyInfo.getKeyName(), keyLocationInfos,
+        xceiverClientManager, requestId, verifyChecksum);
+
+    return new LengthInputStream(keyInputStream, keyInputStream.length);
+  }
+
+  private synchronized void initialize(String keyName,
+      List<OmKeyLocationInfo> blockInfos,
+      XceiverClientManager xceiverClientManager, String requestId,
+      boolean verifyChecksum) {
+    this.key = keyName;
+    this.blockOffsets = new long[blockInfos.size()];
+    long keyLength = 0;
+    for (int i = 0; i < blockInfos.size(); i++) {
+      OmKeyLocationInfo omKeyLocationInfo = blockInfos.get(i);
+      LOG.debug("Adding stream for accessing {}. The stream will be " +
+          "initialized later.", omKeyLocationInfo);
+
+      addStream(omKeyLocationInfo, xceiverClientManager, requestId,
+          verifyChecksum);
+
+      this.blockOffsets[i] = keyLength;
+      keyLength += omKeyLocationInfo.getLength();
+    }
+    this.length = keyLength;
-   * Append another ChunkInputStreamEntry to the end of the list.
-   * The stream will be constructed from the input information when it needs
-   * to be accessed.
+   * Append another BlockInputStream to the end of the list. Note that the
+   * BlockInputStream is only created here and not initialized. The
+   * BlockInputStream is initialized when a read operation is performed on
+   * the block for the first time.
-  private synchronized void addStream(OmKeyLocationInfo omKeyLocationInfo,
+  private synchronized void addStream(OmKeyLocationInfo blockInfo,
-    streamEntries.add(new ChunkInputStreamEntry(omKeyLocationInfo,
-        xceiverClientMngr, clientRequestId, verifyChecksum));
+    blockStreams.add(new BlockInputStream(blockInfo.getBlockID(),
+        blockInfo.getLength(), blockInfo.getPipeline(), blockInfo.getToken(),
+        verifyChecksum, clientRequestId, xceiverClientMngr));
-  private synchronized ChunkInputStreamEntry getStreamEntry(int index)
-      throws IOException {
-    return streamEntries.get(index).getStream();
+  @VisibleForTesting
+  public void addStream(BlockInputStream blockInputStream) {
+    blockStreams.add(blockInputStream);
+  /**
+   * {@inheritDoc}
+   */
+  /**
+   * {@inheritDoc}
+   */
-    checkNotClosed();
+    checkOpen();
-      if (streamEntries.size() == 0 ||
-              (streamEntries.size() - 1 <= currentStreamIndex &&
-                      streamEntries.get(currentStreamIndex)
-                              .getRemaining() == 0)) {
+      if (blockStreams.size() == 0 ||
+          (blockStreams.size() - 1 <= blockIndex &&
+              blockStreams.get(blockIndex)
+                  .getRemaining() == 0)) {
-      ChunkInputStreamEntry current = getStreamEntry(currentStreamIndex);
+
+      // Get the current blockStream and read data from it
+      BlockInputStream current = blockStreams.get(blockIndex);
-            current.blockInputStream.getBlockID(), current.length,
-            numBytesRead));
+            current.getBlockID(), current.getLength(), numBytesRead));
-          ((currentStreamIndex + 1) < streamEntries.size())) {
-        currentStreamIndex += 1;
+          ((blockIndex + 1) < blockStreams.size())) {
+        blockIndex += 1;
+  /**
+   * Seeks the KeyInputStream to the specified position. This involves 2 steps:
+   *    1. Updating the blockIndex to the blockStream corresponding to the
+   *    seeked position.
+   *    2. Seeking the corresponding blockStream to the adjusted position.
+   *
+   * For example, let’s say the block size is 200 bytes and block[0] stores
+   * data from indices 0 - 199, block[1] from indices 200 - 399 and so on.
+   * Let’s say we seek to position 240. In the first step, the blockIndex
+   * would be updated to 1 as indices 200 - 399 reside in blockStream[1]. In
+   * the second step, the blockStream[1] would be seeked to position 40 (=
+   * 240 - blockOffset[1] (= 200)).
+   */
-  public void seek(long pos) throws IOException {
-    checkNotClosed();
+  public synchronized void seek(long pos) throws IOException {
+    checkOpen();
-    Preconditions.assertTrue(currentStreamIndex >= 0);
-    if (currentStreamIndex >= streamEntries.size()) {
-      currentStreamIndex = Arrays.binarySearch(streamOffset, pos);
-    } else if (pos < streamOffset[currentStreamIndex]) {
-      currentStreamIndex =
-          Arrays.binarySearch(streamOffset, 0, currentStreamIndex, pos);
-    } else if (pos >= streamOffset[currentStreamIndex] + streamEntries
-        .get(currentStreamIndex).length) {
-      currentStreamIndex = Arrays
-          .binarySearch(streamOffset, currentStreamIndex + 1,
-              streamEntries.size(), pos);
+
+    // 1. Update the blockIndex
+    if (blockIndex >= blockStreams.size()) {
+      blockIndex = Arrays.binarySearch(blockOffsets, pos);
+    } else if (pos < blockOffsets[blockIndex]) {
+      blockIndex =
+          Arrays.binarySearch(blockOffsets, 0, blockIndex, pos);
+    } else if (pos >= blockOffsets[blockIndex] + blockStreams
+        .get(blockIndex).getLength()) {
+      blockIndex = Arrays
+          .binarySearch(blockOffsets, blockIndex + 1,
+              blockStreams.size(), pos);
-    if (currentStreamIndex < 0) {
+    if (blockIndex < 0) {
-      // inserted in the sorted array. We need to adjust the currentStreamIndex
-      // accordingly so that currentStreamIndex = insertionPoint - 1
-      currentStreamIndex = -currentStreamIndex - 2;
+      // inserted in the sorted array. We need to adjust the blockIndex
+      // accordingly so that blockIndex = insertionPoint - 1
+      blockIndex = -blockIndex - 2;
-    // seek to the proper offset in the BlockInputStream
-    streamEntries.get(currentStreamIndex)
-        .seek(pos - streamOffset[currentStreamIndex]);
+
+    // Reset the previous blockStream's position
+    blockStreams.get(blockIndexOfPrevPosition).resetPosition();
+
+    // 2. Seek the blockStream to the adjusted position
+    blockStreams.get(blockIndex).seek(pos - blockOffsets[blockIndex]);
+    blockIndexOfPrevPosition = blockIndex;
-  public long getPos() throws IOException {
-    return length == 0 ? 0 :
-        streamOffset[currentStreamIndex] + streamEntries.get(currentStreamIndex)
-            .getPos();
+  public synchronized long getPos() throws IOException {
+    return length == 0 ? 0 : blockOffsets[blockIndex] +
+        blockStreams.get(blockIndex).getPos();
-    checkNotClosed();
+    checkOpen();
-    for (int i = 0; i < streamEntries.size(); i++) {
-      streamEntries.get(i).close();
+    for (BlockInputStream blockStream : blockStreams) {
+      blockStream.close();
-   * Encapsulates BlockInputStream.
-   */
-  public static class ChunkInputStreamEntry extends InputStream
-      implements Seekable {
-
-    private BlockInputStream blockInputStream;
-    private final OmKeyLocationInfo blockLocationInfo;
-    private final long length;
-    private final XceiverClientManager xceiverClientManager;
-    private final String requestId;
-    private boolean verifyChecksum;
-
-    // the position of the blockInputStream is maintained by this variable
-    // till the stream is initialized
-    private long position;
-
-    public ChunkInputStreamEntry(OmKeyLocationInfo omKeyLocationInfo,
-        XceiverClientManager xceiverClientMngr, String clientRequestId,
-        boolean verifyChecksum) {
-      this.blockLocationInfo = omKeyLocationInfo;
-      this.length = omKeyLocationInfo.getLength();
-      this.xceiverClientManager = xceiverClientMngr;
-      this.requestId = clientRequestId;
-      this.verifyChecksum = verifyChecksum;
-    }
-
-    @VisibleForTesting
-    public ChunkInputStreamEntry(BlockInputStream blockInputStream,
-        long length) {
-      this.blockInputStream = blockInputStream;
-      this.length = length;
-      this.blockLocationInfo = null;
-      this.xceiverClientManager = null;
-      this.requestId = null;
-    }
-
-    private ChunkInputStreamEntry getStream() throws IOException {
-      if (this.blockInputStream == null) {
-        initializeBlockInputStream();
-      }
-      return this;
-    }
-
-    private void initializeBlockInputStream() throws IOException {
-      BlockID blockID = blockLocationInfo.getBlockID();
-      long containerID = blockID.getContainerID();
-      Pipeline pipeline = blockLocationInfo.getPipeline();
-
-      // irrespective of the container state, we will always read via Standalone
-      // protocol.
-      if (pipeline.getType() != HddsProtos.ReplicationType.STAND_ALONE) {
-        pipeline = Pipeline.newBuilder(pipeline)
-            .setType(HddsProtos.ReplicationType.STAND_ALONE).build();
-      }
-      XceiverClientSpi xceiverClient = xceiverClientManager
-          .acquireClient(pipeline);
-      boolean success = false;
-      long containerKey = blockLocationInfo.getLocalID();
-      try {
-        LOG.debug("Initializing stream for get key to access {} {}",
-            containerID, containerKey);
-        ContainerProtos.DatanodeBlockID datanodeBlockID = blockID
-            .getDatanodeBlockIDProtobuf();
-        if (blockLocationInfo.getToken() != null) {
-          UserGroupInformation.getCurrentUser().
-              addToken(blockLocationInfo.getToken());
-        }
-        ContainerProtos.GetBlockResponseProto response = ContainerProtocolCalls
-            .getBlock(xceiverClient, datanodeBlockID, requestId);
-        List<ContainerProtos.ChunkInfo> chunks =
-            response.getBlockData().getChunksList();
-        success = true;
-        this.blockInputStream = new BlockInputStream(
-            blockLocationInfo.getBlockID(), xceiverClientManager, xceiverClient,
-            chunks, requestId, verifyChecksum, position);
-      } finally {
-        if (!success) {
-          xceiverClientManager.releaseClient(xceiverClient, false);
-        }
-      }
-    }
-
-    synchronized long getRemaining() throws IOException {
-      return length - getPos();
-    }
-
-    @Override
-    public synchronized int read(byte[] b, int off, int len)
-        throws IOException {
-      int readLen = blockInputStream.read(b, off, len);
-      return readLen;
-    }
-
-    @Override
-    public synchronized int read() throws IOException {
-      int data = blockInputStream.read();
-      return data;
-    }
-
-    @Override
-    public synchronized void close() throws IOException {
-      if (blockInputStream != null) {
-        blockInputStream.close();
-      }
-    }
-
-    @Override
-    public void seek(long pos) throws IOException {
-      if (blockInputStream != null) {
-        blockInputStream.seek(pos);
-      } else {
-        position = pos;
-      }
-    }
-
-    @Override
-    public long getPos() throws IOException {
-      if (blockInputStream != null) {
-        return blockInputStream.getPos();
-      } else {
-        return position;
-      }
-    }
-
-    @Override
-    public boolean seekToNewSource(long targetPos) throws IOException {
-      return false;
-    }
-  }
-
-  public static LengthInputStream getFromOmKeyInfo(
-      OmKeyInfo keyInfo,
-      XceiverClientManager xceiverClientManager,
-      StorageContainerLocationProtocol
-          storageContainerLocationClient,
-      String requestId, boolean verifyChecksum) throws IOException {
-    long length = 0;
-    KeyInputStream groupInputStream = new KeyInputStream();
-    groupInputStream.key = keyInfo.getKeyName();
-    List<OmKeyLocationInfo> keyLocationInfos =
-        keyInfo.getLatestVersionLocations().getBlocksLatestVersionOnly();
-    groupInputStream.streamOffset = new long[keyLocationInfos.size()];
-    for (int i = 0; i < keyLocationInfos.size(); i++) {
-      OmKeyLocationInfo omKeyLocationInfo = keyLocationInfos.get(i);
-      LOG.debug("Adding stream for accessing {}. The stream will be " +
-          "initialized later.", omKeyLocationInfo);
-      groupInputStream.addStream(omKeyLocationInfo, xceiverClientManager,
-          requestId, verifyChecksum);
-
-      groupInputStream.streamOffset[i] = length;
-      length += omKeyLocationInfo.getLength();
-    }
-    groupInputStream.length = length;
-    return new LengthInputStream(groupInputStream, length);
-  }
-
-  /**
-  private void checkNotClosed() throws IOException {
+  private void checkOpen() throws IOException {
+
+  @VisibleForTesting
+  public synchronized int getCurrentStreamIndex() {
+    return blockIndex;
+  }
+
+  @VisibleForTesting
+  public long getRemainingOfIndex(int index) throws IOException {
+    return blockStreams.get(index).getRemaining();
+  }

MOV26 MOV26 MOV23 MOV23 MOV23 MOV31 INS23 INS31 MOV31 MOV31 UPD74 INS83 INS39 INS59 INS29 INS8 UPD83 MOV83 INS83 UPD39 MOV39 UPD42 MOV42 MOV44 INS44 INS44 INS44 MOV44 INS8 MOV44 MOV44 MOV78 UPD83 INS39 UPD42 MOV44 INS29 INS29 INS29 INS83 INS83 UPD42 MOV78 UPD42 MOV78 INS39 INS42 MOV44 MOV43 UPD43 MOV43 UPD42 UPD42 UPD42 INS42 INS65 MOV60 MOV60 MOV21 MOV41 MOV43 UPD42 UPD74 MOV74 INS42 INS43 INS42 INS43 INS42 INS21 MOV21 INS60 INS24 MOV21 UPD42 INS21 INS65 INS65 INS65 INS21 INS21 INS70 INS41 UPD42 INS66 MOV43 UPD42 MOV42 INS42 INS7 INS39 INS59 MOV58 INS27 MOV37 INS8 UPD66 INS66 UPD66 UPD66 INS32 INS65 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS32 INS7 INS44 INS42 INS8 UPD42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 INS40 INS22 INS42 INS22 INS42 INS34 INS42 INS32 INS60 MOV21 MOV21 INS21 INS21 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS32 INS42 INS42 INS42 UPD42 MOV43 INS42 MOV21 INS32 INS42 INS52 INS42 INS52 INS42 INS42 INS42 MOV43 INS59 INS7 INS7 MOV43 INS32 INS32 INS32 INS32 UPD42 UPD42 UPD43 UPD42 INS42 INS42 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS32 UPD42 UPD42 INS42 INS42 INS42 INS2 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 INS42 INS22 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 INS42 UPD42 UPD42 UPD42 INS32 UPD42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL39 DEL42 DEL34 DEL59 DEL60 DEL40 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL2 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL40 DEL42 DEL7 DEL21 DEL8 DEL39 DEL40 DEL43 DEL40 DEL42 DEL43 DEL42 DEL42 DEL14 DEL83 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL42 DEL44 DEL39 DEL42 DEL44 DEL8 DEL31 DEL42 DEL44 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL32 DEL41 DEL40 DEL40 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL21 DEL32 DEL42 DEL22 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL8 DEL24 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL83 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL32 DEL21 DEL8 DEL25 DEL52 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL40 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL38 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL27 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL41 DEL8 DEL25 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL9 DEL41 DEL8 DEL31 DEL55 DEL42 DEL78 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL78 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL27 DEL32 DEL21 DEL8 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25
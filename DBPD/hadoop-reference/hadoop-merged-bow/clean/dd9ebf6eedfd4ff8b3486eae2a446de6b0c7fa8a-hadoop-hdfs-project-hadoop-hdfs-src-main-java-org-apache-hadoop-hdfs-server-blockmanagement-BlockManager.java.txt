HDFS-9260. Improve the performance and GC friendliness of NameNode startup and full block reports (Staffan Friberg via cmccabe)

+import org.apache.hadoop.hdfs.protocol.HdfsConstants.DatanodeReportType;
+import org.apache.hadoop.hdfs.util.FoldedTreeSet;
+import org.apache.hadoop.util.VersionInfo;
-  
+
+  /** How often to check and the limit for the storageinfo efficiency. */
+  private final long storageInfoDefragmentInterval;
+  private final long storageInfoDefragmentTimeout;
+  private final double storageInfoDefragmentRatio;
+
+
+  /** StorageInfoDefragmenter thread. */
+  private final Daemon storageInfoDefragmenterThread =
+      new Daemon(new StorageInfoDefragmenter());
-    
+
+    this.storageInfoDefragmentInterval =
+      conf.getLong(
+          DFSConfigKeys.DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_INTERVAL_MS_KEY,
+          DFSConfigKeys.DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_INTERVAL_MS_DEFAULT);
+    this.storageInfoDefragmentTimeout =
+      conf.getLong(
+          DFSConfigKeys.DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_TIMEOUT_MS_KEY,
+          DFSConfigKeys.DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_TIMEOUT_MS_DEFAULT);
+    this.storageInfoDefragmentRatio =
+      conf.getDouble(
+          DFSConfigKeys.DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_RATIO_KEY,
+          DFSConfigKeys.DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_RATIO_DEFAULT);
+
+    storageInfoDefragmenterThread.setName("StorageInfoMonitor");
+    storageInfoDefragmenterThread.start();
+      storageInfoDefragmenterThread.interrupt();
+      storageInfoDefragmenterThread.join(3000);
-    final Iterator<BlockInfo> it = node.getBlockIterator();
-    while(it.hasNext()) {
-      removeStoredBlock(it.next(), node);
+    for (DatanodeStorageInfo storage : node.getStorageInfos()) {
+      final Iterator<BlockInfo> it = storage.getBlockIterator();
+      while (it.hasNext()) {
+        BlockInfo block = it.next();
+        // DatanodeStorageInfo must be removed using the iterator to avoid
+        // ConcurrentModificationException in the underlying storage
+        it.remove();
+        removeStoredBlock(block, node);
+      }
+      // DatanodeStorageInfo must be removed using the iterator to avoid
+      // ConcurrentModificationException in the underlying storage
+      it.remove();
-      final BlockListAsLongs newReport, BlockReportContext context,
-      boolean lastStorageInRpc) throws IOException {
+      final BlockListAsLongs newReport,
+      BlockReportContext context, boolean lastStorageInRpc) throws IOException {
-        invalidatedBlocks = processReport(storageInfo, newReport);
+        invalidatedBlocks = processReport(storageInfo, newReport,
+            context != null ? context.isSorted() : false);
+      // DatanodeStorageInfo must be removed using the iterator to avoid
+      // ConcurrentModificationException in the underlying storage
+      iter.remove();
-      final BlockListAsLongs report) throws IOException {
+      final BlockListAsLongs report, final boolean sorted) throws IOException {
-    reportDiff(storageInfo, report,
-        toAdd, toRemove, toInvalidate, toCorrupt, toUC);
-   
+
+    Iterable<BlockReportReplica> sortedReport;
+    if (!sorted) {
+      blockLog.warn("BLOCK* processReport: Report from the DataNode ({}) is "
+                    + "unsorted. This will cause overhead on the NameNode "
+                    + "which needs to sort the Full BR. Please update the "
+                    + "DataNode to the same version of Hadoop HDFS as the "
+                    + "NameNode ({}).",
+                    storageInfo.getDatanodeDescriptor().getDatanodeUuid(),
+                    VersionInfo.getVersion());
+      Set<BlockReportReplica> set = new FoldedTreeSet<>();
+      for (BlockReportReplica iblk : report) {
+        set.add(new BlockReportReplica(iblk));
+      }
+      sortedReport = set;
+    } else {
+      sortedReport = report;
+    }
+
+    reportDiffSorted(storageInfo, sortedReport,
+                     toAdd, toRemove, toInvalidate, toCorrupt, toUC);
+
+
-  private void reportDiff(DatanodeStorageInfo storageInfo, 
-      BlockListAsLongs newReport,
+  private void reportDiffSorted(DatanodeStorageInfo storageInfo,
+      Iterable<BlockReportReplica> newReport,
-    // place a delimiter in the list which separates blocks 
-    // that have been reported from those that have not
-    Block delimiterBlock = new Block();
-    BlockInfo delimiter = new BlockInfoContiguous(delimiterBlock,
-        (short) 1);
-    AddBlockResult result = storageInfo.addBlock(delimiter, delimiterBlock);
-    assert result == AddBlockResult.ADDED 
-        : "Delimiting block cannot be present in the node";
-    int headIndex = 0; //currently the delimiter is in the head of the list
-    int curIndex;
+    // The blocks must be sorted and the storagenodes blocks must be sorted
+    Iterator<BlockInfo> storageBlocksIterator = storageInfo.getBlockIterator();
+    DatanodeDescriptor dn = storageInfo.getDatanodeDescriptor();
+    BlockInfo storageBlock = null;
-    if (newReport == null) {
-      newReport = BlockListAsLongs.EMPTY;
-    }
-    // scan the report and process newly reported blocks
-    for (BlockReportReplica iblk : newReport) {
-      ReplicaState iState = iblk.getState();
-      BlockInfo storedBlock = processReportedBlock(storageInfo,
-          iblk, iState, toAdd, toInvalidate, toCorrupt, toUC);
+    for (BlockReportReplica replica : newReport) {
-      // move block to the head of the list
-      if (storedBlock != null &&
-          (curIndex = storedBlock.findStorageInfo(storageInfo)) >= 0) {
-        headIndex = storageInfo.moveBlockToHead(storedBlock, curIndex, headIndex);
+      long replicaID = replica.getBlockId();
+      if (BlockIdManager.isStripedBlockID(replicaID)
+          && (!hasNonEcBlockUsingStripedID ||
+              !blocksMap.containsBlock(replica))) {
+        replicaID = BlockIdManager.convertToStripedID(replicaID);
+
+      ReplicaState reportedState = replica.getState();
+
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Reported block " + replica
+                  + " on " + dn + " size " + replica.getNumBytes()
+                  + " replicaState = " + reportedState);
+      }
+
+      if (shouldPostponeBlocksFromFuture
+          && isGenStampInFuture(replica)) {
+        queueReportedBlock(storageInfo, replica, reportedState,
+                           QUEUE_REASON_FUTURE_GENSTAMP);
+        continue;
+      }
+
+      if (storageBlock == null && storageBlocksIterator.hasNext()) {
+        storageBlock = storageBlocksIterator.next();
+      }
+
+      do {
+        int cmp;
+        if (storageBlock == null ||
+            (cmp = Long.compare(replicaID, storageBlock.getBlockId())) < 0) {
+          // Check if block is available in NN but not yet on this storage
+          BlockInfo nnBlock = blocksMap.getStoredBlock(new Block(replicaID));
+          if (nnBlock != null) {
+            reportDiffSortedInner(storageInfo, replica, reportedState,
+                                  nnBlock, toAdd, toCorrupt, toUC);
+          } else {
+            // Replica not found anywhere so it should be invalidated
+            toInvalidate.add(new Block(replica));
+          }
+          break;
+        } else if (cmp == 0) {
+          // Replica matched current storageblock
+          reportDiffSortedInner(storageInfo, replica, reportedState,
+                                storageBlock, toAdd, toCorrupt, toUC);
+          storageBlock = null;
+        } else {
+          // replica has higher ID than storedBlock
+          // Remove all stored blocks with IDs lower than replica
+          do {
+            toRemove.add(storageBlock);
+            storageBlock = storageBlocksIterator.hasNext()
+                           ? storageBlocksIterator.next() : null;
+          } while (storageBlock != null &&
+                   Long.compare(replicaID, storageBlock.getBlockId()) > 0);
+        }
+      } while (storageBlock != null);
-    // collect blocks that have not been reported
-    // all of them are next to the delimiter
-    Iterator<BlockInfo> it =
-        storageInfo.new BlockIterator(delimiter.getNext(0));
-    while (it.hasNext()) {
-      toRemove.add(it.next());
+    // Iterate any remaing blocks that have not been reported and remove them
+    while (storageBlocksIterator.hasNext()) {
+      toRemove.add(storageBlocksIterator.next());
-    storageInfo.removeBlock(delimiter);
-  /**
-   * Process a block replica reported by the data-node.
-   * No side effects except adding to the passed-in Collections.
-   * 
-   * <ol>
-   * <li>If the block is not known to the system (not in blocksMap) then the
-   * data-node should be notified to invalidate this block.</li>
-   * <li>If the reported replica is valid that is has the same generation stamp
-   * and length as recorded on the name-node, then the replica location should
-   * be added to the name-node.</li>
-   * <li>If the reported replica is not valid, then it is marked as corrupt,
-   * which triggers replication of the existing valid replicas.
-   * Corrupt replicas are removed from the system when the block
-   * is fully replicated.</li>
-   * <li>If the reported replica is for a block currently marked "under
-   * construction" in the NN, then it should be added to the 
-   * BlockUnderConstructionFeature's list of replicas.</li>
-   * </ol>
-   * 
-   * @param storageInfo DatanodeStorageInfo that sent the report.
-   * @param block reported block replica
-   * @param reportedState reported replica state
-   * @param toAdd add to DatanodeDescriptor
-   * @param toInvalidate missing blocks (not in the blocks map)
-   *        should be removed from the data-node
-   * @param toCorrupt replicas with unexpected length or generation stamp;
-   *        add to corrupt replicas
-   * @param toUC replicas of blocks currently under construction
-   * @return the up-to-date stored block, if it should be kept.
-   *         Otherwise, null.
-   */
-  private BlockInfo processReportedBlock(
+  private void reportDiffSortedInner(
-      final Block block, final ReplicaState reportedState,
+      final BlockReportReplica replica, final ReplicaState reportedState,
+      final BlockInfo storedBlock,
-      final Collection<Block> toInvalidate, 
-    
-    DatanodeDescriptor dn = storageInfo.getDatanodeDescriptor();
-    if(LOG.isDebugEnabled()) {
-      LOG.debug("Reported block " + block
-          + " on " + dn + " size " + block.getNumBytes()
-          + " replicaState = " + reportedState);
-    }
-  
-    if (shouldPostponeBlocksFromFuture && isGenStampInFuture(block)) {
-      queueReportedBlock(storageInfo, block, reportedState,
-          QUEUE_REASON_FUTURE_GENSTAMP);
-      return null;
-    }
-    
-    // find block by blockId
-    BlockInfo storedBlock = getStoredBlock(block);
-    if(storedBlock == null) {
-      // If blocksMap does not contain reported block id,
-      // the replica should be removed from the data-node.
-      toInvalidate.add(new Block(block));
-      return null;
-    }
+    assert replica != null;
+    assert storedBlock != null;
+
+    DatanodeDescriptor dn = storageInfo.getDatanodeDescriptor();
-    
+
-    if(LOG.isDebugEnabled()) {
+    if (LOG.isDebugEnabled()) {
-    if(invalidateBlocks.contains(dn, block)) {
-      return storedBlock;
+    if (invalidateBlocks.contains(dn, replica)) {
+      return;
-    BlockToMarkCorrupt c = checkReplicaCorrupt(
-        block, reportedState, storedBlock, ucState, dn);
+    BlockToMarkCorrupt c = checkReplicaCorrupt(replica, reportedState,
+                                               storedBlock, ucState, dn);
-      return storedBlock;
+    } else if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {
+      toUC.add(new StatefulBlockInfo(storedBlock, new Block(replica),
+          reportedState));
+    } else if (reportedState == ReplicaState.FINALIZED &&
+               (storedBlock.findStorageInfo(storageInfo) == -1 ||
+                corruptReplicas.isReplicaCorrupt(storedBlock, dn))) {
+      // Add replica if appropriate. If the replica was previously corrupt
+      // but now okay, it might need to be updated.
+      toAdd.add(new BlockInfoToAdd(storedBlock, replica));
-
-    if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {
-      toUC.add(new StatefulBlockInfo(storedBlock,
-          new Block(block), reportedState));
-      return storedBlock;
-    }
-
-    // Add replica if appropriate. If the replica was previously corrupt
-    // but now okay, it might need to be updated.
-    if (reportedState == ReplicaState.FINALIZED
-        && (storedBlock.findStorageInfo(storageInfo) == -1 ||
-            corruptReplicas.isReplicaCorrupt(storedBlock, dn))) {
-      toAdd.add(new BlockInfoToAdd(storedBlock, block));
-    }
-    return storedBlock;
-    AddBlockResult result = storageInfo.addBlock(storedBlock, reported);
+    AddBlockResult result = storageInfo.addBlockInitial(storedBlock, reported);
-    // blockReceived reports a finalized block
-    Collection<BlockInfoToAdd> toAdd = new LinkedList<>();
-    Collection<Block> toInvalidate = new LinkedList<Block>();
-    Collection<BlockToMarkCorrupt> toCorrupt = new LinkedList<BlockToMarkCorrupt>();
-    Collection<StatefulBlockInfo> toUC = new LinkedList<StatefulBlockInfo>();
+
-    processReportedBlock(storageInfo, block, reportedState, toAdd, toInvalidate,
-        toCorrupt, toUC);
-    // the block is only in one of the to-do lists
-    // if it is in none then data-node already has it
-    assert toUC.size() + toAdd.size() + toInvalidate.size() + toCorrupt.size() <= 1
-      : "The block should be only in one of the lists.";
+    if(LOG.isDebugEnabled()) {
+      LOG.debug("Reported block " + block
+          + " on " + node + " size " + block.getNumBytes()
+          + " replicaState = " + reportedState);
+    }
-    for (StatefulBlockInfo b : toUC) { 
-      addStoredBlockUnderConstruction(b, storageInfo);
+    if (shouldPostponeBlocksFromFuture &&
+        isGenStampInFuture(block)) {
+      queueReportedBlock(storageInfo, block, reportedState,
+          QUEUE_REASON_FUTURE_GENSTAMP);
+      return;
-    long numBlocksLogged = 0;
-    for (BlockInfoToAdd b : toAdd) {
-      addStoredBlock(b.stored, b.reported, storageInfo, delHintNode,
-          numBlocksLogged < maxNumBlocksToLog);
-      numBlocksLogged++;
-    }
-    if (numBlocksLogged > maxNumBlocksToLog) {
-      blockLog.debug("BLOCK* addBlock: logged info for {} of {} reported.",
-          maxNumBlocksToLog, numBlocksLogged);
-    }
-    for (Block b : toInvalidate) {
+
+    // find block by blockId
+    BlockInfo storedBlock = getStoredBlock(block);
+    if(storedBlock == null) {
+      // If blocksMap does not contain reported block id,
+      // the replica should be removed from the data-node.
-          "belong to any file", b, node, b.getNumBytes());
-      addToInvalidates(b, node);
+          "belong to any file", block, node, block.getNumBytes());
+      addToInvalidates(new Block(block), node);
+      return;
-    for (BlockToMarkCorrupt b : toCorrupt) {
-      markBlockAsCorrupt(b, storageInfo, node);
+
+    BlockUCState ucState = storedBlock.getBlockUCState();
+    // Block is on the NN
+    if(LOG.isDebugEnabled()) {
+      LOG.debug("In memory blockUCState = " + ucState);
+    }
+
+    // Ignore replicas already scheduled to be removed from the DN
+    if(invalidateBlocks.contains(node, block)) {
+      return;
+    }
+
+    BlockToMarkCorrupt c = checkReplicaCorrupt(
+        block, reportedState, storedBlock, ucState, node);
+    if (c != null) {
+      if (shouldPostponeBlocksFromFuture) {
+        // If the block is an out-of-date generation stamp or state,
+        // but we're the standby, we shouldn't treat it as corrupt,
+        // but instead just queue it for later processing.
+        // TODO: Pretty confident this should be s/storedBlock/block below,
+        // since we should be postponing the info of the reported block, not
+        // the stored block. See HDFS-6289 for more context.
+        queueReportedBlock(storageInfo, storedBlock, reportedState,
+            QUEUE_REASON_CORRUPT_STATE);
+      } else {
+        markBlockAsCorrupt(c, storageInfo, node);
+      }
+      return;
+    }
+
+    if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {
+      addStoredBlockUnderConstruction(
+          new StatefulBlockInfo(storedBlock, new Block(block), reportedState),
+          storageInfo);
+      return;
+    }
+
+    // Add replica if appropriate. If the replica was previously corrupt
+    // but now okay, it might need to be updated.
+    if (reportedState == ReplicaState.FINALIZED
+        && (storedBlock.findStorageInfo(storageInfo) == -1 ||
+            corruptReplicas.isReplicaCorrupt(storedBlock, node))) {
+      addStoredBlock(storedBlock, block, storageInfo, delHintNode, true);
+  /**
+   * Runnable that monitors the fragmentation of the StorageInfo TreeSet and
+   * compacts it when it falls under a certain threshold.
+   */
+  private class StorageInfoDefragmenter implements Runnable {
+
+    @Override
+    public void run() {
+      while (namesystem.isRunning()) {
+        try {
+          // Check storage efficiency only when active NN is out of safe mode.
+          if (isPopulatingReplQueues()) {
+            scanAndCompactStorages();
+          }
+          Thread.sleep(storageInfoDefragmentInterval);
+        } catch (Throwable t) {
+          if (!namesystem.isRunning()) {
+            LOG.info("Stopping thread.");
+            if (!(t instanceof InterruptedException)) {
+              LOG.info("Received an exception while shutting down.", t);
+            }
+            break;
+          } else if (!checkNSRunning && t instanceof InterruptedException) {
+            LOG.info("Stopping for testing.");
+            break;
+          }
+          LOG.error("Thread received Runtime exception.", t);
+          terminate(1, t);
+        }
+      }
+    }
+
+    private void scanAndCompactStorages() throws InterruptedException {
+      ArrayList<String> datanodesAndStorages = new ArrayList<>();
+      for (DatanodeDescriptor node
+          : datanodeManager.getDatanodeListForReport(DatanodeReportType.ALL)) {
+        for (DatanodeStorageInfo storage : node.getStorageInfos()) {
+          try {
+            namesystem.readLock();
+            double ratio = storage.treeSetFillRatio();
+            if (ratio < storageInfoDefragmentRatio) {
+              datanodesAndStorages.add(node.getDatanodeUuid());
+              datanodesAndStorages.add(storage.getStorageID());
+            }
+            LOG.info("StorageInfo TreeSet fill ratio {} : {}{}",
+                     storage.getStorageID(), ratio,
+                     (ratio < storageInfoDefragmentRatio)
+                     ? " (queued for defragmentation)" : "");
+          } finally {
+            namesystem.readUnlock();
+          }
+        }
+      }
+      if (!datanodesAndStorages.isEmpty()) {
+        for (int i = 0; i < datanodesAndStorages.size(); i += 2) {
+          namesystem.writeLock();
+          try {
+            DatanodeStorageInfo storage = datanodeManager.
+                getDatanode(datanodesAndStorages.get(i)).
+                getStorageInfo(datanodesAndStorages.get(i + 1));
+            if (storage != null) {
+              boolean aborted =
+                  !storage.treeSetCompact(storageInfoDefragmentTimeout);
+              if (aborted) {
+                // Compaction timed out, reset iterator to continue with
+                // the same storage next iteration.
+                i -= 2;
+              }
+              LOG.info("StorageInfo TreeSet defragmented {} : {}{}",
+                       storage.getStorageID(), storage.treeSetFillRatio(),
+                       aborted ? " (aborted)" : "");
+            }
+          } finally {
+            namesystem.writeUnlock();
+          }
+          // Wait between each iteration
+          Thread.sleep(1000);
+        }
+      }
+    }
+  }

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS23 INS23 MOV44 INS31 INS55 INS29 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS59 INS44 UPD42 INS39 UPD42 MOV83 MOV39 MOV42 MOV44 MOV44 MOV44 MOV44 MOV43 INS8 INS29 INS83 INS42 INS43 INS31 INS31 INS65 INS42 INS42 INS42 INS65 INS42 INS42 INS14 INS21 INS21 INS21 INS21 INS21 INS70 INS83 INS39 INS42 INS60 INS25 INS74 INS60 INS70 UPD43 UPD42 MOV43 INS42 INS6 INS6 INS25 MOV60 INS25 MOV25 MOV60 MOV25 MOV60 INS25 INS25 MOV60 INS25 MOV25 INS25 INS65 INS42 INS78 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS43 INS8 INS66 INS66 INS43 INS14 INS7 INS7 INS7 INS32 INS32 INS44 INS32 INS8 INS74 INS59 INS38 INS8 INS8 INS43 INS43 MOV74 UPD43 MOV43 INS59 INS44 INS42 INS8 UPD42 INS27 MOV27 MOV27 MOV8 INS25 INS32 INS8 INS43 INS32 INS8 INS32 INS8 MOV43 INS59 INS27 INS8 INS27 INS8 INS66 INS66 INS42 INS61 INS42 INS60 INS70 INS25 INS42 INS43 INS22 INS32 INS22 INS32 INS22 INS32 INS42 INS42 INS45 INS42 INS42 INS21 INS21 INS43 INS42 INS42 INS42 MOV60 MOV61 INS21 INS21 INS43 INS43 INS42 INS42 INS21 INS60 INS70 INS21 INS21 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 INS32 UPD42 UPD42 INS42 INS33 INS43 INS42 MOV60 INS25 MOV60 INS25 INS25 MOV25 INS19 UPD42 UPD42 MOV42 INS33 UPD42 INS32 INS8 MOV25 INS42 INS42 INS21 INS21 UPD42 MOV42 UPD42 INS32 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS41 INS42 INS32 INS42 INS33 INS25 INS41 INS27 INS36 INS21 INS32 INS8 INS74 MOV59 MOV44 INS32 INS8 INS38 INS8 INS42 INS52 INS42 INS42 INS42 INS40 INS40 INS52 INS42 INS42 INS42 INS40 INS40 INS52 INS42 INS42 INS42 INS40 INS40 INS32 INS32 INS42 INS32 INS32 INS42 INS42 INS32 INS74 INS59 MOV44 INS42 INS8 INS7 INS7 INS42 INS42 UPD42 INS42 UPD39 INS27 INS8 MOV43 MOV32 INS8 INS27 INS8 INS27 INS8 INS27 UPD42 INS42 INS42 INS42 INS42 INS21 UPD42 INS32 INS32 MOV42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS8 INS8 MOV42 INS42 INS40 INS27 INS32 UPD42 MOV42 UPD42 MOV42 INS54 INS43 INS43 UPD42 INS14 UPD43 UPD42 INS42 UPD42 MOV42 UPD40 MOV40 INS70 INS32 INS24 INS42 INS42 INS42 INS42 INS34 INS60 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS32 INS43 INS43 INS42 INS14 INS21 INS42 INS42 INS42 INS42 UPD42 INS32 INS32 INS36 INS21 UPD42 INS32 INS21 INS42 INS32 INS21 INS18 INS27 INS32 INS60 INS25 INS42 INS33 INS32 INS42 INS42 INS27 INS42 INS42 MOV27 INS42 INS42 INS32 UPD42 UPD42 INS42 INS42 INS27 INS21 INS21 UPD42 UPD42 UPD27 MOV27 MOV32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS9 INS8 INS12 INS42 INS42 INS74 UPD42 INS44 INS32 INS8 UPD42 MOV42 INS42 INS58 INS27 INS7 INS8 UPD42 INS43 INS59 INS32 INS32 INS45 INS45 INS45 INS45 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS74 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS7 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 MOV42 MOV33 INS42 INS42 INS39 INS59 INS27 INS8 INS25 UPD42 INS42 INS42 INS14 INS45 INS42 INS45 INS42 INS45 MOV32 INS45 INS42 INS42 INS42 INS45 INS42 INS32 INS32 MOV32 INS38 UPD42 INS42 INS42 UPD42 INS25 INS21 INS44 INS8 INS43 INS43 INS42 INS42 INS42 INS54 INS39 INS59 INS42 INS32 INS42 INS34 MOV21 INS54 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 INS43 INS42 INS42 INS14 INS38 INS38 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS27 MOV60 INS25 INS10 UPD27 MOV27 MOV8 INS8 MOV43 INS42 INS14 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS34 INS32 INS8 INS32 UPD43 MOV43 UPD42 MOV42 INS25 INS21 INS21 INS42 INS42 INS8 INS8 INS42 INS34 UPD42 MOV42 UPD42 MOV42 INS8 INS8 INS32 MOV42 MOV42 INS16 INS42 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS33 INS36 INS34 MOV43 INS27 INS8 INS8 INS42 INS34 INS21 INS19 MOV43 INS42 UPD42 INS42 INS21 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 INS38 INS8 INS25 INS32 INS32 MOV21 INS60 MOV25 INS21 INS21 UPD42 UPD42 INS60 INS25 INS21 INS42 INS42 INS34 INS27 INS32 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS7 UPD42 INS32 INS42 INS33 INS21 INS21 INS32 INS7 INS8 INS27 INS32 INS32 INS21 INS25 INS10 INS27 INS8 INS42 INS42 INS45 INS42 INS42 INS34 INS42 INS32 INS39 INS59 UPD27 INS32 INS32 INS43 INS59 INS27 INS8 INS32 INS42 INS33 INS42 INS42 INS42 INS32 INS42 INS42 MOV14 INS32 INS32 INS42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS33 INS21 INS21 INS27 INS27 INS42 INS42 INS42 INS32 INS38 INS8 INS38 INS62 INS21 INS10 INS42 INS42 INS42 INS32 UPD42 UPD42 INS21 INS42 INS42 INS45 INS32 UPD42 MOV42 INS16 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS32 INS42 INS33 INS60 INS25 MOV21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 INS42 INS42 INS14 INS32 INS7 INS42 INS33 INS32 INS34 INS42 INS42 INS45 INS36 MOV21 INS42 INS42 INS43 INS32 INS42 INS42 INS32 INS42 UPD42 MOV42 INS36 INS45 INS45 INS32 INS42 INS32 INS39 INS59 INS42 INS8 UPD42 MOV42 UPD42 MOV42 MOV43 INS42 INS42 INS42 INS42 INS42 INS16 INS42 INS42 INS42 INS32 INS62 INS42 INS42 INS42 INS45 UPD42 UPD42 INS32 INS42 INS42 INS32 INS27 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS38 INS21 UPD42 UPD42 INS45 INS32 INS32 INS16 INS32 INS32 INS33 INS42 INS42 INS42 INS43 UPD42 UPD42 INS45 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS7 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS45 INS45 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS34 DEL42 DEL32 DEL32 DEL21 DEL43 DEL42 DEL43 DEL42 DEL39 DEL34 DEL11 DEL14 DEL42 DEL42 DEL34 DEL39 DEL27 DEL42 DEL40 DEL42 DEL32 DEL7 DEL42 DEL40 DEL27 DEL45 DEL6 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL25 DEL8 DEL70 DEL42 DEL42 DEL42 DEL43 DEL34 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL41 DEL25 DEL42 DEL41 DEL33 DEL33 DEL42 DEL43 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL42 DEL42 DEL7 DEL36 DEL34 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL32 DEL21 DEL32 DEL32 DEL32 DEL27 DEL34 DEL27 DEL45 DEL6 DEL44 DEL42 DEL8 DEL70 DEL39 DEL60 DEL42 DEL40 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL8 DEL70 DEL42 DEL44 DEL42 DEL32 DEL32 DEL21 DEL8 DEL70 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL8 DEL31 DEL34 DEL42 DEL37 DEL45 DEL42
HDFS-13110: [SPS]: Reduce the number of APIs in NamenodeProtocol used by external satisfier. Contributed by Rakesh R.

- * where users may want to physically move the blocks by a dedidated daemon (can
+ * where users may want to physically move the blocks by a dedicated daemon (can
-public class StoragePolicySatisfier implements SPSService, Runnable {
+public class StoragePolicySatisfier<T> implements SPSService<T>, Runnable {
-  private BlockStorageMovementNeeded storageMovementNeeded;
-  private BlockStorageMovementAttemptedItems storageMovementsMonitor;
+  private BlockStorageMovementNeeded<T> storageMovementNeeded;
+  private BlockStorageMovementAttemptedItems<T> storageMovementsMonitor;
-  private Context ctxt;
+  private Context<T> ctxt;
-  public void init(final Context context, final FileIdCollector fileIDCollector,
+  public void init(final Context<T> context,
+      final FileCollector<T> fileIDCollector,
-    this.storageMovementNeeded =
-        new BlockStorageMovementNeeded(context, fileIDCollector);
-    this.storageMovementsMonitor =
-        new BlockStorageMovementAttemptedItems(this,
-        storageMovementNeeded, blockMovementListener);
+    this.storageMovementNeeded = new BlockStorageMovementNeeded<T>(context,
+        fileIDCollector);
+    this.storageMovementsMonitor = new BlockStorageMovementAttemptedItems<T>(
+        this, storageMovementNeeded, blockMovementListener);
+        ItemInfo<T> itemInfo = null;
+        boolean retryItem = false;
-          ItemInfo itemInfo = storageMovementNeeded.get();
+          itemInfo = storageMovementNeeded.get();
-                  + itemInfo.getFileId() + " from the queue");
+                  + itemInfo.getFile() + " from the queue");
-            long trackId = itemInfo.getFileId();
+            T trackId = itemInfo.getFile();
-            boolean hasLowRedundancyBlocks = ctxt
-                .hasLowRedundancyBlocks(trackId);
-                  hasLowRedundancyBlocks, existingStoragePolicy, liveDnReports);
+                  existingStoragePolicy, liveDnReports);
-                this.storageMovementsMonitor.add(new AttemptedItemInfo(itemInfo
-                    .getStartId(), itemInfo.getFileId(), monotonicNow(),
+                this.storageMovementsMonitor.add(new AttemptedItemInfo<T>(
+                    itemInfo.getStartPath(), itemInfo.getFile(), monotonicNow(),
-                itemInfo.increRetryCount();
-                this.storageMovementNeeded.add(itemInfo);
+                retryItem = true;
-                itemInfo.increRetryCount();
-                this.storageMovementNeeded.add(itemInfo);
+                retryItem = true;
-                this.storageMovementNeeded.add(itemInfo);
+                retryItem = true;
+        if (retryItem) {
+          itemInfo.increRetryCount();
+          this.storageMovementNeeded.add(itemInfo);
+        }
-      HdfsLocatedFileStatus fileInfo, boolean hasLowRedundancyBlocks,
+      HdfsLocatedFileStatus fileInfo,
-
+    boolean hasLowRedundancyBlocks = false;
+    int replication = fileInfo.getReplication();
+
+      // Block is considered as low redundancy when the block locations array
+      // length is less than expected replication factor. If any of the block is
+      // low redundant, then hasLowRedundancyBlocks will be marked as true.
+      hasLowRedundancyBlocks |= isLowRedundancyBlock(blockInfo, replication,
+          ecPolicy);
+
-      } else if (hasLowRedundancyBlocks
-          && status != BlocksMovingAnalysis.Status.BLOCKS_TARGETS_PAIRED) {
-        // Check if the previous block was successfully paired.
-        status = BlocksMovingAnalysis.Status.FEW_LOW_REDUNDANCY_BLOCKS;
+    // If there is no block paired and few blocks are low redundant, so marking
+    // the status as FEW_LOW_REDUNDANCY_BLOCKS.
+    if (hasLowRedundancyBlocks
+        && status == BlocksMovingAnalysis.Status.NO_BLOCKS_TARGETS_PAIRED) {
+      status = BlocksMovingAnalysis.Status.FEW_LOW_REDUNDANCY_BLOCKS;
+    }
+   * The given block is considered as low redundancy when the block locations
+   * length is less than expected replication factor. For EC blocks, redundancy
+   * is the summation of data + parity blocks.
+   *
+   * @param blockInfo
+   *          block
+   * @param replication
+   *          replication factor of the given file block
+   * @param ecPolicy
+   *          erasure coding policy of the given file block
+   * @return true if the given block is low redundant.
+   */
+  private boolean isLowRedundancyBlock(LocatedBlock blockInfo, int replication,
+      ErasureCodingPolicy ecPolicy) {
+    boolean hasLowRedundancyBlock = false;
+    if (blockInfo.isStriped()) {
+      // For EC blocks, redundancy is the summation of data + parity blocks.
+      replication = ecPolicy.getNumDataUnits() + ecPolicy.getNumParityUnits();
+    }
+    // block is considered as low redundancy when the block locations length is
+    // less than expected replication factor.
+    hasLowRedundancyBlock = blockInfo.getLocations().length < replication ? true
+        : false;
+    return hasLowRedundancyBlock;
+  }
+
+  /**
-  BlockStorageMovementAttemptedItems getAttemptedItemsMonitor() {
+  public BlockStorageMovementAttemptedItems<T> getAttemptedItemsMonitor() {
-  public void clearQueue(long trackId) {
+  public void clearQueue(T trackId) {
-  final static class AttemptedItemInfo extends ItemInfo {
+  final static class AttemptedItemInfo<T> extends ItemInfo<T> {
-    AttemptedItemInfo(long rootId, long trackId,
+    AttemptedItemInfo(T rootId, T trackId,
+  /**
+   * Returns sps invoked path status. This method is used by internal satisfy
+   * storage policy service.
+   *
+   * @param path
+   *          sps path
+   * @return storage policy satisfy path status
+   * @throws IOException
+   */
-  public void addFileIdToProcess(ItemInfo trackInfo, boolean scanCompleted) {
+  public void addFileToProcess(ItemInfo<T> trackInfo, boolean scanCompleted) {
-          + "storageMovementNeeded queue", trackInfo.getFileId());
+          + "storageMovementNeeded queue", trackInfo.getFile());
-  public void addAllFileIdsToProcess(long startId, List<ItemInfo> itemInfoList,
+  public void addAllFilesToProcess(T startPath, List<ItemInfo<T>> itemInfoList,
-    getStorageMovementQueue().addAll(startId, itemInfoList, scanCompleted);
+    getStorageMovementQueue().addAll(startPath, itemInfoList, scanCompleted);
-  public BlockStorageMovementNeeded getStorageMovementQueue() {
+  public BlockStorageMovementNeeded<T> getStorageMovementQueue() {
-  public void markScanCompletedForPath(Long inodeId) {
+  public void markScanCompletedForPath(T inodeId) {
-    //TODO Add join here on SPS rpc server also

INS73 INS74 INS31 INS42 MOV43 INS43 INS74 INS74 INS74 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS74 INS73 INS74 INS29 UPD42 UPD42 INS74 UPD66 INS42 MOV43 INS43 MOV43 INS43 MOV43 INS43 INS74 INS74 INS60 INS60 MOV25 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS43 INS42 INS60 INS25 INS21 INS41 MOV43 INS43 INS43 INS42 MOV43 INS43 INS65 INS65 INS65 INS65 INS74 INS43 UPD42 UPD74 MOV43 INS43 UPD43 INS42 INS42 INS42 MOV43 INS43 INS43 INS43 INS39 INS59 INS39 INS59 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS39 INS59 INS32 INS8 INS7 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS66 INS66 INS42 INS66 INS66 INS42 MOV43 INS43 INS42 INS74 INS42 UPD42 INS42 UPD42 MOV42 INS42 INS42 INS9 INS42 INS32 INS21 UPD27 INS42 INS9 INS42 INS42 INS21 INS42 INS16 INS42 INS42 UPD42 MOV42 MOV43 INS43 UPD42 INS74 INS74 INS42 INS42 INS7 UPD40 INS7 INS27 INS9 INS9 INS42 MOV43 INS43 MOV43 INS43 INS60 INS60 INS25 INS42 INS32 INS42 INS27 INS22 INS42 INS42 INS42 INS74 INS59 INS39 INS59 INS42 INS8 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 UPD42 MOV43 INS43 INS42 INS33 INS42 INS9 INS21 MOV21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 MOV32 INS43 INS42 MOV21 UPD42 INS10 INS7 INS7 INS7 INS42 INS9 INS42 INS9 INS42 INS9 UPD42 INS74 MOV43 INS43 UPD42 UPD42 INS42 DEL43 DEL42 DEL59 DEL60 DEL39 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL10 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL39 DEL42 DEL44 DEL39 DEL39 DEL39 DEL39
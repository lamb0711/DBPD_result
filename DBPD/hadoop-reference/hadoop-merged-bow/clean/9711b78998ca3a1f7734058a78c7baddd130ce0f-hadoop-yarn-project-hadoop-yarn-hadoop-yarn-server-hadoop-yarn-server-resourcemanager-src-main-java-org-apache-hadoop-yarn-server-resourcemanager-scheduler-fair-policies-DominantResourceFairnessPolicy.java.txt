YARN-7374. Improve performance of DRF comparisons for resource types in fair scheduler

-  private static final DominantResourceFairnessComparator COMPARATOR =
-      new DominantResourceFairnessComparator();
+  private static final int NUM_RESOURCES =
+      ResourceUtils.getNumberOfKnownResourceTypes();
+  private static final DominantResourceFairnessComparator COMPARATORN =
+      new DominantResourceFairnessComparatorN();
+  private static final DominantResourceFairnessComparator COMPARATOR2 =
+      new DominantResourceFairnessComparator2();
-    return COMPARATOR;
+    if (NUM_RESOURCES == 2) {
+      // To improve performance, if we know we're dealing with the common
+      // case of only CPU and memory, then handle CPU and memory explicitly.
+      return COMPARATOR2;
+    } else {
+      // Otherwise, do it the generic way.
+      return COMPARATORN;
+    }
+
-    COMPARATOR.setFSContext(fsContext);
+    COMPARATORN.setFSContext(fsContext);
+    COMPARATOR2.setFSContext(fsContext);
-   * ratios are compared.
+   * ratios are compared. Subclasses of this class will do the actual work of
+   * the comparison, specialized for the number of configured resource types.
-  public static class DominantResourceFairnessComparator
+  public abstract static class DominantResourceFairnessComparator
-    private FSContext fsContext;
+    protected FSContext fsContext;
+    /**
+     * This method is used when apps are tied in fairness ratio. It breaks
+     * the tie by submit time and job name to get a deterministic ordering,
+     * which is useful for unit tests.
+     *
+     * @param s1 the first item to compare
+     * @param s2 the second item to compare
+     * @return &lt; 0, 0, or &gt; 0 if the first item is less than, equal to,
+     * or greater than the second item, respectively
+     */
+    protected int compareAttribrutes(Schedulable s1, Schedulable s2) {
+      int res = (int) Math.signum(s1.getStartTime() - s2.getStartTime());
+
+      if (res == 0) {
+        res = s1.getName().compareTo(s2.getName());
+      }
+
+      return res;
+    }
+  }
+
+  /**
+   * This class compares two {@link Schedulable} instances according to the
+   * DRF policy. If neither instance is below min share, approximate fair share
+   * ratios are compared. This class makes no assumptions about the number of
+   * resource types.
+   */
+  @VisibleForTesting
+  static class DominantResourceFairnessComparatorN
+      extends DominantResourceFairnessComparator {
-      ResourceInformation[] info = ResourceUtils.getResourceTypesArray();
-      float[][] ratios1 = new float[info.length][3];
-      float[][] ratios2 = new float[info.length][3];
+      float[][] ratios1 = new float[NUM_RESOURCES][3];
+      float[][] ratios2 = new float[NUM_RESOURCES][3];
-      int res = 0;
+      int res;
-        // Apps are tied in fairness ratio. Break the tie by submit time and job
-        // name to get a deterministic ordering, which is useful for unit tests.
-        res = (int) Math.signum(s1.getStartTime() - s2.getStartTime());
-
-        if (res == 0) {
-          res = s1.getName().compareTo(s2.getName());
-        }
+        res = compareAttribrutes(s1, s2);
-     * The {@code shares} array will be populated with both the usage ratio
+     * The {@code ratios} array will be populated with both the usage ratio
-     * The {@code shares} array must be at least <i>n</i> x 2, where <i>n</i>
+     * The {@code ratios} array must be at least <i>n</i> x 2, where <i>n</i>
-     * the inner arrays in the {@code shares} array will be used, e.g.
-     * {@code shares[x][0]} and {@code shares[x][1]}.
+     * the inner arrays in the {@code ratios} array will be used, e.g.
+     * {@code ratios[x][0]} and {@code ratios[x][1]}.
-     * {@code shares} array. The dominant resource is the resource type for
+     * {@code ratios} array. The dominant resource is the resource type for
-     * @param ratios the shares array to populate
+     * @param ratios the share ratios array to populate
-     * @param ratios the shares array to populate
+     * @param ratios the share ratios array to populate
+
+  /**
+   * This class compares two {@link Schedulable} instances according to the
+   * DRF policy in the special case that only CPU and memory are configured.
+   * If neither instance is below min share, approximate fair share
+   * ratios are compared.
+   */
+  @VisibleForTesting
+  static class DominantResourceFairnessComparator2
+      extends DominantResourceFairnessComparator {
+    @Override
+    public int compare(Schedulable s1, Schedulable s2) {
+      ResourceInformation[] resourceInfo1 =
+          s1.getResourceUsage().getResources();
+      ResourceInformation[] resourceInfo2 =
+          s2.getResourceUsage().getResources();
+      ResourceInformation[] minShareInfo1 = s1.getMinShare().getResources();
+      ResourceInformation[] minShareInfo2 = s2.getMinShare().getResources();
+      ResourceInformation[] clusterInfo =
+          fsContext.getClusterResource().getResources();
+      double[] shares1 = new double[2];
+      double[] shares2 = new double[2];
+
+      int dominant1 = calculateClusterAndFairRatios(resourceInfo1,
+          s1.getWeight(), clusterInfo, shares1);
+      int dominant2 = calculateClusterAndFairRatios(resourceInfo2,
+          s2.getWeight(), clusterInfo, shares2);
+
+      // A queue is needy for its min share if its dominant resource
+      // (with respect to the cluster capacity) is below its configured min
+      // share for that resource
+      boolean s1Needy = resourceInfo1[dominant1].getValue() <
+          minShareInfo1[dominant1].getValue();
+      boolean s2Needy = resourceInfo1[dominant2].getValue() <
+          minShareInfo2[dominant2].getValue();
+
+      int res;
+
+      if (!s2Needy && !s1Needy) {
+        res = (int) Math.signum(shares1[dominant1] - shares2[dominant2]);
+
+        if (res == 0) {
+          // Because memory and CPU are indices 0 and 1, we can find the
+          // non-dominant index by subtracting the dominant index from 1.
+          res = (int) Math.signum(shares1[1 - dominant1] -
+              shares2[1 - dominant2]);
+        }
+      } else if (s1Needy && !s2Needy) {
+        res = -1;
+      } else if (s2Needy && !s1Needy) {
+        res = 1;
+      } else {
+        double[] minShares1 =
+            calculateMinShareRatios(resourceInfo1, minShareInfo1);
+        double[] minShares2 =
+            calculateMinShareRatios(resourceInfo2, minShareInfo2);
+
+        res = (int) Math.signum(minShares1[dominant1] - minShares2[dominant2]);
+
+        if (res == 0) {
+          res = (int) Math.signum(minShares1[1 - dominant1] -
+              minShares2[1 - dominant2]);
+        }
+      }
+
+      if (res == 0) {
+        res = compareAttribrutes(s1, s2);
+      }
+
+      return res;
+    }
+
+    /**
+     * Calculate a resource's usage ratio and approximate fair share ratio
+     * assuming that CPU and memory are the only configured resource types.
+     * The {@code shares} array will be populated with the approximate fair
+     * share ratio for each resource type. The approximate fair share ratio
+     * is calculated as {@code resourceInfo} divided by {@code cluster} and
+     * the {@code weight}. If the cluster's resources are 100MB and
+     * 10 vcores, the usage ({@code resourceInfo}) is 10 MB and 5 CPU, and the
+     * weights are 2, the fair share ratios will be 0.05 and 0.25.
+     *
+     * The approximate fair share ratio is the usage divided by the
+     * approximate fair share, i.e. the cluster resources times the weight.
+     * The approximate fair share is an acceptable proxy for the fair share
+     * because when comparing resources, the resource with the higher weight
+     * will be assigned by the scheduler a proportionally higher fair share.
+     *
+     * The length of the {@code shares} array must be at least 2.
+     *
+     * The return value will be the index of the dominant resource type in the
+     * {@code shares} array. The dominant resource is the resource type for
+     * which {@code resourceInfo} has the largest usage ratio.
+     *
+     * @param resourceInfo the resource for which to calculate ratios
+     * @param weight the resource weight
+     * @param clusterInfo the total cluster resources
+     * @param shares the share ratios array to populate
+     * @return the index of the resource type with the largest cluster share
+     */
+    @VisibleForTesting
+    int calculateClusterAndFairRatios(ResourceInformation[] resourceInfo,
+        float weight, ResourceInformation[] clusterInfo, double[] shares) {
+      int dominant;
+
+      shares[Resource.MEMORY_INDEX] =
+          ((double) resourceInfo[Resource.MEMORY_INDEX].getValue()) /
+          clusterInfo[Resource.MEMORY_INDEX].getValue();
+      shares[Resource.VCORES_INDEX] =
+          ((double) resourceInfo[Resource.VCORES_INDEX].getValue()) /
+          clusterInfo[Resource.VCORES_INDEX].getValue();
+      dominant =
+          shares[Resource.VCORES_INDEX] > shares[Resource.MEMORY_INDEX] ?
+          Resource.VCORES_INDEX : Resource.MEMORY_INDEX;
+
+      shares[Resource.MEMORY_INDEX] /= weight;
+      shares[Resource.VCORES_INDEX] /= weight;
+
+      return dominant;
+    }
+
+    /**
+     * Calculate a resource's min share ratios assuming that CPU and memory
+     * are the only configured resource types. The return array will be
+     * populated with the {@code resourceInfo} divided by {@code minShareInfo}
+     * for each resource type. If the min shares are 5 MB and 10 vcores, and
+     * the usage ({@code resourceInfo}) is 10 MB and 5 CPU, the ratios will
+     * be 2 and 0.5.
+     *
+     * The length of the {@code ratios} array must be 2.
+     *
+     * @param resourceInfo the resource for which to calculate min shares
+     * @param minShareInfo the min share
+     * @return the share ratios
+     */
+    @VisibleForTesting
+    double[] calculateMinShareRatios(ResourceInformation[] resourceInfo,
+        ResourceInformation[] minShareInfo) {
+      double[] minShares1 = new double[2];
+
+      // both are needy below min share
+      minShares1[Resource.MEMORY_INDEX] =
+          ((double) resourceInfo[Resource.MEMORY_INDEX].getValue()) /
+          minShareInfo[Resource.MEMORY_INDEX].getValue();
+      minShares1[Resource.VCORES_INDEX] =
+          ((double) resourceInfo[Resource.VCORES_INDEX].getValue()) /
+          minShareInfo[Resource.VCORES_INDEX].getValue();
+
+      return minShares1;
+    }
+  }

INS23 INS23 INS55 INS55 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS43 INS59 INS8 INS29 INS83 INS83 INS83 INS42 MOV74 MOV23 MOV31 INS31 INS78 UPD42 MOV43 INS29 INS78 INS83 INS42 INS43 INS31 INS31 INS31 INS42 INS32 UPD42 INS42 INS42 INS14 INS25 INS21 INS65 UPD83 INS29 INS83 INS39 INS42 INS44 INS44 MOV8 INS42 MOV60 INS65 INS42 INS42 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS78 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS78 INS5 INS42 INS44 INS44 INS8 INS42 INS42 INS43 INS43 INS27 INS8 INS8 INS32 INS66 MOV65 INS66 INS66 INS66 INS66 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS41 INS65 UPD66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS25 INS25 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS5 INS42 INS39 INS42 INS5 INS42 INS5 INS42 INS60 INS21 INS21 INS21 INS21 INS21 INS41 INS65 INS65 INS65 INS65 INS42 INS39 INS85 INS5 INS42 INS5 INS42 INS60 INS21 INS21 INS41 INS42 INS42 INS42 INS34 MOV41 INS41 UPD42 INS42 INS42 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS39 INS59 INS42 INS42 MOV5 MOV5 INS8 INS65 INS65 INS65 UPD66 UPD66 INS42 INS42 INS42 MOV5 INS59 INS5 INS59 INS5 INS59 INS5 INS59 INS5 INS59 INS5 INS59 INS5 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS25 INS27 INS8 INS42 INS66 INS66 INS66 MOV65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 MOV65 INS66 INS66 MOV65 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS85 INS43 INS85 INS39 INS85 INS39 INS59 INS7 INS7 INS7 INS7 INS7 INS42 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS85 INS43 INS85 INS5 INS59 INS7 INS7 INS42 UPD42 INS42 INS42 MOV11 UPD42 UPD42 INS21 INS66 INS66 INS66 UPD66 UPD66 UPD66 INS42 INS32 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS39 INS85 INS42 INS3 INS39 INS85 INS42 INS3 INS42 INS32 INS42 INS32 INS42 INS27 INS42 INS27 INS42 INS38 INS38 INS21 INS25 INS27 INS8 INS25 INS42 INS34 INS21 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS2 INS27 INS2 INS27 INS42 INS16 INS2 INS42 INS2 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS39 INS85 INS42 INS3 INS2 INS27 INS2 INS27 MOV5 INS42 MOV5 INS42 INS7 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS5 INS34 INS5 INS34 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS7 INS27 INS8 INS42 INS38 INS21 INS27 INS8 INS8 INS7 INS42 INS40 INS36 INS32 INS42 INS40 INS36 INS32 INS27 INS40 INS40 INS42 INS40 INS42 INS40 INS5 INS34 INS42 INS40 INS36 INS32 INS42 INS40 INS36 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS39 INS85 INS42 INS42 INS42 INS42 INS2 INS42 INS2 INS42 INS2 INS42 INS2 INS42 INS42 INS11 INS42 INS34 INS21 INS42 INS7 INS42 INS38 INS21 INS60 INS60 INS21 INS25 INS42 INS32 INS11 INS2 INS42 INS11 INS2 INS42 INS2 INS2 INS39 INS85 INS11 INS2 INS42 INS11 INS2 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS32 INS7 INS42 INS38 INS42 INS7 INS5 INS59 INS5 INS59 INS7 INS27 INS8 INS42 INS42 INS42 INS39 INS32 INS42 INS40 INS39 INS32 INS42 INS40 INS42 INS40 INS42 INS40 INS39 INS32 INS42 INS40 INS39 INS32 INS42 INS40 INS42 INS42 INS27 INS42 INS11 INS34 INS42 INS34 INS39 INS85 INS42 INS32 INS39 INS85 INS42 INS32 INS42 INS11 INS42 INS34 INS21 INS2 INS42 INS2 INS42 INS2 INS42 INS2 INS42 INS2 INS2 INS39 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS32 INS7 INS42 INS40 INS42 INS40 INS42 INS40 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS11 INS2 INS2 INS2 INS2 INS39 INS32 INS42 INS27 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS34 INS42 INS34 INS42 INS2 INS2 INS42 INS27 INS42 INS27 INS34 INS42 INS34 INS42 DEL8 DEL42 DEL7 DEL21 DEL83 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL40 DEL34
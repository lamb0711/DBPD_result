Merge branch 'trunk' into HADOOP-12756

-import org.apache.hadoop.hdfs.DFSStripedOutputStream;
-import org.apache.hadoop.io.erasurecode.rawcoder.RawErasureDecoder;
+import org.apache.hadoop.hdfs.DFSStripedOutputStream;
-   * Parses a striped block group into individual blocks.
-   * @param bg The striped block group
-   * @param ecPolicy The erasure coding policy
-   * @return An array of the blocks in the group
-   */
-  public static LocatedBlock[] parseStripedBlockGroup(LocatedStripedBlock bg,
-                                               ErasureCodingPolicy ecPolicy) {
-    return parseStripedBlockGroup(bg, ecPolicy.getCellSize(),
-        ecPolicy.getNumDataUnits(), ecPolicy.getNumParityUnits());
-  }
-
-  /**
-   * This method creates an internal block at the given index of a block group
+   * This method creates an internal block at the given index of a block group.
-   * Get the size of an internal block at the given index of a block group
+   * Get the size of an internal block at the given index of a block group.
-   * the block group
+   * the block group.
-   * Get the next completed striped read task
+   * Get the next completed striped read task.
-   * @return {@link StripingChunkReadResult} indicating the status of the read task
-   *          succeeded, and the block index of the task. If the method times
-   *          out without getting any completed read tasks, -1 is returned as
-   *          block index.
+   * @return {@link StripingChunkReadResult} indicating the status of the read
+   *          task succeeded, and the block index of the task. If the method
+   *          times out without getting any completed read tasks, -1 is
+   *          returned as block index.
-   * blocks and parity blocks
+   * blocks and parity blocks.
-   * Initialize the decoding input buffers based on the chunk states in an
-   * {@link AlignedStripe}. For each chunk that was not initially requested,
-   * schedule a new fetch request with the decoding input buffer as transfer
-   * destination.
-   */
-  public static ByteBuffer[] initDecodeInputs(AlignedStripe alignedStripe,
-      int dataBlkNum, int parityBlkNum) {
-    ByteBuffer[] decodeInputs = new ByteBuffer[dataBlkNum + parityBlkNum];
-    for (int i = 0; i < decodeInputs.length; i++) {
-      decodeInputs[i] = ByteBuffer.allocate(
-          (int) alignedStripe.getSpanInBlock());
-    }
-    // read the full data aligned stripe
-    for (int i = 0; i < dataBlkNum; i++) {
-      if (alignedStripe.chunks[i] == null) {
-        alignedStripe.chunks[i] = new StripingChunk(decodeInputs[i]);
-      }
-    }
-    return decodeInputs;
-  }
-
-  /**
-   * Some fetched {@link StripingChunk} might be stored in original application
-   * buffer instead of prepared decode input buffers. Some others are beyond
-   * the range of the internal blocks and should correspond to all zero bytes.
-   * When all pending requests have returned, this method should be called to
-   * finalize decode input buffers.
-   */
-  public static void finalizeDecodeInputs(final ByteBuffer[] decodeInputs,
-                                          AlignedStripe alignedStripe) {
-    for (int i = 0; i < alignedStripe.chunks.length; i++) {
-      final StripingChunk chunk = alignedStripe.chunks[i];
-      if (chunk != null && chunk.state == StripingChunk.FETCHED) {
-        if (chunk.useChunkBuffer()) {
-          chunk.getChunkBuffer().copyTo(decodeInputs[i]);
-        } else {
-          chunk.getByteBuffer().flip();
-        }
-      } else if (chunk != null && chunk.state == StripingChunk.ALLZERO) {
-        //ZERO it. Will be better handled in other following issue.
-        byte[] emptyBytes = new byte[decodeInputs[i].limit()];
-        decodeInputs[i].put(emptyBytes);
-        decodeInputs[i].flip();
-      } else {
-        decodeInputs[i] = null;
-      }
-    }
-  }
-
-  /**
-   * Decode based on the given input buffers and erasure coding policy.
-   */
-  public static void decodeAndFillBuffer(final ByteBuffer[] decodeInputs,
-      AlignedStripe alignedStripe, int dataBlkNum, int parityBlkNum,
-      RawErasureDecoder decoder) {
-    // Step 1: prepare indices and output buffers for missing data units
-    int[] decodeIndices = new int[parityBlkNum];
-    int pos = 0;
-    for (int i = 0; i < dataBlkNum; i++) {
-      if (alignedStripe.chunks[i] != null &&
-          alignedStripe.chunks[i].state == StripingChunk.MISSING){
-        decodeIndices[pos++] = i;
-      }
-    }
-    decodeIndices = Arrays.copyOf(decodeIndices, pos);
-    ByteBuffer[] decodeOutputs = new ByteBuffer[decodeIndices.length];
-    for (int i = 0; i < decodeOutputs.length; i++) {
-      decodeOutputs[i] = ByteBuffer.allocate(
-          (int) alignedStripe.getSpanInBlock());
-    }
-
-    // Step 2: decode into prepared output buffers
-    decoder.decode(decodeInputs, decodeIndices, decodeOutputs);
-
-    // Step 3: fill original application buffer with decoded data
-    for (int i = 0; i < decodeIndices.length; i++) {
-      int missingBlkIdx = decodeIndices[i];
-      StripingChunk chunk = alignedStripe.chunks[missingBlkIdx];
-      if (chunk.state == StripingChunk.MISSING && chunk.useChunkBuffer()) {
-        chunk.getChunkBuffer().copyFrom(decodeOutputs[i]);
-      }
-    }
-  }
-
-  /**
-   * used by {@link DFSStripedOutputStream} in encoding
+   * used by {@link DFSStripedOutputStream} in encoding.
-    VerticalRange ranges[] = new VerticalRange[dataBlkNum + parityBlkNum];
+    VerticalRange[] ranges = new VerticalRange[dataBlkNum + parityBlkNum];
-    /** Logical order in a block group, used when doing I/O to a block group */
+    /** Logical order in a block group, used when doing I/O to a block group. */
-    /** status of each chunk in the stripe */
+    /** status of each chunk in the stripe. */
-    /** start offset in the block group (inclusive) */
+    /** start offset in the block group (inclusive). */
-    /** length of the stripe range */
+    /** length of the stripe range. */
-    /** whether a position is in the range */
+    /** whether a position is in the range. */
-    void copyTo(ByteBuffer target) {
+    public void copyTo(ByteBuffer target) {
-    void copyFrom(ByteBuffer src) {
+    public void copyFrom(ByteBuffer src) {
+  /** Used to indicate the buffered data's range in the block group. */
+  public static class StripeRange {
+    /** start offset in the block group (inclusive). */
+    final long offsetInBlock;
+    /** length of the stripe range. */
+    final long length;
+
+    public StripeRange(long offsetInBlock, long length) {
+      Preconditions.checkArgument(offsetInBlock >= 0 && length >= 0);
+      this.offsetInBlock = offsetInBlock;
+      this.length = length;
+    }
+
+    public boolean include(long pos) {
+      return pos >= offsetInBlock && pos < offsetInBlock + length;
+    }
+
+    public long getLength() {
+      return length;
+    }
+  }
+

MOV26 INS55 INS29 INS83 INS83 INS42 INS23 INS23 INS31 INS31 INS31 INS59 INS83 INS83 UPD65 MOV65 INS29 INS83 INS39 MOV59 INS29 INS83 INS39 INS59 MOV83 INS42 MOV44 MOV44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS5 INS42 UPD66 MOV65 MOV65 INS42 UPD39 UPD42 UPD39 UPD42 INS21 MOV21 MOV21 INS39 INS42 INS41 INS41 INS43 INS85 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS32 INS27 INS42 MOV42 INS42 INS42 INS27 INS22 INS42 INS22 INS42 INS27 INS27 UPD27 MOV27 UPD27 MOV27 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS27 INS42 INS34 INS42 INS34 INS42 UPD42 MOV42 DEL40 DEL26 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL29 DEL83 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL27 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL42 DEL39 DEL42 DEL42 DEL32 DEL11 DEL32 DEL7 DEL21 DEL8 DEL24 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL40 DEL42 DEL2 DEL33 DEL27 DEL40 DEL42 DEL2 DEL42 DEL43 DEL42 DEL42 DEL2 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL41 DEL8 DEL31 DEL29 DEL83 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL83 DEL42 DEL43 DEL42 DEL40 DEL42 DEL2 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL40 DEL27 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL2 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL33 DEL27 DEL40 DEL40 DEL27 DEL27 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL42 DEL2 DEL42 DEL32 DEL3 DEL59 DEL60 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL2 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL2 DEL33 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL24 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL27 DEL8 DEL25 DEL8 DEL24 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL40 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL42 DEL39 DEL42 DEL42 DEL32 DEL11 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL40 DEL27 DEL42 DEL37 DEL39 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL43 DEL42 DEL40 DEL42 DEL2 DEL59 DEL60 DEL40 DEL40 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL2 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL31 DEL43 DEL85 DEL42 DEL65 DEL66 DEL66 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL66 DEL40 DEL42 DEL2 DEL33 DEL40 DEL42 DEL2 DEL42 DEL22 DEL40 DEL42 DEL42 DEL37 DEL2 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32
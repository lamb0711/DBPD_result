HDFS-12787. Ozone: SCM: Aggregate the metrics from all the container reports. Contributed by Yiqun Lin.

+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.RemovalListener;
+import com.google.common.cache.RemovalNotification;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.TimeUnit;
+  /** Key = DatanodeUuid, value = ContainerStat. */
+  private Cache<String, ContainerStat> containerReportCache;
+
+    initContainerReportCache(conf);
+
-    scmNodeManager = new SCMNodeManager(conf, scmStorage.getClusterID());
+    scmNodeManager = new SCMNodeManager(conf, scmStorage.getClusterID(), this);
+   * Initialize container reports cache that sent from datanodes.
+   *
+   * @param conf
+   */
+  private void initContainerReportCache(OzoneConfiguration conf) {
+    containerReportCache = CacheBuilder.newBuilder()
+        .expireAfterAccess(Long.MAX_VALUE, TimeUnit.MILLISECONDS)
+        .maximumSize(Integer.MAX_VALUE)
+        .removalListener(new RemovalListener<String, ContainerStat>() {
+          @Override
+          public void onRemoval(
+              RemovalNotification<String, ContainerStat> removalNotification) {
+            synchronized (containerReportCache) {
+              ContainerStat stat = removalNotification.getValue();
+              // remove invalid container report
+              metrics.decrContainerStat(stat);
+              LOG.debug(
+                  "Remove expired container stat entry for datanode: {}.",
+                  removalNotification.getKey());
+            }
+          }
+        }).build();
+  }
+
+  /**
-    metrics.unRegister();
+    if (containerReportCache != null) {
+      containerReportCache.invalidateAll();
+      containerReportCache.cleanUp();
+    }
+
+    if (metrics != null) {
+      metrics.unRegister();
+    }
+
-    // TODO: We should update the logic once incremental container report
-    // type is supported.
-    if (reports.getType() ==
-        ContainerReportsRequestProto.reportType.fullReport) {
-      ContainerStat stat = new ContainerStat();
-      for (StorageContainerDatanodeProtocolProtos.ContainerInfo info : reports
-          .getReportsList()) {
-        stat.add(new ContainerStat(info.getSize(), info.getUsed(),
-            info.getKeyCount(), info.getReadBytes(), info.getWriteBytes(),
-            info.getReadCount(), info.getWriteCount()));
-      }
-
-      // update container metrics
-      metrics.setLastContainerReportSize(stat.getSize().get());
-      metrics.setLastContainerReportUsed(stat.getUsed().get());
-      metrics.setLastContainerReportKeyCount(stat.getKeyCount().get());
-      metrics.setLastContainerReportReadBytes(stat.getReadBytes().get());
-      metrics.setLastContainerReportWriteBytes(stat.getWriteBytes().get());
-      metrics.setLastContainerReportReadCount(stat.getReadCount().get());
-      metrics.setLastContainerReportWriteCount(stat.getWriteCount().get());
-    }
+    updateContainerReportMetrics(reports);
+  private void updateContainerReportMetrics(
+      ContainerReportsRequestProto reports) {
+    ContainerStat newStat = null;
+    // TODO: We should update the logic once incremental container report
+    // type is supported.
+    if (reports
+        .getType() == ContainerReportsRequestProto.reportType.fullReport) {
+      newStat = new ContainerStat();
+      for (StorageContainerDatanodeProtocolProtos.ContainerInfo info : reports
+          .getReportsList()) {
+        newStat.add(new ContainerStat(info.getSize(), info.getUsed(),
+            info.getKeyCount(), info.getReadBytes(), info.getWriteBytes(),
+            info.getReadCount(), info.getWriteCount()));
+      }
+
+      // update container metrics
+      metrics.setLastContainerStat(newStat);
+    }
+
+    // Update container stat entry, this will trigger a removal operation if it
+    // exists in cache.
+    synchronized (containerReportCache) {
+      String datanodeUuid = reports.getDatanodeID().getDatanodeUuid();
+      if (datanodeUuid != null && newStat != null) {
+        containerReportCache.put(datanodeUuid, newStat);
+        // update global view container metrics
+        metrics.incrContainerStat(newStat);
+      }
+    }
+  }
+
+
+  /**
+   * Invalidate container stat entry for given datanode.
+   *
+   * @param datanodeUuid
+   */
+  public void removeContainerReport(String datanodeUuid) {
+    synchronized (containerReportCache) {
+      containerReportCache.invalidate(datanodeUuid);
+    }
+  }
+
+  /**
+   * Get container stat of specified datanode.
+   *
+   * @param datanodeUuid
+   * @return
+   */
+  public ContainerStat getContainerReport(String datanodeUuid) {
+    ContainerStat stat = null;
+    synchronized (containerReportCache) {
+      stat = containerReportCache.getIfPresent(datanodeUuid);
+    }
+
+    return stat;
+  }
+
+  /**
+   * Returns a view of the container stat entries. Modifications made to the
+   * map will directly affect the cache.
+   *
+   * @return
+   */
+  public ConcurrentMap<String, ContainerStat> getContainerReportCache() {
+    return containerReportCache.asMap();
+  }
+
+  @Override
+  public Map<String, String> getContainerReport() {
+    Map<String, String> id2StatMap = new HashMap<>();
+    synchronized (containerReportCache) {
+      ConcurrentMap<String, ContainerStat> map = containerReportCache.asMap();
+      for (Map.Entry<String, ContainerStat> entry : map.entrySet()) {
+        id2StatMap.put(entry.getKey(), entry.getValue().toJsonString());
+      }
+    }
+
+    return id2StatMap;
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS74 INS59 INS29 INS83 INS39 INS42 INS44 INS8 INS8 INS83 INS39 INS42 INS44 MOV8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS74 INS42 INS8 INS78 INS83 INS74 INS42 INS8 INS65 INS43 INS43 INS43 INS42 INS21 INS65 INS65 INS43 INS42 INS21 INS25 INS25 INS21 MOV21 MOV41 INS43 INS42 INS60 INS51 INS65 INS65 INS43 INS42 INS51 INS65 INS65 INS65 INS42 INS43 INS42 INS60 INS51 INS41 INS65 INS65 INS43 INS43 INS43 INS41 INS42 INS43 INS43 INS43 INS60 INS51 INS41 INS66 INS42 INS42 INS42 INS32 INS66 INS42 INS42 INS7 INS27 INS8 INS27 INS8 INS32 INS42 MOV43 INS59 MOV70 INS42 INS8 INS66 INS42 INS42 INS42 INS8 INS66 INS42 INS42 INS43 INS59 INS42 INS8 INS42 INS66 INS66 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS74 INS59 INS42 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS33 MOV21 INS42 INS42 INS42 INS33 INS60 INS25 INS21 INS42 INS42 INS33 INS21 INS42 INS42 INS43 INS43 INS43 INS42 INS14 INS60 INS70 INS52 INS32 INS42 INS32 INS32 INS7 INS43 INS59 INS27 INS8 INS32 INS7 INS42 INS42 INS42 INS74 INS74 INS59 INS44 INS32 INS8 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS42 MOV14 UPD42 UPD42 MOV42 INS42 INS42 INS32 INS27 INS27 INS21 INS21 INS42 INS42 INS42 INS42 INS32 INS43 INS43 INS43 INS43 INS42 INS32 INS74 INS42 INS42 INS42 INS21 INS32 INS42 INS40 INS74 INS1 INS32 INS42 INS42 INS33 INS42 INS33 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS32 INS32 INS42 INS40 INS40 INS43 INS43 INS43 INS31 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS78 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS32 INS42 INS42 INS74 INS42 INS51 INS42 INS42 INS43 INS43 INS43 INS42 INS8 INS42 INS42 INS42 INS60 INS21 INS21 INS43 INS59 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21
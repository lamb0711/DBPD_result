YARN-7788. Factor out management of temp tags from AllocationTagsManager. (Arun Suresh via kkaranasos)

-import org.apache.hadoop.yarn.api.records.ApplicationAttemptId;
-import org.apache.hadoop.yarn.api.resource.PlacementConstraints;
-import java.util.HashSet;
-  // Application's Temporary containers mapping
-  private Map<ApplicationId, Map<NodeId, Map<ContainerId, Set<String>>>>
-      appTempMappings = new HashMap<>();
-  static class TypeToCountedTags<T> {
+  public static class TypeToCountedTags<T> {
-  Map<ApplicationId, TypeToCountedTags> getPerAppNodeMappings() {
+  public Map<ApplicationId, TypeToCountedTags> getPerAppNodeMappings() {
-  @VisibleForTesting
-  public Map<NodeId, Map<ContainerId, Set<String>>> getAppTempMappings(
-      ApplicationId applicationId) {
-    return appTempMappings.get(applicationId);
-  }
-
-  //
-
-  /**
-   * Method adds a temporary fake-container tag to Node mapping.
-   * Used by the constrained placement algorithm to keep track of containers
-   * that are currently placed on nodes but are not yet allocated.
-   * @param nodeId
-   * @param applicationId
-   * @param allocationTags
-   */
-  public void addTempContainer(NodeId nodeId, ApplicationId applicationId,
-      Set<String> allocationTags) {
-    ContainerId tmpContainer = ContainerId.newContainerId(
-        ApplicationAttemptId.newInstance(applicationId, 1), System.nanoTime());
-
-    writeLock.lock();
-    try {
-      Map<NodeId, Map<ContainerId, Set<String>>> appTempMapping =
-          appTempMappings.computeIfAbsent(applicationId, k -> new HashMap<>());
-      Map<ContainerId, Set<String>> containerTempMapping =
-          appTempMapping.computeIfAbsent(nodeId, k -> new HashMap<>());
-      containerTempMapping.put(tmpContainer, allocationTags);
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Added TEMP container=" + tmpContainer + " with tags=["
-            + StringUtils.join(allocationTags, ",") + "]");
-      }
-    } finally {
-      writeLock.unlock();
-    }
-
-    addContainer(nodeId, tmpContainer, allocationTags);
-  }
-
+    addTags(nodeId, applicationId, allocationTags);
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Added container=" + containerId + " with tags=["
+          + StringUtils.join(allocationTags, ",") + "]");
+    }
+  }
+
+  public void addTags(NodeId nodeId, ApplicationId applicationId,
+      Set<String> allocationTags) {
-
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Added container=" + containerId + " with tags=["
-            + StringUtils.join(allocationTags, ",") + "]");
-      }
+    removeTags(nodeId, applicationId, allocationTags);
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Removed container=" + containerId + " with tags=["
+          + StringUtils.join(allocationTags, ",") + "]");
+    }
+  }
+
+  /**
+   * Helper method to just remove the tags associated with a container.
+   * @param nodeId
+   * @param applicationId
+   * @param allocationTags
+   */
+  public void removeTags(NodeId nodeId, ApplicationId applicationId,
+      Set<String> allocationTags) {
-
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Removed container=" + containerId + " with tags=["
-            + StringUtils.join(allocationTags, ",") + "]");
-      }
-  /**
-   * Method removes temporary containers associated with an application
-   * Used by the placement algorithm to clean temporary tags at the end of
-   * a placement cycle.
-   * @param applicationId Application Id.
-   */
-  public void cleanTempContainers(ApplicationId applicationId) {
-
-    if (!appTempMappings.get(applicationId).isEmpty()) {
-      appTempMappings.get(applicationId).entrySet().stream().forEach(nodeE -> {
-        nodeE.getValue().entrySet().stream().forEach(containerE -> {
-          removeContainer(nodeE.getKey(), containerE.getKey(),
-              containerE.getValue());
-        });
-      });
-      writeLock.lock();
-      try {
-        appTempMappings.remove(applicationId);
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Removed TEMP containers of app=" + applicationId);
-        }
-      } finally {
-        writeLock.unlock();
-      }
-    }
-  }
-

MOV31 MOV31 INS83 INS83 MOV29 MOV79 INS39 INS42 MOV44 MOV44 MOV44 UPD42 MOV44 MOV29 MOV79 INS42 INS44 MOV44 INS44 INS8 MOV29 UPD42 MOV44 MOV25 MOV60 INS21 MOV25 INS43 INS42 INS74 INS42 MOV25 MOV60 MOV21 MOV25 INS32 MOV42 MOV43 MOV43 UPD66 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 UPD42 UPD42 INS42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL74 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL42 DEL78 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL74 DEL42 DEL32 DEL41 DEL45 DEL42 DEL45 DEL42 DEL42 DEL45 DEL32 DEL45 DEL27 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL59 DEL42 DEL43 DEL74 DEL14 DEL86 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL59 DEL42 DEL43 DEL74 DEL14 DEL86 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL59 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL59 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL86 DEL32 DEL21 DEL8 DEL86 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL31
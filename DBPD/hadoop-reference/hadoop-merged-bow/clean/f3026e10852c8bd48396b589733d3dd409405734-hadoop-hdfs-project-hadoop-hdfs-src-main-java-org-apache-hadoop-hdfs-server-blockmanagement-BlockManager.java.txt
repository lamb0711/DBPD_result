Merge trunk into HA branch.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1292838 13f79535-47bb-0310-9956-ffa450edef68

+   * @param reason a textual reason why the block should be marked corrupt,
+   * for logging purposes
-      final DatanodeInfo dn) throws IOException {
+      final DatanodeInfo dn, String reason) throws IOException {
-    markBlockAsCorrupt(storedBlock, dn);
+    markBlockAsCorrupt(storedBlock, dn, reason);
-                                  DatanodeInfo dn) throws IOException {
+                                  DatanodeInfo dn,
+                                  String reason) throws IOException {
-    corruptReplicas.addToCorruptReplicasMap(storedBlock, node);
+    corruptReplicas.addToCorruptReplicasMap(storedBlock, node, reason);
+  
+  /**
+   * BlockToMarkCorrupt is used to build the "toCorrupt" list, which is a
+   * list of blocks that should be considered corrupt due to a block report.
+   */
+  private static class BlockToMarkCorrupt {
+    final BlockInfo blockInfo;
+    final String reason;
+    
+    BlockToMarkCorrupt(BlockInfo blockInfo, String reason) {
+      super();
+      this.blockInfo = blockInfo;
+      this.reason = reason;
+    }
+  }
-    Collection<BlockInfo> toCorrupt = new LinkedList<BlockInfo>();
+    Collection<BlockToMarkCorrupt> toCorrupt = new LinkedList<BlockToMarkCorrupt>();
-    for (BlockInfo b : toCorrupt) {
-      markBlockAsCorrupt(b, node);
+    for (BlockToMarkCorrupt b : toCorrupt) {
+      markBlockAsCorrupt(b.blockInfo, node, b.reason);
-      if (isReplicaCorrupt(iblk, reportedState, storedBlock, ucState, node)) {
+      BlockToMarkCorrupt c = checkReplicaCorrupt(
+          iblk, reportedState, storedBlock, ucState, node);
+      if (c != null) {
-          markBlockAsCorrupt(storedBlock, node);
+          markBlockAsCorrupt(c.blockInfo, node, c.reason);
-      Collection<BlockInfo> toCorrupt,      // add to corrupt replicas list
+      Collection<BlockToMarkCorrupt> toCorrupt, // add to corrupt replicas list
-      final Collection<BlockInfo> toCorrupt,
+      final Collection<BlockToMarkCorrupt> toCorrupt,
-    if (isReplicaCorrupt(block, reportedState, storedBlock, ucState, dn)) {
+    BlockToMarkCorrupt c = checkReplicaCorrupt(
+        block, reportedState, storedBlock, ucState, dn);
+    if (c != null) {
-
-        toCorrupt.add(storedBlock);
+        toCorrupt.add(c);
+   * 
+   * @return a BlockToMarkCorrupt object, or null if the replica is not corrupt
-  private boolean isReplicaCorrupt(Block iblk, ReplicaState reportedState, 
+  private BlockToMarkCorrupt checkReplicaCorrupt(
+      Block iblk, ReplicaState reportedState, 
-        return (storedBlock.getGenerationStamp() != iblk.getGenerationStamp()
-            || storedBlock.getNumBytes() != iblk.getNumBytes());
+        if (storedBlock.getGenerationStamp() != iblk.getGenerationStamp()) {
+          return new BlockToMarkCorrupt(storedBlock,
+              "block is " + ucState + " and reported genstamp " +
+              iblk.getGenerationStamp() + " does not match " +
+              "genstamp in block map " + storedBlock.getGenerationStamp());
+        } else if (storedBlock.getNumBytes() != iblk.getNumBytes()) {
+          return new BlockToMarkCorrupt(storedBlock,
+              "block is " + ucState + " and reported length " +
+              iblk.getNumBytes() + " does not match " +
+              "length in block map " + storedBlock.getNumBytes());
+        } else {
+          return null; // not corrupt
+        }
-        return false;
+        return null;
-        return false;
+        return null; // not corrupt
-        return true;
+        return new BlockToMarkCorrupt(storedBlock,
+            "reported " + reportedState + " replica with genstamp " +
+            iblk.getGenerationStamp() + " does not match COMPLETE block's " +
+            "genstamp in block map " + storedBlock.getGenerationStamp());
-          return false;
+          return null;
-          return true;
+          return new BlockToMarkCorrupt(storedBlock,
+              "reported replica has invalid state " + reportedState);
-      LOG.warn("Unexpected replica state " + reportedState
-          + " for block: " + storedBlock + 
-          " on " + dn.getName() + " size " + storedBlock.getNumBytes());
-      return true;
+      String msg = "Unexpected replica state " + reportedState
+      + " for block: " + storedBlock + 
+      " on " + dn.getName() + " size " + storedBlock.getNumBytes();
+      // log here at WARN level since this is really a broken HDFS
+      // invariant
+      LOG.warn(msg);
+      return new BlockToMarkCorrupt(storedBlock, msg);
-    Collection<BlockInfo> toCorrupt = new LinkedList<BlockInfo>();
+    Collection<BlockToMarkCorrupt> toCorrupt = new LinkedList<BlockToMarkCorrupt>();
-    for (BlockInfo b : toCorrupt) {
-      markBlockAsCorrupt(b, node);
+    for (BlockToMarkCorrupt b : toCorrupt) {
+      markBlockAsCorrupt(b.blockInfo, node, b.reason);

INS55 INS44 INS44 INS29 INS83 INS83 INS42 INS23 INS23 INS31 INS43 UPD42 INS65 INS43 INS42 INS43 INS42 INS65 INS83 MOV43 INS59 INS83 INS43 INS59 INS42 MOV44 INS44 INS8 UPD74 UPD74 INS60 INS42 INS42 INS66 INS66 INS42 INS42 INS66 INS66 INS42 INS42 INS42 UPD42 INS43 INS42 INS46 INS21 INS21 UPD74 INS44 UPD43 UPD43 INS43 INS59 INS27 INS60 UPD74 INS42 INS42 INS42 INS7 INS7 INS43 INS43 INS42 INS60 UPD42 UPD42 INS42 INS42 INS32 INS42 INS33 INS25 INS43 INS59 INS14 UPD43 UPD43 INS22 INS42 INS22 INS42 INS42 UPD74 INS42 INS43 INS59 INS27 INS42 INS42 INS42 INS42 INS42 INS42 MOV27 INS8 INS25 INS33 INS42 INS42 MOV27 INS42 INS43 INS42 INS42 UPD42 UPD74 UPD42 INS52 INS42 INS52 INS42 UPD43 INS40 INS40 INS42 INS42 INS32 INS42 INS33 INS41 MOV27 INS8 INS8 INS33 INS42 UPD43 INS40 INS40 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS41 INS41 INS14 UPD42 UPD42 INS43 INS42 INS27 INS14 INS33 INS43 INS42 INS27 INS42 INS45 INS42 INS45 INS32 INS45 INS45 INS32 INS43 INS42 INS27 INS42 INS45 INS42 INS45 INS32 INS45 INS45 INS32 INS33 INS14 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS32 INS45 INS45 INS32 INS42 INS42 INS42 INS42 INS43 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS45 INS42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL39 DEL27 DEL36 DEL41 DEL9 DEL9 DEL9 DEL9 DEL9 DEL9 DEL42
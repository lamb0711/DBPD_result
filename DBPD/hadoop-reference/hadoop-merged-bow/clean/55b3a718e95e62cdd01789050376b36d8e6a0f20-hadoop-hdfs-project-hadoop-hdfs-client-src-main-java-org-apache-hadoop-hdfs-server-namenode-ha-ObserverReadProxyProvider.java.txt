HDFS-14211. [SBN Read]. Add a configurable flag to enable always-msync mode to ObserverReadProxyProvider. Contributed by Erik Krogen.

+import java.util.concurrent.TimeUnit;
+import org.apache.hadoop.util.Time;
+  /** Configuration key for {@link #autoMsyncPeriodMs}. */
+  static final String AUTO_MSYNC_PERIOD_KEY_PREFIX =
+      HdfsClientConfigKeys.Failover.PREFIX + "observer.auto-msync-period";
+  /** Auto-msync disabled by default. */
+  static final long AUTO_MSYNC_PERIOD_DEFAULT = -1;
+
+   * This adjusts how frequently this proxy provider should auto-msync to the
+   * Active NameNode, automatically performing an msync() call to the active
+   * to fetch the current transaction ID before submitting read requests to
+   * observer nodes. See HDFS-14211 for more description of this feature.
+   * If this is below 0, never auto-msync. If this is 0, perform an msync on
+   * every read operation. If this is above 0, perform an msync after this many
+   * ms have elapsed since the last msync.
+   */
+  private final long autoMsyncPeriodMs;
+
+  /**
+   * The time, in millisecond epoch, that the last msync operation was
+   * performed. This includes any implicit msync (any operation which is
+   * serviced by the Active NameNode).
+   */
+  private volatile long lastMsyncTimeMs = -1;
+
+  /**
+
+    autoMsyncPeriodMs = conf.getTimeDuration(
+        // The host of the URI is the nameservice ID
+        AUTO_MSYNC_PERIOD_KEY_PREFIX + "." + uri.getHost(),
+        AUTO_MSYNC_PERIOD_DEFAULT, TimeUnit.MILLISECONDS);
+
+    lastMsyncTimeMs = Time.monotonicNow();
+  }
+
+  /**
+   * This will call {@link ClientProtocol#msync()} on the active NameNode
+   * (via the {@link #failoverProxy}) to update the state of this client, only
+   * if at least {@link #autoMsyncPeriodMs} ms has elapsed since the last time
+   * an msync was performed.
+   *
+   * @see #autoMsyncPeriodMs
+   */
+  private void autoMsyncIfNecessary() throws IOException {
+    if (autoMsyncPeriodMs == 0) {
+      // Always msync
+      failoverProxy.getProxy().proxy.msync();
+    } else if (autoMsyncPeriodMs > 0) {
+      if (Time.monotonicNow() - lastMsyncTimeMs > autoMsyncPeriodMs) {
+        synchronized (this) {
+          // Use a synchronized block so that only one thread will msync
+          // if many operations are submitted around the same time.
+          // Re-check the entry criterion since the status may have changed
+          // while waiting for the lock.
+          if (Time.monotonicNow() - lastMsyncTimeMs > autoMsyncPeriodMs) {
+            failoverProxy.getProxy().proxy.msync();
+            lastMsyncTimeMs = Time.monotonicNow();
+          }
+        }
+      }
+    }
+        } else {
+          autoMsyncIfNecessary();
+      lastMsyncTimeMs = Time.monotonicNow();

INS26 INS26 INS40 INS40 INS23 INS23 INS23 INS23 INS31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS39 INS42 INS43 INS8 INS65 INS42 INS42 INS27 INS65 INS42 INS38 INS65 INS42 INS65 INS42 INS38 INS21 INS21 INS65 INS65 INS42 INS25 INS66 INS65 INS66 INS40 INS45 INS66 INS34 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS34 INS7 INS7 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS67 INS27 INS8 INS25 INS21 INS67 INS42 INS32 INS42 INS32 INS68 INS67 INS67 INS42 INS42 INS34 INS21 INS27 INS8 INS7 INS42 INS42 INS42 INS27 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS25 INS42 INS32 INS42 INS45 INS32 INS22 INS42 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS42 INS51 INS21 INS42 INS42 INS32 INS42 INS52 INS8 INS32 INS42 INS42 INS25 INS42 INS27 INS8 INS27 INS42 INS21 INS21 INS32 INS42 INS32 INS7 INS42 INS42 INS22 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42
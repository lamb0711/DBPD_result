HDFS-13250. RBF: Router to manage requests across multiple subclusters. Contributed by Inigo Goiri.

+    if (createParent && isPathAll(src)) {
+      int index = src.lastIndexOf(Path.SEPARATOR);
+      String parent = src.substring(0, index);
+      LOG.debug("Creating {} requires creating parent {}", src, parent);
+      FsPermission parentPermissions = getParentPermission(masked);
+      boolean success = mkdirs(parent, parentPermissions, createParent);
+      if (!success) {
+        // This shouldn't happen as mkdirs returns true or exception
+        LOG.error("Couldn't create parents for {}", src);
+      }
+    }
+
+   * Get the permissions for the parent of a child with given permissions. If
+   * the child has r--, we will set it to r-x.
+   * @param mask The permission mask of the child.
+   * @return The permission mask of the parent.
+   */
+  private static FsPermission getParentPermission(final FsPermission mask) {
+    FsPermission ret = new FsPermission(
+        applyExecute(mask.getUserAction()),
+        applyExecute(mask.getGroupAction()),
+        applyExecute(mask.getOtherAction()));
+    return ret;
+  }
+
+  /**
+   * Apply the execute permissions if it can be read.
+   * @param action Input permission.
+   * @return Output permission.
+   */
+  private static FsAction applyExecute(final FsAction action) {
+    if (action.and(FsAction.READ) == FsAction.READ) {
+      return action.or(FsAction.EXECUTE);
+    }
+    return action;
+  }
+
+  /**
-    return (LastBlockWithStatus) rpcClient.invokeSequential(
+    return rpcClient.invokeSequential(
-    rpcClient.invokeSequential(locations, method);
+    if (isPathAll(src)) {
+      rpcClient.invokeConcurrent(locations, method);
+    } else {
+      rpcClient.invokeSequential(locations, method);
+    }
-    rpcClient.invokeSequential(locations, method);
+    if (isPathAll(src)) {
+      rpcClient.invokeConcurrent(locations, method);
+    } else {
+      rpcClient.invokeSequential(locations, method);
+    }
-    return ((Boolean) rpcClient.invokeSequential(locations, method,
-        Boolean.class, Boolean.TRUE)).booleanValue();
+    if (isPathAll(src)) {
+      return rpcClient.invokeAll(locations, method);
+    } else {
+      return rpcClient.invokeSequential(locations, method,
+          Boolean.class, Boolean.TRUE).booleanValue();
+    }
+    RemoteMethod method = new RemoteMethod("mkdirs",
+        new Class<?>[] {String.class, FsPermission.class, boolean.class},
+        new RemoteParam(), masked, createParent);
+
+    // Create in all locations
+    if (isPathAll(src)) {
+      return rpcClient.invokeAll(locations, method);
+    }
+
-    RemoteMethod method = new RemoteMethod("mkdirs",
-        new Class<?>[] {String.class, FsPermission.class, boolean.class},
-        new RemoteParam(), masked, createParent);
-    HdfsFileStatus ret = (HdfsFileStatus) rpcClient.invokeSequential(
-        locations, method, HdfsFileStatus.class, null);
+
+    HdfsFileStatus ret = null;
+    // If it's a directory, we check in all locations
+    if (isPathAll(src)) {
+      ret = getFileInfoAll(locations, method);
+    } else {
+      // Check for file information sequentially
+      ret = (HdfsFileStatus) rpcClient.invokeSequential(
+          locations, method, HdfsFileStatus.class, null);
+    }
+  /**
+   * Get the file info from all the locations.
+   *
+   * @param locations Locations to check.
+   * @param method The file information method to run.
+   * @return The first file info if it's a file, the directory if it's
+   *         everywhere.
+   * @throws IOException If all the locations throw an exception.
+   */
+  private HdfsFileStatus getFileInfoAll(final List<RemoteLocation> locations,
+      final RemoteMethod method) throws IOException {
+
+    // Get the file info from everybody
+    Map<RemoteLocation, HdfsFileStatus> results =
+        rpcClient.invokeConcurrent(locations, method, HdfsFileStatus.class);
+
+    // We return the first file
+    HdfsFileStatus dirStatus = null;
+    for (RemoteLocation loc : locations) {
+      HdfsFileStatus fileStatus = results.get(loc);
+      if (fileStatus != null) {
+        if (!fileStatus.isDirectory()) {
+          return fileStatus;
+        } else if (dirStatus == null) {
+          dirStatus = fileStatus;
+        }
+      }
+    }
+    return dirStatus;
+  }
+
+   * Check if a path should be in all subclusters.
+   *
+   * @param path Path to check.
+   * @return If a path should be in all subclusters.
+   */
+  private boolean isPathAll(final String path) {
+    if (subclusterResolver instanceof MountTableResolver) {
+      try {
+        MountTableResolver mountTable = (MountTableResolver)subclusterResolver;
+        MountTable entry = mountTable.getMountPoint(path);
+        if (entry != null) {
+          return entry.isAll();
+        }
+      } catch (IOException e) {
+        LOG.error("Cannot get mount point: {}", e.getMessage());
+      }
+    }
+    return false;
+  }
+
+  /**

INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 MOV60 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS25 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS60 INS41 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS25 INS41 INS25 INS25 INS25 INS25 INS25 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS74 INS42 INS83 INS43 INS42 INS42 INS60 INS60 INS70 INS41 INS65 INS65 INS65 INS83 INS43 INS42 INS25 INS41 INS27 INS8 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS59 INS42 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS42 MOV32 INS32 INS8 INS8 INS32 INS8 INS8 INS32 INS8 INS8 INS32 INS8 INS32 INS8 INS8 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS43 INS43 INS42 INS74 INS59 INS43 INS59 INS44 INS42 INS8 INS42 INS66 INS42 INS66 INS66 INS42 INS62 INS8 INS9 INS42 INS32 INS60 INS60 INS21 INS60 INS60 INS25 INS42 INS42 INS14 INS32 INS40 INS41 INS42 INS42 INS21 INS21 INS42 INS42 MOV21 MOV21 INS42 INS42 INS41 MOV41 INS42 INS42 INS41 INS33 INS42 INS42 INS21 INS21 INS42 INS42 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS33 INS43 INS42 INS60 INS25 INS42 INS43 INS54 INS42 INS42 INS39 INS59 INS43 INS59 INS32 INS43 INS59 INS39 INS59 INS38 INS8 INS43 INS32 INS32 INS32 INS42 INS42 INS40 INS32 INS32 INS32 INS32 INS32 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS57 INS42 INS43 INS59 INS27 INS8 INS42 INS8 INS12 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS21 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV11 INS43 INS42 INS42 INS32 INS42 INS33 INS25 INS60 INS60 INS25 INS44 INS8 INS42 INS42 INS40 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS8 INS25 INS43 INS59 INS43 INS59 INS27 INS8 INS43 INS42 INS21 INS42 INS42 INS45 INS42 INS32 INS41 INS27 INS8 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS32 INS42 INS42 INS42 INS42 INS33 INS21 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS32 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL43 DEL11 DEL42 DEL43 DEL11 DEL36
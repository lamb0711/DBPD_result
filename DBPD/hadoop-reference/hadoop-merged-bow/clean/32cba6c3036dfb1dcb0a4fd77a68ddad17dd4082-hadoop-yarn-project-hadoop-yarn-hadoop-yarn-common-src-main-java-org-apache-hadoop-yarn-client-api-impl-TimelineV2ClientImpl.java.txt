YARN-5355: YARN Timeline Service v.2: alpha 2 (varunsaxena)

+import java.io.InterruptedIOException;
+import java.lang.reflect.UndeclaredThrowableException;
+import java.net.InetSocketAddress;
+import java.security.PrivilegedExceptionAction;
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.net.NetUtils;
+import org.apache.hadoop.security.SecurityUtil;
+import org.apache.hadoop.yarn.api.records.CollectorInfo;
+import org.apache.hadoop.yarn.api.records.Token;
+import org.apache.hadoop.yarn.security.client.TimelineDelegationTokenIdentifier;
+import com.google.common.annotations.VisibleForTesting;
+  @VisibleForTesting
+  volatile Token currentTimelineToken = null;
+  private UserGroupInformation authUgi;
+
-    UserGroupInformation authUgi = null;
-
-  public void setTimelineServiceAddress(String address) {
-    this.timelineServiceAddress = address;
+  public void setTimelineCollectorInfo(CollectorInfo collectorInfo) {
+    if (collectorInfo == null) {
+      LOG.warn("Not setting collector info as it is null.");
+      return;
+    }
+    // First update the token so that it is available when collector address is
+    // used.
+    if (collectorInfo.getCollectorToken() != null) {
+      // Use collector address to update token service if its not available.
+      setTimelineDelegationToken(
+          collectorInfo.getCollectorToken(), collectorInfo.getCollectorAddr());
+    }
+    // Update timeline service address.
+    if (collectorInfo.getCollectorAddr() != null &&
+        !collectorInfo.getCollectorAddr().isEmpty() &&
+        !collectorInfo.getCollectorAddr().equals(timelineServiceAddress)) {
+      this.timelineServiceAddress = collectorInfo.getCollectorAddr();
+      LOG.info("Updated timeline service address to " + timelineServiceAddress);
+    }
+  }
+
+  private void setTimelineDelegationToken(Token delegationToken,
+      String collectorAddr) {
+    // Checks below are to ensure that an invalid token is not updated in UGI.
+    // This is required because timeline token is set via a public API.
+    if (!delegationToken.getKind().equals(
+        TimelineDelegationTokenIdentifier.KIND_NAME.toString())) {
+      LOG.warn("Timeline token to be updated should be of kind " +
+          TimelineDelegationTokenIdentifier.KIND_NAME);
+      return;
+    }
+    if (collectorAddr == null || collectorAddr.isEmpty()) {
+      collectorAddr = timelineServiceAddress;
+    }
+    // Token need not be updated if both address and token service do not exist.
+    String service = delegationToken.getService();
+    if ((service == null || service.isEmpty()) &&
+        (collectorAddr == null || collectorAddr.isEmpty())) {
+      LOG.warn("Timeline token does not have service and timeline service " +
+          "address is not yet set. Not updating the token");
+      return;
+    }
+    // No need to update a duplicate token.
+    if (currentTimelineToken != null &&
+        currentTimelineToken.equals(delegationToken)) {
+      return;
+    }
+    currentTimelineToken = delegationToken;
+    // Convert the token, sanitize the token service and add it to UGI.
+    org.apache.hadoop.security.token.
+        Token<TimelineDelegationTokenIdentifier> timelineToken =
+            new org.apache.hadoop.security.token.
+            Token<TimelineDelegationTokenIdentifier>(
+                delegationToken.getIdentifier().array(),
+                delegationToken.getPassword().array(),
+                new Text(delegationToken.getKind()),
+                service == null ? new Text() : new Text(service));
+    // Prefer timeline service address over service coming in the token for
+    // updating the token service.
+    InetSocketAddress serviceAddr =
+        (collectorAddr != null && !collectorAddr.isEmpty()) ?
+        NetUtils.createSocketAddr(collectorAddr) :
+        SecurityUtil.getTokenServiceAddr(timelineToken);
+    SecurityUtil.setTokenService(timelineToken, serviceAddr);
+    authUgi.addToken(timelineToken);
+    LOG.info("Updated timeline delegation token " + timelineToken);
+  private ClientResponse doPutObjects(URI base, String path,
+      MultivaluedMap<String, String> params, Object obj) {
+    return connector.getClient().resource(base).path(path).queryParams(params)
+        .accept(MediaType.APPLICATION_JSON).type(MediaType.APPLICATION_JSON)
+        .put(ClientResponse.class, obj);
+  }
+
-    ClientResponse resp;
+    ClientResponse resp = null;
-      resp = connector.getClient().resource(base).path(path).queryParams(params)
-          .accept(MediaType.APPLICATION_JSON).type(MediaType.APPLICATION_JSON)
-          .put(ClientResponse.class, obj);
-    } catch (RuntimeException re) {
-      // runtime exception is expected if the client cannot connect the server
-      String msg = "Failed to get the response from the timeline server.";
-      LOG.error(msg, re);
-      throw new IOException(re);
+      resp = authUgi.doAs(new PrivilegedExceptionAction<ClientResponse>() {
+        @Override
+        public ClientResponse run() throws Exception {
+          return doPutObjects(base, path, params, obj);
+        }
+      });
+    } catch (UndeclaredThrowableException ue) {
+      Throwable cause = ue.getCause();
+      if (cause instanceof IOException) {
+        throw (IOException)cause;
+      } else {
+        throw new IOException(cause);
+      }
+    } catch (InterruptedException ie) {
+      throw (IOException) new InterruptedIOException().initCause(ie);

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS78 INS83 INS43 INS59 INS83 MOV43 INS59 INS42 INS44 INS8 INS83 INS39 INS42 INS44 MOV44 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS44 MOV8 INS42 INS42 INS42 INS33 INS42 INS43 INS42 INS25 INS25 INS25 INS43 INS42 UPD42 INS25 INS25 INS60 INS25 INS25 INS21 INS60 INS60 INS21 INS21 INS21 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS43 INS42 INS41 INS42 INS27 INS8 INS27 INS8 INS27 MOV8 INS42 INS38 INS8 INS27 INS8 MOV43 INS59 INS27 INS8 INS27 INS8 INS7 INS74 INS59 INS43 INS59 INS32 INS32 INS32 INS42 INS42 INS43 INS43 INS43 INS42 MOV32 INS8 INS12 INS42 INS33 INS21 INS41 INS32 INS33 INS21 INS27 INS38 INS21 INS32 INS21 INS41 INS27 INS32 INS21 INS42 INS32 INS36 INS36 INS21 INS41 INS27 INS32 INS41 INS42 INS42 INS43 INS43 INS42 INS14 INS42 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS33 INS21 INS44 INS8 INS32 INS42 INS42 INS32 INS27 INS38 INS32 INS32 INS32 INS42 INS32 INS32 INS42 INS33 INS42 INS42 INS7 INS42 INS42 INS27 INS27 INS32 INS42 INS33 INS42 INS42 INS42 INS40 INS42 INS74 INS32 INS32 INS14 INS16 INS36 INS32 INS32 INS45 INS42 INS7 UPD43 UPD42 INS25 INS43 INS42 INS53 INS42 INS42 INS45 INS42 INS32 INS32 INS32 INS33 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS40 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS27 INS32 INS42 INS42 INS27 INS43 INS43 INS32 INS42 INS32 INS42 INS43 INS32 INS27 INS14 INS14 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 INS43 INS62 INS8 INS8 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS40 INS42 INS33 INS42 INS42 INS42 INS33 INS42 INS42 INS45 INS45 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS43 INS43 INS42 INS27 INS38 INS42 INS42 INS14 INS42 UPD42 INS32 INS42 INS43 MOV53 INS53 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS33 INS32 INS74 INS1 INS42 INS42 INS42 INS11 INS14 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS43 INS31 MOV43 INS42 INS43 INS42 INS43 INS42 INS42 INS78 INS83 INS43 INS42 INS43 INS8 INS42 INS42 INS42 INS42 INS42 INS41 INS32 INS42 INS42 INS42 INS42 INS42 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL42 DEL7 DEL21 DEL45 DEL42 DEL14 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21
HDFS-9866. BlockManager#chooseExcessReplicasStriped may weaken rack fault tolerance. Contributed by Jing Zhao.

-   * Same as {@link #chooseTarget(String, int, Node, Set, long, List, StorageType)}
-   * with added parameter {@code favoredDatanodes}
-  abstract public BlockPlacementStatus verifyBlockPlacement(
+  public abstract BlockPlacementStatus verifyBlockPlacement(
-   * @param candidates
+   * @param availableReplicas
+   * @param delCandidates
+   *          Candidates for deletion. For normal replication, this set is the
+   *          same with availableReplicas. For striped blocks, this set is a
+   *          subset of availableReplicas.
-   *          The required number of replicas for this block
+   *          The expected number of replicas remaining in the delCandidates
-  abstract public List<DatanodeStorageInfo> chooseReplicasToDelete(
-      Collection<DatanodeStorageInfo> candidates, int expectedNumOfReplicas,
+  public abstract List<DatanodeStorageInfo> chooseReplicasToDelete(
+      Collection<DatanodeStorageInfo> availableReplicas,
+      Collection<DatanodeStorageInfo> delCandidates, int expectedNumOfReplicas,
+
-  abstract protected void initialize(Configuration conf,  FSClusterStats stats, 
+  protected abstract void initialize(Configuration conf,  FSClusterStats stats,
-  abstract public boolean isMovable(Collection<DatanodeInfo> candidates,
+  public abstract boolean isMovable(Collection<DatanodeInfo> candidates,
-    } else if (datanode instanceof DatanodeStorageInfo) {
-      return ((DatanodeStorageInfo)datanode).getDatanodeDescriptor();
-      return null;
+      return ((DatanodeStorageInfo)datanode).getDatanodeDescriptor();
-   * 
-   * @param storagesOrDataNodes DatanodeStorageInfo/DatanodeInfo to be split
+   *
+   * @param availableSet all the available DataNodes/storages of the block
+   * @param candidates DatanodeStorageInfo/DatanodeInfo to be split
-      final Iterable<T> storagesOrDataNodes,
+      final Iterable<T> availableSet,
+      final Collection<T> candidates,
-    for(T s: storagesOrDataNodes) {
+    for(T s: availableSet) {
-        storageList = new ArrayList<T>();
+        storageList = new ArrayList<>();
-    // split nodes into two sets
-    for(List<T> storageList : rackMap.values()) {
-      if (storageList.size() == 1) {
+    for (T candidate : candidates) {
+      final String rackName = getRack(getDatanodeInfo(candidate));
+      if (rackMap.get(rackName).size() == 1) {
-        exactlyOne.add(storageList.get(0));
+        exactlyOne.add(candidate);
-        moreThanOne.addAll(storageList);
+        moreThanOne.add(candidate);

INS83 INS83 INS44 INS83 INS83 INS44 INS65 INS74 INS42 UPD42 MOV25 INS65 UPD42 INS83 INS74 INS42 INS42 INS66 UPD42 INS66 INS66 UPD66 UPD66 INS43 INS43 MOV62 MOV8 INS42 INS66 UPD42 INS43 MOV43 UPD42 INS44 INS42 INS8 INS42 INS42 INS42 MOV43 INS42 INS60 MOV25 INS83 MOV43 INS59 INS42 INS32 UPD42 MOV42 INS32 INS32 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 UPD42 UPD74 DEL66 DEL42 DEL69 DEL39 DEL69 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL39 DEL69 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL66 DEL65 DEL65 DEL83 DEL83 DEL83 DEL83 DEL42 DEL42 DEL43 DEL62 DEL33 DEL41 DEL8 DEL25 DEL42 DEL34 DEL32 DEL42 DEL43 DEL74 DEL42 DEL44 DEL32 DEL8
HADOOP-15107. Stabilize/tune S3A committers; review correctness & docs.
Contributed by Steve Loughran.

+import org.apache.hadoop.fs.PathExistsException;
+import org.apache.hadoop.fs.RemoteIterator;
+    } catch (FileNotFoundException e) {
+      // this can mean the job was aborted early on, so don't confuse people
+      // with long stack traces that aren't the underlying problem.
+      maybeIgnore(suppressExceptions, "Pending upload directory not found", e);
-   * Delete the working paths of a job. Does not attempt to clean up
-   * the work of the wrapped committer.
+   * Delete the working paths of a job.
-   *   <li>$dest/__temporary</li>
+   *   <li>{@code $dest/__temporary}</li>
+   * Does not attempt to clean up the work of the wrapped committer.
+   * Generate a {@link PathExistsException} because the destination exists.
+   * Lists some of the child entries first, to help diagnose the problem.
+   * @param path path which exists
+   * @param description description (usually task/job ID)
+   * @return an exception to throw
+   */
+  protected PathExistsException failDestinationExists(final Path path,
+      final String description) {
+
+    LOG.error("{}: Failing commit by job {} to write"
+            + " to existing output path {}.",
+        description,
+        getJobContext().getJobID(), path);
+    // List the first 10 descendants, to give some details
+    // on what is wrong but not overload things if there are many files.
+    try {
+      int limit = 10;
+      RemoteIterator<LocatedFileStatus> lf
+          = getDestFS().listFiles(path, true);
+      LOG.info("Partial Directory listing");
+      while (limit > 0 && lf.hasNext()) {
+        limit--;
+        LocatedFileStatus status = lf.next();
+        LOG.info("{}: {}",
+            status.getPath(),
+            status.isDirectory()
+                ? " dir"
+                : ("file size " + status.getLen() + " bytes"));
+      }
+    } catch (IOException e) {
+      LOG.info("Discarding exception raised when listing {}: " + e, path);
+      LOG.debug("stack trace ", e);
+    }
+    return new PathExistsException(path.toString(),
+        description + ": " + InternalCommitterConstants.E_DEST_EXISTS);
+  }
+
+  /**

INS26 INS26 INS40 INS40 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS21 INS54 INS41 INS12 UPD66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS8 INS12 INS14 INS44 INS8 UPD66 MOV66 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS60 INS60 INS21 INS61 INS44 INS8 INS43 INS32 INS27 INS43 INS42 INS21 INS45 INS45 INS32 INS42 INS39 INS59 INS74 INS59 INS32 INS27 INS8 INS43 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS45 INS40 INS42 INS32 INS42 INS42 INS34 INS43 INS43 INS42 INS32 INS42 INS42 INS45 INS27 INS32 INS21 INS60 INS21 INS42 INS32 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS34 INS42 INS42 INS37 INS43 INS59 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS32 INS16 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS45 INS36 INS42 INS42 INS27 INS45 INS32 INS45 INS42 INS42 DEL66
HDDS-1395. Key write fails with BlockOutputStream has been closed exception (#749). Contributed by Shashikant Banerjee

+import org.apache.hadoop.hdds.scm.client.HddsClientUtils;
-import org.apache.hadoop.hdds.scm.storage.BufferPool;
-import org.apache.hadoop.ozone.OzoneConfigKeys;
-import org.apache.hadoop.ozone.client.OzoneClientUtils;
-import org.apache.hadoop.security.UserGroupInformation;
-import java.util.ArrayList;
-import java.util.ListIterator;
-  // array list's get(index) is O(1)
-  private final ArrayList<BlockOutputStreamEntry> streamEntries;
-  private int currentStreamIndex;
-  private final OzoneManagerProtocol omClient;
-  private final OmKeyArgs keyArgs;
-  private final long openID;
-  private final XceiverClientManager xceiverClientManager;
-  private final int chunkSize;
-  private final String requestID;
-  private final long streamBufferFlushSize;
-  private final long streamBufferMaxSize;
-  private final long watchTimeout;
-  private final long blockSize;
-  private final int bytesPerChecksum;
-  private final ChecksumType checksumType;
-  private final BufferPool bufferPool;
-  private OmMultipartCommitUploadPartInfo commitUploadPartInfo;
-  private ExcludeList excludeList;
+  private final BlockOutputStreamEntryPool blockOutputStreamEntryPool;
+
-  @SuppressWarnings("parameternumber")
-    streamEntries = new ArrayList<>();
-    omClient = null;
-    keyArgs = null;
-    openID = -1;
-    xceiverClientManager = null;
-    chunkSize = 0;
-    requestID = null;
-    streamBufferFlushSize = 0;
-    streamBufferMaxSize = 0;
-    bufferPool = new BufferPool(chunkSize, 1);
-    watchTimeout = 0;
-    blockSize = 0;
-    this.checksumType = ChecksumType.valueOf(
-        OzoneConfigKeys.OZONE_CLIENT_CHECKSUM_TYPE_DEFAULT);
-    this.bytesPerChecksum = OzoneConfigKeys
-        .OZONE_CLIENT_BYTES_PER_CHECKSUM_DEFAULT_BYTES; // Default is 1MB
-    this.retryPolicyMap = OzoneClientUtils.getExceptionList()
+    this.retryPolicyMap = HddsClientUtils.getExceptionList()
+    blockOutputStreamEntryPool = new BlockOutputStreamEntryPool();
-    return streamEntries;
-  }
-  @VisibleForTesting
-  public XceiverClientManager getXceiverClientManager() {
-    return xceiverClientManager;
+    return blockOutputStreamEntryPool.getStreamEntries();
-  public List<OmKeyLocationInfo> getLocationInfoList() throws IOException {
-    List<OmKeyLocationInfo> locationInfoList = new ArrayList<>();
-    for (BlockOutputStreamEntry streamEntry : streamEntries) {
-      OmKeyLocationInfo info =
-          new OmKeyLocationInfo.Builder().setBlockID(streamEntry.getBlockID())
-              .setLength(streamEntry.getCurrentPosition()).setOffset(0)
-              .setToken(streamEntry.getToken())
-              .setPipeline(streamEntry.getPipeline())
-              .build();
-      LOG.debug("block written " + streamEntry.getBlockID() + ", length "
-          + streamEntry.getCurrentPosition() + " bcsID "
-          + streamEntry.getBlockID().getBlockCommitSequenceId());
-      locationInfoList.add(info);
-    }
-    return locationInfoList;
+  @VisibleForTesting
+  public XceiverClientManager getXceiverClientManager() {
+    return blockOutputStreamEntryPool.getXceiverClientManager();
+  }
+
+  @VisibleForTesting
+  public List<OmKeyLocationInfo> getLocationInfoList() {
+    return blockOutputStreamEntryPool.getLocationInfoList();
-    this.streamEntries = new ArrayList<>();
-    this.currentStreamIndex = 0;
-    this.omClient = omClient;
+    blockOutputStreamEntryPool =
+        new BlockOutputStreamEntryPool(omClient, chunkSize, requestId, factor,
+            type, bufferFlushSize, bufferMaxSize, size, watchTimeout,
+            checksumType, bytesPerChecksum, uploadID, partNumber, isMultipart,
+            info, xceiverClientManager, handler.getId());
-    this.keyArgs = new OmKeyArgs.Builder().setVolumeName(info.getVolumeName())
-        .setBucketName(info.getBucketName()).setKeyName(info.getKeyName())
-        .setType(type).setFactor(factor).setDataSize(info.getDataSize())
-        .setIsMultipartKey(isMultipart).setMultipartUploadID(
-            uploadID).setMultipartUploadPartNumber(partNumber)
-        .build();
-    this.openID = handler.getId();
-    this.xceiverClientManager = xceiverClientManager;
-    this.chunkSize = chunkSize;
-    this.requestID = requestId;
-    this.streamBufferFlushSize = bufferFlushSize;
-    this.streamBufferMaxSize = bufferMaxSize;
-    this.blockSize = size;
-    this.watchTimeout = watchTimeout;
-    this.bytesPerChecksum = bytesPerChecksum;
-    this.checksumType = checksumType;
-
-    Preconditions.checkState(chunkSize > 0);
-    Preconditions.checkState(streamBufferFlushSize > 0);
-    Preconditions.checkState(streamBufferMaxSize > 0);
-    Preconditions.checkState(blockSize > 0);
-    Preconditions.checkState(streamBufferFlushSize % chunkSize == 0);
-    Preconditions.checkState(streamBufferMaxSize % streamBufferFlushSize == 0);
-    Preconditions.checkState(blockSize % streamBufferMaxSize == 0);
-    this.bufferPool =
-        new BufferPool(chunkSize, (int)streamBufferMaxSize / chunkSize);
-    this.excludeList = new ExcludeList();
-    this.retryPolicyMap = OzoneClientUtils.getRetryPolicyByException(
+    this.retryPolicyMap = HddsClientUtils.getRetryPolicyByException(
-    // server may return any number of blocks, (0 to any)
-    // only the blocks allocated in this open session (block createVersion
-    // equals to open session version)
-    for (OmKeyLocationInfo subKeyInfo : version.getLocationList()) {
-      if (subKeyInfo.getCreateVersion() == openVersion) {
-        addKeyLocationInfo(subKeyInfo);
-      }
-    }
-  }
-
-  private void addKeyLocationInfo(OmKeyLocationInfo subKeyInfo)
-      throws IOException {
-    Preconditions.checkNotNull(subKeyInfo.getPipeline());
-    UserGroupInformation.getCurrentUser().addToken(subKeyInfo.getToken());
-    BlockOutputStreamEntry.Builder builder =
-        new BlockOutputStreamEntry.Builder()
-            .setBlockID(subKeyInfo.getBlockID())
-            .setKey(keyArgs.getKeyName())
-            .setXceiverClientManager(xceiverClientManager)
-            .setPipeline(subKeyInfo.getPipeline())
-            .setRequestId(requestID)
-            .setChunkSize(chunkSize)
-            .setLength(subKeyInfo.getLength())
-            .setStreamBufferFlushSize(streamBufferFlushSize)
-            .setStreamBufferMaxSize(streamBufferMaxSize)
-            .setWatchTimeout(watchTimeout)
-            .setbufferPool(bufferPool)
-            .setChecksumType(checksumType)
-            .setBytesPerChecksum(bytesPerChecksum)
-            .setToken(subKeyInfo.getToken());
-    streamEntries.add(builder.build());
+    blockOutputStreamEntryPool.addPreallocateBlocks(version, openVersion);
-  private long computeBufferData() {
-    return bufferPool.computeBufferData();
-  }
-
-    int succeededAllocates = 0;
-        if (streamEntries.size() <= currentStreamIndex) {
-          Preconditions.checkNotNull(omClient);
-          // allocate a new block, if a exception happens, log an error and
-          // throw exception to the caller directly, and the write fails.
-          try {
-            allocateNewBlock(currentStreamIndex);
-            succeededAllocates += 1;
-          } catch (IOException ioe) {
-            LOG.error("Try to allocate more blocks for write failed, already "
-                + "allocated " + succeededAllocates
-                + " blocks for this write.");
-            throw ioe;
-          }
-        }
-        // in theory, this condition should never violate due the check above
-        // still do a sanity check.
-        Preconditions.checkArgument(currentStreamIndex < streamEntries.size());
-        BlockOutputStreamEntry current = streamEntries.get(currentStreamIndex);
-
+        BlockOutputStreamEntry current =
+            blockOutputStreamEntryPool.allocateBlockIfNeeded();
-          Preconditions.checkState(!retry || len <= streamBufferMaxSize);
+          Preconditions.checkState(!retry || len <= blockOutputStreamEntryPool
+              .getStreamBufferMaxSize());
-          handleException(current, currentStreamIndex, ioe);
+          handleException(current, ioe);
-   * Discards the subsequent pre allocated blocks and removes the streamEntries
-   * from the streamEntries list for the container which is closed.
-   * @param containerID id of the closed container
-   * @param pipelineId id of the associated pipeline
-   * @param streamIndex index of the stream
-   */
-  private void discardPreallocatedBlocks(long containerID,
-      PipelineID pipelineId, int streamIndex) {
-    // streamIndex < streamEntries.size() signifies that, there are still
-    // pre allocated blocks available.
-
-    // This will be called only to discard the next subsequent unused blocks
-    // in the streamEntryList.
-    if (streamIndex < streamEntries.size()) {
-      ListIterator<BlockOutputStreamEntry> streamEntryIterator =
-          streamEntries.listIterator(streamIndex);
-      while (streamEntryIterator.hasNext()) {
-        BlockOutputStreamEntry streamEntry = streamEntryIterator.next();
-        Preconditions.checkArgument(streamEntry.getCurrentPosition() == 0);
-        if (((pipelineId != null && streamEntry.getPipeline().getId()
-            .equals(pipelineId)) || (containerID != -1
-            && streamEntry.getBlockID().getContainerID() == containerID))) {
-          streamEntryIterator.remove();
-        }
-      }
-    }
-  }
-
-  /**
-   * It might be possible that the blocks pre allocated might never get written
-   * while the stream gets closed normally. In such cases, it would be a good
-   * idea to trim down the locationInfoList by removing the unused blocks if any
-   * so as only the used block info gets updated on OzoneManager during close.
-   */
-  private void removeEmptyBlocks() {
-    if (currentStreamIndex < streamEntries.size()) {
-      ListIterator<BlockOutputStreamEntry> streamEntryIterator =
-          streamEntries.listIterator(currentStreamIndex);
-      while (streamEntryIterator.hasNext()) {
-        if (streamEntryIterator.next().getCurrentPosition() == 0) {
-          streamEntryIterator.remove();
-        }
-      }
-    }
-  }
-
-  private void cleanup() {
-    if (excludeList != null) {
-      excludeList.clear();
-      excludeList = null;
-    }
-    if (bufferPool != null) {
-      bufferPool.clearBufferPool();
-    }
-
-    if (streamEntries != null) {
-      streamEntries.clear();
-    }
-  }
-  /**
-   *    datanode.
+   * datanode.
-   * @param streamIndex Index of the entry
-   * @param exception actual exception that occurred
+   * @param exception   actual exception that occurred
-      int streamIndex, IOException exception) throws IOException {
-    Throwable t = checkForException(exception);
+      IOException exception) throws IOException {
+    Throwable t = HddsClientUtils.checkForException(exception);
-    long bufferedDataLen = computeBufferData();
-    LOG.warn("Encountered exception {}. The last committed block length is {}, "
+    long bufferedDataLen = blockOutputStreamEntryPool.computeBufferData();
+    LOG.debug(
+        "Encountered exception {}. The last committed block length is {}, "
-    Preconditions.checkArgument(bufferedDataLen <= streamBufferMaxSize);
-    Preconditions.checkArgument(offset - getKeyLength() == bufferedDataLen);
+    Preconditions.checkArgument(
+        bufferedDataLen <= blockOutputStreamEntryPool.getStreamBufferMaxSize());
+    Preconditions.checkArgument(
+        offset - blockOutputStreamEntryPool.getKeyLength() == bufferedDataLen);
+    ExcludeList excludeList = blockOutputStreamEntryPool.getExcludeList();
-    // discard all sunsequent blocks the containers and pipelines which
+    // discard all subsequent blocks the containers and pipelines which
-      discardPreallocatedBlocks(streamEntry.getBlockID().getContainerID(), null,
-          streamIndex + 1);
+      blockOutputStreamEntryPool
+          .discardPreallocatedBlocks(streamEntry.getBlockID().getContainerID(),
+              null);
-      // pipeline, just discard all the preallocated blocks on this pipeline.
+      // pipeline, just discard all the pre allocated blocks on this pipeline.
-      discardPreallocatedBlocks(-1, pipelineId, streamIndex + 1);
+      blockOutputStreamEntryPool
+          .discardPreallocatedBlocks(-1, pipelineId);
-      currentStreamIndex += 1;
-    if (totalSuccessfulFlushedData == 0) {
-      streamEntries.remove(streamIndex);
-      currentStreamIndex -= 1;
-    }
-    cleanup();
+    blockOutputStreamEntryPool.cleanup();
-    RetryPolicy retryPolicy =
-        retryPolicyMap.get(checkForException(exception).getClass());
+    RetryPolicy retryPolicy = retryPolicyMap
+        .get(HddsClientUtils.checkForException(exception).getClass());
-    LOG.trace("Retrying Write request. Already tried "
-        + retryCount + " time(s); retry policy is " + retryPolicy);
+    LOG.trace("Retrying Write request. Already tried " + retryCount
+        + " time(s); retry policy is " + retryPolicy);
+
-  public Throwable checkForException(IOException ioe) throws IOException {
-    Throwable t = ioe.getCause();
-    while (t != null) {
-      for (Class<? extends Exception> cls : OzoneClientUtils
-          .getExceptionList()) {
-        if (cls.isInstance(t)) {
-          return t;
-        }
-      }
-      t = t.getCause();
-    }
-    throw ioe;
-  }
-
-  private long getKeyLength() {
-    return streamEntries.stream().mapToLong(e -> e.getCurrentPosition())
-        .sum();
-  }
-
-  /**
-   * Contact OM to get a new block. Set the new block with the index (e.g.
-   * first block has index = 0, second has index = 1 etc.)
-   *
-   * The returned block is made to new BlockOutputStreamEntry to write.
-   *
-   * @param index the index of the block.
-   * @throws IOException
-   */
-  private void allocateNewBlock(int index) throws IOException {
-    OmKeyLocationInfo subKeyInfo =
-        omClient.allocateBlock(keyArgs, openID, excludeList);
-    addKeyLocationInfo(subKeyInfo);
-  }
-
+   *
-   *              outputStream.
+   *           outputStream.
-    if (streamEntries.size() == 0) {
+    if (blockOutputStreamEntryPool.isEmpty()) {
-        int size = streamEntries.size();
-        int streamIndex =
-            currentStreamIndex >= size ? size - 1 : currentStreamIndex;
-        BlockOutputStreamEntry entry = streamEntries.get(streamIndex);
+        BlockOutputStreamEntry entry =
+            blockOutputStreamEntryPool.getCurrentStreamEntry();
-              excludeList.addDatanodes(failedServers);
+              blockOutputStreamEntryPool.getExcludeList()
+                  .addDatanodes(failedServers);
-                currentStreamIndex++;
-            handleException(entry, streamIndex, ioe);
+            handleException(entry, ioe);
-      if (keyArgs != null) {
-        // in test, this could be null
-        removeEmptyBlocks();
-        long length = getKeyLength();
-        Preconditions.checkArgument(offset == length);
-        keyArgs.setDataSize(length);
-        keyArgs.setLocationInfoList(getLocationInfoList());
-        // When the key is multipart upload part file upload, we should not
-        // commit the key, as this is not an actual key, this is a just a
-        // partial key of a large file.
-        if (keyArgs.getIsMultipartKey()) {
-          commitUploadPartInfo = omClient.commitMultipartUploadPart(keyArgs,
-              openID);
-        } else {
-          omClient.commitKey(keyArgs, openID);
-        }
-      } else {
-        LOG.warn("Closing KeyOutputStream, but key args is null");
-      }
+      blockOutputStreamEntryPool.commitKey(offset);
-      cleanup();
+      blockOutputStreamEntryPool.cleanup();
-    return commitUploadPartInfo;
+    return blockOutputStreamEntryPool.getCommitUploadPartInfo();
-    return excludeList;
+    return blockOutputStreamEntryPool.getExcludeList();
-
-    public Builder setOmClient(
-        OzoneManagerProtocol client) {
+    public Builder setOmClient(OzoneManagerProtocol client) {
-    public Builder setChecksumType(ChecksumType cType){
+    public Builder setChecksumType(ChecksumType cType) {
-    public Builder setBytesPerChecksum(int bytes){
+    public Builder setBytesPerChecksum(int bytes) {
-    public KeyOutputStream build() throws IOException {
-      return new KeyOutputStream(openHandler, xceiverManager,
-          omClient, chunkSize, requestID, factor, type, streamBufferFlushSize,
+    public KeyOutputStream build() {
+      return new KeyOutputStream(openHandler, xceiverManager, omClient,
+          chunkSize, requestID, factor, type, streamBufferFlushSize,
-          ": " + FSExceptionMessages.STREAM_IS_CLOSED + " Key: " + keyArgs
-              .getKeyName());
+          ": " + FSExceptionMessages.STREAM_IS_CLOSED + " Key: "
+              + blockOutputStreamEntryPool.getKeyName());

MOV26 MOV23 UPD40 INS31 INS43 MOV21 INS78 MOV83 MOV43 MOV42 MOV8 MOV78 INS8 MOV25 UPD42 MOV42 UPD42 INS42 INS41 INS21 INS21 INS60 INS32 INS32 INS32 INS7 INS32 UPD66 MOV43 INS59 INS42 MOV8 INS32 INS8 INS8 INS32 INS32 UPD42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS14 INS42 INS42 MOV42 INS42 UPD42 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 MOV21 MOV21 MOV21 INS42 INS42 INS42 INS42 UPD43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 UPD42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 INS60 INS42 INS42 INS42 UPD42 UPD42 MOV38 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 MOV59 INS42 INS42 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 MOV44 INS32 INS42 INS42 INS32 INS42 UPD42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL43 DEL74 DEL42 DEL45 DEL79 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL34 DEL38 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL40 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL42 DEL34 DEL42 DEL42 DEL42 DEL43 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL40 DEL43 DEL14 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL32 DEL42 DEL34 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL42 DEL41 DEL8 DEL52 DEL42 DEL22 DEL43 DEL74 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL43 DEL14 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL27 DEL34 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL27 DEL34 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL27 DEL34 DEL27 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL39 DEL42 DEL11 DEL42 DEL27 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL40 DEL43 DEL42 DEL40 DEL43 DEL14 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL34 DEL7 DEL21 DEL8 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL60 DEL42 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL42 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL27 DEL27 DEL36 DEL27 DEL36 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL66 DEL65 DEL39 DEL42 DEL44 DEL42 DEL42 DEL34 DEL38 DEL42 DEL34 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL34 DEL27 DEL42 DEL34 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL41 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL61 DEL42 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL59 DEL42 DEL42 DEL32 DEL86 DEL32 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL32 DEL34 DEL27 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL27 DEL42 DEL34 DEL27 DEL42 DEL16 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL37 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL33 DEL27 DEL42 DEL32 DEL21 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL8 DEL25 DEL8 DEL8 DEL25 DEL8 DEL45 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL43
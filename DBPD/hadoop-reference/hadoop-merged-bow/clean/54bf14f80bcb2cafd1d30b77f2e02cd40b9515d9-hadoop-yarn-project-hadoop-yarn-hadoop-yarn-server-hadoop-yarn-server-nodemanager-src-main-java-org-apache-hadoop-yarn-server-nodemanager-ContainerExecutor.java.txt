YARN-5303. Clean up ContainerExecutor JavaDoc. Contributed by Daniel Templeton.

+/**
+ * This class is abstraction of the mechanism used to launch a container on the
+ * underlying OS.  All executor implementations must extend ContainerExecutor.
+ */
-  final public static FsPermission TASK_LAUNCH_SCRIPT_PERMISSION =
-    FsPermission.createImmutable((short) 0700);
+  /**
+   * The permissions to use when creating the launch script.
+   */
+  public static final FsPermission TASK_LAUNCH_SCRIPT_PERMISSION =
+      FsPermission.createImmutable((short)0700);
+
+  /**
+   * The relative path to which debug information will be written.
+   *
+   * @see ContainerLaunch.ShellScriptBuilder#listDebugInformation
+   */
-
-  private ConcurrentMap<ContainerId, Path> pidFiles =
-      new ConcurrentHashMap<ContainerId, Path>();
-
-  private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
+  private final ConcurrentMap<ContainerId, Path> pidFiles =
+      new ConcurrentHashMap<>();
+  private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
-   * Run the executor initialization steps. 
-   * Verify that the necessary configs, permissions are in place.
-   * @throws IOException
+   * Run the executor initialization steps.
+   * Verify that the necessary configs and permissions are in place.
+   *
+   * @throws IOException if initialization fails
-   * On Windows the ContainerLaunch creates a temporary special jar manifest of 
-   * other jars to workaround the CLASSPATH length. In a  secure cluster this 
-   * jar must be localized so that the container has access to it. 
-   * This function localizes on-demand the jar.
-   * 
-   * @param classPathJar
-   * @param owner
-   * @throws IOException
+   * This function localizes the JAR file on-demand.
+   * On Windows the ContainerLaunch creates a temporary special JAR manifest of
+   * other JARs to workaround the CLASSPATH length. In a secure cluster this
+   * JAR must be localized so that the container has access to it.
+   * The default implementation returns the classpath passed to it, which
+   * is expected to have been created in the node manager's <i>fprivate</i>
+   * folder, which will not work with secure Windows clusters.
+   *
+   * @param jarPath the path to the JAR to localize
+   * @param target the directory where the JAR file should be localized
+   * @param owner the name of the user who should own the localized file
+   * @return the path to the localized JAR file
+   * @throws IOException if localization fails
-  public Path localizeClasspathJar(Path classPathJar, Path pwd, String owner) 
+  public Path localizeClasspathJar(Path jarPath, Path target, String owner)
-    // Non-secure executor simply use the classpath created 
-    // in the NM fprivate folder
-    return classPathJar;
+    return jarPath;
-  
-  
+
+
+   *
-   * @throws IOException For most application init failures
-   * @throws InterruptedException If application init thread is halted by NM
+   * @throws IOException for most application init failures
+   * @throws InterruptedException if application init thread is halted by NM
-   * @throws IOException
+   * @throws IOException if the container launch fails
+   *
-   * @throws IOException
+   * @throws IOException if signaling the container fails
+   *
-   * @throws IOException
-   * @throws InterruptedException
+   * @throws IOException if delete fails
+   * @throws InterruptedException if interrupted while waiting for the deletion
+   * operation to complete
-   * @throws IOException
+   * @throws IOException if there is a failure while checking the container
+   * status
+   *
-   * @throws IOException
-   * @throws InterruptedException 
+   * @throws IOException if there is a failure while reacquiring the container
+   * @throws InterruptedException if interrupted while waiting to reacquire
+   * the container
-
-
+
+
-    String pid = null;
-    pid = ProcessIdFileReader.getProcessId(pidPath);
+    String pid = ProcessIdFileReader.getProcessId(pidPath);
+
+
-    while(isContainerAlive(livenessContext)) {
+
+    while (isContainerAlive(livenessContext)) {
-    String exitCodeFile = ContainerLaunch.getExitCodeFile(pidPath.toString());
-    File file = new File(exitCodeFile);
+    String exitCodeFile = ContainerLaunch.getExitCodeFile(pidPath.toString());
+    File file = new File(exitCodeFile);
+
+
-      
+
-      
+
+
-   * This method writes out the launch environment of a container. This can be
-   * overridden by extending ContainerExecutors to provide different behaviors
+   * This method writes out the launch environment of a container to the
+   * default container launch script. For the default container script path see
+   * {@link ContainerLaunch#CONTAINER_SCRIPT}.
+   *
-   * @param environment The environment variables and their values
-   * @param resources The resources which have been localized for this container
-   * Symlinks will be created to these localized resources
-   * @param command The command that will be run.
-   * @param logDir The log dir to copy debugging information to
+   * @param environment the environment variables and their values
+   * @param resources the resources which have been localized for this
+   * container. Symlinks will be created to these localized resources
+   * @param command the command that will be run.
+   * @param logDir the log dir to copy debugging information to
+  /**
+   * This method writes out the launch environment of a container to a specified
+   * path.
+   *
+   * @param out the output stream to which the environment is written (usually
+   * a script file which will be executed by the Launcher)
+   * @param environment the environment variables and their values
+   * @param resources the resources which have been localized for this
+   * container. Symlinks will be created to these localized resources
+   * @param command the command that will be run.
+   * @param logDir the log dir to copy debugging information to
+   * @param outFilename the path to which to write the launch environment
+   * @throws IOException if any errors happened writing to the OutputStream,
+   * while creating symlinks
+   */
-    Set<String> whitelist = new HashSet<String>();
+    Set<String> whitelist = new HashSet<>();
+
+
-          sb.env(env.getKey().toString(), env.getValue().toString());
+          sb.env(env.getKey(), env.getValue());
-          sb.whitelistedEnv(env.getKey().toString(), env.getValue().toString());
+          sb.whitelistedEnv(env.getKey(), env.getValue());
+
-      for (Map.Entry<Path,List<String>> entry : resources.entrySet()) {
-        for (String linkName : entry.getValue()) {
+      for (Path path: resources.keySet()) {
+        for (String linkName: resources.get(path)) {
-            File directory = new File(entry.getKey().toString());
+            File directory = new File(path.toString());
-            sb.symlink(entry.getKey(), new Path(linkName));
+            sb.symlink(path, new Path(linkName));
-    if (getConf() != null && getConf().getBoolean(
-        YarnConfiguration.NM_LOG_CONTAINER_DEBUG_INFO,
+    if (getConf() != null &&
+        getConf().getBoolean(YarnConfiguration.NM_LOG_CONTAINER_DEBUG_INFO,
-      sb.copyDebugInformation(new Path(outFilename), new Path(logDir, outFilename));
+      sb.copyDebugInformation(new Path(outFilename),
+          new Path(logDir, outFilename));
+
+  /**
+   * The container exit code.
+   */
+
+    /**
+     * Get the exit code as an int.
+     * @return the exit code as an int
+     */
-    NULL(0, "NULL"), QUIT(3, "SIGQUIT"), 
-    KILL(9, "SIGKILL"), TERM(15, "SIGTERM");
+    NULL(0, "NULL"),
+    QUIT(3, "SIGQUIT"),
+    KILL(9, "SIGKILL"),
+    TERM(15, "SIGTERM");
+
+
+
+    /**
+     * Get the signal number.
+     * @return the signal number
+     */
+
+  /**
+   * Log each line of the output string as INFO level log messages.
+   *
+   * @param output the output string to log
+   */
+
-   * @param containerId
+   *
+   * @param containerId the container ID
+  /**
+   * Return a command line to execute the given command in the OS shell.
+   * On Windows, the {code}groupId{code} parameter can be used to launch
+   * and associate the given GID with a process group. On
+   * non-Windows hosts, the {code}groupId{code} parameter is ignored.
+   *
+   * @param command the command to execute
+   * @param groupId the job owner's GID
+   * @param userName the job owner's username
+   * @param pidFile the path to the container's PID file
+   * @param conf the configuration
+   * @return the command line to execute
+   */
-  
-  /** 
-   *  Return a command to execute the given command in OS shell.
-   *  On Windows, the passed in groupId can be used to launch
-   *  and associate the given groupId in a process group. On
-   *  non-Windows, groupId is ignored. 
+
+  /**
+   * Return a command line to execute the given command in the OS shell.
+   * On Windows, the {code}groupId{code} parameter can be used to launch
+   * and associate the given GID with a process group. On
+   * non-Windows hosts, the {code}groupId{code} parameter is ignored.
+   *
+   * @param command the command to execute
+   * @param groupId the job owner's GID for Windows. On other operating systems
+   * it is ignored.
+   * @param userName the job owner's username for Windows. On other operating
+   * systems it is ignored.
+   * @param pidFile the path to the container's PID file on Windows. On other
+   * operating systems it is ignored.
+   * @param conf the configuration
+   * @param resource on Windows this parameter controls memory and CPU limits.
+   * If null, no limits are set. On other operating systems it is ignored.
+   * @return the command line to execute
-    boolean containerSchedPriorityIsSet = false;
-    int containerSchedPriorityAdjustment = 
-        YarnConfiguration.DEFAULT_NM_CONTAINER_EXECUTOR_SCHED_PRIORITY;
-
-    if (conf.get(YarnConfiguration.NM_CONTAINER_EXECUTOR_SCHED_PRIORITY) != 
-        null) {
-      containerSchedPriorityIsSet = true;
-      containerSchedPriorityAdjustment = conf 
-          .getInt(YarnConfiguration.NM_CONTAINER_EXECUTOR_SCHED_PRIORITY, 
-          YarnConfiguration.DEFAULT_NM_CONTAINER_EXECUTOR_SCHED_PRIORITY);
-    }
-  
-      int cpuRate = -1;
-      int memory = -1;
-      if (resource != null) {
-        if (conf
-            .getBoolean(
-                YarnConfiguration.NM_WINDOWS_CONTAINER_MEMORY_LIMIT_ENABLED,
-                YarnConfiguration.DEFAULT_NM_WINDOWS_CONTAINER_MEMORY_LIMIT_ENABLED)) {
-          memory = (int) resource.getMemorySize();
-        }
-
-        if (conf.getBoolean(
-            YarnConfiguration.NM_WINDOWS_CONTAINER_CPU_LIMIT_ENABLED,
-            YarnConfiguration.DEFAULT_NM_WINDOWS_CONTAINER_CPU_LIMIT_ENABLED)) {
-          int containerVCores = resource.getVirtualCores();
-          int nodeVCores = NodeManagerHardwareUtils.getVCores(conf);
-          int nodeCpuPercentage =
-              NodeManagerHardwareUtils.getNodeCpuPercentage(conf);
-
-          float containerCpuPercentage =
-              (float) (nodeCpuPercentage * containerVCores) / nodeVCores;
-
-          // CPU should be set to a percentage * 100, e.g. 20% cpu rate limit
-          // should be set as 20 * 100.
-          cpuRate = Math.min(10000, (int) (containerCpuPercentage * 100));
-        }
-      }
-      return new String[] { Shell.getWinUtilsPath(), "task", "create", "-m",
-          String.valueOf(memory), "-c", String.valueOf(cpuRate), groupId,
-          "cmd /c " + command };
+      return getRunCommandForWindows(command, groupId, userName, pidFile,
+          conf, resource);
-      List<String> retCommand = new ArrayList<String>();
-      if (containerSchedPriorityIsSet) {
-        retCommand.addAll(Arrays.asList("nice", "-n",
-            Integer.toString(containerSchedPriorityAdjustment)));
-      }
-      retCommand.addAll(Arrays.asList("bash", command));
-      return retCommand.toArray(new String[retCommand.size()]);
+      return getRunCommandForOther(command, conf);
-   * Is the container still active?
-   * @param containerId
-   * @return true if the container is active else false.
+   * Return a command line to execute the given command in the OS shell.
+   * The {code}groupId{code} parameter can be used to launch
+   * and associate the given GID with a process group.
+   *
+   * @param command the command to execute
+   * @param groupId the job owner's GID
+   * @param userName the job owner's username
+   * @param pidFile the path to the container's PID file
+   * @param conf the configuration
+   * @param resource this parameter controls memory and CPU limits.
+   * If null, no limits are set.
+   * @return the command line to execute
+   */
+  protected String[] getRunCommandForWindows(String command, String groupId,
+      String userName, Path pidFile, Configuration conf, Resource resource) {
+    int cpuRate = -1;
+    int memory = -1;
+
+    if (resource != null) {
+      if (conf.getBoolean(
+          YarnConfiguration.NM_WINDOWS_CONTAINER_MEMORY_LIMIT_ENABLED,
+          YarnConfiguration.DEFAULT_NM_WINDOWS_CONTAINER_MEMORY_LIMIT_ENABLED)) {
+        memory = (int)resource.getMemorySize();
+      }
+
+      if (conf.getBoolean(
+          YarnConfiguration.NM_WINDOWS_CONTAINER_CPU_LIMIT_ENABLED,
+          YarnConfiguration.DEFAULT_NM_WINDOWS_CONTAINER_CPU_LIMIT_ENABLED)) {
+        int containerVCores = resource.getVirtualCores();
+        int nodeVCores = NodeManagerHardwareUtils.getVCores(conf);
+        int nodeCpuPercentage =
+            NodeManagerHardwareUtils.getNodeCpuPercentage(conf);
+
+        float containerCpuPercentage =
+            (float)(nodeCpuPercentage * containerVCores) / nodeVCores;
+
+        // CPU should be set to a percentage * 100, e.g. 20% cpu rate limit
+        // should be set as 20 * 100.
+        cpuRate = Math.min(10000, (int)(containerCpuPercentage * 100));
+      }
+    }
+
+    return new String[] {
+        Shell.getWinUtilsPath(),
+        "task",
+        "create",
+        "-m",
+        String.valueOf(memory),
+        "-c",
+        String.valueOf(cpuRate),
+        groupId,
+        "cmd /c " + command
+    };
+  }
+
+  /**
+   * Return a command line to execute the given command in the OS shell.
+   *
+   * @param command the command to execute
+   * @param conf the configuration
+   * @return the command line to execute
+   */
+  protected String[] getRunCommandForOther(String command,
+      Configuration conf) {
+    List<String> retCommand = new ArrayList<>();
+    boolean containerSchedPriorityIsSet = false;
+    int containerSchedPriorityAdjustment =
+        YarnConfiguration.DEFAULT_NM_CONTAINER_EXECUTOR_SCHED_PRIORITY;
+
+    if (conf.get(YarnConfiguration.NM_CONTAINER_EXECUTOR_SCHED_PRIORITY) !=
+        null) {
+      containerSchedPriorityIsSet = true;
+      containerSchedPriorityAdjustment = conf
+          .getInt(YarnConfiguration.NM_CONTAINER_EXECUTOR_SCHED_PRIORITY,
+          YarnConfiguration.DEFAULT_NM_CONTAINER_EXECUTOR_SCHED_PRIORITY);
+    }
+
+    if (containerSchedPriorityIsSet) {
+      retCommand.addAll(Arrays.asList("nice", "-n",
+          Integer.toString(containerSchedPriorityAdjustment)));
+    }
+
+    retCommand.addAll(Arrays.asList("bash", command));
+
+    return retCommand.toArray(new String[retCommand.size()]);
+  }
+
+  /**
+   * Return whether the container is still active.
+   *
+   * @param containerId the target container's ID
+   * @return true if the container is active
+
-   * Mark the container as active
-   * 
-   * @param containerId
-   *          the ContainerId
-   * @param pidFilePath
-   *          Path where the executor should write the pid of the launched
-   *          process
+   * Mark the container as active.
+   *
+   * @param containerId the container ID
+   * @param pidFilePath the path where the executor should write the PID
+   * of the launched process
-   * Mark the container as inactive.
-   * Done iff the container is still active. Else treat it as
-   * a no-op
+   * Mark the container as inactive. For inactive containers this
+   * method has no effect.
+   *
+   * @param containerId the container ID
-   * Get the process-identifier for the container
-   * 
-   * @param containerID
-   * @return the processid of the container if it has already launched,
-   *         otherwise return null
+   * Get the process-identifier for the container.
+   *
+   * @param containerID the container ID
+   * @return the process ID of the container if it has already launched,
+   * or null otherwise
-    if (pidFile == null) {
-      // This container isn't even launched yet.
-      return pid;
+
+    // If PID is null, this container hasn't launched yet.
+    if (pidFile != null) {
+      try {
+        pid = ProcessIdFileReader.getProcessId(pidFile);
+      } catch (IOException e) {
+        LOG.error("Got exception reading pid from pid-file " + pidFile, e);
+      }
-    try {
-      pid = ProcessIdFileReader.getProcessId(pidFile);
-    } catch (IOException e) {
-      LOG.error("Got exception reading pid from pid-file " + pidFile, e);
-    }
+
+  /**
+   * This class will signal a target container after a specified delay.
+   * @see #signalContainer
+   */
-    private Container container;
+    private final Container container;
+    /**
+     * Basic constructor.
+     *
+     * @param container the container to signal
+     * @param user the user as whow to send the signal
+     * @param pid the PID of the container process
+     * @param delayMS the period of time to wait in millis before signaling
+     * the container
+     * @param signal the signal to send
+     * @param containerExecutor the executor to use to send the signal
+     */
-        long delay, Signal signal, ContainerExecutor containerExecutor) {
+        long delayMS, Signal signal, ContainerExecutor containerExecutor) {
-      this.delay = delay;
+      this.delay = delayMS;
+
-        return;
+        interrupt();
-        container.handle(new ContainerDiagnosticsUpdateEvent(container
-          .getContainerId(), message));
+        container.handle(new ContainerDiagnosticsUpdateEvent(
+            container.getContainerId(), message));

INS29 MOV44 INS31 INS31 INS65 INS29 INS83 INS29 INS83 INS83 MOV60 MOV60 INS29 INS29 INS29 INS29 INS29 INS83 INS5 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS8 UPD42 MOV8 INS29 INS83 INS5 INS42 INS44 INS44 MOV8 INS29 INS66 INS66 INS65 INS65 INS65 INS65 INS65 UPD42 UPD42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS29 INS29 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS43 INS42 MOV60 MOV60 MOV25 INS65 INS65 INS65 INS83 INS29 INS66 INS66 INS67 UPD74 UPD66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 UPD42 INS66 INS42 INS66 INS66 INS66 INS66 UPD42 UPD66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD66 INS66 MOV43 UPD66 UPD66 INS65 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS65 INS65 INS65 INS65 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS8 INS8 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 UPD66 MOV66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS66 UPD66 INS66 UPD66 UPD66 UPD27 INS66 INS67 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD42 INS40 INS42 MOV42 MOV32 INS67 INS66 INS66 INS66 INS66 INS41 INS41 MOV54 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 UPD74 INS32 INS32 UPD74 UPD42 MOV8 MOV43 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS32 UPD42 UPD42 INS42 INS42 MOV32 MOV32 INS42 INS42 MOV32 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 MOV43 UPD42 MOV42 MOV43 UPD42 MOV42 DEL83 DEL42 DEL43 DEL42 DEL43 DEL33 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL32 DEL42 DEL32 DEL65 DEL40 DEL25 DEL8 DEL42 DEL43 DEL66 DEL42 DEL41 DEL41
HDFS-2108. Move datanode heartbeat handling from namenode package to blockmanagement package.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1154042 13f79535-47bb-0310-9956-ffa450edef68

+import static org.apache.hadoop.hdfs.server.common.Util.now;
+
+import org.apache.hadoop.hdfs.server.protocol.BalancerBandwidthCommand;
-import org.apache.hadoop.hdfs.server.protocol.BalancerBandwidthCommand;
-  final FSNamesystem namesystem;
+  private final FSNamesystem namesystem;
+  private final BlockManager blockManager;
+
+  private final HeartbeatManager heartbeatManager;
-  DatanodeManager(final FSNamesystem namesystem, final Configuration conf
+  DatanodeManager(final BlockManager blockManager,
+      final FSNamesystem namesystem, final Configuration conf
+    this.blockManager = blockManager;
+
+    this.heartbeatManager = new HeartbeatManager(namesystem, conf);
+
+
+    heartbeatManager.activate(conf);
+    heartbeatManager.close();
-  
+
+  /** @return the heartbeat manager. */
+  HeartbeatManager getHeartbeatManager() {
+    return heartbeatManager;
+  }
+
+  /** @return the datanode statistics. */
+  public DatanodeStatistics getDatanodeStatistics() {
+    return heartbeatManager;
+  }
+
+  /**
+   * Remove a datanode descriptor.
+   * @param nodeInfo datanode descriptor.
+   */
+  private void removeDatanode(DatanodeDescriptor nodeInfo) {
+    assert namesystem.hasWriteLock();
+    heartbeatManager.removeDatanode(nodeInfo);
+    blockManager.removeBlocksAssociatedTo(nodeInfo);
+    networktopology.remove(nodeInfo);
+
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("remove datanode " + nodeInfo.getName());
+    }
+    namesystem.checkSafeMode();
+  }
+
+  /**
+   * Remove a datanode
+   * @throws UnregisteredNodeException 
+   */
+  public void removeDatanode(final DatanodeID node
+      ) throws UnregisteredNodeException {
+    namesystem.writeLock();
+    try {
+      final DatanodeDescriptor descriptor = getDatanode(node);
+      if (descriptor != null) {
+        removeDatanode(descriptor);
+      } else {
+        NameNode.stateChangeLog.warn("BLOCK* removeDatanode: "
+                                     + node.getName() + " does not exist");
+      }
+    } finally {
+      namesystem.writeUnlock();
+    }
+  }
+
-  public void removeDeadDatanode(final DatanodeID nodeID) {
-    synchronized(namesystem.heartbeats) {
+  void removeDeadDatanode(final DatanodeID nodeID) {
-          namesystem.removeDatanode(d);
+          removeDatanode(d);
-    }
-  public boolean isDatanodeDead(DatanodeDescriptor node) {
+  boolean isDatanodeDead(DatanodeDescriptor node) {
-      namesystem.getBlockManager().startDecommission(nodeReg);
+      startDecommission(nodeReg);
-  
+  /**
+   * Change, if appropriate, the admin state of a datanode to 
+   * decommission completed. Return true if decommission is complete.
+   */
+  boolean checkDecommissionState(DatanodeDescriptor node) {
+    // Check to see if all blocks in this decommissioned
+    // node has reached their target replication factor.
+    if (node.isDecommissionInProgress()) {
+      if (!blockManager.isReplicationInProgress(node)) {
+        node.setDecommissioned();
+        LOG.info("Decommission complete for node " + node.getName());
+      }
+    }
+    return node.isDecommissioned();
+  }
+
+  /** Start decommissioning the specified datanode. */
+  private void startDecommission(DatanodeDescriptor node) throws IOException {
+    if (!node.isDecommissionInProgress() && !node.isDecommissioned()) {
+      LOG.info("Start Decommissioning node " + node.getName() + " with " + 
+          node.numBlocks() +  " blocks.");
+      heartbeatManager.startDecommission(node);
+      node.decommissioningStatus.setStartTime(now());
+      
+      // all the blocks that reside on this node have to be replicated.
+      checkDecommissionState(node);
+    }
+  }
+
+  /** Stop decommissioning the specified datanodes. */
+  void stopDecommission(DatanodeDescriptor node) throws IOException {
+    if (node.isDecommissionInProgress() || node.isDecommissioned()) {
+      LOG.info("Stop Decommissioning node " + node.getName());
+      heartbeatManager.stopDecommission(node);
+      blockManager.processOverReplicatedBlocksOnReCommission(node);
+    }
+  }
+
-      namesystem.removeDatanode(nodeN);
+      removeDatanode(nodeN);
-      synchronized(namesystem.heartbeats) {
-        if( !namesystem.heartbeats.contains(nodeS)) {
-          namesystem.heartbeats.add(nodeS);
-          //update its timestamp
-          nodeS.updateHeartbeat(0L, 0L, 0L, 0L, 0, 0);
-          nodeS.isAlive = true;
-        }
-      }
+      heartbeatManager.register(nodeS);
-    synchronized(namesystem.heartbeats) {
-      namesystem.heartbeats.add(nodeDescr);
-      nodeDescr.isAlive = true;
-      // no need to update its timestamp
-      // because its is done when the descriptor is created
-    }
+    // no need to update its timestamp
+    // because its is done when the descriptor is created
+    heartbeatManager.addDatanode(nodeDescr);
-        node.setDisallowed(true);  // case 2.
+        node.setDisallowed(true); // case 2.
-          namesystem.getBlockManager().startDecommission(node);   // case 3.
+          startDecommission(node); // case 3.
-          namesystem.getBlockManager().stopDecommission(node);   // case 4.
+          stopDecommission(node); // case 4.
-    synchronized (namesystem.heartbeats) {
+    synchronized (heartbeatManager) {
-        namesystem.updateStats(nodeinfo, false);
-        nodeinfo.updateHeartbeat(capacity, dfsUsed, remaining, blockPoolUsed,
-            xceiverCount, failedVolumes);
-        namesystem.updateStats(nodeinfo, true);
+        heartbeatManager.updateHeartbeat(nodeinfo, capacity, dfsUsed,
+            remaining, blockPoolUsed, xceiverCount, failedVolumes);

MOV26 INS26 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS44 INS29 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 MOV8 INS29 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS39 INS42 INS44 INS43 INS8 INS42 INS42 INS42 INS42 INS83 INS43 INS42 INS21 INS21 INS21 INS21 INS65 INS42 INS41 INS65 INS42 INS41 INS65 INS65 INS43 INS42 INS6 INS21 INS21 INS21 INS25 INS21 INS65 INS65 INS83 INS43 INS42 INS42 INS21 INS54 INS65 INS43 INS42 INS25 INS41 INS65 INS43 INS42 INS42 INS25 INS65 INS43 INS42 INS42 INS25 MOV21 INS42 INS7 INS7 INS32 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS32 INS32 INS32 INS32 INS8 INS32 INS66 INS42 INS66 INS42 INS32 INS8 INS8 INS66 INS66 INS42 INS32 INS8 INS32 INS66 INS42 INS27 INS8 INS66 INS42 INS27 INS8 INS42 INS22 INS42 INS22 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS60 INS25 INS21 INS42 INS42 INS25 INS42 INS42 INS38 INS38 INS21 INS21 INS21 INS21 INS32 INS32 INS21 INS21 INS21 MOV21 INS42 UPD42 INS52 INS42 INS52 INS42 INS43 INS42 INS42 INS32 INS83 INS43 INS59 INS27 INS8 INS8 INS32 INS38 INS8 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS45 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS27 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS45 INS32 INS45 INS45 INS32 INS42 INS42 INS42 INS42 DEL83 DEL42 DEL40 DEL51 DEL8 DEL83 DEL42 DEL42 DEL32 DEL42 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL34 DEL34 DEL34 DEL34 DEL34 DEL34 DEL32 DEL21 DEL40 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL51 DEL40 DEL40 DEL40 DEL9 DEL7 DEL21 DEL8 DEL51 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21
HDFS-4234. Use generic code for choosing datanode in Balancer.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1417130 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.net.Node;
-    protected boolean isMoveQuotaFull() {
+    protected boolean hasSpaceForScheduling() {
-  /* Decide all <source, target> pairs and
+  /** A matcher interface for matching nodes. */
+  private interface Matcher {
+    /** Given the cluster topology, does the left node match the right node? */
+    boolean match(NetworkTopology cluster, Node left,  Node right);
+  }
+
+  /** Match datanodes in the same node group. */
+  static final Matcher SAME_NODE_GROUP = new Matcher() {
+    @Override
+    public boolean match(NetworkTopology cluster, Node left, Node right) {
+      return cluster.isOnSameNodeGroup(left, right);
+    }
+  };
+
+  /** Match datanodes in the same rack. */
+  static final Matcher SAME_RACK = new Matcher() {
+    @Override
+    public boolean match(NetworkTopology cluster, Node left, Node right) {
+      return cluster.isOnSameRack(left, right);
+    }
+  };
+
+  /** Match any datanode with any other datanode. */
+  static final Matcher ANY_OTHER = new Matcher() {
+    @Override
+    public boolean match(NetworkTopology cluster, Node left, Node right) {
+      return left != right;
+    }
+  };
+
+  /**
+   * Decide all <source, target> pairs and
-    // First, match nodes on the same node group if cluster has nodegroup
-    // awareness
+    // First, match nodes on the same node group if cluster is node group aware
-      chooseNodesOnSameNodeGroup();
+      chooseNodes(SAME_NODE_GROUP);
-    chooseNodes(true);
-    // At last, match nodes on different racks
-    chooseNodes(false);
+    chooseNodes(SAME_RACK);
+    // At last, match all remaining nodes
+    chooseNodes(ANY_OTHER);
-  
-  /**
-   * Decide all <source, target> pairs where source and target are 
-   * on the same NodeGroup
-   */
-  private void chooseNodesOnSameNodeGroup() {
+  /** Decide all <source, target> pairs according to the matcher. */
+  private void chooseNodes(final Matcher matcher) {
-     * one or more underUtilized datanodes within same NodeGroup(targets).
+     * one or more underUtilized datanodes (targets).
-    chooseOnSameNodeGroup(overUtilizedDatanodes, underUtilizedDatanodes);
-
-    /* match each remaining overutilized datanode (source) to below average 
-     * utilized datanodes within the same NodeGroup(targets).
+    chooseDatanodes(overUtilizedDatanodes, underUtilizedDatanodes, matcher);
+    
+    /* match each remaining overutilized datanode (source) to 
+     * below average utilized datanodes (targets).
-    chooseOnSameNodeGroup(overUtilizedDatanodes, belowAvgUtilizedDatanodes);
+    chooseDatanodes(overUtilizedDatanodes, belowAvgUtilizedDatanodes, matcher);
-    /* match each remaining underutilized datanode to above average utilized 
-     * datanodes within the same NodeGroup.
+    /* match each remaining underutilized datanode (target) to 
+     * above average utilized datanodes (source).
-    chooseOnSameNodeGroup(underUtilizedDatanodes, aboveAvgUtilizedDatanodes);
+    chooseDatanodes(underUtilizedDatanodes, aboveAvgUtilizedDatanodes, matcher);
-  
+
-   * Match two sets of nodes within the same NodeGroup, one should be source
-   * nodes (utilization > Avg), and the other should be destination nodes 
-   * (utilization < Avg).
-   * @param datanodes
-   * @param candidates
+   * For each datanode, choose matching nodes from the candidates. Either the
+   * datanodes or the candidates are source nodes with (utilization > Avg), and
+   * the others are target nodes with (utilization < Avg).
-      chooseOnSameNodeGroup(Collection<D> datanodes, Collection<C> candidates) {
+      chooseDatanodes(Collection<D> datanodes, Collection<C> candidates,
+          Matcher matcher) {
-      for(; chooseOnSameNodeGroup(datanode, candidates.iterator()); );
-      if (!datanode.isMoveQuotaFull()) {
+      for(; chooseForOneDatanode(datanode, candidates, matcher); );
+      if (!datanode.hasSpaceForScheduling()) {
-  
+
-   * Match one datanode with a set of candidates nodes within the same NodeGroup.
+   * For the given datanode, choose a candidate and then schedule it.
+   * @return true if a candidate is chosen; false if no candidates is chosen.
-  private <T extends BalancerDatanode> boolean chooseOnSameNodeGroup(
-      BalancerDatanode dn, Iterator<T> candidates) {
-    final T chosen = chooseCandidateOnSameNodeGroup(dn, candidates);
+  private <C extends BalancerDatanode> boolean chooseForOneDatanode(
+      BalancerDatanode dn, Collection<C> candidates, Matcher matcher) {
+    final Iterator<C> i = candidates.iterator();
+    final C chosen = chooseCandidate(dn, i, matcher);
+
-    if (!chosen.isMoveQuotaFull()) {
-      candidates.remove();
+    if (!chosen.hasSpaceForScheduling()) {
+      i.remove();
-  /** choose a datanode from <code>candidates</code> within the same NodeGroup 
-   * of <code>dn</code>.
-   */
-  private <T extends BalancerDatanode> T chooseCandidateOnSameNodeGroup(
-      BalancerDatanode dn, Iterator<T> candidates) {
-    if (dn.isMoveQuotaFull()) {
+  /** Choose a candidate for the given datanode. */
+  private <D extends BalancerDatanode, C extends BalancerDatanode>
+      C chooseCandidate(D dn, Iterator<C> candidates, Matcher matcher) {
+    if (dn.hasSpaceForScheduling()) {
-        final T c = candidates.next();
-        if (!c.isMoveQuotaFull()) {
+        final C c = candidates.next();
+        if (!c.hasSpaceForScheduling()) {
-          continue;
-        }
-        if (cluster.isOnSameNodeGroup(dn.getDatanode(), c.getDatanode())) {
+        } else if (matcher.match(cluster, dn.getDatanode(), c.getDatanode())) {
-  /* if onRack is true, decide all <source, target> pairs
-   * where source and target are on the same rack; Otherwise
-   * decide all <source, target> pairs where source and target are
-   * on different racks
-   */
-  private void chooseNodes(boolean onRack) {
-    /* first step: match each overUtilized datanode (source) to
-     * one or more underUtilized datanodes (targets).
-     */
-    chooseTargets(underUtilizedDatanodes, onRack);
-    
-    /* match each remaining overutilized datanode (source) to 
-     * below average utilized datanodes (targets).
-     * Note only overutilized datanodes that haven't had that max bytes to move
-     * satisfied in step 1 are selected
-     */
-    chooseTargets(belowAvgUtilizedDatanodes, onRack);
-
-    /* match each remaining underutilized datanode (target) to 
-     * above average utilized datanodes (source).
-     * Note only underutilized datanodes that have not had that max bytes to
-     * move satisfied in step 1 are selected.
-     */
-    chooseSources(aboveAvgUtilizedDatanodes, onRack);
-  }
-   
-  /* choose targets from the target candidate list for each over utilized
-   * source datanode. OnRackTarget determines if the chosen target 
-   * should be on the same rack as the source
-   */
-  private void chooseTargets(
-      Collection<BalancerDatanode> targetCandidates, boolean onRackTarget ) {
-    for (Iterator<Source> srcIterator = overUtilizedDatanodes.iterator();
-        srcIterator.hasNext();) {
-      Source source = srcIterator.next();
-      while (chooseTarget(source, targetCandidates.iterator(), onRackTarget)) {
-      }
-      if (!source.isMoveQuotaFull()) {
-        srcIterator.remove();
-      }
-    }
-    return;
-  }
-  
-  /* choose sources from the source candidate list for each under utilized
-   * target datanode. onRackSource determines if the chosen source 
-   * should be on the same rack as the target
-   */
-  private void chooseSources(
-      Collection<Source> sourceCandidates, boolean onRackSource) {
-    for (Iterator<BalancerDatanode> targetIterator = 
-      underUtilizedDatanodes.iterator(); targetIterator.hasNext();) {
-      BalancerDatanode target = targetIterator.next();
-      while (chooseSource(target, sourceCandidates.iterator(), onRackSource)) {
-      }
-      if (!target.isMoveQuotaFull()) {
-        targetIterator.remove();
-      }
-    }
-    return;
-  }
-
-  /* For the given source, choose targets from the target candidate list.
-   * OnRackTarget determines if the chosen target 
-   * should be on the same rack as the source
-   */
-  private boolean chooseTarget(Source source,
-      Iterator<BalancerDatanode> targetCandidates, boolean onRackTarget) {
-    if (!source.isMoveQuotaFull()) {
-      return false;
-    }
-    boolean foundTarget = false;
-    BalancerDatanode target = null;
-    while (!foundTarget && targetCandidates.hasNext()) {
-      target = targetCandidates.next();
-      if (!target.isMoveQuotaFull()) {
-        targetCandidates.remove();
-        continue;
-      }
-      if (onRackTarget) {
-        // choose from on-rack nodes
-        if (cluster.isOnSameRack(source.datanode, target.datanode)) {
-          foundTarget = true;
-        }
-      } else {
-        // choose from off-rack nodes
-        if (!cluster.isOnSameRack(source.datanode, target.datanode)) {
-          foundTarget = true;
-        }
-      }
-    }
-    if (foundTarget) {
-      assert(target != null):"Choose a null target";
-      matchSourceWithTargetToMove(source, target);
-      if (!target.isMoveQuotaFull()) {
-        targetCandidates.remove();
-      }
-      return true;
-    }
-    return false;
-  }
-
-  /* For the given target, choose sources from the source candidate list.
-   * OnRackSource determines if the chosen source 
-   * should be on the same rack as the target
-   */
-  private boolean chooseSource(BalancerDatanode target,
-      Iterator<Source> sourceCandidates, boolean onRackSource) {
-    if (!target.isMoveQuotaFull()) {
-      return false;
-    }
-    boolean foundSource = false;
-    Source source = null;
-    while (!foundSource && sourceCandidates.hasNext()) {
-      source = sourceCandidates.next();
-      if (!source.isMoveQuotaFull()) {
-        sourceCandidates.remove();
-        continue;
-      }
-      if (onRackSource) {
-        // choose from on-rack nodes
-        if ( cluster.isOnSameRack(source.getDatanode(), target.getDatanode())) {
-          foundSource = true;
-        }
-      } else {
-        // choose from off-rack nodes
-        if (!cluster.isOnSameRack(source.datanode, target.datanode)) {
-          foundSource = true;
-        }
-      }
-    }
-    if (foundSource) {
-      assert(source != null):"Choose a null source";
-      matchSourceWithTargetToMove(source, target);
-      if ( !source.isMoveQuotaFull()) {
-          sourceCandidates.remove();
-        }
-      return true;
-    }
-    return false;
-  }
-

INS26 MOV31 INS40 INS55 INS23 INS23 INS23 INS29 INS83 INS42 MOV31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS29 UPD39 UPD42 UPD42 INS44 UPD42 INS44 INS73 INS43 UPD42 INS44 UPD42 MOV65 INS29 INS39 INS42 INS44 INS44 INS44 INS65 INS42 INS42 INS14 INS65 INS42 INS42 INS14 INS65 INS42 INS42 INS14 INS65 INS65 INS83 INS43 INS42 INS21 INS21 MOV21 INS43 INS42 INS65 UPD42 UPD74 INS43 INS42 INS60 UPD42 INS42 INS43 INS42 UPD43 UPD74 INS43 INS42 UPD66 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS66 INS43 INS1 INS66 INS43 INS1 INS66 INS43 INS1 INS66 INS66 INS66 INS66 INS66 INS66 UPD42 MOV42 INS32 INS32 UPD66 UPD66 UPD66 INS42 UPD66 INS66 UPD43 UPD43 INS42 INS83 INS74 INS59 UPD43 INS8 UPD66 UPD42 MOV42 UPD42 UPD43 INS42 INS66 INS42 INS42 INS42 UPD42 MOV42 INS31 INS42 INS31 INS42 INS31 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS43 INS43 INS42 MOV32 UPD42 INS21 MOV42 UPD42 UPD42 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS78 UPD83 MOV83 UPD39 MOV39 UPD42 MOV42 MOV44 INS44 INS44 INS8 INS78 UPD83 MOV83 MOV39 UPD42 MOV42 MOV44 MOV44 INS44 INS8 INS42 INS42 UPD42 UPD42 INS42 UPD42 INS32 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS41 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS41 INS42 UPD43 UPD42 INS43 UPD42 INS43 INS42 INS41 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 INS27 UPD42 UPD43 MOV8 MOV25 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 DEL66 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL9 DEL9 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL43 DEL74 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL38 DEL9 DEL41 DEL8 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL38 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL38 DEL32 DEL21 DEL18 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL40 DEL40 DEL32 DEL38 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL61 DEL42 DEL42 DEL33 DEL27 DEL36 DEL45 DEL6 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL9 DEL41 DEL8 DEL25 DEL9 DEL41 DEL29 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL65 DEL42 DEL65 DEL66 DEL43 DEL42 DEL42 DEL32 DEL21 DEL18 DEL8 DEL83 DEL39 DEL42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL44 DEL39 DEL42 DEL44 DEL43 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL32 DEL8 DEL61 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL41 DEL8 DEL31 DEL39 DEL42 DEL44 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL42 DEL32 DEL8 DEL61 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL41 DEL8 DEL31 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL38 DEL9 DEL41 DEL8 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL38 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL18 DEL8 DEL25 DEL42 DEL42 DEL42 DEL40 DEL40 DEL32 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL40 DEL40 DEL32 DEL38 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL61 DEL42 DEL33 DEL27 DEL36 DEL45 DEL6 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL9 DEL41 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31
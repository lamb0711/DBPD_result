HDFS-4987. Namenode changes to track multiple storages per datanode.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1518087 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.protocol.DatanodeInfo;
-   * This array contains triplets of references. For each i-th datanode the
-   * block belongs to triplets[3*i] is the reference to the DatanodeDescriptor
-   * and triplets[3*i+1] and triplets[3*i+2] are references to the previous and
-   * the next blocks, respectively, in the list of blocks belonging to this
-   * data-node.
+   * This array contains triplets of references. For each i-th storage, the
+   * block belongs to triplets[3*i] is the reference to the
+   * {@link DatanodeStorageInfo} and triplets[3*i+1] and triplets[3*i+2] are
+   * references to the previous and the next blocks, respectively, in the list
+   * of blocks belonging to this storage.
+    DatanodeStorageInfo storage = getStorageInfo(index);
+    return storage == null ? null : storage.getDatanodeDescriptor();
+  }
+
+  DatanodeStorageInfo getStorageInfo(int index) {
-    return (DatanodeDescriptor)triplets[index*3];
+    DatanodeStorageInfo storage = (DatanodeStorageInfo)triplets[index*3];
+    return storage;
-  private void setDatanode(int index, DatanodeDescriptor node, BlockInfo previous,
-      BlockInfo next) {
+  void setStorageInfo(int index, DatanodeStorageInfo storage) {
-    int i = index * 3;
-    assert index >= 0 && i+2 < triplets.length : "Index is out of bound";
-    triplets[i] = node;
-    triplets[i+1] = previous;
-    triplets[i+2] = next;
+    assert index >= 0 && index*3 < triplets.length : "Index is out of bound";
+    triplets[index*3] = storage;
-   * Add data-node this block belongs to.
+   * Add a {@link DatanodeStorageInfo} location for a block
-  public boolean addNode(DatanodeDescriptor node) {
-    if(findDatanode(node) >= 0) // the node is already there
+  boolean addStorage(DatanodeStorageInfo storage) {
+    if(findStorageInfo(storage) >= 0) // the node is already there
-    setDatanode(lastNode, node, null, null);
+    setStorageInfo(lastNode, storage);
+    setNext(lastNode, null);
+    setPrevious(lastNode, null);
-   * Remove data-node from the block.
+   * Remove {@link DatanodeStorageInfo} location for a block
-  public boolean removeNode(DatanodeDescriptor node) {
-    int dnIndex = findDatanode(node);
+  boolean removeStorage(DatanodeStorageInfo storage) {
+    int dnIndex = findStorageInfo(storage);
-    setDatanode(dnIndex, getDatanode(lastNode), getPrevious(lastNode),
-        getNext(lastNode));
+    setStorageInfo(dnIndex, getStorageInfo(lastNode));
+    setNext(dnIndex, getNext(lastNode)); 
+    setPrevious(dnIndex, getPrevious(lastNode)); 
-    setDatanode(lastNode, null, null, null);
+    setStorageInfo(lastNode, null);
+    setNext(lastNode, null); 
+    setPrevious(lastNode, null); 
+  /**
+   * Find specified DatanodeStorageInfo.
+   * @param dn
+   * @return index or -1 if not found.
+   */
+  int findStorageInfo(DatanodeInfo dn) {
+    int len = getCapacity();
+    for(int idx = 0; idx < len; idx++) {
+      DatanodeStorageInfo cur = getStorageInfo(idx);
+      if(cur == null)
+        break;
+      if(cur.getDatanodeDescriptor() == dn)
+        return idx;
+    }
+    return -1;
+  }
+  
+  /**
+   * Find specified DatanodeStorageInfo.
+   * @param storageInfo
+   * @return index or -1 if not found.
+   */
+  int findStorageInfo(DatanodeStorageInfo storageInfo) {
+    int len = getCapacity();
+    for(int idx = 0; idx < len; idx++) {
+      DatanodeStorageInfo cur = getStorageInfo(idx);
+      if(cur == storageInfo)
+        return idx;
+      if(cur == null)
+        break;
+    }
+    return -1;
+  }
-   * related to the specified DatanodeDescriptor.
+   * related to the specified DatanodeStorageInfo.
-  public BlockInfo listInsert(BlockInfo head, DatanodeDescriptor dn) {
-    int dnIndex = this.findDatanode(dn);
+  BlockInfo listInsert(BlockInfo head, DatanodeStorageInfo storage) {
+    int dnIndex = this.findStorageInfo(storage);
-      head.setPrevious(head.findDatanode(dn), this);
+      head.setPrevious(head.findStorageInfo(storage), this);
-   * related to the specified DatanodeDescriptor.
+   * related to the specified DatanodeStorageInfo.
-   * empty after deletion.
+   * empy after deletion.
-  public BlockInfo listRemove(BlockInfo head, DatanodeDescriptor dn) {
+  BlockInfo listRemove(BlockInfo head, DatanodeStorageInfo storage) {
-    int dnIndex = this.findDatanode(dn);
+    int dnIndex = this.findStorageInfo(storage);
-      prev.setNext(prev.findDatanode(dn), next);
+      prev.setNext(prev.findStorageInfo(storage), next);
-      next.setPrevious(next.findDatanode(dn), prev);
+      next.setPrevious(next.findStorageInfo(storage), prev);
-  /**
-   * Remove this block from the list of blocks related to the specified
-   * DatanodeDescriptor. Insert it into the head of the list of blocks.
-   *
-   * @return the new head of the list.
-   */
-  public BlockInfo moveBlockToHead(BlockInfo head, DatanodeDescriptor dn,
-      int curIndex, int headIndex) {
-    if (head == this) {
-      return this;
-    }
-    BlockInfo next = this.setNext(curIndex, head);
-    BlockInfo prev = this.setPrevious(curIndex, null);
-
-    head.setPrevious(headIndex, this);
-    prev.setNext(prev.findDatanode(dn), next);
-    if (next != null)
-      next.setPrevious(next.findDatanode(dn), prev);
-    return this;
+  int listCount(DatanodeStorageInfo storage) {
+    int count = 0;
+    for(BlockInfo cur = this; cur != null;
+          cur = cur.getNext(cur.findStorageInfo(storage)))
+      count++;
+    return count;

INS26 INS40 INS31 INS31 INS31 INS31 INS31 MOV43 UPD42 MOV42 MOV44 INS8 INS43 INS42 INS44 INS39 INS42 MOV44 MOV44 MOV8 UPD42 UPD42 MOV29 INS39 INS42 MOV44 INS8 INS29 INS39 INS42 INS44 INS8 INS39 INS42 INS44 INS8 INS60 INS41 INS42 INS39 INS42 INS60 UPD43 UPD42 UPD43 UPD42 INS21 INS21 INS21 UPD43 UPD42 INS21 INS21 INS21 INS21 INS21 INS65 UPD43 INS60 INS24 INS41 INS65 INS65 INS65 INS43 INS42 INS60 INS24 INS41 UPD43 UPD42 UPD43 UPD42 INS43 INS42 INS60 INS24 MOV41 UPD66 UPD66 INS65 UPD66 UPD66 UPD66 INS43 INS59 INS16 INS43 INS59 INS42 UPD42 UPD66 INS65 INS66 UPD42 INS32 INS32 INS32 UPD66 INS65 INS66 UPD42 INS32 INS32 INS32 INS32 INS32 UPD66 INS42 UPD66 UPD42 INS39 INS59 INS58 INS27 INS37 INS8 INS38 INS66 INS42 INS66 UPD42 MOV42 INS39 INS59 INS58 INS27 INS37 INS8 INS38 UPD66 UPD42 UPD66 UPD66 UPD42 INS42 INS39 INS59 INS58 INS27 INS7 INS21 INS42 INS42 UPD42 MOV42 INS42 INS32 INS27 INS33 INS32 INS42 INS42 MOV11 UPD42 INS42 UPD42 MOV42 MOV42 INS42 INS42 UPD42 MOV42 MOV33 INS42 INS42 MOV33 INS42 UPD42 UPD42 MOV42 INS42 MOV32 INS42 INS42 MOV32 INS42 MOV42 MOV33 INS42 INS42 MOV33 INS42 INS42 MOV33 INS42 INS32 INS39 INS59 INS42 INS42 INS42 INS60 INS25 MOV25 INS34 INS42 INS32 INS39 INS59 INS42 INS42 INS42 MOV60 INS25 INS25 INS34 INS42 INS34 MOV43 INS59 UPD42 MOV42 MOV33 INS42 INS32 INS37 INS42 INS42 INS42 INS33 INS42 INS42 UPD43 UPD27 UPD27 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS34 INS43 INS59 INS27 INS10 INS41 INS42 INS42 INS34 INS43 INS27 INS41 INS27 INS10 UPD42 UPD42 UPD42 UPD42 INS42 INS52 UPD42 MOV42 INS42 MOV32 INS42 UPD42 UPD42 UPD34 UPD42 UPD34 INS42 INS42 INS32 INS42 INS33 INS32 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS33 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 DEL42 DEL39 DEL42 DEL42 DEL34 DEL27 DEL59 DEL60 DEL42 DEL42 DEL2 DEL42 DEL7 DEL21 DEL42 DEL42 DEL34 DEL27 DEL2 DEL42 DEL7 DEL21 DEL83 DEL39 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL83 DEL32 DEL21 DEL83 DEL32 DEL21 DEL66 DEL42 DEL52 DEL52 DEL41 DEL8 DEL52 DEL33 DEL83 DEL83 DEL52 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL43 DEL42 DEL52 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL25 DEL8 DEL31
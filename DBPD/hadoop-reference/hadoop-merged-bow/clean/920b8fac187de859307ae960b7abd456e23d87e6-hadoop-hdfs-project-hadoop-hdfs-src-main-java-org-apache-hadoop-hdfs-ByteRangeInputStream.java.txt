HDFS-3334. Fix ByteRangeInputStream stream leakage.  Contributed by Daryn Sharp


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1331570 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.common.annotations.VisibleForTesting;
+
-    NORMAL, SEEK
+    NORMAL, SEEK, CLOSED
-  private InputStream getInputStream() throws IOException {
-    if (status != StreamStatus.NORMAL) {
-      
-      if (in != null) {
-        in.close();
-        in = null;
-      }
-      
-      // Use the original url if no resolved url exists, eg. if
-      // it's the first time a request is made.
-      final URLOpener opener =
-        (resolvedURL.getURL() == null) ? originalURL : resolvedURL;
-
-      final HttpURLConnection connection = opener.openConnection(startPos);
-      connection.connect();
-      checkResponseCode(connection);
-
-      final String cl = connection.getHeaderField(StreamFile.CONTENT_LENGTH);
-      if (cl == null) {
-        throw new IOException(StreamFile.CONTENT_LENGTH+" header is missing");
-      }
-      final long streamlength = Long.parseLong(cl);
-      filelength = startPos + streamlength;
-      // Java has a bug with >2GB request streams.  It won't bounds check
-      // the reads so the transfer blocks until the server times out
-      in = new BoundedInputStream(connection.getInputStream(), streamlength);
-
-      resolvedURL.setURL(getResolvedUrl(connection));
-      status = StreamStatus.NORMAL;
+  @VisibleForTesting
+  protected InputStream getInputStream() throws IOException {
+    switch (status) {
+      case NORMAL:
+        break;
+      case SEEK:
+        if (in != null) {
+          in.close();
+        }
+        in = openInputStream();
+        status = StreamStatus.NORMAL;
+        break;
+      case CLOSED:
+        throw new IOException("Stream closed");
-    
+  @VisibleForTesting
+  protected InputStream openInputStream() throws IOException {
+    // Use the original url if no resolved url exists, eg. if
+    // it's the first time a request is made.
+    final URLOpener opener =
+      (resolvedURL.getURL() == null) ? originalURL : resolvedURL;
+
+    final HttpURLConnection connection = opener.openConnection(startPos);
+    connection.connect();
+    checkResponseCode(connection);
+
+    final String cl = connection.getHeaderField(StreamFile.CONTENT_LENGTH);
+    if (cl == null) {
+      throw new IOException(StreamFile.CONTENT_LENGTH+" header is missing");
+    }
+    final long streamlength = Long.parseLong(cl);
+    filelength = startPos + streamlength;
+    // Java has a bug with >2GB request streams.  It won't bounds check
+    // the reads so the transfer blocks until the server times out
+    InputStream is =
+        new BoundedInputStream(connection.getInputStream(), streamlength);
+
+    resolvedURL.setURL(getResolvedUrl(connection));
+    
+    return is;
+  }
+  
+  @Override
-      status = StreamStatus.SEEK;
+      if (status != StreamStatus.CLOSED) {
+        status = StreamStatus.SEEK;
+      }
+  @Override
+  @Override
-}
+  
+  @Override
+  public void close() throws IOException {
+    if (in != null) {
+      in.close();
+      in = null;
+    }
+    status = StreamStatus.CLOSED;
+  }
+}

INS26 INS40 INS31 INS31 INS72 INS78 INS83 INS43 INS42 INS43 INS8 INS78 UPD83 UPD42 MOV8 INS78 INS78 INS78 INS78 INS83 INS39 INS42 INS43 INS8 INS42 INS42 INS42 INS42 INS50 MOV41 INS42 INS60 INS41 INS42 INS42 INS42 INS42 INS42 MOV25 INS21 INS42 INS49 INS10 INS49 INS25 INS21 MOV21 INS10 INS49 INS53 INS43 INS59 INS42 INS7 INS42 INS42 INS27 INS8 INS7 INS42 INS14 INS42 INS42 MOV14 INS25 INS42 INS40 INS42 INS33 INS21 INS42 INS32 INS43 INS45 INS27 INS8 INS32 INS42 INS42 INS42 INS40 MOV21 INS42 INS42 DEL42 DEL7 DEL21 DEL42 DEL40 DEL27 DEL25 DEL8
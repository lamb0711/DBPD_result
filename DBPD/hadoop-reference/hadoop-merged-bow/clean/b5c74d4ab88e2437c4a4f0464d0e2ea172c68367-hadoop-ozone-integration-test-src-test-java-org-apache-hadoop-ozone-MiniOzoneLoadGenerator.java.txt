HDDS-1782. Add an option to MiniOzoneChaosCluster to read files multiple times. Contributed by Mukul Kumar Singh. (#1076)



+import org.apache.hadoop.ozone.chaos.TestProbability;
+import java.io.IOException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
+  private static String keyNameDelimiter = "_";
+
-  MiniOzoneLoadGenerator(List<OzoneBucket> bucket, int numThreads,
+  private final AtomicInteger agedFileWrittenIndex;
+  private final ExecutorService agedFileExecutor;
+  private final OzoneBucket agedLoadBucket;
+  private final TestProbability agedWriteProbability;
+
+  MiniOzoneLoadGenerator(List<OzoneBucket> bucket,
+                         OzoneBucket agedLoadBucket, int numThreads,
+    this.agedFileWrittenIndex = new AtomicInteger(0);
+    this.agedFileExecutor = Executors.newSingleThreadExecutor();
+    this.agedLoadBucket = agedLoadBucket;
+    this.agedWriteProbability = TestProbability.valueOf(10);
+
-      // choose a random buffer.
-      int index = RandomUtils.nextInt();
-      ByteBuffer buffer = buffers.get(index % numBuffers);
-      int bufferCapacity = buffer.capacity();
-
-      String keyName = threadName + "-" + index;
-      try (OzoneOutputStream stream = bucket.createKey(keyName,
-          bufferCapacity, ReplicationType.RATIS, ReplicationFactor.THREE,
-          new HashMap<>())) {
-        stream.write(buffer.array());
-      } catch (Exception e) {
-        LOG.error("LOADGEN: Create key:{} failed with exception, skipping",
-            keyName, e);
-        continue;
-        // TODO: HDDS-1403.A key write can fail after multiple block writes
-        //  to closed container. add a break here once that is fixed.
-      }
-
-      try (OzoneInputStream stream = bucket.readKey(keyName)) {
-        byte[] readBuffer = new byte[bufferCapacity];
-        int readLen = stream.read(readBuffer);
-
-        if (readLen < bufferCapacity) {
-          LOG.error("LOADGEN: Read mismatch, key:{} read data length:{} is " +
-              "smaller than excepted:{}", keyName, readLen, bufferCapacity);
-          break;
-        }
-
-        if (!Arrays.equals(readBuffer, buffer.array())) {
-          LOG.error("LOADGEN: Read mismatch, key:{} Read data does not match " +
-              "the written data", keyName);
-          break;
-        }
-
-      } catch (Exception e) {
-        LOG.error("LOADGEN: Read key:{} failed with exception", keyName, e);
-        break;
-      }
-
-        bucket.deleteKey(keyName);
+        int index = RandomUtils.nextInt();
+        String keyName = writeData(index, bucket, threadName);
+
+        readData(bucket, keyName);
+
+        deleteKey(bucket, keyName);
-        LOG.error("LOADGEN: Unable to delete key:{}", keyName, e);
+        LOG.error("LOADGEN: Exiting due to exception", e);
+        break;
-  public void startIO(long time, TimeUnit timeUnit) {
+
+  private String writeData(int keyIndex, OzoneBucket bucket, String threadName)
+      throws Exception {
+    // choose a random buffer.
+    ByteBuffer buffer = buffers.get(keyIndex % numBuffers);
+    int bufferCapacity = buffer.capacity();
+
+    String keyName = threadName + keyNameDelimiter + keyIndex;
+    try (OzoneOutputStream stream = bucket.createKey(keyName,
+        bufferCapacity, ReplicationType.RATIS, ReplicationFactor.THREE,
+        new HashMap<>())) {
+      stream.write(buffer.array());
+    } catch (Throwable t) {
+      LOG.error("LOADGEN: Create key:{} failed with exception, skipping",
+          keyName, t);
+      throw t;
+    }
+
+    return keyName;
+  }
+
+  private void readData(OzoneBucket bucket, String keyName) throws Exception {
+    int index = Integer.valueOf(keyName.split(keyNameDelimiter)[1]);
+
+
+    ByteBuffer buffer = buffers.get(index % numBuffers);
+    int bufferCapacity = buffer.capacity();
+
+    try (OzoneInputStream stream = bucket.readKey(keyName)) {
+      byte[] readBuffer = new byte[bufferCapacity];
+      int readLen = stream.read(readBuffer);
+
+      if (readLen < bufferCapacity) {
+        throw new IOException("Read mismatch, key:" + keyName +
+            " read data length:" + readLen +
+            " is smaller than excepted:" + bufferCapacity);
+      }
+
+      if (!Arrays.equals(readBuffer, buffer.array())) {
+        throw new IOException("Read mismatch, key:" + keyName +
+            " read data does not match the written data");
+      }
+    } catch (Throwable t) {
+      LOG.error("LOADGEN: Read key:{} failed with exception", keyName, t);
+      throw t;
+    }
+  }
+
+  private void deleteKey(OzoneBucket bucket, String keyName) throws Exception {
+    try {
+      bucket.deleteKey(keyName);
+    } catch (Throwable t) {
+      LOG.error("LOADGEN: Unable to delete key:{}", keyName, t);
+      throw t;
+    }
+  }
+
+  private String getKeyToRead() {
+    int currentIndex = agedFileWrittenIndex.get();
+    return currentIndex != 0 ?
+        String.valueOf(RandomUtils.nextInt(0, currentIndex)): null;
+  }
+
+  private void startAgedFilesLoad(long runTimeMillis) {
+    long threadID = Thread.currentThread().getId();
+    LOG.info("AGED LOADGEN: Started Aged IO Thread:{}.", threadID);
+    String threadName = Thread.currentThread().getName();
+    long startTime = Time.monotonicNow();
+
+    while (isWriteThreadRunning.get() &&
+        (Time.monotonicNow() < startTime + runTimeMillis)) {
+
+      String keyName = null;
+      try {
+        if (agedWriteProbability.isTrue()) {
+          keyName = writeData(agedFileWrittenIndex.incrementAndGet(),
+              agedLoadBucket, threadName);
+        } else {
+          keyName = getKeyToRead();
+          if (keyName != null) {
+            readData(agedLoadBucket, keyName);
+          }
+        }
+      } catch (Throwable t) {
+        LOG.error("AGED LOADGEN: {} Exiting due to exception", keyName, t);
+        break;
+      }
+    }
+    // This will terminate other threads too.
+    isWriteThreadRunning.set(false);
+    LOG.info("Terminating IO thread:{}.", threadID);
+  }
+
+  void startIO(long time, TimeUnit timeUnit) {
+      writeFutures.add(CompletableFuture.runAsync(() ->
+              startAgedFilesLoad(timeUnit.toMillis(time)), agedFileExecutor));
+

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS44 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS43 MOV8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS21 INS21 INS21 INS21 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS60 MOV54 INS41 INS43 INS42 INS43 INS42 INS42 INS60 INS43 INS42 INS43 INS42 INS42 INS54 INS42 INS60 INS41 INS39 INS42 INS60 INS21 INS60 INS60 INS61 INS21 INS21 INS42 INS7 INS7 INS7 INS7 INS8 INS42 INS42 INS43 INS59 INS39 INS59 INS43 INS59 INS42 INS42 INS42 INS39 INS59 INS42 INS42 MOV8 INS12 INS39 INS59 INS16 INS39 INS59 INS32 INS43 INS59 INS39 INS59 INS27 INS8 INS32 INS32 INS22 INS14 INS22 INS32 INS22 INS42 INS22 INS32 MOV60 INS54 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS27 INS42 INS32 INS44 INS44 INS8 INS42 INS32 INS27 INS32 INS33 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS36 INS60 INS54 INS42 INS42 INS9 INS42 INS42 INS45 INS42 INS21 INS52 INS42 INS43 INS34 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS34 INS8 INS12 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 UPD43 UPD42 INS53 INS42 INS42 INS2 INS43 INS42 INS53 INS43 INS42 INS21 INS53 INS42 INS42 INS42 INS34 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS43 INS59 INS8 INS12 INS32 INS42 MOV60 INS60 INS21 INS21 MOV44 INS8 INS42 INS42 UPD42 INS42 INS32 INS34 INS53 INS53 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS42 INS42 INS33 INS25 INS44 INS8 INS42 INS42 INS32 MOV43 INS59 INS32 INS32 INS21 INS10 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS14 INS14 UPD42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS8 INS43 INS42 INS21 INS10 INS42 INS42 INS86 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS27 INS43 INS27 INS42 INS42 INS21 INS21 INS25 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 UPD45 MOV45 INS42 INS45 INS42 INS45 INS42 INS42 UPD45 MOV45 INS42 UPD45 MOV45 INS7 INS7 INS27 INS8 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 DEL18 DEL42 DEL42 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL45 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL10 DEL42 DEL42 DEL27 DEL42 DEL32 DEL21 DEL10 DEL10 DEL42 DEL43 DEL42 DEL44 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL83
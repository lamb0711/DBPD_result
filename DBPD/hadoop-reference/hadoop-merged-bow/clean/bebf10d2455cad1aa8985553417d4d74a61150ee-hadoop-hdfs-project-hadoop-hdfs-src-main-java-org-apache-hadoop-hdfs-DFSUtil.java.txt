HDFS-10656. Optimize conversion of byte arrays back to path string. Contributed by Daryn Sharp.

-import com.google.common.base.Charsets;
-  public static String byteArray2PathString(byte[][] pathComponents,
-      int offset, int length) {
-    if (pathComponents.length == 0) {
+  public static String byteArray2PathString(final byte[][] components,
+      final int offset, final int length) {
+    // specifically not using StringBuilder to more efficiently build
+    // string w/o excessive byte[] copies and charset conversions.
+    final int range = offset + length;
+    Preconditions.checkPositionIndexes(offset, range, components.length);
+    if (length == 0) {
-    Preconditions.checkArgument(offset >= 0 && offset < pathComponents.length);
-    Preconditions.checkArgument(length >= 0 && offset + length <=
-        pathComponents.length);
-    if (offset == 0 && length == 1
-        && (pathComponents[0] == null || pathComponents[0].length == 0)) {
-      return Path.SEPARATOR;
+    // absolute paths start with either null or empty byte[]
+    byte[] firstComponent = components[offset];
+    boolean isAbsolute = (offset == 0 &&
+        (firstComponent == null || firstComponent.length == 0));
+    if (offset == 0 && length == 1) {
+      return isAbsolute ? Path.SEPARATOR : bytes2String(firstComponent);
-    StringBuilder result = new StringBuilder();
-    int lastIndex = offset + length - 1;
-    for (int i = offset; i <= lastIndex; i++) {
-      result.append(new String(pathComponents[i], Charsets.UTF_8));
-      if (i < lastIndex) {
-        result.append(Path.SEPARATOR_CHAR);
-      }
+    // compute length of full byte[], seed with 1st component and delimiters
+    int pos = isAbsolute ? 0 : firstComponent.length;
+    int size = pos + length - 1;
+    for (int i=offset + 1; i < range; i++) {
+      size += components[i].length;
-    return result.toString();
+    final byte[] result = new byte[size];
+    if (!isAbsolute) {
+      System.arraycopy(firstComponent, 0, result, 0, firstComponent.length);
+    }
+    // append remaining components as "/component".
+    for (int i=offset + 1; i < range; i++) {
+      result[pos++] = (byte)Path.SEPARATOR_CHAR;
+      int len = components[i].length;
+      System.arraycopy(components[i], 0, result, pos, len);
+      pos += len;
+    }
+    return bytes2String(result);

MOV25 INS83 UPD42 INS83 INS83 INS60 INS60 INS60 INS25 INS24 INS60 INS25 INS24 INS83 INS39 INS59 INS5 INS59 INS39 INS59 MOV27 MOV8 INS39 MOV58 UPD27 MOV27 MOV37 INS8 INS83 INS5 INS59 INS38 INS8 INS58 INS27 INS37 INS8 INS42 MOV27 UPD42 INS42 INS42 INS40 INS42 INS39 INS85 INS42 INS2 INS42 INS36 UPD42 INS16 UPD42 UPD42 INS21 INS39 INS85 INS42 INS3 INS42 INS21 INS39 INS59 MOV42 UPD42 MOV42 INS42 MOV21 INS60 INS21 INS21 INS42 INS42 INS42 INS27 INS16 INS42 INS34 INS40 INS27 INS7 INS5 INS42 INS32 INS42 INS27 INS7 INS39 INS59 INS32 INS7 UPD27 MOV27 MOV36 INS42 INS40 INS32 UPD42 INS42 INS34 INS42 INS22 INS39 INS85 INS42 INS42 INS42 INS34 INS42 INS34 INS40 INS42 INS34 INS2 INS11 INS42 INS22 INS42 INS42 INS2 INS34 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS2 INS42 INS42 INS37 INS39 INS40 INS2 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS34 DEL40 DEL26 DEL42 DEL34 DEL27 DEL42 DEL40 DEL27 DEL27 DEL40 DEL42 DEL34 DEL2 DEL42 DEL34 DEL2 DEL42 DEL22 DEL34 DEL40 DEL42 DEL42 DEL40 DEL27 DEL27 DEL32 DEL21 DEL27 DEL25 DEL42 DEL43 DEL42 DEL43 DEL14 DEL42 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL2 DEL40 DEL14 DEL32 DEL21 DEL27 DEL8 DEL25 DEL8 DEL24 DEL42
Merge remote-tracking branch 'apache/trunk' into HDFS-7285

-  
-  /**
-   * Choose <i>localMachine</i> as the target.
-   * if <i>localMachine</i> is not available, 
-   * choose a node on the same rack
-   * @return the chosen storage
-   */
+
-      EnumMap<StorageType, Integer> storageTypes, boolean fallbackToLocalRack)
+      EnumMap<StorageType, Integer> storageTypes)
-      if (excludedNodes.add(localMachine)) { // was not in the excluded list
+      if (excludedNodes.add(localMachine) // was not in the excluded list
+          && isGoodDatanode(localDatanode, maxNodesPerRack, false,
+              results, avoidStaleNodes)) {
-                maxNodesPerRack, false, results, avoidStaleNodes, type) >= 0) {
+                results, type) >= 0) {
+    return null;
+  }
+
+  /**
+   * Choose <i>localMachine</i> as the target.
+   * if <i>localMachine</i> is not available,
+   * choose a node on the same rack
+   * @return the chosen storage
+   */
+  protected DatanodeStorageInfo chooseLocalStorage(Node localMachine,
+      Set<Node> excludedNodes, long blocksize, int maxNodesPerRack,
+      List<DatanodeStorageInfo> results, boolean avoidStaleNodes,
+      EnumMap<StorageType, Integer> storageTypes, boolean fallbackToLocalRack)
+      throws NotEnoughReplicasException {
+    DatanodeStorageInfo localStorage = chooseLocalStorage(localMachine,
+        excludedNodes, blocksize, maxNodesPerRack, results,
+        avoidStaleNodes, storageTypes);
+    if (localStorage != null) {
+      return localStorage;
+    }
+        if (!isGoodDatanode(chosenNode, maxNodesPerRack, considerLoad,
+            results, avoidStaleNodes)) {
+          if (LOG.isDebugEnabled()) {
+            builder.append("\n]");
+          }
+          badTarget = true;
+          continue;
+        }
-                excludedNodes, blocksize, maxNodesPerRack, considerLoad, results,
-                avoidStaleNodes, type);
+                excludedNodes, blocksize, results, type);
-      int maxNodesPerRack,
-      boolean considerLoad,
-      List<DatanodeStorageInfo> results,                           
-      boolean avoidStaleNodes,
+      List<DatanodeStorageInfo> results,
-    if (isGoodTarget(storage, blockSize, maxNodesPerRack, considerLoad,
-        results, avoidStaleNodes, storageType)) {
+    if (isGoodTarget(storage, blockSize, results, storageType)) {
+  private static void logNodeIsNotChosen(DatanodeDescriptor node,
+      String reason) {
+    if (LOG.isDebugEnabled()) {
+      // build the error message for later use.
+      debugLoggingBuilder.get()
+          .append("\n  Datanode ").append(node)
+          .append(" is not chosen since ").append(reason).append(".");
+    }
+  }
+
-   * Determine if a storage is a good target. 
-   * 
-   * @param storage The target storage
-   * @param blockSize Size of block
-   * @param maxTargetPerRack Maximum number of targets per rack. The value of 
-   *                       this parameter depends on the number of racks in 
+   * Determine if a datanode is good for placing block.
+   *
+   * @param node The target datanode
+   * @param maxTargetPerRack Maximum number of targets per rack. The value of
+   *                       this parameter depends on the number of racks in
-   * @param results A list containing currently chosen nodes. Used to check if 
+   * @param results A list containing currently chosen nodes. Used to check if
-   * @return Return true if <i>node</i> has enough space, 
-   *         does not have too much load, 
-   *         and the rack does not have too many nodes.
+   * @return Reture true if the datanode is good candidate, otherwise false
+   */
+  boolean isGoodDatanode(DatanodeDescriptor node,
+                         int maxTargetPerRack, boolean considerLoad,
+                         List<DatanodeStorageInfo> results,
+                         boolean avoidStaleNodes) {
+    // check if the node is (being) decommissioned
+    if (node.isDecommissionInProgress() || node.isDecommissioned()) {
+      logNodeIsNotChosen(node, "the node is (being) decommissioned ");
+      return false;
+    }
+
+    if (avoidStaleNodes) {
+      if (node.isStale(this.staleInterval)) {
+        logNodeIsNotChosen(node, "the node is stale ");
+        return false;
+      }
+    }
+
+    // check the communication traffic of the target machine
+    if (considerLoad) {
+      final double maxLoad = 2.0 * stats.getInServiceXceiverAverage();
+      final int nodeLoad = node.getXceiverCount();
+      if (nodeLoad > maxLoad) {
+        logNodeIsNotChosen(node, "the node is too busy (load: " + nodeLoad
+            + " > " + maxLoad + ") ");
+        return false;
+      }
+    }
+      
+    // check if the target rack has chosen too many nodes
+    String rackname = node.getNetworkLocation();
+    int counter=1;
+    for(DatanodeStorageInfo resultStorage : results) {
+      if (rackname.equals(
+          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {
+        counter++;
+      }
+    }
+    if (counter > maxTargetPerRack) {
+      logNodeIsNotChosen(node, "the rack has too many chosen nodes ");
+      return false;
+    }
+
+    return true;
+  }
+
+  /**
+   * Determine if a storage is a good target.
+   *
+   * @param storage The target storage
+   * @param blockSize Size of block
+   * @param results A list containing currently chosen nodes. Used to check if
+   *                too many nodes has been chosen in the target rack.
+   * @return Return true if <i>node</i> has enough space.
-                               long blockSize, int maxTargetPerRack,
-                               boolean considerLoad,
+                               long blockSize,
-                               boolean avoidStaleNodes,
-    // check if the node is (being) decommissioned
-    if (node.isDecommissionInProgress() || node.isDecommissioned()) {
-      logNodeIsNotChosen(storage, "the node is (being) decommissioned ");
-      return false;
-    }
-    if (avoidStaleNodes) {
-      if (node.isStale(this.staleInterval)) {
-        logNodeIsNotChosen(storage, "the node is stale ");
-        return false;
-      }
-    }
-    
-    final long remaining = node.getRemaining(storage.getStorageType());
+    final long remaining = node.getRemaining(storage.getStorageType(),
+        requiredSize);
-    // check the communication traffic of the target machine
-    if (considerLoad) {
-      final double maxLoad = 2.0 * stats.getInServiceXceiverAverage();
-      final int nodeLoad = node.getXceiverCount();
-      if (nodeLoad > maxLoad) {
-        logNodeIsNotChosen(storage, "the node is too busy (load: " + nodeLoad
-            + " > " + maxLoad + ") ");
-        return false;
-      }
-    }
-      
-    // check if the target rack has chosen too many nodes
-    String rackname = node.getNetworkLocation();
-    int counter=1;
-    for(DatanodeStorageInfo resultStorage : results) {
-      if (rackname.equals(
-          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {
-        counter++;
-      }
-    }
-    if (counter>maxTargetPerRack) {
-      logNodeIsNotChosen(storage, "the rack has too many chosen nodes ");
-      return false;
-    }

INS31 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS44 MOV44 INS44 MOV44 INS44 MOV44 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS39 INS42 INS44 MOV44 MOV44 INS44 MOV44 INS8 INS41 INS65 MOV65 INS42 INS43 INS42 INS74 INS42 INS39 INS42 INS74 INS42 INS74 INS42 INS42 INS60 INS25 MOV25 MOV41 INS43 INS42 INS43 INS42 INS25 INS65 INS65 INS65 MOV65 INS65 MOV65 INS65 INS43 INS42 INS74 INS42 MOV25 INS25 MOV25 MOV60 MOV60 MOV70 INS25 INS41 INS33 INS66 INS66 INS66 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS59 INS27 INS8 INS42 INS42 INS32 INS8 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS43 INS43 INS42 INS8 MOV27 INS8 INS9 UPD66 UPD66 UPD66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS21 INS42 INS42 MOV41 INS25 INS21 MOV41 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV32 INS8 INS32 INS42 MOV32 INS32 INS25 INS32 INS42 INS45 UPD42 INS21 MOV41 INS42 INS42 INS45 INS42 INS42 INS42 INS9 INS42 INS42 INS38 INS8 INS32 INS42 INS42 INS32 INS32 INS25 INS21 INS18 INS32 INS42 INS45 INS42 INS42 INS45 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS7 INS32 INS42 INS42 INS42 INS42 INS21 INS42 INS9 INS32 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS45 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL9 DEL42 DEL42 DEL42 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL66 DEL66 DEL66 DEL65 DEL66 DEL66 DEL42 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25
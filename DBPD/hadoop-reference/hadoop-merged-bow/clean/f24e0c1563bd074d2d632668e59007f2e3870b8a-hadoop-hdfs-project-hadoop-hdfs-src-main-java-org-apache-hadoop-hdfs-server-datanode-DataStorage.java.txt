Merge trunk to HDFS-4685.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1550774 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Properties;
+import java.util.*;
+import org.apache.hadoop.hdfs.server.protocol.DatanodeStorage;
-  /** Unique storage ID. {@see DataNode#createNewStorageId(int)} for details */
-  private String storageID;
+  /**
+   * Datanode UUID that this storage is currently attached to. This
+   *  is the same as the legacy StorageID for datanodes that were
+   *  upgraded from a pre-UUID version. For compatibility with prior
+   *  versions of Datanodes we cannot make this field a UUID.
+   */
+  private String datanodeUuid = null;
-    storageID = "";
-  public DataStorage(StorageInfo storageInfo, String strgID) {
+  public DataStorage(StorageInfo storageInfo) {
-    this.storageID = strgID;
-  /** @return storage ID. */
-  public synchronized String getStorageID() {
-    return storageID;
+  public synchronized String getDatanodeUuid() {
+    return datanodeUuid;
-  
-  synchronized void setStorageID(String newStorageID) {
-    this.storageID = newStorageID;
+
+  public synchronized void setDatanodeUuid(String newDatanodeUuid) {
+    this.datanodeUuid = newDatanodeUuid;
-  public synchronized void createStorageID(int datanodePort) {
-    if (storageID != null && !storageID.isEmpty()) {
-      return;
+  public synchronized void createStorageID(StorageDirectory sd) {
+    if (sd.getStorageUuid() == null) {
+      sd.setStorageUuid(DatanodeStorage.generateUuid());
-    storageID = DataNode.createNewStorageId(datanodePort);
-      NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt)
+      NamespaceInfo nsInfo, Collection<StorageLocation> dataDirs,
+      StartupOption startOpt)
-    for(Iterator<File> it = dataDirs.iterator(); it.hasNext();) {
-      File dataDir = it.next();
+    for(Iterator<StorageLocation> it = dataDirs.iterator(); it.hasNext();) {
+      File dataDir = it.next().getFile();
-          format(sd, nsInfo);
+          format(sd, nsInfo, datanode.getDatanodeUuid());
+      createStorageID(getStorageDir(idx));
-    // make sure we have storage id set - if not - generate new one
-    createStorageID(datanode.getXferPort());
-    
-      Collection<File> dataDirs, StartupOption startOpt) throws IOException {
+      Collection<StorageLocation> dataDirs, StartupOption startOpt) throws IOException {
-    
+
-    for(Iterator<File> it = dataDirs.iterator(); it.hasNext();) {
-      File dnRoot = it.next();
+    for(StorageLocation dir : dataDirs) {
+      File dnRoot = dir.getFile();
-  void format(StorageDirectory sd, NamespaceInfo nsInfo) throws IOException {
+  void format(StorageDirectory sd, NamespaceInfo nsInfo,
+              String datanodeUuid) throws IOException {
-    // store storageID as it currently is
+    this.datanodeUuid = datanodeUuid;
+
+    if (sd.getStorageUuid() == null) {
+      // Assign a new Storage UUID.
+      sd.setStorageUuid(DatanodeStorage.generateUuid());
+    }
+
-   * DataStorage VERSION file
+   * DataStorage VERSION file.
+   * Always called just before writing the properties to
+   * the VERSION file.
-    props.setProperty("storageID", getStorageID());
+    props.setProperty("storageID", sd.getStorageUuid());
+
+    String datanodeUuid = getDatanodeUuid();
+    if (datanodeUuid != null) {
+      props.setProperty("datanodeUuid", datanodeUuid);
+    }
+
+   * Always called just after reading the properties from the VERSION file.
+
-    String sid = getStorageID();
-    if (!(sid.equals("") || ssid.equals("") || sid.equals(ssid))) {
+    String sid = sd.getStorageUuid();
+    if (!(sid == null || sid.equals("") ||
+          ssid.equals("") || sid.equals(ssid))) {
-    
-    if (sid.equals("")) { // update id only if it was empty
-      setStorageID(ssid);
+
+    if (sid == null) { // update id only if it was null
+      sd.setStorageUuid(ssid);
+    }
+
+    // Update the datanode UUID if present.
+    if (props.getProperty("datanodeUuid") != null) {
+      String dnUuid = props.getProperty("datanodeUuid");
+
+      if (getDatanodeUuid() == null) {
+        setDatanodeUuid(dnUuid);
+      } else if (getDatanodeUuid().compareTo(dnUuid) != 0) {
+        throw new InconsistentFSStateException(sd.getRoot(),
+            "Root " + sd.getRoot() + ": DatanodeUuid=" + dnUuid +
+            ", does not match " + getDatanodeUuid() + " from other" +
+            " StorageDirectory.");
+      }

MOV26 UPD40 UPD40 UPD42 INS83 UPD42 MOV44 MOV44 UPD42 INS33 UPD42 INS43 INS42 INS25 UPD74 UPD74 INS70 UPD42 INS21 INS25 INS60 INS25 INS25 UPD66 UPD66 MOV66 UPD66 INS66 UPD42 INS42 UPD27 MOV27 INS8 UPD43 UPD43 INS44 INS42 MOV8 INS7 INS27 INS8 INS43 INS59 INS27 INS8 INS27 INS8 INS27 INS8 UPD42 INS32 INS33 MOV21 UPD42 UPD74 INS21 UPD42 INS43 INS42 INS22 INS42 INS32 INS33 INS21 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS33 INS21 INS32 INS33 INS60 INS25 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 UPD43 INS32 UPD42 MOV42 INS52 INS42 INS42 INS42 INS32 INS42 UPD42 INS42 INS32 INS42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 UPD45 MOV45 INS43 INS59 INS27 MOV8 INS25 INS42 INS42 INS32 UPD42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS33 INS27 INS8 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS27 MOV32 INS42 INS42 INS45 INS42 INS32 INS34 INS53 INS27 MOV32 UPD42 UPD42 INS32 INS42 INS42 INS14 INS32 INS42 INS33 INS42 INS43 INS32 INS27 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS45 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL65 DEL42 DEL45 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL33 DEL27 DEL32 DEL38 DEL42 DEL42 DEL32 DEL7 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL32
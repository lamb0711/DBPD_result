HDFS-6305. WebHdfs response decoding may throw RuntimeExceptions (Daryn Sharp via jeagles)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594273 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.hdfs.web.resources.AccessTimeParam;
-import org.apache.hadoop.hdfs.web.resources.AclPermissionParam;
-import org.apache.hadoop.hdfs.web.resources.BlockSizeParam;
-import org.apache.hadoop.hdfs.web.resources.BufferSizeParam;
-import org.apache.hadoop.hdfs.web.resources.ConcatSourcesParam;
-import org.apache.hadoop.hdfs.web.resources.CreateParentParam;
-import org.apache.hadoop.hdfs.web.resources.DelegationParam;
-import org.apache.hadoop.hdfs.web.resources.DeleteOpParam;
-import org.apache.hadoop.hdfs.web.resources.DestinationParam;
-import org.apache.hadoop.hdfs.web.resources.DoAsParam;
-import org.apache.hadoop.hdfs.web.resources.GetOpParam;
-import org.apache.hadoop.hdfs.web.resources.GroupParam;
-import org.apache.hadoop.hdfs.web.resources.HttpOpParam;
-import org.apache.hadoop.hdfs.web.resources.LengthParam;
-import org.apache.hadoop.hdfs.web.resources.ModificationTimeParam;
-import org.apache.hadoop.hdfs.web.resources.OffsetParam;
-import org.apache.hadoop.hdfs.web.resources.OverwriteParam;
-import org.apache.hadoop.hdfs.web.resources.OwnerParam;
-import org.apache.hadoop.hdfs.web.resources.Param;
-import org.apache.hadoop.hdfs.web.resources.PermissionParam;
-import org.apache.hadoop.hdfs.web.resources.PostOpParam;
-import org.apache.hadoop.hdfs.web.resources.PutOpParam;
-import org.apache.hadoop.hdfs.web.resources.RecursiveParam;
-import org.apache.hadoop.hdfs.web.resources.RenameOptionSetParam;
-import org.apache.hadoop.hdfs.web.resources.RenewerParam;
-import org.apache.hadoop.hdfs.web.resources.ReplicationParam;
-import org.apache.hadoop.hdfs.web.resources.TokenArgumentParam;
-import org.apache.hadoop.hdfs.web.resources.UserParam;
+import org.apache.hadoop.hdfs.web.resources.*;
+import org.apache.hadoop.hdfs.web.resources.HttpOpParam.Op;
-   * Run a http operation.
-   * Connect to the http server, validate response, and obtain the JSON output.
-   * 
-   * @param op http operation
-   * @param fspath file system path
-   * @param parameters parameters for the operation
-   * @return a JSON object, e.g. Object[], Map<?, ?>, etc.
-   * @throws IOException
-   */
-  private Map<?, ?> run(final HttpOpParam.Op op, final Path fspath,
-      final Param<?,?>... parameters) throws IOException {
-    return new FsPathRunner(op, fspath, parameters).run().json;
-  }
-
-  /**
-  abstract class AbstractRunner {
+  abstract class AbstractRunner<T> {
-    protected HttpURLConnection conn = null;
-    private Map<?, ?> json = null;
-    AbstractRunner run() throws IOException {
+    T run() throws IOException {
-            new PrivilegedExceptionAction<AbstractRunner>() {
+            new PrivilegedExceptionAction<T>() {
-              public AbstractRunner run() throws IOException {
+              public T run() throws IOException {
-    
-    private void init() throws IOException {
-      checkRetry = !redirected;
-      URL url = getUrl();
-      conn = (HttpURLConnection) connectionFactory.openConnection(url);
-    }
-    
-    private void connect() throws IOException {
-      connect(op.getDoOutput());
+
+    /**
+     * Two-step requests redirected to a DN
+     * 
+     * Create/Append:
+     * Step 1) Submit a Http request with neither auto-redirect nor data. 
+     * Step 2) Submit another Http request with the URL from the Location header with data.
+     * 
+     * The reason of having two-step create/append is for preventing clients to
+     * send out the data before the redirect. This issue is addressed by the
+     * "Expect: 100-continue" header in HTTP/1.1; see RFC 2616, Section 8.2.3.
+     * Unfortunately, there are software library bugs (e.g. Jetty 6 http server
+     * and Java 6 http client), which do not correctly implement "Expect:
+     * 100-continue". The two-step create/append is a temporary workaround for
+     * the software library bugs.
+     * 
+     * Open/Checksum
+     * Also implements two-step connects for other operations redirected to
+     * a DN such as open and checksum
+     */
+    private HttpURLConnection connect(URL url) throws IOException {
+      // resolve redirects for a DN operation unless already resolved
+      if (op.getRedirect() && !redirected) {
+        final HttpOpParam.Op redirectOp =
+            HttpOpParam.TemporaryRedirectOp.valueOf(op);
+        final HttpURLConnection conn = connect(redirectOp, url);
+        // application level proxy like httpfs might not issue a redirect
+        if (conn.getResponseCode() == op.getExpectedHttpResponseCode()) {
+          return conn;
+        }
+        try {
+          validateResponse(redirectOp, conn, false);
+          url = new URL(conn.getHeaderField("Location"));
+        } finally {
+          conn.disconnect();
+        }
+      }
+      return connect(op, url);
-    private void connect(boolean doOutput) throws IOException {
+    private HttpURLConnection connect(final HttpOpParam.Op op, final URL url)
+        throws IOException {
+      final HttpURLConnection conn =
+          (HttpURLConnection)connectionFactory.openConnection(url);
+      final boolean doOutput = op.getDoOutput();
+          } else {
+            conn.setRequestProperty("Content-Type",
+                MediaType.APPLICATION_OCTET_STREAM);
+            conn.setChunkedStreamingMode(32 << 10); //32kB-chunk
+      return conn;
-    private void disconnect() {
-      if (conn != null) {
-        conn.disconnect();
-        conn = null;
-      }
-    }
-
-    private AbstractRunner runWithRetry() throws IOException {
+    private T runWithRetry() throws IOException {
+        checkRetry = !redirected;
+        final URL url = getUrl();
-          init();
-          if (op.getDoOutput()) {
-            twoStepWrite();
-          } else {
-            getResponse(op != GetOpParam.Op.OPEN);
+          final HttpURLConnection conn = connect(url);
+          // output streams will validate on close
+          if (!op.getDoOutput()) {
+            validateResponse(op, conn, false);
-          return this;
-        } catch(IOException ioe) {
+          return getResponse(conn);
+        } catch (IOException ioe) {
-    /**
-     * Two-step Create/Append:
-     * Step 1) Submit a Http request with neither auto-redirect nor data. 
-     * Step 2) Submit another Http request with the URL from the Location header with data.
-     * 
-     * The reason of having two-step create/append is for preventing clients to
-     * send out the data before the redirect. This issue is addressed by the
-     * "Expect: 100-continue" header in HTTP/1.1; see RFC 2616, Section 8.2.3.
-     * Unfortunately, there are software library bugs (e.g. Jetty 6 http server
-     * and Java 6 http client), which do not correctly implement "Expect:
-     * 100-continue". The two-step create/append is a temporary workaround for
-     * the software library bugs.
-     */
-    HttpURLConnection twoStepWrite() throws IOException {
-      //Step 1) Submit a Http request with neither auto-redirect nor data. 
-      connect(false);
-      validateResponse(HttpOpParam.TemporaryRedirectOp.valueOf(op), conn, false);
-      final String redirect = conn.getHeaderField("Location");
-      disconnect();
-      checkRetry = false;
-      
-      //Step 2) Submit another Http request with the URL from the Location header with data.
-      conn = (HttpURLConnection) connectionFactory.openConnection(new URL(
-          redirect));
-      conn.setRequestProperty("Content-Type",
-          MediaType.APPLICATION_OCTET_STREAM);
-      conn.setChunkedStreamingMode(32 << 10); //32kB-chunk
-      connect();
-      return conn;
-    }
-
-    FSDataOutputStream write(final int bufferSize) throws IOException {
-      return WebHdfsFileSystem.this.write(op, conn, bufferSize);
-    }
-
-    void getResponse(boolean getJsonAndDisconnect) throws IOException {
-      try {
-        connect();
-        final int code = conn.getResponseCode();
-        if (!redirected && op.getRedirect()
-            && code != op.getExpectedHttpResponseCode()) {
-          final String redirect = conn.getHeaderField("Location");
-          json = validateResponse(HttpOpParam.TemporaryRedirectOp.valueOf(op),
-              conn, false);
-          disconnect();
-  
-          checkRetry = false;
-          conn = (HttpURLConnection) connectionFactory.openConnection(new URL(
-              redirect));
-          connect();
-        }
-
-        json = validateResponse(op, conn, false);
-        if (json == null && getJsonAndDisconnect) {
-          json = jsonParse(conn, false);
-        }
-      } finally {
-        if (getJsonAndDisconnect) {
-          disconnect();
-        }
-      }
-    }
+    abstract T getResponse(HttpURLConnection conn) throws IOException;
-  final class FsPathRunner extends AbstractRunner {
+  /**
+   * Abstract base class to handle path-based operations with params
+   */
+  abstract class AbstractFsPathRunner<T> extends AbstractRunner<T> {
-    private final Param<?, ?>[] parameters;
-
-    FsPathRunner(final HttpOpParam.Op op, final Path fspath, final Param<?,?>... parameters) {
+    private final Param<?,?>[] parameters;
+    
+    AbstractFsPathRunner(final HttpOpParam.Op op, final Path fspath,
+        Param<?,?>... parameters) {
-
+    
-  final class URLRunner extends AbstractRunner {
+  /**
+   * Default path-based implementation expects no json response
+   */
+  class FsPathRunner extends AbstractFsPathRunner<Void> {
+    FsPathRunner(Op op, Path fspath, Param<?,?>... parameters) {
+      super(op, fspath, parameters);
+    }
+    
+    @Override
+    Void getResponse(HttpURLConnection conn) throws IOException {
+      return null;
+    }
+  }
+
+  /**
+   * Handle path-based operations with a json response
+   */
+  abstract class FsPathResponseRunner<T> extends AbstractFsPathRunner<T> {
+    FsPathResponseRunner(final HttpOpParam.Op op, final Path fspath,
+        Param<?,?>... parameters) {
+      super(op, fspath, parameters);
+    }
+    
+    @Override
+    final T getResponse(HttpURLConnection conn) throws IOException {
+      try {
+        final Map<?,?> json = jsonParse(conn, false);
+        if (json == null) {
+          // match exception class thrown by parser
+          throw new IllegalStateException("Missing response");
+        }
+        return decodeResponse(json);
+      } catch (IOException ioe) {
+        throw ioe;
+      } catch (Exception e) { // catch json parser errors
+        final IOException ioe =
+            new IOException("Response decoding failure: "+e.toString(), e);
+        if (LOG.isDebugEnabled()) {
+          LOG.debug(ioe);
+        }
+        throw ioe;
+      } finally {
+        conn.disconnect();
+      }
+    }
+    
+    abstract T decodeResponse(Map<?,?> json) throws IOException;
+  }
+
+  /**
+   * Handle path-based operations with json boolean response
+   */
+  class FsPathBooleanRunner extends FsPathResponseRunner<Boolean> {
+    FsPathBooleanRunner(Op op, Path fspath, Param<?,?>... parameters) {
+      super(op, fspath, parameters);
+    }
+    
+    @Override
+    Boolean decodeResponse(Map<?,?> json) throws IOException {
+      return (Boolean)json.get("boolean");
+    }
+  }
+
+  /**
+   * Handle create/append output streams
+   */
+  class FsPathOutputStreamRunner extends AbstractFsPathRunner<FSDataOutputStream> {
+    private final int bufferSize;
+    
+    FsPathOutputStreamRunner(Op op, Path fspath, int bufferSize,
+        Param<?,?>... parameters) {
+      super(op, fspath, parameters);
+      this.bufferSize = bufferSize;
+    }
+    
+    @Override
+    FSDataOutputStream getResponse(final HttpURLConnection conn)
+        throws IOException {
+      return new FSDataOutputStream(new BufferedOutputStream(
+          conn.getOutputStream(), bufferSize), statistics) {
+        @Override
+        public void close() throws IOException {
+          try {
+            super.close();
+          } finally {
+            try {
+              validateResponse(op, conn, true);
+            } finally {
+              conn.disconnect();
+            }
+          }
+        }
+      };
+    }
+  }
+  
+  /**
+   * Used by open() which tracks the resolved url itself
+   */
+  final class URLRunner extends AbstractRunner<HttpURLConnection> {
+
+    @Override
+    HttpURLConnection getResponse(HttpURLConnection conn) throws IOException {
+      return conn;
+    }
-    final Map<?, ?> json = run(op, f);
-    final HdfsFileStatus status = JsonUtil.toFileStatus(json, true);
+    HdfsFileStatus status = new FsPathResponseRunner<HdfsFileStatus>(op, f) {
+      @Override
+      HdfsFileStatus decodeResponse(Map<?,?> json) {
+        return JsonUtil.toFileStatus(json, true);
+      }
+    }.run();
-    final Map<?, ?> json = run(op, f);
-    AclStatus status = JsonUtil.toAclStatus(json);
+    AclStatus status = new FsPathResponseRunner<AclStatus>(op, f) {
+      @Override
+      AclStatus decodeResponse(Map<?,?> json) {
+        return JsonUtil.toAclStatus(json);
+      }
+    }.run();
-    final Map<?, ?> json = run(op, f,
-        new PermissionParam(applyUMask(permission)));
-    return (Boolean)json.get("boolean");
+    return new FsPathBooleanRunner(op, f,
+        new PermissionParam(applyUMask(permission))
+    ).run();
-    run(op, f, new DestinationParam(makeQualified(destination).toUri().getPath()),
-        new CreateParentParam(createParent));
+    new FsPathRunner(op, f,
+        new DestinationParam(makeQualified(destination).toUri().getPath()),
+        new CreateParentParam(createParent)
+    ).run();
-    final Map<?, ?> json = run(op, src,
-        new DestinationParam(makeQualified(dst).toUri().getPath()));
-    return (Boolean)json.get("boolean");
+    return new FsPathBooleanRunner(op, src,
+        new DestinationParam(makeQualified(dst).toUri().getPath())
+    ).run();
-    run(op, src, new DestinationParam(makeQualified(dst).toUri().getPath()),
-        new RenameOptionSetParam(options));
+    new FsPathRunner(op, src,
+        new DestinationParam(makeQualified(dst).toUri().getPath()),
+        new RenameOptionSetParam(options)
+    ).run();
-    run(op, p, new OwnerParam(owner), new GroupParam(group));
+    new FsPathRunner(op, p,
+        new OwnerParam(owner), new GroupParam(group)
+    ).run();
-    run(op, p, new PermissionParam(permission));
+    new FsPathRunner(op, p,new PermissionParam(permission)).run();
-    run(op, path, new AclPermissionParam(aclSpec));
+    new FsPathRunner(op, path, new AclPermissionParam(aclSpec)).run();
-    run(op, path, new AclPermissionParam(aclSpec));
+    new FsPathRunner(op, path, new AclPermissionParam(aclSpec)).run();
-    run(op, path);
+    new FsPathRunner(op, path).run();
-    run(op, path);
+    new FsPathRunner(op, path).run();
-    run(op, p, new AclPermissionParam(aclSpec));
+    new FsPathRunner(op, p, new AclPermissionParam(aclSpec)).run();
-    final Map<?, ?> json = run(op, p, new ReplicationParam(replication));
-    return (Boolean)json.get("boolean");
+    return new FsPathBooleanRunner(op, p,
+        new ReplicationParam(replication)
+    ).run();
-    run(op, p, new ModificationTimeParam(mtime), new AccessTimeParam(atime));
+    new FsPathRunner(op, p,
+        new ModificationTimeParam(mtime),
+        new AccessTimeParam(atime)
+    ).run();
-  FSDataOutputStream write(final HttpOpParam.Op op,
-      final HttpURLConnection conn, final int bufferSize) throws IOException {
-    return new FSDataOutputStream(new BufferedOutputStream(
-        conn.getOutputStream(), bufferSize), statistics) {
-      @Override
-      public void close() throws IOException {
-        try {
-          super.close();
-        } finally {
-          try {
-            validateResponse(op, conn, true);
-          } finally {
-            conn.disconnect();
-          }
-        }
-      }
-    };
-  }
-
-
-    ConcatSourcesParam param = new ConcatSourcesParam(srcs);
-    run(op, trg, param);
+    new FsPathRunner(op, trg, new ConcatSourcesParam(srcs)).run();
-    return new FsPathRunner(op, f,
+    return new FsPathOutputStreamRunner(op, f, bufferSize,
-        new BlockSizeParam(blockSize))
-      .run()
-      .write(bufferSize);
+        new BlockSizeParam(blockSize)
+    ).run();
-    return new FsPathRunner(op, f, new BufferSizeParam(bufferSize))
-      .run()
-      .write(bufferSize);
+    return new FsPathOutputStreamRunner(op, f, bufferSize,
+        new BufferSizeParam(bufferSize)
+    ).run();
-    final Map<?, ?> json = run(op, f, new RecursiveParam(recursive));
-    return (Boolean)json.get("boolean");
+    return new FsPathBooleanRunner(op, f,
+        new RecursiveParam(recursive)
+    ).run();
-      return new URLRunner(GetOpParam.Op.OPEN, offsetUrl, resolved).run().conn;
+      return new URLRunner(GetOpParam.Op.OPEN, offsetUrl, resolved).run();
-    final Map<?, ?> json  = run(op, f);
-    final Map<?, ?> rootmap = (Map<?, ?>)json.get(FileStatus.class.getSimpleName() + "es");
-    final Object[] array = (Object[])rootmap.get(FileStatus.class.getSimpleName());
+    return new FsPathResponseRunner<FileStatus[]>(op, f) {
+      @Override
+      FileStatus[] decodeResponse(Map<?,?> json) {
+        final Map<?, ?> rootmap = (Map<?, ?>)json.get(FileStatus.class.getSimpleName() + "es");
+        final Object[] array = (Object[])rootmap.get(FileStatus.class.getSimpleName());
-    //convert FileStatus
-    final FileStatus[] statuses = new FileStatus[array.length];
-    for(int i = 0; i < array.length; i++) {
-      final Map<?, ?> m = (Map<?, ?>)array[i];
-      statuses[i] = makeQualified(JsonUtil.toFileStatus(m, false), f);
-    }
-    return statuses;
+        //convert FileStatus
+        final FileStatus[] statuses = new FileStatus[array.length];
+        for (int i = 0; i < array.length; i++) {
+          final Map<?, ?> m = (Map<?, ?>)array[i];
+          statuses[i] = makeQualified(JsonUtil.toFileStatus(m, false), f);
+        }
+        return statuses;
+      }
+    }.run();
-    final Map<?, ?> m = run(op, null, new RenewerParam(renewer));
-    final Token<DelegationTokenIdentifier> token = JsonUtil.toDelegationToken(m);
+    Token<DelegationTokenIdentifier> token =
+        new FsPathResponseRunner<Token<DelegationTokenIdentifier>>(
+            op, null, new RenewerParam(renewer)) {
+      @Override
+      Token<DelegationTokenIdentifier> decodeResponse(Map<?,?> json)
+          throws IOException {
+        return JsonUtil.toDelegationToken(json);
+      }
+    }.run();
-    TokenArgumentParam dtargParam = new TokenArgumentParam(
-        token.encodeToUrlString());
-    final Map<?, ?> m = run(op, null, dtargParam);
-    return (Long) m.get("long");
+    return new FsPathResponseRunner<Long>(op, null,
+        new TokenArgumentParam(token.encodeToUrlString())) {
+      @Override
+      Long decodeResponse(Map<?,?> json) throws IOException {
+        return (Long) json.get("long");
+      }
+    }.run();
-    TokenArgumentParam dtargParam = new TokenArgumentParam(
-        token.encodeToUrlString());
-    run(op, null, dtargParam);
+    new FsPathRunner(op, null,
+        new TokenArgumentParam(token.encodeToUrlString())
+    ).run();
-    final Map<?, ?> m = run(op, p, new OffsetParam(offset),
-        new LengthParam(length));
-    return DFSUtil.locatedBlocks2Locations(JsonUtil.toLocatedBlocks(m));
+    return new FsPathResponseRunner<BlockLocation[]>(op, p,
+        new OffsetParam(offset), new LengthParam(length)) {
+      @Override
+      BlockLocation[] decodeResponse(Map<?,?> json) throws IOException {
+        return DFSUtil.locatedBlocks2Locations(
+            JsonUtil.toLocatedBlocks(json));
+      }
+    }.run();
-    final Map<?, ?> m = run(op, p);
-    return JsonUtil.toContentSummary(m);
+    return new FsPathResponseRunner<ContentSummary>(op, p) {
+      @Override
+      ContentSummary decodeResponse(Map<?,?> json) {
+        return JsonUtil.toContentSummary(json);        
+      }
+    }.run();
-    final Map<?, ?> m = run(op, p);
-    return JsonUtil.toMD5MD5CRC32FileChecksum(m);
+    return new FsPathResponseRunner<MD5MD5CRC32FileChecksum>(op, p) {
+      @Override
+      MD5MD5CRC32FileChecksum decodeResponse(Map<?,?> json) throws IOException {
+        return JsonUtil.toMD5MD5CRC32FileChecksum(json);
+      }
+    }.run();

UPD40 UPD40 INS55 INS55 INS55 INS55 INS31 INS73 INS31 INS31 INS29 UPD83 UPD42 INS73 INS74 INS29 INS42 INS74 INS31 INS31 INS29 INS83 INS42 INS73 INS74 INS31 INS31 INS31 INS29 INS42 INS74 INS31 INS31 INS29 INS42 INS74 INS23 INS31 MOV31 INS29 INS74 INS31 INS78 INS5 INS8 MOV78 INS83 INS83 INS39 INS42 MOV44 MOV43 INS8 INS42 INS43 MOV29 INS83 MOV43 INS42 INS44 MOV43 INS8 INS43 MOV44 INS43 INS83 INS43 INS42 INS44 MOV43 INS65 INS42 MOV43 INS43 UPD42 MOV44 MOV65 INS43 INS43 INS42 INS44 INS44 INS44 INS8 INS78 INS43 INS42 INS44 MOV43 INS8 UPD65 MOV65 INS42 INS43 INS43 INS42 MOV44 MOV44 INS44 INS8 INS78 INS83 INS43 INS42 INS44 MOV43 INS8 INS83 INS43 INS42 INS44 INS43 INS65 INS43 INS43 INS42 INS44 INS44 MOV44 INS8 INS78 INS43 INS42 INS44 MOV43 INS8 INS65 INS43 MOV43 INS83 INS83 INS39 INS59 INS42 INS44 INS44 INS44 INS44 INS8 INS78 INS42 INS65 MOV43 INS43 INS78 INS43 INS42 INS44 MOV43 INS8 INS21 MOV21 INS41 INS42 INS43 INS85 MOV21 MOV60 INS41 INS60 MOV60 INS41 INS41 INS41 INS41 INS42 MOV43 INS42 INS25 INS41 INS42 INS83 INS43 INS42 INS60 INS60 MOV41 INS42 INS42 INS43 INS42 INS66 UPD42 MOV42 UPD66 INS42 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS46 INS42 INS42 MOV43 INS42 INS41 UPD66 INS42 INS42 INS74 INS42 INS46 INS42 INS42 MOV43 INS42 INS54 INS42 MOV74 INS42 INS42 INS66 INS42 INS42 INS43 INS42 INS43 INS42 INS46 INS42 INS42 MOV74 INS42 MOV41 INS66 INS42 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS74 INS42 INS46 INS21 INS42 INS66 UPD42 MOV42 INS42 INS42 INS43 INS42 INS41 INS43 INS43 INS59 MOV32 MOV32 INS32 MOV32 MOV32 MOV32 MOV32 INS42 INS32 INS74 INS59 INS32 INS32 INS32 INS32 INS66 UPD66 INS66 INS66 INS66 MOV27 MOV38 INS8 INS32 INS42 INS83 INS43 INS59 INS83 INS39 INS59 INS42 INS42 INS42 INS43 INS76 INS76 INS42 INS42 INS42 INS33 INS43 INS76 INS76 INS42 INS42 INS42 INS8 INS12 INS12 INS8 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD43 MOV43 MOV76 MOV76 INS42 INS42 INS42 INS7 INS42 INS42 INS42 UPD42 INS42 INS42 INS32 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 UPD42 INS14 INS42 MOV32 INS14 INS42 INS43 INS43 INS42 INS32 INS14 INS42 INS14 UPD42 INS14 INS42 INS14 INS42 INS14 INS42 MOV60 INS60 INS25 INS54 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS42 MOV11 INS42 MOV32 MOV21 MOV60 INS42 INS42 INS60 INS25 INS41 INS44 INS8 INS44 INS8 INS21 UPD42 INS22 INS42 INS14 INS42 INS14 MOV42 INS43 INS42 INS42 MOV14 MOV43 INS42 INS42 MOV14 MOV14 INS43 INS42 INS42 MOV14 INS43 INS42 INS42 MOV14 MOV14 INS43 INS42 INS42 MOV14 MOV14 INS43 INS42 INS42 MOV14 INS43 INS42 INS42 MOV14 INS43 INS42 INS42 MOV14 INS43 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS42 MOV14 INS43 INS42 INS42 MOV14 INS43 INS42 INS42 MOV14 MOV14 INS43 INS42 INS42 MOV14 UPD43 INS42 UPD43 INS42 INS43 INS42 INS42 MOV14 INS74 INS42 INS42 INS1 INS42 INS42 INS14 INS42 INS74 INS42 INS33 MOV14 INS1 INS43 INS42 INS33 MOV14 INS74 INS42 INS42 MOV14 MOV14 INS1 INS74 INS42 INS42 INS1 INS74 INS42 INS42 INS1 UPD43 INS83 MOV43 INS59 UPD27 MOV27 INS8 INS8 MOV8 INS8 INS83 INS83 MOV74 INS59 MOV27 INS8 INS32 INS43 INS42 INS53 INS43 INS42 INS60 INS25 INS53 INS32 INS52 INS42 INS74 INS42 INS42 INS1 INS74 INS42 INS42 INS1 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS43 INS5 INS31 INS74 INS42 INS33 MOV14 INS1 INS43 INS43 INS31 INS42 INS43 INS5 INS31 INS43 INS43 INS31 INS43 UPD43 MOV43 INS31 INS40 UPD42 MOV32 INS42 INS32 MOV32 MOV41 MOV21 MOV21 MOV21 MOV21 INS60 INS42 MOV32 INS53 INS42 INS42 INS42 INS42 INS42 INS83 INS43 INS59 INS32 INS8 INS42 INS42 INS42 INS43 INS43 INS31 INS43 INS43 INS31 INS42 INS43 INS85 MOV78 MOV5 INS42 INS44 MOV8 INS43 MOV74 INS31 INS42 INS42 INS78 INS43 INS42 INS44 INS43 INS8 INS42 INS43 INS85 INS78 INS5 INS42 INS44 INS43 INS8 INS42 INS42 INS78 INS43 INS42 INS44 INS8 INS42 UPD42 INS78 INS43 INS42 INS44 INS43 INS8 UPD74 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS83 INS43 INS59 INS38 INS32 INS14 INS42 INS42 INS14 INS42 INS42 INS21 INS42 INS42 INS78 MOV43 INS42 INS44 INS8 INS42 INS42 INS78 MOV43 INS42 INS44 INS8 INS42 MOV74 INS42 INS42 INS78 INS74 INS42 INS44 INS43 INS8 INS42 INS42 MOV74 INS42 INS42 MOV41 INS42 INS42 INS43 INS85 MOV74 INS42 INS42 MOV41 INS42 INS42 MOV74 INS42 MOV41 INS42 INS42 MOV74 INS42 INS42 MOV41 UPD43 MOV42 UPD42 MOV42 MOV42 MOV9 UPD42 INS14 INS42 INS42 INS32 MOV32 INS42 INS42 INS43 INS45 INS43 INS27 INS42 INS32 INS42 MOV74 INS42 INS41 INS42 MOV74 INS42 INS41 INS43 INS76 INS76 INS42 INS43 INS43 MOV74 INS42 INS42 INS41 INS42 INS43 UPD42 UPD43 MOV43 MOV32 UPD42 MOV42 INS42 MOV32 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS43 INS76 INS76 MOV32 MOV76 MOV32 INS42 INS42 INS42 MOV43 MOV76 MOV76 INS32 INS42 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 UPD42 MOV42 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL42 DEL42 DEL42 DEL14 DEL42 DEL32 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL42 DEL33 DEL59 DEL23 DEL83 DEL42 DEL43 DEL76 DEL76 DEL74 DEL42 DEL33 DEL59 DEL23 DEL42 DEL42 DEL42 DEL52 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL42 DEL32 DEL32 DEL7 DEL42 DEL42 DEL42 DEL14 DEL32 DEL11 DEL42 DEL33 DEL7 DEL21 DEL83 DEL39 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL39 DEL39 DEL42 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL25 DEL8 DEL31 DEL32 DEL21 DEL42 DEL32 DEL21 DEL8 DEL42 DEL40 DEL27 DEL52 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL14 DEL32 DEL11 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL83 DEL39 DEL42 DEL44 DEL8 DEL31 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL32 DEL21 DEL83 DEL39 DEL42 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL7 DEL21 DEL42 DEL27 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL43 DEL83 DEL66 DEL83 DEL42 DEL83 DEL39 DEL42 DEL44 DEL43 DEL83 DEL42 DEL42 DEL42 DEL83 DEL42 DEL59 DEL60 DEL83 DEL42 DEL42 DEL42 DEL32 DEL59 DEL42 DEL59 DEL60 DEL83 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL45 DEL32 DEL11 DEL42 DEL42 DEL42 DEL83 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL45 DEL32 DEL11 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL83 DEL42 DEL43 DEL76 DEL76 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL45 DEL32 DEL11 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL83 DEL42 DEL43 DEL76 DEL76 DEL74 DEL42 DEL59 DEL60 DEL42 DEL22 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL42 DEL42 DEL33 DEL32 DEL59 DEL60 DEL83 DEL42 DEL32 DEL59 DEL60 DEL83 DEL83 DEL39 DEL42 DEL43 DEL42 DEL59 DEL60 DEL83 DEL42 DEL42 DEL42 DEL33 DEL42 DEL32 DEL59 DEL60 DEL8 DEL31 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL33 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60
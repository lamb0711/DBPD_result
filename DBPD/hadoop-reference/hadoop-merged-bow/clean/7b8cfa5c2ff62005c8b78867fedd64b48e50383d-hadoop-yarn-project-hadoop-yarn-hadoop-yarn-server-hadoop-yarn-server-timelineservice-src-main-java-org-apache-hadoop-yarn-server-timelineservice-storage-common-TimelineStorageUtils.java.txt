YARN-5109. timestamps are stored unencoded causing parse errors (Varun Saxena via sjlee)

-import java.util.ArrayList;
-import org.apache.hadoop.yarn.api.records.ApplicationId;
-import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineKeyValueFilter;
+import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineKeyValueFilter;
-import org.apache.hadoop.yarn.util.ConverterUtils;
-  /** empty bytes. */
-  public static final byte[] EMPTY_BYTES = new byte[0];
-
-  /** indicator for no limits for splitting. */
-  public static final int NO_LIMIT_SPLIT = -1;
-
-   * Splits the source array into multiple array segments using the given
-   * separator, up to a maximum of count items. This will naturally produce
-   * copied byte arrays for each of the split segments. To identify the split
-   * ranges without the array copies, see {@link #splitRanges(byte[], byte[])}.
-   *
-   * @param source Source array.
-   * @param separator Separator represented as a byte array.
-   * @return byte[][] after splitting the source
-   */
-  public static byte[][] split(byte[] source, byte[] separator) {
-    return split(source, separator, NO_LIMIT_SPLIT);
-  }
-
-  /**
-   * Splits the source array into multiple array segments using the given
-   * separator, up to a maximum of count items. This will naturally produce
-   * copied byte arrays for each of the split segments. To identify the split
-   * ranges without the array copies, see {@link #splitRanges(byte[], byte[])}.
-   *
-   * @param source Source array.
-   * @param separator Separator represented as a byte array.
-   * @param limit a non-positive value indicates no limit on number of segments.
-   * @return byte[][] after splitting the input source.
-   */
-  public static byte[][] split(byte[] source, byte[] separator, int limit) {
-    List<Range> segments = splitRanges(source, separator, limit);
-
-    byte[][] splits = new byte[segments.size()][];
-    for (int i = 0; i < segments.size(); i++) {
-      Range r = segments.get(i);
-      byte[] tmp = new byte[r.length()];
-      if (tmp.length > 0) {
-        System.arraycopy(source, r.start(), tmp, 0, r.length());
-      }
-      splits[i] = tmp;
-    }
-    return splits;
-  }
-
-  /**
-   * Returns a list of ranges identifying [start, end) -- closed, open --
-   * positions within the source byte array that would be split using the
-   * separator byte array.
-   *
-   * @param source Source array.
-   * @param separator Separator represented as a byte array.
-   * @return a list of ranges.
-   */
-  public static List<Range> splitRanges(byte[] source, byte[] separator) {
-    return splitRanges(source, separator, NO_LIMIT_SPLIT);
-  }
-
-  /**
-   * Returns a list of ranges identifying [start, end) -- closed, open --
-   * positions within the source byte array that would be split using the
-   * separator byte array.
-   *
-   * @param source the source data
-   * @param separator the separator pattern to look for
-   * @param limit the maximum number of splits to identify in the source
-   * @return a list of ranges.
-   */
-  public static List<Range> splitRanges(byte[] source, byte[] separator,
-      int limit) {
-    List<Range> segments = new ArrayList<Range>();
-    if ((source == null) || (separator == null)) {
-      return segments;
-    }
-    int start = 0;
-    itersource: for (int i = 0; i < source.length; i++) {
-      for (int j = 0; j < separator.length; j++) {
-        if (source[i + j] != separator[j]) {
-          continue itersource;
-        }
-      }
-      // all separator elements matched
-      if (limit > 0 && segments.size() >= (limit - 1)) {
-        // everything else goes in one final segment
-        break;
-      }
-      segments.add(new Range(start, i));
-      start = i + separator.length;
-      // i will be incremented again in outer for loop
-      i += separator.length - 1;
-    }
-    // add in remaining to a final range
-    if (start <= source.length) {
-      segments.add(new Range(start, source.length));
-    }
-    return segments;
-  }
-
-  /**
-
-  /**
-   * Converts/encodes a string app Id into a byte representation for (row) keys.
-   * For conversion, we extract cluster timestamp and sequence id from the
-   * string app id (calls {@link ConverterUtils#toApplicationId(String)} for
-   * conversion) and then store it in a byte array of length 12 (8 bytes (long)
-   * for cluster timestamp followed 4 bytes(int) for sequence id). Both cluster
-   * timestamp and sequence id are inverted so that the most recent cluster
-   * timestamp and highest sequence id appears first in the table (i.e.
-   * application id appears in a descending order).
-   *
-   * @param appIdStr application id in string format i.e.
-   * application_{cluster timestamp}_{sequence id with min 4 digits}
-   *
-   * @return encoded byte representation of app id.
-   */
-  public static byte[] encodeAppId(String appIdStr) {
-    ApplicationId appId = ConverterUtils.toApplicationId(appIdStr);
-    byte[] appIdBytes = new byte[Bytes.SIZEOF_LONG + Bytes.SIZEOF_INT];
-    byte[] clusterTs = Bytes.toBytes(invertLong(appId.getClusterTimestamp()));
-    System.arraycopy(clusterTs, 0, appIdBytes, 0, Bytes.SIZEOF_LONG);
-    byte[] seqId = Bytes.toBytes(invertInt(appId.getId()));
-    System.arraycopy(seqId, 0, appIdBytes, Bytes.SIZEOF_LONG, Bytes.SIZEOF_INT);
-    return appIdBytes;
-  }
-
-  /**
-   * Converts/decodes a 12 byte representation of app id for (row) keys to an
-   * app id in string format which can be returned back to client.
-   * For decoding, 12 bytes are interpreted as 8 bytes of inverted cluster
-   * timestamp(long) followed by 4 bytes of inverted sequence id(int). Calls
-   * {@link ApplicationId#toString} to generate string representation of app id.
-   *
-   * @param appIdBytes application id in byte representation.
-   *
-   * @return decoded app id in string format.
-   */
-  public static String decodeAppId(byte[] appIdBytes) {
-    if (appIdBytes.length != (Bytes.SIZEOF_LONG + Bytes.SIZEOF_INT)) {
-      throw new IllegalArgumentException("Invalid app id in byte format");
-    }
-    long clusterTs = invertLong(Bytes.toLong(appIdBytes, 0, Bytes.SIZEOF_LONG));
-    int seqId =
-        invertInt(Bytes.toInt(appIdBytes, Bytes.SIZEOF_LONG, Bytes.SIZEOF_INT));
-    return ApplicationId.newInstance(clusterTs, seqId).toString();
-  }
-
-    Map<String, Object> columns = prefix.readResults(result);
+    Map<String, Object> columns =
+        prefix.readResults(result, StringKeyConverter.getInstance());
-    Map<String, Object> columns = prefix.readResults(result);
+    Map<String, Object> columns =
+        prefix.readResults(result, StringKeyConverter.getInstance());
-    Map<?, Object> eventsResult =
-        prefix.readResultsHavingCompoundColumnQualifiers(result);
-    for (Map.Entry<?, Object> eventResult : eventsResult.entrySet()) {
-      byte[][] karr = (byte[][])eventResult.getKey();
-      // the column name is of the form "eventId=timestamp=infoKey"
-      if (karr.length == 3) {
-        String id = Bytes.toString(karr[0]);
-        long ts = TimelineStorageUtils.invertLong(Bytes.toLong(karr[1]));
-        String key = Separator.VALUES.joinEncoded(id, Long.toString(ts));
-        TimelineEvent event = eventsMap.get(key);
-        if (event == null) {
-          event = new TimelineEvent();
-          event.setId(id);
-          event.setTimestamp(ts);
-          eventsMap.put(key, event);
-        }
-        // handle empty info
-        String infoKey = karr[2].length == 0 ? null : Bytes.toString(karr[2]);
-        if (infoKey != null) {
-          event.addInfo(infoKey, eventResult.getValue());
-        }
-      } else {
-        LOG.warn("incorrectly formatted column name: it will be discarded");
-        continue;
+    Map<EventColumnName, Object> eventsResult =
+        prefix.readResults(result, EventColumnNameConverter.getInstance());
+    for (Map.Entry<EventColumnName, Object>
+             eventResult : eventsResult.entrySet()) {
+      EventColumnName eventColumnName = eventResult.getKey();
+      String key = eventColumnName.getId() +
+          Long.toString(eventColumnName.getTimestamp());
+      // Retrieve previously seen event to add to it
+      TimelineEvent event = eventsMap.get(key);
+      if (event == null) {
+        // First time we're seeing this event, add it to the eventsMap
+        event = new TimelineEvent();
+        event.setId(eventColumnName.getId());
+        event.setTimestamp(eventColumnName.getTimestamp());
+        eventsMap.put(key, event);
+      }
+      if (eventColumnName.getInfoKey() != null) {
+        event.addInfo(eventColumnName.getInfoKey(), eventResult.getValue());

MOV26 INS60 MOV60 MOV74 INS59 UPD74 INS8 INS42 INS32 INS43 UPD74 MOV60 MOV60 MOV60 MOV25 MOV25 INS42 INS42 INS42 INS32 INS32 INS42 UPD42 INS32 INS43 INS43 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV32 INS27 INS32 INS32 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 INS32 INS32 INS32 INS32 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL34 DEL3 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL66 DEL66 DEL66 DEL66 DEL42 DEL39 DEL85 DEL5 DEL69 DEL39 DEL85 DEL5 DEL69 DEL68 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL85 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL42 DEL39 DEL85 DEL5 DEL69 DEL39 DEL85 DEL5 DEL69 DEL68 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL85 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL85 DEL85 DEL5 DEL42 DEL39 DEL85 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL59 DEL60 DEL40 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL34 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL2 DEL42 DEL7 DEL21 DEL8 DEL24 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL33 DEL27 DEL36 DEL42 DEL33 DEL27 DEL36 DEL27 DEL42 DEL41 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL27 DEL2 DEL42 DEL42 DEL2 DEL27 DEL42 DEL18 DEL8 DEL25 DEL8 DEL24 DEL42 DEL34 DEL27 DEL42 DEL42 DEL32 DEL42 DEL34 DEL27 DEL36 DEL27 DEL27 DEL10 DEL8 DEL25 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL32 DEL21 DEL42 DEL42 DEL40 DEL27 DEL7 DEL21 DEL42 DEL40 DEL34 DEL27 DEL7 DEL21 DEL8 DEL24 DEL30 DEL42 DEL40 DEL27 DEL42 DEL42 DEL42 DEL43 DEL42 DEL40 DEL14 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL40 DEL40 DEL27 DEL3 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL34 DEL42 DEL34 DEL40 DEL32 DEL21 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL34 DEL42 DEL40 DEL40 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL40 DEL40 DEL40 DEL27 DEL36 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL40 DEL32 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL40 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL76 DEL76 DEL39 DEL85 DEL85 DEL5 DEL39 DEL85 DEL85 DEL5 DEL11 DEL42 DEL43 DEL40 DEL32 DEL32 DEL42 DEL40 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL34 DEL2 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL2 DEL32 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL34 DEL2 DEL42 DEL22 DEL34 DEL27 DEL33 DEL42 DEL42 DEL42 DEL34 DEL2 DEL32 DEL16 DEL59 DEL60 DEL8 DEL42 DEL42 DEL45 DEL32 DEL21 DEL18 DEL8 DEL25 DEL8
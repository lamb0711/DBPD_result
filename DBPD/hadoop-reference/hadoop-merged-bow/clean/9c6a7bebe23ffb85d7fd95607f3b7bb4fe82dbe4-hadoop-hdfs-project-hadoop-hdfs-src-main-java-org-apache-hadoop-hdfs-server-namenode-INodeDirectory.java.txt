HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68

-  INodeReference.WithCount replaceChild4Reference(INode oldChild) {
-    Preconditions.checkArgument(!oldChild.isReference());
-    final INodeReference.WithCount withCount
-        = new INodeReference.WithCount(null, oldChild);
-    final INodeReference ref = new INodeReference(this, withCount);
-    withCount.setParentReference(ref);
-    replaceChild(oldChild, ref);
-    return withCount;
-  }
-
-      withCount = (INodeReference.WithCount) oldChild.asReference().getReferredINode();
+      withCount = (INodeReference.WithCount) oldChild.asReference()
+          .getReferredINode();
-    final INodeReference.WithName ref = new INodeReference.WithName(
-        this, withCount, oldChild.getLocalNameBytes());
+    final INodeReference.WithName ref = new INodeReference.WithName(this,
+        withCount, oldChild.getLocalNameBytes());
+      final boolean isRef = curNode.isReference();
-      if (isDir && dir instanceof INodeDirectoryWithSnapshot) {
+      if (!isRef && isDir && dir instanceof INodeDirectoryWithSnapshot) {
+      } else if (isRef && isDir && !lastComp) {
+        // If the curNode is a reference node, need to check its dstSnapshot:
+        // 1. if the existing snapshot is no later than the dstSnapshot (which
+        // is the latest snapshot in dst before the rename), the changes 
+        // should be recorded in previous snapshots (belonging to src).
+        // 2. however, if the ref node is already the last component, we still 
+        // need to know the latest snapshot among the ref node's ancestors, 
+        // in case of processing a deletion operation. Thus we do not overwrite
+        // the latest snapshot if lastComp is true. In case of the operation is
+        // a modification operation, we do a similar check in corresponding 
+        // recordModification method.
+        if (!existing.isSnapshot()) {
+          int dstSnapshotId = curNode.asReference().getDstSnapshotId();
+          Snapshot latest = existing.getLatestSnapshot();
+          if (latest == null ||  // no snapshot in dst tree of rename
+              dstSnapshotId >= latest.getId()) { // the above scenario 
+            Snapshot lastSnapshot = null;
+            if (curNode.isDirectory()
+                && curNode.asDirectory() instanceof INodeDirectoryWithSnapshot) {
+              lastSnapshot = ((INodeDirectoryWithSnapshot) curNode
+                  .asDirectory()).getLastSnapshot();
+            } else if (curNode.isFile()
+                && curNode.asFile() instanceof INodeFileWithSnapshot) {
+              lastSnapshot = ((INodeFileWithSnapshot) curNode
+                  .asFile()).getDiffs().getLastSnapshot();
+            }
+            existing.setSnapshot(lastSnapshot);
+          }
+        }

INS60 INS25 INS83 INS39 INS59 MOV27 MOV8 INS25 INS42 INS32 INS38 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS38 INS25 INS42 INS38 INS8 INS32 INS60 INS60 INS25 INS42 INS42 INS39 INS59 INS43 INS59 INS27 INS8 INS42 INS32 INS42 INS42 INS32 INS27 INS27 INS60 INS25 INS21 INS32 INS42 INS42 INS42 INS42 INS33 INS42 INS32 INS43 INS59 INS27 INS8 INS25 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS32 INS62 INS21 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS7 INS32 INS62 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS7 INS36 INS42 INS42 INS42 INS42 INS42 INS32 INS11 INS32 INS42 INS43 INS32 INS36 INS42 INS42 INS42 INS42 INS11 INS43 INS32 INS42 INS42 INS42 DEL40 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL32 DEL21 DEL83 DEL40 DEL43 DEL42 DEL40 DEL43 DEL33 DEL42 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL52 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL25
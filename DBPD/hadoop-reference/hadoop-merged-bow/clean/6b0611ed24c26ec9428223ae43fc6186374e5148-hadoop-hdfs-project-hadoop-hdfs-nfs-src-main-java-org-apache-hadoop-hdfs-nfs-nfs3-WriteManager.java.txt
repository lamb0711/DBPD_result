Merging r1539737 through r1539896 from trunk to branch HDFS-2832

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1539898 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-import java.util.Map.Entry;
+import org.apache.hadoop.hdfs.protocol.AlreadyBeingCreatedException;
+import org.apache.hadoop.ipc.RemoteException;
-import org.apache.hadoop.nfs.nfs3.Nfs3Constant.WriteStableHow;
+import com.google.common.annotations.VisibleForTesting;
-  private final ConcurrentMap<FileHandle, OpenFileCtx> openFileMap = Maps
-      .newConcurrentMap();
-
+ 
-  private final StreamMonitor streamMonitor;
-  
+  private final int maxStreams;
+
-  
-  public static final long DEFAULT_STREAM_TIMEOUT = 10 * 60 * 1000; //10 minutes
-  public static final long MINIMIUM_STREAM_TIMEOUT = 10 * 1000; //10 seconds
-  
-  void addOpenFileStream(FileHandle h, OpenFileCtx ctx) {
-    openFileMap.put(h, ctx);
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("After add the new stream " + h.getFileId()
-          + ", the stream number:" + openFileMap.size());
+
+  private final OpenFileCtxCache fileContextCache;
+
+  static public class MultipleCachedStreamException extends IOException {
+    private static final long serialVersionUID = 1L;
+
+    public MultipleCachedStreamException(String msg) {
+      super(msg);
+  boolean addOpenFileStream(FileHandle h, OpenFileCtx ctx) {
+    return fileContextCache.put(h, ctx);
+  }
+  
-    
-    streamTimeout = config.getLong("dfs.nfs3.stream.timeout",
-        DEFAULT_STREAM_TIMEOUT);
+    streamTimeout = config.getLong(Nfs3Constant.OUTPUT_STREAM_TIMEOUT,
+        Nfs3Constant.OUTPUT_STREAM_TIMEOUT_DEFAULT);
-    if (streamTimeout < MINIMIUM_STREAM_TIMEOUT) {
+    if (streamTimeout < Nfs3Constant.OUTPUT_STREAM_TIMEOUT_MIN_DEFAULT) {
-          + MINIMIUM_STREAM_TIMEOUT + "ms.");
-      streamTimeout = MINIMIUM_STREAM_TIMEOUT;
+          + Nfs3Constant.OUTPUT_STREAM_TIMEOUT_MIN_DEFAULT + "ms.");
+      streamTimeout = Nfs3Constant.OUTPUT_STREAM_TIMEOUT_MIN_DEFAULT;
-    
-    this.streamMonitor = new StreamMonitor();
+    maxStreams = config.getInt(Nfs3Constant.MAX_OPEN_FILES,
+        Nfs3Constant.MAX_OPEN_FILES_DEFAULT);
+    LOG.info("Maximum open streams is "+ maxStreams);
+    this.fileContextCache = new OpenFileCtxCache(config, streamTimeout);
-  private void startAsyncDataSerivce() {
-    streamMonitor.start();
+  void startAsyncDataSerivce() {
+    if (asyncDataServiceStarted) {
+      return;
+    }
+    fileContextCache.start();
-  private void shutdownAsyncDataService() {
-    asyncDataService.shutdown();
+  void shutdownAsyncDataService() {
+    if (!asyncDataServiceStarted) {
+      return;
+    }
-    streamMonitor.interrupt();
+    asyncDataService.shutdown();
+    fileContextCache.shutdown();
-    // First write request starts the async data service
-    if (!asyncDataServiceStarted) {
-      startAsyncDataSerivce();
-    }
-
-    long offset = request.getOffset();
-    WriteStableHow stableHow = request.getStableHow();
-      LOG.debug("handleWrite fileId: " + handle.getFileId() + " offset: "
-          + offset + " length:" + count + " stableHow:" + stableHow.getValue());
+      LOG.debug("handleWrite " + request);
-    OpenFileCtx openFileCtx = openFileMap.get(fileHandle);
+    OpenFileCtx openFileCtx = fileContextCache.get(fileHandle);
+      } catch (RemoteException e) {
+        IOException io = e.unwrapRemoteException();
+        if (io instanceof AlreadyBeingCreatedException) {
+          LOG.warn("Can't append file:" + fileIdPath
+              + ". Possibly the file is being closed. Drop the request:"
+              + request + ", wait for the client to retry...");
+          return;
+        }
+        throw e;
-      addOpenFileStream(fileHandle, openFileCtx);
+
+      if (!addOpenFileStream(fileHandle, openFileCtx)) {
+        LOG.info("Can't add new stream. Close it. Tell client to retry.");
+        try {
+          fos.close();
+        } catch (IOException e) {
+          LOG.error("Can't close stream for fileId:" + handle.getFileId());
+        }
+        // Notify client to retry
+        WccData fileWcc = new WccData(latestAttr.getWccAttr(), latestAttr);
+        WRITE3Response response = new WRITE3Response(Nfs3Status.NFS3ERR_JUKEBOX,
+            fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);
+        Nfs3Utils.writeChannel(channel,
+            response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),
+            xid);
+        return;
+      }
+
-        LOG.debug("opened stream for file:" + fileHandle.getFileId());
+        LOG.debug("Opened stream for appending file:" + fileHandle.getFileId());
-    OpenFileCtx openFileCtx = openFileMap.get(fileHandle);
+    OpenFileCtx openFileCtx = fileContextCache.get(fileHandle);
-      OpenFileCtx openFileCtx = openFileMap.get(fileHandle);
+      OpenFileCtx openFileCtx = fileContextCache.get(fileHandle);
-      OpenFileCtx openFileCtx = openFileMap
-          .get(new FileHandle(attr.getFileId()));
+      OpenFileCtx openFileCtx = fileContextCache.get(new FileHandle(attr
+          .getFileId()));
-  
-  /**
-   * StreamMonitor wakes up periodically to find and closes idle streams.
-   */
-  class StreamMonitor extends Daemon {
-    private int rotation = 5 * 1000; // 5 seconds
-    private long lastWakeupTime = 0;
-    @Override
-    public void run() {
-      while (true) {
-        Iterator<Entry<FileHandle, OpenFileCtx>> it = openFileMap.entrySet()
-            .iterator();
-        if (LOG.isTraceEnabled()) {
-          LOG.trace("openFileMap size:" + openFileMap.size());
-        }
-        while (it.hasNext()) {
-          Entry<FileHandle, OpenFileCtx> pairs = it.next();
-          OpenFileCtx ctx = pairs.getValue();
-          if (ctx.streamCleanup((pairs.getKey()).getFileId(), streamTimeout)) {
-            it.remove();
-            if (LOG.isDebugEnabled()) {
-              LOG.debug("After remove stream " + pairs.getKey().getFileId()
-                  + ", the stream number:" + openFileMap.size());
-            }
-          }
-        }
-
-        // Check if it can sleep
-        try {
-          long workedTime = System.currentTimeMillis() - lastWakeupTime;
-          if (workedTime < rotation) {
-            if (LOG.isTraceEnabled()) {
-              LOG.trace("StreamMonitor can still have a sleep:"
-                  + ((rotation - workedTime) / 1000));
-            }
-            Thread.sleep(rotation - workedTime);
-          }
-          lastWakeupTime = System.currentTimeMillis();
-
-        } catch (InterruptedException e) {
-          LOG.info("StreamMonitor got interrupted");
-          return;
-        }
-      }
-    }
+  @VisibleForTesting
+  OpenFileCtxCache getOpenFileCtxCache() {
+    return this.fileContextCache;

MOV26 MOV26 MOV26 MOV23 MOV23 UPD40 UPD40 UPD40 INS55 INS31 INS31 INS39 UPD43 INS83 INS83 INS42 INS43 MOV23 INS31 UPD39 MOV42 MOV44 MOV44 INS8 MOV21 INS78 INS43 INS42 INS8 INS42 UPD42 UPD42 INS42 UPD83 INS83 INS42 INS44 INS8 INS41 MOV21 MOV21 MOV21 MOV21 MOV25 MOV21 MOV21 INS21 INS25 INS25 INS42 UPD42 MOV42 INS41 UPD42 INS34 INS43 INS42 INS46 INS32 INS7 INS42 INS8 MOV38 INS8 INS22 INS42 INS42 UPD42 MOV42 MOV42 MOV42 MOV42 INS40 INS42 INS32 UPD42 INS22 INS14 INS41 UPD42 INS41 UPD42 UPD42 INS25 INS52 INS42 INS40 INS40 INS42 INS42 INS40 INS40 UPD45 INS42 INS52 INS42 INS43 INS42 INS42 UPD42 INS12 INS38 INS8 UPD42 INS40 UPD42 MOV42 INS44 INS8 MOV32 INS21 INS54 INS60 INS60 INS21 INS41 INS40 UPD45 UPD42 INS43 INS42 INS60 INS25 INS53 INS32 INS8 INS12 INS43 INS59 INS43 INS59 INS32 UPD42 UPD42 INS42 INS43 INS59 INS62 INS8 INS42 INS42 INS42 INS45 MOV21 INS44 INS8 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS43 INS21 INS41 INS32 INS43 INS42 INS21 INS43 INS32 INS42 INS43 INS40 INS42 INS34 MOV32 INS40 INS42 INS42 INS14 INS42 INS14 UPD45 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS45 MOV32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL34 DEL34 DEL27 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL34 DEL34 DEL27 DEL59 DEL23 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL45 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL43 DEL14 DEL42 DEL42 DEL32 DEL8 DEL31 DEL83 DEL83 DEL42 DEL32 DEL21 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL45 DEL42 DEL45 DEL45 DEL42 DEL42 DEL32 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL83 DEL39 DEL42 DEL34 DEL34 DEL27 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL42 DEL78 DEL83 DEL39 DEL42 DEL9 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL36 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL61 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL27 DEL36 DEL34 DEL27 DEL36 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL32 DEL21 DEL41 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL31 DEL55
YARN-6610. [YARN-3926] DominantResourceCalculator#getResourceAsValue dominant param is updated to handle multiple resources. Contributed by Daniel Templeton.

+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.yarn.exceptions.YarnRuntimeException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.Arrays;
+  static final Log LOG = LogFactory.getLog(DominantResourceCalculator.class);
-    
-    float l = getResourceAsValue(clusterResource, lhs, true);
-    float r = getResourceAsValue(clusterResource, rhs, true);
+    // We have to calculate the shares for all resource types for both
+    // resources and then look for which resource has the biggest
+    // share overall.
+    ResourceInformation[] clusterRes = clusterResource.getResources();
+    // If array creation shows up as a time sink, these arrays could be cached
+    // because they're always the same length.
+    double[] lhsShares = new double[clusterRes.length];
+    double[] rhsShares = new double[clusterRes.length];
+    double diff;
-    if (l < r) {
-      return -1;
-    } else if (l > r) {
-      return 1;
-    } else if (!singleType) {
-      l = getResourceAsValue(clusterResource, lhs, false);
-      r = getResourceAsValue(clusterResource, rhs, false);
+    try {
+      if (singleType) {
+        double[] max = new double[2];
-      if (l < r) {
-        return -1;
-      } else if (l > r) {
-        return 1;
+        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);
+
+        diff = max[0] - max[1];
+      } else if (clusterRes.length == 2) {
+        // Special case to handle the common scenario of only CPU and memory
+        // so the we can optimize for performance
+        diff = calculateSharesForMandatoryResources(clusterRes, lhs, rhs,
+            lhsShares, rhsShares);
+      } else {
+        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);
+
+        Arrays.sort(lhsShares);
+        Arrays.sort(rhsShares);
+
+        diff = compareShares(lhsShares, rhsShares);
+    } catch (ArrayIndexOutOfBoundsException ex) {
+      StringWriter out = new StringWriter(); // No need to close a StringWriter
+      ex.printStackTrace(new PrintWriter(out));
+
+      LOG.error("A problem was encountered while calculating resource "
+          + "availability that should not occur under normal circumstances. "
+          + "Please report this error to the Hadoop community by opening a "
+          + "JIRA ticket at http://issues.apache.org/jira and including the "
+          + "following information:\n* Exception encountered: " + out + "* "
+          + "Cluster resources: " + Arrays.toString(clusterRes) + "\n* "
+          + "LHS resource: " + Arrays.toString(lhs.getResources()) + "\n* "
+          + "RHS resource: " + Arrays.toString(rhs.getResources()));
+      LOG.error("The resource manager is in an inconsistent state. It is safe "
+          + "for the resource manager to be restarted as the error encountered "
+          + "should be transitive. If high availability is enabled, failing "
+          + "over to a standby resource manager is also safe.");
+      throw new YarnRuntimeException("A problem was encountered while "
+          + "calculating resource availability that should not occur under "
+          + "normal circumstances. Please see the log for more information.",
+          ex);
-    return 0;
+    return (int) Math.signum(diff);
-   * Use 'dominant' for now since we only have 2 resources - gives us a slight
-   * performance boost.
-   * <p></p>
-   * Once we add more resources, we'll need a more complicated (and slightly
-   * less performant algorithm).
+   * Calculate the shares for {@code first} and {@code second} according to
+   * {@code clusterRes}, and store the results in {@code firstShares} and
+   * {@code secondShares}, respectively. All parameters must be non-null.
+   * @param clusterRes the array of ResourceInformation instances that
+   * represents the cluster's maximum resources
+   * @param first the first resource to compare
+   * @param second the second resource to compare
+   * @param firstShares an array to store the shares for the first resource
+   * @param secondShares an array to store the shares for the second resource
+   * @return -1.0, 0.0, or 1.0, depending on whether the max share of the first
+   * resource is less than, equal to, or greater than the max share of the
+   * second resource, respectively
+   * @throws NullPointerException if any parameter is null
-  protected float getResourceAsValue(Resource clusterResource,
-      Resource resource, boolean dominant) {
+  private void calculateShares(ResourceInformation[] clusterRes, Resource first,
+      Resource second, double[] firstShares, double[] secondShares) {
+    ResourceInformation[] firstRes = first.getResources();
+    ResourceInformation[] secondRes = second.getResources();
-    float min = Float.MAX_VALUE;
-    float max = 0.0f;
-    int maxLength = ResourceUtils.getResourceTypesArray().length;
-    for (int i = 0; i < maxLength; i++) {
-      ResourceInformation clusterResourceResourceInformation = clusterResource
-          .getResourceInformation(i);
-      ResourceInformation resourceInformation = resource
-          .getResourceInformation(i);
-      long resourceValue = UnitsConversionUtil.convert(
-          resourceInformation.getUnits(),
-          clusterResourceResourceInformation.getUnits(),
-          resourceInformation.getValue());
-      float tmp = (float) resourceValue
-          / (float) clusterResourceResourceInformation.getValue();
-      min = min < tmp ? min : tmp;
-      max = max > tmp ? max : tmp;
+    for (int i = 0; i < clusterRes.length; i++) {
+      firstShares[i] = calculateShare(clusterRes[i], firstRes[i]);
+      secondShares[i] = calculateShare(clusterRes[i], secondRes[i]);
-    return (dominant) ? max : min;
+  }
+
+  /**
+   * Calculate the shares for {@code first} and {@code second} according to
+   * {@code clusterRes}, and store the results in {@code firstShares} and
+   * {@code secondShares}, respectively. All parameters must be non-null.
+   * This method assumes that the length of {@code clusterRes} is exactly 2 and
+   * makes performance optimizations based on that assumption.
+   * @param clusterRes the array of ResourceInformation instances that
+   * represents the cluster's maximum resources
+   * @param first the first resource to compare
+   * @param second the second resource to compare
+   * @param firstShares an array to store the shares for the first resource
+   * @param secondShares an array to store the shares for the second resource
+   * @return -1.0, 0.0, or 1.0, depending on whether the max share of the first
+   * resource is less than, equal to, or greater than the max share of the
+   * second resource, respectively
+   * @throws NullPointerException if any parameter is null
+   */
+  private int calculateSharesForMandatoryResources(
+      ResourceInformation[] clusterRes, Resource first, Resource second,
+      double[] firstShares, double[] secondShares) {
+    ResourceInformation[] firstRes = first.getResources();
+    ResourceInformation[] secondRes = second.getResources();
+    int firstDom = 0;
+    int secondDom = 0;
+    int firstSub = 0;
+    int secondSub = 0;
+
+    for (int i = 0; i < clusterRes.length; i++) {
+      firstShares[i] = calculateShare(clusterRes[i], firstRes[i]);
+      secondShares[i] = calculateShare(clusterRes[i], secondRes[i]);
+
+      if (firstShares[i] > firstShares[firstDom]) {
+        firstDom = i;
+      }
+
+      if (firstShares[i] < firstShares[firstSub]) {
+        firstSub = i;
+      }
+
+      if (secondShares[i] > secondShares[secondDom]) {
+        secondDom = i;
+      }
+
+      if (secondShares[i] < secondShares[secondSub]) {
+        secondSub = i;
+      }
+    }
+
+    if (firstShares[firstDom] > secondShares[secondDom]) {
+      return 1;
+    } else if (firstShares[firstDom] < secondShares[secondDom]) {
+      return -1;
+    } else if (firstShares[firstSub] > secondShares[secondSub]) {
+      return 1;
+    } else if (firstShares[firstSub] < secondShares[secondSub]) {
+      return -1;
+    } else {
+      return 0;
+    }
+  }
+
+  /**
+   * Calculate the shares for {@code first} and {@code second} according to
+   * {@code clusterRes}, and store the results in {@code firstShares} and
+   * {@code secondShares}, respectively. {@code max} will be populated with
+   * the max shares from {@code firstShare} and {@code secondShare} in the
+   * first and second indices, respectively. All parameters must be non-null,
+   * and {@code max} must have a length of at least 2.
+   * @param clusterRes the array of ResourceInformation instances that
+   * represents the cluster's maximum resources
+   * @param first the first resource to compare
+   * @param second the second resource to compare
+   * @param firstShares an array to store the shares for the first resource
+   * @param secondShares an array to store the shares for the second resource
+   * @param max an array to store the max shares of the first and second
+   * resources
+   * @return -1.0, 0.0, or 1.0, depending on whether the max share of the first
+   * resource is less than, equal to, or greater than the max share of the
+   * second resource, respectively
+   * @throws NullPointerException if any parameter is null
+   * @throws ArrayIndexOutOfBoundsException if the length of {@code max} is
+   * less than 2
+   */
+  private void calculateShares(ResourceInformation[] clusterRes, Resource first,
+      Resource second, double[] firstShares, double[] secondShares,
+      double[] max) {
+    ResourceInformation[] firstRes = first.getResources();
+    ResourceInformation[] secondRes = second.getResources();
+
+    max[0] = 0.0;
+    max[1] = 0.0;
+
+    for (int i = 0; i < clusterRes.length; i++) {
+      firstShares[i] = calculateShare(clusterRes[i], firstRes[i]);
+      secondShares[i] = calculateShare(clusterRes[i], secondRes[i]);
+
+      if (firstShares[i] > max[0]) {
+        max[0] = firstShares[i];
+      }
+
+      if (secondShares[i] > max[1]) {
+        max[1] = secondShares[i];
+      }
+    }
+  }
+
+  /**
+   * Calculate the share for a resource type.
+   * @param clusterRes the resource type for the cluster maximum
+   * @param res the resource type for which to calculate the share
+   * @return the share
+   */
+  private double calculateShare(ResourceInformation clusterRes,
+      ResourceInformation res) {
+      // Convert the resources' units into the cluster resource's units
+    long value = UnitsConversionUtil.convert(res.getUnits(),
+          clusterRes.getUnits(), res.getValue());
+
+    return (double) value / clusterRes.getValue();
+  }
+
+  /**
+   * Compare the two shares arrays by comparing the largest elements, then the
+   * next largest if the previous were equal, etc. The share arrays must be
+   * sorted in ascending order.
+   * @param lhsShares the first share array to compare
+   * @param rhsShares the second share array to compare
+   * @return a number that is less than 0 if the first array is less than the
+   * second, equal to 0 if the arrays are equal, and greater than 0 if the
+   * first array is greater than the second
+   */
+  private double compareShares(double[] lhsShares, double[] rhsShares) {
+    double diff = 0.0;
+
+    // lhsShares and rhsShares must necessarily have the same length, because
+    // everyone uses the same master resource list.
+    for (int i = lhsShares.length - 1; i >= 0; i--) {
+      diff = lhsShares[i] - rhsShares[i];
+
+      if (diff != 0.0) {
+        break;
+      }
+    }
+
+    return diff;
-    return
-        getResourceAsValue(clusterResource, numerator, true) /
-        getResourceAsValue(clusterResource, denominator, true);
+    ResourceInformation[] clusterRes = clusterResource.getResources();
+    // We have to provide the calculateShares() method with somewhere to store
+    // the shares. We don't actually need these shares afterwards.
+    double[] numeratorShares = new double[clusterRes.length];
+    double[] denominatorShares = new double[clusterRes.length];
+    // We also have to provide a place for calculateShares() to store the max
+    // shares so that we can use them.
+    double[] max = new double[2];
+
+    calculateShares(clusterRes, numerator, denominator, numeratorShares,
+        denominatorShares, max);
+
+    return (float) (max[0] / max[1]);

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS44 MOV44 INS44 INS44 INS44 INS8 MOV29 UPD83 MOV83 UPD39 MOV39 INS42 INS44 INS44 MOV44 MOV44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS42 INS42 INS32 INS60 INS60 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS5 INS42 UPD42 INS43 INS42 INS5 INS42 INS5 INS42 INS60 INS60 INS24 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS5 INS42 INS43 INS42 UPD42 INS5 UPD42 INS5 INS42 INS60 INS60 MOV60 MOV60 INS60 INS60 INS24 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS5 INS42 INS43 INS42 INS43 INS42 INS5 INS42 INS5 INS42 INS5 INS42 MOV60 INS60 INS21 INS21 INS24 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 MOV60 INS41 INS65 INS65 INS65 INS65 INS5 INS42 INS5 INS42 INS60 INS24 INS41 INS60 INS60 INS60 INS60 INS21 INS41 INS42 INS42 INS57 INS5 INS5 INS59 INS5 INS59 INS39 INS59 INS8 INS12 INS11 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 MOV43 INS85 INS42 INS39 INS85 INS39 INS85 INS5 INS59 INS5 INS59 MOV58 INS27 MOV37 INS8 UPD66 INS65 UPD66 INS65 INS66 INS65 UPD66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 UPD66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS43 INS85 INS42 INS39 INS85 INS39 INS85 INS5 INS59 INS5 INS59 UPD39 UPD39 MOV39 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS27 MOV8 INS25 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS65 INS66 INS66 INS43 INS85 INS42 INS42 INS39 INS85 INS39 INS85 INS39 INS85 INS5 INS5 INS59 INS7 INS7 INS58 INS27 INS37 INS8 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS39 INS85 INS39 INS85 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS5 INS59 INS5 INS59 INS5 INS59 INS5 INS59 INS32 INS11 INS43 MOV43 INS85 UPD42 INS39 INS85 INS42 INS3 INS39 INS85 UPD42 MOV42 INS3 INS42 INS25 INS44 INS8 INS39 INS32 INS66 INS66 INS66 INS66 INS66 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS40 INS21 INS21 UPD66 MOV66 INS66 INS66 INS66 INS66 INS66 INS42 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 UPD42 INS34 UPD42 UPD34 UPD42 MOV42 INS34 INS42 INS34 INS39 INS59 INS42 INS40 INS42 INS21 INS21 INS25 INS25 INS25 INS25 INS2 INS2 INS27 MOV8 INS25 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS43 INS85 UPD42 INS43 INS85 INS42 INS32 INS2 INS34 INS2 INS34 INS39 INS59 INS42 INS40 INS42 INS21 INS21 INS25 INS25 UPD42 MOV11 INS32 INS42 INS34 INS39 INS59 INS42 INS34 INS42 MOV21 INS25 INS43 INS85 INS42 INS32 INS39 INS85 INS42 INS3 INS39 INS85 INS42 INS3 INS39 INS85 INS42 INS3 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS42 INS39 INS36 INS42 UPD42 INS5 INS40 INS5 INS40 INS42 INS8 INS25 INS43 INS42 INS60 INS21 INS21 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS7 INS7 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS42 INS42 INS42 INS42 INS2 INS2 INS27 MOV8 INS25 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS34 INS7 INS7 INS27 INS8 INS27 INS8 UPD39 UPD42 UPD42 MOV42 MOV42 INS42 INS27 INS27 INS8 INS42 MOV42 INS42 INS5 INS40 INS5 INS40 INS5 INS34 INS27 INS39 INS85 INS39 INS85 INS60 INS21 INS21 INS27 INS8 INS8 INS42 INS43 INS59 INS32 INS32 INS32 INS14 INS2 INS32 INS2 INS32 INS2 INS32 INS2 INS32 INS2 INS2 INS21 INS2 INS2 INS21 INS2 INS2 INS21 INS2 INS2 INS21 INS42 INS42 INS42 INS42 INS2 INS2 INS27 MOV8 INS8 INS2 INS32 INS2 INS32 INS2 INS2 INS21 INS2 INS2 INS21 UPD42 UPD42 UPD42 INS40 INS34 UPD42 INS27 INS42 INS34 INS10 INS39 INS85 INS39 INS85 INS39 INS85 INS2 INS2 INS5 INS59 INS32 INS7 INS40 INS34 MOV21 INS21 INS21 INS21 MOV21 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS27 INS42 INS42 INS27 INS43 INS27 INS42 INS42 INS42 INS42 INS2 INS2 INS42 INS42 INS42 INS2 INS2 INS42 INS42 INS42 INS2 INS2 INS42 INS42 INS42 INS2 INS2 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS2 INS2 MOV41 INS42 INS42 UPD42 MOV42 INS2 INS2 INS42 INS42 INS42 INS2 INS2 INS42 INS42 INS42 INS34 INS7 INS42 INS42 INS42 INS34 INS7 INS2 INS2 INS42 INS34 INS42 INS34 INS39 INS85 INS42 INS3 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS42 INS42 INS27 INS32 INS32 INS32 INS43 INS43 INS42 INS27 INS42 INS45 INS45 INS32 INS45 INS45 INS32 INS45 INS45 INS32 INS45 INS45 INS45 INS45 INS42 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS2 INS2 INS2 INS42 INS42 INS42 INS42 INS5 INS34 INS2 INS2 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS45 INS45 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS34 INS42 INS42 INS42 INS34 INS42 INS42 INS39 INS85 INS42 INS34 INS42 INS34 UPD42 UPD42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 DEL39 DEL42 DEL9 DEL9 DEL9 DEL39 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL42 DEL38 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL25 DEL25 DEL8 DEL25 DEL25 DEL25 DEL39 DEL40 DEL42 DEL42 DEL42 DEL27 DEL42 DEL42 DEL16 DEL42 DEL42 DEL42 DEL32 DEL42 DEL22 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL39 DEL32 DEL11 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL27 DEL42 DEL42 DEL16 DEL7 DEL21 DEL8 DEL24 DEL42 DEL36 DEL42 DEL42 DEL16 DEL41 DEL8 DEL31 DEL42 DEL42 DEL9 DEL32 DEL9 DEL32 DEL27 DEL41
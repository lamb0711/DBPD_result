HDFS-7722. DataNode#checkDiskError should also remove Storage when error is found. (Lei Xu via Colin P. McCabe)

+import java.io.File;
+import java.util.HashSet;
+            LOG.error("Failed to add volume: " + volume, e);
-      if (!changedVolumes.deactivateLocations.isEmpty()) {
-        LOG.info("Deactivating volumes: " +
-            Joiner.on(",").join(changedVolumes.deactivateLocations));
-
-        data.removeVolumes(changedVolumes.deactivateLocations);
-        try {
-          storage.removeVolumes(changedVolumes.deactivateLocations);
-        } catch (IOException e) {
-          errorMessageBuilder.append(e.getMessage());
-        }
+      try {
+        removeVolumes(changedVolumes.deactivateLocations);
+      } catch (IOException e) {
+        errorMessageBuilder.append(e.getMessage());
+        LOG.error("Failed to remove volume: " + e.getMessage(), e);
+  /**
+   * Remove volumes from DataNode.
+   * See {@link removeVolumes(final Set<File>, boolean)} for details.
+   *
+   * @param locations the StorageLocations of the volumes to be removed.
+   * @throws IOException
+   */
+  private void removeVolumes(final Collection<StorageLocation> locations)
+    throws IOException {
+    if (locations.isEmpty()) {
+      return;
+    }
+    Set<File> volumesToRemove = new HashSet<>();
+    for (StorageLocation loc : locations) {
+      volumesToRemove.add(loc.getFile().getAbsoluteFile());
+    }
+    removeVolumes(volumesToRemove, true);
+  }
+
+  /**
+   * Remove volumes from DataNode.
+   *
+   * It does three things:
+   * <li>
+   *   <ul>Remove volumes and block info from FsDataset.</ul>
+   *   <ul>Remove volumes from DataStorage.</ul>
+   *   <ul>Reset configuration DATA_DIR and {@link dataDirs} to represent
+   *   active volumes.</ul>
+   * </li>
+   * @param absoluteVolumePaths the absolute path of volumes.
+   * @param clearFailure if true, clears the failure information related to the
+   *                     volumes.
+   * @throws IOException
+   */
+  private synchronized void removeVolumes(
+      final Set<File> absoluteVolumePaths, boolean clearFailure)
+      throws IOException {
+    for (File vol : absoluteVolumePaths) {
+      Preconditions.checkArgument(vol.isAbsolute());
+    }
+
+    if (absoluteVolumePaths.isEmpty()) {
+      return;
+    }
+
+    LOG.info(String.format("Deactivating volumes (clear failure=%b): %s",
+        clearFailure, Joiner.on(",").join(absoluteVolumePaths)));
+
+    IOException ioe = null;
+    // Remove volumes and block infos from FsDataset.
+    data.removeVolumes(absoluteVolumePaths, clearFailure);
+
+    // Remove volumes from DataStorage.
+    try {
+      storage.removeVolumes(absoluteVolumePaths);
+    } catch (IOException e) {
+      ioe = e;
+    }
+
+    // Set configuration and dataDirs to reflect volume changes.
+    for (Iterator<StorageLocation> it = dataDirs.iterator(); it.hasNext(); ) {
+      StorageLocation loc = it.next();
+      if (absoluteVolumePaths.contains(loc.getFile().getAbsoluteFile())) {
+        it.remove();
+      }
+    }
+    conf.set(DFS_DATANODE_DATA_DIR_KEY, Joiner.on(",").join(dataDirs));
+
+    if (ioe != null) {
+      throw ioe;
+    }
+  }
+
-    try {
-      data.checkDataDir();
-    } catch (DiskErrorException de) {
-      handleDiskError(de.getMessage());
+    Set<File> unhealthyDataDirs = data.checkDataDir();
+    if (unhealthyDataDirs != null && !unhealthyDataDirs.isEmpty()) {
+      try {
+        // Remove all unhealthy volumes from DataNode.
+        removeVolumes(unhealthyDataDirs, false);
+      } catch (IOException e) {
+        LOG.warn("Error occurred when removing unhealthy storage dirs: "
+            + e.getMessage(), e);
+      }
+      StringBuilder sb = new StringBuilder("DataNode failed volumes:");
+      for (File dataDir : unhealthyDataDirs) {
+        sb.append(dataDir.getAbsolutePath() + ";");
+      }
+      handleDiskError(sb.toString());

INS26 INS26 INS40 INS40 INS31 INS31 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS8 INS65 INS65 INS65 INS83 INS74 INS42 INS42 INS25 INS60 INS70 INS21 INS65 INS65 INS65 INS65 INS83 INS74 INS42 INS39 INS42 INS42 INS70 INS25 MOV21 INS60 INS21 INS54 INS24 INS21 INS25 INS60 INS25 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS43 INS43 INS32 INS8 INS74 INS59 INS44 INS42 INS8 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS43 INS43 INS44 INS42 INS8 INS32 INS8 INS32 INS43 INS59 INS32 INS8 INS12 INS58 INS32 INS8 INS32 INS27 INS8 INS74 INS59 INS27 INS8 MOV54 INS66 INS42 INS42 INS42 INS42 INS41 INS43 INS43 INS42 INS14 INS43 INS42 INS21 INS42 INS42 INS9 INS42 INS42 INS42 INS43 INS42 INS21 INS42 INS42 INS41 INS42 INS42 MOV32 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS74 INS59 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS32 INS42 INS33 INS53 INS43 INS43 INS42 MOV32 INS27 INS38 MOV54 INS60 INS70 INS21 INS42 INS42 INS74 INS42 INS32 INS42 INS32 UPD42 UPD42 INS45 INS42 MOV32 INS32 INS43 INS42 INS21 INS43 INS43 INS42 INS32 INS43 INS59 INS32 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS32 INS43 INS59 INS44 INS42 INS8 INS32 INS43 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS21 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS14 INS43 INS42 INS21 INS42 INS32 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 UPD43 UPD42 INS43 INS45 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 UPD42 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 UPD42 INS42 INS27 INS42 INS32 INS45 INS45 INS32 INS45 INS32 INS42 INS42 INS21 INS42 INS42 UPD42 MOV42 MOV42 INS32 INS42 INS42 INS27 INS42 INS45 INS42 DEL42 DEL40 DEL42 DEL32 DEL38 DEL42 DEL42 DEL40 DEL32 DEL21 DEL8 DEL25 DEL40 DEL45 DEL27 DEL32 DEL8
Merge remote-tracking branch 'apache/trunk' into HDFS-7285

-import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.hdfs.DFSUtil;
+import java.util.EnumMap;
+import java.util.ArrayList;
+import java.util.HashSet;
+  private DistCpOptions inputOptions;
+  private Configuration conf;
+  private EnumMap<SnapshotDiffReport.DiffType, List<DiffInfo>> diffMap;
+  private DiffInfo[] renameDiffs;
-  static boolean sync(DistCpOptions inputOptions, Configuration conf)
-      throws IOException {
+  DistCpSync(DistCpOptions options, Configuration conf) {
+    this.inputOptions = options;
+    this.conf = conf;
+  }
+
+  /**
+   * Check if three conditions are met before sync.
+   * 1. Only one source directory.
+   * 2. Both source and target file system are DFS.
+   * 3. There is no change between from and the current status in target
+   *    file system.
+   *  Throw exceptions if first two aren't met, and return false to fallback to
+   *  default distcp if the third condition isn't met.
+   */
+  private boolean preSyncCheck() throws IOException {
-    final DistributedFileSystem sourceFs = (DistributedFileSystem) sfs;
-    final DistributedFileSystem targetFs= (DistributedFileSystem) tfs;
+    final DistributedFileSystem targetFs = (DistributedFileSystem) tfs;
-    if (!checkNoChange(inputOptions, targetFs, targetDir)) {
+    if (!checkNoChange(targetFs, targetDir)) {
+    return true;
+  }
+
+  public boolean sync() throws IOException {
+    if (!preSyncCheck()) {
+      return false;
+    }
+
+    if (!getAllDiffs()) {
+      return false;
+    }
+
+    List<Path> sourcePaths = inputOptions.getSourcePaths();
+    final Path sourceDir = sourcePaths.get(0);
+    final Path targetDir = inputOptions.getTargetPath();
+    final FileSystem tfs = targetDir.getFileSystem(conf);
+    final DistributedFileSystem targetFs = (DistributedFileSystem) tfs;
-      DiffInfo[] diffs = getDiffs(inputOptions, sourceFs, sourceDir, targetDir);
-      if (diffs == null) {
-        return false;
+      DiffInfo[] renameAndDeleteDiffs = getRenameAndDeleteDiffs(targetDir);
+      if (renameAndDeleteDiffs.length > 0) {
+        // do the real sync work: deletion and rename
+        syncDiff(renameAndDeleteDiffs, targetFs, tmpDir);
-      // do the real sync work: deletion and rename
-      syncDiff(diffs, targetFs, tmpDir);
-  private static String getSnapshotName(String name) {
+  /**
+   * Get all diffs from source directory snapshot diff report, put them into an
+   * EnumMap whose key is DiffType, and value is a DiffInfo list. If there is
+   * no entry for a given DiffType, the associated value will be an empty list.
+   */
+  private boolean getAllDiffs() throws IOException {
+    List<Path> sourcePaths = inputOptions.getSourcePaths();
+    final Path sourceDir = sourcePaths.get(0);
+    try {
+      DistributedFileSystem fs =
+          (DistributedFileSystem) sourceDir.getFileSystem(conf);
+      final String from = getSnapshotName(inputOptions.getFromSnapshot());
+      final String to = getSnapshotName(inputOptions.getToSnapshot());
+      SnapshotDiffReport report = fs.getSnapshotDiffReport(sourceDir,
+          from, to);
+
+      this.diffMap = new EnumMap<>(SnapshotDiffReport.DiffType.class);
+      for (SnapshotDiffReport.DiffType type :
+          SnapshotDiffReport.DiffType.values()) {
+        diffMap.put(type, new ArrayList<DiffInfo>());
+      }
+
+      for (SnapshotDiffReport.DiffReportEntry entry : report.getDiffList()) {
+        // If the entry is the snapshot root, usually a item like "M\t."
+        // in the diff report. We don't need to handle it and cannot handle it,
+        // since its sourcepath is empty.
+        if (entry.getSourcePath().length <= 0) {
+          continue;
+        }
+        List<DiffInfo> list = diffMap.get(entry.getType());
+
+        if (entry.getType() == SnapshotDiffReport.DiffType.MODIFY ||
+            entry.getType() == SnapshotDiffReport.DiffType.CREATE ||
+            entry.getType() == SnapshotDiffReport.DiffType.DELETE) {
+          final Path source =
+              new Path(DFSUtil.bytes2String(entry.getSourcePath()));
+          list.add(new DiffInfo(source, null, entry.getType()));
+        } else if (entry.getType() == SnapshotDiffReport.DiffType.RENAME) {
+          final Path source =
+              new Path(DFSUtil.bytes2String(entry.getSourcePath()));
+          final Path target =
+              new Path(DFSUtil.bytes2String(entry.getTargetPath()));
+          list.add(new DiffInfo(source, target, entry.getType()));
+        }
+      }
+      return true;
+    } catch (IOException e) {
+      DistCp.LOG.warn("Failed to compute snapshot diff on " + sourceDir, e);
+    }
+    this.diffMap = null;
+    return false;
+  }
+
+  private String getSnapshotName(String name) {
-  private static Path getSourceSnapshotPath(Path sourceDir, String snapshotName) {
+  private Path getSourceSnapshotPath(Path sourceDir, String snapshotName) {
-  private static Path createTargetTmpDir(DistributedFileSystem targetFs,
-      Path targetDir) throws IOException {
+  private Path createTargetTmpDir(DistributedFileSystem targetFs,
+                                  Path targetDir) throws IOException {
-  private static void deleteTargetTmpDir(DistributedFileSystem targetFs,
-      Path tmpDir) {
+  private void deleteTargetTmpDir(DistributedFileSystem targetFs,
+                                  Path tmpDir) {
-  private static boolean checkNoChange(DistCpOptions inputOptions,
-      DistributedFileSystem fs, Path path) {
+  private boolean checkNoChange(DistributedFileSystem fs, Path path) {
-  @VisibleForTesting
-  static DiffInfo[] getDiffs(DistCpOptions inputOptions,
-      DistributedFileSystem fs, Path sourceDir, Path targetDir) {
-    try {
-      final String from = getSnapshotName(inputOptions.getFromSnapshot());
-      final String to = getSnapshotName(inputOptions.getToSnapshot());
-      SnapshotDiffReport sourceDiff = fs.getSnapshotDiffReport(sourceDir,
-          from, to);
-      return DiffInfo.getDiffs(sourceDiff, targetDir);
-    } catch (IOException e) {
-      DistCp.LOG.warn("Failed to compute snapshot diff on " + sourceDir, e);
-    }
-    return null;
-  }
-
-  private static void syncDiff(DiffInfo[] diffs,
+  private void syncDiff(DiffInfo[] diffs,
-  private static void moveToTmpDir(DiffInfo[] diffs,
+  private void moveToTmpDir(DiffInfo[] diffs,
-  private static void moveToTarget(DiffInfo[] diffs,
+  private void moveToTarget(DiffInfo[] diffs,
+
+  /**
+   * Get rename and delete diffs and add the targetDir as the prefix of their
+   * source and target paths.
+   */
+  private DiffInfo[] getRenameAndDeleteDiffs(Path targetDir) {
+    List<DiffInfo> renameAndDeleteDiff = new ArrayList<>();
+    for (DiffInfo diff : diffMap.get(SnapshotDiffReport.DiffType.DELETE)) {
+      Path source = new Path(targetDir, diff.source);
+      renameAndDeleteDiff.add(new DiffInfo(source, diff.target,
+          diff.getType()));
+    }
+
+    for (DiffInfo diff : diffMap.get(SnapshotDiffReport.DiffType.RENAME)) {
+      Path source = new Path(targetDir, diff.source);
+      Path target = new Path(targetDir, diff.target);
+      renameAndDeleteDiff.add(new DiffInfo(source, target, diff.getType()));
+    }
+
+    return renameAndDeleteDiff.toArray(
+        new DiffInfo[renameAndDeleteDiff.size()]);
+  }
+
+  private DiffInfo[] getCreateAndModifyDiffs() {
+    List<DiffInfo> createDiff =
+        diffMap.get(SnapshotDiffReport.DiffType.CREATE);
+    List<DiffInfo> modifyDiff =
+        diffMap.get(SnapshotDiffReport.DiffType.MODIFY);
+    List<DiffInfo> diffs =
+        new ArrayList<>(createDiff.size() + modifyDiff.size());
+    diffs.addAll(createDiff);
+    diffs.addAll(modifyDiff);
+    return diffs.toArray(new DiffInfo[diffs.size()]);
+  }
+
+  /**
+   * Probe for a path being a parent of another.
+   * @return true if the parent's path matches the start of the child's
+   */
+  private boolean isParentOf(Path parent, Path child) {
+    String parentPath = parent.toString();
+    String childPath = child.toString();
+    if (!parentPath.endsWith(Path.SEPARATOR)) {
+      parentPath += Path.SEPARATOR;
+    }
+
+    return childPath.length() > parentPath.length() &&
+        childPath.startsWith(parentPath);
+  }
+
+  /**
+   * Find the possible rename item which equals to the parent or self of
+   * a created/modified file/directory.
+   * @param diff a modify/create diff item
+   * @param renameDiffArray all rename diffs
+   * @return possible rename item
+   */
+  private DiffInfo getRenameItem(DiffInfo diff, DiffInfo[] renameDiffArray) {
+    for (DiffInfo renameItem : renameDiffArray) {
+      if (diff.source.equals(renameItem.source)) {
+        // The same path string may appear in:
+        // 1. both renamed and modified snapshot diff entries.
+        // 2. both renamed and created snapshot diff entries.
+        // Case 1 is the about same file/directory, whereas case 2
+        // is about two different files/directories.
+        // We are finding case 1 here, thus we check against DiffType.MODIFY.
+        if (diff.getType() == SnapshotDiffReport.DiffType.MODIFY) {
+          return renameItem;
+        }
+      } else if (isParentOf(renameItem.source, diff.source)) {
+        // If rename entry is the parent of diff entry, then both MODIFY and
+        // CREATE diff entries should be handled.
+        return renameItem;
+      }
+    }
+    return null;
+  }
+
+  /**
+   * For a given source path, get its target path based on the rename item.
+   * @return target path
+   */
+  private Path getTargetPath(Path sourcePath, DiffInfo renameItem) {
+    if (sourcePath.equals(renameItem.source)) {
+      return renameItem.target;
+    }
+    StringBuffer sb = new StringBuffer(sourcePath.toString());
+    String remain = sb.substring(renameItem.source.toString().length() + 1);
+    return new Path(renameItem.target, remain);
+  }
+
+  /**
+   * Prepare the diff list.
+   * This diff list only includes created or modified files/directories, since
+   * delete and rename items are synchronized already.
+   *
+   * If the parent or self of a source path is renamed, we need to change its
+   * target path according the correspondent rename item.
+   * @return a diff list
+   */
+  public ArrayList<DiffInfo> prepareDiffList() {
+    DiffInfo[] modifyAndCreateDiffs = getCreateAndModifyDiffs();
+
+    List<DiffInfo> renameDiffsList =
+        diffMap.get(SnapshotDiffReport.DiffType.RENAME);
+    DiffInfo[] renameDiffArray =
+        renameDiffsList.toArray(new DiffInfo[renameDiffsList.size()]);
+    Arrays.sort(renameDiffArray, DiffInfo.sourceComparator);
+
+    ArrayList<DiffInfo> finalListWithTarget = new ArrayList<>();
+    for (DiffInfo diff : modifyAndCreateDiffs) {
+      DiffInfo renameItem = getRenameItem(diff, renameDiffArray);
+      if (renameItem == null) {
+        diff.target = diff.source;
+      } else {
+        diff.target = getTargetPath(diff.source, renameItem);
+      }
+      finalListWithTarget.add(diff);
+    }
+    return finalListWithTarget;
+  }
+
+  /**
+   * This method returns a list of items to be excluded when recursively
+   * traversing newDir to build the copy list.
+   *
+   * Specifically, given a newly created directory newDir (a CREATE entry in
+   * the snapshot diff), if a previously copied file/directory itemX is moved
+   * (a RENAME entry in the snapshot diff) into newDir, itemX should be
+   * excluded when recursively traversing newDir in caller method so that it
+   * will not to be copied again.
+   * If the same itemX also has a MODIFY entry in the snapshot diff report,
+   * meaning it was modified after it was previously copied, it will still
+   * be added to the copy list in caller method.
+   * @return the exclude list
+   */
+  public HashSet<String> getTraverseExcludeList(Path newDir, Path prefix) {
+    if (renameDiffs == null) {
+      List<DiffInfo> renameList =
+          diffMap.get(SnapshotDiffReport.DiffType.RENAME);
+      renameDiffs = renameList.toArray(new DiffInfo[renameList.size()]);
+      Arrays.sort(renameDiffs, DiffInfo.targetComparator);
+    }
+
+    if (renameDiffs.length <= 0) {
+      return null;
+    }
+
+    boolean foundChild = false;
+    HashSet<String> excludeList = new HashSet<>();
+    for (DiffInfo diff : renameDiffs) {
+      if (isParentOf(newDir, diff.target)) {
+        foundChild = true;
+        excludeList.add(new Path(prefix, diff.target).toUri().getPath());
+      } else if (foundChild) {
+        // The renameDiffs was sorted, the matching section should be
+        // contiguous.
+        break;
+      }
+    }
+    return excludeList;
+  }

MOV26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 MOV43 INS59 INS83 INS43 INS59 INS83 INS74 INS59 INS83 INS5 INS59 INS42 MOV44 MOV44 INS8 INS29 UPD83 UPD42 UPD83 MOV83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 MOV5 INS42 MOV44 INS8 INS83 INS5 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS43 INS42 MOV44 INS44 INS8 INS29 INS83 INS74 INS42 MOV8 INS29 INS83 INS74 INS42 INS44 INS44 INS8 INS42 INS42 INS42 INS43 INS43 INS74 INS42 INS43 INS85 INS42 UPD42 INS21 INS21 INS65 INS41 INS42 MOV25 INS25 INS60 INS60 INS60 INS60 INS60 MOV60 MOV54 INS65 INS42 INS60 INS60 INS54 INS21 INS41 INS65 INS60 INS70 INS70 INS41 INS43 INS85 INS60 INS60 INS60 INS21 INS21 INS41 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS60 INS25 INS41 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS5 INS42 INS70 MOV41 INS65 INS65 INS42 UPD42 INS43 INS42 INS25 INS60 INS60 INS41 INS65 INS65 INS43 INS43 INS60 INS60 INS60 INS21 INS60 INS70 INS41 INS65 INS65 INS43 INS43 INS43 INS42 INS43 INS42 INS25 INS25 INS60 INS60 INS70 INS41 INS42 INS40 INS43 INS43 INS42 INS7 INS7 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS9 INS38 INS38 INS8 INS74 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS66 INS66 INS66 INS74 INS59 INS83 INS43 INS59 INS8 MOV12 INS7 INS9 INS66 INS66 INS74 INS59 INS44 INS32 INS8 INS44 INS32 INS8 INS32 INS42 INS74 INS59 INS74 INS59 INS74 INS59 INS32 INS32 INS32 INS66 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS38 INS8 INS27 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS43 INS85 INS44 INS42 INS8 INS66 INS66 INS42 INS32 INS8 INS43 INS59 INS43 INS59 INS14 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS5 INS59 INS74 INS59 INS5 INS59 INS32 INS74 INS59 INS44 INS42 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS27 INS8 INS27 INS8 INS39 INS59 INS74 INS59 INS44 INS42 INS8 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS32 INS32 INS41 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 MOV42 INS42 INS11 INS25 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS60 MOV60 MOV60 MOV60 INS21 INS70 INS70 INS41 INS22 INS33 INS43 INS43 INS42 INS14 INS43 INS42 INS42 INS42 INS40 INS60 INS21 INS43 INS42 INS42 INS42 INS40 INS60 INS60 INS21 INS42 INS42 INS3 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS3 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS21 INS27 INS32 INS42 INS43 INS42 INS25 INS42 INS42 INS40 INS41 INS42 INS42 INS14 INS42 INS42 INS32 INS43 INS40 INS42 INS43 INS85 INS42 INS32 INS43 INS43 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS42 INS42 INS40 INS43 INS43 INS42 INS14 INS43 INS42 INS60 INS25 INS21 INS42 INS33 INS60 INS21 INS21 INS40 INS34 INS41 INS42 INS9 INS43 INS43 INS42 INS14 INS43 INS42 INS25 INS52 INS42 INS52 INS42 INS42 INS42 INS9 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS34 MOV43 INS59 INS7 INS44 INS32 INS8 INS44 INS32 INS8 INS9 INS52 INS42 INS42 INS42 INS74 INS42 INS43 INS59 INS32 INS42 INS43 INS59 INS43 INS59 INS32 INS5 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS74 INS27 INS5 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS7 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS8 INS25 INS40 INS43 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS3 INS42 INS42 INS74 INS42 INS43 INS59 INS27 INS8 INS8 INS32 INS74 INS59 INS7 INS32 INS33 INS42 INS42 INS74 INS42 INS32 INS8 INS25 INS42 UPD42 INS40 INS34 MOV21 INS42 INS11 UPD42 INS22 INS14 INS43 INS42 INS40 INS42 INS21 INS43 INS42 INS42 INS42 INS25 INS60 INS25 INS43 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS43 INS85 INS42 INS42 INS43 INS32 INS32 INS43 INS85 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS40 INS25 INS32 INS8 INS42 INS42 INS42 INS32 INS34 INS5 INS32 INS43 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS40 INS43 INS42 INS42 INS40 INS21 INS21 INS42 INS8 UPD42 MOV43 INS32 INS52 INS42 INS74 INS57 INS40 INS32 INS40 INS27 INS8 INS74 INS59 INS27 INS8 INS25 INS42 INS43 INS42 INS40 INS43 INS42 INS40 INS32 INS43 INS42 INS40 INS43 INS42 INS40 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS42 INS40 INS40 INS41 INS32 INS42 INS43 INS85 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS3 INS42 INS7 INS32 INS10 UPD42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS14 INS22 INS34 INS18 INS43 INS43 INS42 INS32 INS27 INS27 INS60 INS21 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS41 INS42 INS40 INS42 INS42 INS40 INS40 INS40 INS32 INS5 INS32 INS42 INS9 INS42 INS42 INS32 INS42 INS40 INS74 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS32 INS40 INS83 INS43 INS59 INS32 INS32 INS40 INS60 INS60 INS21 INS42 INS42 INS42 UPD42 MOV42 INS40 INS42 INS43 INS85 INS42 INS42 INS32 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS32 INS40 INS32 INS40 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS42 INS33 INS32 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS43 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS32 INS43 INS32 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL83 DEL42 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL44 DEL42 DEL78 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL31 DEL83 DEL83 DEL83 DEL42 DEL32 DEL41 DEL8 DEL54
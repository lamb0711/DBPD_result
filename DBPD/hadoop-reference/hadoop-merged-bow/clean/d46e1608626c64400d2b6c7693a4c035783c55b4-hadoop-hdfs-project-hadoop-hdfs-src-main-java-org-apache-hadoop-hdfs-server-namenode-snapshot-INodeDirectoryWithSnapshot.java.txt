HDFS-4877. Snapshot: fix the scenario where a directory is renamed under its prior descendant. Contributed by Jing Zhao.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490421 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Map;
-          counts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);
+          counts.get(Quota.DISKSPACE), false);
-      final BlocksMapUpdateInfo collectedBlocks, final List<INode> removedINodes)
+      final BlocksMapUpdateInfo collectedBlocks,
+      final List<INode> removedINodes, final boolean countDiffChange)
+    Map<INode, INode> priorCreated = null;
+    Map<INode, INode> priorDeleted = null;
+      // if there is a snapshot diff associated with prior, we need to record
+      // its original created and deleted list before deleting post
+      if (prior != null) {
+        DirectoryDiff priorDiff = this.getDiffs().getDiff(prior);
+        if (priorDiff != null && priorDiff.getSnapshot().equals(prior)) {
+          List<INode> cList = priorDiff.diff.getList(ListType.CREATED);
+          List<INode> dList = priorDiff.diff.getList(ListType.DELETED);
+          priorCreated = new HashMap<INode, INode>(cList.size());
+          for (INode cNode : cList) {
+            priorCreated.put(cNode, cNode);
+          }
+          priorDeleted = new HashMap<INode, INode>(dList.size());
+          for (INode dNode : dList) {
+            priorDeleted.put(dNode, dNode);
+          }
+        }
+      }
+      
-          collectedBlocks, removedINodes));
+          collectedBlocks, removedINodes, countDiffChange));
+      
+      // check priorDiff again since it may be created during the diff deletion
-          for (INode cNode : priorDiff.getChildrenDiff().getList(
-              ListType.CREATED)) {
-            counts.add(cNode.cleanSubtree(snapshot, null, collectedBlocks,
-                removedINodes));
+          if (priorCreated != null) {
+            // we only check the node originally in prior's created list
+            for (INode cNode : priorDiff.getChildrenDiff().getList(
+                ListType.CREATED)) {
+              if (priorCreated.containsKey(cNode)) {
+                counts.add(cNode.cleanSubtree(snapshot, null, collectedBlocks,
+                    removedINodes, countDiffChange));
+              }
+            }
+          
+          
-            counts.add(cleanDeletedINode(dNode, snapshot, prior,
-                collectedBlocks, removedINodes));
+            if (priorDeleted == null || !priorDeleted.containsKey(dNode)) {
+              counts.add(cleanDeletedINode(dNode, snapshot, prior,
+                  collectedBlocks, removedINodes, countDiffChange));
+            }
-        removedINodes));
+        removedINodes, priorDeleted, countDiffChange));
-  private static Quota.Counts cleanDeletedINode(INode inode, final Snapshot post, 
-      final Snapshot prior, final BlocksMapUpdateInfo collectedBlocks, 
-      final List<INode> removedINodes) throws QuotaExceededException {
+  private static Quota.Counts cleanDeletedINode(INode inode,
+      final Snapshot post, final Snapshot prior,
+      final BlocksMapUpdateInfo collectedBlocks,
+      final List<INode> removedINodes, final boolean countDiffChange) 
+      throws QuotaExceededException {
-          wn.cleanSubtree(post, prior, collectedBlocks, removedINodes);
+          wn.cleanSubtree(post, prior, collectedBlocks, removedINodes,
+              countDiffChange);
-            topNode.asFile(), collectedBlocks, removedINodes));
+            topNode.asFile(), collectedBlocks, removedINodes, countDiffChange));
+        ChildrenDiff priorChildrenDiff = null;
-            counts.add(priorDiff.diff.destroyCreatedList(sdir,
+            priorChildrenDiff = priorDiff.getChildrenDiff();
+            counts.add(priorChildrenDiff.destroyCreatedList(sdir,
+        
+          if (priorChildrenDiff != null
+              && priorChildrenDiff.search(ListType.DELETED,
+                  child.getLocalNameBytes()) != null) {
+            continue;
+          }
-        inode.cleanSubtree(snapshot, prior, collectedBlocks, removedINodes);
+        inode.cleanSubtree(snapshot, prior, collectedBlocks, removedINodes,
+            true);
-      inode.cleanSubtree(snapshot, prior, collectedBlocks, removedINodes);
+      inode.cleanSubtree(snapshot, prior, collectedBlocks, removedINodes, true);
+      Map<INode, INode> excludedNodes = null;
-              removedINodes);
+              removedINodes, true);
+          List<INode> dList = priorDiff.diff.getList(ListType.DELETED);
+          excludedNodes = new HashMap<INode, INode>(dList.size());
+          for (INode dNode : dList) {
+            excludedNodes.put(dNode, dNode);
+          }
+        if (excludedNodes != null && excludedNodes.containsKey(child)) {
+          continue;
+        }

INS26 INS26 INS40 INS40 INS44 INS44 INS83 INS39 INS42 INS60 INS60 INS83 INS39 INS42 INS74 INS59 INS74 INS59 INS43 INS43 INS43 INS42 INS33 INS43 INS43 INS43 INS42 INS33 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS42 INS42 INS42 INS33 INS60 INS25 INS60 INS43 INS59 INS27 INS8 INS42 INS9 INS74 INS59 INS42 INS42 INS32 INS27 INS32 INS60 INS60 INS21 INS70 INS21 INS70 INS25 INS60 INS9 INS43 INS43 INS43 INS42 INS33 INS25 INS32 INS42 INS42 INS42 INS33 INS32 INS42 INS42 INS74 INS59 INS74 INS59 INS7 INS44 INS42 INS8 INS7 INS44 INS42 INS8 INS27 INS8 INS8 INS43 INS59 INS8 INS42 INS42 INS42 INS8 INS27 INS8 INS52 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS32 INS42 INS14 INS43 INS42 INS21 INS42 INS14 INS43 INS42 INS21 INS42 INS33 MOV70 INS25 INS42 INS42 INS42 INS42 INS33 INS25 MOV21 MOV21 INS60 INS21 INS70 INS27 INS32 INS18 INS42 INS42 INS40 INS42 INS40 INS42 INS42 INS40 INS42 INS40 INS74 INS32 INS42 INS32 INS74 INS32 INS42 INS32 INS8 INS27 INS8 INS27 INS8 INS74 INS59 INS7 INS44 INS42 INS8 INS42 INS33 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS25 INS27 INS38 MOV21 INS21 INS27 INS27 INS18 INS9 INS43 INS43 INS42 INS32 INS42 INS14 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS42 INS33 INS32 INS7 INS42 INS33 INS32 INS33 INS42 INS42 INS40 INS42 INS40 INS74 INS32 INS42 INS32 INS42 INS42 INS42 MOV21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS32 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL8 DEL8 DEL40 DEL8 DEL8
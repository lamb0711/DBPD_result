Merge branch 'trunk' into HADOOP-12756

+import org.apache.hadoop.io.WritableUtils;
-    private DataInputStream in;
-    private DataOutputStream out;
+    private IpcStreams ipcStreams;
+    private final int maxResponseLength;
-    private ResponseBuffer pingRequest; // ping message
-    
+    private byte[] pingRequest; // ping message
+
+      this.maxResponseLength = remoteId.conf.getInt(
+          CommonConfigurationKeys.IPC_MAXIMUM_RESPONSE_LENGTH,
+          CommonConfigurationKeys.IPC_MAXIMUM_RESPONSE_LENGTH_DEFAULT);
-        pingRequest = new ResponseBuffer();
+        ResponseBuffer buf = new ResponseBuffer();
-        pingHeader.writeDelimitedTo(pingRequest);
+        pingHeader.writeDelimitedTo(buf);
+        pingRequest = buf.toByteArray();
-    
-    private synchronized AuthMethod setupSaslConnection(final InputStream in2, 
-        final OutputStream out2) throws IOException {
+
+    private synchronized AuthMethod setupSaslConnection(IpcStreams streams)
+        throws IOException {
-      return saslRpcClient.saslConnect(in2, out2);
+      return saslRpcClient.saslConnect(streams);
-          InputStream inStream = NetUtils.getInputStream(socket);
-          OutputStream outStream = NetUtils.getOutputStream(socket);
-          writeConnectionHeader(outStream);
+          ipcStreams = new IpcStreams(socket, maxResponseLength);
+          writeConnectionHeader(ipcStreams);
-            final InputStream in2 = inStream;
-            final OutputStream out2 = outStream;
-                      return setupSaslConnection(in2, out2);
+                      return setupSaslConnection(ipcStreams);
-              inStream = saslRpcClient.getInputStream(inStream);
-              outStream = saslRpcClient.getOutputStream(outStream);
+              ipcStreams.setSaslClient(saslRpcClient);
-        
-          if (doPing) {
-            inStream = new PingInputStream(inStream);
-          }
-          this.in = new DataInputStream(new BufferedInputStream(inStream));
-          // SASL may have already buffered the stream
-          if (!(outStream instanceof BufferedOutputStream)) {
-            outStream = new BufferedOutputStream(outStream);
+          if (doPing) {
+            ipcStreams.setInputStream(new PingInputStream(ipcStreams.in));
-          this.out = new DataOutputStream(outStream);
-          
+
-    private void writeConnectionHeader(OutputStream outStream)
+    private void writeConnectionHeader(IpcStreams streams)
-      DataOutputStream out = new DataOutputStream(new BufferedOutputStream(outStream));
-      // Write out the header, version and authentication method
-      out.write(RpcConstants.HEADER.array());
-      out.write(RpcConstants.CURRENT_VERSION);
-      out.write(serviceClass);
-      out.write(authProtocol.callId);
-      out.flush();
+      // Write out the header, version and authentication method.
+      // The output stream is buffered but we must not flush it yet.  The
+      // connection setup protocol requires the client to send multiple
+      // messages before reading a response.
+      //
+      //   insecure: send header+context+call, read
+      //   secure  : send header+negotiate, read, (sasl), context+call, read
+      //
+      // The client must flush only when it's prepared to read.  Otherwise
+      // "broken pipe" exceptions occur if the server closes the connection
+      // before all messages are sent.
+      final DataOutputStream out = streams.out;
+      synchronized (out) {
+        out.write(RpcConstants.HEADER.array());
+        out.write(RpcConstants.CURRENT_VERSION);
+        out.write(serviceClass);
+        out.write(authProtocol.callId);
+      }
-    
+
+      // do not flush.  the context and first ipc call request must be sent
+      // together to avoid possibility of broken pipes upon authz failure.
+      // see writeConnectionHeader
-      buf.writeTo(out);
+      synchronized (ipcStreams.out) {
+        ipcStreams.sendRequest(buf.toByteArray());
+      }
-    
+
-        synchronized (out) {
-          pingRequest.writeTo(out);
-          out.flush();
+        synchronized (ipcStreams.out) {
+          ipcStreams.sendRequest(pingRequest);
+          ipcStreams.flush();
-              synchronized (Connection.this.out) {
+              synchronized (ipcStreams.out) {
-                buf.writeTo(out); // RpcRequestHeader + RpcRequest
-                out.flush();
+                // RpcRequestHeader + RpcRequest
+                ipcStreams.sendRequest(buf.toByteArray());
+                ipcStreams.flush();
-        int totalLen = in.readInt();
-        ByteBuffer bb = ByteBuffer.allocate(totalLen);
-        in.readFully(bb.array());
-
+        ByteBuffer bb = ipcStreams.readResponse();
-      IOUtils.closeStream(out);
-      IOUtils.closeStream(in);
+      IOUtils.closeStream(ipcStreams);
+
+  /** Manages the input and output streams for an IPC connection.
+   *  Only exposed for use by SaslRpcClient.
+   */
+  @InterfaceAudience.Private
+  public static class IpcStreams implements Closeable, Flushable {
+    private DataInputStream in;
+    public DataOutputStream out;
+    private int maxResponseLength;
+    private boolean firstResponse = true;
+
+    IpcStreams(Socket socket, int maxResponseLength) throws IOException {
+      this.maxResponseLength = maxResponseLength;
+      setInputStream(
+          new BufferedInputStream(NetUtils.getInputStream(socket)));
+      setOutputStream(
+          new BufferedOutputStream(NetUtils.getOutputStream(socket)));
+    }
+
+    void setSaslClient(SaslRpcClient client) throws IOException {
+      setInputStream(client.getInputStream(in));
+      setOutputStream(client.getOutputStream(out));
+    }
+
+    private void setInputStream(InputStream is) {
+      this.in = (is instanceof DataInputStream)
+          ? (DataInputStream)is : new DataInputStream(is);
+    }
+
+    private void setOutputStream(OutputStream os) {
+      this.out = (os instanceof DataOutputStream)
+          ? (DataOutputStream)os : new DataOutputStream(os);
+    }
+
+    public ByteBuffer readResponse() throws IOException {
+      int length = in.readInt();
+      if (firstResponse) {
+        firstResponse = false;
+        // pre-rpcv9 exception, almost certainly a version mismatch.
+        if (length == -1) {
+          in.readInt(); // ignore fatal/error status, it's fatal for us.
+          throw new RemoteException(WritableUtils.readString(in),
+                                    WritableUtils.readString(in));
+        }
+      }
+      if (length <= 0) {
+        throw new RpcException("RPC response has invalid length");
+      }
+      if (maxResponseLength > 0 && length > maxResponseLength) {
+        throw new RpcException("RPC response exceeds maximum data length");
+      }
+      ByteBuffer bb = ByteBuffer.allocate(length);
+      in.readFully(bb.array());
+      return bb;
+    }
+
+    public void sendRequest(byte[] buf) throws IOException {
+      out.write(buf);
+    }
+
+    @Override
+    public void flush() throws IOException {
+      out.flush();
+    }
+
+    @Override
+    public void close() {
+      IOUtils.closeStream(out);
+      IOUtils.closeStream(in);
+    }
+  }

INS26 INS40 MOV23 INS55 INS23 INS23 INS29 INS78 INS83 INS83 INS42 INS43 INS43 MOV23 MOV23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS43 INS59 INS83 INS83 INS39 INS59 INS83 INS5 MOV59 INS44 INS8 INS65 INS40 INS42 INS42 UPD83 INS83 INS39 INS59 INS83 INS39 INS59 INS42 INS44 INS44 INS43 INS8 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 MOV44 INS8 INS83 INS43 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS43 MOV8 INS78 INS83 INS39 INS42 INS8 INS42 INS42 INS42 INS39 INS85 INS21 UPD43 UPD42 INS43 INS42 INS60 INS51 INS51 INS21 INS66 INS66 INS42 INS42 INS9 INS43 INS42 INS39 INS42 INS42 INS21 INS21 INS21 INS43 INS42 INS42 INS21 INS21 MOV43 INS42 INS21 UPD42 INS21 INS42 INS42 MOV60 INS25 INS25 INS25 INS60 MOV21 INS41 INS5 INS42 INS42 INS21 INS42 INS42 INS42 MOV21 MOV21 INS7 UPD42 INS42 INS83 MOV43 INS59 INS42 MOV8 INS40 INS8 INS32 INS42 INS7 INS32 INS32 INS42 INS32 INS32 INS7 INS7 INS42 INS8 INS27 INS8 INS27 INS8 INS43 INS59 INS42 INS39 INS85 INS32 INS22 INS32 INS60 INS21 UPD42 INS42 INS40 MOV21 INS42 INS42 INS42 INS22 INS42 INS42 INS14 INS42 INS14 INS42 INS32 INS42 INS32 MOV22 INS16 MOV22 INS16 UPD42 INS21 INS25 INS42 INS34 INS53 INS27 INS27 INS53 INS42 INS42 INS32 INS42 INS42 INS42 INS52 INS42 INS40 INS42 INS40 INS40 MOV43 INS59 INS7 MOV21 INS32 INS40 INS8 INS52 INS42 MOV43 MOV32 MOV43 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS11 INS14 INS36 INS11 INS14 INS7 INS27 INS8 INS14 INS42 INS34 INS42 INS42 INS14 INS42 INS42 INS42 INS42 MOV14 UPD42 INS42 INS32 MOV21 INS42 INS42 INS32 INS21 INS21 INS62 MOV43 INS42 INS43 INS42 INS62 MOV43 INS42 MOV43 INS42 INS42 INS9 INS42 INS38 INS21 INS53 INS43 INS45 INS43 INS45 INS42 INS42 INS32 MOV42 UPD42 MOV42 INS32 INS32 UPD42 UPD42 INS42 INS43 INS42 INS42 INS43 INS34 INS32 INS14 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS32 UPD43 UPD42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 MOV14 INS32 INS40 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 INS32 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 DEL42 DEL7 DEL21 DEL83 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL14 DEL7 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL7 DEL42 DEL14 DEL14 DEL7 DEL21 DEL42 DEL42 DEL43 DEL62 DEL36 DEL38 DEL8 DEL25 DEL42 DEL42 DEL14 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21
HDFS-6613. Improve logging in caching classes. (wang)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607697 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+;
-  private static final Log LOG =
-      LogFactory.getLog(CacheReplicationMonitor.class);
+  private static final Logger LOG =
+      LoggerFactory.getLogger(CacheReplicationMonitor.class);
-      LOG.fatal("Thread exiting", t);
+      LOG.error("Thread exiting", t);
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Directive " + directive.getId() + ": the directive " +
-              "expired at " + directive.getExpiryTime() + " (now = " +
-              now + ")");
-        }
+        LOG.debug("Directive {}: the directive expired at {} (now = {})",
+             directive.getId(), directive.getExpiryTime(), now);
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Directive " + directive.getId() +
-              ": got UnresolvedLinkException while resolving path " + path);
-        }
+        LOG.debug("Directive {}: got UnresolvedLinkException while resolving "
+                + "path {}", directive.getId(), path
+        );
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Directive " + directive.getId() +
-              ": No inode found at " + path);
-        }
+        LOG.debug("Directive {}: No inode found at {}", directive.getId(),
+            path);
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Directive " + directive.getId() + 
-              ": ignoring non-directive, non-file inode " + node);
-        }
+        LOG.debug("Directive {}: ignoring non-directive, non-file inode {} ",
+            directive.getId(), node);
-      if (LOG.isDebugEnabled()) {
-        LOG.debug(String.format("Directive %d: not scanning file %s because " +
-            "bytesNeeded for pool %s is %d, but the pool's limit is %d",
-            directive.getId(),
-            file.getFullPathName(),
-            pool.getPoolName(),
-            pool.getBytesNeeded(),
-            pool.getLimit()));
-      }
+      LOG.debug("Directive {}: not scanning file {} because " +
+          "bytesNeeded for pool {} is {}, but the pool's limit is {}",
+          directive.getId(),
+          file.getFullPathName(),
+          pool.getPoolName(),
+          pool.getBytesNeeded(),
+          pool.getLimit());
-        if (LOG.isTraceEnabled()) {
-          LOG.trace("Directive " + directive.getId() + ": can't cache " +
-              "block " + blockInfo + " because it is in state " +
-              blockInfo.getBlockUCState() + ", not COMPLETE.");
-        }
+        LOG.trace("Directive {}: can't cache block {} because it is in state "
+                + "{}, not COMPLETE.", directive.getId(), blockInfo,
+            blockInfo.getBlockUCState()
+        );
-        // blocks in state COMMITTED.
+        // blocks in state COMPLETE.
-      if (LOG.isTraceEnabled()) {
-        LOG.trace("Directive " + directive.getId() + ": setting replication " +
-                "for block " + blockInfo + " to " + ocblock.getReplication());
-      }
+      LOG.trace("Directive {}: setting replication for block {} to {}",
+          directive.getId(), blockInfo, ocblock.getReplication());
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Directive " + directive.getId() + ": caching " +
-          file.getFullPathName() + ": " + cachedTotal + "/" + neededTotal +
-          " bytes");
-    }
+    LOG.debug("Directive {}: caching {}: {}/{} bytes", directive.getId(),
+        file.getFullPathName(), cachedTotal, neededTotal);
-          if (LOG.isTraceEnabled()) {
-            LOG.trace("Block " + cblock.getBlockId() + ": removing from " +
-                "PENDING_UNCACHED for node " + datanode.getDatanodeUuid() +
-                "because the DataNode uncached it.");
-          }
+          LOG.trace("Block {}: removing from PENDING_UNCACHED for node {} "
+              + "because the DataNode uncached it.", cblock.getBlockId(),
+              datanode.getDatanodeUuid());
-        if (LOG.isTraceEnabled()) {
-          LOG.trace("Block " + cblock.getBlockId() + ": can't cache " +
-              "block because it is " + reason);
-        }
+        LOG.trace("Block {}: can't cache block because it is {}",
+            cblock.getBlockId(), reason);
-          if (LOG.isTraceEnabled()) {
-            LOG.trace("Block " + cblock.getBlockId() + ": removing from " +
-                "PENDING_CACHED for node " + datanode.getDatanodeUuid() +
-                "because we already have " + numCached + " cached " +
-                "replicas and we only need " + neededCached);
-          }
+          LOG.trace("Block {}: removing from PENDING_CACHED for node {}"
+                  + "because we already have {} cached replicas and we only" +
+                  " need {}",
+              cblock.getBlockId(), datanode.getDatanodeUuid(), numCached,
+              neededCached
+          );
-          if (LOG.isTraceEnabled()) {
-            LOG.trace("Block " + cblock.getBlockId() + ": removing from " +
-                "PENDING_UNCACHED for node " + datanode.getDatanodeUuid() +
-                "because we only have " + numCached + " cached replicas " +
-                "and we need " + neededCached);
-          }
+          LOG.trace("Block {}: removing from PENDING_UNCACHED for node {} "
+                  + "because we only have {} cached replicas and we need " +
+                  "{}", cblock.getBlockId(), datanode.getDatanodeUuid(),
+              numCached, neededCached
+          );
-        if (LOG.isTraceEnabled()) {
-          LOG.trace("Block " + cblock.getBlockId() + ": removing from " +
-              "cachedBlocks, since neededCached == 0, and " +
-              "pendingUncached and pendingCached are empty.");
-        }
+        LOG.trace("Block {}: removing from cachedBlocks, since neededCached "
+                + "== 0, and pendingUncached and pendingCached are empty.",
+            cblock.getBlockId()
+        );
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Block " + cachedBlock.getBlockId() + ": can't add new " +
-            "cached replicas, because there is no record of this block " +
-            "on the NameNode.");
-      }
+      LOG.debug("Block {}: can't add new cached replicas," +
+          " because there is no record of this block " +
+          "on the NameNode.", cachedBlock.getBlockId());
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Block " + cachedBlock.getBlockId() + ": can't cache this " +
-            "block, because it is not yet complete.");
-      }
+      LOG.debug("Block {}: can't cache this block, because it is not yet"
+          + " complete.", cachedBlock.getBlockId());
-      long pendingCapacity = datanode.getCacheRemaining();
+      long pendingBytes = 0;
-          pendingCapacity -= info.getNumBytes();
+          pendingBytes -= info.getNumBytes();
-          pendingCapacity += info.getNumBytes();
+          pendingBytes += info.getNumBytes();
+      long pendingCapacity = pendingBytes + datanode.getCacheRemaining();
-        if (LOG.isTraceEnabled()) {
-          LOG.trace("Block " + blockInfo.getBlockId() + ": DataNode " +
-              datanode.getDatanodeUuid() + " is not a valid possibility " +
-              "because the block has size " + blockInfo.getNumBytes() + ", but " +
-              "the DataNode only has " + datanode.getCacheRemaining() + " " +
-              "bytes of cache remaining.");
-        }
+        LOG.trace("Block {}: DataNode {} is not a valid possibility " +
+            "because the block has size {}, but the DataNode only has {}" +
+            "bytes of cache remaining ({} pending bytes, {} already cached.",
+            blockInfo.getBlockId(), datanode.getDatanodeUuid(),
+            blockInfo.getNumBytes(), pendingCapacity, pendingBytes,
+            datanode.getCacheRemaining());
-      if (LOG.isTraceEnabled()) {
-          LOG.trace("Block " + blockInfo.getBlockId() + ": added to " +
-              "PENDING_CACHED on DataNode " + datanode.getDatanodeUuid());
-      }
+      LOG.trace("Block {}: added to PENDING_CACHED on DataNode {}",
+          blockInfo.getBlockId(), datanode.getDatanodeUuid());
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Block " + blockInfo.getBlockId() + ": we only have " +
-            (cachedBlock.getReplication() - neededCached + chosen.size()) +
-            " of " + cachedBlock.getReplication() + " cached replicas.  " +
-            outOfCapacity + " DataNodes have insufficient cache capacity.");
-      }
+      LOG.debug("Block {}: we only have {} of {} cached replicas."
+              + " {} DataNodes have insufficient cache capacity.",
+          blockInfo.getBlockId(),
+          (cachedBlock.getReplication() - neededCached + chosen.size()),
+          cachedBlock.getReplication(), outOfCapacity
+      );

MOV26 MOV26 UPD40 UPD40 UPD43 UPD42 MOV25 MOV21 MOV25 UPD42 UPD42 MOV27 MOV60 MOV61 MOV21 MOV8 MOV27 MOV25 INS41 MOV21 INS45 MOV32 MOV32 INS42 INS42 MOV25 MOV21 MOV21 INS60 MOV25 MOV21 MOV60 MOV6 MOV27 MOV8 MOV32 MOV27 MOV8 MOV8 INS39 INS59 MOV27 INS18 UPD42 UPD42 MOV21 INS45 MOV32 INS42 MOV32 MOV21 MOV32 MOV32 INS42 INS34 INS27 MOV21 INS18 INS45 MOV32 MOV32 MOV32 MOV36 MOV32 INS42 UPD42 MOV21 MOV8 UPD45 UPD45 MOV8 UPD45 UPD45 UPD45 UPD45 INS42 MOV32 UPD45 UPD45 INS45 MOV32 MOV32 INS42 INS45 MOV32 INS42 MOV32 INS42 MOV32 MOV21 MOV21 INS45 MOV32 INS42 MOV21 MOV21 MOV32 MOV32 MOV32 MOV32 INS42 INS42 MOV32 INS27 MOV32 INS42 UPD45 UPD45 UPD45 UPD45 UPD7 UPD7 UPD45 UPD45 UPD45 UPD45 MOV45 UPD45 MOV45 INS45 MOV32 INS42 MOV32 MOV32 INS27 MOV32 MOV32 INS42 INS42 INS27 MOV32 MOV32 INS42 INS42 UPD42 UPD42 UPD45 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 DEL42 DEL42 DEL32 DEL45 DEL45 DEL45 DEL45 DEL42 DEL45 DEL27 DEL18 DEL8 DEL25 DEL42 DEL27 DEL42 DEL42 DEL32 DEL8 DEL25 DEL45 DEL45 DEL42 DEL27 DEL42 DEL42 DEL32 DEL25 DEL8 DEL45 DEL45 DEL42 DEL27 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL45 DEL45 DEL45 DEL42 DEL42 DEL42 DEL32 DEL8 DEL25 DEL45 DEL45 DEL45 DEL42 DEL45 DEL27 DEL42 DEL42 DEL32 DEL8 DEL25 DEL45 DEL45 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL42 DEL42 DEL32 DEL8 DEL25 DEL45 DEL45 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL32 DEL45 DEL45 DEL45 DEL42 DEL27 DEL8 DEL25 DEL45 DEL42 DEL45 DEL45 DEL42 DEL27 DEL42 DEL42 DEL32 DEL8 DEL25 DEL45 DEL42 DEL45 DEL45 DEL42 DEL27 DEL42 DEL42 DEL32 DEL8 DEL25 DEL45 DEL45 DEL42 DEL42 DEL32 DEL25 DEL8 DEL45 DEL42 DEL42 DEL32 DEL8 DEL25 DEL45 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL45 DEL45 DEL45 DEL45 DEL45 DEL18 DEL8 DEL25 DEL45 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL32 DEL45 DEL45 DEL45 DEL42 DEL8 DEL25
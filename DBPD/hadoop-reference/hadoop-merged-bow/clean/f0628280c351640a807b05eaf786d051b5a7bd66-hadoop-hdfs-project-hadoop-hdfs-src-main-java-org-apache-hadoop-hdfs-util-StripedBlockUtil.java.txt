HDFS-8282. Erasure coding: move striped reading logic to StripedBlockUtil. Contributed by Zhe Zhang.

+import com.google.common.annotations.VisibleForTesting;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CompletionService;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+  /**
+   * This method plans the read portion from each block in the stripe
+   * @param dataBlkNum The number of data blocks in the striping group
+   * @param cellSize The size of each striping cell
+   * @param startInBlk Starting offset in the striped block
+   * @param len Length of the read request
+   * @param bufOffset  Initial offset in the result buffer
+   * @return array of {@link ReadPortion}, each representing the portion of I/O
+   *         for an individual block in the group
+   */
+  @VisibleForTesting
+  public static ReadPortion[] planReadPortions(final int dataBlkNum,
+      final int cellSize, final long startInBlk, final int len, int bufOffset) {
+    ReadPortion[] results = new ReadPortion[dataBlkNum];
+    for (int i = 0; i < dataBlkNum; i++) {
+      results[i] = new ReadPortion();
+    }
+
+    // cellIdxInBlk is the index of the cell in the block
+    // E.g., cell_3 is the 2nd cell in blk_0
+    int cellIdxInBlk = (int) (startInBlk / (cellSize * dataBlkNum));
+
+    // blkIdxInGroup is the index of the block in the striped block group
+    // E.g., blk_2 is the 3rd block in the group
+    final int blkIdxInGroup = (int) (startInBlk / cellSize % dataBlkNum);
+    results[blkIdxInGroup].startOffsetInBlock = cellSize * cellIdxInBlk +
+        startInBlk % cellSize;
+    boolean crossStripe = false;
+    for (int i = 1; i < dataBlkNum; i++) {
+      if (blkIdxInGroup + i >= dataBlkNum && !crossStripe) {
+        cellIdxInBlk++;
+        crossStripe = true;
+      }
+      results[(blkIdxInGroup + i) % dataBlkNum].startOffsetInBlock =
+          cellSize * cellIdxInBlk;
+    }
+
+    int firstCellLen = Math.min(cellSize - (int) (startInBlk % cellSize), len);
+    results[blkIdxInGroup].offsetsInBuf.add(bufOffset);
+    results[blkIdxInGroup].lengths.add(firstCellLen);
+    results[blkIdxInGroup].readLength += firstCellLen;
+
+    int i = (blkIdxInGroup + 1) % dataBlkNum;
+    for (int done = firstCellLen; done < len; done += cellSize) {
+      ReadPortion rp = results[i];
+      rp.offsetsInBuf.add(done + bufOffset);
+      final int readLen = Math.min(len - done, cellSize);
+      rp.lengths.add(readLen);
+      rp.readLength += readLen;
+      i = (i + 1) % dataBlkNum;
+    }
+    return results;
+  }
+
+  /**
+   * Get the next completed striped read task
+   *
+   * @return {@link StripedReadResult} indicating the status of the read task
+   *          succeeded, and the block index of the task. If the method times
+   *          out without getting any completed read tasks, -1 is returned as
+   *          block index.
+   * @throws InterruptedException
+   */
+  public static StripedReadResult getNextCompletedStripedRead(
+      CompletionService<Void> readService, Map<Future<Void>,
+      Integer> futures, final long threshold) throws InterruptedException {
+    Preconditions.checkArgument(!futures.isEmpty());
+    Preconditions.checkArgument(threshold > 0);
+    Future<Void> future = null;
+    try {
+      future = readService.poll(threshold, TimeUnit.MILLISECONDS);
+      if (future != null) {
+        future.get();
+        return new StripedReadResult(futures.remove(future),
+            StripedReadResult.SUCCESSFUL);
+      } else {
+        return new StripedReadResult(StripedReadResult.TIMEOUT);
+      }
+    } catch (ExecutionException e) {
+      return new StripedReadResult(futures.remove(future),
+          StripedReadResult.FAILED);
+    } catch (CancellationException e) {
+      return new StripedReadResult(futures.remove(future),
+          StripedReadResult.CANCELLED);
+    }
+  }
+
+  /**
+   * This class represents the portion of I/O associated with each block in the
+   * striped block group.
+   */
+  public static class ReadPortion {
+    /**
+     * startOffsetInBlock
+     *     |
+     *     v
+     *     |<-lengths[0]->|<-  lengths[1]  ->|<-lengths[2]->|
+     * +------------------+------------------+----------------+
+     * |      cell_0      |      cell_3      |     cell_6     |  <- blk_0
+     * +------------------+------------------+----------------+
+     *   _/                \_______________________
+     *  |                                          |
+     *  v offsetsInBuf[0]                          v offsetsInBuf[1]
+     * +------------------------------------------------------+
+     * |  cell_0     |      cell_1 and cell_2      |cell_3 ...|   <- buf
+     * |  (partial)  |    (from blk_1 and blk_2)   |          |
+     * +------------------------------------------------------+
+     */
+    public long startOffsetInBlock = 0;
+    public int readLength = 0;
+    public final List<Integer> offsetsInBuf = new ArrayList<>();
+    public final List<Integer> lengths = new ArrayList<>();
+
+    public int[] getOffsets() {
+      int[] offsets = new int[offsetsInBuf.size()];
+      for (int i = 0; i < offsets.length; i++) {
+        offsets[i] = offsetsInBuf.get(i);
+      }
+      return offsets;
+    }
+
+    public int[] getLengths() {
+      int[] lens = new int[this.lengths.size()];
+      for (int i = 0; i < lens.length; i++) {
+        lens[i] = this.lengths.get(i);
+      }
+      return lens;
+    }
+
+    public boolean containsReadPortion(ReadPortion rp) {
+      long end = startOffsetInBlock + readLength;
+      return startOffsetInBlock <= rp.startOffsetInBlock && end >=
+          rp.startOffsetInBlock + rp.readLength;
+    }
+  }
+
+  /**
+   * This class represents result from a striped read request.
+   * If the task was successful or the internal computation failed,
+   * an index is also returned.
+   */
+  public static class StripedReadResult {
+    public static final int SUCCESSFUL = 0x01;
+    public static final int FAILED = 0x02;
+    public static final int TIMEOUT = 0x04;
+    public static final int CANCELLED = 0x08;
+
+    public final int index;
+    public final int state;
+
+    public StripedReadResult(int state) {
+      Preconditions.checkArgument(state == TIMEOUT,
+          "Only timeout result should return negative index.");
+      this.index = -1;
+      this.state = state;
+    }
+
+    public StripedReadResult(int index, int state) {
+      Preconditions.checkArgument(state != TIMEOUT,
+          "Timeout result should return negative index.");
+      this.index = index;
+      this.state = state;
+    }
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS55 INS55 INS29 INS78 INS83 INS83 INS5 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS85 INS83 INS39 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS39 INS42 INS60 INS24 INS60 INS60 INS21 INS60 INS24 INS60 INS21 INS21 INS21 INS60 INS24 INS41 INS65 INS65 INS65 INS42 INS74 INS42 INS74 INS42 INS83 INS39 INS42 INS42 INS21 INS21 INS60 INS54 INS65 INS29 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS83 INS74 INS59 INS83 INS83 INS74 INS59 INS83 INS5 INS42 INS8 INS83 INS5 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS65 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS42 INS44 INS8 INS83 INS42 INS44 INS44 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS42 INS5 INS59 INS58 INS27 INS37 INS8 INS39 INS59 INS83 INS39 INS59 INS7 INS39 INS59 INS58 INS27 INS37 INS8 INS39 INS59 INS32 INS32 INS7 INS39 INS59 INS58 INS27 INS7 INS8 INS42 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS43 INS43 INS43 INS74 INS43 INS32 INS32 INS74 INS59 INS8 INS12 INS12 INS66 INS66 INS65 INS42 INS34 INS42 INS34 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS39 INS85 INS60 INS24 INS41 INS39 INS85 INS60 INS24 INS41 INS43 INS42 INS60 INS41 INS66 INS66 INS66 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS42 INS39 INS42 INS21 INS21 INS21 INS39 INS42 INS39 INS42 INS21 INS21 INS21 INS42 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS42 INS42 INS21 INS42 INS11 INS42 INS11 INS22 INS27 INS42 INS9 INS39 INS59 INS42 INS42 INS42 INS25 INS21 INS42 INS32 INS22 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS27 INS39 INS59 INS42 INS42 INS42 INS42 INS60 INS21 INS60 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS38 INS42 INS42 INS27 INS43 INS43 INS42 INS33 INS21 INS25 INS44 INS8 INS44 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS74 INS42 INS42 INS74 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS39 INS59 INS27 INS32 INS7 INS7 INS32 INS7 INS7 INS42 INS5 INS42 INS42 INS34 INS7 INS39 INS36 INS39 INS36 INS2 INS42 INS27 INS27 INS42 INS34 INS27 INS8 INS7 INS42 INS42 INS27 INS42 INS2 INS42 INS2 INS42 INS2 INS42 INS36 INS42 INS42 INS42 INS43 INS59 INS32 INS83 INS39 INS59 INS32 INS7 INS7 INS42 INS42 INS32 INS42 INS34 INS42 INS42 INS7 INS27 INS8 INS8 INS43 INS42 INS41 INS43 INS42 INS41 INS43 INS43 INS39 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 INS39 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 INS42 INS27 INS27 INS27 INS42 INS42 INS27 INS45 INS22 INS38 INS22 INS42 INS42 INS42 INS27 INS45 INS22 INS42 INS22 INS42 INS43 INS85 INS2 INS14 INS27 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS38 INS21 INS21 INS22 INS27 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS2 INS40 INS42 INS27 INS42 INS32 INS40 INS42 INS42 INS40 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS41 INS41 INS42 INS14 INS42 INS14 INS42 INS42 INS5 INS32 INS42 INS34 INS7 INS5 INS32 INS42 INS34 INS7 INS42 INS42 INS42 INS40 INS42 INS27 INS42 INS42 INS52 INS42 INS34 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS43 INS42 INS36 INS27 INS42 INS27 INS42 INS42 INS37 INS7 INS2 INS42 INS42 INS42 INS39 INS36 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS36 INS42 INS42 INS42 INS42 INS40 INS32 INS14 INS14 INS43 INS32 INS40 INS43 INS32 INS40 INS39 INS85 INS42 INS42 INS2 INS32 INS39 INS85 INS22 INS42 INS2 INS32 INS40 INS40 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS27 INS27 INS42 INS42 INS27 INS42 INS42 INS43 INS32 INS40 INS43 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS36 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS27 INS42 INS42
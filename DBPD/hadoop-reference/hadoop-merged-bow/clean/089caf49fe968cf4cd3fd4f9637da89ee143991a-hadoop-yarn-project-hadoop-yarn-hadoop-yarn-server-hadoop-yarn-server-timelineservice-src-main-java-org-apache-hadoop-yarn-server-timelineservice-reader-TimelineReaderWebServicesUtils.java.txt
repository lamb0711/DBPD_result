YARN-4447. Provide a mechanism to represent complex filters and parse them at the REST layer (Varun Saxena via sjlee)

-import java.io.IOException;
-import java.util.HashSet;
-import java.util.Set;
+import org.apache.commons.io.IOUtils;
-import org.apache.hadoop.yarn.server.timeline.GenericObjectMapper;
-import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineCompareFilter;
-import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineCompareOp;
-import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineKeyValueFilter;
-import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineExistsFilter;
-import org.apache.hadoop.yarn.server.timelineservice.reader.filter.TimelineKeyValuesFilter;
-  private static final String COMMA_DELIMITER = ",";
-  private static final String COLON_DELIMITER = ":";
-   * @throws Exception if any problem occurs during parsing.
-      String entityType, String entityId) throws Exception {
+      String entityType, String entityId) {
-   * @throws Exception if any problem occurs during parsing.
+   * @throws TimelineParseException if any problem occurs during parsing.
-      String metricfilters, String eventfilters) throws Exception {
+      String metricfilters, String eventfilters) throws TimelineParseException {
-        parseKeyStrValuesStr(relatesTo, COMMA_DELIMITER, COLON_DELIMITER),
-        parseKeyStrValuesStr(isRelatedTo, COMMA_DELIMITER, COLON_DELIMITER),
-        parseKeyStrValueObj(infofilters, COMMA_DELIMITER, COLON_DELIMITER),
-        parseKeyStrValueStr(conffilters, COMMA_DELIMITER, COLON_DELIMITER),
-        parseMetricFilters(metricfilters, COMMA_DELIMITER),
-        parseValuesStr(eventfilters, COMMA_DELIMITER));
+        parseRelationFilters(relatesTo), parseRelationFilters(isRelatedTo),
+        parseKVFilters(infofilters, false), parseKVFilters(conffilters, true),
+        parseMetricFilters(metricfilters), parseEventFilters(eventfilters));
-   * @throws Exception if any problem occurs during parsing.
+   * @throws TimelineParseException if any problem occurs during parsing.
-      String metrics, String fields) throws Exception {
-    return new TimelineDataToRetrieve(
-        null, null, parseFieldsStr(fields, COMMA_DELIMITER));
+      String metrics, String fields) throws TimelineParseException {
+    return new TimelineDataToRetrieve(parseDataToRetrieve(confs),
+        parseDataToRetrieve(metrics), parseFieldsStr(
+            fields, TimelineParseConstants.COMMA_DELIMITER));
-  static TimelineFilterList parseValuesStr(String str, String delimiter) {
-    if (str == null || str.isEmpty()) {
-      return null;
-    }
-    TimelineFilterList filterList = new TimelineFilterList();
-    String[] strs = str.split(delimiter);
-    for (String aStr : strs) {
-      filterList.addFilter(new TimelineExistsFilter(TimelineCompareOp.EQUAL,
-          aStr.trim()));
-    }
-    return filterList;
-  }
-
-  private static TimelineFilterList parseKeyValues(String str,
-      String pairsDelim, String keyValuesDelim, boolean stringValue,
-      boolean multipleValues) {
-    if (str == null) {
-      return null;
-    }
-    TimelineFilterList list = new TimelineFilterList();
-    String[] pairs = str.split(pairsDelim);
-    for (String pair : pairs) {
-      if (pair == null || pair.trim().isEmpty()) {
-        continue;
-      }
-      String[] pairStrs = pair.split(keyValuesDelim);
-      if (pairStrs.length < 2) {
-        continue;
-      }
-      if (!stringValue) {
-        try {
-          Object value =
-              GenericObjectMapper.OBJECT_READER.readValue(pairStrs[1].trim());
-          list.addFilter(new TimelineKeyValueFilter(TimelineCompareOp.EQUAL,
-              pairStrs[0].trim(), value));
-        } catch (IOException e) {
-          list.addFilter(new TimelineKeyValueFilter(TimelineCompareOp.EQUAL,
-              pairStrs[0].trim(), pairStrs[1].trim()));
-        }
-      } else {
-        String key = pairStrs[0].trim();
-        if (multipleValues) {
-          Set<Object> values = new HashSet<Object>();
-          for (int i = 1; i < pairStrs.length; i++) {
-            values.add(pairStrs[i].trim());
-          }
-          list.addFilter(new TimelineKeyValuesFilter(
-              TimelineCompareOp.EQUAL, key, values));
-        } else {
-          list.addFilter(new TimelineKeyValueFilter(TimelineCompareOp.EQUAL,
-              key, pairStrs[1].trim()));
-        }
-      }
-    }
-    return list;
+  static TimelineFilterList parseEventFilters(String expr)
+      throws TimelineParseException {
+    return parseFilters(new TimelineParserForExistFilters(expr,
+        TimelineParseConstants.COMMA_CHAR));
-   * Parse a delimited string and convert it into a map of key-values with each
-   * key having a set of values. Both the key and values are interpreted as
-   * strings.
-   * For instance, if pairsDelim is "," and keyValuesDelim is ":", then the
-   * string should be represented as
-   * "key1:value11:value12:value13,key2:value21,key3:value31:value32".
-   * @param str delimited string represented as multiple keys having multiple
-   *     values.
-   * @param pairsDelim key-values pairs are delimited by this delimiter.
-   * @param keyValuesDelim values for a key are delimited by this delimiter.
-   * @return a map of key-values with each key having a set of values.
+   * Parse relation filters.
+   * @param expr Relation filter expression
+   * @return a {@link TimelineFilterList} object.
+   *
+   * @throws Exception if any problem occurs.
-  static TimelineFilterList parseKeyStrValuesStr(String str, String pairsDelim,
-      String keyValuesDelim) {
-    return parseKeyValues(str, pairsDelim, keyValuesDelim, true, true);
+  static TimelineFilterList parseRelationFilters(String expr)
+      throws TimelineParseException {
+    return parseFilters(new TimelineParserForRelationFilters(expr,
+        TimelineParseConstants.COMMA_CHAR,
+        TimelineParseConstants.COLON_DELIMITER));
+  }
+
+  private static TimelineFilterList parseFilters(TimelineParser parser)
+      throws TimelineParseException {
+    try {
+      return parser.parse();
+    } finally {
+      IOUtils.closeQuietly(parser);
+    }
-   * Parse a delimited string and convert it into a map of key-value pairs with
-   * both the key and value interpreted as strings.
-   * For instance, if pairsDelim is "," and keyValDelim is ":", then the string
-   * should be represented as "key1:value1,key2:value2,key3:value3".
-   * @param str delimited string represented as key-value pairs.
-   * @param pairsDelim key-value pairs are delimited by this delimiter.
-   * @param keyValDelim key and value are delimited by this delimiter.
-   * @return a map of key-value pairs with both key and value being strings.
+   * Parses config and info filters.
+   *
+   * @param expr Expression to be parsed.
+   * @param valueAsString true, if value has to be interpreted as string, false
+   *     otherwise. It is true for config filters and false for info filters.
+   * @return a {@link TimelineFilterList} object.
+   * @throws TimelineParseException if any problem occurs during parsing.
-  static TimelineFilterList parseKeyStrValueStr(String str, String pairsDelim,
-      String keyValDelim) {
-    return parseKeyValues(str, pairsDelim, keyValDelim, true, false);
-  }
-
-  /**
-   * Parse a delimited string and convert it into a map of key-value pairs with
-   * key being a string and value interpreted as any object.
-   * For instance, if pairsDelim is "," and keyValDelim is ":", then the string
-   * should be represented as "key1:value1,key2:value2,key3:value3".
-   * @param str delimited string represented as key-value pairs.
-   * @param pairsDelim key-value pairs are delimited by this delimiter.
-   * @param keyValDelim key and value are delimited by this delimiter.
-   * @return a map of key-value pairs with key being a string and value, any
-   *     object.
-   */
-  static TimelineFilterList parseKeyStrValueObj(String str, String pairsDelim,
-      String keyValDelim) {
-    return parseKeyValues(str, pairsDelim, keyValDelim, false, false);
+  static TimelineFilterList parseKVFilters(String expr, boolean valueAsString)
+      throws TimelineParseException {
+    return parseFilters(new TimelineParserForKVFilters(expr, valueAsString));
-  static TimelineFilterList parseMetricFilters(String str,
-      String delimiter) {
-    if (str == null || str.isEmpty()) {
-      return null;
-    }
-    TimelineFilterList list = new TimelineFilterList();
-    String[] strs = str.split(delimiter);
-    for (String aStr : strs) {
-      list.addFilter(new TimelineCompareFilter(
-          TimelineCompareOp.GREATER_OR_EQUAL, aStr.trim(), 0L));
-    }
-    return list;
+  /**
+   * Parses metric filters.
+   *
+   * @param expr Metric filter expression to be parsed.
+   * @return a {@link TimelineFilterList} object.
+   * @throws TimelineParseException if any problem occurs during parsing.
+   */
+  static TimelineFilterList parseMetricFilters(String expr)
+      throws TimelineParseException {
+    return parseFilters(new TimelineParserForNumericFilters(expr));
+
+  /**
+   * Parses confstoretrieve and metricstoretrieve.
+   * @param str String representing confs/metrics to retrieve expression.
+   *
+   * @return a {@link TimelineFilterList} object.
+   * @throws TimelineParseException if any problem occurs during parsing.
+   */
+  static TimelineFilterList parseDataToRetrieve(String expr)
+        throws TimelineParseException {
+    return parseFilters(new TimelineParserForDataToRetrieve(expr));
+  }

MOV26 MOV31 UPD40 INS31 INS31 INS31 UPD43 UPD43 MOV29 INS83 MOV43 UPD42 MOV42 MOV44 INS43 INS8 INS29 INS83 MOV43 INS42 MOV44 INS43 INS8 MOV43 UPD42 INS43 INS8 MOV43 UPD42 MOV44 INS43 MOV43 UPD42 INS43 MOV29 MOV83 MOV43 UPD42 MOV42 MOV44 INS43 INS8 UPD42 UPD42 UPD42 UPD42 MOV42 INS41 INS65 INS65 INS65 INS65 UPD42 UPD42 MOV42 INS41 UPD43 UPD42 UPD42 MOV42 MOV54 UPD65 UPD65 UPD42 INS39 INS42 UPD42 MOV42 UPD65 UPD65 MOV43 INS42 UPD42 MOV42 UPD65 UPD65 UPD42 UPD42 MOV42 INS41 UPD42 UPD42 INS32 INS66 INS42 INS66 INS66 INS65 INS66 INS42 INS66 INS32 UPD42 INS8 UPD66 UPD42 UPD66 UPD42 UPD66 INS66 INS66 INS65 UPD66 INS42 UPD66 UPD66 UPD42 UPD66 INS66 INS65 UPD66 UPD42 UPD66 UPD66 UPD66 INS66 INS65 UPD66 UPD42 UPD66 INS32 INS32 INS32 INS42 INS14 INS42 UPD42 MOV42 MOV14 INS41 MOV21 UPD42 MOV42 UPD42 INS14 UPD42 MOV42 UPD42 INS14 UPD42 MOV42 UPD42 MOV42 MOV14 UPD42 UPD42 UPD42 INS9 UPD42 INS9 UPD42 INS42 INS42 INS42 INS42 INS40 UPD43 MOV43 INS42 INS40 UPD43 INS42 UPD40 INS40 INS32 INS43 INS42 INS42 INS43 INS42 UPD43 INS42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL33 DEL42 DEL42 DEL42 DEL32 DEL83 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL33 DEL41 DEL8 DEL25 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL40 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL40 DEL42 DEL34 DEL2 DEL42 DEL32 DEL42 DEL14 DEL32 DEL21 DEL42 DEL42 DEL42 DEL43 DEL40 DEL42 DEL34 DEL2 DEL32 DEL42 DEL34 DEL2 DEL42 DEL32 DEL14 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL33 DEL27 DEL33 DEL41 DEL8 DEL25 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL18 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL34 DEL27 DEL18 DEL8 DEL25 DEL42 DEL38 DEL8 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL42 DEL43 DEL40 DEL42 DEL42 DEL14 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL43 DEL40 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL14 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL8 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL9 DEL9 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL9 DEL9 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL33 DEL41 DEL8 DEL25 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL40 DEL42 DEL42 DEL32 DEL34
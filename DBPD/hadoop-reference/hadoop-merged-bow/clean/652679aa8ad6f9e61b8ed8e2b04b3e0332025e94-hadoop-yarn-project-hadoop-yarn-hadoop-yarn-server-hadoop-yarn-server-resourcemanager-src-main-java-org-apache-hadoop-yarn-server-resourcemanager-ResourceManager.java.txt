YARN-6061. Add an UncaughtExceptionHandler for critical threads in RM. (Yufei Gu via kasha)

+import java.util.concurrent.atomic.AtomicBoolean;
-  
+
-    
+    rmContext.setResourceManager(this);
+
+    private StandByTransitionRunnable standByTransitionRunnable;
+      standByTransitionRunnable = new StandByTransitionRunnable();
+
-  public void handleTransitionToStandBy() {
-    if (rmContext.isHAEnabled()) {
-      try {
-        // Transition to standby and reinit active services
-        LOG.info("Transitioning RM to Standby mode");
-        transitionToStandby(true);
-        EmbeddedElector elector = rmContext.getLeaderElectorService();
-        if (elector != null) {
-          elector.rejoinElection();
+  /**
+   * Transition to standby state in a new thread. The transition operation is
+   * asynchronous to avoid deadlock caused by cyclic dependency.
+   */
+  public void handleTransitionToStandByInNewThread() {
+    Thread standByTransitionThread =
+        new Thread(activeServices.standByTransitionRunnable);
+    standByTransitionThread.setName("StandByTransitionThread");
+    standByTransitionThread.start();
+  }
+
+  /**
+   * The class to transition RM to standby state. The same
+   * {@link StandByTransitionRunnable} object could be used in multiple threads,
+   * but runs only once. That's because RM can go back to active state after
+   * transition to standby state, the same runnable in the old context can't
+   * transition RM to standby state again. A new runnable is created every time
+   * RM transitions to active state.
+   */
+  private class StandByTransitionRunnable implements Runnable {
+    // The atomic variable to make sure multiple threads with the same runnable
+    // run only once.
+    private AtomicBoolean hasAlreadyRun = new AtomicBoolean(false);
+
+    @Override
+    public void run() {
+      // Run this only once, even if multiple threads end up triggering
+      // this simultaneously.
+      if (hasAlreadyRun.getAndSet(true)) {
+        return;
+      }
+
+      if (rmContext.isHAEnabled()) {
+        try {
+          // Transition to standby and reinit active services
+          LOG.info("Transitioning RM to Standby mode");
+          transitionToStandby(true);
+          EmbeddedElector elector = rmContext.getLeaderElectorService();
+          if (elector != null) {
+            elector.rejoinElection();
+          }
+        } catch (Exception e) {
+          LOG.fatal("Failed to transition RM to Standby mode.", e);
+          ExitUtil.terminate(1, e);
-      } catch (Exception e) {
-        LOG.fatal("Failed to transition RM to Standby mode.", e);
-        ExitUtil.terminate(1, e);

INS26 INS40 INS31 INS55 INS23 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS42 INS43 INS23 MOV31 INS21 INS83 INS43 INS59 INS65 INS60 INS21 INS21 INS65 INS42 INS83 INS43 INS59 INS78 UPD42 INS32 INS42 INS42 INS21 INS66 INS66 INS43 INS59 INS32 INS32 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS14 INS42 INS25 INS42 INS42 INS52 INS7 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS9 INS32 INS8 INS42 INS14 INS43 INS40 INS42 INS42 INS42 INS9 INS41 INS43 INS42 INS42
HDFS-1623. High Availability Framework for HDFS NN. Contributed by Todd Lipcon, Aaron T. Myers, Eli Collins, Uma Maheswara Rao G, Bikas Saha, Suresh Srinivas, Jitendra Nath Pandey, Hari Mankude, Brandon Li, Sanjay Radia, Mingjie Lai, and Gregory Chanan


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296534 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.DFSUtil;
+import org.apache.hadoop.hdfs.HAUtil;
-  protected static final Log LOG = LogFactory.getLog(FSImage.class.getName());
+  public static final Log LOG = LogFactory.getLog(FSImage.class.getName());
-                    Collection<URI> imageDirs, Collection<URI> editsDirs)
+                    Collection<URI> imageDirs,
+                    List<URI> editsDirs)
+    String nameserviceId = DFSUtil.getNamenodeNameServiceId(conf);
+    if (!HAUtil.isHAEnabled(conf, nameserviceId)) {
+      editLog.initJournalsForWrite();
+    } else {
+      editLog.initSharedJournalsForRead();
+    }
+        String nameserviceId = DFSUtil.getNamenodeNameServiceId(conf);
+        if (curState != StorageState.NORMAL && HAUtil.isHAEnabled(conf, nameserviceId)) {
+          throw new IOException("Cannot start an HA namenode with name dirs " +
+              "that need recovery. Dir: " + sd + " state: " + curState);
+        }
-        assert !prevDir.exists() : "prvious directory must not exist.";
-        assert !tmpDir.exists() : "prvious.tmp directory must not exist.";
-        assert !editLog.isOpen() : "Edits log must not be open.";
+        assert !prevDir.exists() : "previous directory must not exist.";
+        assert !tmpDir.exists() : "previous.tmp directory must not exist.";
+        assert !editLog.isSegmentOpen() : "Edits log must not be open.";
-    Collection<URI> checkpointEditsDirs =
+    List<URI> checkpointEditsDirs =
-  void openEditLog() throws IOException {
+  void openEditLogForWrite() throws IOException {
-    Preconditions.checkState(!editLog.isOpen(),
-        "edit log should not yet be open");
-    editLog.open();
+    editLog.openForWrite();
-    editLog.recoverUnclosedStreams();
+    if (editLog.isOpenForWrite()) {
+      // We only want to recover streams if we're going into Active mode.
+      editLog.recoverUnclosedStreams();
+    }
+      // If we're open for write, we're either non-HA or we're the active NN, so
+      // we better be able to load all the edits. If we're the standby NN, it's
+      // OK to not be able to read all of edits right now.
+      long toAtLeastTxId = editLog.isOpenForWrite() ? inspector.getMaxSeenTxId() : 0;
-                                               inspector.getMaxSeenTxId());
+          toAtLeastTxId, false);
-  protected long loadEdits(Iterable<EditLogInputStream> editStreams,
-                           FSNamesystem target) throws IOException {
+  public long loadEdits(Iterable<EditLogInputStream> editStreams,
+      FSNamesystem target) throws IOException, EditLogInputException {
-    int numLoaded = 0;
+    long numLoaded = 0;
-        int thisNumLoaded = loader.loadFSEdits(editIn, startingTxId);
-        startingTxId += thisNumLoaded;
-        numLoaded += thisNumLoaded;
-        lastAppliedTxId += thisNumLoaded;
+        long thisNumLoaded = 0;
+        try {
+          thisNumLoaded = loader.loadFSEdits(editIn, startingTxId);
+        } catch (EditLogInputException elie) {
+          thisNumLoaded = elie.getNumEditsLoaded();
+          throw elie;
+        } finally {
+          // Update lastAppliedTxId even in case of error, since some ops may
+          // have been successfully applied before the error.
+          lastAppliedTxId = startingTxId + thisNumLoaded - 1;
+          startingTxId += thisNumLoaded;
+          numLoaded += thisNumLoaded;
+        }
+      // update the counts
+      target.dir.updateCountForINodeWithQuota();   
-
-    // update the counts
-    target.dir.updateCountForINodeWithQuota();    
+    
-   * filenames and blocks.  Return whether we should
-   * "re-save" and consolidate the edit-logs
+   * filenames and blocks.
-  synchronized void saveNamespace(FSNamesystem source) throws IOException {
+  public synchronized void saveNamespace(FSNamesystem source) throws IOException {
-    boolean editLogWasOpen = editLog.isOpen();
+    boolean editLogWasOpen = editLog.isSegmentOpen();
-    long imageTxId = editLog.getLastWrittenTxId();
+    long imageTxId = getLastAppliedOrWrittenTxId();
-  void cancelSaveNamespace(String reason)
+  public void cancelSaveNamespace(String reason)
-  static Collection<URI> getCheckpointEditsDirs(Configuration conf,
+  static List<URI> getCheckpointEditsDirs(Configuration conf,
+  public long getLastAppliedOrWrittenTxId() {
+    return Math.max(lastAppliedTxId,
+        editLog != null ? editLog.getLastWrittenTxId() : 0);
+  }
+
+  public void updateLastAppliedTxIdFromWritten() {
+    this.lastAppliedTxId = editLog.getLastWrittenTxId();
+  }
+
+  public synchronized long getMostRecentCheckpointTxId() {
+    return storage.getMostRecentCheckpointTxId();
+  }

INS26 INS26 INS40 INS40 INS31 INS31 INS31 UPD83 UPD42 UPD83 INS43 INS83 INS83 UPD74 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS8 UPD74 INS60 INS25 INS25 INS42 UPD43 INS41 INS21 INS41 UPD43 INS43 INS59 INS38 INS8 INS8 UPD74 INS32 INS8 UPD39 UPD66 UPD42 INS32 INS7 INS32 UPD42 INS42 INS42 INS32 INS32 INS21 INS21 UPD43 UPD42 INS42 INS42 MOV21 INS60 MOV21 INS32 INS42 INS42 INS42 INS16 INS22 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 UPD42 INS39 INS59 UPD42 INS42 INS27 MOV32 INS34 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS42 INS16 INS54 INS42 INS33 INS43 INS59 INS27 INS8 UPD45 UPD45 INS32 MOV32 INS34 INS42 INS9 UPD39 INS8 INS12 INS8 INS42 INS42 INS32 INS27 INS32 INS53 INS42 INS42 INS34 INS21 INS44 INS8 MOV21 MOV21 MOV21 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS14 UPD42 INS7 INS43 INS42 INS21 INS53 UPD7 INS43 INS27 INS42 MOV32 INS42 INS7 INS42 INS27 INS42 INS27 INS42 INS45 INS42 INS42 INS32 INS27 INS34 INS45 INS45 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL45 DEL32 DEL21 DEL42 DEL66
YARN-2768 Improved Yarn Registry service record structure (stevel)

+import org.apache.commons.lang.StringUtils;
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-  public static final String E_NO_SERVICE_RECORD = "No service record at path";
+  public static final String E_NO_DATA = "No data at path";
+  public static final String E_DATA_TOO_SHORT = "Data at path too short";
+  public static final String E_MISSING_MARKER_STRING =
+      "Missing marker string: ";
-  private final byte[] header;
-   * @param header byte array to use as header
-  public JsonSerDeser(Class<T> classType, byte[] header) {
+  public JsonSerDeser(Class<T> classType) {
-    Preconditions.checkArgument(header != null, "null header");
-    // make an immutable copy to keep findbugs happy.
-    byte[] h = new byte[header.length];
-    System.arraycopy(header, 0, h, 0, header.length);
-    this.header = h;
+  /**
+   * Get the simple name of the class type to be marshalled
+   * @return the name of the class being marshalled
+   */
-    return fromBytes(path.toString(), b, 0);
+    return fromBytes(path.toString(), b);
-      DataOutputStream dataOutputStream) throws
-      IOException {
+      DataOutputStream dataOutputStream) throws IOException {
-   * Convert JSON To bytes, inserting the header
-   * @param instance instance to convert
-   * @return a byte array
-   * @throws IOException
-   */
-  public byte[] toByteswithHeader(T instance) throws IOException {
-    byte[] body = toBytes(instance);
-
-    ByteBuffer buffer = ByteBuffer.allocate(body.length + header.length);
-    buffer.put(header);
-    buffer.put(body);
-    return buffer.array();
-  }
-
-  /**
-   * @return offset in the array to read from
-  public T fromBytes(String path, byte[] bytes, int offset) throws IOException,
+  public T fromBytes(String path, byte[] bytes) throws IOException,
-    int data = bytes.length - offset;
-    if (data <= 0) {
-      throw new EOFException("No data at " + path);
+    return fromBytes(path, bytes, "");
+  }
+
+  /**
+   * Deserialize from a byte array, optionally checking for a marker string.
+   * <p>
+   * If the marker parameter is supplied (and not empty), then its presence
+   * will be verified before the JSON parsing takes place; it is a fast-fail
+   * check. If not found, an {@link InvalidRecordException} exception will be
+   * raised
+   * @param path path the data came from
+   * @param bytes byte array
+   * @param marker an optional string which, if set, MUST be present in the
+   * UTF-8 parsed payload.
+   * @return The parsed record
+   * @throws IOException all problems
+   * @throws EOFException not enough data
+   * @throws InvalidRecordException if the JSON parsing failed.
+   * @throws NoRecordException if the data is not considered a record: either
+   * it is too short or it did not contain the marker string.
+   */
+  public T fromBytes(String path, byte[] bytes, String marker)
+      throws IOException, NoRecordException, InvalidRecordException {
+    int len = bytes.length;
+    if (len == 0 ) {
+      throw new NoRecordException(path, E_NO_DATA);
-    String json = new String(bytes, offset, data, UTF_8);
+    if (StringUtils.isNotEmpty(marker) && len < marker.length()) {
+      throw new NoRecordException(path, E_DATA_TOO_SHORT);
+    }
+    String json = new String(bytes, 0, len, UTF_8);
+    if (StringUtils.isNotEmpty(marker)
+        && !json.contains(marker)) {
+      throw new NoRecordException(path, E_MISSING_MARKER_STRING + marker);
+    }
-   * Read from a byte array to a type, checking the header first
-   * @param path source of data
-   * @param buffer buffer
-   * @return the parsed structure
-   * Null if the record was too short or the header did not match
-   * @throws IOException on a failure
-   * @throws NoRecordException if header checks implied there was no record
-   * @throws InvalidRecordException if record parsing failed
-   */
-  @SuppressWarnings("unchecked")
-  public T fromBytesWithHeader(String path, byte[] buffer) throws IOException {
-    int hlen = header.length;
-    int blen = buffer.length;
-    if (hlen > 0) {
-      if (blen < hlen) {
-        throw new NoRecordException(path, E_NO_SERVICE_RECORD);
-      }
-      byte[] magic = Arrays.copyOfRange(buffer, 0, hlen);
-      if (!Arrays.equals(header, magic)) {
-        LOG.debug("start of entry does not match service record header at {}",
-            path);
-        throw new NoRecordException(path, E_NO_SERVICE_RECORD);
-      }
-    }
-    return fromBytes(path, buffer, hlen);
-  }
-
-  /**
-   * Check if a buffer has a header which matches this record type
-   * @param buffer buffer
-   * @return true if there is a match
-   * @throws IOException
-   */
-  public boolean headerMatches(byte[] buffer) throws IOException {
-    int hlen = header.length;
-    int blen = buffer.length;
-    boolean matches = false;
-    if (blen > hlen) {
-      byte[] magic = Arrays.copyOfRange(buffer, 0, hlen);
-      matches = Arrays.equals(header, magic);
-    }
-    return matches;
-  }
-
-  /**
-   * Convert an object to a JSON string
+   * Convert an instance to a JSON string
+  /**
+   * Convert an instance to a string form for output. This is a robust
+   * operation which will convert any JSON-generating exceptions into
+   * error text.
+   * @param instance non-null instance
+   * @return a JSON string
+   */
+  public String toString(T instance) {
+    Preconditions.checkArgument(instance != null, "Null instance argument");
+    try {
+      return toJson(instance);
+    } catch (IOException e) {
+      return "Failed to convert to a string: " + e;
+    }
+  }

MOV26 MOV23 MOV31 UPD40 INS23 UPD83 INS83 INS43 INS83 INS83 INS83 INS43 INS59 INS29 MOV43 MOV44 MOV43 INS43 INS8 MOV43 UPD42 MOV44 MOV44 MOV43 UPD43 MOV43 INS43 INS42 MOV44 UPD42 UPD45 INS42 UPD42 INS45 UPD42 MOV42 UPD42 MOV42 INS45 INS65 INS65 INS5 UPD42 UPD42 MOV42 INS41 INS65 INS65 INS43 UPD42 UPD42 INS25 INS25 INS60 INS25 MOV54 INS42 INS21 INS54 INS66 INS66 INS39 INS85 INS32 UPD66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 UPD66 UPD42 UPD66 INS42 INS66 INS66 UPD66 UPD66 UPD42 UPD66 UPD66 INS42 INS66 INS66 INS42 UPD27 MOV27 MOV8 INS27 MOV8 MOV43 INS59 INS27 INS8 UPD66 UPD66 INS66 INS66 UPD42 UPD66 UPD66 INS32 INS8 INS12 INS42 INS42 INS42 INS45 INS42 UPD42 UPD40 UPD42 INS32 INS27 INS42 INS14 INS32 INS38 INS53 INS42 INS42 INS27 INS45 INS41 INS44 INS8 INS42 INS42 INS42 INS42 INS32 MOV43 INS42 INS34 INS42 INS42 INS42 INS42 INS42 MOV32 INS14 UPD42 MOV42 INS33 INS32 MOV43 INS42 MOV41 INS43 UPD42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 INS27 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 INS42 INS45 INS42 DEL40 DEL26 DEL39 DEL85 DEL5 DEL42 DEL66 DEL65 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL42 DEL33 DEL27 DEL45 DEL32 DEL21 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL40 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL34 DEL42 DEL34 DEL40 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL34 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL40 DEL40 DEL27 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL39 DEL39 DEL42 DEL40 DEL42 DEL27 DEL59 DEL60 DEL42 DEL34 DEL27 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL8 DEL66 DEL42 DEL45 DEL79 DEL39 DEL85 DEL5 DEL39 DEL42 DEL40 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL27 DEL25 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL59 DEL60 DEL38 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL42 DEL65 DEL39 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL39 DEL42 DEL40 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL27 DEL39 DEL85 DEL5 DEL42 DEL42 DEL34 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25
HDDS-1986. Fix listkeys API. (#1588)


+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+    if (maxKeys <= 0) {
+      return result;
+    }
+
-    try (TableIterator<String, ? extends KeyValue<String, OmKeyInfo>> keyIter =
-        getKeyTable()
-            .iterator()) {
-      KeyValue<String, OmKeyInfo> kv = keyIter.seek(seekKey);
-      while (currentCount < maxKeys && keyIter.hasNext()) {
-        kv = keyIter.next();
-        // Skip the Start key if needed.
-        if (kv != null && skipStartKey && kv.getKey().equals(seekKey)) {
-          continue;
+
+
+    TreeMap<String, OmKeyInfo> cacheKeyMap = new TreeMap<>();
+    Set<String> deletedKeySet = new TreeSet<>();
+    Iterator<Map.Entry<CacheKey<String>, CacheValue<OmKeyInfo>>> iterator =
+        keyTable.cacheIterator();
+
+    //TODO: We can avoid this iteration if table cache has stored entries in
+    // treemap. Currently HashMap is used in Cache. HashMap get operation is an
+    // constant time operation, where as for treeMap get is log(n).
+    // So if we move to treemap, the get operation will be affected. As get
+    // is frequent operation on table. So, for now in list we iterate cache map
+    // and construct treeMap which match with keyPrefix and are greater than or
+    // equal to startKey. Later we can revisit this, if list operation
+    // is becoming slow.
+    while (iterator.hasNext()) {
+      Map.Entry< CacheKey<String>, CacheValue<OmKeyInfo>> entry =
+          iterator.next();
+
+      String key = entry.getKey().getCacheKey();
+      OmKeyInfo omKeyInfo = entry.getValue().getCacheValue();
+      // Making sure that entry in cache is not for delete key request.
+
+      if (omKeyInfo != null) {
+        if (key.startsWith(seekPrefix) && key.compareTo(seekKey) >= 0) {
+          cacheKeyMap.put(key, omKeyInfo);
+      } else {
+        deletedKeySet.add(key);
+      }
+    }
+
+    // Get maxKeys from DB if it has.
+
+    try (TableIterator<String, ? extends KeyValue<String, OmKeyInfo>>
+             keyIter = getKeyTable().iterator()) {
+      KeyValue< String, OmKeyInfo > kv;
+      keyIter.seek(seekKey);
+      // we need to iterate maxKeys + 1 here because if skipStartKey is true,
+      // we should skip that entry and return the result.
+      while (currentCount < maxKeys + 1 && keyIter.hasNext()) {
+        kv = keyIter.next();
-          result.add(kv.getValue());
-          currentCount++;
+
+          // Entry should not be marked for delete, consider only those
+          // entries.
+          if(!deletedKeySet.contains(kv.getKey())) {
+            cacheKeyMap.put(kv.getKey(), kv.getValue());
+            currentCount++;
+          }
+
+    // Finally DB entries and cache entries are merged, then return the count
+    // of maxKeys from the sorted map.
+    currentCount = 0;
+
+    for (Map.Entry<String, OmKeyInfo>  cacheKey : cacheKeyMap.entrySet()) {
+      if (cacheKey.getKey().equals(seekKey) && skipStartKey) {
+        continue;
+      }
+
+      result.add(cacheKey.getValue());
+      currentCount++;
+
+      if (currentCount == maxKeys) {
+        break;
+      }
+    }
+
+    // Clear map and set.
+    cacheKeyMap.clear();
+    deletedKeySet.clear();
+

INS26 INS26 INS26 INS40 INS40 INS40 INS25 INS60 INS60 INS60 INS61 INS21 INS70 INS21 INS21 INS27 INS8 INS74 INS59 INS74 INS59 INS74 INS59 INS32 INS8 INS7 INS44 INS32 INS8 INS32 INS32 INS42 INS34 INS41 INS43 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS74 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS25 INS21 INS42 INS34 INS74 INS42 INS42 INS42 INS25 INS21 INS21 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS43 INS74 INS74 INS42 INS42 INS74 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS8 MOV32 INS43 INS43 INS43 INS27 MOV8 INS32 INS37 INS27 INS8 INS43 INS43 INS40 INS43 INS43 INS43 INS43 INS43 INS74 INS74 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS25 INS21 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS10 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS43 INS43 INS43 INS43 INS42 INS42 INS32 INS42 INS32 INS42 INS27 INS8 INS32 INS27 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS21 INS42 INS42 INS42 MOV42 INS34 INS25 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS32 INS38 MOV8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 MOV32 INS42 INS42 INS42 INS42 MOV32 DEL42 DEL33 DEL27 DEL42 DEL27 DEL27 DEL25 DEL42 DEL42 DEL32
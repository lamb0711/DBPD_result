HDFS-9543. DiskBalancer: Add Data mover. Contributed by Anu Engineer.

-import org.apache.hadoop.hdfs.server.datanode.DiskBalancerWorkStatus.DiskBalancerWorkEntry;
+import org.apache.hadoop.hdfs.protocol.ExtendedBlock;
+import org.apache.hadoop.hdfs.server.datanode.DiskBalancerWorkStatus
+    .DiskBalancerWorkEntry;
+import java.util.List;
+import java.util.LinkedList;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
- * <p/>
+ * <p>
- * <p/>
+ * <p>
- * <p/>
+ * <p>
- * <p/>
+ * <p>
+    final int secondsTowait = 10;
-      if(!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
+      if (!scheduler.awaitTermination(secondsTowait, TimeUnit.SECONDS)) {
-        if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
+        if (!scheduler.awaitTermination(secondsTowait, TimeUnit.SECONDS)) {
+   *
-                               boolean force) throws DiskBalancerException {
+                              boolean force) throws DiskBalancerException {
-           Integer.toString(DiskBalancerConstants.DISKBALANCER_VALID_PLAN_HOURS)
-          +  " hours ago.";
+          Integer.toString(DiskBalancerConstants.DISKBALANCER_VALID_PLAN_HOURS)
+          + " hours ago.";
-   * @param source      - Source vol
-   * @param dest        - destination volume
-   * @param step        - Move Step
+   * @param source - Source vol
+   * @param dest   - destination volume
+   * @param step   - Move Step
-    if(source.getStorageID().equals(dest.getStorageID())) {
+    if (source.getStorageID().equals(dest.getStorageID())) {
-   * <p/>
+   * <p>
+    private int poolIndex;
+    private AtomicBoolean shouldRun;
+      shouldRun = new AtomicBoolean(false);
+     * Sets Diskmover copyblocks into runnable state.
+     */
+    @Override
+    public void setRunnable() {
+      this.shouldRun.set(true);
+    }
+
+    /**
+     * Signals copy block to exit.
+     */
+    @Override
+    public void setExitFlag() {
+      this.shouldRun.set(false);
+    }
+
+    /**
+     * Returns the shouldRun boolean flag.
+     */
+    public boolean shouldRun() {
+      return this.shouldRun.get();
+    }
+
+    /**
+     * Checks if a given block is less than needed size to meet our goal.
+     *
+     * @param blockSize - block len
+     * @param item      - Work item
+     * @return true if this block meets our criteria, false otherwise.
+     */
+    private boolean isLessThanNeeded(long blockSize,
+                                     DiskBalancerWorkItem item) {
+      long bytesToCopy = item.getBytesToCopy() - item.getBytesCopied();
+      bytesToCopy = bytesToCopy +
+          ((bytesToCopy * getBlockTolerancePercentage(item)) / 100);
+      return (blockSize <= bytesToCopy) ? true : false;
+    }
+
+    /**
+     * Returns the default block tolerance if the plan does not have value of
+     * tolerance specified.
+     *
+     * @param item - DiskBalancerWorkItem
+     * @return long
+     */
+    private long getBlockTolerancePercentage(DiskBalancerWorkItem item) {
+      return item.getTolerancePercent() <= 0 ? this.blockTolerance :
+          item.getTolerancePercent();
+    }
+
+    /**
+     * Inflates bytesCopied and returns true or false. This allows us to stop
+     * copying if we have reached close enough.
+     *
+     * @param item DiskBalancerWorkItem
+     * @return -- false if we need to copy more, true if we are done
+     */
+    private boolean isCloseEnough(DiskBalancerWorkItem item) {
+      long temp = item.getBytesCopied() +
+          ((item.getBytesCopied() * getBlockTolerancePercentage(item)) / 100);
+      return (item.getBytesToCopy() >= temp) ? false : true;
+    }
+
+    /**
+     * Returns disk bandwidth associated with this plan, if none is specified
+     * returns the global default.
+     *
+     * @param item DiskBalancerWorkItem.
+     * @return MB/s - long
+     */
+    private long getDiskBandwidth(DiskBalancerWorkItem item) {
+      return item.getBandwidth() <= 0 ? this.diskBandwidth : item
+          .getBandwidth();
+    }
+
+    /**
+     * Computes sleep delay needed based on the block that just got copied. we
+     * copy using a burst mode, that is we let the copy proceed in full
+     * throttle. Once a copy is done, we compute how many bytes have been
+     * transferred and try to average it over the user specified bandwidth. In
+     * other words, This code implements a poor man's token bucket algorithm for
+     * traffic shaping.
+     *
+     * @param bytesCopied - byteCopied.
+     * @param timeUsed    in milliseconds
+     * @param item        DiskBalancerWorkItem
+     * @return sleep delay in Milliseconds.
+     */
+    private long computeDelay(long bytesCopied, long timeUsed,
+                              DiskBalancerWorkItem item) {
+
+      // we had an overflow, ignore this reading and continue.
+      if (timeUsed == 0) {
+        return 0;
+      }
+      final int megaByte = 1024 * 1024;
+      long bytesInMB = bytesCopied / megaByte;
+      long lastThroughput = bytesInMB / SECONDS.convert(timeUsed,
+          TimeUnit.MILLISECONDS);
+      long delay = (bytesInMB / getDiskBandwidth(item)) - lastThroughput;
+      return (delay <= 0) ? 0 : MILLISECONDS.convert(delay, TimeUnit.SECONDS);
+    }
+
+    /**
+     * Returns maximum errors to tolerate for the specific plan or the default.
+     *
+     * @param item - DiskBalancerWorkItem
+     * @return maximum error counts to tolerate.
+     */
+    private long getMaxError(DiskBalancerWorkItem item) {
+      return item.getMaxDiskErrors() <= 0 ? this.maxDiskErrors :
+          item.getMaxDiskErrors();
+    }
+
+    /**
+     * Gets the next block that we can copy, returns null if we cannot find a
+     * block that fits our parameters or if have run out of blocks.
+     *
+     * @param iter Block Iter
+     * @param item - Work item
+     * @return Extended block or null if no copyable block is found.
+     */
+    private ExtendedBlock getBlockToCopy(FsVolumeSpi.BlockIterator iter,
+                                         DiskBalancerWorkItem item) {
+      while (!iter.atEnd() && item.getErrorCount() < getMaxError(item)) {
+        try {
+          ExtendedBlock block = iter.nextBlock();
+
+          // A valid block is a finalized block, we iterate until we get
+          // finalized blocks
+          if (!this.dataset.isValidBlock(block)) {
+            continue;
+          }
+
+          // We don't look for the best, we just do first fit
+          if (isLessThanNeeded(block.getNumBytes(), item)) {
+            return block;
+          }
+
+        } catch (IOException e) {
+          item.incErrorCount();
+        }
+      }
+
+      if (item.getErrorCount() >= getMaxError(item)) {
+        item.setErrMsg("Error count exceeded.");
+        LOG.info("Maximum error count exceeded. Error count: {} Max error:{} "
+            , item.getErrorCount(), item.getMaxDiskErrors());
+      }
+
+      return null;
+    }
+
+    /**
+     * Opens all Block pools on a given volume.
+     *
+     * @param source    Source
+     * @param poolIters List of PoolIters to maintain.
+     */
+    private void openPoolIters(FsVolumeSpi source, List<FsVolumeSpi
+        .BlockIterator> poolIters) {
+      Preconditions.checkNotNull(source);
+      Preconditions.checkNotNull(poolIters);
+
+      for (String blockPoolID : source.getBlockPoolList()) {
+        poolIters.add(source.newBlockIterator(blockPoolID,
+            "DiskBalancerSource"));
+      }
+    }
+
+    /**
+     * Returns the next block that we copy from all the block pools. This
+     * function looks across all block pools to find the next block to copy.
+     *
+     * @param poolIters - List of BlockIterators
+     * @return ExtendedBlock.
+     */
+    ExtendedBlock getNextBlock(List<FsVolumeSpi.BlockIterator> poolIters,
+                               DiskBalancerWorkItem item) {
+      Preconditions.checkNotNull(poolIters);
+      int currentCount = 0;
+      ExtendedBlock block = null;
+      while (block == null && currentCount < poolIters.size()) {
+        currentCount++;
+        poolIndex = poolIndex++ % poolIters.size();
+        FsVolumeSpi.BlockIterator currentPoolIter = poolIters.get(poolIndex);
+        block = getBlockToCopy(currentPoolIter, item);
+      }
+
+      if (block == null) {
+        try {
+          item.setErrMsg("No source blocks found to move.");
+          LOG.error("No movable source blocks found. {}", item.toJson());
+        } catch (IOException e) {
+          LOG.error("Unable to get json from Item.");
+        }
+      }
+      return block;
+    }
+
+    /**
+     * Close all Pool Iters.
+     *
+     * @param poolIters List of BlockIters
+     */
+    private void closePoolIters(List<FsVolumeSpi.BlockIterator> poolIters) {
+      Preconditions.checkNotNull(poolIters);
+      for (FsVolumeSpi.BlockIterator iter : poolIters) {
+        try {
+          iter.close();
+        } catch (IOException ex) {
+          LOG.error("Error closing a block pool iter. ex: {}", ex);
+        }
+      }
+    }
+
+    /**
+      FsVolumeSpi source = pair.getSource();
+      FsVolumeSpi dest = pair.getDest();
+      List<FsVolumeSpi.BlockIterator> poolIters = new LinkedList<>();
-    }
+      if (source.isTransientStorage() || dest.isTransientStorage()) {
+        return;
+      }
-    /**
-     * Begin the actual copy operations. This is useful in testing.
-     */
-    @Override
-    public void setRunnable() {
+      try {
+        openPoolIters(source, poolIters);
+        if (poolIters.size() == 0) {
+          LOG.error("No block pools found on volume. volume : {}. Exiting.",
+              source.getBasePath());
+          return;
+        }
-    }
+        while (shouldRun()) {
+          try {
-    /**
-     * Tells copyBlocks to exit from the copy routine.
-     */
-    @Override
-    public void setExitFlag() {
+            // Check for the max error count constraint.
+            if (item.getErrorCount() > getMaxError(item)) {
+              LOG.error("Exceeded the max error count. source {}, dest: {} " +
+                      "error count: {}", source.getBasePath(),
+                  dest.getBasePath(), item.getErrorCount());
+              this.setExitFlag();
+              continue;
+            }
+            // Check for the block tolerance constraint.
+            if (isCloseEnough(item)) {
+              LOG.info("Copy from {} to {} done. copied {} bytes and {} " +
+                      "blocks.",
+                  source.getBasePath(), dest.getBasePath(),
+                  item.getBytesCopied(), item.getBlocksCopied());
+              this.setExitFlag();
+              continue;
+            }
+
+            ExtendedBlock block = getNextBlock(poolIters, item);
+            // we are not able to find any blocks to copy.
+            if (block == null) {
+              this.setExitFlag();
+              LOG.error("No source blocks, exiting the copy. Source: {}, " +
+                      "dest:{}", source.getBasePath(), dest.getBasePath());
+              continue;
+            }
+
+            // check if someone told us exit, treat this as an interruption
+            // point
+            // for the thread, since both getNextBlock and moveBlocAcrossVolume
+            // can take some time.
+            if (!shouldRun()) {
+              continue;
+            }
+
+            long timeUsed;
+            // There is a race condition here, but we will get an IOException
+            // if dest has no space, which we handle anyway.
+            if (dest.getAvailable() > item.getBytesToCopy()) {
+              long begin = System.nanoTime();
+              this.dataset.moveBlockAcrossVolumes(block, dest);
+              long now = System.nanoTime();
+              timeUsed = (now - begin) > 0 ? now - begin : 0;
+            } else {
+
+              // Technically it is possible for us to find a smaller block and
+              // make another copy, but opting for the safer choice of just
+              // exiting here.
+              LOG.error("Destination volume: {} does not have enough space to" +
+                  " accommodate a block. Block Size: {} Exiting from" +
+                  " copyBlocks.", dest.getBasePath(), block.getNumBytes());
+              this.setExitFlag();
+              continue;
+            }
+
+            LOG.debug("Moved block with size {} from  {} to {}",
+                block.getNumBytes(), source.getBasePath(),
+                dest.getBasePath());
+
+            item.incCopiedSoFar(block.getNumBytes());
+            item.incBlocksCopied();
+
+            // Check for the max throughput constraint.
+            // We sleep here to keep the promise that we will not
+            // copy more than Max MB/sec. we sleep enough time
+            // to make sure that our promise is good on average.
+            // Because we sleep, if a shutdown or cancel call comes in
+            // we exit via Thread Interrupted exception.
+            Thread.sleep(computeDelay(block.getNumBytes(), timeUsed, item));
+
+          } catch (IOException ex) {
+            LOG.error("Exception while trying to copy blocks. error: {}", ex);
+            item.incErrorCount();
+          } catch (InterruptedException e) {
+            LOG.error("Copy Block Thread interrupted, exiting the copy.");
+            Thread.currentThread().interrupt();
+            item.incErrorCount();
+            this.setExitFlag();
+          }
+        }
+      } finally {
+        // Close all Iters.
+        closePoolIters(poolIters);
+      }

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 UPD66 UPD66 UPD66 UPD66 INS60 INS83 INS39 INS59 INS83 INS43 INS59 INS29 MOV78 UPD42 UPD42 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 MOV29 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 MOV29 MOV78 MOV83 MOV39 INS42 MOV44 MOV44 INS8 INS83 INS39 INS59 UPD66 UPD66 UPD66 UPD66 INS42 INS42 INS42 INS21 INS65 INS21 INS21 INS65 INS41 INS65 INS65 INS65 INS65 INS39 INS42 INS43 INS42 INS60 INS21 INS41 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS65 INS65 INS43 INS42 INS60 INS41 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS39 INS42 INS43 INS42 INS25 INS60 INS60 INS60 INS60 INS41 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS61 INS25 INS41 INS65 INS65 INS65 INS43 INS42 INS74 INS42 INS21 INS21 INS70 INS65 INS65 INS42 INS74 INS42 INS43 INS42 INS21 INS60 INS60 INS61 INS25 INS41 INS65 INS65 INS74 INS42 INS21 INS70 INS60 INS60 INS60 INS25 INS54 INS42 INS34 INS7 INS66 INS32 UPD66 INS32 INS66 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS39 INS59 INS7 INS16 INS66 INS66 INS42 INS66 INS66 INS42 INS16 INS66 INS66 INS42 INS66 INS66 INS42 INS39 INS59 INS16 INS66 INS66 INS42 INS66 INS66 INS42 INS16 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS83 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS16 INS66 INS42 INS66 INS66 INS42 INS16 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS40 INS42 INS27 INS8 INS27 INS8 INS33 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS43 INS32 INS32 INS44 INS32 INS8 UPD66 INS66 INS42 INS66 INS66 INS43 INS43 INS42 INS32 INS39 INS59 INS43 INS59 INS27 INS8 INS27 INS8 INS42 INS66 INS42 INS66 INS43 INS43 INS32 INS44 INS42 INS8 INS43 INS59 INS43 INS59 INS74 INS59 INS27 INS8 INS8 INS8 INS42 INS14 INS22 INS42 INS9 INS22 INS42 INS9 INS22 INS42 INS42 INS27 INS42 INS27 INS36 INS9 INS9 INS27 INS22 INS32 INS42 INS27 INS36 INS9 INS9 INS27 INS22 INS32 INS42 INS34 INS41 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS36 INS34 INS32 INS27 INS22 INS32 INS38 INS27 INS54 INS32 INS32 INS21 INS21 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS21 INS42 INS40 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS33 INS27 INS27 INS21 INS21 INS60 INS21 INS42 INS33 INS54 INS42 INS40 INS42 INS42 INS42 INS43 INS42 INS54 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS32 INS32 INS41 INS21 INS25 INS61 INS21 INS43 INS9 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS32 INS42 INS36 INS27 INS32 INS34 INS52 INS42 INS42 INS42 INS32 INS36 INS27 INS32 INS34 INS52 INS42 INS42 INS42 INS34 INS34 INS34 INS42 INS42 INS42 INS32 INS36 INS42 INS27 INS42 INS42 INS42 INS40 INS32 INS34 INS52 INS42 INS42 INS42 INS32 INS32 INS32 INS8 INS12 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS33 INS42 INS32 INS37 INS7 INS43 INS59 INS7 INS8 INS12 INS40 INS8 INS12 INS42 INS42 INS42 INS42 INS42 INS40 INS74 INS42 INS42 INS42 INS42 INS32 INS27 INS8 INS32 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS27 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS25 INS44 INS8 INS42 INS42 INS45 INS42 INS42 INS45 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS40 INS42 INS32 INS42 INS32 INS21 INS21 INS44 INS8 INS21 INS44 INS8 INS43 INS42 INS42 INS42 INS32 INS34 INS21 INS41 INS42 INS54 INS42 INS42 INS36 INS34 INS36 INS34 INS42 INS42 INS42 INS32 INS43 INS59 INS38 INS8 INS32 INS8 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS37 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS43 INS42 INS21 INS32 INS43 INS42 INS21 INS42 INS42 INS42 INS32 INS8 INS12 INS12 INS42 INS27 INS27 INS42 INS42 INS42 INS42 INS32 INS32 INS18 INS42 INS32 INS42 INS41 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS32 INS25 INS25 INS60 INS25 INS25 INS60 INS25 INS21 INS21 INS21 INS21 INS44 INS8 INS44 INS8 INS42 INS32 INS32 INS32 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS42 INS27 INS8 INS32 INS8 INS43 INS59 INS27 INS8 INS38 INS8 INS39 INS59 INS27 INS8 INS8 INS32 INS32 INS32 INS32 INS43 INS42 INS21 INS21 INS43 INS42 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS32 INS32 INS21 INS21 INS18 INS42 INS42 INS21 INS21 INS18 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS18 INS32 INS18 INS42 INS32 INS32 INS60 INS21 INS60 INS21 INS21 INS21 INS18 INS42 INS42 INS45 INS32 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS39 INS59 INS32 INS39 INS59 INS7 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS27 INS32 INS32 INS32 INS52 INS42 INS42 INS42 INS27 INS32 INS32 INS32 INS32 INS52 INS42 INS52 INS42 INS42 INS42 INS27 INS32 INS32 INS42 INS32 INS22 INS42 INS42 INS42 INS42 INS32 INS42 INS16 INS42 INS42 INS27 INS32 INS32 INS52 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS27 INS27 INS34 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS36 INS34 INS42 INS42 INS27 INS42 INS42 DEL34 DEL34 DEL42 DEL8 DEL31
YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.

-import java.util.Set;
-import org.apache.hadoop.security.Groups;
-import org.apache.hadoop.util.ReflectionUtils;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.DefaultPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.FSPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.PlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.PrimaryGroupPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.RejectPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.SecondaryGroupExistingPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.SpecifiedPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.UserPlacementRule;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import static org.apache.hadoop.yarn.server.resourcemanager.placement.PlacementFactory.getPlacementRule;
+
+/**
+ * The FairScheduler rules based policy for placing an application in a queue.
+ * It parses the configuration and updates the {@link
+ * org.apache.hadoop.yarn.server.resourcemanager.placement.PlacementManager}
+ * with a list of {@link PlacementRule}s to execute in order.
+ */
-public class QueuePlacementPolicy {
-  private static final Map<String, Class<? extends QueuePlacementRule>> ruleClasses;
-  static {
-    Map<String, Class<? extends QueuePlacementRule>> map =
-        new HashMap<String, Class<? extends QueuePlacementRule>>();
-    map.put("user", QueuePlacementRule.User.class);
-    map.put("primaryGroup", QueuePlacementRule.PrimaryGroup.class);
-    map.put("secondaryGroupExistingQueue",
-        QueuePlacementRule.SecondaryGroupExistingQueue.class);
-    map.put("specified", QueuePlacementRule.Specified.class);
-    map.put("nestedUserQueue",
-        QueuePlacementRule.NestedUserQueue.class);
-    map.put("default", QueuePlacementRule.Default.class);
-    map.put("reject", QueuePlacementRule.Reject.class);
-    ruleClasses = Collections.unmodifiableMap(map);
+final class QueuePlacementPolicy {
+  private static final Logger LOG =
+      LoggerFactory.getLogger(QueuePlacementPolicy.class);
+
+  // Simple private class to make the rule mapping simpler.
+  private static final class RuleMap {
+    private final Class<? extends PlacementRule> ruleClass;
+    private final String terminal;
+
+    private RuleMap(Class<? extends PlacementRule> clazz, String terminate) {
+      this.ruleClass = clazz;
+      this.terminal = terminate;
+    }
-  
-  private final List<QueuePlacementRule> rules;
-  private final Map<FSQueueType, Set<String>> configuredQueues;
-  private final Groups groups;
-  
-  public QueuePlacementPolicy(List<QueuePlacementRule> rules,
-      Map<FSQueueType, Set<String>> configuredQueues, Configuration conf)
+
+  // The list of known rules:
+  // key to the map is the name in the configuration.
+  // for each name the mapping contains the class name of the implementation
+  // and a flag (true, false or create) which describes the terminal state
+  // see the method getTerminal() for more comments.
+  private static final Map<String, RuleMap> RULES;
+  static {
+    Map<String, RuleMap> map = new HashMap<>();
+    map.put("user", new RuleMap(UserPlacementRule.class, "create"));
+    map.put("primaryGroup",
+        new RuleMap(PrimaryGroupPlacementRule.class, "create"));
+    map.put("secondaryGroupExistingQueue",
+        new RuleMap(SecondaryGroupExistingPlacementRule.class, "false"));
+    map.put("specified", new RuleMap(SpecifiedPlacementRule.class, "false"));
+    map.put("nestedUserQueue", new RuleMap(UserPlacementRule.class, "create"));
+    map.put("default", new RuleMap(DefaultPlacementRule.class, "create"));
+    map.put("reject", new RuleMap(RejectPlacementRule.class, "true"));
+    RULES = Collections.unmodifiableMap(map);
+  }
+
+  private QueuePlacementPolicy() {
+  }
+
+  /**
+   * Update the rules in the manager based on this placement policy.
+   * @param newRules The new list of rules to set in the manager.
+   * @param newTerminalState The list of terminal states for this set of rules.
+   * @param fs the reference to the scheduler needed in the rule on init.
+   * @throws AllocationConfigurationException for any errors
+   */
+  private static void updateRuleSet(List<PlacementRule> newRules,
+                                    List<Boolean> newTerminalState,
+                                    FairScheduler fs)
-    for (int i = 0; i < rules.size()-1; i++) {
-      if (rules.get(i).isTerminal()) {
+    if (newRules.isEmpty()) {
+      LOG.debug("Empty rule set defined, ignoring update");
+      return;
+    }
+    LOG.debug("Placement rule order check");
+    for (int i = 0; i < newTerminalState.size()-1; i++) {
+      if (newTerminalState.get(i)) {
-            + i + " in queue placement policy can never be reached");
+            + (i+1) + " in queue placement policy can never be reached");
-    if (!rules.get(rules.size()-1).isTerminal()) {
+    if (!newTerminalState.get(newTerminalState.size()-1)) {
-    this.rules = rules;
-    this.configuredQueues = configuredQueues;
-    groups = new Groups(conf);
+    // Set the scheduler in the rule to get queues etc
+    LOG.debug("Initialising new rule set");
+    try {
+      for (PlacementRule rule: newRules){
+        rule.initialize(fs);
+      }
+    } catch (IOException ioe) {
+      // We should never throw as we pass in a FS object, however we still
+      // should consider any exception here a config error.
+      throw new AllocationConfigurationException(
+          "Rule initialisation failed with exception", ioe);
+    }
+    // Update the placement manager with the new rule list.
+    // We only get here when all rules are OK.
+    fs.getRMContext().getQueuePlacementManager().updateRules(newRules);
+    LOG.debug("PlacementManager active with new rule set");
-  
+
-   * Builds a QueuePlacementPolicy from an xml element.
+   * Builds a QueuePlacementPolicy from a xml element.
+   * @param confElement the placement policy xml snippet from the
+   *                    {@link FairSchedulerConfiguration}
+   * @param fs the reference to the scheduler needed in the rule on init.
+   * @throws AllocationConfigurationException for any errors
-  public static QueuePlacementPolicy fromXml(Element el,
-      Map<FSQueueType, Set<String>> configuredQueues, Configuration conf)
+  static void fromXml(Element confElement, FairScheduler fs)
-    List<QueuePlacementRule> rules = new ArrayList<QueuePlacementRule>();
-    NodeList elements = el.getChildNodes();
+    LOG.debug("Reloading placement policy from allocation config");
+    if (confElement == null || !confElement.hasChildNodes()) {
+      throw new AllocationConfigurationException(
+          "Empty configuration for QueuePlacementPolicy is not allowed");
+    }
+    List<PlacementRule> newRules = new ArrayList<>();
+    List<Boolean> newTerminalState = new ArrayList<>();
+    NodeList elements = confElement.getChildNodes();
-      if (node instanceof Element) {
-        QueuePlacementRule rule = createAndInitializeRule(node);
-        rules.add(rule);
+      if (node instanceof Element &&
+          node.getNodeName().equalsIgnoreCase("rule")) {
+        String name = ((Element) node).getAttribute("name");
+        LOG.debug("Creating new rule: {}", name);
+        PlacementRule rule = createRule((Element)node);
+
+        // The only child node that we currently know is a parent rule
+        PlacementRule parentRule = null;
+        String parentName = null;
+        Element child = getParentRuleElement(node);
+        if (child != null) {
+          parentName = child.getAttribute("name");
+          parentRule = getParentRule(child, fs);
+        }
+        // Need to make sure that the nestedUserQueue has a parent for
+        // backwards compatibility
+        if (name.equalsIgnoreCase("nestedUserQueue") && parentRule == null) {
+          throw new AllocationConfigurationException("Rule '" + name
+              + "' must have a parent rule set");
+        }
+        newRules.add(rule);
+        if (parentRule == null) {
+          newTerminalState.add(
+              getTerminal(RULES.get(name).terminal, rule));
+        } else {
+          ((FSPlacementRule)rule).setParentRule(parentRule);
+          newTerminalState.add(
+              getTerminal(RULES.get(name).terminal, rule) &&
+              getTerminal(RULES.get(parentName).terminal, parentRule));
+        }
-    return new QueuePlacementPolicy(rules, configuredQueues, conf);
+    updateRuleSet(newRules, newTerminalState, fs);
-  
+
-   * Create and initialize a rule given a xml node
-   * @param node
-   * @return QueuePlacementPolicy
-   * @throws AllocationConfigurationException
+   * Find the element that defines the parent rule.
+   * @param node the xml node to check for a parent rule
+   * @return {@link Element} that describes the parent rule or
+   * <code>null</code> if none is found
-  public static QueuePlacementRule createAndInitializeRule(Node node)
+  private static Element getParentRuleElement(Node node)
-    Element element = (Element) node;
+    Element parent = null;
+    // walk over the node list
+    if (node.hasChildNodes()) {
+      NodeList childList = node.getChildNodes();
+      for (int j = 0; j < childList.getLength(); j++) {
+        Node child = childList.item(j);
+        if (child instanceof Element &&
+            child.getNodeName().equalsIgnoreCase("rule")) {
+          if (parent != null) {
+            LOG.warn("Rule '{}' has multiple parent rules defined, only the " +
+                "last parent rule will be used",
+                ((Element) node).getAttribute("name"));
+          }
+          parent = ((Element) child);
+        }
+      }
+    }
+    // sanity check the rule that is configured
+    if (parent != null) {
+      String parentName = parent.getAttribute("name");
+      if (parentName.equals("reject") ||
+          parentName.equals("nestedUserQueue")) {
+        throw new AllocationConfigurationException("Rule '"
+            + parentName
+            + "' is not allowed as a parent rule for any rule");
+      }
+    }
+    return parent;
+  }
+
+  /**
+   * Retrieve the configured parent rule from the xml config.
+   * @param parent the xml element that contains the name of the rule to add.
+   * @param fs the reference to the scheduler needed in the rule on init.
+   * @return {@link PlacementRule} to set as a parent
+   * @throws AllocationConfigurationException for any error
+   */
+  private static PlacementRule getParentRule(Element parent,
+                                             FairScheduler fs)
+      throws AllocationConfigurationException {
+    LOG.debug("Creating new parent rule: {}", parent.getAttribute("name"));
+    PlacementRule parentRule = createRule(parent);
+    // Init the rule, we do not want to add it to the list of the
+    // placement manager
+    try {
+      parentRule.initialize(fs);
+    } catch (IOException ioe) {
+      // We should never throw as we pass in a FS object, however we
+      // still should consider any exception here a config error.
+      throw new AllocationConfigurationException(
+          "Parent Rule initialisation failed with exception", ioe);
+    }
+    return parentRule;
+  }
+
+  /**
+   * Returns the terminal status of the rule based on the definition and the
+   * create flag set in the rule.
+   * @param terminal The definition of the terminal flag
+   * @param rule The rule to check
+   * @return <code>true</code> if the rule is terminal <code>false</code> in
+   * all other cases.
+   */
+  private static Boolean getTerminal(String terminal, PlacementRule rule) {
+    switch (terminal) {
+    case "true":    // rule is always terminal
+      return true;
+    case "false":   // rule is never terminal
+      return false;
+    default:        // rule is terminal based on the create flag
+      return ((FSPlacementRule)rule).getCreateFlag();
+    }
+  }
+
+  /**
+   * Create a rule from a given a xml node.
+   * @param element the xml element to create the rule from
+   * @return PlacementRule
+   * @throws AllocationConfigurationException for any error
+   */
+  @SuppressWarnings("unchecked")
+  private static PlacementRule createRule(Element element)
+      throws AllocationConfigurationException {
-    Class<? extends QueuePlacementRule> clazz = ruleClasses.get(ruleName);
-    if (clazz == null) {
+    Class<? extends PlacementRule> ruleClass = null;
+    if (RULES.containsKey(ruleName)) {
+      ruleClass = RULES.get(ruleName).ruleClass;
+    }
+    if (ruleClass == null) {
-    QueuePlacementRule rule = ReflectionUtils.newInstance(clazz, null);
-    rule.initializeFromXml(element);
-    return rule;
+    return getPlacementRule(ruleClass, element);
-   * Build a simple queue placement policy from the allow-undeclared-pools and
-   * user-as-default-queue configuration options.
+   * Build a simple queue placement policy from the configuration options
+   * {@link FairSchedulerConfiguration#ALLOW_UNDECLARED_POOLS} and
+   * {@link FairSchedulerConfiguration#USER_AS_DEFAULT_QUEUE}.
+   * @param fs the reference to the scheduler needed in the rule on init.
-  public static QueuePlacementPolicy fromConfiguration(Configuration conf,
-      Map<FSQueueType, Set<String>> configuredQueues) {
+  static void fromConfiguration(FairScheduler fs) {
+    LOG.debug("Creating base placement policy from config");
+    Configuration conf = fs.getConfig();
+
-    List<QueuePlacementRule> rules = new ArrayList<QueuePlacementRule>();
-    rules.add(new QueuePlacementRule.Specified().initialize(create, null));
+    List<PlacementRule> newRules = new ArrayList<>();
+    List<Boolean> newTerminalState = new ArrayList<>();
+    Class<? extends PlacementRule> clazz =
+        RULES.get("specified").ruleClass;
+    newRules.add(getPlacementRule(clazz, create));
+    newTerminalState.add(false);
-      rules.add(new QueuePlacementRule.User().initialize(create, null));
+      clazz = RULES.get("user").ruleClass;
+      newRules.add(getPlacementRule(clazz, create));
+      newTerminalState.add(create);
-      rules.add(new QueuePlacementRule.Default().initialize(true, null));
+      clazz = RULES.get("default").ruleClass;
+      newRules.add(getPlacementRule(clazz, true));
+      newTerminalState.add(true);
-      return new QueuePlacementPolicy(rules, configuredQueues, conf);
+      updateRuleSet(newRules, newTerminalState, fs);
-      		"placement policy from conf", ex);
+          "placement policy from conf", ex);
-
-  /**
-   * Applies this rule to an app with the given requested queue and user/group
-   * information.
-   * 
-   * @param requestedQueue
-   *    The queue specified in the ApplicationSubmissionContext
-   * @param user
-   *    The user submitting the app
-   * @return
-   *    The name of the queue to assign the app to.  Or null if the app should
-   *    be rejected.
-   * @throws IOException
-   *    If an exception is encountered while getting the user's groups
-   */
-  public String assignAppToQueue(String requestedQueue, String user)
-      throws IOException {
-    for (QueuePlacementRule rule : rules) {
-      String queue = rule.assignAppToQueue(requestedQueue, user, groups,
-          configuredQueues);
-      if (queue == null || !queue.isEmpty()) {
-        return queue;
-      }
-    }
-    throw new IllegalStateException("Should have applied a rule before " +
-    		"reaching here");
-  }
-  
-  public List<QueuePlacementRule> getRules() {
-    return rules;
-  }

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 UPD40 INS40 INS40 UPD40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS29 UPD83 INS23 INS55 INS23 INS28 INS31 INS31 INS31 INS65 MOV83 MOV83 MOV83 INS43 INS59 INS83 INS83 INS83 INS42 INS23 INS23 INS31 INS83 INS83 INS83 UPD74 MOV74 INS59 INS83 INS8 INS83 INS42 INS8 INS29 INS83 UPD83 MOV83 INS39 UPD42 MOV42 MOV44 MOV44 MOV44 MOV43 MOV8 INS39 INS44 INS8 UPD83 UPD43 UPD42 MOV44 INS43 INS8 INS83 UPD83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS79 UPD83 UPD43 UPD42 INS44 INS29 UPD83 INS39 INS42 INS44 INS8 INS66 INS66 INS65 INS66 INS65 INS66 UPD42 MOV42 INS42 INS32 INS83 INS83 INS74 MOV59 INS83 INS83 MOV43 INS59 INS83 INS42 INS44 INS44 INS8 MOV43 UPD43 INS42 INS60 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS65 INS65 INS65 INS65 INS65 UPD74 UPD42 UPD74 MOV74 UPD42 UPD43 UPD42 INS25 INS21 INS21 INS54 INS21 INS21 INS65 INS65 INS65 MOV43 UPD42 INS43 INS42 INS21 INS25 MOV60 MOV60 MOV60 MOV24 INS21 INS65 INS65 UPD65 UPD42 INS42 INS60 INS25 MOV25 INS41 INS42 INS43 INS42 UPD43 MOV43 UPD42 MOV42 INS42 INS21 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS42 MOV43 INS42 INS43 INS42 INS50 INS42 INS45 UPD42 INS43 INS42 INS60 INS25 INS41 INS65 INS65 INS43 INS42 INS21 INS60 MOV60 MOV60 INS60 INS60 INS60 INS21 INS21 INS25 INS25 MOV54 INS40 INS42 INS42 INS42 INS57 MOV43 UPD76 MOV76 UPD42 INS42 INS74 INS42 MOV43 INS42 INS21 INS21 UPD42 UPD74 MOV74 MOV59 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 UPD43 UPD43 UPD42 INS32 INS8 INS32 INS32 INS8 INS12 INS32 INS32 UPD66 INS42 INS66 INS65 INS42 INS66 INS42 INS66 UPD42 MOV42 INS32 INS27 INS8 INS74 UPD74 INS32 INS66 INS42 INS66 INS66 INS65 UPD66 UPD66 INS43 INS59 INS32 INS8 INS27 INS42 UPD66 UPD42 UPD66 UPD42 UPD66 UPD66 INS65 UPD66 UPD42 UPD66 INS42 UPD42 INS32 INS43 INS59 INS8 INS12 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS49 INS41 INS49 INS41 INS49 INS41 UPD66 UPD42 INS66 UPD66 INS66 INS42 UPD74 MOV74 INS59 INS32 INS8 INS32 INS66 INS65 INS66 INS65 INS66 INS42 INS66 INS42 INS32 MOV43 INS59 UPD74 MOV74 INS59 INS74 INS59 INS74 INS59 INS32 INS32 INS42 INS8 MOV27 INS8 MOV43 UPD43 MOV43 UPD76 MOV76 INS7 INS7 MOV43 UPD43 INS14 INS14 INS14 INS14 INS14 INS14 INS14 UPD42 UPD42 UPD42 INS42 INS42 INS21 INS41 INS42 INS42 INS45 INS32 INS42 INS42 INS45 INS70 INS44 INS8 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS27 INS38 INS53 INS43 INS43 UPD42 UPD43 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS33 INS42 INS42 INS60 INS24 INS42 INS33 INS60 INS25 INS42 INS42 UPD42 MOV42 INS45 INS32 INS42 INS42 INS32 INS21 INS44 INS8 INS45 INS9 INS45 INS9 INS32 UPD76 UPD42 MOV42 INS33 UPD42 MOV42 UPD42 MOV42 MOV42 INS21 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 INS67 INS67 INS42 INS42 INS45 INS42 INS32 UPD43 INS42 INS14 MOV43 INS43 INS42 INS14 MOV43 INS76 INS42 INS22 INS42 INS42 INS32 INS42 INS42 INS9 INS21 INS21 INS21 INS21 INS21 INS21 INS21 UPD42 UPD43 INS22 INS42 INS22 INS42 UPD42 UPD74 INS43 INS57 INS45 INS43 INS57 INS45 INS43 INS57 INS45 INS43 INS57 INS45 INS43 INS57 INS45 INS43 INS57 INS45 INS43 INS57 INS45 INS32 INS32 UPD42 MOV42 MOV42 MOV27 INS44 INS42 INS8 INS43 INS42 INS53 INS32 INS42 INS42 INS33 INS32 INS14 INS42 INS42 UPD74 UPD42 UPD74 UPD42 INS27 INS43 INS59 INS58 INS27 INS37 INS8 MOV43 INS59 INS27 INS8 UPD42 MOV42 UPD42 MOV42 INS45 UPD42 MOV42 INS42 INS32 MOV43 INS42 MOV53 INS36 INS42 UPD43 INS7 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS74 INS42 INS74 INS43 INS32 INS42 INS42 INS42 INS42 INS7 INS32 INS32 INS7 INS32 INS32 INS32 UPD42 INS52 INS42 INS52 INS42 INS42 UPD43 MOV43 INS42 UPD43 MOV43 INS42 UPD43 MOV43 INS42 UPD43 MOV43 INS42 UPD43 MOV43 INS42 UPD43 MOV43 INS42 UPD43 MOV43 INS42 INS42 INS45 UPD42 UPD42 MOV42 MOV42 MOV42 INS43 INS42 MOV21 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS45 MOV62 INS32 INS60 INS21 MOV60 INS60 INS60 INS60 INS25 INS25 INS25 UPD42 MOV42 INS42 INS32 INS39 INS59 INS42 INS32 INS42 INS60 INS25 INS42 INS32 INS32 INS32 INS53 UPD42 MOV42 UPD42 MOV42 INS42 INS11 UPD42 INS42 INS22 INS43 INS43 UPD42 MOV42 INS42 INS42 INS45 INS42 INS22 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS32 UPD43 MOV43 INS45 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS45 MOV43 INS59 INS32 INS43 UPD43 MOV43 INS59 MOV43 INS59 MOV43 MOV59 INS27 INS8 INS27 INS8 INS27 INS8 INS8 INS42 INS42 INS42 INS34 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS45 INS42 UPD42 MOV42 INS45 UPD42 MOV42 INS42 INS45 INS14 UPD43 INS45 INS42 INS43 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS9 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 UPD42 INS32 UPD42 INS42 INS33 INS42 INS33 UPD42 INS42 INS33 INS21 INS21 INS32 INS27 INS53 UPD42 INS42 INS33 INS21 INS21 INS21 UPD42 MOV42 INS42 INS32 INS62 INS32 MOV25 INS21 UPD43 MOV43 INS27 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS45 INS36 INS36 INS42 INS45 INS42 MOV11 UPD42 INS7 INS7 INS42 INS42 INS45 INS42 INS33 INS14 INS32 INS32 INS32 UPD42 MOV42 INS42 INS42 INS42 INS43 INS32 UPD42 MOV42 INS45 INS27 INS7 INS42 INS45 INS42 INS45 INS27 INS11 INS42 INS32 INS42 INS32 INS43 INS27 INS42 INS42 INS32 INS36 INS42 INS42 INS42 INS42 INS27 INS42 INS42 UPD42 MOV42 INS42 INS33 INS42 INS36 MOV42 INS34 INS43 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS22 INS42 INS11 INS32 INS32 INS11 INS42 INS32 INS42 INS43 INS42 INS42 INS22 INS42 INS42 INS22 INS42 UPD42 UPD42 INS27 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS45 INS45 INS36 UPD42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS43 INS42 INS42 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL42 DEL43 DEL76 DEL74 DEL40 DEL57 DEL40 DEL57 DEL40 DEL57 DEL40 DEL57 DEL40 DEL57 DEL40 DEL57 DEL40 DEL57 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL7 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL14 DEL7 DEL21 DEL43 DEL42 DEL43 DEL74 DEL74 DEL23 DEL83 DEL42 DEL43 DEL74 DEL74 DEL60 DEL8 DEL28 DEL83 DEL83 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL31 DEL83 DEL42 DEL43 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL60 DEL42 DEL42 DEL42 DEL14 DEL41 DEL8 DEL42 DEL40 DEL43 DEL14 DEL42 DEL33 DEL40 DEL14 DEL42 DEL9 DEL33 DEL32 DEL32 DEL21 DEL42 DEL44 DEL43 DEL42 DEL43 DEL43 DEL43 DEL74 DEL74 DEL42 DEL44 DEL42 DEL40 DEL43 DEL14 DEL33 DEL32 DEL32 DEL21 DEL8 DEL66 DEL42 DEL42 DEL44 DEL42 DEL45 DEL45 DEL27 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL32 DEL38 DEL27 DEL42 DEL41 DEL8 DEL25 DEL8 DEL70 DEL8 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL32 DEL59 DEL60 DEL32 DEL21 DEL42 DEL41 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL41 DEL43 DEL74 DEL42 DEL42 DEL41 DEL8
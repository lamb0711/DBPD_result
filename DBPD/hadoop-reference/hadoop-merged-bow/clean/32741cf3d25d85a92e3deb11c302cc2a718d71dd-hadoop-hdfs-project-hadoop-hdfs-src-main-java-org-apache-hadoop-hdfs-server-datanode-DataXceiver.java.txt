Revert "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)" (jenkins didn't run yet)

This reverts commit 5aa892ed486d42ae6b94c4866b92cd2b382ea640.

-import static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.ShortCircuitFdResponse.USE_RECEIPT_VERIFICATION;
-import static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.ShortCircuitFdResponse.DO_NOT_USE_RECEIPT_VERIFICATION;
-      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)
-        throws IOException {
+      SlotId slotId, int maxVersion) throws IOException {
-    SlotId registeredSlotId = null;
-    boolean success = false;
-      try {
-        if (peer.getDomainSocket() == null) {
-          throw new IOException("You cannot pass file descriptors over " +
-              "anything but a UNIX domain socket.");
-        }
-        if (slotId != null) {
-          boolean isCached = datanode.data.
-              isCached(blk.getBlockPoolId(), blk.getBlockId());
-          datanode.shortCircuitRegistry.registerSlot(
-              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);
-          registeredSlotId = slotId;
-        }
-        fis = datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);
-        Preconditions.checkState(fis != null);
-        bld.setStatus(SUCCESS);
-        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);
-      } catch (ShortCircuitFdsVersionException e) {
-        bld.setStatus(ERROR_UNSUPPORTED);
-        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);
-        bld.setMessage(e.getMessage());
-      } catch (ShortCircuitFdsUnsupportedException e) {
-        bld.setStatus(ERROR_UNSUPPORTED);
-        bld.setMessage(e.getMessage());
-      } catch (InvalidToken e) {
-        bld.setStatus(ERROR_ACCESS_TOKEN);
-        bld.setMessage(e.getMessage());
-      } catch (IOException e) {
-        bld.setStatus(ERROR);
-        bld.setMessage(e.getMessage());
+      if (peer.getDomainSocket() == null) {
+        throw new IOException("You cannot pass file descriptors over " +
+            "anything but a UNIX domain socket.");
+      if (slotId != null) {
+        boolean isCached = datanode.data.
+            isCached(blk.getBlockPoolId(), blk.getBlockId());
+        datanode.shortCircuitRegistry.registerSlot(
+            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);
+      }
+      try {
+        fis = datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);
+      } finally {
+        if ((fis == null) && (slotId != null)) {
+          datanode.shortCircuitRegistry.unregisterSlot(slotId);
+        }
+      }
+      bld.setStatus(SUCCESS);
+      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);
+    } catch (ShortCircuitFdsVersionException e) {
+      bld.setStatus(ERROR_UNSUPPORTED);
+      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);
+      bld.setMessage(e.getMessage());
+    } catch (ShortCircuitFdsUnsupportedException e) {
+      bld.setStatus(ERROR_UNSUPPORTED);
+      bld.setMessage(e.getMessage());
+    } catch (InvalidToken e) {
+      bld.setStatus(ERROR_ACCESS_TOKEN);
+      bld.setMessage(e.getMessage());
+    } catch (IOException e) {
+      bld.setStatus(ERROR);
+      bld.setMessage(e.getMessage());
+    }
+    try {
-        byte buf[] = new byte[1];
-        if (supportsReceiptVerification) {
-          buf[0] = (byte)USE_RECEIPT_VERIFICATION.getNumber();
-        } else {
-          buf[0] = (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();
-        }
-        DomainSocket sock = peer.getDomainSocket();
-        sock.sendFileDescriptors(fds, buf, 0, buf.length);
-        if (supportsReceiptVerification) {
-          LOG.trace("Reading receipt verification byte for " + slotId);
-          int val = sock.getInputStream().read();
-          if (val < 0) {
-            throw new EOFException();
-          }
-        } else {
-          LOG.trace("Receipt verification is not enabled on the DataNode.  " +
-                    "Not verifying " + slotId);
-        }
-        success = true;
+        byte buf[] = new byte[] { (byte)0 };
+        peer.getDomainSocket().
+          sendFileDescriptors(fds, buf, 0, buf.length);
-      if ((!success) && (registeredSlotId != null)) {
-        LOG.info("Unregistering " + registeredSlotId + " because the " +
-            "requestShortCircuitFdsForRead operation failed.");
-        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);
-      }
-            blk.getBlockId(), dnR.getDatanodeUuid(), success));
+            blk.getBlockId(), dnR.getDatanodeUuid(), (fis != null)
+          ));

MOV8 MOV21 MOV60 MOV60 INS54 INS8 INS8 INS54 MOV21 MOV25 INS25 MOV25 INS8 INS8 MOV32 INS8 MOV21 INS25 MOV60 INS21 INS27 INS8 INS32 INS36 INS36 MOV21 MOV32 INS40 INS42 INS32 INS27 INS27 INS4 INS42 INS42 MOV27 MOV32 MOV32 INS36 INS42 INS33 INS42 INS33 INS40 UPD42 UPD42 INS11 MOV27 INS39 INS34 DEL40 DEL26 DEL40 DEL26 DEL39 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL34 DEL42 DEL42 DEL34 DEL2 DEL39 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL34 DEL2 DEL39 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL43 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL42 DEL45 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL9 DEL7 DEL21 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL38 DEL36 DEL42 DEL33 DEL27 DEL36 DEL27 DEL42 DEL42 DEL45 DEL42 DEL45 DEL45 DEL27 DEL32 DEL21 DEL40 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL40 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8
HDFS-9833. Erasure coding: recomputing block checksum on the fly by reconstructing the missed/corrupt block data. Contributed by Rakesh R.

-import org.apache.hadoop.hdfs.server.protocol.BlockECReconstructionCommand.BlockECReconstructionInfo;
+import java.util.concurrent.ThreadPoolExecutor;
-class StripedReconstructor implements Runnable {
-  private static final Logger LOG = DataNode.LOG;
+abstract class StripedReconstructor {
+  protected static final Logger LOG = DataNode.LOG;
-  private final ErasureCodingWorker worker;
-  private final DataNode datanode;
-
+  private final DataNode datanode;
-
-
-  private final BitSet liveBitSet;
-
-
-  private StripedWriter stripedWriter;
-
+  private ThreadPoolExecutor stripedReadPool;
+  private long maxTargetLength = 0L;
+  private final BitSet liveBitSet;
-                       BlockECReconstructionInfo reconstructionInfo) {
-    this.worker = worker;
+      StripedReconstructionInfo stripedReconInfo) {
+    this.stripedReadPool = worker.getStripedReadPool();
-
-    ecPolicy = reconstructionInfo.getErasureCodingPolicy();
-
-    blockGroup = reconstructionInfo.getExtendedBlock();
-    byte[] liveIndices = reconstructionInfo.getLiveBlockIndices();
-    liveBitSet = new BitSet(ecPolicy.getNumDataUnits() +
-        ecPolicy.getNumParityUnits());
-    for (int i = 0; i < liveIndices.length; i++) {
-      liveBitSet.set(liveIndices[i]);
+    this.ecPolicy = stripedReconInfo.getEcPolicy();
+    liveBitSet = new BitSet(
+        ecPolicy.getNumDataUnits() + ecPolicy.getNumParityUnits());
+    for (int i = 0; i < stripedReconInfo.getLiveIndices().length; i++) {
+      liveBitSet.set(stripedReconInfo.getLiveIndices()[i]);
-
-    stripedReader = new StripedReader(this, datanode,
-        conf, reconstructionInfo);
-    stripedWriter = new StripedWriter(this, datanode,
-        conf, reconstructionInfo);
+    blockGroup = stripedReconInfo.getBlockGroup();
+    stripedReader = new StripedReader(this, datanode, conf, stripedReconInfo);
-  BitSet getLiveBitSet() {
-    return liveBitSet;
-  }
+  /**
+   * Reconstruct one or more missed striped block in the striped block group,
+   * the minimum number of live striped blocks should be no less than data
+   * block number.
+   *
+   * @throws IOException
+   */
+  abstract void reconstruct() throws IOException;
-  boolean hasValidTargets() {
-    return stripedWriter.hasValidTargets();
-  }
-
-  @Override
-  public void run() {
-    datanode.incrementXmitsInProgress();
-    try {
-      stripedReader.init();
-
-      stripedWriter.init();
-
-      reconstructAndTransfer();
-
-      stripedWriter.endTargetBlocks();
-
-      // Currently we don't check the acks for packets, this is similar as
-      // block replication.
-    } catch (Throwable e) {
-      LOG.warn("Failed to reconstruct striped block: {}", blockGroup, e);
-      datanode.getMetrics().incrECFailedReconstructionTasks();
-    } finally {
-      datanode.decrementXmitsInProgress();
-      datanode.getMetrics().incrECReconstructionTasks();
-      stripedReader.close();
-      stripedWriter.close();
-    }
-  }
-
-  void reconstructAndTransfer() throws IOException {
-    while (positionInBlock < stripedWriter.getMaxTargetLength()) {
-      long remaining = stripedWriter.getMaxTargetLength() - positionInBlock;
-      final int toReconstructLen =
-          (int) Math.min(stripedReader.getBufferSize(), remaining);
-      // step1: read from minimum source DNs required for reconstruction.
-      // The returned success list is the source DNs we do real read from
-      stripedReader.readMinimumSources(toReconstructLen);
-
-      // step2: decode to reconstruct targets
-      reconstructTargets(toReconstructLen);
-
-      // step3: transfer data
-      if (stripedWriter.transferData2Targets() == 0) {
-        String error = "Transfer failed for all targets.";
-        throw new IOException(error);
-      }
-
-      positionInBlock += toReconstructLen;
-
-      clearBuffers();
-    }
-  }
-
-  private void initDecoderIfNecessary() {
+  protected void initDecoderIfNecessary() {
-  private void reconstructTargets(int toReconstructLen) {
-    initDecoderIfNecessary();
-
-    ByteBuffer[] inputs = stripedReader.getInputBuffers(toReconstructLen);
-
-    int[] erasedIndices = stripedWriter.getRealTargetIndices();
-    ByteBuffer[] outputs = stripedWriter.getRealTargetBuffers(toReconstructLen);
-
-    decoder.decode(inputs, erasedIndices, outputs);
-
-    stripedWriter.updateRealTargetBuffers(toReconstructLen);
-  }
-
-  /**
-   * Clear all associated buffers.
-   */
-  private void clearBuffers() {
-    stripedReader.clearBuffers();
-
-    stripedWriter.clearBuffers();
-  }
-
-  DataChecksum getChecksum() {
+  public DataChecksum getChecksum() {
-    return new ExecutorCompletionService<>(worker.getStripedReadPool());
+    return new ExecutorCompletionService<>(stripedReadPool);
+
+  BitSet getLiveBitSet() {
+    return liveBitSet;
+  }
+
+  long getMaxTargetLength() {
+    return maxTargetLength;
+  }
+
+  void setMaxTargetLength(long maxTargetLength) {
+    this.maxTargetLength = maxTargetLength;
+  }
+
+  void updatePositionInBlock(long positionInBlockArg) {
+    this.positionInBlock += positionInBlockArg;
+  }
+
+  RawErasureDecoder getDecoder() {
+    return decoder;
+  }
+
+  StripedReader getStripedReader() {
+    return stripedReader;
+  }
+
+  Configuration getConf() {
+    return conf;
+  }
+
+  DataNode getDatanode() {
+    return datanode;
+  }

MOV26 MOV23 MOV23 MOV23 MOV23 MOV31 MOV31 MOV31 MOV31 UPD40 INS83 INS31 INS31 INS31 INS31 INS31 UPD83 UPD43 INS39 INS29 INS83 INS39 INS42 MOV43 UPD83 INS83 UPD39 UPD42 INS42 INS44 INS8 INS42 INS44 INS8 INS43 INS42 INS8 INS43 INS42 INS8 INS43 INS42 INS8 INS43 INS42 MOV8 UPD42 UPD42 UPD42 INS34 UPD43 UPD42 INS24 INS65 INS65 INS39 INS42 MOV21 INS39 INS42 MOV21 INS42 INS41 UPD42 MOV42 INS41 UPD42 MOV42 INS41 INS42 INS41 UPD42 MOV58 INS27 MOV37 MOV8 INS66 INS66 INS66 INS42 INS42 INS7 INS42 INS42 INS42 INS42 MOV32 INS22 INS42 INS22 UPD42 INS32 UPD42 INS42 INS22 INS42 INS22 UPD42 UPD42 INS52 INS42 UPD42 UPD42 INS32 INS42 INS42 INS42 MOV43 UPD42 INS52 INS42 INS52 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 DEL42 DEL43 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL39 DEL85 DEL5 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL27 DEL24 DEL52 DEL42 DEL42 DEL42 DEL14 DEL42 DEL43 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL32 DEL21 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL31 DEL42 DEL42 DEL32 DEL42 DEL78 DEL83 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL59 DEL60 DEL83 DEL39 DEL42 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21
HDFS-10999. Introduce separate stats for Replicated and Erasure Coded Blocks apart from the current Aggregated stats. (Manoj Govindassamy via lei)

+import java.util.HashSet;
+import java.util.Map.Entry;
+import java.util.concurrent.atomic.LongAdder;
-  /** Mapping: DatanodeInfo -> Collection of Blocks */
-  private final Map<DatanodeInfo, LightWeightHashSet<Block>> node2blocks =
-      new HashMap<DatanodeInfo, LightWeightHashSet<Block>>();
-  /** The total number of blocks in the map. */
-  private long numBlocks = 0L;
-
+  private final Map<DatanodeInfo, LightWeightHashSet<Block>>
+      nodeToBlocks = new HashMap<>();
+  private final Map<DatanodeInfo, LightWeightHashSet<Block>>
+      nodeToECBlockGroups = new HashMap<>();
+  private final LongAdder numBlocks = new LongAdder();
+  private final LongAdder numECBlockGroups = new LongAdder();
-  /** @return the number of blocks to be invalidated . */
-  synchronized long numBlocks() {
-    return numBlocks;
+  /**
+   * @return The total number of blocks to be invalidated.
+   */
+  long numBlocks() {
+    return getECBlockGroupsStat() + getBlocksStat();
+   * @return The total number of blocks of type
+   * {@link org.apache.hadoop.hdfs.protocol.BlockType#CONTIGUOUS}
+   * to be invalidated.
+   */
+  long getBlocksStat() {
+    return numBlocks.longValue();
+  }
+
+  /**
+   * @return The total number of blocks of type
+   * {@link org.apache.hadoop.hdfs.protocol.BlockType#STRIPED}
+   * to be invalidated.
+   */
+  long getECBlockGroupsStat() {
+    return numECBlockGroups.longValue();
+  }
+
+  private LightWeightHashSet<Block> getBlocksSet(final DatanodeInfo dn) {
+    if (nodeToBlocks.containsKey(dn)) {
+      return nodeToBlocks.get(dn);
+    }
+    return null;
+  }
+
+  private LightWeightHashSet<Block> getECBlockGroupsSet(final DatanodeInfo dn) {
+    if (nodeToECBlockGroups.containsKey(dn)) {
+      return nodeToECBlockGroups.get(dn);
+    }
+    return null;
+  }
+
+  private LightWeightHashSet<Block> getBlocksSet(final DatanodeInfo dn,
+      final Block block) {
+    if (BlockIdManager.isStripedBlockID(block.getBlockId())) {
+      return getECBlockGroupsSet(dn);
+    } else {
+      return getBlocksSet(dn);
+    }
+  }
+
+  private void putBlocksSet(final DatanodeInfo dn, final Block block,
+      final LightWeightHashSet set) {
+    if (BlockIdManager.isStripedBlockID(block.getBlockId())) {
+      assert getECBlockGroupsSet(dn) == null;
+      nodeToECBlockGroups.put(dn, set);
+    } else {
+      assert getBlocksSet(dn) == null;
+      nodeToBlocks.put(dn, set);
+    }
+  }
+
+  private long getBlockSetsSize(final DatanodeInfo dn) {
+    LightWeightHashSet<Block> replicaBlocks = getBlocksSet(dn);
+    LightWeightHashSet<Block> stripedBlocks = getECBlockGroupsSet(dn);
+    return ((replicaBlocks == null ? 0 : replicaBlocks.size()) +
+        (stripedBlocks == null ? 0 : stripedBlocks.size()));
+  }
+
+
+  /**
-    final LightWeightHashSet<Block> s = node2blocks.get(dn);
+    final LightWeightHashSet<Block> s = getBlocksSet(dn, block);
-   * Add a block to the block collection
-   * which will be invalidated on the specified datanode.
+   * Add a block to the block collection which will be
+   * invalidated on the specified datanode.
-    LightWeightHashSet<Block> set = node2blocks.get(datanode);
+    LightWeightHashSet<Block> set = getBlocksSet(datanode, block);
-      set = new LightWeightHashSet<Block>();
-      node2blocks.put(datanode, set);
+      set = new LightWeightHashSet<>();
+      putBlocksSet(datanode, block, set);
-      numBlocks++;
+      if (BlockIdManager.isStripedBlockID(block.getBlockId())) {
+        numECBlockGroups.increment();
+      } else {
+        numBlocks.increment();
+      }
-    final LightWeightHashSet<Block> blocks = node2blocks.remove(dn);
-    if (blocks != null) {
-      numBlocks -= blocks.size();
+    LightWeightHashSet<Block> replicaBlockSets = nodeToBlocks.remove(dn);
+    if (replicaBlockSets != null) {
+      numBlocks.add(replicaBlockSets.size() * -1);
+    }
+    LightWeightHashSet<Block> blockGroupSets = nodeToECBlockGroups.remove(dn);
+    if (blockGroupSets != null) {
+      numECBlockGroups.add(blockGroupSets.size() * -1);
-    final LightWeightHashSet<Block> v = node2blocks.get(dn);
+    final LightWeightHashSet<Block> v = getBlocksSet(dn, block);
-      numBlocks--;
-      if (v.isEmpty()) {
-        node2blocks.remove(dn);
+      if (BlockIdManager.isStripedBlockID(block.getBlockId())) {
+        numECBlockGroups.decrement();
+      } else {
+        numBlocks.decrement();
+      }
+      if (v.isEmpty() && getBlockSetsSize(dn) == 0) {
+        remove(dn);
-  /** Print the contents to out. */
-  synchronized void dump(final PrintWriter out) {
-    final int size = node2blocks.values().size();
-    out.println("Metasave: Blocks " + numBlocks 
-        + " waiting deletion from " + size + " datanodes.");
-    if (size == 0) {
-      return;
-    }
-
-    for(Map.Entry<DatanodeInfo, LightWeightHashSet<Block>> entry : node2blocks.entrySet()) {
+  private void dumpBlockSet(final Map<DatanodeInfo,
+      LightWeightHashSet<Block>> nodeToBlocksMap, final PrintWriter out) {
+    for(Entry<DatanodeInfo, LightWeightHashSet<Block>> entry :
+        nodeToBlocksMap.entrySet()) {
-      if (blocks.size() > 0) {
+      if (blocks != null && blocks.size() > 0) {
+  /** Print the contents to out. */
+  synchronized void dump(final PrintWriter out) {
+    final int size = nodeToBlocks.values().size() +
+        nodeToECBlockGroups.values().size();
+    out.println("Metasave: Blocks " + numBlocks()
+        + " waiting deletion from " + size + " datanodes.");
+    if (size == 0) {
+      return;
+    }
+    dumpBlockSet(nodeToBlocks, out);
+    dumpBlockSet(nodeToECBlockGroups, out);
+  }
-    return new ArrayList<DatanodeInfo>(node2blocks.keySet());
+    HashSet<DatanodeInfo> set = new HashSet<>();
+    set.addAll(nodeToBlocks.keySet());
+    set.addAll(nodeToECBlockGroups.keySet());
+    return new ArrayList<>(set);
+  /**
+   * Get blocks to invalidate by limit as blocks that can be sent in one
+   * message is limited.
+   * @return the remaining limit
+   */
+  private int getBlocksToInvalidateByLimit(LightWeightHashSet<Block> blockSet,
+      List<Block> toInvalidate, LongAdder statsAdder, int limit) {
+    assert blockSet != null;
+    int remainingLimit = limit;
+    List<Block> polledBlocks = blockSet.pollN(limit);
+    remainingLimit -= polledBlocks.size();
+    toInvalidate.addAll(polledBlocks);
+    statsAdder.add(polledBlocks.size() * -1);
+    return remainingLimit;
+  }
+
-    final LightWeightHashSet<Block> set = node2blocks.get(dn);
-    if (set == null) {
-      return null;
+
+    int remainingLimit = blockInvalidateLimit;
+    final List<Block> toInvalidate = new ArrayList<>();
+
+    if (nodeToBlocks.get(dn) != null) {
+      remainingLimit = getBlocksToInvalidateByLimit(nodeToBlocks.get(dn),
+          toInvalidate, numBlocks, remainingLimit);
-
-    // # blocks that can be sent in one message is limited
-    final int limit = blockInvalidateLimit;
-    final List<Block> toInvalidate = set.pollN(limit);
-
-    // If we send everything in this message, remove this node entry
-    if (set.isEmpty()) {
+    if ((remainingLimit > 0) && (nodeToECBlockGroups.get(dn) != null)) {
+      getBlocksToInvalidateByLimit(nodeToECBlockGroups.get(dn),
+          toInvalidate, numECBlockGroups, remainingLimit);
+    }
+    if (toInvalidate.size() > 0 && getBlockSetsSize(dn) == 0) {
-
-    numBlocks -= toInvalidate.size();
-    node2blocks.clear();
-    numBlocks = 0;
+    nodeToBlocks.clear();
+    nodeToECBlockGroups.clear();
+    numBlocks.reset();
+    numECBlockGroups.reset();

INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS74 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS29 INS39 INS42 INS8 UPD42 MOV29 INS39 INS42 INS8 UPD83 MOV83 MOV74 INS42 INS44 INS8 INS83 MOV74 INS42 INS44 INS8 INS83 MOV74 INS42 INS44 INS44 INS8 INS83 MOV39 UPD42 MOV42 INS44 INS44 INS44 MOV8 INS83 INS39 INS42 INS44 INS8 INS29 UPD42 MOV44 MOV44 MOV44 MOV29 MOV44 MOV29 INS39 INS42 MOV44 MOV44 INS8 UPD83 UPD42 INS44 MOV29 MOV83 INS39 UPD42 MOV42 INS44 INS8 MOV29 INS83 MOV74 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS83 MOV74 INS42 MOV44 INS8 UPD42 INS43 INS43 INS74 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 UPD65 MOV65 INS41 UPD65 INS41 INS83 INS43 INS42 INS25 INS41 INS83 INS43 INS42 INS25 MOV41 INS83 INS43 INS42 INS83 INS43 INS42 INS25 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS60 MOV60 INS41 INS65 MOV25 INS25 INS60 MOV25 INS60 INS25 INS83 INS74 INS42 INS83 INS43 INS42 MOV60 INS21 MOV25 INS21 INS21 INS60 INS21 INS21 MOV41 INS65 INS65 INS74 INS42 INS74 INS42 INS43 INS42 INS39 INS42 INS6 INS60 MOV60 INS21 INS21 INS21 INS41 MOV60 MOV25 INS60 INS60 INS25 INS25 INS25 MOV21 MOV41 INS21 INS21 UPD74 INS42 INS42 INS43 INS43 INS74 INS43 INS43 UPD66 INS27 UPD66 INS65 INS66 INS32 UPD66 INS65 UPD66 INS32 INS42 INS32 INS8 INS33 INS42 INS32 INS8 INS42 INS42 INS32 INS8 INS8 INS42 INS42 INS42 INS32 INS8 INS8 INS42 MOV74 INS59 INS36 INS74 INS66 INS66 INS74 MOV27 INS27 INS8 INS74 INS59 INS27 INS83 MOV74 INS59 MOV27 INS8 INS43 INS43 INS74 INS42 INS39 INS32 INS32 INS32 INS74 INS59 INS32 INS32 INS66 INS66 INS66 INS43 INS43 INS43 INS43 INS42 INS27 INS39 MOV59 INS74 INS7 INS32 INS32 INS42 INS39 INS59 INS83 MOV74 INS59 INS27 INS8 INS27 INS8 INS27 INS8 INS32 INS32 INS32 INS42 INS42 INS43 INS42 INS42 INS32 INS32 INS67 INS42 INS42 INS67 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS41 INS42 INS42 INS32 INS41 INS41 INS42 INS42 INS32 INS6 MOV21 INS6 MOV21 INS42 INS32 UPD42 INS27 INS43 INS43 INS43 INS43 UPD42 INS21 INS25 UPD42 INS42 INS33 MOV21 INS43 INS43 INS42 INS32 INS42 INS33 INS42 INS32 INS25 INS25 INS42 INS42 INS43 INS43 UPD74 UPD42 UPD42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS43 MOV43 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 UPD74 INS42 INS42 INS42 INS42 INS42 INS42 INS33 UPD42 UPD42 INS43 INS43 UPD42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS14 INS32 INS33 MOV21 INS36 INS36 INS21 INS27 INS27 INS21 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS40 INS42 INS32 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS27 INS32 INS27 INS42 INS42 UPD42 UPD42 INS36 INS36 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS7 INS32 INS32 INS8 INS8 UPD42 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS8 INS27 MOV8 INS42 INS42 UPD43 MOV43 INS27 INS32 INS32 INS45 INS32 INS45 INS42 INS45 INS42 INS74 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS32 INS38 INS74 INS42 UPD42 MOV42 UPD42 MOV42 UPD7 INS27 INS27 INS32 MOV32 INS34 INS32 INS34 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV33 INS42 INS42 INS42 INS42 INS32 INS33 UPD42 UPD42 INS16 INS16 INS42 INS14 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS21 MOV21 INS42 INS42 INS27 UPD42 UPD42 INS27 INS42 INS42 INS32 INS21 INS21 MOV32 INS27 INS42 MOV27 MOV27 INS32 UPD42 MOV42 INS32 INS42 INS42 INS43 INS42 INS42 INS34 INS43 INS42 INS32 INS42 INS34 INS32 INS33 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS34 INS32 INS27 INS34 INS32 INS74 INS42 INS42 INS32 INS32 INS32 INS38 INS32 INS38 INS42 INS42 INS32 INS32 INS32 INS34 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS33 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS34 UPD42 MOV42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL66 DEL65 DEL29 DEL42 DEL43 DEL29 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL42 DEL42 DEL14 DEL7 DEL42 DEL27 DEL8 DEL42 DEL42 DEL31 DEL83 DEL42 DEL32 DEL7 DEL42 DEL37 DEL83 DEL42 DEL37 DEL8 DEL25 DEL42 DEL8 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL40 DEL32 DEL42 DEL42 DEL32 DEL83 DEL42 DEL8 DEL25 DEL83 DEL39 DEL60 DEL32 DEL25 DEL8 DEL31 DEL42 DEL34 DEL7
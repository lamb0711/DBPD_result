HDFS-6934. Move checksum computation off the hot path when writing to RAM disk. Contributed by Chris Nauroth.

+import java.util.Arrays;
+      StorageType storageType = retval.storageType;
+            setStorageType(storageType).
-      DatanodeInfo[] nodes = block.getLocations();
-        return getBestNodeDNAddrPair(nodes, ignoredNodes);
+        return getBestNodeDNAddrPair(block, ignoredNodes);
-        String errMsg =
-          getBestNodeDNAddrPairErrorString(nodes, deadNodes, ignoredNodes);
+        String errMsg = getBestNodeDNAddrPairErrorString(block.getLocations(),
+          deadNodes, ignoredNodes);
-        
+
+        DatanodeInfo[] nodes = block.getLocations();
-   * Get the best node.
-   * @param nodes Nodes to choose from.
-   * @param ignoredNodes Do not chose nodes in this array (may be null)
+   * Get the best node from which to stream the data.
+   * @param block LocatedBlock, containing nodes in priority order.
+   * @param ignoredNodes Do not choose nodes in this array (may be null)
-  private DNAddrPair getBestNodeDNAddrPair(final DatanodeInfo[] nodes,
+  private DNAddrPair getBestNodeDNAddrPair(LocatedBlock block,
-    DatanodeInfo chosenNode = bestNode(nodes, deadNodes, ignoredNodes);
+    DatanodeInfo[] nodes = block.getLocations();
+    StorageType[] storageTypes = block.getStorageTypes();
+    DatanodeInfo chosenNode = null;
+    StorageType storageType = null;
+    if (nodes != null) {
+      for (int i = 0; i < nodes.length; i++) {
+        if (!deadNodes.containsKey(nodes[i])
+            && (ignoredNodes == null || !ignoredNodes.contains(nodes[i]))) {
+          chosenNode = nodes[i];
+          // Storage types are ordered to correspond with nodes, so use the same
+          // index to get storage type.
+          if (storageTypes != null && i < storageTypes.length) {
+            storageType = storageTypes[i];
+          }
+          break;
+        }
+      }
+    }
+    if (chosenNode == null) {
+      throw new IOException("No live nodes contain block " + block.getBlock() +
+          " after checking nodes = " + Arrays.toString(nodes) +
+          ", ignoredNodes = " + ignoredNodes);
+    }
-    return new DNAddrPair(chosenNode, targetAddr);
+    return new DNAddrPair(chosenNode, targetAddr, storageType);
+      StorageType storageType = datanode.storageType;
+            setStorageType(storageType).
-            chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored);
+            chosenNode = getBestNodeDNAddrPair(block, ignored);
-  /**
-   * Pick the best node from which to stream the data.
-   * Entries in <i>nodes</i> are already in the priority order
-   */
-  static DatanodeInfo bestNode(DatanodeInfo nodes[],
-      AbstractMap<DatanodeInfo, DatanodeInfo> deadNodes,
-      Collection<DatanodeInfo> ignoredNodes) throws IOException {
-    if (nodes != null) {
-      for (int i = 0; i < nodes.length; i++) {
-        if (!deadNodes.containsKey(nodes[i])
-            && (ignoredNodes == null || !ignoredNodes.contains(nodes[i]))) {
-          return nodes[i];
-        }
-      }
-    }
-    throw new IOException("No live nodes contain current block");
-  }
-
-  static class DNAddrPair {
+  private static final class DNAddrPair {
-    DNAddrPair(DatanodeInfo info, InetSocketAddress addr) {
+    final StorageType storageType;
+
+    DNAddrPair(DatanodeInfo info, InetSocketAddress addr,
+        StorageType storageType) {
+      this.storageType = storageType;

INS26 INS40 INS31 MOV29 MOV83 MOV43 MOV42 INS44 MOV44 MOV43 INS8 INS83 INS83 INS23 INS43 INS42 INS60 MOV60 INS60 INS60 MOV25 INS25 MOV60 MOV25 MOV60 INS41 INS83 INS43 INS59 INS44 UPD66 UPD42 UPD66 UPD66 INS42 INS5 INS59 INS5 INS43 INS59 INS43 INS59 INS27 INS8 INS14 INS42 INS42 INS43 INS42 INS21 INS60 MOV43 MOV85 INS42 INS32 INS43 INS85 UPD42 MOV42 INS42 INS33 UPD42 MOV42 INS42 INS33 INS42 INS33 INS53 MOV43 INS42 INS42 INS42 INS60 INS42 INS7 INS43 INS59 INS42 INS42 UPD42 MOV42 UPD42 UPD42 INS14 INS43 INS59 INS22 INS42 INS42 INS42 INS40 MOV43 INS27 INS42 INS42 INS40 INS52 INS42 MOV60 INS8 INS45 INS32 INS45 INS32 INS45 INS42 UPD42 INS21 INS25 INS10 INS42 INS42 INS42 INS42 INS42 INS7 INS27 MOV8 MOV32 INS42 MOV2 INS27 INS27 INS21 INS42 INS42 INS33 INS42 INS40 INS7 INS42 INS2 INS42 INS42 MOV42 INS32 MOV32 INS42 INS40 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 UPD42 MOV32 INS42 INS42 UPD42 UPD42 UPD42 UPD42 DEL40 DEL43 DEL42 DEL42 DEL41 DEL83 DEL5 DEL42 DEL44 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL43 DEL42 DEL85 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31
HDFS-15383. RBF: Add support for router delegation token without watch (#2047)

Improving router's performance for delegation tokens related operations. It achieves the goal by removing watchers from router on tokens since based on our experience. The huge number of watches inside Zookeeper is degrading Zookeeper's performance pretty hard. The current limit is about 1.2-1.5 million.
+import org.apache.hadoop.security.token.Token;
+import org.apache.hadoop.util.Time;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZooKeeper;
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =
+      ZK_CONF_PREFIX + "router.token.sync.interval";
+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;
+
-  private Configuration conf = null;
+  private Configuration conf;
+
+  private final ScheduledExecutorService scheduler =
+      Executors.newSingleThreadScheduledExecutor();
+
+  // Local cache of delegation tokens, used for deprecating tokens from
+  // currentTokenMap
+  private final Set<AbstractDelegationTokenIdentifier> localTokenCache =
+      new HashSet<>();
+  // Native zk client for getting all tokens
+  private ZooKeeper zookeeper;
+  private final String TOKEN_PATH = "/" + zkClient.getNamespace()
+      + ZK_DTSM_TOKENS_ROOT;
+  // The flag used to issue an extra check before deletion
+  // Since cancel token and token remover thread use the same
+  // API here and one router could have a token that is renewed
+  // by another router, thus token remover should always check ZK
+  // to confirm whether it has been renewed or not
+  private ThreadLocal<Boolean> checkAgainstZkBeforeDeletion =
+      new ThreadLocal<Boolean>() {
+        @Override
+        protected Boolean initialValue() {
+          return true;
+        }
+      };
-      super.startThreads();
+      startThreads();
+  public void startThreads() throws IOException {
+    super.startThreads();
+    // start token cache related work when watcher is disabled
+    if (!isTokenWatcherEnabled()) {
+      LOG.info("Watcher for tokens is disabled in this secret manager");
+      try {
+        // By default set this variable
+        checkAgainstZkBeforeDeletion.set(true);
+        // Ensure the token root path exists
+        if (zkClient.checkExists().forPath(ZK_DTSM_TOKENS_ROOT) == null) {
+          zkClient.create().creatingParentsIfNeeded()
+              .withMode(CreateMode.PERSISTENT)
+              .forPath(ZK_DTSM_TOKENS_ROOT);
+        }
+        // Set up zookeeper client
+        try {
+          zookeeper = zkClient.getZookeeperClient().getZooKeeper();
+        } catch (Exception e) {
+          LOG.info("Cannot get zookeeper client ", e);
+        } finally {
+          if (zookeeper == null) {
+            throw new IOException("Zookeeper client is null");
+          }
+        }
+
+        LOG.info("Start loading token cache");
+        long start = Time.now();
+        rebuildTokenCache(true);
+        LOG.info("Loaded token cache in {} milliseconds", Time.now() - start);
+
+        int syncInterval = conf.getInt(ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL,
+            ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT);
+        scheduler.scheduleAtFixedRate(new Runnable() {
+          @Override
+          public void run() {
+            try {
+              rebuildTokenCache(false);
+            } catch (Exception e) {
+              // ignore
+            }
+          }
+        }, syncInterval, syncInterval, TimeUnit.SECONDS);
+      } catch (Exception e) {
+        LOG.error("Error rebuilding local cache for zkDelegationTokens ", e);
+      }
+    }
+  }
+
+  @Override
+  public void stopThreads() {
+    super.stopThreads();
+    scheduler.shutdown();
+  }
+
+  @Override
+
+  /**
+   * This function will rebuild local token cache from zk storage.
+   * It is first called when the secret manager is initialized and
+   * then regularly at a configured interval.
+   *
+   * @param initial whether this is called during initialization
+   * @throws IOException
+   */
+  private void rebuildTokenCache(boolean initial) throws IOException {
+    localTokenCache.clear();
+    // Use bare zookeeper client to get all children since curator will
+    // wrap the same API with a sorting process. This is time consuming given
+    // millions of tokens
+    List<String> zkTokens;
+    try {
+      zkTokens = zookeeper.getChildren(TOKEN_PATH, false);
+    } catch (KeeperException | InterruptedException e) {
+      throw new IOException("Tokens cannot be fetched from path "
+          + TOKEN_PATH, e);
+    }
+    byte[] data;
+    for (String tokenPath : zkTokens) {
+      try {
+        data = zkClient.getData().forPath(
+            ZK_DTSM_TOKENS_ROOT + "/" + tokenPath);
+      } catch (KeeperException.NoNodeException e) {
+        LOG.debug("No node in path [" + tokenPath + "]");
+        continue;
+      } catch (Exception ex) {
+        throw new IOException(ex);
+      }
+      // Store data to currentTokenMap
+      AbstractDelegationTokenIdentifier ident = processTokenAddOrUpdate(data);
+      // Store data to localTokenCache for sync
+      localTokenCache.add(ident);
+    }
+    if (!initial) {
+      // Sync zkTokens with local cache, specifically
+      // 1) add/update tokens to local cache from zk, which is done through
+      //    processTokenAddOrUpdate above
+      // 2) remove tokens in local cache but not in zk anymore
+      for (AbstractDelegationTokenIdentifier ident : currentTokens.keySet()) {
+        if (!localTokenCache.contains(ident)) {
+            currentTokens.remove(ident);
+        }
+      }
+    }
+  }
+
+  @Override
+  public AbstractDelegationTokenIdentifier cancelToken(
+      Token<AbstractDelegationTokenIdentifier> token, String canceller)
+      throws IOException {
+    checkAgainstZkBeforeDeletion.set(false);
+    AbstractDelegationTokenIdentifier ident = super.cancelToken(token,
+        canceller);
+    checkAgainstZkBeforeDeletion.set(true);
+    return ident;
+  }
+
+  @Override
+  protected void removeStoredToken(AbstractDelegationTokenIdentifier ident)
+      throws IOException {
+    super.removeStoredToken(ident, checkAgainstZkBeforeDeletion.get());
+  }
+
+  @Override
+  protected void addOrUpdateToken(AbstractDelegationTokenIdentifier ident,
+      DelegationTokenInformation info, boolean isUpdate) throws Exception {
+    // Store the data in local memory first
+    currentTokens.put(ident, info);
+    super.addOrUpdateToken(ident, info, isUpdate);
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS74 INS59 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS74 INS59 INS78 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS42 INS42 INS27 INS42 INS34 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS27 INS43 INS43 INS42 INS14 INS42 INS42 MOV21 INS25 INS42 INS21 INS21 INS65 INS65 INS65 INS39 INS42 INS42 INS21 INS60 INS54 INS60 INS70 INS25 INS42 INS42 INS74 INS42 INS43 INS42 INS42 INS21 INS60 INS21 INS41 INS42 INS43 INS42 INS42 INS21 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS21 INS21 INS42 INS45 INS42 INS42 INS42 INS42 INS74 INS45 INS32 INS42 INS42 INS42 INS74 INS1 INS38 INS8 INS48 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS32 INS74 INS59 INS8 INS12 INS5 INS59 INS44 INS42 INS8 INS38 INS8 INS43 INS43 INS42 INS32 INS43 INS59 INS32 INS42 INS42 INS48 INS42 INS42 INS32 INS48 INS43 INS42 INS42 INS43 INS43 INS31 INS21 INS32 INS21 INS54 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS21 INS44 INS8 INS39 INS85 INS42 INS43 INS42 INS54 INS60 INS21 INS42 INS70 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS48 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS78 INS83 INS43 INS42 INS8 INS32 INS42 INS32 INS8 INS12 INS42 INS42 INS7 INS84 INS42 INS53 INS42 INS8 INS12 INS12 INS43 INS59 INS32 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS45 INS21 INS25 INS54 INS21 INS60 INS21 INS21 INS60 INS21 INS44 INS8 INS42 INS32 INS43 INS43 INS14 INS21 INS44 INS8 INS44 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS25 INS9 INS32 INS27 INS8 INS8 INS12 INS8 INS32 INS39 INS59 INS32 INS32 INS39 INS59 INS32 INS43 INS42 INS21 INS42 INS42 INS42 INS9 INS42 INS42 INS43 INS27 INS42 INS7 INS43 INS42 INS21 INS18 INS43 INS42 INS53 INS42 INS42 INS42 INS38 INS8 INS42 INS42 INS9 INS32 INS33 INS21 INS21 INS44 INS8 INS25 INS42 INS42 INS45 INS42 INS32 INS42 INS9 INS42 INS42 INS45 INS27 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS32 INS42 INS45 INS42 INS42 INS32 INS40 INS32 INS42 INS14 INS32 INS21 INS32 INS42 INS42 INS32 INS7 INS43 INS42 INS21 INS27 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS1 INS42 INS42 INS45 INS42 INS32 INS42 INS27 INS42 INS42 INS27 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS42 INS31 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS42 INS40 INS32 INS42 INS42 INS42 INS45 INS42 INS14 INS78 INS83 INS39 INS42 INS8 INS32 INS42 INS42 INS42 INS43 INS45 INS42 INS54 INS42 INS42 INS42 INS8 INS12 INS21 INS44 INS8 INS32 INS43 INS42 INS42 INS9 INS42 DEL33
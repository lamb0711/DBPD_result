Merge remote-tracking branch 'apache/trunk' into HDFS-7285

+import org.apache.hadoop.util.ReflectionUtils;
-import org.apache.hadoop.yarn.logaggregation.ContainerLogsRetentionPolicy;
+import org.apache.hadoop.yarn.server.api.ContainerLogAggregationPolicy;
+import org.apache.hadoop.yarn.server.api.ContainerLogContext;
+import org.apache.hadoop.yarn.server.api.ContainerType;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.container.Container;
-  private final ContainerLogsRetentionPolicy retentionPolicy;
+  private final ContainerLogAggregationPolicy logAggPolicy;
-      ContainerLogsRetentionPolicy retentionPolicy,
-    this.retentionPolicy = retentionPolicy;
+    this.logAggPolicy = getLogAggPolicy(conf);
+  }
+
+  private ContainerLogAggregationPolicy getLogAggPolicy(Configuration conf) {
+    ContainerLogAggregationPolicy policy = getLogAggPolicyInstance(conf);
+    String params = getLogAggPolicyParameters(conf);
+    if (params != null) {
+      policy.parseParameters(params);
+    }
+    return policy;
+  }
+
+  // Use the policy class specified in LogAggregationContext if available.
+  // Otherwise use the cluster-wide default policy class.
+  private ContainerLogAggregationPolicy getLogAggPolicyInstance(
+      Configuration conf) {
+    Class<? extends ContainerLogAggregationPolicy> policyClass = null;
+    if (this.logAggregationContext != null) {
+      String className =
+          this.logAggregationContext.getLogAggregationPolicyClassName();
+      if (className != null) {
+        try {
+          Class<?> policyFromContext = conf.getClassByName(className);
+          if (ContainerLogAggregationPolicy.class.isAssignableFrom(
+              policyFromContext)) {
+            policyClass = policyFromContext.asSubclass(
+                ContainerLogAggregationPolicy.class);
+          } else {
+            LOG.warn(this.appId + " specified invalid log aggregation policy " +
+                className);
+          }
+        } catch (ClassNotFoundException cnfe) {
+          // We don't fail the app if the policy class isn't valid.
+          LOG.warn(this.appId + " specified invalid log aggregation policy " +
+              className);
+        }
+      }
+    }
+    if (policyClass == null) {
+      policyClass = conf.getClass(YarnConfiguration.NM_LOG_AGG_POLICY_CLASS,
+          AllContainerLogAggregationPolicy.class,
+              ContainerLogAggregationPolicy.class);
+    } else {
+      LOG.info(this.appId + " specifies ContainerLogAggregationPolicy of "
+          + policyClass);
+    }
+    return ReflectionUtils.newInstance(policyClass, conf);
+  }
+
+  // Use the policy parameters specified in LogAggregationContext if available.
+  // Otherwise use the cluster-wide default policy parameters.
+  private String getLogAggPolicyParameters(Configuration conf) {
+    String params = null;
+    if (this.logAggregationContext != null) {
+      params = this.logAggregationContext.getLogAggregationPolicyParameters();
+    }
+    if (params == null) {
+      params = conf.get(YarnConfiguration.NM_LOG_AGG_POLICY_CLASS_PARAMETERS);
+    }
+    return params;
-    //    and satisfy the retentionPolicy.
+    //    and satisfy the ContainerLogAggregationPolicy.
-    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,
-    // so simply set wasContainerSuccessful as true to
-    // bypass FAILED_CONTAINERS check and find the running containers 
-    // which satisfy the retentionPolicy.
+    //    we use exitCode of 0 to find those which satisfy the
+    //    ContainerLogAggregationPolicy.
-      for (ContainerId container : this.context.getApplications()
-        .get(this.appId).getContainers().keySet()) {
-        if (shouldUploadLogs(container, true)) {
-          pendingContainerInThisCycle.add(container);
+      for (Container container : this.context.getApplications()
+        .get(this.appId).getContainers().values()) {
+        ContainerType containerType =
+            container.getContainerTokenIdentifier().getContainerType();
+        if (shouldUploadLogs(new ContainerLogContext(
+            container.getContainerId(), containerType, 0))) {
+          pendingContainerInThisCycle.add(container.getContainerId());
-  private boolean shouldUploadLogs(ContainerId containerId,
-      boolean wasContainerSuccessful) {
-
-    // All containers
-    if (this.retentionPolicy
-        .equals(ContainerLogsRetentionPolicy.ALL_CONTAINERS)) {
-      return true;
-    }
-
-    // AM Container only
-    if (this.retentionPolicy
-        .equals(ContainerLogsRetentionPolicy.APPLICATION_MASTER_ONLY)) {
-      if ((containerId.getContainerId()
-          & ContainerId.CONTAINER_ID_BITMASK)== 1) {
-        return true;
-      }
-      return false;
-    }
-
-    // AM + Failing containers
-    if (this.retentionPolicy
-        .equals(ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY)) {
-      if ((containerId.getContainerId()
-          & ContainerId.CONTAINER_ID_BITMASK) == 1) {
-        return true;
-      } else if(!wasContainerSuccessful) {
-        return true;
-      }
-      return false;
-    }
-    return false;
+  private boolean shouldUploadLogs(ContainerLogContext logContext) {
+    return logAggPolicy.shouldDoLogAggregation(logContext);
-  public void startContainerLogAggregation(ContainerId containerId,
-      boolean wasContainerSuccessful) {
-    if (shouldUploadLogs(containerId, wasContainerSuccessful)) {
-      LOG.info("Considering container " + containerId
+  public void startContainerLogAggregation(ContainerLogContext logContext) {
+    if (shouldUploadLogs(logContext)) {
+      LOG.info("Considering container " + logContext.getContainerId()
-      this.pendingContainers.add(containerId);
+      this.pendingContainers.add(logContext.getContainerId());

MOV26 INS26 INS26 INS26 INS26 MOV23 INS40 UPD40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 UPD43 MOV21 MOV83 INS43 UPD42 MOV42 MOV44 INS8 INS83 INS43 INS42 MOV44 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 UPD42 UPD42 INS42 UPD43 UPD42 INS60 INS60 INS25 INS41 INS42 INS43 INS42 INS60 INS25 MOV25 MOV41 INS42 INS43 INS42 INS60 INS25 INS25 MOV41 INS43 INS42 MOV41 UPD43 UPD42 UPD42 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS42 INS74 INS59 INS27 INS8 INS27 INS8 INS32 INS42 INS43 INS59 INS27 INS8 INS27 INS8 INS42 INS42 INS32 UPD42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS43 INS76 INS42 INS33 INS22 INS33 INS60 INS25 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS22 INS33 INS21 INS42 INS33 INS21 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS52 INS42 INS43 INS59 INS27 INS8 INS7 INS32 INS52 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS54 INS42 INS32 INS42 INS42 INS27 INS42 INS32 INS42 INS32 UPD43 UPD42 INS60 INS32 MOV22 UPD42 MOV42 INS8 INS12 UPD42 MOV42 UPD42 MOV42 INS40 INS57 INS57 INS22 INS45 INS42 MOV22 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 INS43 INS59 INS32 INS42 UPD42 MOV42 UPD42 INS60 INS25 INS44 INS8 INS43 INS43 INS52 INS42 UPD42 INS42 INS42 INS32 INS14 INS42 INS42 INS74 INS59 INS32 MOV8 INS8 INS43 INS42 INS21 INS42 INS42 INS32 INS42 INS43 INS32 INS42 INS34 INS43 INS76 INS42 INS32 INS57 INS42 INS42 INS21 INS21 INS42 INS32 INS42 INS42 INS42 MOV42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS7 INS32 INS42 INS42 INS27 MOV42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS22 INS45 INS42 INS42 INS42 INS57 INS22 INS45 INS42 INS52 INS42 INS43 MOV52 UPD42 MOV42 INS42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL39 DEL42 DEL9 DEL41 DEL32 DEL40 DEL27 DEL36 DEL34 DEL27 DEL9 DEL41 DEL9 DEL9 DEL9 DEL9 DEL39 DEL40 DEL32 DEL25 DEL22 DEL42 DEL40 DEL32 DEL8 DEL25 DEL40 DEL32 DEL32 DEL40 DEL27 DEL36 DEL34 DEL27 DEL8 DEL42 DEL38 DEL8 DEL25 DEL25 DEL9 DEL41 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31 DEL39 DEL42 DEL44 DEL42 DEL42
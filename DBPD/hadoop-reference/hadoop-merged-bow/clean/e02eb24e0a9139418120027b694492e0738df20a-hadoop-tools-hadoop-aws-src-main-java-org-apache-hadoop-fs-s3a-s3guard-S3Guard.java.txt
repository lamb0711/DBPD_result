HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.

Contributed by Steve Loughran.

Change-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb

-import org.apache.hadoop.fs.s3a.Tristate;
-          conf.getPropertySources(S3_METADATA_STORE_IMPL));
+          (Object)conf.getPropertySources(S3_METADATA_STORE_IMPL));
+    return putAndReturn(ms, status, instrumentation, timeProvider, null);
+  }
+
+  /**
+   * Helper function which puts a given S3AFileStatus into the MetadataStore and
+   * returns the same S3AFileStatus. Instrumentation monitors the put operation.
+   * @param ms MetadataStore to {@code put()} into.
+   * @param status status to store
+   * @param instrumentation instrumentation of the s3a file system
+   * @param timeProvider Time provider to use when writing entries
+   * @param operationState possibly-null metastore state tracker.
+   * @return The same status as passed in
+   * @throws IOException if metadata store update failed
+   */
+  @RetryTranslated
+  public static S3AFileStatus putAndReturn(
+      final MetadataStore ms,
+      final S3AFileStatus status,
+      final S3AInstrumentation instrumentation,
+      final ITtlTimeProvider timeProvider,
+      @Nullable final BulkOperationState operationState) throws IOException {
-    S3Guard.putWithTtl(ms, new PathMetadata(status), timeProvider);
-    instrumentation.addValueToQuantiles(S3GUARD_METADATASTORE_PUT_PATH_LATENCY,
-        (System.nanoTime() - startTimeNano));
-    instrumentation.incrementCounter(S3GUARD_METADATASTORE_PUT_PATH_REQUEST, 1);
+    try {
+      putWithTtl(ms, new PathMetadata(status), timeProvider, operationState);
+    } finally {
+      instrumentation.addValueToQuantiles(
+          S3GUARD_METADATASTORE_PUT_PATH_LATENCY,
+          (System.nanoTime() - startTimeNano));
+      instrumentation.incrementCounter(
+          S3GUARD_METADATASTORE_PUT_PATH_REQUEST,
+          1);
+    }
+   * Initiate a bulk write and create an operation state for it.
+   * This may then be passed into put operations.
+   * @param metastore store
+   * @param operation the type of the operation.
+   * @param path path under which updates will be explicitly put.
+   * @return a store-specific state to pass into the put operations, or null
+   * @throws IOException failure
+   */
+  public static BulkOperationState initiateBulkWrite(
+      @Nullable final MetadataStore metastore,
+      final BulkOperationState.OperationType operation,
+      final Path path) throws IOException {
+    Preconditions.checkArgument(
+        operation != BulkOperationState.OperationType.Rename,
+        "Rename operations cannot be started through initiateBulkWrite");
+    if (metastore == null || isNullMetadataStore(metastore)) {
+      return null;
+    } else {
+      return metastore.initiateBulkWrite(operation, path);
+    }
+  }
+
+  /**
-          S3Guard.putWithTtl(ms, new PathMetadata(s), timeProvider);
+          S3Guard.putWithTtl(ms, new PathMetadata(s), timeProvider, null);
-      S3Guard.putWithTtl(ms, dirMeta, timeProvider);
+      S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);
-   * @param timeProvider Time provider for testing.
+   * @param timeProvider Time provider.
-          S3Guard.putWithTtl(ms, dirMeta, timeProvider);
+          S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);
-      S3Guard.putWithTtl(ms, pathMetas, timeProvider);
+      S3Guard.putWithTtl(ms, pathMetas, timeProvider, null);
-   * metadata to the supplied lists. It does not store in MetadataStore.
+   * metadata to the supplied lists. It does not update the MetadataStore.
-  public static void addAncestors(MetadataStore metadataStore,
-      Path qualifiedPath, String username, ITtlTimeProvider timeProvider)
-      throws IOException {
-    Collection<PathMetadata> newDirs = new ArrayList<>();
-    Path parent = qualifiedPath.getParent();
-    while (!parent.isRoot()) {
-      PathMetadata directory = metadataStore.get(parent);
-      if (directory == null || directory.isDeleted()) {
-        S3AFileStatus s3aStatus = new S3AFileStatus(Tristate.FALSE, parent, username);
-        PathMetadata meta = new PathMetadata(s3aStatus, Tristate.FALSE, false);
-        newDirs.add(meta);
-      } else {
-        break;
-      }
-      parent = parent.getParent();
-    }
-    S3Guard.putWithTtl(metadataStore, newDirs, timeProvider);
+  /**
+   * This adds all new ancestors of a path as directories.
+   * This forwards to
+   * {@link MetadataStore#addAncestors(Path, ITtlTimeProvider, BulkOperationState)}.
+   * <p>
+   * Originally it implemented the logic to probe for an add ancestors,
+   * but with the addition of a store-specific bulk operation state
+   * it became unworkable.
+   *
+   * @param metadataStore store
+   * @param qualifiedPath path to update
+   * @param operationState (nullable) operational state for a bulk update
+   * @throws IOException failure
+   */
+  @Retries.RetryTranslated
+  public static void addAncestors(
+      final MetadataStore metadataStore,
+      final Path qualifiedPath,
+      final ITtlTimeProvider timeProvider,
+      @Nullable final BulkOperationState operationState) throws IOException {
+    metadataStore.addAncestors(qualifiedPath, timeProvider, operationState);
+  /**
+   * Add the fact that a file was moved from a source path to a destination.
+   * @param srcPaths collection of source paths to update
+   * @param dstMetas collection of destination meta data entries to update.
+   * @param srcPath path of the source file.
+   * @param dstStatus status of the source file after it was copied.
+   */
+  /**
+   * Put a directory entry, setting the updated timestamp of the
+   * directory and its children.
+   * @param ms metastore
+   * @param dirMeta directory
+   * @param timeProvider nullable time provider
+   * @throws IOException failure.
+   */
-      ITtlTimeProvider timeProvider)
+      final ITtlTimeProvider timeProvider,
+      @Nullable final BulkOperationState operationState)
-    dirMeta.setLastUpdated(timeProvider.getNow());
+    long now = timeProvider.getNow();
+    dirMeta.setLastUpdated(now);
-        .forEach(pm -> pm.setLastUpdated(timeProvider.getNow()));
-    ms.put(dirMeta);
+        .forEach(pm -> pm.setLastUpdated(now));
+    ms.put(dirMeta, operationState);
+  /**
+   * Put an entry, using the time provider to set its timestamp.
+   * @param ms metastore
+   * @param fileMeta entry to write
+   * @param timeProvider nullable time provider
+   * @param operationState nullable state for a bulk update
+   * @throws IOException failure.
+   */
-      @Nullable ITtlTimeProvider timeProvider) throws IOException {
+      @Nullable ITtlTimeProvider timeProvider,
+      @Nullable final BulkOperationState operationState) throws IOException {
-    ms.put(fileMeta);
+    ms.put(fileMeta, operationState);
+  /**
+   * Put entries, using the time provider to set their timestamp.
+   * @param ms metastore
+   * @param fileMetas file metadata entries.
+   * @param timeProvider nullable time provider
+   * @param operationState nullable state for a bulk update
+   * @throws IOException failure.
+   */
-      Collection<PathMetadata> fileMetas,
-      @Nullable ITtlTimeProvider timeProvider)
+      Collection<? extends PathMetadata> fileMetas,
+      @Nullable ITtlTimeProvider timeProvider,
+      @Nullable final BulkOperationState operationState)
+    patchLastUpdated(fileMetas, timeProvider);
+    ms.put(fileMetas, operationState);
+  }
+
+  /**
+   * Patch any collection of metadata entries with the timestamp
+   * of a time provider.
+   * This <i>MUST</i> be used when creating new entries for directories.
+   * @param fileMetas file metadata entries.
+   * @param timeProvider nullable time provider
+   */
+  static void patchLastUpdated(
+      final Collection<? extends PathMetadata> fileMetas,
+      @Nullable final ITtlTimeProvider timeProvider) {
-    ms.put(fileMetas);
+  /**
+   * Get a path entry provided it is not considered expired.
+   * @param ms metastore
+   * @param path path to look up.
+   * @param timeProvider nullable time provider
+   * @return the metadata or null if there as no entry.
+   * @throws IOException failure.
+   */
-      // Special case: the pathmetadata's last updated is 0. This can happen
+      // Special case: the path metadata's last updated is 0. This can happen
-            + "not expired.");
+            + "not expired.", path);
+  /**
+   * List children; mark the result as non-auth if the TTL has expired.
+   * @param ms metastore
+   * @param path path to look up.
+   * @param timeProvider nullable time provider
+   * @return the listing of entries under a path, or null if there as no entry.
+   * @throws IOException failure.
+   */

INS31 INS31 INS31 INS31 INS8 INS29 INS78 MOV83 MOV83 MOV43 INS42 INS44 INS44 MOV44 MOV44 INS44 INS43 MOV8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 MOV43 INS8 INS29 INS78 INS83 INS83 INS39 INS42 MOV44 MOV44 INS44 INS44 INS43 INS8 INS29 INS29 INS44 INS29 INS44 INS29 INS83 INS83 INS39 INS42 MOV44 INS44 MOV44 INS44 MOV43 INS8 INS29 UPD42 INS44 INS29 INS29 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS83 MOV43 INS42 INS83 UPD43 UPD42 INS83 INS78 INS83 INS43 INS42 UPD42 MOV42 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS78 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS21 INS25 INS65 INS65 INS65 INS65 INS65 INS40 INS83 INS83 INS83 INS43 INS42 INS78 INS83 INS43 INS42 INS42 MOV21 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS83 INS78 INS83 INS43 INS42 INS60 INS65 INS65 INS65 INS65 INS65 INS65 INS78 INS83 INS43 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS74 INS42 INS78 INS83 INS43 INS42 INS21 INS21 INS65 INS65 INS65 INS83 UPD74 INS78 INS83 INS43 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS32 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 UPD42 INS42 UPD42 MOV42 INS8 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 UPD42 MOV42 INS40 INS42 INS32 MOV27 INS8 INS8 UPD66 UPD66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS39 INS59 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 MOV43 INS76 INS42 INS42 INS32 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS66 MOV43 INS76 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS33 INS66 MOV21 MOV21 MOV21 UPD42 MOV42 UPD42 MOV42 INS27 INS45 INS41 INS41 INS68 UPD42 INS42 INS42 INS42 MOV32 UPD42 MOV42 INS42 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS42 INS40 UPD42 UPD42 UPD42 INS33 INS32 INS42 INS42 INS69 INS69 INS69 INS11 INS42 INS42 INS42 INS42 INS42 INS33 INS33 MOV43 INS43 INS43 INS42 INS43 MOV32 INS42 INS42 INS42 INS42 INS33 INS33 DEL40 DEL26 DEL42 DEL42 DEL42 DEL39 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL40 DEL9 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL10 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL61 DEL8 DEL31 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL21
Revert "HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang."

This reverts commit c17439c2ddd921b63b1635e6f1cba634b8da8557.

-import org.apache.hadoop.hdfs.server.common.HdfsServerConstants;
+  public static final BlockInfoContiguous[] EMPTY_ARRAY = {};
-  protected BlockInfoContiguous(BlockInfo from) {
+  protected BlockInfoContiguous(BlockInfoContiguous from) {
+  /**
+   * Ensure that there is enough  space to include num more triplets.
+   * @return first free triplet index.
+   */
+  private int ensureCapacity(int num) {
+    assert this.triplets != null : "BlockInfo is not initialized";
+    int last = numNodes();
+    if (triplets.length >= (last+num)*3) {
+      return last;
+    }
+    /* Not enough space left. Create a new array. Should normally
+     * happen only when replication is manually increased by the user. */
+    Object[] old = triplets;
+    triplets = new Object[(last+num)*3];
+    System.arraycopy(old, 0, triplets, 0, last * 3);
+    return last;
+  }
+
-    return ContiguousBlockStorageOp.addStorage(this, storage);
+    // find the last null node
+    int lastNode = ensureCapacity(1);
+    setStorageInfo(lastNode, storage);
+    setNext(lastNode, null);
+    setPrevious(lastNode, null);
+    return true;
-    return ContiguousBlockStorageOp.removeStorage(this, storage);
+    int dnIndex = findStorageInfo(storage);
+    if (dnIndex < 0) { // the node is not found
+      return false;
+    }
+    assert getPrevious(dnIndex) == null && getNext(dnIndex) == null :
+        "Block is still in the list and must be removed first.";
+    // find the last not null node
+    int lastNode = numNodes()-1;
+    // replace current node triplet by the lastNode one
+    setStorageInfo(dnIndex, getStorageInfo(lastNode));
+    setNext(dnIndex, getNext(lastNode));
+    setPrevious(dnIndex, getPrevious(lastNode));
+    // set the last triplet to null
+    setStorageInfo(lastNode, null);
+    setNext(lastNode, null);
+    setPrevious(lastNode, null);
+    return true;
-    return ContiguousBlockStorageOp.numNodes(this);
+    assert this.triplets != null : "BlockInfo is not initialized";
+    assert triplets.length % 3 == 0 : "Malformed BlockInfo";
+
+    for (int idx = getCapacity()-1; idx >= 0; idx--) {
+      if (getDatanode(idx) != null) {
+        return idx + 1;
+      }
+    }
+    return 0;
-    ContiguousBlockStorageOp.replaceBlock(this, newBlock);
-  }
+    assert newBlock instanceof BlockInfoContiguous;
+    for (int i = this.numNodes() - 1; i >= 0; i--) {
+      final DatanodeStorageInfo storage = this.getStorageInfo(i);
+      final boolean removed = storage.removeBlock(this);
+      assert removed : "currentBlock not found.";
-  @Override
-  BlockInfoUnderConstruction convertCompleteBlockToUC(
-      HdfsServerConstants.BlockUCState s, DatanodeStorageInfo[] targets) {
-    BlockInfoUnderConstructionContiguous ucBlock =
-        new BlockInfoUnderConstructionContiguous(this,
-            getBlockCollection().getPreferredBlockReplication(), s, targets);
-    ucBlock.setBlockCollection(getBlockCollection());
-    return ucBlock;
+      final DatanodeStorageInfo.AddBlockResult result = storage.addBlock(
+          newBlock);
+      assert result == DatanodeStorageInfo.AddBlockResult.ADDED :
+          "newBlock already exists.";
+    }

INS23 INS31 INS31 INS31 INS83 INS83 INS83 INS5 INS59 INS29 INS83 INS39 INS42 INS44 INS8 MOV78 MOV39 MOV42 MOV44 MOV8 MOV78 MOV44 MOV78 INS8 MOV78 MOV39 MOV42 MOV44 INS8 INS43 INS85 INS42 INS4 UPD43 INS65 INS65 INS39 INS42 INS6 INS60 INS25 INS60 INS21 INS21 INS41 INS60 INS21 INS21 INS21 INS41 INS60 INS25 INS6 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS41 INS6 INS6 INS24 INS41 INS6 INS24 INS42 UPD42 INS66 INS66 INS27 INS45 INS39 INS59 INS27 INS8 INS5 INS59 INS7 INS32 INS42 INS39 INS59 INS32 INS32 INS32 INS9 INS39 INS59 INS27 INS8 INS27 INS45 INS39 INS59 INS32 INS32 INS32 INS32 INS32 INS32 INS9 INS27 INS45 INS27 INS45 INS58 INS27 INS37 INS8 INS34 INS62 INS58 INS27 INS37 INS8 INS22 INS33 INS42 INS32 INS40 INS27 INS41 INS43 INS85 INS42 INS42 INS42 INS3 INS42 INS42 INS42 INS34 INS42 INS34 INS27 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS32 INS42 INS34 INS41 INS27 INS27 INS42 INS27 UPD42 MOV42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS33 INS22 INS33 INS27 INS34 INS39 INS59 INS42 INS34 INS42 INS25 INS42 INS43 INS39 INS59 INS42 INS34 INS42 INS60 INS60 INS6 INS60 INS6 INS52 INS42 INS42 INS36 INS34 INS42 INS42 INS5 INS27 INS42 INS34 INS42 INS34 INS42 INS42 INS9 INS32 INS33 INS32 INS33 INS32 INS34 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS52 INS42 INS40 INS34 INS42 INS27 INS27 INS8 UPD42 MOV42 INS42 INS27 INS83 MOV43 INS59 INS83 INS39 INS59 INS42 INS45 INS83 INS43 INS59 INS27 INS45 INS27 INS43 INS85 INS36 INS34 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS32 INS33 INS41 INS32 INS34 INS42 INS32 INS42 INS32 INS40 INS42 INS32 INS42 INS40 INS42 INS42 INS42 INS27 INS42 UPD42 MOV42 UPD42 MOV42 INS27 INS52 INS42 INS52 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS52 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS34 DEL40 DEL26 DEL52 DEL32 DEL41 DEL42 DEL78 DEL31 DEL52 DEL32 DEL41 DEL52 DEL32 DEL41 DEL8 DEL42 DEL42 DEL52 DEL42 DEL32 DEL21 DEL8 DEL31 DEL43 DEL42 DEL40 DEL43 DEL42 DEL44 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL52 DEL32 DEL32 DEL42 DEL42 DEL14 DEL59 DEL60 DEL32 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31
HDFS-4244. Support snapshot deletion.  Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1430953 13f79535-47bb-0310-9956-ffa450edef68

-   *
+   * 
+   * <pre>
+   * </pre>
+    
+    /**
+     * Combine the posterior diff with this diff. This function needs to called
+     * before the posterior diff is to be deleted. In general we have:
+     * 
+     * <pre>
+     * 1. For (c, 0) in the posterior diff, check the inode in this diff:
+     * 1.1 (c', 0) in this diff: impossible
+     * 1.2 (0, d') in this diff: put in created --> (c, d')
+     * 1.3 (c', d') in this diff: impossible
+     * 1.4 (0, 0) in this diff: put in created --> (c, 0)
+     * This is the same logic with {@link #create(INode)}.
+     * 
+     * 2. For (0, d) in the posterior diff,
+     * 2.1 (c', 0) in this diff: remove from old created --> (0, 0)
+     * 2.2 (0, d') in this diff: impossible
+     * 2.3 (c', d') in this diff: remove from old created --> (0, d')
+     * 2.4 (0, 0) in this diff: put in deleted --> (0, d)
+     * This is the same logic with {@link #delete(INode)}.
+     * 
+     * 3. For (c, d) in the posterior diff,
+     * 3.1 (c', 0) in this diff: replace old created --> (c, 0)
+     * 3.2 (0, d') in this diff: impossible
+     * 3.3 (c', d') in this diff: replace old created --> (c, d')
+     * 3.4 (0, 0) in this diff: put in created and deleted --> (c, d)
+     * This is the same logic with {@link #modify(INode, INode)}.
+     * </pre>
+     * 
+     * Note that after this function the postDiff will be deleted.
+     * 
+     * @param the posterior diff to combine
+     * @param collectedBlocks Used in case 2.3, 3.1, and 3.3 to collect 
+     *                        information for blocksMap update
+     */
+    void combinePostDiff(Diff postDiff, BlocksMapUpdateInfo collectedBlocks) {
+      while (postDiff.created != null && !postDiff.created.isEmpty()) {
+        INode node = postDiff.created.remove(postDiff.created.size() - 1);
+        int deletedIndex = search(postDiff.deleted, node);
+        if (deletedIndex < 0) {
+          // for case 1
+          create(node);
+        } else {
+          // case 3
+          int createdIndex = search(created, node);
+          if (createdIndex < 0) {
+            // 3.4
+            create(node);
+            insertDeleted(node, search(deleted, node));
+          } else {
+            // 3.1 and 3.3
+            created.set(createdIndex, node);
+            // for 3.1 and 3.3, if the node is an INodeFileWithLink, need to
+            // remove d in the posterior diff from the circular list, also do
+            // possible block deletion and blocksMap updating
+            INode dInPost = postDiff.deleted.get(deletedIndex);
+            if (dInPost instanceof INodeFileWithLink) {
+              // dInPost must be an INodeFileWithLink
+              ((INodeFileWithLink) dInPost)
+                  .collectSubtreeBlocksAndClear(collectedBlocks);
+            }
+          }
+          // also remove the inode from the deleted list
+          postDiff.deleted.remove(deletedIndex);
+        }
+      }
+      
+      while (postDiff.deleted != null && !postDiff.deleted.isEmpty()) {
+        // case 2
+        INode node = postDiff.deleted.remove(postDiff.deleted.size() - 1);
+        Triple<Integer, INode, Integer> triple = delete(node);
+        // for 2.3, if the node is an INodeFileWithLink, need to remove c' from
+        // the circular list
+        INode cInCurrent = triple.middle;
+        if (cInCurrent instanceof INodeFileWithLink) {
+          ((INodeFileWithLink) cInCurrent)
+              .collectSubtreeBlocksAndClear(collectedBlocks);
+        }
+      }
+    }
+  
+  /**
+   * Delete the snapshot with the given name. The synchronization of the diff
+   * list will be done outside.
+   * 
+   * If the diff to remove is not the first one in the diff list, we need to 
+   * combine the diff with its previous one:
+   * 
+   * @param snapshot The snapshot to be deleted
+   * @param collectedBlocks Used to collect information for blocksMap update
+   * @return The SnapshotDiff containing the deleted snapshot. 
+   *         Null if the snapshot with the given name does not exist. 
+   */
+  SnapshotDiff deleteSnapshotDiff(Snapshot snapshot,
+      BlocksMapUpdateInfo collectedBlocks) {
+    int snapshotIndex = Collections.binarySearch(diffs, snapshot);
+    if (snapshotIndex == -1) {
+      return null;
+    } else {
+      SnapshotDiff diffToRemove = null;
+      diffToRemove = diffs.remove(snapshotIndex);
+      if (snapshotIndex > 0) {
+        // combine the to-be-removed diff with its previous diff
+        SnapshotDiff previousDiff = diffs.get(snapshotIndex - 1);
+        previousDiff.diff.combinePostDiff(diffToRemove.diff, collectedBlocks);
+        previousDiff.posteriorDiff = diffToRemove.posteriorDiff;
+        diffToRemove.posteriorDiff = null;
+      }
+      return diffToRemove;
+    }
+  }

INS31 INS31 INS29 INS43 INS42 INS44 INS44 INS8 INS29 INS39 INS42 INS44 INS44 INS8 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS60 INS25 INS66 INS66 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS61 INS61 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS39 INS59 INS27 INS8 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS27 INS8 INS42 INS32 INS42 INS38 INS41 INS60 INS21 INS25 INS41 INS68 INS68 INS68 INS27 INS38 INS60 INS60 INS25 INS27 INS38 INS60 INS60 INS60 INS25 INS42 INS42 INS42 INS42 INS34 INS33 INS43 INS59 INS7 INS27 INS8 INS42 INS42 INS69 INS42 INS69 INS42 INS69 INS69 INS40 INS33 INS32 INS43 INS59 INS39 INS59 INS27 INS8 INS8 INS40 INS33 INS32 INS43 INS59 INS74 INS59 INS43 INS59 INS62 INS8 INS42 INS42 INS33 INS42 INS32 INS42 INS34 INS60 INS21 INS21 INS21 INS43 INS43 INS43 INS43 INS40 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS34 INS21 INS60 INS25 INS21 INS40 INS42 INS42 INS42 INS32 INS43 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS40 INS42 INS43 INS21 INS42 INS42 INS42 INS43 INS59 INS32 INS7 INS7 INS42 INS42 INS42 INS42 INS40 INS42 INS27 INS42 INS40 INS42 INS32 INS39 INS59 INS27 INS8 INS8 INS32 INS40 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS40 INS42 INS40 INS42 INS40 INS40 INS40 INS33 INS32 INS34 INS42 INS42 INS42 INS32 INS42 INS34 INS21 INS21 INS21 INS60 INS25 INS40 INS42 INS42 INS32 INS34 INS36 INS42 INS42 INS42 INS42 INS27 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS43 INS59 INS62 INS8 INS40 INS42 INS11 INS42 INS34 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS21 INS43 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS36 INS42 INS42 INS11 INS43 INS42 INS42
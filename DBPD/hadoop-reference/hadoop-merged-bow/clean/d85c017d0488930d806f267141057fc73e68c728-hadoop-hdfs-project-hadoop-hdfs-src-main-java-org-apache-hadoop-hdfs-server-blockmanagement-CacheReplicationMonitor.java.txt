HDFS-5651. Remove dfs.namenode.caching.enabled and improve CRM locking. Contributed by Colin Patrick McCabe.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1555002 13f79535-47bb-0310-9956-ffa450edef68

-  private final ReentrantLock lock = new ReentrantLock();
+  private final ReentrantLock lock;
-  private final Condition doRescan = lock.newCondition();
+  private final Condition doRescan;
-  private final Condition scanFinished = lock.newCondition();
+  private final Condition scanFinished;
-   * The monotonic time at which the current scan started.
-   */
-  private long startTimeMs;
-
-  /**
-      CacheManager cacheManager, long intervalMs) {
+      CacheManager cacheManager, long intervalMs, ReentrantLock lock) {
+    this.lock = lock;
+    this.doRescan = this.lock.newCondition();
+    this.scanFinished = this.lock.newCondition();
-    startTimeMs = 0;
+    long startTimeMs = 0;
+    Thread.currentThread().setName("CacheReplicationMonitor(" +
+        System.identityHashCode(this) + ")");
-        // Not all of the variables accessed here need the CRM lock, but take
-        // it anyway for simplicity
-        } finally {
-          lock.unlock();
-        }
-        // Mark scan as started, clear needsRescan
-        lock.lock();
-        try {
-        // Retake the CRM lock to update synchronization-related variables
+        // Update synchronization-related variables.
+    } catch (InterruptedException e) {
+      LOG.info("Shutting down CacheReplicationMonitor.");
+      return;
-   * Similar to {@link CacheReplicationMonitor#waitForRescan()}, except it only
-   * waits if there are pending operations that necessitate a rescan as
-   * indicated by {@link #setNeedsRescan()}.
-   * <p>
-   * Note that this call may release the FSN lock, so operations before and
-   * after are not necessarily atomic.
-   */
-  public void waitForRescanIfNeeded() {
-    lock.lock();
-    try {
-      if (!needsRescan) {
-        return;
-      }
-    } finally {
-      lock.unlock();
-    }
-    waitForRescan();
-  }
-
-  /**
-  public void waitForRescan() {
-    // Drop the FSN lock temporarily and retake it after we finish waiting
-    // Need to handle both the read lock and the write lock
-    boolean retakeWriteLock = false;
-    if (namesystem.hasWriteLock()) {
-      namesystem.writeUnlock();
-      retakeWriteLock = true;
-    } else if (namesystem.hasReadLock()) {
-      namesystem.readUnlock();
-    } else {
-      // Expected to have at least one of the locks
-      Preconditions.checkState(false,
-          "Need to be holding either the read or write lock");
+  public void waitForRescanIfNeeded() {
+    Preconditions.checkArgument(!namesystem.hasWriteLock(),
+        "Must not hold the FSN write lock when waiting for a rescan.");
+    Preconditions.checkArgument(lock.isHeldByCurrentThread(),
+        "Must hold the CRM lock when waiting for a rescan.");
+    if (!needsRescan) {
+      return;
-    // try/finally for retaking FSN lock
-    try {
-      lock.lock();
-      // try/finally for releasing CRM lock
+    // If no scan is already ongoing, mark the CRM as dirty and kick
+    if (!isScanning) {
+      doRescan.signal();
+    }
+    // Wait until the scan finishes and the count advances
+    final long startCount = scanCount;
+    while ((!shutdown) && (startCount >= scanCount)) {
-        // If no scan is already ongoing, mark the CRM as dirty and kick
-        if (!isScanning) {
-          needsRescan = true;
-          doRescan.signal();
-        }
-        // Wait until the scan finishes and the count advances
-        final long startCount = scanCount;
-        while (startCount >= scanCount) {
-          try {
-            scanFinished.await();
-          } catch (InterruptedException e) {
-            LOG.warn("Interrupted while waiting for CacheReplicationMonitor"
-                + " rescan", e);
-            break;
-          }
-        }
-      } finally {
-        lock.unlock();
-      }
-    } finally {
-      if (retakeWriteLock) {
-        namesystem.writeLock();
-      } else {
-        namesystem.readLock();
+        scanFinished.await();
+      } catch (InterruptedException e) {
+        LOG.warn("Interrupted while waiting for CacheReplicationMonitor"
+            + " rescan", e);
+        break;
-    lock.lock();
-    try {
-      this.needsRescan = true;
-    } finally {
-      lock.unlock();
-    }
+    Preconditions.checkArgument(lock.isHeldByCurrentThread(),
+        "Must hold the CRM lock when setting the needsRescan bit.");
+    this.needsRescan = true;
-   * Shut down and join the monitor thread.
+   * Shut down the monitor thread.
+    Preconditions.checkArgument(namesystem.hasWriteLock());
+      // Since we hold both the FSN write lock and the CRM lock here,
+      // we know that the CRM thread cannot be currently modifying
+      // the cache manager state while we're closing it.
+      // Since the CRM thread checks the value of 'shutdown' after waiting
+      // for a lock, we know that the thread will not modify the cache
+      // manager state after this point.
-    try {
-      if (this.isAlive()) {
-        this.join(60000);
-      }
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  private void rescan() {
+  private void rescan() throws InterruptedException {
+      if (shutdown) {
+        throw new InterruptedException("CacheReplicationMonitor was " +
+            "shut down.");
+      }
-    if (!cacheManager.isActive()) {
-      return;
-    }
-    if (!cacheManager.isActive()) {
-      return;
-    }

INS44 UPD42 MOV8 MOV8 INS43 MOV43 INS42 INS21 INS21 INS21 INS60 INS21 INS21 INS21 MOV25 INS21 MOV21 INS42 INS7 INS7 INS7 INS39 INS59 INS32 INS12 INS32 INS32 INS27 INS32 UPD66 INS22 INS42 INS22 INS32 INS22 INS32 INS42 INS34 MOV32 INS42 INS27 MOV44 INS8 INS42 INS42 INS38 INS45 INS42 INS42 INS32 INS45 INS36 INS36 INS42 INS42 INS32 INS45 UPD42 MOV42 UPD42 MOV42 INS32 INS25 INS52 INS42 INS52 INS42 INS22 INS42 INS52 INS42 INS22 INS42 INS42 INS42 INS45 INS32 INS45 INS21 INS41 MOV32 INS42 INS42 INS38 MOV27 INS42 INS42 UPD42 MOV42 INS42 INS42 INS8 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS32 INS42 INS53 INS42 INS42 INS45 INS14 MOV21 MOV21 INS43 INS27 INS42 INS45 INS45 DEL14 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL34 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL66 DEL42 DEL42 DEL68 DEL65 DEL66 DEL66 DEL66 DEL42 DEL68 DEL65 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL9 DEL7 DEL21 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL9 DEL45 DEL32 DEL21 DEL8 DEL25 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL52 DEL42 DEL32 DEL52 DEL42 DEL34 DEL32 DEL21 DEL8 DEL25 DEL8 DEL8 DEL12 DEL54 DEL42 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25
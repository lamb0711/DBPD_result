YARN-7174. Add retry logic in LogsCLI when fetch running application logs. Contributed by Xuan Gong.

+import java.net.ConnectException;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import com.sun.jersey.api.client.ClientRequest;
+import com.sun.jersey.api.client.filter.ClientFilter;
+  private static final String CLIENT_MAX_RETRY_OPTION = "client_max_retries";
+  private static final String CLIENT_RETRY_INTERVAL_OPTION
+      = "client_retry_interval_ms";
+
+  private Client webServiceClient = null;
+
+  private static final int DEFAULT_MAX_RETRIES = 30;
+  private static final long DEFAULT_RETRY_INTERVAL = 1000;
+
+  @Private
+  @VisibleForTesting
+  ClientConnectionRetry connectionRetry;
+      webServiceClient = Client.create();
+    int maxRetries = DEFAULT_MAX_RETRIES;
+    long retryInterval = DEFAULT_RETRY_INTERVAL;
+      if (commandLine.hasOption(CLIENT_MAX_RETRY_OPTION)) {
+        maxRetries = Integer.parseInt(commandLine.getOptionValue(
+            CLIENT_MAX_RETRY_OPTION));
+      }
+      if (commandLine.hasOption(CLIENT_RETRY_INTERVAL_OPTION)) {
+        retryInterval = Long.parseLong(commandLine.getOptionValue(
+            CLIENT_RETRY_INTERVAL_OPTION));
+      }
+    // Set up Retry WebService Client
+    connectionRetry = new ClientConnectionRetry(maxRetries, retryInterval);
+    ClientJerseyRetryFilter retryFilter = new ClientJerseyRetryFilter();
+    webServiceClient.addFilter(retryFilter);
+
-    Client webServiceClient = Client.create();
-    Client webServiceClient = Client.create();
-    Client webServiceClient = Client.create();
-
-      Client webServiceClient = Client.create();
+  /**
+   * Create Command Options.
+   * @return the command options
+   */
+    opts.addOption(CLIENT_MAX_RETRY_OPTION, true, "Set max retry number for a"
+        + " retry client to get the container logs for the running "
+        + "applications. Use a negative value to make retry forever. "
+        + "The default value is 30.");
+    opts.addOption(CLIENT_RETRY_INTERVAL_OPTION, true,
+        "Work with --client_max_retries to create a retry client. "
+        + "The default value is 1000.");
+    opts.getOption(CLIENT_MAX_RETRY_OPTION).setArgName("Max Retries");
+    opts.getOption(CLIENT_RETRY_INTERVAL_OPTION)
+        .setArgName("Retry Interval");
+  /**
+   * Create Print options for helper message.
+   * @param commandOpts the options
+   * @return the print options
+   */
+    printOpts.addOption(commandOpts.getOption(CLIENT_MAX_RETRY_OPTION));
+    printOpts.addOption(commandOpts.getOption(CLIENT_RETRY_INTERVAL_OPTION));
+
+  // Class to handle retry
+  static class ClientConnectionRetry {
+
+    // maxRetries < 0 means keep trying
+    @Private
+    @VisibleForTesting
+    public int maxRetries;
+
+    @Private
+    @VisibleForTesting
+    public long retryInterval;
+
+    // Indicates if retries happened last time. Only tests should read it.
+    // In unit tests, retryOn() calls should _not_ be concurrent.
+    private boolean retried = false;
+
+    @Private
+    @VisibleForTesting
+    boolean getRetired() {
+      return retried;
+    }
+
+    // Constructor with default retry settings
+    public ClientConnectionRetry(int inputMaxRetries,
+        long inputRetryInterval) {
+      this.maxRetries = inputMaxRetries;
+      this.retryInterval = inputRetryInterval;
+    }
+
+    public Object retryOn(ClientRetryOp op)
+        throws RuntimeException, IOException {
+      int leftRetries = maxRetries;
+      retried = false;
+
+      // keep trying
+      while (true) {
+        try {
+          // try perform the op, if fail, keep retrying
+          return op.run();
+        } catch (IOException | RuntimeException e) {
+          // break if there's no retries left
+          if (leftRetries == 0) {
+            break;
+          }
+          if (op.shouldRetryOn(e)) {
+            logException(e, leftRetries);
+          } else {
+            throw e;
+          }
+        }
+        if (leftRetries > 0) {
+          leftRetries--;
+        }
+        retried = true;
+        try {
+          // sleep for the given time interval
+          Thread.sleep(retryInterval);
+        } catch (InterruptedException ie) {
+          System.out.println("Client retry sleep interrupted! ");
+        }
+      }
+      throw new RuntimeException("Connection retries limit exceeded.");
+    };
+
+    private void logException(Exception e, int leftRetries) {
+      if (leftRetries > 0) {
+        System.out.println("Exception caught by ClientConnectionRetry,"
+              + " will try " + leftRetries + " more time(s).\nMessage: "
+              + e.getMessage());
+      } else {
+        // note that maxRetries may be -1 at the very beginning
+        System.out.println("ConnectionException caught by ClientConnectionRetry,"
+            + " will keep retrying.\nMessage: "
+            + e.getMessage());
+      }
+    }
+  }
+
+  private class ClientJerseyRetryFilter extends ClientFilter {
+    @Override
+    public ClientResponse handle(final ClientRequest cr)
+        throws ClientHandlerException {
+      // Set up the retry operation
+      ClientRetryOp jerseyRetryOp = new ClientRetryOp() {
+        @Override
+        public Object run() {
+          // Try pass the request, if fail, keep retrying
+          return getNext().handle(cr);
+        }
+
+        @Override
+        public boolean shouldRetryOn(Exception e) {
+          // Only retry on connection exceptions
+          return (e instanceof ClientHandlerException)
+              && (e.getCause() instanceof ConnectException ||
+                  e.getCause() instanceof SocketTimeoutException ||
+                  e.getCause() instanceof SocketException);
+        }
+      };
+      try {
+        return (ClientResponse) connectionRetry.retryOn(jerseyRetryOp);
+      } catch (IOException e) {
+        throw new ClientHandlerException("Jersey retry failed!\nMessage: "
+              + e.getMessage());
+      }
+    }
+  }
+
+  // Abstract class for an operation that should be retried by client
+  private static abstract class ClientRetryOp {
+    // The operation that should be retried
+    public abstract Object run() throws IOException;
+    // The method to indicate if we should retry given the incoming exception
+    public abstract boolean shouldRetryOn(Exception e);
+  }

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS55 INS55 INS55 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 MOV43 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS78 INS78 INS43 INS59 INS29 INS29 INS83 INS42 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS83 INS42 INS43 INS31 INS83 INS83 INS83 INS42 INS31 INS31 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS33 INS42 INS34 INS42 INS34 INS42 INS42 INS42 INS42 INS60 INS60 INS21 INS60 INS21 INS65 INS65 INS21 INS21 INS21 INS21 INS65 INS65 INS65 INS21 INS21 INS78 INS78 INS83 INS39 INS59 INS78 INS78 INS83 INS39 INS59 INS83 INS39 INS59 INS78 INS78 INS39 INS42 INS8 INS83 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS42 INS78 INS83 INS43 INS42 INS44 INS43 INS8 INS83 INS83 INS43 INS42 INS43 INS83 INS83 INS39 INS42 INS44 INS39 INS59 INS39 INS59 INS7 INS43 INS59 INS32 INS66 INS66 INS32 INS32 INS32 INS32 INS66 INS42 INS66 INS66 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS41 INS39 INS42 INS39 INS42 INS21 INS21 INS42 INS43 INS42 INS42 INS42 INS60 INS21 INS61 INS53 INS43 INS42 INS39 INS42 INS25 INS42 INS42 INS83 INS43 INS42 INS42 INS60 INS54 INS42 INS42 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS25 INS25 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS27 INS42 INS42 INS42 INS9 INS27 INS32 INS42 INS45 INS32 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS7 INS7 INS42 INS39 INS59 INS7 INS9 INS8 INS14 INS42 INS27 INS8 INS8 INS42 INS43 INS59 INS8 INS12 INS42 INS7 INS32 INS8 INS32 INS8 INS43 INS42 INS42 INS43 INS45 INS45 INS45 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS42 INS9 INS54 INS25 INS21 INS54 INS43 INS45 INS42 INS34 INS21 INS21 INS42 INS42 INS14 INS41 INS44 INS8 INS42 MOV32 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS21 INS42 INS42 INS52 INS42 INS52 INS42 INS8 INS12 INS27 INS8 INS7 INS8 INS12 INS42 INS32 INS32 INS43 INS1 INS11 INS43 INS42 INS53 INS7 INS7 INS41 INS44 INS8 INS42 INS34 INS21 INS42 INS9 INS21 INS44 INS8 INS40 INS42 INS27 INS40 INS42 INS27 INS42 INS31 INS31 INS43 INS32 INS42 INS14 INS42 INS32 INS42 INS32 INS32 INS84 INS42 INS25 INS25 INS37 INS32 INS43 INS42 INS21 INS27 INS42 INS45 INS32 INS45 INS45 INS32 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS43 INS43 INS27 INS8 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS43 INS42 INS41 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS10 INS42 INS42 INS42 INS21 INS53 INS40 INS42 INS45 INS32 INS42 INS27 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS36 INS36 INS42 INS42 INS42 INS42 INS62 INS27 INS42 INS43 INS62 INS62 INS62 INS42 INS32 INS43 INS32 INS43 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60
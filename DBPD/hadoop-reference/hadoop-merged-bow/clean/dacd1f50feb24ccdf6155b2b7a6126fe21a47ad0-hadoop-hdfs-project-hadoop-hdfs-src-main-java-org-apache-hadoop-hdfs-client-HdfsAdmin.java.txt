HDFS-10324. Trash directory in an encryption zone should be pre-created with correct permissions. Contributed by Wei-Chiu Chuang.

+import org.apache.hadoop.HadoopIllegalArgumentException;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.permission.FsAction;
+import org.apache.hadoop.fs.permission.FsPermission;
+  private static final FsPermission TRASH_PERMISSION = new FsPermission(
+      FsAction.ALL, FsAction.ALL, FsAction.ALL, true);
+  @Deprecated
-    throws IOException, AccessControlException, FileNotFoundException {
+      throws IOException, AccessControlException, FileNotFoundException {
+   * Create an encryption zone rooted at an empty existing directory, using the
+   * specified encryption key. An encryption zone has an associated encryption
+   * key used when reading and writing files within the zone.
+   *
+   * Additional options, such as provisioning the trash directory, can be
+   * specified using {@link CreateEncryptionZoneFlag} flags.
+   *
+   * @param path    The path of the root of the encryption zone. Must refer to
+   *                an empty, existing directory.
+   * @param keyName Name of key available at the KeyProvider.
+   * @param flags   flags for this operation.
+   * @throws IOException            if there was a general IO exception
+   * @throws AccessControlException if the caller does not have access to path
+   * @throws FileNotFoundException  if the path does not exist
+   * @throws HadoopIllegalArgumentException if the flags are invalid
+   */
+  public void createEncryptionZone(Path path, String keyName,
+      EnumSet<CreateEncryptionZoneFlag> flags)
+      throws IOException, AccessControlException, FileNotFoundException,
+      HadoopIllegalArgumentException{
+    dfs.createEncryptionZone(path, keyName);
+    if (flags.contains(CreateEncryptionZoneFlag.PROVISION_TRASH)) {
+      if (flags.contains(CreateEncryptionZoneFlag.NO_TRASH)) {
+        throw new HadoopIllegalArgumentException(
+            "can not have both PROVISION_TRASH and NO_TRASH flags");
+      }
+      this.provisionEZTrash(path);
+    }
+  }
+
+  /**
+   * Provision a trash directory for a given encryption zone.
+
+   * @param path the root of the encryption zone
+   * @throws IOException if the trash directory can not be created.
+   */
+  public void provisionEncryptionZoneTrash(Path path) throws IOException {
+    this.provisionEZTrash(path);
+  }
+
+  /**
+
+  private void provisionEZTrash(Path path) throws IOException {
+    // make sure the path is an EZ
+    EncryptionZone ez = dfs.getEZForPath(path);
+    if (ez == null) {
+      throw new IllegalArgumentException(path + " is not an encryption zone.");
+    }
+
+    String ezPath = ez.getPath();
+    if (!path.toString().equals(ezPath)) {
+      throw new IllegalArgumentException(path + " is not the root of an " +
+          "encryption zone. Do you mean " + ez.getPath() + "?");
+    }
+
+    // check if the trash directory exists
+
+    Path trashPath = new Path(ez.getPath(), FileSystem.TRASH_PREFIX);
+
+    if (dfs.exists(trashPath)) {
+      String errMessage = "Will not provision new trash directory for " +
+          "encryption zone " + ez.getPath() + ". Path already exists.";
+      FileStatus trashFileStatus = dfs.getFileStatus(trashPath);
+      if (!trashFileStatus.isDirectory()) {
+        errMessage += "\r\n" +
+            "Warning: " + trashPath.toString() + " is not a directory";
+      }
+      if (!trashFileStatus.getPermission().equals(TRASH_PERMISSION)) {
+        errMessage += "\r\n" +
+            "Warning: the permission of " +
+            trashPath.toString() + " is not " + TRASH_PERMISSION;
+      }
+      throw new IOException(errMessage);
+    }
+
+    // Update the permission bits
+    dfs.mkdir(trashPath, TRASH_PERMISSION);
+    dfs.setPermission(trashPath, TRASH_PERMISSION);
+  }
+

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS78 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 INS43 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS42 INS42 INS14 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS74 INS42 INS42 INS42 INS42 INS42 INS21 INS25 INS65 INS65 INS65 INS43 INS42 INS42 INS21 INS43 INS42 INS42 INS60 INS25 INS60 INS25 INS60 INS25 INS21 INS21 INS43 INS40 INS40 INS40 INS9 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS43 INS32 INS32 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS42 INS43 INS59 INS27 INS8 INS43 INS59 INS38 INS8 INS43 INS59 INS32 INS8 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS25 INS21 INS52 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS32 INS32 INS53 INS42 INS42 INS14 INS42 INS42 INS42 INS60 INS60 INS25 INS25 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS32 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS14 INS43 INS32 INS40 INS43 INS59 INS43 INS59 INS38 INS8 INS38 INS8 INS14 INS42 INS42 INS40 INS53 INS52 INS42 INS42 INS43 INS27 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS32 INS21 INS32 INS21 INS43 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS45 INS45 INS32 INS45 INS27 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS7 INS32 INS42 INS42 INS7 INS42 INS43 INS45 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS27 INS32 INS45 INS27 INS32 INS45 INS42 INS45 INS45 INS42 INS42 INS45 INS45 INS42 INS42
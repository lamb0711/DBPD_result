Merge trunk into HDFS-1623 branch.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1158072 13f79535-47bb-0310-9956-ffa450edef68

+import static org.apache.hadoop.hdfs.server.common.Util.now;
+
+import org.apache.hadoop.HadoopIllegalArgumentException;
+import org.apache.hadoop.hdfs.server.protocol.BalancerBandwidthCommand;
-import org.apache.hadoop.hdfs.server.protocol.BalancerBandwidthCommand;
+import org.apache.hadoop.hdfs.util.CyclicIteration;
-import org.apache.hadoop.util.CyclicIteration;
-  final FSNamesystem namesystem;
+  private final FSNamesystem namesystem;
+  private final BlockManager blockManager;
+
+  private final HeartbeatManager heartbeatManager;
-  DatanodeManager(final FSNamesystem namesystem, final Configuration conf
+  DatanodeManager(final BlockManager blockManager,
+      final FSNamesystem namesystem, final Configuration conf
+    this.blockManager = blockManager;
+
+    this.heartbeatManager = new HeartbeatManager(namesystem, conf);
+
+
+    heartbeatManager.activate(conf);
+    heartbeatManager.close();
-  
+
+  /** @return the heartbeat manager. */
+  HeartbeatManager getHeartbeatManager() {
+    return heartbeatManager;
+  }
+
+  /** @return the datanode statistics. */
+  public DatanodeStatistics getDatanodeStatistics() {
+    return heartbeatManager;
+  }
+
+  /**
+   * Remove a datanode descriptor.
+   * @param nodeInfo datanode descriptor.
+   */
+  private void removeDatanode(DatanodeDescriptor nodeInfo) {
+    assert namesystem.hasWriteLock();
+    heartbeatManager.removeDatanode(nodeInfo);
+    blockManager.removeBlocksAssociatedTo(nodeInfo);
+    networktopology.remove(nodeInfo);
+
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("remove datanode " + nodeInfo.getName());
+    }
+    namesystem.checkSafeMode();
+  }
+
+  /**
+   * Remove a datanode
+   * @throws UnregisteredNodeException 
+   */
+  public void removeDatanode(final DatanodeID node
+      ) throws UnregisteredNodeException {
+    namesystem.writeLock();
+    try {
+      final DatanodeDescriptor descriptor = getDatanode(node);
+      if (descriptor != null) {
+        removeDatanode(descriptor);
+      } else {
+        NameNode.stateChangeLog.warn("BLOCK* removeDatanode: "
+                                     + node.getName() + " does not exist");
+      }
+    } finally {
+      namesystem.writeUnlock();
+    }
+  }
+
-  public void removeDeadDatanode(final DatanodeID nodeID) {
-    synchronized(namesystem.heartbeats) {
+  void removeDeadDatanode(final DatanodeID nodeID) {
-          namesystem.removeDatanode(d);
+          removeDatanode(d);
-    }
-  public boolean isDatanodeDead(DatanodeDescriptor node) {
+  boolean isDatanodeDead(DatanodeDescriptor node) {
-  public void removeDecomNodeFromList(final List<DatanodeDescriptor> nodeList) {
+  private void removeDecomNodeFromList(final List<DatanodeDescriptor> nodeList) {
-      namesystem.getBlockManager().startDecommission(nodeReg);
+      startDecommission(nodeReg);
-  
+  /**
+   * Change, if appropriate, the admin state of a datanode to 
+   * decommission completed. Return true if decommission is complete.
+   */
+  boolean checkDecommissionState(DatanodeDescriptor node) {
+    // Check to see if all blocks in this decommissioned
+    // node has reached their target replication factor.
+    if (node.isDecommissionInProgress()) {
+      if (!blockManager.isReplicationInProgress(node)) {
+        node.setDecommissioned();
+        LOG.info("Decommission complete for node " + node.getName());
+      }
+    }
+    return node.isDecommissioned();
+  }
+
+  /** Start decommissioning the specified datanode. */
+  private void startDecommission(DatanodeDescriptor node) throws IOException {
+    if (!node.isDecommissionInProgress() && !node.isDecommissioned()) {
+      LOG.info("Start Decommissioning node " + node.getName() + " with " + 
+          node.numBlocks() +  " blocks.");
+      heartbeatManager.startDecommission(node);
+      node.decommissioningStatus.setStartTime(now());
+      
+      // all the blocks that reside on this node have to be replicated.
+      checkDecommissionState(node);
+    }
+  }
+
+  /** Stop decommissioning the specified datanodes. */
+  void stopDecommission(DatanodeDescriptor node) throws IOException {
+    if (node.isDecommissionInProgress() || node.isDecommissioned()) {
+      LOG.info("Stop Decommissioning node " + node.getName());
+      heartbeatManager.stopDecommission(node);
+      blockManager.processOverReplicatedBlocksOnReCommission(node);
+    }
+  }
+
-    nodeReg.exportedKeys = namesystem.getBlockManager().getBlockKeys();
+    nodeReg.exportedKeys = blockManager.getBlockKeys();
-      namesystem.removeDatanode(nodeN);
+      removeDatanode(nodeN);
-      synchronized(namesystem.heartbeats) {
-        if( !namesystem.heartbeats.contains(nodeS)) {
-          namesystem.heartbeats.add(nodeS);
-          //update its timestamp
-          nodeS.updateHeartbeat(0L, 0L, 0L, 0L, 0, 0);
-          nodeS.isAlive = true;
-        }
-      }
+      heartbeatManager.register(nodeS);
-    synchronized(namesystem.heartbeats) {
-      namesystem.heartbeats.add(nodeDescr);
-      nodeDescr.isAlive = true;
-      // no need to update its timestamp
-      // because its is done when the descriptor is created
+    // no need to update its timestamp
+    // because its is done when the descriptor is created
+    heartbeatManager.addDatanode(nodeDescr);
+  }
+
+  /**
+   * Rereads conf to get hosts and exclude list file names.
+   * Rereads the files to update the hosts and exclude lists.  It
+   * checks if any of the hosts have changed states:
+   */
+  public void refreshNodes(final Configuration conf) throws IOException {
+    namesystem.checkSuperuserPrivilege();
+    refreshHostsReader(conf);
+    namesystem.writeLock();
+    try {
+      refreshDatanodes();
+    } finally {
+      namesystem.writeUnlock();
-  public void refreshHostsReader(Configuration conf) throws IOException {
+  private void refreshHostsReader(Configuration conf) throws IOException {
-   * Rereads the config to get hosts and exclude list file names.
-   * Rereads the files to update the hosts and exclude lists.  It
-   * checks if any of the hosts have changed states:
-  public void refreshDatanodes() throws IOException {
+  private void refreshDatanodes() throws IOException {
-        node.setDisallowed(true);  // case 2.
+        node.setDisallowed(true); // case 2.
-          namesystem.getBlockManager().startDecommission(node);   // case 3.
+          startDecommission(node); // case 3.
-          namesystem.getBlockManager().stopDecommission(node);   // case 4.
+          stopDecommission(node); // case 4.
+  /** @return list of datanodes where decommissioning is in progress. */
+  public List<DatanodeDescriptor> getDecommissioningNodes() {
+    namesystem.readLock();
+    try {
+      final List<DatanodeDescriptor> decommissioningNodes
+          = new ArrayList<DatanodeDescriptor>();
+      final List<DatanodeDescriptor> results = getDatanodeListForReport(
+          DatanodeReportType.LIVE);
+      for(DatanodeDescriptor node : results) {
+        if (node.isDecommissionInProgress()) {
+          decommissioningNodes.add(node);
+        }
+      }
+      return decommissioningNodes;
+    } finally {
+      namesystem.readUnlock();
+    }
+  }
+
+
-  public void fetchDatanodess(final List<DatanodeDescriptor> live, 
-      final List<DatanodeDescriptor> dead) {
-    final List<DatanodeDescriptor> results =
-        getDatanodeListForReport(DatanodeReportType.ALL);    
-    for(DatanodeDescriptor node : results) {
-      if (isDatanodeDead(node))
-        dead.add(node);
-      else
-        live.add(node);
+  public void fetchDatanodes(final List<DatanodeDescriptor> live, 
+      final List<DatanodeDescriptor> dead, final boolean removeDecommissionNode) {
+    if (live == null && dead == null) {
+      throw new HadoopIllegalArgumentException("Both live and dead lists are null");
+    }
+
+    namesystem.readLock();
+    try {
+      final List<DatanodeDescriptor> results =
+          getDatanodeListForReport(DatanodeReportType.ALL);    
+      for(DatanodeDescriptor node : results) {
+        if (isDatanodeDead(node)) {
+          if (dead != null) {
+            dead.add(node);
+          }
+        } else {
+          if (live != null) {
+            live.add(node);
+          }
+        }
+      }
+    } finally {
+      namesystem.readUnlock();
+    }
+    
+    if (removeDecommissionNode) {
+      if (live != null) {
+        removeDecomNodeFromList(live);
+      }
+      if (dead != null) {
+        removeDecomNodeFromList(dead);
+      }
-    synchronized (namesystem.heartbeats) {
+    synchronized (heartbeatManager) {
-        namesystem.updateStats(nodeinfo, false);
-        nodeinfo.updateHeartbeat(capacity, dfsUsed, remaining, blockPoolUsed,
-            xceiverCount, failedVolumes);
-        namesystem.updateStats(nodeinfo, true);
+        heartbeatManager.updateHeartbeat(nodeinfo, capacity, dfsUsed,
+            remaining, blockPoolUsed, xceiverCount, failedVolumes);
-        namesystem.addKeyUpdateCommand(cmds, nodeinfo);
+        blockManager.addKeyUpdateCommand(cmds, nodeinfo);

MOV26 MOV26 INS26 INS26 INS40 INS40 UPD40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS44 INS29 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 MOV8 UPD83 INS29 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 UPD83 UPD83 INS29 INS83 INS74 INS42 INS8 UPD42 INS44 INS8 INS42 INS42 INS42 INS42 INS83 INS43 INS42 INS21 INS21 INS21 INS21 INS65 INS42 INS41 INS65 INS42 INS41 INS65 INS65 INS43 INS42 INS6 INS21 INS21 INS21 INS25 INS21 INS65 INS65 INS83 INS43 INS42 INS42 INS21 INS54 INS65 INS43 INS42 INS25 INS41 INS65 INS43 INS42 INS42 INS25 INS65 INS43 INS42 INS42 INS25 MOV21 INS65 INS83 INS43 INS42 INS42 INS21 INS21 INS21 INS54 INS65 INS43 INS43 INS21 INS54 INS83 INS39 INS42 INS25 INS21 INS54 INS25 INS42 INS7 INS7 INS32 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS32 INS32 INS32 INS32 INS8 INS32 INS66 INS42 INS66 INS42 INS32 INS8 INS8 INS66 INS66 INS42 INS32 INS8 INS32 INS66 INS42 INS27 INS8 INS66 INS42 INS27 INS8 INS66 INS66 INS66 INS42 INS32 INS32 INS32 INS8 INS8 INS66 INS42 INS42 INS32 INS8 INS8 INS27 INS8 INS32 MOV8 INS8 INS42 INS8 INS42 INS22 INS42 INS22 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS60 INS25 INS21 INS42 INS42 INS25 INS42 INS42 INS38 INS38 INS21 INS21 INS21 INS21 INS32 INS32 INS21 INS21 INS21 MOV21 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS60 INS60 INS70 INS41 INS21 INS27 INS27 INS53 INS42 INS42 INS21 INS25 INS25 INS52 INS42 INS52 INS42 INS43 INS42 INS42 INS32 INS83 INS43 INS59 INS27 INS8 INS8 INS32 INS38 INS8 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS32 UPD42 MOV42 INS32 INS32 INS83 INS74 INS59 INS83 INS74 INS59 INS44 INS42 INS8 INS42 INS32 INS42 INS33 INS42 INS33 INS14 INS32 INS27 INS8 INS27 INS8 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS32 INS43 INS42 INS25 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS33 INS21 INS42 INS33 INS21 INS45 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS32 INS42 INS42 INS74 INS42 INS42 INS42 INS40 INS42 INS32 INS8 INS42 INS8 INS8 INS32 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS27 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS21 INS25 INS25 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS45 INS32 INS45 INS45 INS32 INS42 INS42 INS32 INS27 INS8 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 MOV21 INS42 INS33 MOV21 DEL83 DEL42 DEL40 DEL51 DEL8 DEL83 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL34 DEL34 DEL34 DEL34 DEL34 DEL34 DEL32 DEL21 DEL40 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL51 DEL40 DEL40 DEL40 DEL9 DEL7 DEL21 DEL8 DEL51 DEL66 DEL66 DEL66 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21
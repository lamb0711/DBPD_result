HDFS-6934. Move checksum computation off the hot path when writing to RAM disk. Contributed by Chris Nauroth.

+import java.io.BufferedOutputStream;
+import java.io.DataOutputStream;
+import org.apache.hadoop.hdfs.protocol.HdfsConstants;
+import org.apache.hadoop.io.IOUtils;
-   * @return the meta replica information; null if block was not found
+   * @return the meta replica information
-    try {
-      Storage.nativeCopyFileUnbuffered(srcMeta, dstMeta, true);
-    } catch (IOException e) {
-      throw new IOException("Failed to copy " + srcMeta + " to " + dstMeta, e);
-    }
+    computeChecksum(srcMeta, dstMeta, srcFile);
+
-      LOG.debug("Copied " + srcMeta + " to " + dstMeta);
+      LOG.debug("Copied " + srcMeta + " to " + dstMeta +
+          " and calculated checksum");
+  /**
+   * Compute and store the checksum for a block file that does not already have
+   * its checksum computed.
+   *
+   * @param srcMeta source meta file, containing only the checksum header, not a
+   *     calculated checksum
+   * @param dstMeta destination meta file, into which this method will write a
+   *     full computed checksum
+   * @param blockFile block file for which the checksum will be computed
+   * @throws IOException
+   */
+  private static void computeChecksum(File srcMeta, File dstMeta, File blockFile)
+      throws IOException {
+    final DataChecksum checksum = BlockMetadataHeader.readDataChecksum(srcMeta);
+    final byte[] data = new byte[1 << 16];
+    final byte[] crcs = new byte[checksum.getChecksumSize(data.length)];
+
+    DataOutputStream metaOut = null;
+    InputStream dataIn = null;
+    try {
+      File parentFile = dstMeta.getParentFile();
+      if (parentFile != null) {
+        if (!parentFile.mkdirs() && !parentFile.isDirectory()) {
+          throw new IOException("Destination '" + parentFile
+              + "' directory cannot be created");
+        }
+      }
+      metaOut = new DataOutputStream(new BufferedOutputStream(
+          new FileOutputStream(dstMeta), HdfsConstants.SMALL_BUFFER_SIZE));
+      BlockMetadataHeader.writeHeader(metaOut, checksum);
+
+      dataIn = isNativeIOAvailable ?
+          NativeIO.getShareDeleteFileInputStream(blockFile) :
+          new FileInputStream(blockFile);
+
+      int offset = 0;
+      for(int n; (n = dataIn.read(data, offset, data.length - offset)) != -1; ) {
+        if (n > 0) {
+          n += offset;
+          offset = n % checksum.getBytesPerChecksum();
+          final int length = n - offset;
+
+          if (length > 0) {
+            checksum.calculateChunkedSums(data, 0, length, crcs, 0);
+            metaOut.write(crcs, 0, checksum.getChecksumSize(length));
+
+            System.arraycopy(data, length, data, 0, offset);
+          }
+        }
+      }
+
+      // calculate and write the last crc
+      checksum.calculateChunkedSums(data, 0, offset, crcs, 0);
+      metaOut.write(crcs, 0, 4);
+    } finally {
+      IOUtils.cleanup(LOG, dataIn, metaOut);
+    }
+  }
+
+  @Override
+        // Replicas must be evicted from client short-circuit caches, because the
+        // storage will no longer be transient, and thus will require validating
+        // checksum.  This also stops a client from holding file descriptors,
+        // which would prevent the OS from reclaiming the memory.
+        datanode.getShortCircuitRegistry().processBlockInvalidation(
+            ExtendedBlockId.fromExtendedBlock(extendedBlock));

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 MOV43 INS8 INS78 MOV21 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS60 INS60 INS60 INS54 INS42 UPD66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS83 INS43 INS59 INS83 INS5 INS59 INS83 INS5 INS59 INS43 INS59 INS43 INS59 INS8 INS8 UPD42 INS42 INS42 INS42 INS32 INS39 INS85 INS42 INS3 INS39 INS85 INS42 INS3 INS42 INS42 INS33 INS42 INS42 INS33 INS60 INS25 INS21 INS21 INS21 INS60 INS24 INS21 INS21 INS21 INS42 INS42 INS42 INS5 INS27 INS5 INS32 INS43 INS59 INS27 INS8 INS7 INS32 INS7 INS39 INS59 INS58 INS27 INS8 INS32 INS32 INS32 INS21 INS39 INS85 INS34 INS34 INS39 INS85 INS42 INS42 INS40 INS42 INS42 INS32 INS42 INS33 INS25 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS16 INS42 INS34 INS39 INS59 INS36 INS38 INS25 INS42 INS42 INS42 INS34 INS42 INS42 INS34 INS42 INS42 INS42 INS34 INS34 INS42 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS42 INS27 INS8 INS43 INS14 INS42 INS32 INS14 INS42 INS7 INS34 INS27 INS8 INS32 INS42 INS32 INS38 INS38 INS53 INS42 INS43 INS14 INS40 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS42 INS34 INS21 INS21 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS14 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS7 INS7 INS83 INS39 INS59 INS27 INS8 INS42 INS42 INS42 INS42 MOV43 INS27 INS42 INS40 INS42 INS42 INS42 INS42 INS27 INS42 INS27 INS42 INS34 INS21 INS21 INS21 INS45 INS42 INS45 INS42 INS32 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS34 INS42 INS42 INS42 INS34 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 DEL42 DEL9 DEL8 DEL42 DEL44 DEL45 DEL42 DEL45 DEL42 DEL27 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54
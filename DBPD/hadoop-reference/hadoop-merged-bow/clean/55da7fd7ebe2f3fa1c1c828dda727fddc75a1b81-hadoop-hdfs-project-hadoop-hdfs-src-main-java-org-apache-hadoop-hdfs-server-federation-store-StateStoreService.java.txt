HDFS-10687. Federation Membership State Store internal API. Contributed by Jason Kace and Inigo Goiri.

(cherry picked from commit 95cae08849d23cf12c5d280c29f90908e6a90d40)

+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.apache.hadoop.hdfs.server.federation.store.impl.MembershipStoreImpl;
+import org.apache.hadoop.hdfs.server.federation.store.records.MembershipState;
+import org.apache.hadoop.util.Time;
+ * <li>{@link RebalancerStore}: Log of the rebalancing operations.
+ * <li>{@link RouterStore}: Router state in the federation.
+ * <li>{@link TokenStore}: Tokens in the federation.
+  /** Supported record stores. */
+  private final Map<
+      Class<? extends BaseRecord>, RecordStore<? extends BaseRecord>>
+          recordStores;
+
+  /** Service to maintain State Store caches. */
+  private StateStoreCacheUpdateService cacheUpdater;
+  /** Time the cache was last successfully updated. */
+  private long cacheLastUpdateTime;
+  /** List of internal caches to update. */
+  private final List<StateStoreCache> cachesToUpdateInternal;
+  /** List of external caches to update. */
+  private final List<StateStoreCache> cachesToUpdateExternal;
+
+
+
+    // Records and stores supported by this implementation
+    this.recordStores = new HashMap<>();
+
+    // Caches to maintain
+    this.cachesToUpdateInternal = new ArrayList<>();
+    this.cachesToUpdateExternal = new ArrayList<>();
+    // Add supported record stores
+    addRecordStore(MembershipStoreImpl.class);
+
+    // Set expirations intervals for each record
+    MembershipState.setExpirationMs(conf.getLong(
+        DFSConfigKeys.FEDERATION_STORE_MEMBERSHIP_EXPIRATION_MS,
+        DFSConfigKeys.FEDERATION_STORE_MEMBERSHIP_EXPIRATION_MS_DEFAULT));
+
+    // Cache update service
+    this.cacheUpdater = new StateStoreCacheUpdateService(this);
+    addService(this.cacheUpdater);
+
+   * Add a record store to the State Store. It includes adding the store, the
+   * supported record and the cache management.
+   *
+   * @param clazz Class of the record store to track.
+   * @return New record store.
+   * @throws ReflectiveOperationException
+   */
+  private <T extends RecordStore<?>> void addRecordStore(
+      final Class<T> clazz) throws ReflectiveOperationException {
+
+    assert this.getServiceState() == STATE.INITED :
+        "Cannot add record to the State Store once started";
+
+    T recordStore = RecordStore.newInstance(clazz, this.getDriver());
+    Class<? extends BaseRecord> recordClass = recordStore.getRecordClass();
+    this.recordStores.put(recordClass, recordStore);
+
+    // Subscribe for cache updates
+    if (recordStore instanceof StateStoreCache) {
+      StateStoreCache cachedRecordStore = (StateStoreCache) recordStore;
+      this.cachesToUpdateInternal.add(cachedRecordStore);
+    }
+  }
+
+  /**
+   * Get the record store in this State Store for a given interface.
+   *
+   * @param recordStoreClass Class of the record store.
+   * @return Registered record store or null if not found.
+   */
+  public <T extends RecordStore<?>> T getRegisteredRecordStore(
+      final Class<T> recordStoreClass) {
+    for (RecordStore<? extends BaseRecord> recordStore :
+        this.recordStores.values()) {
+      if (recordStoreClass.isInstance(recordStore)) {
+        @SuppressWarnings("unchecked")
+        T recordStoreChecked = (T) recordStore;
+        return recordStoreChecked;
+      }
+    }
+    return null;
+  }
+
+  /**
-    // TODO add list of records
-    return new LinkedList<>();
+    return this.recordStores.keySet();
+          this.refreshCaches();
+  //
+  // Cached state store data
+  //
+  /**
+   * The last time the state store cache was fully updated.
+   *
+   * @return Timestamp.
+   */
+  public long getCacheUpdateTime() {
+    return this.cacheLastUpdateTime;
+  }
+
+  /**
+   * Stops the cache update service.
+   */
+  @VisibleForTesting
+  public void stopCacheUpdateService() {
+    if (this.cacheUpdater != null) {
+      this.cacheUpdater.stop();
+      removeService(this.cacheUpdater);
+      this.cacheUpdater = null;
+    }
+  }
+
+  /**
+   * Register a cached record store for automatic periodic cache updates.
+   *
+   * @param client Client to the state store.
+   */
+  public void registerCacheExternal(StateStoreCache client) {
+    this.cachesToUpdateExternal.add(client);
+  }
+
+  /**
+   * Refresh the cache with information from the State Store. Called
+   * periodically by the CacheUpdateService to maintain data caches and
+   * versions.
+   */
+  public void refreshCaches() {
+    refreshCaches(false);
+  }
+
+  /**
+   * Refresh the cache with information from the State Store. Called
+   * periodically by the CacheUpdateService to maintain data caches and
+   * versions.
+   * @param force If we force the refresh.
+   */
+  public void refreshCaches(boolean force) {
+    boolean success = true;
+    if (isDriverReady()) {
+      List<StateStoreCache> cachesToUpdate = new LinkedList<>();
+      cachesToUpdate.addAll(cachesToUpdateInternal);
+      cachesToUpdate.addAll(cachesToUpdateExternal);
+      for (StateStoreCache cachedStore : cachesToUpdate) {
+        String cacheName = cachedStore.getClass().getSimpleName();
+        boolean result = false;
+        try {
+          result = cachedStore.loadCache(force);
+        } catch (IOException e) {
+          LOG.error("Error updating cache for {}", cacheName, e);
+          result = false;
+        }
+        if (!result) {
+          success = false;
+          LOG.error("Cache update failed for cache {}", cacheName);
+        }
+      }
+    } else {
+      success = false;
+      LOG.info("Skipping State Store cache update, driver is not ready.");
+    }
+    if (success) {
+      // Uses local time, not driver time.
+      this.cacheLastUpdateTime = Time.now();
+    }
+  }
+
+  /**
+   * Update the cache for a specific record store.
+   *
+   * @param clazz Class of the record store.
+   * @return If the cached was loaded.
+   * @throws IOException if the cache update failed.
+   */
+  public boolean loadCache(final Class<?> clazz) throws IOException {
+    return loadCache(clazz, false);
+  }
+
+  /**
+   * Update the cache for a specific record store.
+   *
+   * @param clazz Class of the record store.
+   * @param force Force the update ignoring cached periods.
+   * @return If the cached was loaded.
+   * @throws IOException if the cache update failed.
+   */
+  public boolean loadCache(Class<?> clazz, boolean force) throws IOException {
+    List<StateStoreCache> cachesToUpdate =
+        new LinkedList<StateStoreCache>();
+    cachesToUpdate.addAll(this.cachesToUpdateInternal);
+    cachesToUpdate.addAll(this.cachesToUpdateExternal);
+    for (StateStoreCache cachedStore : cachesToUpdate) {
+      if (clazz.isInstance(cachedStore)) {
+        return cachedStore.loadCache(force);
+      }
+    }
+    throw new IOException("Registered cache was not found for " + clazz);
+  }
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS74 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS83 INS74 INS59 INS29 INS83 INS83 INS74 INS59 INS29 INS83 INS73 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS73 INS43 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS78 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS43 INS74 INS74 INS42 INS65 INS42 INS42 INS65 INS42 INS65 INS43 INS43 INS42 INS65 INS43 INS43 INS42 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS65 INS65 INS65 INS65 INS42 INS74 INS83 INS74 INS42 INS42 INS6 INS60 INS60 INS21 INS25 INS65 INS65 INS65 INS42 INS74 INS42 INS83 INS74 INS42 INS70 INS41 INS65 INS65 INS41 INS65 INS42 INS25 INS65 INS65 INS43 INS42 INS21 INS65 INS21 INS65 INS65 INS39 INS42 INS60 INS25 INS25 INS65 INS65 INS65 INS65 INS83 INS74 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS74 INS42 INS39 INS42 INS42 INS60 INS21 INS21 INS70 INS53 INS42 INS42 INS42 INS66 INS42 INS43 INS76 INS43 INS76 INS66 INS66 INS66 INS42 INS42 INS66 INS42 INS42 INS7 INS7 INS7 INS32 INS32 INS7 INS32 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS76 INS43 INS43 INS27 INS45 INS43 INS59 INS74 INS59 INS32 INS62 INS8 INS66 INS42 INS66 INS66 INS43 INS76 INS43 INS43 INS44 INS32 INS8 INS33 INS32 INS66 INS66 INS22 INS66 INS27 INS8 INS66 INS42 INS66 INS42 INS32 INS66 INS66 INS66 INS32 INS66 INS66 INS66 INS42 INS66 INS39 INS59 INS32 INS8 INS8 INS42 INS8 INS66 INS42 INS66 INS66 INS42 INS66 INS43 INS76 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS43 INS76 INS74 INS59 INS32 INS32 INS44 INS42 INS8 INS14 INS42 INS43 INS42 INS43 INS22 INS14 INS22 INS14 INS22 INS14 INS42 INS57 INS42 INS42 INS32 INS22 INS14 INS42 INS22 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS32 INS43 INS76 INS42 INS32 INS22 INS42 INS42 INS42 INS42 INS43 INS60 INS21 INS42 INS42 INS42 INS74 INS42 INS22 INS42 INS25 INS22 INS42 INS52 INS42 INS22 INS33 INS21 INS21 INS21 INS22 INS42 INS42 INS42 INS9 INS42 INS9 INS42 INS60 INS21 INS21 INS70 INS21 INS21 INS21 INS42 INS42 INS42 INS9 INS42 INS43 INS43 INS42 INS14 INS42 INS42 INS22 INS42 INS42 INS22 INS43 INS42 INS25 INS43 INS27 INS42 INS42 INS52 INS42 INS74 INS52 INS42 INS74 INS52 INS42 INS74 INS43 INS42 INS42 INS40 INS40 INS52 INS42 INS43 INS52 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS42 INS42 INS52 INS42 INS42 INS43 INS59 INS32 INS43 INS76 INS52 INS42 INS32 INS8 INS52 INS42 INS52 INS42 INS32 INS32 INS7 INS52 INS42 INS74 INS59 INS32 INS32 INS44 INS42 INS8 INS7 INS32 INS7 INS42 INS42 INS74 INS52 INS42 INS52 INS42 INS42 INS32 INS8 INS42 INS45 INS42 INS43 INS43 INS43 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS11 INS22 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS60 INS41 INS22 INS42 INS42 INS22 INS22 INS33 INS43 INS43 INS42 MOV14 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS60 INS60 INS54 INS25 INS42 INS9 INS42 INS42 INS45 INS22 INS32 INS43 INS43 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS43 INS42 INS52 INS42 INS42 INS79 INS43 INS59 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS43 INS59 INS39 INS59 INS8 INS12 INS38 INS8 INS52 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS11 INS21 INS42 INS42 INS32 INS42 INS9 INS21 INS44 INS8 INS42 INS21 INS21 INS42 INS42 INS42 INS43 INS42 INS32 INS32 INS42 INS7 INS43 INS42 INS21 INS21 INS7 INS32 INS42 INS52 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS7 INS42 INS9 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS9
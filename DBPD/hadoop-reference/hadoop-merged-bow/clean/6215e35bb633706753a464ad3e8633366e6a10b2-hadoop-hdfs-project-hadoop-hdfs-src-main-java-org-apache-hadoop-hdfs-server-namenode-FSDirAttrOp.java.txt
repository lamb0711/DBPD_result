HDFS-11150: [SPS]: Provide persistence when satisfying storage policy. Contributed by Yuanbo Liu

+import org.apache.hadoop.hdfs.XAttrHelper;
+import java.util.ArrayList;
+import static org.apache.hadoop.hdfs.server.common.HdfsServerConstants.XATTR_SATISFY_STORAGE_POLICY;
-  static void satisfyStoragePolicy(FSDirectory fsd, BlockManager bm,
-      String src) throws IOException {
+  static FileStatus satisfyStoragePolicy(FSDirectory fsd, BlockManager bm,
+      String src, boolean logRetryCache) throws IOException {
+    List<XAttr> xAttrs = Lists.newArrayListWithCapacity(1);
-      unprotectedSatisfyStoragePolicy(bm, iip);
+      XAttr satisfyXAttr = unprotectedSatisfyStoragePolicy(iip, bm, fsd);
+      xAttrs.add(satisfyXAttr);
+    fsd.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);
+    return fsd.getAuditFileInfo(iip);
-  static void unprotectedSatisfyStoragePolicy(BlockManager bm,
-      INodesInPath iip) throws IOException {
+  static XAttr unprotectedSatisfyStoragePolicy(INodesInPath iip,
+      BlockManager bm, FSDirectory fsd) throws IOException {
-    // check whether file exists.
-    INode inode = iip.getLastINode();
-    if (inode == null) {
-      throw new FileNotFoundException("File/Directory does not exist: "
-          + iip.getPath());
-    }
+    final INode inode = FSDirectory.resolveLastINode(iip);
+    final int snapshotId = iip.getLatestSnapshotId();
+    final List<INode> candidateNodes = new ArrayList<>();
-    // TODO: need to check whether inode's storage policy
-    // has been satisfied or inode exists in the satisfier
-    // list before calling satisfyStoragePolicy in BlockManager.
-    if (inode.isDirectory()) {
-      final int snapshotId = iip.getLatestSnapshotId();
+    // TODO: think about optimization here, label the dir instead
+    // of the sub-files of the dir.
+    if (inode.isFile()) {
+      candidateNodes.add(inode);
+    } else if (inode.isDirectory()) {
-          bm.satisfyStoragePolicy(node.getId());
-
+          candidateNodes.add(node);
-    } else if (inode.isFile()) {
-      bm.satisfyStoragePolicy(inode.getId());
-    } else {
-      throw new FileNotFoundException("File/Directory does not exist: "
-          + iip.getPath());
+
+    // If node has satisfy xattr, then stop adding it
+    // to satisfy movement queue.
+    if (inodeHasSatisfyXAttr(candidateNodes)) {
+      throw new IOException(
+          "Cannot request to call satisfy storage policy on path "
+          + iip.getPath()
+          + ", as this file/dir was already called for satisfying "
+          + "storage policy.");
+    }
+
+    final List<XAttr> xattrs = Lists.newArrayListWithCapacity(1);
+    final XAttr satisfyXAttr =
+        XAttrHelper.buildXAttr(XATTR_SATISFY_STORAGE_POLICY);
+    xattrs.add(satisfyXAttr);
+
+    for (INode node : candidateNodes) {
+      bm.satisfyStoragePolicy(node.getId());
+      List<XAttr> existingXAttrs = XAttrStorage.readINodeXAttrs(node);
+      List<XAttr> newXAttrs = FSDirXAttrOp.setINodeXAttrs(
+          fsd, existingXAttrs, xattrs, EnumSet.of(XAttrSetFlag.CREATE));
+      XAttrStorage.updateINodeXAttrs(node, newXAttrs, snapshotId);
+    }
+    return satisfyXAttr;
+  }
+
+  private static boolean inodeHasSatisfyXAttr(List<INode> candidateNodes) {
+    // If the node is a directory and one of the child files
+    // has satisfy xattr, then return true for this directory.
+    for (INode inode : candidateNodes) {
+      final XAttrFeature f = inode.getXAttrFeature();
+      if (inode.isFile() &&
+          f != null && f.getXAttr(XATTR_SATISFY_STORAGE_POLICY) != null) {
+        return true;
+      }
+    }
+    return false;

INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS43 INS44 INS83 INS43 INS42 MOV44 MOV44 INS44 MOV43 INS8 INS83 UPD39 UPD42 INS44 INS8 INS42 INS39 INS42 INS60 INS21 INS41 INS42 INS43 INS42 INS60 MOV60 INS60 MOV25 MOV25 INS60 INS60 INS21 INS70 INS41 INS74 INS42 INS70 INS41 INS74 INS59 INS32 INS32 INS42 INS83 INS43 INS59 INS83 INS74 INS59 MOV32 INS8 INS25 INS32 INS83 INS74 INS59 INS83 INS43 INS59 INS32 INS44 INS42 INS8 INS42 INS43 INS43 INS44 INS42 INS8 INS9 INS43 INS43 INS42 INS32 INS60 INS21 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS21 MOV32 MOV8 UPD42 MOV42 UPD42 MOV42 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS42 MOV21 INS60 INS60 INS21 INS42 INS42 MOV43 INS42 MOV60 MOV25 INS42 INS42 INS42 INS42 INS34 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS32 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS74 INS59 INS74 INS59 INS32 INS83 INS43 INS27 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS42 UPD43 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS27 INS27 INS41 MOV42 INS42 MOV42 UPD42 MOV42 INS42 UPD42 UPD45 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 INS32 INS27 MOV32 INS33 INS9 INS42 INS42 INS40 INS42 INS42 INS42 MOV33 UPD42 UPD42 INS42 INS21 INS32 INS42 INS42 INS42 DEL39 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL27 DEL42 DEL43 DEL45 DEL27 DEL14 DEL53 DEL8 DEL8
HADOOP-7444. Add Checksum API to verify and calculate checksums "in bulk". Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1146111 13f79535-47bb-0310-9956-ffa450edef68

+import java.nio.ByteBuffer;
+import org.apache.hadoop.fs.ChecksumException;
+   * Verify that the given checksums match the given data.
+   * 
+   * The 'mark' of the ByteBuffer parameters may be modified by this function,.
+   * but the position is maintained.
+   *  
+   * @param data the DirectByteBuffer pointing to the data to verify.
+   * @param checksums the DirectByteBuffer pointing to a series of stored
+   *                  checksums
+   * @param fileName the name of the file being read, for error-reporting
+   * @param basePos the file position to which the start of 'data' corresponds
+   * @throws ChecksumException if the checksums do not match
+   */
+  public void verifyChunkedSums(ByteBuffer data, ByteBuffer checksums,
+      String fileName, long basePos)
+  throws ChecksumException {
+    if (size == 0) return;
+    
+    if (data.hasArray() && checksums.hasArray()) {
+      verifyChunkedSums(
+          data.array(), data.arrayOffset() + data.position(), data.remaining(),
+          checksums.array(), checksums.arrayOffset() + checksums.position(),
+          fileName, basePos);
+      return;
+    }
+    
+    int startDataPos = data.position();
+    data.mark();
+    checksums.mark();
+    try {
+      byte[] buf = new byte[bytesPerChecksum];
+      byte[] sum = new byte[size];
+      while (data.remaining() > 0) {
+        int n = Math.min(data.remaining(), bytesPerChecksum);
+        checksums.get(sum);
+        data.get(buf, 0, n);
+        summer.reset();
+        summer.update(buf, 0, n);
+        int calculated = (int)summer.getValue();
+        int stored = (sum[0] << 24 & 0xff000000) |
+          (sum[1] << 16 & 0xff0000) |
+          (sum[2] << 8 & 0xff00) |
+          sum[3] & 0xff;
+        if (calculated != stored) {
+          long errPos = basePos + data.position() - startDataPos - n;
+          throw new ChecksumException(
+              "Checksum error: "+ fileName + " at "+ errPos +
+              " exp: " + stored + " got: " + calculated, errPos);
+        }
+      }
+    } finally {
+      data.reset();
+      checksums.reset();
+    }
+  }
+  
+  /**
+   * Implementation of chunked verification specifically on byte arrays. This
+   * is to avoid the copy when dealing with ByteBuffers that have array backing.
+   */
+  private void verifyChunkedSums(
+      byte[] data, int dataOff, int dataLen,
+      byte[] checksums, int checksumsOff, String fileName,
+      long basePos) throws ChecksumException {
+    
+    int remaining = dataLen;
+    int dataPos = 0;
+    while (remaining > 0) {
+      int n = Math.min(remaining, bytesPerChecksum);
+      
+      summer.reset();
+      summer.update(data, dataOff + dataPos, n);
+      dataPos += n;
+      remaining -= n;
+      
+      int calculated = (int)summer.getValue();
+      int stored = (checksums[checksumsOff] << 24 & 0xff000000) |
+        (checksums[checksumsOff + 1] << 16 & 0xff0000) |
+        (checksums[checksumsOff + 2] << 8 & 0xff00) |
+        checksums[checksumsOff + 3] & 0xff;
+      checksumsOff += 4;
+      if (calculated != stored) {
+        long errPos = basePos + dataPos - n;
+        throw new ChecksumException(
+            "Checksum error: "+ fileName + " at "+ errPos +
+            " exp: " + stored + " got: " + calculated, errPos);
+      }
+    }
+  }
+
+  /**
+   * Calculate checksums for the given data.
+   * 
+   * The 'mark' of the ByteBuffer parameters may be modified by this function,
+   * but the position is maintained.
+   * 
+   * @param data the DirectByteBuffer pointing to the data to checksum.
+   * @param checksums the DirectByteBuffer into which checksums will be
+   *                  stored. Enough space must be available in this
+   *                  buffer to put the checksums.
+   */
+  public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) {
+    if (size == 0) return;
+    
+    if (data.hasArray() && checksums.hasArray()) {
+      calculateChunkedSums(data.array(), data.arrayOffset() + data.position(), data.remaining(),
+          checksums.array(), checksums.arrayOffset() + checksums.position());
+      return;
+    }
+    
+    data.mark();
+    checksums.mark();
+    try {
+      byte[] buf = new byte[bytesPerChecksum];
+      while (data.remaining() > 0) {
+        int n = Math.min(data.remaining(), bytesPerChecksum);
+        data.get(buf, 0, n);
+        summer.reset();
+        summer.update(buf, 0, n);
+        checksums.putInt((int)summer.getValue());
+      }
+    } finally {
+      data.reset();
+      checksums.reset();
+    }
+  }
+
+  /**
+   * Implementation of chunked calculation specifically on byte arrays. This
+   * is to avoid the copy when dealing with ByteBuffers that have array backing.
+   */
+  private void calculateChunkedSums(
+      byte[] data, int dataOffset, int dataLength,
+      byte[] sums, int sumsOffset) {
+
+    int remaining = dataLength;
+    while (remaining > 0) {
+      int n = Math.min(remaining, bytesPerChecksum);
+      summer.reset();
+      summer.update(data, dataOffset, n);
+      dataOffset += n;
+      remaining -= n;
+      long calculated = summer.getValue();
+      sums[sumsOffset++] = (byte) (calculated >> 24);
+      sums[sumsOffset++] = (byte) (calculated >> 16);
+      sums[sumsOffset++] = (byte) (calculated >> 8);
+      sums[sumsOffset++] = (byte) (calculated);
+    }
+  }
+
+
+  /**

INS26 INS26 INS40 INS40 INS31 INS31 INS31 INS31 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS25 INS25 INS60 INS21 INS21 INS54 INS65 INS5 INS42 INS39 INS42 INS39 INS42 INS5 INS42 INS39 INS42 INS43 INS42 INS39 INS42 INS42 INS60 INS60 INS61 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS25 INS25 INS21 INS21 INS54 INS65 INS5 INS42 INS39 INS42 INS39 INS42 INS5 INS42 INS39 INS42 INS60 INS61 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS27 INS41 INS27 INS8 INS39 INS59 INS32 INS32 INS8 INS8 INS66 INS66 INS39 INS85 INS39 INS85 INS42 INS39 INS59 INS39 INS59 INS27 INS8 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS27 INS41 INS27 INS8 INS32 INS32 INS8 INS8 INS66 INS66 INS39 INS85 INS39 INS85 INS39 INS59 INS27 INS8 INS42 INS34 INS32 INS32 INS21 INS41 INS42 INS32 INS42 INS42 INS42 INS42 INS60 INS60 INS61 INS21 INS21 INS42 INS42 INS42 INS34 INS42 INS34 INS60 INS21 INS21 INS21 INS21 INS60 INS60 INS21 INS25 INS42 INS34 INS32 INS32 INS21 INS41 INS42 INS42 INS42 INS42 INS60 INS61 INS21 INS21 INS42 INS42 INS42 INS34 INS60 INS21 INS21 INS21 INS21 INS60 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS5 INS59 INS5 INS59 INS27 INS8 INS32 INS32 INS39 INS59 INS32 INS32 INS7 INS7 INS39 INS59 INS39 INS59 INS7 INS27 INS8 INS42 INS42 INS42 INS42 INS32 INS5 INS59 INS27 INS8 INS32 INS32 INS39 INS59 INS32 INS32 INS7 INS7 INS39 INS59 INS7 INS7 INS7 INS7 INS42 INS32 INS27 INS32 INS32 INS27 INS42 INS42 INS39 INS85 INS42 INS3 INS39 INS85 INS42 INS3 INS32 INS34 INS60 INS21 INS21 INS21 INS21 INS60 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS27 INS42 INS34 INS42 INS42 INS60 INS53 INS42 INS32 INS27 INS32 INS32 INS27 INS39 INS85 INS42 INS3 INS32 INS34 INS60 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS2 INS11 INS2 INS11 INS2 INS11 INS2 INS11 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS5 INS42 INS5 INS42 INS42 INS42 INS39 INS59 INS32 INS32 INS32 INS32 INS39 INS59 INS39 INS59 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS32 INS36 INS36 INS36 INS27 INS39 INS59 INS14 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS5 INS42 INS42 INS42 INS39 INS59 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS37 INS39 INS36 INS42 INS37 INS39 INS36 INS42 INS37 INS39 INS36 INS42 INS37 INS39 INS36 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS39 INS85 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS11 INS42 INS27 INS42 INS42 INS60 INS53 INS42 INS42 INS27 INS27 INS27 INS2 INS34 INS42 INS27 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS42 INS32 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS11 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS39 INS32 INS36 INS36 INS36 INS27 INS39 INS59 INS14 INS27 INS34 INS27 INS34 INS27 INS34 INS42 INS27 INS27 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS39 INS32 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS42 INS42 INS42 INS27 INS27 INS27 INS2 INS34 INS42 INS27 INS43 INS27 INS42 INS2 INS34 INS2 INS34 INS2 INS34 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS34 INS27 INS34 INS27 INS34 INS42 INS34 INS27 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS27 INS42 INS27 INS2 INS34 INS2 INS34 INS2 INS34 INS27 INS42 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS32 INS42 INS42
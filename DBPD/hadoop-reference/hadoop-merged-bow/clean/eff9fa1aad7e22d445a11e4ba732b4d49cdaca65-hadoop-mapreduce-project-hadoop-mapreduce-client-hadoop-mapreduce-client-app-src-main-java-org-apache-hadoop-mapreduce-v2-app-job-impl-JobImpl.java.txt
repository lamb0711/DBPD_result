MAPREDUCE-3921. MR AM should act on node health status changes. Contributed by Bikas Saha.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1349065 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.mapreduce.v2.app.job.TaskAttempt;
+import org.apache.hadoop.mapreduce.v2.app.job.event.JobUpdatedNodesEvent;
+import org.apache.hadoop.mapreduce.v2.app.job.event.TaskAttemptKillEvent;
+import org.apache.hadoop.yarn.api.records.NodeId;
+import org.apache.hadoop.yarn.api.records.NodeReport;
+import org.apache.hadoop.yarn.api.records.NodeState;
+  /**
+   * maps nodes to tasks that have run on those nodes
+   */
+  private final HashMap<NodeId, List<TaskAttemptId>> 
+    nodesToSucceededTaskAttempts = new HashMap<NodeId, List<TaskAttemptId>>();
+
+  private static final UpdatedNodesTransition UPDATED_NODES_TRANSITION =
+      new UpdatedNodesTransition();
-
+          // Ignore-able events
+          .addTransition(JobState.NEW, JobState.NEW,
+              JobEventType.JOB_UPDATED_NODES)
+              
-
+          // Ignore-able events
+          .addTransition(JobState.INITED, JobState.INITED,
+              JobEventType.JOB_UPDATED_NODES)
+              
+              JobEventType.JOB_UPDATED_NODES,
+              UPDATED_NODES_TRANSITION)
+          .addTransition(JobState.RUNNING, JobState.RUNNING,
-                         JobEventType.JOB_MAP_TASK_RESCHEDULED,
-                         JobEventType.JOB_TASK_ATTEMPT_FETCH_FAILURE))
+                  JobEventType.JOB_UPDATED_NODES,
+                  JobEventType.JOB_MAP_TASK_RESCHEDULED,
+                  JobEventType.JOB_TASK_ATTEMPT_FETCH_FAILURE))
-              EnumSet.of(JobEventType.JOB_KILL,
+              EnumSet.of(JobEventType.JOB_KILL, 
+                  JobEventType.JOB_UPDATED_NODES,
-              EnumSet.of(JobEventType.JOB_KILL,
+              EnumSet.of(JobEventType.JOB_KILL, 
+                  JobEventType.JOB_UPDATED_NODES,
-              EnumSet.of(JobEventType.JOB_KILL,
+              EnumSet.of(JobEventType.JOB_KILL, 
+                  JobEventType.JOB_UPDATED_NODES,
+                  JobEventType.JOB_UPDATED_NODES,
-
+  
+  
+  private void actOnUnusableNode(NodeId nodeId, NodeState nodeState) {
+    // rerun previously successful map tasks
+    List<TaskAttemptId> taskAttemptIdList = nodesToSucceededTaskAttempts.get(nodeId);
+    if(taskAttemptIdList != null) {
+      String mesg = "TaskAttempt killed because it ran on unusable node "
+          + nodeId;
+      for(TaskAttemptId id : taskAttemptIdList) {
+        if(TaskType.MAP == id.getTaskId().getTaskType()) {
+          // reschedule only map tasks because their outputs maybe unusable
+          LOG.info(mesg + ". AttemptId:" + id);
+          eventHandler.handle(new TaskAttemptKillEvent(id, mesg));
+        }
+      }
+    }
+    // currently running task attempts on unusable nodes are handled in
+    // RMContainerAllocator
+  }
+      TaskAttemptId attemptId = tce.getAttemptId();
+      TaskId taskId = attemptId.getTaskId();
-        job.successAttemptCompletionEventNoMap.remove(tce.getAttemptId().getTaskId());
+        job.successAttemptCompletionEventNoMap.remove(taskId);
-
+      
+      // if this attempt is not successful then why is the previous successful 
+      // attempt being removed above - MAPREDUCE-4330
-        job.successAttemptCompletionEventNoMap.put(tce.getAttemptId().getTaskId(), 
-            tce.getEventId());
+        job.successAttemptCompletionEventNoMap.put(taskId, tce.getEventId());
+        
+        // here we could have simply called Task.getSuccessfulAttempt() but
+        // the event that triggers this code is sent before
+        // Task.successfulAttempt is set and so there is no guarantee that it
+        // will be available now
+        Task task = job.tasks.get(taskId);
+        TaskAttempt attempt = task.getAttempt(attemptId);
+        NodeId nodeId = attempt.getNodeId();
+        assert (nodeId != null); // node must exist for a successful event
+        List<TaskAttemptId> taskAttemptIdList = job.nodesToSucceededTaskAttempts
+            .get(nodeId);
+        if (taskAttemptIdList == null) {
+          taskAttemptIdList = new ArrayList<TaskAttemptId>();
+          job.nodesToSucceededTaskAttempts.put(nodeId, taskAttemptIdList);
+        }
+        taskAttemptIdList.add(attempt.getID());
-
+  
+  private static class UpdatedNodesTransition implements
+      SingleArcTransition<JobImpl, JobEvent> {
+    @Override
+    public void transition(JobImpl job, JobEvent event) {
+      JobUpdatedNodesEvent updateEvent = (JobUpdatedNodesEvent) event;
+      for(NodeReport nr: updateEvent.getUpdatedNodes()) {
+        NodeState nodeState = nr.getNodeState();
+        if(nodeState.isUnusable()) {
+          // act on the updates
+          job.actOnUnusableNode(nr.getNodeId(), nodeState);
+        }
+      }
+    }
+  }
+  

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS83 INS42 INS23 INS23 INS31 INS55 INS29 INS83 INS83 INS74 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS42 INS74 INS31 INS65 INS43 INS43 INS74 INS42 INS14 INS42 INS42 INS14 INS43 INS42 INS43 INS42 INS60 INS25 INS43 INS43 INS43 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS66 INS42 INS42 INS43 INS43 INS74 INS43 INS42 INS42 INS74 INS59 INS27 INS8 INS60 INS60 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS60 INS70 INS42 INS42 INS43 INS43 INS74 INS42 INS43 INS43 INS42 INS32 INS42 INS33 INS60 INS70 INS43 INS59 INS43 INS59 INS42 INS42 INS43 INS59 INS44 INS32 INS8 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS44 INS42 INS8 INS42 INS42 MOV32 INS42 INS42 INS32 INS60 INS60 INS60 INS6 INS60 INS25 INS21 INS42 INS42 INS11 INS43 INS42 INS42 INS42 INS60 INS25 INS42 INS42 INS40 INS42 INS42 INS27 INS43 INS42 INS25 INS42 INS42 UPD42 MOV42 INS43 INS59 INS43 INS59 INS43 INS59 INS36 INS74 INS59 INS27 INS8 INS32 INS43 INS42 INS42 INS43 INS59 INS32 INS8 INS40 INS45 INS42 INS42 INS27 INS8 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS27 INS43 INS43 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS21 INS40 INS32 INS21 INS21 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS40 INS42 INS42 INS7 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS14 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS14 INS74 INS42 INS42 INS40 INS42 INS45 INS42 INS43 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS40 INS40 INS32 INS42 MOV32 MOV42 INS40 INS40 INS40 INS42 UPD40 UPD40 MOV14 UPD40 INS42 UPD40 UPD42 UPD40 MOV14 UPD40 INS42 INS32 INS42 INS40 INS32 INS42 MOV40 INS40 INS40 INS42 MOV32 MOV42 INS40 INS40 INS40 UPD40 UPD40 UPD40 UPD42 UPD40 UPD40 MOV14 UPD40 UPD40 MOV14 UPD40 UPD40 INS42 UPD40 UPD42 UPD40 UPD40 UPD40 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32
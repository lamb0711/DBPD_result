HDFS-9239. DataNode Lifeline Protocol: an alternative protocol for reporting DataNode liveness. Contributed by Chris Nauroth.

+import java.io.Closeable;
+import java.util.concurrent.CountDownLatch;
+import org.apache.hadoop.hdfs.protocolPB.DatanodeLifelineProtocolClientSideTranslatorPB;
-  BPServiceActor(InetSocketAddress nnAddr, BPOfferService bpos) {
+  BPServiceActor(InetSocketAddress nnAddr, InetSocketAddress lifelineNnAddr,
+      BPOfferService bpos) {
+    this.lifelineSender = lifelineNnAddr != null ?
+        new LifelineSender(lifelineNnAddr) : null;
+    this.initialRegistrationComplete = lifelineNnAddr != null ?
+        new CountDownLatch(1) : null;
-    scheduler = new Scheduler(dnConf.heartBeatInterval, dnConf.blockReportInterval);
+    scheduler = new Scheduler(dnConf.heartBeatInterval,
+        dnConf.getLifelineIntervalMs(), dnConf.blockReportInterval);
+  private final CountDownLatch initialRegistrationComplete;
+  private final LifelineSender lifelineSender;
+
+   * Used to inject a spy NN in the unit tests.
+   */
+  @VisibleForTesting
+  void setLifelineNameNode(
+      DatanodeLifelineProtocolClientSideTranslatorPB dnLifelineProtocol) {
+    lifelineSender.lifelineNamenode = dnLifelineProtocol;
+  }
+
+  @VisibleForTesting
+  DatanodeLifelineProtocolClientSideTranslatorPB getLifelineNameNodeProxy() {
+    return lifelineSender.lifelineNamenode;
+  }
+
+  /**
-    bpThread = new Thread(this, formatThreadName());
+    bpThread = new Thread(this, formatThreadName("heartbeating", nnAddr));
+
+    if (lifelineSender != null) {
+      lifelineSender.start();
+    }
-  private String formatThreadName() {
+  private String formatThreadName(String action, InetSocketAddress addr) {
-    return "DataNode: [" + dataDirs.toString() + "] " +
-      " heartbeating to " + nnAddr;
+    return "DataNode: [" + dataDirs.toString() + "]  " +
+        action + " to " + addr;
+    if (lifelineSender != null) {
+      lifelineSender.stop();
+    }
-        bpThread.interrupt();
+      bpThread.interrupt();
+      if (lifelineSender != null) {
+        lifelineSender.join();
+      }
+    IOUtils.cleanup(null, lifelineSender);
-        + "; heartBeatInterval=" + dnConf.heartBeatInterval);
+        + "; heartBeatInterval=" + dnConf.heartBeatInterval
+        + (lifelineSender != null ?
+            "; lifelineIntervalMs=" + dnConf.getLifelineIntervalMs() : ""));
+      if (initialRegistrationComplete != null) {
+        initialRegistrationComplete.countDown();
+      }
+  private final class LifelineSender implements Runnable, Closeable {
+
+    private final InetSocketAddress lifelineNnAddr;
+    private Thread lifelineThread;
+    private DatanodeLifelineProtocolClientSideTranslatorPB lifelineNamenode;
+
+    public LifelineSender(InetSocketAddress lifelineNnAddr) {
+      this.lifelineNnAddr = lifelineNnAddr;
+    }
+
+    @Override
+    public void close() {
+      stop();
+      try {
+        join();
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
+      IOUtils.cleanup(null, lifelineNamenode);
+    }
+
+    @Override
+    public void run() {
+      // The lifeline RPC depends on registration with the NameNode, so wait for
+      // initial registration to complete.
+      while (shouldRun()) {
+        try {
+          initialRegistrationComplete.await();
+          break;
+        } catch (InterruptedException e) {
+          // The only way thread interruption can happen while waiting on this
+          // latch is if the state of the actor has been updated to signal
+          // shutdown.  The next loop's call to shouldRun() will return false,
+          // and the thread will finish.
+          Thread.currentThread().interrupt();
+        }
+      }
+
+      // After initial NameNode registration has completed, execute the main
+      // loop for sending periodic lifeline RPCs if needed.  This is done in a
+      // second loop to avoid a pointless wait on the above latch in every
+      // iteration of the main loop.
+      while (shouldRun()) {
+        try {
+          if (lifelineNamenode == null) {
+            lifelineNamenode = dn.connectToLifelineNN(lifelineNnAddr);
+          }
+          sendLifelineIfDue();
+          Thread.sleep(scheduler.getLifelineWaitTime());
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+        } catch (IOException e) {
+          LOG.warn("IOException in LifelineSender for " + BPServiceActor.this,
+              e);
+        }
+      }
+
+      LOG.info("LifelineSender for " + BPServiceActor.this + " exiting.");
+    }
+
+    public void start() {
+      lifelineThread = new Thread(this, formatThreadName("lifeline",
+          lifelineNnAddr));
+      lifelineThread.setDaemon(true);
+      lifelineThread.setUncaughtExceptionHandler(
+          new Thread.UncaughtExceptionHandler() {
+            @Override
+            public void uncaughtException(Thread thread, Throwable t) {
+              LOG.error(thread + " terminating on unexpected exception", t);
+            }
+          });
+      lifelineThread.start();
+    }
+
+    public void stop() {
+      if (lifelineThread != null) {
+        lifelineThread.interrupt();
+      }
+    }
+
+    public void join() throws InterruptedException {
+      if (lifelineThread != null) {
+        lifelineThread.join();
+      }
+    }
+
+    private void sendLifelineIfDue() throws IOException {
+      long startTime = scheduler.monotonicNow();
+      if (!scheduler.isLifelineDue(startTime)) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Skipping sending lifeline for " + BPServiceActor.this
+              + ", because it is not due.");
+        }
+        return;
+      }
+      if (dn.areHeartbeatsDisabledForTests()) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Skipping sending lifeline for " + BPServiceActor.this
+              + ", because heartbeats are disabled for tests.");
+        }
+        return;
+      }
+      sendLifeline();
+      dn.getMetrics().addLifeline(scheduler.monotonicNow() - startTime);
+      scheduler.scheduleNextLifeline(scheduler.monotonicNow());
+    }
+
+    private void sendLifeline() throws IOException {
+      StorageReport[] reports =
+          dn.getFSDataset().getStorageReports(bpos.getBlockPoolId());
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Sending lifeline with " + reports.length + " storage " +
+                  " reports from service actor: " + BPServiceActor.this);
+      }
+      VolumeFailureSummary volumeFailureSummary = dn.getFSDataset()
+          .getVolumeFailureSummary();
+      int numFailedVolumes = volumeFailureSummary != null ?
+          volumeFailureSummary.getFailedStorageLocations().length : 0;
+      lifelineNamenode.sendLifeline(bpRegistration,
+                                    reports,
+                                    dn.getFSDataset().getCacheCapacity(),
+                                    dn.getFSDataset().getCacheUsed(),
+                                    dn.getXmitsInProgress(),
+                                    dn.getXceiverCount(),
+                                    numFailedVolumes,
+                                    volumeFailureSummary);
+    }
+  }
+
+    volatile long nextLifelineTime = monotonicNow();
+
+    @VisibleForTesting
+    private final long lifelineIntervalMs;
-    Scheduler(long heartbeatIntervalMs, long blockReportIntervalMs) {
+    Scheduler(long heartbeatIntervalMs, long lifelineIntervalMs,
+        long blockReportIntervalMs) {
+      this.lifelineIntervalMs = lifelineIntervalMs;
+      scheduleNextLifeline(nextHeartbeatTime);
+      scheduleNextLifeline(nextHeartbeatTime);
+    long scheduleNextLifeline(long baseTime) {
+      // Numerical overflow is possible here and is okay.
+      nextLifelineTime = baseTime + lifelineIntervalMs;
+      return nextLifelineTime;
+    }
+
+    boolean isLifelineDue(long startTime) {
+      return (nextLifelineTime - startTime <= 0);
+    }
+
+    long getLifelineWaitTime() {
+      return nextLifelineTime - monotonicNow();
+    }
+

INS26 INS26 INS26 INS40 INS40 INS40 INS42 INS23 INS23 INS31 INS31 INS55 INS44 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS29 INS78 INS39 INS42 INS44 INS8 INS78 INS43 INS42 INS8 INS44 INS44 INS83 INS83 INS42 INS43 INS43 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS23 INS31 INS31 INS31 INS43 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS65 INS42 INS43 INS42 INS21 INS42 INS42 INS41 INS25 INS43 INS42 INS43 INS42 INS25 INS21 INS42 INS42 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS44 INS39 INS42 INS44 INS8 INS39 INS42 INS44 INS8 INS39 INS42 INS8 INS42 INS7 INS7 INS66 INS42 INS7 INS40 INS27 INS8 INS42 INS42 INS27 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS21 INS42 INS21 INS54 INS21 INS42 INS61 INS61 INS21 INS21 INS21 INS21 INS21 INS25 INS42 INS25 INS42 INS60 INS25 INS25 INS21 INS21 INS21 INS42 INS60 INS25 INS60 INS60 INS21 INS42 INS42 INS32 INS42 INS39 INS42 INS21 INS21 INS21 INS39 INS42 INS21 INS41 INS39 INS42 INS41 INS41 INS22 INS16 INS22 INS16 INS40 INS42 INS42 INS33 INS21 UPD45 INS42 UPD45 UPD42 INS42 INS33 INS21 INS25 INS42 INS42 INS33 INS42 INS25 INS42 INS7 INS32 INS8 INS12 INS32 INS32 INS8 INS32 INS8 INS32 INS7 INS32 INS32 INS32 INS27 INS8 INS27 INS8 INS39 INS59 INS38 INS8 INS32 INS8 INS32 INS32 INS32 INS5 INS59 INS32 INS8 INS43 INS59 INS39 INS59 INS32 INS42 INS7 INS32 INS32 INS7 INS42 INS36 INS27 INS52 INS42 INS27 INS14 INS33 INS52 INS42 INS27 INS14 INS33 INS32 INS32 INS32 INS27 INS8 INS36 INS27 INS8 INS22 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS33 INS42 INS42 INS54 INS42 INS54 INS42 INS42 INS27 INS42 INS14 INS42 INS42 INS9 INS42 INS42 INS14 INS42 INS42 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS32 INS32 INS25 INS41 INS42 INS42 INS25 INS41 INS42 INS32 INS42 INS27 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS32 INS42 INS16 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS42 INS32 INS42 INS33 INS43 INS42 INS42 INS33 INS43 INS34 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS16 INS42 INS33 INS21 INS52 INS42 INS32 INS43 INS42 INS21 INS8 INS12 INS8 INS12 INS12 INS45 INS52 INS45 INS43 INS52 INS32 INS43 INS1 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS32 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS32 INS42 INS27 INS22 INS34 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS27 INS34 INS42 INS42 INS42 INS32 INS27 INS27 INS45 INS32 INS42 INS42 INS32 INS21 INS10 INS44 INS8 INS25 INS21 INS21 INS44 INS8 INS44 INS8 INS42 INS42 INS42 INS45 INS42 INS40 INS31 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS33 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS45 INS32 INS42 INS42 INS32 INS42 INS32 INS43 INS42 INS21 INS27 INS8 INS32 INS32 INS43 INS42 INS21 INS43 INS42 INS21 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS32 INS32 INS45 INS40 INS45 INS45 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS43 INS42 INS43 INS42 INS21 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS32 INS42 INS7 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS45 INS52 INS45 INS45 INS52 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS52 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 DEL42
HDFS-7426. Change nntop JMX format to be a JSON blob.

-import java.util.HashMap;
+import java.util.List;
+import java.util.Stack;
-import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.Lists;
+import com.google.common.primitives.Ints;
+import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.hdfs.server.namenode.top.TopConf;
-import org.apache.hadoop.conf.Configuration;
-  private int windowLenMs;
-  private int bucketsPerWindow; // e.g., 10 buckets per minute
-  private int topUsersCnt; // e.g., report top 10 metrics
-
-  /**
-   * Create a metric name composed of the command and user
-   *
-   * @param command the command executed
-   * @param user    the user
-   * @return a composed metric name
-   */
-  @VisibleForTesting
-  public static String createMetricName(String command, String user) {
-    return command + "." + user;
-  }
+  private final int windowLenMs;
+  private final int bucketsPerWindow; // e.g., 10 buckets per minute
+  private final int topUsersCnt; // e.g., report top 10 metrics
+   * Represents a snapshot of the rolling window. It contains one Op per 
+   * operation in the window, with ranked users for each Op.
+   */
+  public static class TopWindow {
+    private final int windowMillis;
+    private final List<Op> top;
+
+    public TopWindow(int windowMillis) {
+      this.windowMillis = windowMillis;
+      this.top = Lists.newArrayList();
+    }
+
+    public void addOp(Op op) {
+      top.add(op);
+    }
+
+    public int getWindowLenMs() {
+      return windowMillis;
+    }
+
+    public List<Op> getOps() {
+      return top;
+    }
+  }
+
+  /**
+   * Represents an operation within a TopWindow. It contains a ranked 
+   * set of the top users for the operation.
+   */
+  public static class Op {
+    private final String opType;
+    private final List<User> topUsers;
+    private final long totalCount;
+
+    public Op(String opType, long totalCount) {
+      this.opType = opType;
+      this.topUsers = Lists.newArrayList();
+      this.totalCount = totalCount;
+    }
+
+    public void addUser(User u) {
+      topUsers.add(u);
+    }
+
+    public String getOpType() {
+      return opType;
+    }
+
+    public List<User> getTopUsers() {
+      return topUsers;
+    }
+
+    public long getTotalCount() {
+      return totalCount;
+    }
+  }
+
+  /**
+   * Represents a user who called an Op within a TopWindow. Specifies the 
+   * user and the number of times the user called the operation.
+   */
+  public static class User {
+    private final String user;
+    private final long count;
+
+    public User(String user, long count) {
+      this.user = user;
+      this.count = count;
+    }
+
+    public String getUser() {
+      return user;
+    }
+
+    public long getCount() {
+      return count;
+    }
+  }
+
+  /**
-  public RollingWindowManager(Configuration conf, long reportingPeriodMs) {
-    windowLenMs = (int) reportingPeriodMs;
+  public RollingWindowManager(Configuration conf, int reportingPeriodMs) {
+    
+    windowLenMs = reportingPeriodMs;
-   * @return a map between the top metrics and their values. The user is encoded
-   * in the metric name. Refer to {@link RollingWindowManager#createMetricName} for
-   * the actual format.
+   * @return a TopWindow describing the top users for each metric in the 
+   * window.
-  public MetricValueMap snapshot(long time) {
-    MetricValueMap map = new MetricValueMap();
-    Set<String> metricNames = metricMap.keySet();
-    LOG.debug("iterating in reported metrics, size={} values={}",
-        metricNames.size(), metricNames);
-    for (Map.Entry<String,RollingWindowMap> rwEntry: metricMap.entrySet()) {
-      String metricName = rwEntry.getKey();
-      RollingWindowMap rollingWindows = rwEntry.getValue();
-      TopN topN = new TopN(topUsersCnt);
-      Iterator<Map.Entry<String, RollingWindow>> iterator =
-          rollingWindows.entrySet().iterator();
-      while (iterator.hasNext()) {
-        Map.Entry<String, RollingWindow> entry = iterator.next();
-        String userName = entry.getKey();
-        RollingWindow aWindow = entry.getValue();
-        long windowSum = aWindow.getSum(time);
-        // do the gc here
-        if (windowSum == 0) {
-          LOG.debug("gc window of metric: {} userName: {}",
-              metricName, userName);
-          iterator.remove();
-          continue;
-        }
-        LOG.debug("offer window of metric: {} userName: {} sum: {}",
-            metricName, userName, windowSum);
-        topN.offer(new NameValuePair(userName, windowSum));
-      }
-      int n = topN.size();
-      LOG.info("topN size for command " + metricName + " is: " + n);
-      if (n == 0) {
+  public TopWindow snapshot(long time) {
+    TopWindow window = new TopWindow(windowLenMs);
+    if (LOG.isDebugEnabled()) {
+      Set<String> metricNames = metricMap.keySet();
+      LOG.debug("iterating in reported metrics, size={} values={}",
+          metricNames.size(), metricNames);
+    }
+    for (Map.Entry<String, RollingWindowMap> entry : metricMap.entrySet()) {
+      String metricName = entry.getKey();
+      RollingWindowMap rollingWindows = entry.getValue();
+      TopN topN = getTopUsersForMetric(time, metricName, rollingWindows);
+      final int size = topN.size();
+      if (size == 0) {
-      String allMetricName =
-          createMetricName(metricName, TopConf.ALL_USERS);
-      map.put(allMetricName, Long.valueOf(topN.total));
-      for (int i = 0; i < n; i++) {
-        NameValuePair userEntry = topN.poll();
-        String userMetricName =
-            createMetricName(metricName, userEntry.name);
-        map.put(userMetricName, Long.valueOf(userEntry.value));
+      Op op = new Op(metricName, topN.getTotal());
+      window.addOp(op);
+      // Reverse the users from the TopUsers using a stack, 
+      // since we'd like them sorted in descending rather than ascending order
+      Stack<NameValuePair> reverse = new Stack<NameValuePair>();
+      for (int i = 0; i < size; i++) {
+        reverse.push(topN.poll());
+      }
+      for (int i = 0; i < size; i++) {
+        NameValuePair userEntry = reverse.pop();
+        User user = new User(userEntry.name, Long.valueOf(userEntry.value));
+        op.addUser(user);
-    return map;
+    return window;
+  }
+
+  /**
+   * Calculates the top N users over a time interval.
+   * 
+   * @param time the current time
+   * @param metricName Name of metric
+   * @return
+   */
+  private TopN getTopUsersForMetric(long time, String metricName, 
+      RollingWindowMap rollingWindows) {
+    TopN topN = new TopN(topUsersCnt);
+    Iterator<Map.Entry<String, RollingWindow>> iterator =
+        rollingWindows.entrySet().iterator();
+    while (iterator.hasNext()) {
+      Map.Entry<String, RollingWindow> entry = iterator.next();
+      String userName = entry.getKey();
+      RollingWindow aWindow = entry.getValue();
+      long windowSum = aWindow.getSum(time);
+      // do the gc here
+      if (windowSum == 0) {
+        LOG.debug("gc window of metric: {} userName: {}",
+            metricName, userName);
+        iterator.remove();
+        continue;
+      }
+      LOG.debug("offer window of metric: {} userName: {} sum: {}",
+          metricName, userName, windowSum);
+      topN.offer(new NameValuePair(userName, windowSum));
+    }
+    LOG.info("topN size for command {} is: {}", metricName, topN.size());
+    return topN;
-   * A pair of a name and its corresponding value
+   * A pair of a name and its corresponding value. Defines a custom 
+   * comparator so the TopN PriorityQueue sorts based on the count.
-
-  /**
-   * A mapping from metric names to their absolute values and their percentage
-   */
-  @InterfaceAudience.Private
-  public static class MetricValueMap extends HashMap<String, Number> {
-    private static final long serialVersionUID = 8936732010242400171L;
-  }

MOV26 MOV26 MOV26 MOV26 INS26 UPD40 INS40 UPD40 UPD40 INS55 INS55 INS55 INS31 INS83 INS83 INS83 INS29 INS83 INS83 INS42 INS23 INS23 INS31 INS31 INS31 INS31 MOV29 MOV83 MOV83 UPD42 MOV42 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS42 INS23 INS23 INS31 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS8 UPD83 UPD43 INS42 INS44 INS44 MOV8 MOV65 INS83 INS83 INS39 INS59 INS83 INS83 INS74 INS59 MOV83 INS42 INS44 INS8 UPD83 MOV83 INS39 UPD42 MOV42 INS44 MOV8 INS83 INS39 INS42 INS8 INS83 INS74 INS42 INS8 INS83 INS83 MOV43 INS59 INS83 INS83 INS74 INS59 MOV83 INS83 INS39 INS59 INS83 INS42 MOV44 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 MOV43 INS42 INS8 INS83 INS74 INS42 INS8 INS83 INS39 INS42 INS8 INS65 INS83 MOV83 INS43 INS59 INS83 INS83 MOV39 INS59 INS83 INS42 MOV44 INS44 INS8 INS83 MOV43 INS42 INS8 INS83 INS39 INS42 INS8 UPD39 MOV65 MOV65 INS65 INS42 INS39 INS42 INS60 INS25 INS70 INS41 INS65 INS65 INS65 INS65 UPD42 MOV43 INS42 INS43 INS42 INS21 INS41 INS66 UPD66 INS42 INS43 INS43 INS42 INS39 INS42 INS21 INS21 INS43 INS42 INS21 INS41 INS43 INS43 INS41 INS66 UPD66 INS42 UPD43 MOV43 UPD43 MOV43 INS42 INS42 UPD42 INS39 INS42 INS21 INS21 INS21 INS43 INS42 INS21 INS41 INS43 INS43 INS41 INS41 INS66 INS66 INS42 INS42 INS42 INS39 INS42 INS21 INS21 INS41 INS41 INS66 INS66 INS43 INS59 INS32 INS8 MOV44 MOV32 INS8 INS42 UPD66 MOV66 INS42 UPD66 MOV66 INS42 INS66 UPD42 MOV42 INS32 INS42 UPD66 INS66 INS42 INS42 INS7 INS7 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 INS7 INS7 INS7 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 MOV60 MOV21 UPD42 INS60 INS60 INS60 MOV60 INS25 INS60 INS21 INS60 INS24 INS24 MOV42 MOV42 INS45 INS42 INS32 INS22 INS42 INS22 INS32 INS42 INS42 INS42 INS22 INS42 INS22 INS32 INS22 INS42 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS43 INS42 MOV43 INS59 MOV43 INS59 INS43 INS59 INS83 INS27 MOV8 INS43 INS59 INS32 INS74 INS59 MOV58 INS27 MOV37 INS8 INS58 INS27 INS37 INS8 UPD42 MOV42 UPD42 MOV42 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 UPD42 INS42 INS34 INS42 INS42 INS14 INS42 INS42 INS42 INS43 INS43 INS42 INS14 INS42 INS42 INS21 INS39 INS59 INS42 INS42 INS42 INS60 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS32 INS42 INS42 INS74 INS32 UPD42 MOV42 UPD34 MOV34 MOV43 INS59 INS43 INS59 INS32 INS42 INS42 INS42 INS43 INS43 INS42 INS42 MOV32 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS40 MOV32 INS42 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL78 DEL31 DEL42 DEL45 DEL42 DEL27 DEL41 DEL39 DEL42 DEL11 DEL42 DEL42 DEL67 DEL65 DEL66 DEL66 DEL65 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL42 DEL34 DEL27 DEL25 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL32 DEL21 DEL42 DEL42 DEL27 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL43 DEL42 DEL43 DEL14 DEL59 DEL60 DEL70 DEL42 DEL41 DEL8 DEL40 DEL78 DEL74 DEL83 DEL59 DEL23 DEL55
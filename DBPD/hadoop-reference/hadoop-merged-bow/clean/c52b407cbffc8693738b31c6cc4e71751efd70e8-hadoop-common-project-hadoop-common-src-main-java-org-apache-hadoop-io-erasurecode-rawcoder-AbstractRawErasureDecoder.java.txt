HADOOP-12685. Input buffer position after encode/decode not consistent between different kinds of buffers. Contributed by Rui Li.

Change-Id: I713c7b4e3cfae70c04b7e4b292ab53eae348d8d9

-    if (usingDirectBuffer) {
-      doDecode(inputs, erasedIndexes, outputs);
-      return;
-    }
-
-    int[] inputOffsets = new int[inputs.length];
-    int[] outputOffsets = new int[outputs.length];
-    byte[][] newInputs = new byte[inputs.length][];
-    byte[][] newOutputs = new byte[outputs.length][];
-
-    ByteBuffer buffer;
-    for (int i = 0; i < inputs.length; ++i) {
-      buffer = inputs[i];
-      if (buffer != null) {
-        inputOffsets[i] = buffer.arrayOffset() + buffer.position();
-        newInputs[i] = buffer.array();
+    int[] inputPositions = new int[inputs.length];
+    for (int i = 0; i < inputPositions.length; i++) {
+      if (inputs[i] != null) {
+        inputPositions[i] = inputs[i].position();
-    for (int i = 0; i < outputs.length; ++i) {
-      buffer = outputs[i];
-      outputOffsets[i] = buffer.arrayOffset() + buffer.position();
-      newOutputs[i] = buffer.array();
+    if (usingDirectBuffer) {
+      doDecode(inputs, erasedIndexes, outputs);
+    } else {
+      int[] inputOffsets = new int[inputs.length];
+      int[] outputOffsets = new int[outputs.length];
+      byte[][] newInputs = new byte[inputs.length][];
+      byte[][] newOutputs = new byte[outputs.length][];
+
+      ByteBuffer buffer;
+      for (int i = 0; i < inputs.length; ++i) {
+        buffer = inputs[i];
+        if (buffer != null) {
+          inputOffsets[i] = buffer.arrayOffset() + buffer.position();
+          newInputs[i] = buffer.array();
+        }
+      }
+
+      for (int i = 0; i < outputs.length; ++i) {
+        buffer = outputs[i];
+        outputOffsets[i] = buffer.arrayOffset() + buffer.position();
+        newOutputs[i] = buffer.array();
+      }
+
+      doDecode(newInputs, inputOffsets, dataLen,
+          erasedIndexes, newOutputs, outputOffsets);
-    doDecode(newInputs, inputOffsets, dataLen,
-        erasedIndexes, newOutputs, outputOffsets);
-
-    for (int i = 0; i < inputs.length; ++i) {
-      buffer = inputs[i];
-      if (buffer != null) {
+    for (int i = 0; i < inputs.length; i++) {
+      if (inputs[i] != null) {
-        buffer.position(buffer.position() + dataLen);
+        inputs[i].position(inputPositions[i] + dataLen);

INS60 INS24 INS25 INS24 INS5 INS59 INS58 INS27 INS37 INS8 INS42 MOV8 INS8 MOV58 MOV27 INS37 INS8 INS39 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS25 MOV60 MOV60 MOV60 MOV60 MOV60 MOV24 MOV24 MOV21 INS42 MOV25 INS5 INS40 INS42 INS34 INS27 INS8 INS39 INS85 INS2 INS33 MOV21 INS2 INS42 INS42 INS42 INS42 INS2 INS32 MOV2 INS42 INS42 INS2 INS42 INS2 INS42 INS42 INS42 INS42 DEL42 DEL41 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL25 DEL42 DEL38 DEL8 DEL24
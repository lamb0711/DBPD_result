YARN-3901. Populate flow run data in the flow_run & flow activity tables (Vrushali C via sjlee)

-
+import org.apache.hadoop.yarn.server.timelineservice.storage.flow.AggregationCompactionDimension;
+import org.apache.hadoop.yarn.server.timelineservice.storage.flow.Attribute;
-   * @param rowKey identifying the row to write. Nothing gets written when null.
-   * @param tableMutator used to modify the underlying HBase table
-   * @param columnQualifier column qualifier. Nothing gets written when null.
-   * @param timestamp version timestamp. When null the server timestamp will be
-   *          used.
-   * @param inputValue the value to write to the rowKey and column qualifier.
-   *          Nothing gets written when null.
+   * @param rowKey
+   *          identifying the row to write. Nothing gets written when null.
+   * @param tableMutator
+   *          used to modify the underlying HBase table
+   * @param columnQualifier
+   *          column qualifier. Nothing gets written when null.
+   * @param timestamp
+   *          version timestamp. When null the current timestamp multiplied with
+   *          TimestampGenerator.TS_MULTIPLIER and added with last 3 digits of
+   *          app id will be used
+   * @param inputValue
+   *          the value to write to the rowKey and column qualifier. Nothing
+   *          gets written when null.
-      byte[] columnQualifier, Long timestamp, Object inputValue)
-      throws IOException {
+      byte[] columnQualifier, Long timestamp, Object inputValue,
+      Attribute... attributes) throws IOException {
-
-    if (timestamp == null) {
-      p.addColumn(columnFamilyBytes, columnQualifier,
-          GenericObjectMapper.write(inputValue));
-    } else {
-      p.addColumn(columnFamilyBytes, columnQualifier, timestamp,
-          GenericObjectMapper.write(inputValue));
+    timestamp = getPutTimestamp(timestamp, attributes);
+    p.addColumn(columnFamilyBytes, columnQualifier, timestamp,
+        GenericObjectMapper.write(inputValue));
+    if ((attributes != null) && (attributes.length > 0)) {
+      for (Attribute attribute : attributes) {
+        p.setAttribute(attribute.getName(), attribute.getValue());
+      }
+  /*
+   * Figures out the cell timestamp used in the Put For storing into flow run
+   * table. We would like to left shift the timestamp and supplement it with the
+   * AppId id so that there are no collisions in the flow run table's cells
+   */
+  private long getPutTimestamp(Long timestamp, Attribute[] attributes) {
+    if (timestamp == null) {
+      timestamp = System.currentTimeMillis();
+    }
+    String appId = getAppIdFromAttributes(attributes);
+    long supplementedTS = TimestampGenerator.getSupplementedTimestamp(
+        timestamp, appId);
+    return supplementedTS;
+  }
+
+  private String getAppIdFromAttributes(Attribute[] attributes) {
+    if (attributes == null) {
+      return null;
+    }
+    String appId = null;
+    for (Attribute attribute : attributes) {
+      if (AggregationCompactionDimension.APPLICATION_ID.toString().equals(
+          attribute.getName())) {
+        appId = Bytes.toString(attribute.getValue());
+      }
+    }
+    return appId;
+  }
+
-                cellResults.put(cell.getKey(), value);
+                cellResults.put(
+                    TimestampGenerator.getTruncatedTimestamp(cell.getKey()),
+                    value);
+   * @param qualifier for the remainder of the column.
+   * @return fully sanitized column qualifier that is a combination of prefix
+   *         and qualifier. If prefix is null, the result is simply the encoded
+   *         qualifier without any separator.
+   */
+  public static byte[] getColumnQualifier(byte[] columnPrefixBytes,
+      long qualifier) {
+
+    if (columnPrefixBytes == null) {
+      return Bytes.toBytes(qualifier);
+    }
+
+    // Convert qualifier to lower case, strip of separators and tag on column
+    // prefix.
+    byte[] columnQualifier =
+        Separator.QUALIFIERS.join(columnPrefixBytes, Bytes.toBytes(qualifier));
+    return columnQualifier;
+  }
+  /**
+   * @param columnPrefixBytes The byte representation for the column prefix.
+   *          Should not contain {@link Separator#QUALIFIERS}.

INS26 INS26 INS40 INS40 INS31 INS31 INS31 INS44 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS8 INS43 INS42 INS21 MOV21 INS43 INS42 INS5 INS42 INS25 INS60 INS60 INS41 INS42 INS5 INS42 INS25 INS60 INS70 INS41 INS65 INS65 INS65 INS39 INS85 INS5 INS42 INS39 INS42 INS25 INS60 INS41 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS42 INS7 INS27 INS8 INS42 INS43 INS85 MOV27 INS8 INS43 INS59 INS39 INS59 INS42 INS43 INS85 INS27 INS8 INS43 INS59 INS44 INS42 INS8 INS42 INS42 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS66 INS66 INS39 INS85 INS27 INS8 INS5 INS59 INS42 INS42 INS32 INS36 INS36 INS70 INS42 INS21 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS33 INS41 INS42 INS42 INS33 INS43 INS42 INS25 INS67 INS42 INS33 INS41 INS39 INS85 INS42 INS32 INS42 INS42 INS42 INS27 INS27 INS44 INS42 INS8 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS32 INS8 INS42 INS42 INS32 INS40 INS42 INS42 INS32 INS42 INS33 INS40 INS34 INS43 INS42 MOV21 INS42 INS32 INS32 INS42 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS7 UPD42 INS32 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 MOV32 INS42 UPD42 UPD42 DEL42 DEL8 DEL8 DEL42
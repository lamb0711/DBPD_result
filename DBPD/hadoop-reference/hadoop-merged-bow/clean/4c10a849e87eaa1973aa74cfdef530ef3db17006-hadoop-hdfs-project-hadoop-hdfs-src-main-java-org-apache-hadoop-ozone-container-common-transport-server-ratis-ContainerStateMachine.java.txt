HDFS-13078. Ozone: Update Ratis on Ozone to 0.1.1-alpha-8fd74ed-SNAPSHOT.
To fix large chunk reads (>4M) from Datanodes. Contributed by Mukul Kumar Singh.

-import org.apache.ratis.protocol.RaftClientReply;
-import org.apache.ratis.statemachine.BaseStateMachine;
-import org.apache.ratis.statemachine.SimpleStateMachineStorage;
+import org.apache.ratis.statemachine.impl.BaseStateMachine;
+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;
+import org.apache.ratis.statemachine.impl.TransactionContextImpl;
- * and these readonly requests are replied from the
- * {@link #query(RaftClientRequest)}
+ * and these readonly requests are replied from the {@link #query(Message)}.
-  private final ConcurrentHashMap<String, CompletableFuture<Message>>
+  private final ConcurrentHashMap<Long, CompletableFuture<Message>>
-    return new TransactionContext(this, request, log);
+    return new TransactionContextImpl(this, request, log);
+  private CompletableFuture<Message> handleWriteChunk(
+      ContainerCommandRequestProto requestProto, long entryIndex) {
+    final WriteChunkRequestProto write = requestProto.getWriteChunk();
+    String containerName = write.getPipeline().getContainerName();
+    CompletableFuture<Message> future =
+        createContainerFutureMap.get(containerName);
+    CompletableFuture<Message> writeChunkFuture;
+    if (future != null) {
+      writeChunkFuture = future.thenApplyAsync(
+          v -> runCommand(requestProto), writeChunkExecutor);
+    } else {
+      writeChunkFuture = CompletableFuture.supplyAsync(
+          () -> runCommand(requestProto), writeChunkExecutor);
+    }
+    writeChunkFutureMap.put(entryIndex, writeChunkFuture);
+    return writeChunkFuture;
+  }
+
+  private CompletableFuture<Message> handleCreateContainer(
+      ContainerCommandRequestProto requestProto) {
+    String containerName =
+        requestProto.getCreateContainer().getContainerData().getName();
+    createContainerFutureMap.
+        computeIfAbsent(containerName, k -> new CompletableFuture<>());
+    return CompletableFuture.completedFuture(() -> ByteString.EMPTY);
+  }
+
-      if (requestProto.getCmdType() == ContainerProtos.Type.CreateContainer) {
-        String containerName =
-            requestProto.getCreateContainer().getContainerData().getName();
-        createContainerFutureMap.
-            computeIfAbsent(containerName, k -> new CompletableFuture<>());
-        return CompletableFuture.completedFuture(() -> ByteString.EMPTY);
-      } else {
-        final WriteChunkRequestProto write = requestProto.getWriteChunk();
-        String containerName = write.getPipeline().getContainerName();
-        CompletableFuture<Message> future =
-            createContainerFutureMap.get(containerName);
-
-        CompletableFuture<Message> writeChunkFuture;
-        if (future != null) {
-          writeChunkFuture = future.thenApplyAsync(
-              v -> runCommand(requestProto), writeChunkExecutor);
-        } else {
-          writeChunkFuture = CompletableFuture.supplyAsync(
-              () -> runCommand(requestProto), writeChunkExecutor);
-        }
-        writeChunkFutureMap
-            .put(write.getChunkData().getChunkName(), writeChunkFuture);
-        return writeChunkFuture;
+      ContainerProtos.Type cmdType = requestProto.getCmdType();
+      switch (cmdType) {
+      case CreateContainer:
+        return handleCreateContainer(requestProto);
+      case WriteChunk:
+        return handleWriteChunk(requestProto, entry.getIndex());
+      default:
+        throw new IllegalStateException("Cmd Type:" + cmdType
+            + " should not have state machine data");
-  public CompletableFuture<RaftClientReply> query(RaftClientRequest request) {
+  public CompletableFuture<Message> query(Message request) {
-          getRequestProto(request.getMessage().getContent());
-      RaftClientReply raftClientReply =
-          new RaftClientReply(request, runCommand(requestProto));
-      return CompletableFuture.completedFuture(raftClientReply);
+          getRequestProto(request.getContent());
+      return CompletableFuture.completedFuture(runCommand(requestProto));
+      ContainerProtos.Type cmdType = requestProto.getCmdType();
-      if (requestProto.getCmdType() == ContainerProtos.Type.WriteChunk) {
+      if (cmdType == ContainerProtos.Type.WriteChunk) {
-            writeChunkFutureMap.remove(write.getChunkData().getChunkName());
+            writeChunkFutureMap.remove(trx.getLogEntry().getIndex());
-        if (requestProto.getCmdType() == ContainerProtos.Type.CreateContainer) {
+        if (cmdType == ContainerProtos.Type.CreateContainer) {

MOV26 MOV26 UPD40 UPD40 UPD40 INS31 INS31 UPD74 UPD83 UPD42 INS44 INS44 MOV8 INS83 INS74 INS42 INS44 MOV8 MOV78 INS83 INS74 INS42 MOV44 INS8 UPD74 UPD66 INS66 UPD43 INS43 INS42 INS39 INS42 INS43 INS43 INS43 INS42 INS43 INS43 INS54 UPD43 UPD43 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS8 MOV12 UPD42 UPD42 UPD43 UPD42 MOV42 MOV60 INS60 INS50 INS60 UPD43 UPD42 INS43 INS59 INS42 INS49 INS41 INS49 INS41 INS49 INS53 INS43 INS59 UPD42 INS40 INS42 MOV32 INS42 INS32 INS42 INS32 INS14 MOV32 INS40 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS27 INS42 INS42 INS42 INS45 INS42 INS45 MOV42 INS42 UPD42 UPD42 UPD42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL27 DEL25 DEL8 DEL54 DEL8 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42
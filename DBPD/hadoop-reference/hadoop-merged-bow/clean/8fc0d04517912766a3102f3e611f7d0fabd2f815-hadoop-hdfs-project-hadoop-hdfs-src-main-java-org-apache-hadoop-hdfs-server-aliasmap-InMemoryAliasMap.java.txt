HDFS-14001. [PROVIDED Storage] bootstrapStandby should manage the InMemoryAliasMap. Contributed by Virajith Jalaparti.

+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
+import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;
+import org.apache.hadoop.fs.FileUtil;
+import org.apache.hadoop.hdfs.server.namenode.ImageServlet;
+import org.apache.hadoop.hdfs.server.namenode.TransferFsImage;
+import org.apache.hadoop.hdfs.util.DataTransferThrottler;
+import org.apache.hadoop.io.IOUtils;
+import org.iq80.leveldb.ReadOptions;
+import org.iq80.leveldb.Snapshot;
+import javax.servlet.http.HttpServletResponse;
+import java.io.BufferedOutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.net.URI;
+  private static final String SNAPSHOT_COPY_DIR = "aliasmap_snapshot";
+  private static final String TAR_NAME = "aliasmap.tar.gz";
+  private final URI aliasMapURI;
-  @VisibleForTesting
-  static String createPathErrorMessage(String directory) {
-    return new StringBuilder()
-        .append("Configured directory '")
-        .append(directory)
-        .append("' doesn't exist")
-        .toString();
-  }
-
-    LOG.info("Attempting to load InMemoryAliasMap from \"{}\"", directory);
+    if (directory == null) {
+      throw new IOException("InMemoryAliasMap location is null");
+    }
-      String error = createPathErrorMessage(directory);
-      throw new IOException(error);
+      LOG.warn("InMemoryAliasMap location {} is missing. Creating it.",
+          levelDBpath);
+      if(!levelDBpath.mkdirs()) {
+        throw new IOException(
+            "Unable to create missing aliasmap location: " + levelDBpath);
+      }
-    InMemoryAliasMap aliasMap = new InMemoryAliasMap(levelDb, blockPoolID);
+    InMemoryAliasMap aliasMap =  new InMemoryAliasMap(levelDBpath.toURI(),
+        levelDb, blockPoolID);
-  InMemoryAliasMap(DB levelDb, String blockPoolID) {
+  InMemoryAliasMap(URI aliasMapURI, DB levelDb, String blockPoolID) {
+    this.aliasMapURI = aliasMapURI;
+   * Transfer this aliasmap for bootstrapping standby Namenodes. The map is
+   * transferred as a tar.gz archive. This archive needs to be extracted on the
+   * standby Namenode.
+   *
+   * @param response http response.
+   * @param conf configuration to use.
+   * @param aliasMap aliasmap to transfer.
+   * @throws IOException
+   */
+  public static void transferForBootstrap(HttpServletResponse response,
+      Configuration conf, InMemoryAliasMap aliasMap) throws IOException {
+    File aliasMapSnapshot = null;
+    File compressedAliasMap = null;
+    try {
+      aliasMapSnapshot = createSnapshot(aliasMap);
+      // compress the snapshot that is associated with the
+      // block pool id of the aliasmap.
+      compressedAliasMap = getCompressedAliasMap(
+          new File(aliasMapSnapshot, aliasMap.blockPoolID));
+      try (FileInputStream fis = new FileInputStream(compressedAliasMap)) {
+        ImageServlet.setVerificationHeadersForGet(response, compressedAliasMap);
+        ImageServlet.setFileNameHeaders(response, compressedAliasMap);
+        // send file
+        DataTransferThrottler throttler =
+            ImageServlet.getThrottlerForBootstrapStandby(conf);
+        TransferFsImage.copyFileToStream(response.getOutputStream(),
+            compressedAliasMap, fis, throttler);
+      }
+    } finally {
+      // cleanup the temporary snapshot and compressed files.
+      StringBuilder errMessage = new StringBuilder();
+      if (compressedAliasMap != null
+          && !FileUtil.fullyDelete(compressedAliasMap)) {
+        errMessage.append("Failed to fully delete compressed aliasmap ")
+            .append(compressedAliasMap.getAbsolutePath()).append("\n");
+      }
+      if (aliasMapSnapshot != null && !FileUtil.fullyDelete(aliasMapSnapshot)) {
+        errMessage.append("Failed to fully delete the aliasmap snapshot ")
+            .append(aliasMapSnapshot.getAbsolutePath()).append("\n");
+      }
+      if (errMessage.length() > 0) {
+        throw new IOException(errMessage.toString());
+      }
+    }
+  }
+
+  /**
+   * Create a new LevelDB store which is a snapshot copy of the original
+   * aliasmap.
+   *
+   * @param aliasMap original aliasmap.
+   * @return the {@link File} where the snapshot is created.
+   * @throws IOException
+   */
+  static File createSnapshot(InMemoryAliasMap aliasMap) throws IOException {
+    File originalAliasMapDir = new File(aliasMap.aliasMapURI);
+    String bpid = originalAliasMapDir.getName();
+    File snapshotDir =
+        new File(originalAliasMapDir.getParent(), SNAPSHOT_COPY_DIR);
+    File newLevelDBDir = new File(snapshotDir, bpid);
+    if (!newLevelDBDir.mkdirs()) {
+      throw new IOException(
+          "Unable to create aliasmap snapshot directory " + newLevelDBDir);
+    }
+    // get a snapshot for the original DB.
+    DB originalDB = aliasMap.levelDb;
+    try (Snapshot snapshot = originalDB.getSnapshot()) {
+      // create a new DB for the snapshot and copy all K,V pairs.
+      Options options = new Options();
+      options.createIfMissing(true);
+      try (DB snapshotDB = JniDBFactory.factory.open(newLevelDBDir, options)) {
+        try (DBIterator iterator =
+            originalDB.iterator(new ReadOptions().snapshot(snapshot))) {
+          iterator.seekToFirst();
+          while (iterator.hasNext()) {
+            Map.Entry<byte[], byte[]> entry = iterator.next();
+            snapshotDB.put(entry.getKey(), entry.getValue());
+          }
+        }
+      }
+    }
+
+    return snapshotDir;
+  }
+
+  /**
+   * Compress the given aliasmap directory as tar.gz.
+   *
+   * @return a reference to the compressed aliasmap.
+   * @throws IOException
+   */
+  private static File getCompressedAliasMap(File aliasMapDir)
+      throws IOException {
+    File outCompressedFile = new File(aliasMapDir.getParent(), TAR_NAME);
+    BufferedOutputStream bOut = null;
+    GzipCompressorOutputStream gzOut = null;
+    TarArchiveOutputStream tOut = null;
+    try {
+      bOut = new BufferedOutputStream(new FileOutputStream(outCompressedFile));
+      gzOut = new GzipCompressorOutputStream(bOut);
+      tOut = new TarArchiveOutputStream(gzOut);
+      addFileToTarGzRecursively(tOut, aliasMapDir, "", new Configuration());
+    } finally {
+      if (tOut != null) {
+        tOut.finish();
+      }
+      IOUtils.cleanupWithLogger(null, tOut, gzOut, bOut);
+    }
+    return outCompressedFile;
+  }
+
+  /**
+   * Add all contents of the given file to the archive.
+   *
+   * @param tOut archive to use.
+   * @param file file to archive.
+   * @param prefix path prefix.
+   * @throws IOException
+   */
+  private static void addFileToTarGzRecursively(TarArchiveOutputStream tOut,
+      File file, String prefix, Configuration conf) throws IOException {
+    String entryName = prefix + file.getName();
+    TarArchiveEntry tarEntry = new TarArchiveEntry(file, entryName);
+    tOut.putArchiveEntry(tarEntry);
+
+    LOG.debug("Adding entry {} to alias map archive", entryName);
+    if (file.isFile()) {
+      try (FileInputStream in = new FileInputStream(file)) {
+        IOUtils.copyBytes(in, tOut, conf, false);
+      }
+      tOut.closeArchiveEntry();
+    } else {
+      tOut.closeArchiveEntry();
+      File[] children = file.listFiles();
+      if (children != null) {
+        for (File child : children) {
+          // skip the LOCK file
+          if (!child.getName().equals("LOCK")) {
+            addFileToTarGzRecursively(tOut, child, entryName + "/", conf);
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Extract the aliasmap archive to complete the bootstrap process. This method
+   * has to be called after the aliasmap archive is transfered from the primary
+   * Namenode.
+   *
+   * @param aliasMap location of the aliasmap.
+   * @throws IOException
+   */
+  public static void completeBootstrapTransfer(File aliasMap)
+      throws IOException {
+    File tarname = new File(aliasMap, TAR_NAME);
+    if (!tarname.exists()) {
+      throw new IOException(
+          "Aliasmap archive (" + tarname + ") does not exist");
+    }
+    try {
+      FileUtil.unTar(tarname, aliasMap);
+    } finally {
+      // delete the archive.
+      if(!FileUtil.fullyDelete(tarname)) {
+        LOG.warn("Failed to fully delete aliasmap archive: " + tarname);
+      }
+    }
+  }
+
+  /**

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 MOV43 INS59 INS83 INS83 INS43 INS59 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 MOV44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS43 INS8 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS25 INS25 INS43 INS42 INS21 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS54 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS25 INS60 INS54 INS41 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 UPD42 INS43 INS42 INS42 INS60 INS60 INS21 INS21 INS25 INS65 INS65 INS65 INS43 INS42 INS42 INS60 INS25 INS54 INS27 INS8 MOV38 INS8 MOV43 INS42 INS7 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS8 INS8 INS66 INS66 INS42 INS66 INS66 INS65 INS66 INS42 INS42 INS43 INS59 MOV43 INS59 INS43 INS59 INS43 INS59 INS38 INS8 INS43 INS59 INS58 INS8 INS42 INS66 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS8 INS8 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS32 INS32 INS8 INS8 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS43 INS59 INS38 INS8 INS8 INS8 INS42 INS33 MOV53 MOV21 MOV25 INS22 INS42 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS21 INS54 INS60 INS25 INS25 INS25 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS14 INS32 INS53 INS42 INS42 INS40 INS43 INS59 INS60 INS21 INS54 INS42 INS42 INS14 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS21 INS21 INS21 INS25 INS21 INS42 INS42 INS27 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS54 INS21 INS21 INS60 INS25 INS42 INS42 INS14 INS32 INS53 INS21 INS25 INS38 INS8 MOV43 INS32 INS52 INS42 INS7 INS7 INS58 INS8 INS43 INS59 INS27 INS8 INS27 INS8 INS27 INS8 INS43 INS40 INS42 INS42 INS43 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS43 INS59 INS32 INS58 INS8 INS43 INS32 INS42 INS7 INS7 INS7 INS32 INS27 INS8 INS32 INS42 INS32 INS43 INS42 INS42 INS58 INS8 INS32 INS32 INS5 INS59 INS27 INS8 INS43 INS42 INS42 INS42 INS42 INS14 INS32 INS38 INS8 INS45 UPD42 UPD45 UPD42 INS32 INS53 INS42 INS42 INS42 INS32 INS42 INS32 INS43 INS59 INS21 INS21 INS60 INS21 INS42 INS42 MOV14 INS27 INS38 INS21 INS27 INS38 INS21 INS32 INS34 INS53 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS9 INS43 INS59 INS54 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS45 INS14 INS42 INS33 INS21 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS21 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS32 INS42 INS33 INS70 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS32 INS21 UPD42 MOV42 UPD42 MOV42 INS14 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS32 INS32 INS43 INS59 INS32 INS42 INS33 INS32 INS32 INS42 INS33 INS32 INS32 INS42 INS42 INS14 INS42 INS45 INS42 INS43 INS42 INS42 INS32 INS58 INS8 INS43 INS14 INS43 INS42 INS43 INS42 INS43 INS32 INS42 INS42 INS14 INS32 INS42 INS42 INS42 INS44 INS42 INS8 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS32 INS43 INS27 INS43 INS42 INS40 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 MOV42 UPD45 MOV45 INS42 INS42 INS42 INS32 INS42 INS45 INS43 INS32 INS42 INS40 INS42 INS42 INS42 INS43 INS59 INS21 INS61 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS43 INS42 INS25 INS42 INS42 INS27 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 MOV42 INS42 INS42 INS32 INS32 INS32 INS8 INS42 INS42 INS42 INS38 INS8 INS45 INS42 INS42 UPD45 UPD42 MOV42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS60 INS21 INS32 INS21 INS14 INS42 INS42 INS74 INS59 INS32 INS32 INS42 INS45 INS32 INS43 INS43 INS5 INS5 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS40 INS39 INS85 INS39 INS85 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL78 DEL42 DEL32 DEL32 DEL41 DEL8
HDFS-8757 : OzoneHandler : Add localStorageHandler support for Buckets. Contributed by Anu Engineer

-
+import org.apache.hadoop.ozone.web.handlers.BucketArgs;
+import org.apache.hadoop.ozone.web.request.OzoneAcl;
+import org.apache.hadoop.ozone.web.response.BucketInfo;
+import org.apache.hadoop.ozone.web.response.ListBuckets;
+import java.util.List;
+import java.util.ListIterator;
- * A stand alone Ozone implementation that allows us to run
- * Ozone tests in local mode. This acts as the
- * ozone backend when using MiniDFSCluster for testing.
+ * A stand alone Ozone implementation that allows us to run Ozone tests in local
+ * mode. This acts as the ozone backend when using MiniDFSCluster for testing.
-  static final Log LOG = LogFactory.getLog(OzoneMetadataManager.class);
-  private static OzoneMetadataManager bm = null;
-
+  static final Log LOG = LogFactory.getLog(OzoneMetadataManager.class);
+  private static final String USER_DB = "/user.db";
+  private static final String META_DB = "/metadata.db";
+  private static OzoneMetadataManager bm = null;
-
-  private static final  String USER_DB = "/user.db";
-  private static final  String META_DB = "/metadata.db";
-
-                    OzoneConfigKeys.DFS_STORAGE_LOCAL_ROOT_DEFAULT);
+            OzoneConfigKeys.DFS_STORAGE_LOCAL_ROOT_DEFAULT);
+   *
-  public static synchronized  OzoneMetadataManager getOzoneMetadataManager() {
+  public static synchronized OzoneMetadataManager getOzoneMetadataManager() {
-   *
+    lock.writeLock().lock();
-      lock.writeLock().lock();
-                 volumeList.toDBString().getBytes(encoding));
+          volumeList.toDBString().getBytes(encoding));
-                     newVInfo.toDBString().getBytes(encoding));
+          newVInfo.toDBString().getBytes(encoding));
-   * @param args - Volume Args
+   * @param args     - Volume Args
-   *
-    VolumeInfo info;
+    lock.writeLock().lock();
-      lock.writeLock().lock();
-      info = VolumeInfo.parse(new String(volumeInfo, encoding));
+      VolumeInfo info = VolumeInfo.parse(new String(volumeInfo, encoding));
-            ErrorTable.newError(ErrorTable.SERVER_ERROR, args);
+            ErrorTable.newError(ErrorTable.BAD_PROPERTY, args);
-                     info.toDBString().getBytes(encoding));
+          info.toDBString().getBytes(encoding));
-                 volumeList.toDBString().getBytes(encoding));
+          volumeList.toDBString().getBytes(encoding));
-   *
-               volumeList.toDBString().getBytes(encoding));
+        volumeList.toDBString().getBytes(encoding));
-   *
-   *
-    VolumeInfo info;
+    lock.readLock().lock();
-      lock.readLock().lock();
-      info = VolumeInfo.parse(new String(volumeInfo, encoding));
+
+      VolumeInfo info = VolumeInfo.parse(new String(volumeInfo, encoding));
-   *
-   *
+    lock.readLock().lock();
-      lock.readLock().lock();
-   *
-   *
+    lock.readLock().lock();
-      lock.readLock().lock();
-   *
+    lock.writeLock().lock();
-      lock.writeLock().lock();
-                 volumeList.toDBString().getBytes(encoding));
+          volumeList.toDBString().getBytes(encoding));
+  /**
+   * Create a bucket if it does not exist.
+   *
+   * @param args - BucketArgs
+   * @throws OzoneException
+   */
+  public void createBucket(BucketArgs args) throws OzoneException {
+    lock.writeLock().lock();
+    try {
+      // check if volume exists, buckets cannot be created without volumes
+      byte[] volumeName = metadataDB.get(args.getVolumeName()
+          .getBytes(encoding));
+      if (volumeName == null) {
+        throw ErrorTable.newError(ErrorTable.VOLUME_NOT_FOUND, args);
+      }
+
+      // A resource name is volume/bucket -- That is the key in metadata table
+      byte[] bucketName = metadataDB.get(args.getResourceName()
+          .getBytes(encoding));
+      if (bucketName != null) {
+        throw ErrorTable.newError(ErrorTable.BUCKET_ALREADY_EXISTS, args);
+      }
+
+      BucketInfo bucketInfo =
+          new BucketInfo(args.getVolumeName(), args.getBucketName());
+
+      if (args.getRemoveAcls() != null) {
+        OzoneException ex = ErrorTable.newError(ErrorTable.MALFORMED_ACL, args);
+        ex.setMessage("Remove ACLs specified in bucket create. Please remove " +
+            "them and retry.");
+        throw ex;
+      }
+
+      VolumeInfo volInfo = VolumeInfo.parse(new String(volumeName, encoding));
+      volInfo.setBucketCount(volInfo.getBucketCount() + 1);
+
+      bucketInfo.setAcls(args.getAddAcls());
+      bucketInfo.setStorageType(args.getStorageType());
+      bucketInfo.setVersioning(args.getVersioning());
+      ListBuckets bucketList;
+
+      // get bucket list from user/volume -> bucketList
+      byte[] volumeBuckets = userDB.get(args.getParentName()
+          .getBytes(encoding));
+      if (volumeBuckets == null) {
+        bucketList = new ListBuckets();
+      } else {
+        bucketList = ListBuckets.parse(new String(volumeBuckets, encoding));
+      }
+
+      bucketList.addBucket(bucketInfo);
+      bucketList.sort();
+
+      // Update Volume->bucketCount
+      userDB.put(args.getVolumeName().getBytes(encoding),
+          volInfo.toDBString().getBytes(encoding));
+
+      // Now update the userDB with user/volume -> bucketList
+      userDB.put(args.getParentName().getBytes(encoding),
+          bucketList.toDBString().getBytes(encoding));
+
+      // and update the metadataDB with volume/bucket->BucketInfo
+      metadataDB.put(args.getResourceName().getBytes(encoding),
+          bucketInfo.toDBString().getBytes(encoding));
+
+    } catch (IOException | DBException ex) {
+      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args, ex);
+    } finally {
+      lock.writeLock().unlock();
+    }
+  }
+
+  /**
+   * Updates the Bucket properties like ACls and Storagetype.
+   *
+   * @param args     - Bucket Args
+   * @param property - Flag which tells us what property to upgrade
+   * @throws OzoneException
+   */
+  public void setBucketProperty(BucketArgs args, BucketProperty property)
+      throws OzoneException {
+
+    lock.writeLock().lock();
+    try {
+      // volume/bucket-> bucketInfo
+      byte[] bucketInfo = metadataDB.get(args.getResourceName().
+          getBytes(encoding));
+      if (bucketInfo == null) {
+        throw ErrorTable.newError(ErrorTable.INVALID_BUCKET_NAME, args);
+      }
+
+      BucketInfo info = BucketInfo.parse(new String(bucketInfo, encoding));
+      byte[] volumeBuckets = userDB.get(args.getParentName()
+          .getBytes(encoding));
+      ListBuckets bucketList = ListBuckets.parse(new String(volumeBuckets,
+          encoding));
+      bucketList.getBuckets().remove(info);
+
+      switch (property) {
+      case ACLS:
+        processRemoveAcls(args, info);
+        processAddAcls(args, info);
+        break;
+      case STORAGETYPE:
+        info.setStorageType(args.getStorageType());
+        break;
+      case VERSIONING:
+        info.setVersioning(args.getVersioning());
+        break;
+      default:
+        OzoneException ozEx =
+            ErrorTable.newError(ErrorTable.BAD_PROPERTY, args);
+        ozEx.setMessage("Bucket property is not recognized.");
+        throw ozEx;
+      }
+
+      bucketList.addBucket(info);
+      metadataDB.put(args.getResourceName().getBytes(encoding),
+          info.toDBString().getBytes(encoding));
+
+      userDB.put(args.getParentName().getBytes(encoding),
+          bucketList.toDBString().getBytes(encoding));
+    } catch (IOException | DBException ex) {
+      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args, ex);
+    } finally {
+      lock.writeLock().unlock();
+    }
+  }
+
+  /**
+   * Process Remove Acls and remove them from the bucket.
+   *
+   * @param args - BucketArgs
+   * @param info - BucketInfo
+   */
+  private void processRemoveAcls(BucketArgs args, BucketInfo info) {
+    List<OzoneAcl> removeAcls = args.getRemoveAcls();
+    if ((removeAcls == null) || (info.getAcls() == null)) {
+      return;
+    }
+    for (OzoneAcl racl : args.getRemoveAcls()) {
+      ListIterator<OzoneAcl> aclIter = info.getAcls().listIterator();
+      while (aclIter.hasNext()) {
+        if (racl.equals(aclIter.next())) {
+          aclIter.remove();
+          break;
+        }
+      }
+    }
+  }
+
+  /**
+   * Process Add Acls and Add them to the bucket.
+   *
+   * @param args - BucketArgs
+   * @param info - BucketInfo
+   */
+  private void processAddAcls(BucketArgs args, BucketInfo info) {
+    List<OzoneAcl> addAcls = args.getAddAcls();
+    if ((addAcls == null)) {
+      return;
+    }
+
+    if (info.getAcls() == null) {
+      info.setAcls(addAcls);
+      return;
+    }
+
+    for (OzoneAcl newacl : addAcls) {
+      ListIterator<OzoneAcl> aclIter = info.getAcls().listIterator();
+      while (aclIter.hasNext()) {
+        if (newacl.equals(aclIter.next())) {
+          continue;
+        }
+      }
+      info.getAcls().add(newacl);
+    }
+  }
+
+  /**
+   * Deletes a given bucket.
+   *
+   * @param args - BucketArgs
+   * @throws OzoneException
+   */
+  public void deleteBucket(BucketArgs args) throws OzoneException {
+    lock.writeLock().lock();
+    try {
+      byte[] bucketInfo = metadataDB.get(args.getResourceName()
+          .getBytes(encoding));
+      if (bucketInfo == null) {
+        throw ErrorTable.newError(ErrorTable.INVALID_BUCKET_NAME, args);
+      }
+
+      BucketInfo bInfo = BucketInfo.parse(new String(bucketInfo, encoding));
+
+      // Only remove buckets if they are empty.
+      if (bInfo.getKeyCount() > 0) {
+        throw ErrorTable.newError(ErrorTable.BUCKET_NOT_EMPTY, args);
+      }
+
+      byte[] bucketBytes = userDB.get(args.getParentName().getBytes(encoding));
+      if (bucketBytes == null) {
+        throw ErrorTable.newError(ErrorTable.INVALID_BUCKET_NAME, args);
+      }
+
+      ListBuckets bucketList =
+          ListBuckets.parse(new String(bucketBytes, encoding));
+      bucketList.getBuckets().remove(bInfo);
+
+      metadataDB.delete(args.getResourceName().getBytes(encoding));
+      userDB.put(args.getParentName().getBytes(encoding),
+          bucketList.toDBString().getBytes(encoding));
+    } catch (IOException | DBException ex) {
+      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args, ex);
+    } finally {
+      lock.writeLock().unlock();
+    }
+  }
+
+  /**
+   * Returns the Bucket info for a given bucket.
+   *
+   * @param args - Bucket Args
+   * @return BucketInfo   -  Bucket Information
+   * @throws OzoneException
+   */
+  public BucketInfo getBucketInfo(BucketArgs args) throws OzoneException {
+    lock.readLock().lock();
+    try {
+      byte[] bucketBytes = metadataDB.get(args.getResourceName()
+          .getBytes(encoding));
+      if (bucketBytes == null) {
+        throw ErrorTable.newError(ErrorTable.INVALID_BUCKET_NAME, args);
+      }
+
+      return BucketInfo.parse(new String(bucketBytes, encoding));
+    } catch (IOException ex) {
+      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args, ex);
+    } finally {
+      lock.readLock().unlock();
+    }
+  }
+
+  /**
+   * Returns a list of buckets for a given volume.
+   *
+   * @param args - volume args
+   * @return List of buckets
+   * @throws OzoneException
+   */
+  public ListBuckets listBuckets(VolumeArgs args) throws OzoneException {
+    lock.readLock().lock();
+    try {
+      String userVolKey = args.getUserName() + "/" + args.getVolumeName();
+
+      byte[] bucketBytes = userDB.get(userVolKey.getBytes(encoding));
+      if (bucketBytes == null) {
+        throw ErrorTable.newError(ErrorTable.INVALID_VOLUME_NAME, args);
+      }
+      return ListBuckets.parse(new String(bucketBytes, encoding));
+    } catch (IOException ex) {
+      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args, ex);
+    } finally {
+      lock.readLock().unlock();
+    }
+  }
+
+  /**
+   * Bucket Properties.
+   */
+  public enum BucketProperty {
+    ACLS, STORAGETYPE, VERSIONING
+  }

INS26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV23 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS71 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS42 INS72 INS72 INS72 UPD66 UPD66 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS65 INS65 INS65 INS43 INS42 INS42 INS21 INS54 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS21 INS54 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS25 INS70 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS25 INS25 INS70 INS65 INS65 INS65 INS43 INS42 INS42 INS21 INS54 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS21 INS54 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS21 INS54 INS65 INS42 INS42 INS42 UPD66 INS66 INS42 INS66 INS42 INS42 INS32 INS8 INS12 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS32 INS8 INS12 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS74 INS59 INS27 INS8 INS44 INS32 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS74 INS59 INS36 INS8 INS27 INS8 INS44 INS42 INS8 INS66 INS42 INS66 INS42 INS42 INS32 INS8 INS12 INS8 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS8 INS12 INS8 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS8 INS12 INS8 INS66 INS60 INS60 INS32 INS42 INS60 INS25 INS60 INS25 INS60 INS25 INS60 INS21 INS21 INS21 INS21 INS60 INS60 INS25 INS21 INS21 INS21 INS21 INS21 INS44 INS8 INS21 INS32 INS42 INS60 INS25 INS60 INS60 INS60 INS21 INS50 INS21 INS21 INS21 INS44 INS8 INS21 INS43 INS43 INS42 INS32 INS36 INS36 INS41 INS43 INS42 INS42 INS42 INS60 INS61 INS43 INS43 INS42 INS32 INS27 INS41 INS32 INS33 INS21 INS41 INS43 INS42 INS60 INS61 INS21 INS32 INS42 INS60 INS25 INS60 INS25 INS60 INS25 INS60 INS21 INS21 INS21 INS44 INS8 INS21 INS32 INS42 INS60 INS25 INS41 INS44 INS8 INS21 INS32 INS42 INS60 INS60 INS25 INS41 INS44 INS8 INS21 MOV43 INS59 MOV43 INS59 INS42 INS42 INS5 INS59 INS27 INS8 INS5 INS59 INS27 INS8 INS43 INS59 INS27 INS8 INS43 INS59 INS32 INS32 INS32 INS32 INS43 INS59 INS5 INS59 INS27 INS8 INS8 INS32 INS32 INS32 INS32 INS32 INS84 INS42 INS53 INS32 INS42 INS42 INS5 INS59 INS27 INS8 INS43 INS59 INS5 INS59 INS43 INS59 INS32 INS42 INS49 INS21 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS60 INS21 INS53 INS32 INS32 INS32 INS84 INS42 INS53 INS32 INS42 INS42 INS42 INS42 INS27 INS27 INS42 INS74 INS59 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS74 INS59 INS32 INS8 INS32 INS42 INS42 INS5 INS59 INS27 INS8 INS43 INS59 INS27 INS8 INS5 INS59 INS27 INS8 INS43 INS59 INS32 INS32 INS32 INS84 INS42 INS53 INS32 INS42 INS42 INS5 INS59 INS27 INS8 INS32 INS43 INS42 INS53 INS32 INS42 INS42 INS43 INS59 INS5 INS59 INS27 INS8 INS32 INS43 INS42 INS53 INS32 INS42 MOV32 INS42 MOV32 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS14 INS32 INS33 INS60 INS21 INS53 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS39 INS85 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS32 INS43 INS43 INS32 INS32 INS42 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS32 INS39 INS85 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS32 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS32 INS43 INS43 INS32 INS32 INS42 INS42 INS33 INS32 INS33 INS43 INS43 INS42 INS32 INS42 INS42 INS25 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS42 INS25 INS32 INS42 INS42 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS32 INS32 INS34 INS53 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS43 INS43 INS32 INS32 INS42 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS14 INS42 INS32 INS32 INS42 INS42 INS42 INS27 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS14 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS32 INS43 INS32 INS32 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS42 INS14 INS32 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS7 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS8 INS42 INS42 INS32 INS42 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS45 INS32 INS42 INS42 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 UPD40 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS43 INS42 INS42 INS32 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS21 INS10 INS42 INS42 INS42 INS42 INS32 INS18 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS43 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS45 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 DEL66 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21
YARN-7653. Node group support for AllocationTagsManager. (Panagiotis Garefalakis via asuresh)

+import org.apache.hadoop.yarn.server.resourcemanager.RMContext;
- * Support storing maps between container-tags/applications and
- * nodes. This will be required by affinity/anti-affinity implementation and
- * cardinality.
+ * In-memory mapping between applications/container-tags and nodes/racks.
+ * Required by constrained affinity/anti-affinity and cardinality placement.
+  private final RMContext rmContext;
-  // Application's tags to node
-  private Map<ApplicationId, NodeToCountedTags> perAppMappings =
+  // Application's tags to Node
+  private Map<ApplicationId, NodeToCountedTags> perAppNodeMappings =
+      new HashMap<>();
+  // Application's tags to Rack
+  private Map<ApplicationId, NodeToCountedTags> perAppRackMappings =
-  private NodeToCountedTags globalMapping = new NodeToCountedTags();
+  private NodeToCountedTags<NodeId> globalNodeMapping = new NodeToCountedTags();
+  // Global tags to Rack mapping
+  private NodeToCountedTags<String> globalRackMapping = new NodeToCountedTags();
-   * Store node to counted tags.
+   * Generic store mapping type <T> to counted tags.
+   * Currently used both for NodeId to Tag, Count and Rack to Tag, Count
-  static class NodeToCountedTags {
-    // Map<NodeId, Map<Tag, Count>>
-    private Map<NodeId, Map<String, Long>> nodeToTagsWithCount =
-        new HashMap<>();
+  static class NodeToCountedTags<T> {
+    // Map<Type, Map<Tag, Count>>
+    private Map<T, Map<String, Long>> typeToTagsWithCount = new HashMap<>();
-    private void addTagsToNode(NodeId nodeId, Set<String> tags) {
-      Map<String, Long> innerMap = nodeToTagsWithCount.computeIfAbsent(nodeId,
-          k -> new HashMap<>());
+    private void addTags(T type, Set<String> tags) {
+      Map<String, Long> innerMap =
+          typeToTagsWithCount.computeIfAbsent(type, k -> new HashMap<>());
-        } else{
+        } else {
-    private void addTagToNode(NodeId nodeId, String tag) {
-      Map<String, Long> innerMap = nodeToTagsWithCount.computeIfAbsent(nodeId,
-          k -> new HashMap<>());
+    private void addTag(T type, String tag) {
+      Map<String, Long> innerMap =
+          typeToTagsWithCount.computeIfAbsent(type, k -> new HashMap<>());
-      } else{
+      } else {
-              "Trying to remove tags from node, however the count already"
+              "Trying to remove tags from node/rack, however the count already"
-    private void removeTagsFromNode(NodeId nodeId, Set<String> tags) {
-      Map<String, Long> innerMap = nodeToTagsWithCount.get(nodeId);
+    private void removeTags(T type, Set<String> tags) {
+      Map<String, Long> innerMap = typeToTagsWithCount.get(type);
-        LOG.warn("Failed to find node=" + nodeId
+        LOG.warn("Failed to find node/rack=" + type
-        nodeToTagsWithCount.remove(nodeId);
+        typeToTagsWithCount.remove(type);
-    private void removeTagFromNode(NodeId nodeId, String tag) {
-      Map<String, Long> innerMap = nodeToTagsWithCount.get(nodeId);
+    private void removeTag(T type, String tag) {
+      Map<String, Long> innerMap = typeToTagsWithCount.get(type);
-        LOG.warn("Failed to find node=" + nodeId
+        LOG.warn("Failed to find node/rack=" + type
-        nodeToTagsWithCount.remove(nodeId);
+        typeToTagsWithCount.remove(type);
-    private long getCardinality(NodeId nodeId, String tag) {
-      Map<String, Long> innerMap = nodeToTagsWithCount.get(nodeId);
+    private long getCardinality(T type, String tag) {
+      Map<String, Long> innerMap = typeToTagsWithCount.get(type);
-    private long getCardinality(NodeId nodeId, Set<String> tags,
+    private long getCardinality(T type, Set<String> tags,
-      Map<String, Long> innerMap = nodeToTagsWithCount.get(nodeId);
+      Map<String, Long> innerMap = typeToTagsWithCount.get(type);
-      return nodeToTagsWithCount.isEmpty();
+      return typeToTagsWithCount.isEmpty();
-    public Map<NodeId, Map<String, Long>> getNodeToTagsWithCount() {
-      return nodeToTagsWithCount;
+    public Map<T, Map<String, Long>> getTypeToTagsWithCount() {
+      return typeToTagsWithCount;
-  Map<ApplicationId, NodeToCountedTags> getPerAppMappings() {
-    return perAppMappings;
+  Map<ApplicationId, NodeToCountedTags> getPerAppNodeMappings() {
+    return perAppNodeMappings;
-  NodeToCountedTags getGlobalMapping() {
-    return globalMapping;
+  Map<ApplicationId, NodeToCountedTags> getPerAppRackMappings() {
+    return perAppRackMappings;
-  public AllocationTagsManager() {
+  @VisibleForTesting
+  NodeToCountedTags getGlobalNodeMapping() {
+    return globalNodeMapping;
+  }
+
+  @VisibleForTesting
+  NodeToCountedTags getGlobalRackMapping() {
+    return globalRackMapping;
+  }
+
+  public AllocationTagsManager(RMContext context) {
+    rmContext = context;
-      NodeToCountedTags perAppTagsMapping = perAppMappings.computeIfAbsent(
-          applicationId, k -> new NodeToCountedTags());
-
+      NodeToCountedTags perAppTagsMapping = perAppNodeMappings
+          .computeIfAbsent(applicationId, k -> new NodeToCountedTags());
+      NodeToCountedTags perAppRackTagsMapping = perAppRackMappings
+          .computeIfAbsent(applicationId, k -> new NodeToCountedTags());
+      // Covering test-cases where context is mocked
+      String nodeRack = (rmContext.getRMNodes() != null
+          && rmContext.getRMNodes().get(nodeId) != null)
+              ? rmContext.getRMNodes().get(nodeId).getRackName()
+              : "default-rack";
-        perAppTagsMapping.addTagsToNode(nodeId, allocationTags);
-        globalMapping.addTagsToNode(nodeId, allocationTags);
+        perAppTagsMapping.addTags(nodeId, allocationTags);
+        perAppRackTagsMapping.addTags(nodeRack, allocationTags);
+        globalNodeMapping.addTags(nodeId, allocationTags);
+        globalRackMapping.addTags(nodeRack, allocationTags);
-        perAppTagsMapping.addTagToNode(nodeId, applicationIdTag);
-        globalMapping.addTagToNode(nodeId, applicationIdTag);
+        perAppTagsMapping.addTag(nodeId, applicationIdTag);
+        perAppRackTagsMapping.addTag(nodeRack, applicationIdTag);
+        globalNodeMapping.addTag(nodeId, applicationIdTag);
+        globalRackMapping.addTag(nodeRack, applicationIdTag);
-        LOG.debug(
-            "Added container=" + containerId + " with tags=[" + StringUtils
-                .join(allocationTags, ",") + "]");
+        LOG.debug("Added container=" + containerId + " with tags=["
+            + StringUtils.join(allocationTags, ",") + "]");
-      NodeToCountedTags perAppTagsMapping = perAppMappings.get(applicationId);
+      NodeToCountedTags perAppTagsMapping =
+          perAppNodeMappings.get(applicationId);
+      NodeToCountedTags perAppRackTagsMapping =
+          perAppRackMappings.get(applicationId);
-
+      // Covering test-cases where context is mocked
+      String nodeRack = (rmContext.getRMNodes() != null
+          && rmContext.getRMNodes().get(nodeId) != null)
+              ? rmContext.getRMNodes().get(nodeId).getRackName()
+              : "default-rack";
-        perAppTagsMapping.removeTagsFromNode(nodeId, allocationTags);
-        globalMapping.removeTagsFromNode(nodeId, allocationTags);
+        perAppTagsMapping.removeTags(nodeId, allocationTags);
+        perAppRackTagsMapping.removeTags(nodeRack, allocationTags);
+        globalNodeMapping.removeTags(nodeId, allocationTags);
+        globalRackMapping.removeTags(nodeRack, allocationTags);
-        perAppTagsMapping.removeTagFromNode(nodeId, applicationIdTag);
-        globalMapping.removeTagFromNode(nodeId, applicationIdTag);
+        perAppTagsMapping.removeTag(nodeId, applicationIdTag);
+        perAppRackTagsMapping.removeTag(nodeRack, applicationIdTag);
+        globalNodeMapping.removeTag(nodeId, applicationIdTag);
+        globalRackMapping.removeTag(nodeRack, applicationIdTag);
-        perAppMappings.remove(applicationId);
+        perAppNodeMappings.remove(applicationId);
+      }
+      if (perAppRackTagsMapping.isEmpty()) {
+        perAppRackMappings.remove(applicationId);
-        LOG.debug(
-            "Removed container=" + containerId + " with tags=[" + StringUtils
-                .join(allocationTags, ",") + "]");
+        LOG.debug("Removed container=" + containerId + " with tags=["
+            + StringUtils.join(allocationTags, ",") + "]");
-   * Get cardinality for following conditions. External can pass-in a binary op
-   * to implement customized logic.   *
+   * Get Node cardinality for a specific tag.
+   * When applicationId is null, method returns aggregated cardinality
+   *
-   *                      When multiple tags specified. Returns cardinality
-   *                      depends on op. If a specified tag doesn't exist,
-   *                      0 will be its cardinality.
-   *                      When null/empty tags specified, all tags
-   *                      (of the node/app) will be considered.
+   *                      If a specified tag doesn't exist,
+   *                      method returns 0.
-            "Must specify nodeId/tags/op to query cardinality");
+            "Must specify nodeId/tag to query cardinality");
-        mapping = perAppMappings.get(applicationId);
-      } else{
-        mapping = globalMapping;
+        mapping = perAppNodeMappings.get(applicationId);
+      } else {
+        mapping = globalNodeMapping;
+   * Get Rack cardinality for a specific tag.
+   *
+   * @param rack          rack, required.
+   * @param applicationId applicationId. When null is specified, return
+   *                      aggregated cardinality among all nodes.
+   * @param tag           allocation tag, see
+   *                      {@link SchedulingRequest#getAllocationTags()},
+   *                      If a specified tag doesn't exist,
+   *                      method returns 0.
+   * @return cardinality of specified query on the rack.
+   * @throws InvalidAllocationTagsQueryException when illegal query
+   *                                            parameter specified
+   */
+  public long getRackCardinality(String rack, ApplicationId applicationId,
+      String tag) throws InvalidAllocationTagsQueryException {
+    readLock.lock();
+
+    try {
+      if (rack == null) {
+        throw new InvalidAllocationTagsQueryException(
+            "Must specify rack/tag to query cardinality");
+      }
+
+      NodeToCountedTags mapping;
+      if (applicationId != null) {
+        mapping = perAppRackMappings.get(applicationId);
+      } else {
+        mapping = globalRackMapping;
+      }
+
+      if (mapping == null) {
+        return 0;
+      }
+
+      return mapping.getCardinality(rack, tag);
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+
+
+  /**
-   *                      aggregated cardinality among all nodes.
+   *                      aggregation among all applications.
-   *                      aggregated cardinality among all nodes.
+   *                      aggregated cardinality among all applications.
-   *                      This sparameter only take effect when #values >= 2.
+   *                      This parameter only take effect when #values >= 2.
-        mapping = perAppMappings.get(applicationId);
-      } else{
-        mapping = globalMapping;
+        mapping = perAppNodeMappings.get(applicationId);
+      } else {
+        mapping = globalNodeMapping;
+
+  /**
+   * Get cardinality for following conditions. External can pass-in a binary op
+   * to implement customized logic.
+   *
+   * @param rack          rack, required.
+   * @param applicationId applicationId. When null is specified, return
+   *                      aggregated cardinality among all applications.
+   * @param tags          allocation tags, see
+   *                      {@link SchedulingRequest#getAllocationTags()},
+   *                      When multiple tags specified. Returns cardinality
+   *                      depends on op. If a specified tag doesn't exist, 0
+   *                      will be its cardinality. When null/empty tags
+   *                      specified, all tags (of the rack/app) will be
+   *                      considered.
+   * @param op            operator. Such as Long::max, Long::sum, etc. Required.
+   *                      This parameter only take effect when #values >= 2.
+   * @return cardinality of specified query on the rack.
+   * @throws InvalidAllocationTagsQueryException when illegal query
+   *                                            parameter specified
+   */
+  public long getRackCardinalityByOp(String rack, ApplicationId applicationId,
+      Set<String> tags, LongBinaryOperator op)
+      throws InvalidAllocationTagsQueryException {
+    readLock.lock();
+
+    try {
+      if (rack == null || op == null) {
+        throw new InvalidAllocationTagsQueryException(
+            "Must specify rack/tags/op to query cardinality");
+      }
+
+      NodeToCountedTags mapping;
+      if (applicationId != null) {
+        mapping = perAppRackMappings.get(applicationId);
+      } else {
+        mapping = globalRackMapping;
+      }
+
+      if (mapping == null) {
+        return 0;
+      }
+
+      return mapping.getCardinality(rack, tags, op);
+    } finally {
+      readLock.unlock();
+    }
+  }

INS26 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS74 MOV59 INS74 INS83 INS74 INS59 INS73 UPD42 MOV78 INS74 INS42 INS8 UPD42 INS78 MOV43 INS42 INS8 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 UPD66 UPD66 INS42 INS42 UPD42 INS43 INS43 INS43 UPD42 INS43 INS43 UPD42 INS43 INS43 INS42 INS14 INS42 UPD74 INS59 UPD42 UPD42 UPD42 UPD42 INS78 UPD74 UPD42 INS43 INS43 INS43 INS41 INS42 INS41 INS43 INS42 INS21 INS65 INS65 MOV65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS21 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS74 INS42 INS43 INS42 INS42 INS21 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 UPD66 INS66 UPD43 INS42 INS14 UPD43 UPD42 INS60 UPD43 UPD42 MOV60 UPD43 UPD42 MOV60 UPD43 UPD42 MOV60 UPD43 UPD42 INS60 UPD43 UPD42 INS42 UPD43 UPD42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS7 UPD66 UPD66 UPD66 UPD66 INS66 INS42 INS66 INS42 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS32 INS8 INS8 INS42 INS66 INS66 UPD66 UPD66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS43 INS42 INS32 INS8 INS8 INS42 UPD42 INS74 UPD42 MOV74 INS59 UPD42 MOV74 UPD42 MOV27 MOV32 UPD42 MOV27 MOV32 UPD42 MOV74 INS59 UPD42 MOV74 UPD42 UPD42 INS42 INS42 INS60 INS60 INS60 INS60 INS25 INS68 INS42 INS42 INS25 INS60 INS25 INS25 INS41 INS21 INS68 INS42 INS42 INS42 INS42 INS25 INS60 INS25 INS25 INS41 INS21 INS43 INS42 INS32 INS42 INS32 UPD42 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS8 INS27 INS42 INS42 INS27 INS8 INS43 INS59 MOV27 INS8 INS8 INS27 INS8 INS32 INS32 INS42 INS42 INS27 INS8 INS43 INS59 INS27 INS8 INS8 INS27 INS8 INS32 INS32 INS42 INS42 INS42 INS42 MOV86 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS32 INS42 INS42 INS16 INS21 INS21 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS16 INS21 INS21 INS21 INS21 INS42 INS42 INS21 INS42 INS33 INS42 INS33 INS53 INS42 INS42 INS21 INS21 INS42 INS33 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS53 INS42 INS42 INS42 INS33 INS21 INS21 INS42 INS33 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS86 INS36 INS32 INS45 INS32 INS32 INS32 INS32 UPD42 INS42 INS42 INS42 INS36 INS32 INS45 INS32 INS32 INS32 INS32 INS32 INS14 INS7 INS7 INS34 INS42 INS33 INS42 INS33 INS14 INS7 INS7 INS34 UPD45 UPD42 UPD45 UPD42 INS59 INS14 INS27 INS32 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS27 INS32 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 UPD45 UPD42 INS43 INS45 INS42 INS32 INS42 INS42 UPD42 INS43 INS45 INS42 INS32 INS42 INS42 INS42 INS43 INS27 INS27 INS32 INS42 INS42 INS27 INS27 INS32 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD45 INS42 INS32 INS33 INS32 INS33 INS42 INS42 INS32 INS33 INS32 INS33 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL66 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL66 DEL66 DEL66
Merge branch 'trunk' into HADOOP-12756

+import java.util.EnumSet;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.hadoop.fs.CreateFlag;
+import org.apache.hadoop.fs.InvalidRequestException;
+import org.apache.hadoop.fs.PathIOException;
+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;
+  private final AtomicBoolean closed = new AtomicBoolean(false);
+   * {@inheritDoc}
+   * @throws FileNotFoundException if the parent directory is not present -or
+   * is not a directory.
+   */
+  @Override
+  public FSDataOutputStream createNonRecursive(Path path,
+      FsPermission permission,
+      EnumSet<CreateFlag> flags,
+      int bufferSize,
+      short replication,
+      long blockSize,
+      Progressable progress) throws IOException {
+    Path parent = path.getParent();
+    if (parent != null) {
+      // expect this to raise an exception if there is no parent
+      if (!getFileStatus(parent).isDirectory()) {
+        throw new FileAlreadyExistsException("Not a directory: " + parent);
+      }
+    }
+    return create(path, permission,
+        flags.contains(CreateFlag.OVERWRITE), bufferSize,
+        replication, blockSize, progress);
+  }
+
+  /**
-            removeKeys(keysToDelete, true);
+            removeKeys(keysToDelete, true, false);
-            removeKeys(keysToDelete, false);
+            removeKeys(keysToDelete, false, false);
-  private void deleteObject(String key) {
+  private void deleteObject(String key) throws InvalidRequestException {
+    blockRootDelete(key);
+   * Reject any request to delete an object where the key is root.
+   * @param key key to validate
+   * @throws InvalidRequestException if the request was rejected due to
+   * a mistaken attempt to delete the root directory.
+   */
+  private void blockRootDelete(String key) throws InvalidRequestException {
+    if (key.isEmpty() || "/".equals(key)) {
+      throw new InvalidRequestException("Bucket "+ bucket
+          +" cannot be deleted");
+    }
+  }
+
+  /**
-   * @param keysToDelete collection of keys to delete on the s3-backend
+   * @param keysToDelete collection of keys to delete on the s3-backend.
+   *        if empty, no request is made of the object store.
+   * @param deleteFakeDir indicates whether this is for deleting fake dirs
+   * @throws InvalidRequestException if the request was rejected due to
+   * a mistaken attempt to delete the root directory.
-          boolean clearKeys) throws AmazonClientException {
+      boolean clearKeys, boolean deleteFakeDir)
+      throws AmazonClientException, InvalidRequestException {
+    if (keysToDelete.isEmpty()) {
+      // exit fast if there are no keys to delete
+      return;
+    }
+    for (DeleteObjectsRequest.KeyVersion keyVersion : keysToDelete) {
+      blockRootDelete(keyVersion.getKey());
+    }
-      instrumentation.fileDeleted(keysToDelete.size());
+    }
+    if (!deleteFakeDir) {
+    } else {
+      instrumentation.fakeDirsDeleted(keysToDelete.size());
-      if (!recursive && !status.isEmptyDirectory()) {
-        throw new IOException("Path is a folder: " + f +
-                              " and it is not an empty directory");
-      }
-
-        LOG.info("s3a cannot delete the root directory");
-        return false;
+        return rejectRootDirectoryDelete(status, recursive);
+      }
+
+      if (!recursive && !status.isEmptyDirectory()) {
+        throw new PathIsNotEmptyDirectoryException(f.toString());
-              removeKeys(keys, true);
+              removeKeys(keys, true, false);
-              removeKeys(keys, false);
+              removeKeys(keys, false, false);
-    createFakeDirectoryIfNecessary(f.getParent());
+    Path parent = f.getParent();
+    if (parent != null) {
+      createFakeDirectoryIfNecessary(parent);
+    }
+  /**
+   * Implements the specific logic to reject root directory deletion.
+   * The caller must return the result of this call, rather than
+   * attempt to continue with the delete operation: deleting root
+   * directories is never allowed. This method simply implements
+   * the policy of when to return an exit code versus raise an exception.
+   * @param status filesystem status
+   * @param recursive recursive flag from command
+   * @return a return code for the operation
+   * @throws PathIOException if the operation was explicitly rejected.
+   */
+  private boolean rejectRootDirectoryDelete(S3AFileStatus status,
+      boolean recursive) throws IOException {
+    LOG.info("s3a delete the {} root directory of {}", bucket, recursive);
+    boolean emptyRoot = status.isEmptyDirectory();
+    if (emptyRoot) {
+      return true;
+    }
+    if (recursive) {
+      return false;
+    } else {
+      // reject
+      throw new PathIOException(bucket, "Cannot delete root path");
+    }
+  }
+
-  public synchronized void close() throws IOException {
+  public void close() throws IOException {
+    if (closed.getAndSet(true)) {
+      // already closed
+      return;
+    }
-   * @param f path
+   * @param path path
-  private void deleteUnnecessaryFakeDirectories(Path f) {
-    while (true) {
-      String key = "";
-      try {
-        key = pathToKey(f);
-        if (key.isEmpty()) {
-          break;
+  private void deleteUnnecessaryFakeDirectories(Path path) {
+    List<DeleteObjectsRequest.KeyVersion> keysToRemove = new ArrayList<>();
+    while (!path.isRoot()) {
+      String key = pathToKey(path);
+      key = (key.endsWith("/")) ? key : (key + "/");
+      keysToRemove.add(new DeleteObjectsRequest.KeyVersion(key));
+      path = path.getParent();
+    }
+    try {
+      removeKeys(keysToRemove, false, true);
+    } catch(AmazonClientException | InvalidRequestException e) {
+      instrumentation.errorIgnored();
+      if (LOG.isDebugEnabled()) {
+        StringBuilder sb = new StringBuilder();
+        for(DeleteObjectsRequest.KeyVersion kv : keysToRemove) {
+          sb.append(kv.getKey()).append(",");
-
-        S3AFileStatus status = getFileStatus(f);
-
-        if (status.isDirectory() && status.isEmptyDirectory()) {
-          LOG.debug("Deleting fake directory {}/", key);
-          deleteObject(key + "/");
-        }
-      } catch (IOException | AmazonClientException e) {
-        LOG.debug("While deleting key {} ", key, e);
-        instrumentation.errorIgnored();
+        LOG.debug("While deleting keys {} ", sb.toString(), e);
-
-      if (f.isRoot()) {
-        break;
-      }
-
-      f = f.getParent();
-

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS29 INS78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 MOV43 INS8 INS43 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS44 INS43 INS29 INS83 INS39 INS42 INS44 INS44 MOV43 INS8 MOV29 INS83 INS39 INS42 MOV44 INS8 INS42 INS42 INS14 INS65 INS65 INS42 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 MOV60 INS25 INS41 INS42 INS21 INS65 INS65 INS65 INS43 INS42 INS42 MOV25 INS65 INS65 INS39 INS42 INS42 INS25 INS70 INS25 INS60 INS25 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS21 INS60 INS25 INS25 INS25 UPD42 INS60 INS61 INS54 INS43 INS9 INS65 INS42 INS66 INS66 INS42 INS42 INS43 INS43 INS42 INS43 INS27 INS8 INS32 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS27 UPD66 INS66 INS42 INS66 INS42 INS66 INS66 INS32 INS8 INS44 INS42 INS8 INS38 INS8 INS8 MOV25 INS43 INS59 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 MOV42 INS32 INS39 INS59 INS42 INS8 INS42 INS8 INS8 INS32 INS8 UPD42 INS74 INS59 INS38 INS8 INS8 INS12 INS42 INS42 INS42 INS42 UPD42 INS32 INS42 INS33 INS25 INS42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS32 INS53 INS42 INS42 INS41 INS43 INS42 INS21 INS42 MOV21 INS21 INS42 INS42 MOV32 INS42 INS33 MOV21 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS42 INS42 MOV32 INS41 MOV41 INS53 INS42 INS42 INS9 INS41 INS43 INS43 INS42 INS14 INS32 INS60 MOV21 INS21 MOV21 MOV21 MOV44 INS8 INS42 INS42 INS38 INS8 UPD42 MOV42 INS42 INS40 INS45 INS42 INS42 INS14 INS40 INS32 INS32 MOV32 MOV27 INS9 INS14 INS42 INS40 INS74 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 INS7 INS32 INS7 UPD84 MOV21 INS25 INS32 INS53 INS43 INS27 INS42 INS32 INS42 INS42 INS32 INS41 INS53 INS42 INS43 INS42 INS45 INS43 INS42 INS32 INS42 INS16 INS42 INS42 INS14 INS42 INS32 UPD42 UPD42 INS9 INS9 INS43 MOV32 INS8 INS32 INS42 INS14 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS14 INS42 INS42 INS42 INS42 INS36 INS42 INS36 INS43 INS42 INS42 UPD42 MOV42 INS42 UPD42 UPD42 INS60 INS70 MOV21 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS43 INS32 INS32 MOV27 INS40 INS43 INS59 INS44 INS42 INS8 INS32 INS42 INS45 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD45 MOV45 INS42 INS42 INS14 INS43 INS42 INS21 INS42 INS42 INS45 INS32 INS42 INS43 INS40 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS45 INS9 INS9 INS42 INS42 INS32 INS42 INS42 INS9 INS9 DEL45 DEL10 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL45 DEL32 DEL21 DEL83 DEL42 DEL42 DEL32 DEL32 DEL42 DEL45 DEL42 DEL42 DEL32 DEL7 DEL83 DEL39 DEL42 DEL9 DEL42 DEL32 DEL7 DEL21 DEL43 DEL42 DEL32 DEL59 DEL60 DEL32 DEL27 DEL8 DEL25 DEL8 DEL8 DEL12 DEL54 DEL10 DEL8 DEL25 DEL8 DEL61 DEL8 DEL31
HDFS-3246: pRead equivalent for direct read path (#597)

HDFS-3246: pRead equivalent for direct read path

Contributed by Sahil Takiar
+import org.apache.hadoop.fs.ByteBufferPositionedReadable;
-    ReadableByteChannel, CanUnbuffer, StreamCapabilities {
+    ReadableByteChannel, CanUnbuffer, StreamCapabilities,
+    ByteBufferPositionedReadable {
-    try {
-      final int n = ((PositionedReadable) in).read(position, buffer, offset, 
-          length);
-      if (n > 0) {
-        // This operation does not change the current offset of the file
-        decrypt(position, buffer, offset, n);
-      }
-      
-      return n;
-    } catch (ClassCastException e) {
+    if (!(in instanceof PositionedReadable)) {
+    final int n = ((PositionedReadable) in).read(position, buffer, offset,
+        length);
+    if (n > 0) {
+      // This operation does not change the current offset of the file
+      decrypt(position, buffer, offset, n);
+    }
+
+    return n;
+  }
+
+  /**
+   * Positioned read using {@link ByteBuffer}s. This method is thread-safe.
+   */
+  @Override
+  public int read(long position, final ByteBuffer buf)
+      throws IOException {
+    checkStream();
+    if (!(in instanceof ByteBufferPositionedReadable)) {
+      throw new UnsupportedOperationException("This stream does not support " +
+          "positioned reads with byte buffers.");
+    }
+    int bufPos = buf.position();
+    final int n = ((ByteBufferPositionedReadable) in).read(position, buf);
+    if (n > 0) {
+      // This operation does not change the current offset of the file
+      decrypt(position, buf, n, bufPos);
+    }
+
+    return n;
-    ByteBuffer inBuffer = getBuffer();
-    ByteBuffer outBuffer = getBuffer();
+    ByteBuffer localInBuffer = null;
+    ByteBuffer localOutBuffer = null;
+      localInBuffer = getBuffer();
+      localOutBuffer = getBuffer();
-      inBuffer.position(padding); // Set proper position for input data.
+      localInBuffer.position(padding); // Set proper position for input data.
-        int toDecrypt = Math.min(length - n, inBuffer.remaining());
-        inBuffer.put(buffer, offset + n, toDecrypt);
+        int toDecrypt = Math.min(length - n, localInBuffer.remaining());
+        localInBuffer.put(buffer, offset + n, toDecrypt);
-        decrypt(decryptor, inBuffer, outBuffer, padding);
+        decrypt(decryptor, localInBuffer, localOutBuffer, padding);
-        outBuffer.get(buffer, offset + n, toDecrypt);
+        localOutBuffer.get(buffer, offset + n, toDecrypt);
-        padding = afterDecryption(decryptor, inBuffer, position + n, iv);
+        padding = afterDecryption(decryptor, localInBuffer, position + n, iv);
-      returnBuffer(inBuffer);
-      returnBuffer(outBuffer);
+      returnBuffer(localInBuffer);
+      returnBuffer(localOutBuffer);
-  
+
+  /**
+   * Decrypts the given {@link ByteBuffer} in place. {@code length} bytes are
+   * decrypted from {@code buf} starting at {@code start}.
+   * {@code buf.position()} and {@code buf.limit()} are unchanged after this
+   * method returns. This method is thread-safe.
+   *
+   * <p>
+   *   This method decrypts the input buf chunk-by-chunk and writes the
+   *   decrypted output back into the input buf. It uses two local buffers
+   *   taken from the {@link #bufferPool} to assist in this process: one is
+   *   designated as the input buffer and it stores a single chunk of the
+   *   given buf, the other is designated as the output buffer, which stores
+   *   the output of decrypting the input buffer. Both buffers are of size
+   *   {@link #bufferSize}.
+   * </p>
+   *
+   * <p>
+   *   Decryption is done by using a {@link Decryptor} and the
+   *   {@link #decrypt(Decryptor, ByteBuffer, ByteBuffer, byte)} method. Once
+   *   the decrypted data is written into the output buffer, is is copied back
+   *   into buf. Both buffers are returned back into the pool once the entire
+   *   buf is decrypted.
+   * </p>
+   *
+   * @param filePosition the current position of the file being read
+   * @param buf the {@link ByteBuffer} to decrypt
+   * @param length the number of bytes in {@code buf} to decrypt
+   * @param start the position in {@code buf} to start decrypting data from
+   */
+  private void decrypt(long filePosition, ByteBuffer buf, int length, int start)
+          throws IOException {
+    ByteBuffer localInBuffer = null;
+    ByteBuffer localOutBuffer = null;
+
+    // Duplicate the buffer so we don't have to worry about resetting the
+    // original position and limit at the end of the method
+    buf = buf.duplicate();
+
+    int decryptedBytes = 0;
+    Decryptor localDecryptor = null;
+    try {
+      localInBuffer = getBuffer();
+      localOutBuffer = getBuffer();
+      localDecryptor = getDecryptor();
+      byte[] localIV = initIV.clone();
+      updateDecryptor(localDecryptor, filePosition, localIV);
+      byte localPadding = getPadding(filePosition);
+      // Set proper filePosition for inputdata.
+      localInBuffer.position(localPadding);
+
+      while (decryptedBytes < length) {
+        buf.position(start + decryptedBytes);
+        buf.limit(start + decryptedBytes +
+                Math.min(length - decryptedBytes, localInBuffer.remaining()));
+        localInBuffer.put(buf);
+        // Do decryption
+        try {
+          decrypt(localDecryptor, localInBuffer, localOutBuffer, localPadding);
+          buf.position(start + decryptedBytes);
+          buf.limit(start + length);
+          decryptedBytes += localOutBuffer.remaining();
+          buf.put(localOutBuffer);
+        } finally {
+          localPadding = afterDecryption(localDecryptor, localInBuffer,
+                                         filePosition + length, localIV);
+        }
+      }
+    } finally {
+      returnBuffer(localInBuffer);
+      returnBuffer(localOutBuffer);
+      returnDecryptor(localDecryptor);
+    }
+  }
+
-    try {
-      ((PositionedReadable) in).readFully(position, buffer, offset, length);
-      if (length > 0) {
-        // This operation does not change the current offset of the file
-        decrypt(position, buffer, offset, length);
-      }
-    } catch (ClassCastException e) {
+    if (!(in instanceof PositionedReadable)) {
+    ((PositionedReadable) in).readFully(position, buffer, offset, length);
+    if (length > 0) {
+      // This operation does not change the current offset of the file
+      decrypt(position, buffer, offset, length);
+    }
-    try {
-      /*
-       * If data of target pos in the underlying stream has already been read 
-       * and decrypted in outBuffer, we just need to re-position outBuffer.
-       */
-      if (pos <= streamOffset && pos >= (streamOffset - outBuffer.remaining())) {
-        int forward = (int) (pos - (streamOffset - outBuffer.remaining()));
-        if (forward > 0) {
-          outBuffer.position(outBuffer.position() + forward);
-        }
-      } else {
-        ((Seekable) in).seek(pos);
-        resetStreamOffset(pos);
+    /*
+     * If data of target pos in the underlying stream has already been read
+     * and decrypted in outBuffer, we just need to re-position outBuffer.
+     */
+    if (pos <= streamOffset && pos >= (streamOffset - outBuffer.remaining())) {
+      int forward = (int) (pos - (streamOffset - outBuffer.remaining()));
+      if (forward > 0) {
+        outBuffer.position(outBuffer.position() + forward);
-    } catch (ClassCastException e) {
-      throw new UnsupportedOperationException("This stream does not support " +
-          "seek.");
+    } else {
+      if (!(in instanceof Seekable)) {
+        throw new UnsupportedOperationException("This stream does not " +
+                "support seek.");
+      }
+      ((Seekable) in).seek(pos);
+      resetStreamOffset(pos);
-   * Decrypt all data in buf: total n bytes from given start position.
-   * Output is also buf and same start position.
-   * buf.position() and buf.limit() should be unchanged after decryption.
+   * Decrypts the given {@link ByteBuffer} in place. {@code length} bytes are
+   * decrypted from {@code buf} starting at {@code start}.
+   * {@code buf.position()} and {@code buf.limit()} are unchanged after this
+   * method returns.
+   *
+   * @see #decrypt(long, ByteBuffer, int, int)
-  private void decrypt(ByteBuffer buf, int n, int start) 
+  private void decrypt(ByteBuffer buf, int length, int start)
-    final int pos = buf.position();
-    final int limit = buf.limit();
-    int len = 0;
-    while (len < n) {
-      buf.position(start + len);
-      buf.limit(start + len + Math.min(n - len, inBuffer.remaining()));
+    buf = buf.duplicate();
+    int decryptedBytes = 0;
+    while (decryptedBytes < length) {
+      buf.position(start + decryptedBytes);
+      buf.limit(start + decryptedBytes +
+              Math.min(length - decryptedBytes, inBuffer.remaining()));
-        buf.position(start + len);
-        buf.limit(limit);
-        len += outBuffer.remaining();
+        buf.position(start + decryptedBytes);
+        buf.limit(start + length);
+        decryptedBytes += outBuffer.remaining();
-        padding = afterDecryption(decryptor, inBuffer, streamOffset - (n - len), iv);
+        padding = afterDecryption(decryptor, inBuffer,
+                streamOffset - (length - decryptedBytes), iv);
-    buf.position(pos);
-    try {
-      boolean result = ((Seekable) in).seekToNewSource(targetPos);
-      resetStreamOffset(targetPos);
-      return result;
-    } catch (ClassCastException e) {
+    if (!(in instanceof Seekable)) {
+    boolean result = ((Seekable) in).seekToNewSource(targetPos);
+    resetStreamOffset(targetPos);
+    return result;
-    try {
-      if (outBuffer.remaining() > 0) {
-        // Have some decrypted data unread, need to reset.
-        ((Seekable) in).seek(getPos());
-        resetStreamOffset(getPos());
+    if (outBuffer.remaining() > 0) {
+      if (!(in instanceof Seekable)) {
+        throw new UnsupportedOperationException("This stream does not " +
+                "support seek.");
-      final ByteBuffer buffer = ((HasEnhancedByteBufferAccess) in).
-          read(bufferPool, maxLength, opts);
-      if (buffer != null) {
-        final int n = buffer.remaining();
-        if (n > 0) {
-          streamOffset += buffer.remaining(); // Read n bytes
-          final int pos = buffer.position();
-          decrypt(buffer, n, pos);
-        }
-      }
-      return buffer;
-    } catch (ClassCastException e) {
-      throw new UnsupportedOperationException("This stream does not support " + 
+      // Have some decrypted data unread, need to reset.
+      ((Seekable) in).seek(getPos());
+      resetStreamOffset(getPos());
+    }
+    if (!(in instanceof HasEnhancedByteBufferAccess)) {
+      throw new UnsupportedOperationException("This stream does not support " +
+    final ByteBuffer buffer = ((HasEnhancedByteBufferAccess) in).
+        read(bufferPool, maxLength, opts);
+    if (buffer != null) {
+      final int n = buffer.remaining();
+      if (n > 0) {
+        streamOffset += buffer.remaining(); // Read n bytes
+        final int pos = buffer.position();
+        decrypt(buffer, n, pos);
+      }
+    }
+    return buffer;
-    try {
-      ((HasEnhancedByteBufferAccess) in).releaseBuffer(buffer);
-    } catch (ClassCastException e) {
+    if (!(in instanceof HasEnhancedByteBufferAccess)) {
+    ((HasEnhancedByteBufferAccess) in).releaseBuffer(buffer);
-    try {
-      ((CanSetReadahead) in).setReadahead(readahead);
-    } catch (ClassCastException e) {
+    if (!(in instanceof CanSetReadahead)) {
+    ((CanSetReadahead) in).setReadahead(readahead);
-    try {
-      ((CanSetDropBehind) in).setDropBehind(dropCache);
-    } catch (ClassCastException e) {
+    if (!(in instanceof CanSetReadahead)) {
+    ((CanSetDropBehind) in).setDropBehind(dropCache);
+    case StreamCapabilities.UNBUFFER:
+      return true;
-    case StreamCapabilities.UNBUFFER:
-      return true;
+    case StreamCapabilities.PREADBYTEBUFFER:
+      if (!(in instanceof StreamCapabilities)) {
+        throw new UnsupportedOperationException("This stream does not expose " +
+          "its stream capabilities.");
+      }
+      return ((StreamCapabilities) in).hasCapability(capability);

INS26 INS40 INS43 INS31 INS31 INS42 MOV8 INS29 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 INS8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV21 INS25 INS65 INS42 INS39 INS42 INS83 INS43 INS42 INS42 INS21 INS25 MOV60 INS60 INS25 INS41 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS60 INS60 INS21 INS60 INS60 INS54 MOV21 INS25 MOV25 MOV21 INS65 UPD42 INS21 MOV21 MOV21 INS25 MOV21 INS25 INS25 INS25 INS25 MOV49 MOV41 INS38 MOV8 INS66 INS65 INS66 INS42 INS32 INS38 INS8 INS83 INS39 INS59 INS27 INS8 INS42 MOV43 MOV43 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS65 INS66 INS42 INS43 INS59 INS43 INS59 INS7 INS39 INS59 INS43 INS59 INS8 INS8 INS38 MOV8 UPD66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 UPD66 INS66 INS68 INS7 INS38 MOV8 INS38 MOV8 INS38 MOV8 INS38 MOV8 INS38 MOV8 INS25 INS41 INS49 INS36 INS42 INS42 INS36 INS53 UPD42 INS42 INS32 INS42 INS34 INS21 UPD42 INS33 UPD42 INS33 INS21 INS21 INS42 INS66 INS66 INS66 INS66 INS66 INS67 INS67 INS42 INS68 INS42 INS66 INS66 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS32 INS42 INS34 INS42 INS42 INS33 INS21 INS21 INS21 INS60 INS21 INS60 INS21 INS61 INS21 INS21 INS21 INS36 INS25 INS42 INS66 INS66 INS66 UPD66 MOV66 INS66 INS42 INS69 INS69 INS69 INS69 INS42 INS32 UPD42 UPD42 UPD42 INS36 INS25 INS36 INS36 INS36 INS36 INS40 INS38 INS8 INS32 INS62 INS62 INS14 INS36 INS42 INS42 INS42 INS32 INS7 INS7 INS42 INS42 INS42 INS69 INS69 INS69 INS69 INS42 INS42 INS7 INS7 INS7 INS5 INS59 INS32 INS39 INS59 INS32 INS27 INS8 INS32 INS32 INS32 INS62 INS38 INS8 INS39 INS43 INS39 INS39 MOV42 UPD42 MOV42 INS62 INS38 INS8 INS62 INS62 INS62 INS62 INS36 INS53 INS36 INS42 INS42 INS42 INS43 INS42 INS43 MOV43 INS27 INS11 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 MOV32 UPD42 UPD42 UPD42 INS43 INS43 INS43 INS39 INS42 INS32 INS42 INS32 INS42 INS32 INS39 INS85 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS21 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS36 INS53 INS42 INS42 INS43 INS36 INS53 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS62 INS14 INS11 INS42 INS42 INS45 INS45 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS8 INS8 INS42 INS62 INS14 UPD42 UPD42 INS42 INS62 INS14 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS27 INS43 INS42 INS42 UPD42 MOV27 UPD42 UPD42 UPD42 MOV27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS43 INS43 INS27 INS27 UPD42 INS42 INS43 INS43 INS27 INS42 INS42 INS45 INS45 INS42 UPD42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS7 INS32 INS7 INS42 INS42 INS45 INS45 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS45 INS45 UPD42 INS42 INS42 INS27 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 UPD42 UPD42 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL83 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL83 DEL39 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8
HDFS-4103. Support O(1) snapshot creation.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1424782 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.common.base.Preconditions;
-  static public INodeDirectorySnapshottable newInstance(
-      final INodeDirectory dir, final int snapshotQuota) {
-    return new INodeDirectorySnapshottable(dir, snapshotQuota);
-  }
+  /** Limit the number of snapshot per snapshottable directory. */
+  static final int SNAPSHOT_LIMIT = 1 << 16;
-  /** Snapshots of this directory in ascending order of snapshot id. */
-  private final List<Snapshot> snapshots = new ArrayList<Snapshot>();
-  /** Snapshots of this directory in ascending order of snapshot names. */
-  private final List<Snapshot> snapshotsByNames = new ArrayList<Snapshot>();
-  
-   * @return {@link #snapshots}
+   * Snapshots of this directory in ascending order of snapshot names.
+   * Note that snapshots in ascending order of snapshot id are stored in
+   * {@link INodeDirectoryWithSnapshot}.diffs (a private field).
-  @VisibleForTesting
-  List<Snapshot> getSnapshots() {
-    return snapshots;
-  }
+  private final List<Snapshot> snapshotsByNames = new ArrayList<Snapshot>();
-  private int snapshotQuota;
+  private int snapshotQuota = SNAPSHOT_LIMIT;
-  private INodeDirectorySnapshottable(INodeDirectory dir,
-      final int snapshotQuota) {
-    super(dir, true);
-    setSnapshotQuota(snapshotQuota);
+  public INodeDirectorySnapshottable(INodeDirectory dir) {
+    super(dir, true, null);
+  /** @return the number of existing snapshots. */
-    return snapshots.size();
+    return getSnapshotsByNames().size();
-      INodeDirectoryWithSnapshot ssRoot = snapshot.getRoot();
+      final INodeDirectory ssRoot = snapshot.getRoot();
-  /** @return the last snapshot. */
-  public Snapshot getLastSnapshot() {
-    final int n = snapshots.size();
-    return n == 0? null: snapshots.get(n - 1);
-  }
-
-    if (snapshots.size() + 1 > snapshotQuota) {
+    final int n = getNumSnapshots();
+    if (n + 1 > snapshotQuota) {
-          + snapshots.size() + " snapshot(s) and the snapshot quota is "
+          + n + " snapshot(s) and the snapshot quota is "
-    snapshots.add(s);
+    addSnapshotDiff(s, this, true);
-    s.getRoot().updateModificationTime(timestamp);
-    updateModificationTime(timestamp);
+    s.getRoot().updateModificationTime(timestamp, null);
+    updateModificationTime(timestamp, null);
-  
+
+  /**
+   * Replace itself with {@link INodeDirectoryWithSnapshot} or
+   * {@link INodeDirectory} depending on the latest snapshot.
+   */
+  void replaceSelf(final Snapshot latest) {
+    if (latest == null) {
+      Preconditions.checkState(getLastSnapshot() == null,
+          "latest == null but getLastSnapshot() != null, this=%s", this);
+      replaceSelf4INodeDirectory();
+    } else {
+      replaceSelf4INodeDirectoryWithSnapshot(latest).recordModification(latest);
+    }
+  }
+
-  public void dumpTreeRecursively(PrintWriter out, StringBuilder prefix) {
-    super.dumpTreeRecursively(out, prefix);
+  public void dumpTreeRecursively(PrintWriter out, StringBuilder prefix,
+      Snapshot snapshot) {
+    super.dumpTreeRecursively(out, prefix, snapshot);
-    out.print(prefix);
-    out.print(snapshots.size());
-    out.print(snapshots.size() <= 1 ? " snapshot of " : " snapshots of ");
-    out.println(getLocalName());
-
-    dumpTreeRecursively(out, prefix, new Iterable<INodeDirectoryWithSnapshot>() {
-      @Override
-      public Iterator<INodeDirectoryWithSnapshot> iterator() {
-        return new Iterator<INodeDirectoryWithSnapshot>() {
-          final Iterator<Snapshot> i = snapshots.iterator();
-
-          @Override
-          public boolean hasNext() {
-            return i.hasNext();
-          }
-
-          @Override
-          public INodeDirectoryWithSnapshot next() {
-            return i.next().getRoot();
-          }
-
-          @Override
-          public void remove() {
-            throw new UnsupportedOperationException();
-          }
-        };
+    try {
+    if (snapshot == null) {
+      out.println();
+      out.print(prefix);
+      int n = 0;
+      for(SnapshotDiff diff : getSnapshotDiffs()) {
+        if (diff.isSnapshotRoot()) {
+          n++;
+        }
-    });
+      out.print(n);
+      out.print(n <= 1 ? " snapshot of " : " snapshots of ");
+      final String name = getLocalName();
+      out.println(name.isEmpty()? "/": name);
+
+      dumpTreeRecursively(out, prefix, new Iterable<Pair<? extends INode, Snapshot>>() {
+        @Override
+        public Iterator<Pair<? extends INode, Snapshot>> iterator() {
+          return new Iterator<Pair<? extends INode, Snapshot>>() {
+            final Iterator<SnapshotDiff> i = getSnapshotDiffs().iterator();
+            private SnapshotDiff next = findNext();
+  
+            private SnapshotDiff findNext() {
+              for(; i.hasNext(); ) {
+                final SnapshotDiff diff = i.next();
+                if (diff.isSnapshotRoot()) {
+                  return diff;
+                }
+              }
+              return null;
+            }
+
+            @Override
+            public boolean hasNext() {
+              return next != null;
+            }
+  
+            @Override
+            public Pair<INodeDirectory, Snapshot> next() {
+              final Snapshot s = next.snapshot;
+              final Pair<INodeDirectory, Snapshot> pair =
+                  new Pair<INodeDirectory, Snapshot>(s.getRoot(), s);
+              next = findNext();
+              return pair;
+            }
+  
+            @Override
+            public void remove() {
+              throw new UnsupportedOperationException();
+            }
+          };
+        }
+      });
+    }
+    } catch(Exception e) {
+      throw new RuntimeException("this=" + this, e);
+    }

INS26 MOV31 MOV31 INS40 UPD83 INS39 UPD83 INS29 INS39 INS42 INS44 INS44 UPD42 INS27 INS42 INS65 INS60 UPD65 INS83 MOV43 INS42 INS25 INS43 INS42 INS54 UPD66 INS34 INS34 UPD66 INS66 INS65 INS66 INS33 INS66 INS83 INS39 INS59 INS66 INS65 INS66 INS65 UPD66 INS27 INS8 INS8 INS42 INS8 INS12 INS42 INS32 INS42 INS32 UPD42 INS52 INS9 INS33 INS33 INS42 INS42 INS42 INS33 INS21 INS21 INS21 INS42 INS25 INS44 INS8 UPD42 MOV42 INS83 MOV43 INS42 INS42 INS32 INS32 INS32 INS27 INS8 INS43 INS42 INS53 UPD42 MOV42 UPD42 MOV42 INS27 INS45 INS52 INS42 INS32 INS42 INS42 INS42 INS33 INS21 MOV21 INS60 INS70 MOV21 MOV21 INS60 MOV21 MOV21 INS42 INS14 INS42 INS32 INS33 UPD42 MOV42 UPD42 MOV42 INS32 INS39 INS59 INS44 INS32 INS8 INS83 INS43 INS59 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS34 INS43 INS42 INS42 INS25 UPD42 MOV42 INS42 INS42 MOV32 INS16 INS42 INS45 INS52 INS42 INS32 INS8 INS32 INS45 INS42 UPD74 INS42 INS42 INS21 INS42 INS42 INS42 INS74 INS37 INS43 INS76 MOV43 INS74 INS42 INS42 INS43 MOV43 INS74 UPD42 MOV42 INS43 INS76 INS43 INS42 INS43 INS42 UPD74 INS42 INS74 INS23 INS31 INS43 INS76 UPD43 MOV43 UPD74 MOV74 INS83 INS43 INS59 INS83 INS43 INS42 INS8 MOV78 MOV78 INS74 INS42 INS43 UPD42 UPD43 INS42 INS42 INS32 INS42 INS24 INS41 INS43 INS43 INS43 INS60 INS60 INS21 INS41 INS42 UPD42 INS32 INS42 MOV32 INS8 INS33 INS27 INS42 UPD42 MOV42 INS42 INS83 MOV43 INS59 INS83 INS74 INS59 INS7 INS42 UPD42 MOV42 INS60 INS25 INS42 INS33 INS42 INS40 INS43 INS43 INS43 INS42 INS14 INS42 INS32 INS83 INS43 INS59 INS32 INS8 INS42 INS42 INS42 INS74 INS32 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS41 INS43 INS43 INS43 INS42 MOV42 INS42 INS42 INS42 INS42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL14 DEL66 DEL42 DEL67 DEL65 DEL65 DEL29 DEL42 DEL78 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL83 DEL42 DEL83 DEL39 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL33 DEL42 DEL34 DEL27 DEL32 DEL16 DEL41 DEL42 DEL32 DEL42 DEL42 DEL32 DEL43 DEL74 DEL43 DEL32 DEL41
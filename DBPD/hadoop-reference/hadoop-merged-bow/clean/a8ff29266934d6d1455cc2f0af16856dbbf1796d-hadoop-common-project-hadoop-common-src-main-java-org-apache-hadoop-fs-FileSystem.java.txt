Merge trunk into HDFS-3077 branch.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1377092 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.fs.Options.ChecksumOpt;
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.util.DataChecksum;
+import com.google.common.annotations.VisibleForTesting;
+
-   * the only user of this value, and uses it to lookup this filesystem's
-   * service tokens.  The token cache will not attempt to acquire tokens if the
-   * service is null.
+   * the only user of the canonical service name, and uses it to lookup this
+   * filesystem's service tokens.
+   * If file system provides a token of its own then it must have a canonical
+   * name, otherwise canonical name can be null.
+   * 
+   * Default Impl: If the file system has child file systems 
+   * (such as an embedded file system) then it is assumed that the fs has no
+   * tokens of its own and hence returns a null name; otherwise a service
+   * name is built using Uri and port.
+   * 
+  @InterfaceAudience.LimitedPrivate({ "HDFS", "MapReduce" })
-    return SecurityUtil.buildDTServiceName(getUri(), getDefaultPort());
+    return (getChildFileSystems() == null)
+      ? SecurityUtil.buildDTServiceName(getUri(), getDefaultPort())
+      : null;
-   * Deprecated  - use @link {@link #getDelegationTokens(String)}
+   * This is an internal method that should have been declared protected
+   * but wasn't historically.
+   * Callers should use {@link #addDelegationTokens(String, Credentials)}
+   * 
-  @InterfaceAudience.LimitedPrivate({"HDFS", "MapReduce"})
-  @Deprecated
+  @InterfaceAudience.Private()
-   * Get one or more delegation tokens associated with the filesystem. Normally
-   * a file system returns a single delegation token. A file system that manages
-   * multiple file systems underneath, could return set of delegation tokens for
-   * all the file systems it manages.
+   * Obtain all delegation tokens used by this FileSystem that are not
+   * already present in the given Credentials.  Existing tokens will neither
+   * be verified as valid nor having the given renewer.  Missing tokens will
+   * be acquired and added to the given Credentials.
-   * @param renewer the account name that is allowed to renew the token.
+   * Default Impl: works for simple fs with its own token
+   * and also for an embedded fs whose tokens are those of its
+   * children file system (i.e. the embedded fs has not tokens of its
+   * own).
+   * 
+   * @param renewer the user allowed to renew the delegation tokens
+   * @param credentials cache in which to add new delegation tokens
-   *    If delegation tokens not supported then return a list of size zero.
-   * @throws IOException
-   */
-  @InterfaceAudience.LimitedPrivate( { "HDFS", "MapReduce" })
-  public List<Token<?>> getDelegationTokens(String renewer) throws IOException {
-    return new ArrayList<Token<?>>(0);
-  }
-  
-  /**
-   * @see #getDelegationTokens(String)
-   * This is similar to getDelegationTokens, with the added restriction that if
-   * a token is already present in the passed Credentials object - that token
-   * is returned instead of a new delegation token. 
-   * 
-   * If the token is found to be cached in the Credentials object, this API does
-   * not verify the token validity or the passed in renewer. 
-   * 
-   * 
-   * @param renewer the account name that is allowed to renew the token.
-   * @param credentials a Credentials object containing already knowing 
-   *   delegationTokens.
-   * @return a list of delegation tokens.
-  public List<Token<?>> getDelegationTokens(String renewer,
-      Credentials credentials) throws IOException {
-    List<Token<?>> allTokens = getDelegationTokens(renewer);
-    List<Token<?>> newTokens = new ArrayList<Token<?>>();
-    if (allTokens != null) {
-      for (Token<?> token : allTokens) {
-        Token<?> knownToken = credentials.getToken(token.getService());
-        if (knownToken == null) {
-          newTokens.add(token);
-        } else {
-          newTokens.add(knownToken);
+  public Token<?>[] addDelegationTokens(
+      final String renewer, Credentials credentials) throws IOException {
+    if (credentials == null) {
+      credentials = new Credentials();
+    }
+    final List<Token<?>> tokens = new ArrayList<Token<?>>();
+    collectDelegationTokens(renewer, credentials, tokens);
+    return tokens.toArray(new Token<?>[tokens.size()]);
+  }
+  
+  /**
+   * Recursively obtain the tokens for this FileSystem and all descended
+   * FileSystems as determined by getChildFileSystems().
+   * @param renewer the user allowed to renew the delegation tokens
+   * @param credentials cache in which to add the new delegation tokens
+   * @param tokens list in which to add acquired tokens
+   * @throws IOException
+   */
+  private void collectDelegationTokens(final String renewer,
+                                       final Credentials credentials,
+                                       final List<Token<?>> tokens)
+                                           throws IOException {
+    final String serviceName = getCanonicalServiceName();
+    // Collect token of the this filesystem and then of its embedded children
+    if (serviceName != null) { // fs has token, grab it
+      final Text service = new Text(serviceName);
+      Token<?> token = credentials.getToken(service);
+      if (token == null) {
+        token = getDelegationToken(renewer);
+        if (token != null) {
+          tokens.add(token);
+          credentials.addToken(service, token);
-    return newTokens;
+    // Now collect the tokens from the children
+    final FileSystem[] children = getChildFileSystems();
+    if (children != null) {
+      for (final FileSystem fs : children) {
+        fs.collectDelegationTokens(renewer, credentials, tokens);
+      }
+    }
+  /**
+   * Get all the immediate child FileSystems embedded in this FileSystem.
+   * It does not recurse and get grand children.  If a FileSystem
+   * has multiple child FileSystems, then it should return a unique list
+   * of those FileSystems.  Default is to return null to signify no children.
+   * 
+   * @return FileSystems used by this FileSystem
+   */
+  @InterfaceAudience.LimitedPrivate({ "HDFS" })
+  @VisibleForTesting
+  public FileSystem[] getChildFileSystems() {
+    return null;
+  }
+  
+    // CRC32 is chosen as default as it is available in all 
+    // releases that support checksum.
+    // The client trash configuration is ignored.
-        false);
+        false,
+        CommonConfigurationKeysPublic.FS_TRASH_INTERVAL_DEFAULT,
+        DataChecksum.Type.CRC32);
-    // only DFS support this
-    return create(f, permission, flags.contains(CreateFlag.OVERWRITE), bufferSize, replication, blockSize, progress);
+    return create(f, permission, flags, bufferSize, replication,
+        blockSize, progress, null);
-  
+  /**
+   * Create an FSDataOutputStream at the indicated Path with a custom
+   * checksum option
+   * @param f the file name to open
+   * @param permission
+   * @param flags {@link CreateFlag}s to use for this stream.
+   * @param bufferSize the size of the buffer to be used.
+   * @param replication required block replication for the file.
+   * @param blockSize
+   * @param progress
+   * @param checksumOpt checksum parameter. If null, the values
+   *        found in conf will be used.
+   * @throws IOException
+   * @see #setPermission(Path, FsPermission)
+   */
+  public FSDataOutputStream create(Path f,
+      FsPermission permission,
+      EnumSet<CreateFlag> flags,
+      int bufferSize,
+      short replication,
+      long blockSize,
+      Progressable progress,
+      ChecksumOpt checksumOpt) throws IOException {
+    // Checksum options are ignored by default. The file systems that
+    // implement checksum need to override this method. The full
+    // support is currently only available in DFS.
+    return create(f, permission, flags.contains(CreateFlag.OVERWRITE), 
+        bufferSize, replication, blockSize, progress);
+  }
+
-     int bytesPerChecksum) throws IOException {
+     ChecksumOpt checksumOpt) throws IOException {
-        results = listStatus(parentPaths, fp);
+        try {
+          results = listStatus(parentPaths, fp);
+        } catch (FileNotFoundException e) {
+          results = null;
+        }
-      parents = FileUtil.stat2Paths(listStatus(parents, fp));
+      try {
+        parents = FileUtil.stat2Paths(listStatus(parents, fp));
+      } catch (FileNotFoundException e) {
+        parents = null;
+      }

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS31 MOV79 INS77 MOV79 INS5 UPD42 MOV44 MOV43 INS8 UPD83 INS39 UPD42 INS44 INS44 MOV43 INS8 INS29 INS79 INS78 INS83 INS5 INS42 INS8 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 MOV8 MOV65 INS40 INS65 MOV65 MOV74 INS85 INS83 INS25 MOV60 INS21 INS41 UPD65 UPD65 MOV65 INS83 INS83 INS43 INS42 INS83 MOV74 INS42 INS60 MOV25 INS60 INS25 INS65 INS65 INS40 INS4 INS42 INS43 INS85 INS41 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS42 INS43 INS42 UPD66 UPD66 INS66 INS66 INS66 INS66 UPD66 INS66 INS16 INS66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 INS66 UPD66 INS66 UPD66 INS66 UPD66 INS42 INS66 INS27 INS8 INS83 INS32 INS32 UPD66 UPD66 UPD66 UPD66 INS42 UPD66 UPD42 MOV42 INS83 INS43 MOV59 INS83 INS5 INS59 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS45 INS42 INS33 INS32 INS66 INS66 INS42 INS66 INS42 INS42 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS66 INS66 INS42 INS68 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS8 INS36 MOV32 INS33 INS42 INS33 INS21 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS3 UPD42 MOV42 UPD42 UPD42 INS60 MOV60 MOV25 INS43 INS85 INS42 INS32 INS42 INS33 INS70 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS69 INS69 INS42 INS42 INS54 MOV21 INS27 UPD42 INS69 INS7 INS5 INS32 UPD42 INS83 INS43 INS59 INS8 INS42 INS42 INS44 INS42 INS8 INS43 INS43 INS8 MOV8 INS12 INS32 INS33 INS43 INS42 INS14 MOV74 INS85 INS42 INS42 INS42 INS42 INS14 UPD42 UPD42 INS21 INS25 INS83 INS43 INS42 INS21 INS42 INS42 INS54 MOV21 INS44 INS8 INS42 INS42 INS43 INS43 INS42 UPD42 MOV42 INS7 INS27 INS8 INS42 INS32 MOV8 INS12 INS43 INS42 INS21 UPD42 MOV42 INS42 INS42 INS32 INS42 INS33 MOV21 MOV21 INS42 INS42 INS42 INS42 INS42 INS44 INS8 INS42 INS7 INS42 INS42 INS43 INS42 INS21 INS42 INS33 UPD42 UPD42 UPD42 INS42 UPD42 INS42 INS7 INS42 INS33 DEL42 DEL78 DEL66 DEL40 DEL45 DEL45 DEL4 DEL79 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL74 DEL43 DEL74 DEL34 DEL14 DEL41 DEL8 DEL42 DEL42 DEL43 DEL69 DEL68 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL32 DEL8 DEL8 DEL42 DEL44 DEL42 DEL8 DEL70 DEL43 DEL43 DEL76 DEL74 DEL74 DEL60 DEL42 DEL41 DEL8 DEL39 DEL42
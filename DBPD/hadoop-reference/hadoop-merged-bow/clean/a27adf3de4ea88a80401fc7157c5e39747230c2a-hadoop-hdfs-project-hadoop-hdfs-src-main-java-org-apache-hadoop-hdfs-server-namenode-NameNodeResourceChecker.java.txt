HDFS-2430. The number of failed or low-resource volumes the NN can tolerate should be configurable. Contributed by Aaron T. Myers


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1211650 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.classification.InterfaceAudience;
- * the NameNode has disk space available on all volumes which are configured to
- * be checked. Volumes containing file system name/edits dirs are added by
- * default, and arbitrary extra volumes may be configured as well.
+ * the NameNode has disk space available on all required volumes, and any volume
+ * which is configured to be redundant. Volumes containing file system edits dirs
+ * are added by default, and arbitrary extra volumes may be configured as well.
-public class NameNodeResourceChecker {
+@InterfaceAudience.Private
+class NameNodeResourceChecker {
-  private Map<String, DF> volumes;
+  private Map<String, CheckedVolume> volumes;
+  private int minimumRedundantVolumes;
+  
+  @VisibleForTesting
+  class CheckedVolume implements CheckableNameNodeResource {
+    private DF df;
+    private boolean required;
+    private String volume;
+    
+    public CheckedVolume(File dirToCheck, boolean required)
+        throws IOException {
+      df = new DF(dirToCheck, conf);
+      this.required = required;
+      volume = df.getFilesystem();
+    }
+    
+    public String getVolume() {
+      return volume;
+    }
+    
+    @Override
+    public boolean isRequired() {
+      return required;
+    }
+
+    @Override
+    public boolean isResourceAvailable() {
+      long availableSpace = df.getAvailable();
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Space available on volume '" + volume + "' is "
+            + availableSpace);
+      }
+      if (availableSpace < duReserved) {
+        LOG.warn("Space available on volume '" + volume + "' is "
+            + availableSpace +
+            ", which is below the configured reserved amount " + duReserved);
+        return false;
+      } else {
+        return true;
+      }
+    }
+    
+    @Override
+    public String toString() {
+      return "volume: " + volume + " required: " + required +
+          " resource available: " + isResourceAvailable();
+    }
+  }
-   * Create a NameNodeResourceChecker, which will check the name dirs and edits
-   * dirs set in <code>conf</code>.
-   * 
-   * @param conf
-   * @throws IOException
+   * Create a NameNodeResourceChecker, which will check the edits dirs and any
+   * additional dirs to check set in <code>conf</code>.
-    volumes = new HashMap<String, DF>();
+    volumes = new HashMap<String, CheckedVolume>();
-  
+    
-
-    addDirsToCheck(FSNamesystem.getNamespaceDirs(conf));
-    addDirsToCheck(localEditDirs);
-    addDirsToCheck(extraCheckedVolumes);
+
+    // Add all the local edits dirs, marking some as required if they are
+    // configured as such.
+    for (URI editsDirToCheck : localEditDirs) {
+      addDirToCheck(editsDirToCheck,
+          FSNamesystem.getRequiredNamespaceEditsDirs(conf).contains(
+              editsDirToCheck));
+    }
+
+    // All extra checked volumes are marked "required"
+    for (URI extraDirToCheck : extraCheckedVolumes) {
+      addDirToCheck(extraDirToCheck, true);
+    }
+    
+    minimumRedundantVolumes = conf.getInt(
+        DFSConfigKeys.DFS_NAMENODE_CHECKED_VOLUMES_MINIMUM_KEY,
+        DFSConfigKeys.DFS_NAMENODE_CHECKED_VOLUMES_MINIMUM_DEFAULT);
-   * Add the passed-in directories to the list of volumes to check.
+   * Add the volume of the passed-in directory to the list of volumes to check.
+   * If <code>required</code> is true, and this volume is already present, but
+   * is marked redundant, it will be marked required. If the volume is already
+   * present but marked required then this method is a no-op.
-   * @param directoriesToCheck
-   *          The directories whose volumes will be checked for available space.
-   * @throws IOException
+   * @param directoryToCheck
+   *          The directory whose volume will be checked for available space.
-  private void addDirsToCheck(Collection<URI> directoriesToCheck)
+  private void addDirToCheck(URI directoryToCheck, boolean required)
-    for (URI directoryUri : directoriesToCheck) {
-      File dir = new File(directoryUri.getPath());
-      if (!dir.exists()) {
-        throw new IOException("Missing directory "+dir.getAbsolutePath());
-      }
-      DF df = new DF(dir, conf);
-      volumes.put(df.getFilesystem(), df);
+    File dir = new File(directoryToCheck.getPath());
+    if (!dir.exists()) {
+      throw new IOException("Missing directory "+dir.getAbsolutePath());
+    }
+    
+    CheckedVolume newVolume = new CheckedVolume(dir, required);
+    CheckedVolume volume = volumes.get(newVolume.getVolume());
+    if (volume == null || (volume != null && !volume.isRequired())) {
+      volumes.put(newVolume.getVolume(), newVolume);
-   * volumes.
+   * redundant volumes, and all of the configured required volumes.
-   *         least one volume, false otherwise.
-   * @throws IOException
+   *         least one redundant volume and all of the required volumes, false
+   *         otherwise.
-    return getVolumesLowOnSpace().size() < volumes.size();
+    return NameNodeResourcePolicy.areResourcesAvailable(volumes.values(),
+        minimumRedundantVolumes);
+   * 
-   * @throws IOException 
+  @VisibleForTesting
-    for (DF volume : volumes.values()) {
-      long availableSpace = volume.getAvailable();
-      String fileSystem = volume.getFilesystem();
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Space available on volume '" + fileSystem + "' is " + availableSpace);
-      }
-      if (availableSpace < duReserved) {
-        LOG.warn("Space available on volume '" + fileSystem + "' is "
-            + availableSpace +
-            ", which is below the configured reserved amount " + duReserved);
-        lowVolumes.add(volume.getFilesystem());
-      }
+    for (CheckedVolume volume : volumes.values()) {
+      lowVolumes.add(volume.getVolume());
-  void setVolumes(Map<String, DF> volumes) {
+  void setVolumes(Map<String, CheckedVolume> volumes) {
+  
+  @VisibleForTesting
+  void setMinimumReduntdantVolumes(int minimumRedundantVolumes) {
+    this.minimumRedundantVolumes = minimumRedundantVolumes;
+  }

INS26 INS40 INS78 INS42 INS23 INS55 INS31 INS40 UPD74 INS83 INS39 INS59 INS78 INS42 INS43 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 UPD42 INS44 INS8 INS78 INS78 INS39 INS42 INS44 INS8 UPD66 UPD66 UPD66 UPD43 INS42 INS42 INS42 INS83 MOV43 INS59 INS83 INS39 INS59 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS43 INS8 INS83 MOV43 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS70 INS70 INS43 UPD42 INS39 UPD42 MOV42 MOV60 MOV25 MOV60 INS60 INS25 INS42 UPD74 INS42 INS39 INS42 INS21 UPD42 INS42 INS42 INS42 INS42 MOV43 INS42 INS39 INS42 INS42 INS21 INS21 MOV21 INS41 INS42 INS41 INS42 INS60 INS25 INS25 INS42 INS42 INS41 UPD66 UPD66 INS44 INS42 INS8 INS44 INS42 INS8 INS7 UPD66 INS66 INS66 INS66 UPD42 UPD66 MOV42 MOV43 INS43 INS43 INS59 INS27 INS8 UPD66 INS66 UPD66 INS32 INS8 UPD43 INS7 INS7 INS7 INS7 INS42 INS42 INS39 INS59 MOV32 INS8 MOV27 INS8 INS8 INS27 MOV43 INS42 MOV21 MOV43 INS42 MOV21 INS42 INS32 INS42 UPD42 INS42 INS42 INS32 INS27 INS36 INS21 UPD42 MOV42 UPD42 MOV42 INS32 INS42 UPD43 MOV21 UPD42 INS22 INS42 INS42 INS14 INS22 INS42 INS42 MOV32 INS42 INS32 INS21 INS21 INS41 INS41 INS45 INS42 INS45 INS42 INS45 INS32 UPD74 INS42 UPD42 MOV42 UPD42 MOV42 INS40 INS40 INS43 UPD43 UPD42 INS42 INS42 INS32 INS42 INS33 INS27 INS32 MOV42 UPD42 MOV42 UPD42 INS52 INS42 MOV43 INS42 INS42 INS52 INS42 INS42 INS42 INS32 INS32 INS9 INS9 INS42 INS43 UPD42 INS42 INS32 UPD42 UPD42 INS9 INS42 UPD42 UPD42 INS42 INS42 INS27 INS38 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 MOV32 INS42 INS42 INS42 INS33 INS32 INS42 INS42 UPD42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 UPD42 INS42 INS42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL65 DEL42 DEL65 DEL32 DEL42 DEL65 DEL42 DEL43 DEL74 DEL44 DEL42 DEL8 DEL70 DEL8 DEL42 DEL65 DEL32 DEL32 DEL32 DEL27 DEL42 DEL66 DEL65 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8
HADOOP-12747. support wildcard in libjars argument (sjlee)

+import java.io.File;
+import org.apache.hadoop.fs.FileUtil;
-    parseGeneralOptions(options, conf, args);
+    parseGeneralOptions(options, args);
-   * Modify configuration according user-specified generic options
-   * @param conf Configuration to be modified
+   * Modify configuration according user-specified generic options.
+   *
-  private void processGeneralOptions(Configuration conf,
-      CommandLine line) throws IOException {
+  private void processGeneralOptions(CommandLine line) throws IOException {
-      conf.set("tmpjars", 
-               validateFiles(line.getOptionValue("libjars"), conf),
+      // for libjars, we allow expansion of wildcards
+      conf.set("tmpjars",
+               validateFiles(line.getOptionValue("libjars"), true),
-               validateFiles(line.getOptionValue("files"), conf),
+               validateFiles(line.getOptionValue("files")),
-                validateFiles(line.getOptionValue("archives"), conf),
+                validateFiles(line.getOptionValue("archives")),
-    if(jars==null) {
+    if (jars == null || jars.trim().isEmpty()) {
-          "filesystem. Ignoring.");
+            "filesystem. It will not be added to the local classpath.");
-   * file:///home/user/file1,file:///home/user/file2
-   * @param files
-   * @return
+   * file:///home/user/file1,file:///home/user/file2.
+   *
+   * This method does not recognize wildcards.
+   *
+   * @param files the input files argument
+   * @return a comma-separated list of validated and qualified paths, or null
+   * if the input files argument is null
-  private String validateFiles(String files, Configuration conf) 
-      throws IOException  {
-    if (files == null) 
+  private String validateFiles(String files) throws IOException {
+    return validateFiles(files, false);
+  }
+
+  /**
+   * takes input as a comma separated list of files
+   * and verifies if they exist. It defaults for file:///
+   * if the files specified do not have a scheme.
+   * it returns the paths uri converted defaulting to file:///.
+   * So an input of  /home/user/file1,/home/user/file2 would return
+   * file:///home/user/file1,file:///home/user/file2.
+   *
+   * @param files the input files argument
+   * @param expandWildcard whether a wildcard entry is allowed and expanded. If
+   * true, any directory followed by a wildcard is a valid entry and is replaced
+   * with the list of jars in that directory. It is used to support the wildcard
+   * notation in a classpath.
+   * @return a comma-separated list of validated and qualified paths, or null
+   * if the input files argument is null
+   */
+  private String validateFiles(String files, boolean expandWildcard)
+      throws IOException {
+    if (files == null) {
+    }
-    String[] finalArr = new String[fileArr.length];
+    List<String> finalPaths = new ArrayList<>(fileArr.length);
-      String finalPath;
+      final String wildcard = "*";
+      boolean isWildcard = tmp.endsWith(wildcard) && expandWildcard;
-        pathURI = new URI(tmp);
+        if (isWildcard) {
+          // strip the wildcard
+          tmp = tmp.substring(0, tmp.length() - 1);
+        }
+        // handle the case where a wildcard alone ("*") or the wildcard on the
+        // current directory ("./*") is specified
+        pathURI = matchesCurrentDirectory(tmp) ?
+            new File(Path.CUR_DIR).toURI() :
+            new URI(tmp);
-        finalPath = path.makeQualified(localFs.getUri(),
-            localFs.getWorkingDirectory()).toString();
-      }
-      else {
+        if (isWildcard) {
+          expandWildcard(finalPaths, path, localFs);
+        } else {
+          finalPaths.add(path.makeQualified(localFs.getUri(),
+              localFs.getWorkingDirectory()).toString());
+        }
+      } else {
-        finalPath = path.makeQualified(fs.getUri(),
-            fs.getWorkingDirectory()).toString();
+        if (isWildcard) {
+          expandWildcard(finalPaths, path, fs);
+        } else {
+          finalPaths.add(path.makeQualified(fs.getUri(),
+              fs.getWorkingDirectory()).toString());
+        }
-      finalArr[i] = finalPath;
-    return StringUtils.arrayToString(finalArr);
+    if (finalPaths.isEmpty()) {
+      throw new IllegalArgumentException("Path " + files + " cannot be empty.");
+    }
+    return StringUtils.join(",", finalPaths);
+  }
+
+  private boolean matchesCurrentDirectory(String path) {
+    return path.isEmpty() || path.equals(Path.CUR_DIR) ||
+        path.equals(Path.CUR_DIR + File.separator);
+  }
+
+  private void expandWildcard(List<String> finalPaths, Path path, FileSystem fs)
+      throws IOException {
+    if (!fs.isDirectory(path)) {
+      throw new FileNotFoundException(path + " is not a directory.");
+    }
+    // get all the jars in the directory
+    List<Path> jars = FileUtil.getJarsInDirectory(path.toString(),
+        fs.equals(FileSystem.getLocal(conf)));
+    if (jars.isEmpty()) {
+      LOG.warn(path + " does not have jars in it. It will be ignored.");
+    } else {
+      for (Path jar: jars) {
+        finalPaths.add(jar.makeQualified(fs.getUri(),
+            fs.getWorkingDirectory()).toString());
+      }
+    }
-   * configuration accordingly
+   * configuration accordingly.
+   *
-   * @param conf Configuration to be modified
-  private void parseGeneralOptions(Options opts, Configuration conf, 
-      String[] args) throws IOException {
+  private void parseGeneralOptions(Options opts, String[] args)
+      throws IOException {
-      processGeneralOptions(conf, commandLine);
+      processGeneralOptions(commandLine);

INS26 INS26 INS40 INS40 INS31 INS31 INS31 MOV21 INS29 INS83 MOV43 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS65 INS65 INS65 INS43 INS42 INS42 INS41 INS65 INS39 INS42 INS25 MOV43 INS42 INS41 INS74 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS60 INS25 UPD66 INS27 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS32 UPD66 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS8 INS74 MOV60 INS32 INS8 INS27 INS43 INS43 INS42 INS42 INS38 INS8 INS74 INS59 INS32 INS8 INS8 UPD66 MOV27 INS32 INS42 INS42 INS9 INS41 INS43 INS43 UPD42 INS14 INS60 INS42 INS42 INS53 UPD42 INS45 UPD42 INS32 INS32 INS32 INS42 INS42 INS32 INS53 INS43 INS43 INS42 INS32 INS42 INS42 INS21 INS70 INS32 INS42 MOV33 INS42 INS42 INS74 INS40 INS83 MOV43 INS39 INS59 INS14 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS27 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS44 INS42 INS8 INS42 INS42 INS43 UPD42 INS45 INS42 INS27 INS25 INS25 INS25 INS43 INS27 INS40 INS40 INS43 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS43 INS42 INS21 INS9 INS42 INS32 INS42 INS42 INS8 INS42 INS8 INS8 INS42 INS8 INS8 INS42 INS45 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS42 INS32 INS42 INS42 INS42 INS21 INS16 INS21 MOV21 INS21 MOV21 INS42 INS42 INS32 UPD45 INS7 INS32 INS32 MOV14 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 INS32 INS42 INS42 INS34 INS27 INS43 INS40 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 INS42 DEL42 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL41 DEL85 DEL5 DEL85 DEL5 DEL40 DEL3 DEL42 DEL7 DEL42 DEL7 DEL42 DEL42 DEL2 DEL42 DEL7 DEL21 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42
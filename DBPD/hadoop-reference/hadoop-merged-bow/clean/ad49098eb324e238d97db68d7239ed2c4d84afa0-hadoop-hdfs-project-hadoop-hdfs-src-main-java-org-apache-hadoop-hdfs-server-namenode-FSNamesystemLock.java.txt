HDFS-11615. FSNamesystemLock metrics can be inaccurate due to millisecond precision. Contributed by Erik Krogen.

-
- * held the lock for. Note that if a thread dies, metrics produced after the
+ * held the lock for. These metrics have names of the form
+ * FSN(Read|Write)LockNanosOperationName, where OperationName denotes the name
+ * of the operation that initiated the lock hold (this will be OTHER for certain
+ * uncategorized operations) and they export the hold time values in
+ * nanoseconds. Note that if a thread dies, metrics produced after the
-  private final long lockSuppressWarningInterval;
+  private final long lockSuppressWarningIntervalMs;
-  private final long writeLockReportingThreshold;
+  private final long writeLockReportingThresholdMs;
-  private long writeLockHeldTimeStamp;
+  private long writeLockHeldTimeStampNanos;
-  private long timeStampOfLastWriteLockReport = 0;
-  private long longestWriteLockHeldInterval = 0;
+  /** Time stamp (ms) of the last time a write lock report was written. */
+  private long timeStampOfLastWriteLockReportMs = 0;
+  /** Longest time (ms) a write lock was held since the last report. */
+  private long longestWriteLockHeldIntervalMs = 0;
-  private final long readLockReportingThreshold;
+  private final long readLockReportingThresholdMs;
-  private final ThreadLocal<Long> readLockHeldTimeStamp =
+  private final ThreadLocal<Long> readLockHeldTimeStampNanos =
-  private final AtomicLong timeStampOfLastReadLockReport = new AtomicLong(0);
-  private final AtomicLong longestReadLockHeldInterval = new AtomicLong(0);
+  /** Time stamp (ms) of the last time a read lock report was written. */
+  private final AtomicLong timeStampOfLastReadLockReportMs = new AtomicLong(0);
+  /** Longest time (ms) a read lock was held since the last report. */
+  private final AtomicLong longestReadLockHeldIntervalMs = new AtomicLong(0);
+  private static final String LOCK_METRIC_SUFFIX = "Nanos";
-    this.writeLockReportingThreshold = conf.getLong(
+    this.writeLockReportingThresholdMs = conf.getLong(
-    this.readLockReportingThreshold = conf.getLong(
+    this.readLockReportingThresholdMs = conf.getLong(
-    this.lockSuppressWarningInterval = conf.getTimeDuration(
+    this.lockSuppressWarningIntervalMs = conf.getTimeDuration(
-      readLockHeldTimeStamp.set(timer.monotonicNow());
+      readLockHeldTimeStampNanos.set(timer.monotonicNowNanos());
-    final long readLockInterval =
-        timer.monotonicNow() - readLockHeldTimeStamp.get();
+    final long readLockIntervalNanos =
+        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();
-      addMetric(opName, readLockInterval, false);
-      readLockHeldTimeStamp.remove();
+      addMetric(opName, readLockIntervalNanos, false);
+      readLockHeldTimeStampNanos.remove();
-    if (needReport && readLockInterval >= this.readLockReportingThreshold) {
+    final long readLockIntervalMs =
+        TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);
+    if (needReport && readLockIntervalMs >= this.readLockReportingThresholdMs) {
-        localLongestReadLock = longestReadLockHeldInterval.get();
-      } while (localLongestReadLock - readLockInterval < 0 &&
-          !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,
-              readLockInterval));
+        localLongestReadLock = longestReadLockHeldIntervalMs.get();
+      } while (localLongestReadLock - readLockIntervalMs < 0 &&
+          !longestReadLockHeldIntervalMs.compareAndSet(localLongestReadLock,
+              readLockIntervalMs));
-      long now;
+      long nowMs;
-        now = timer.monotonicNow();
+        nowMs = timer.monotonicNow();
-            timeStampOfLastReadLockReport.get();
-        if (now - localTimeStampOfLastReadLockReport <
-            lockSuppressWarningInterval) {
+            timeStampOfLastReadLockReportMs.get();
+        if (nowMs - localTimeStampOfLastReadLockReport <
+            lockSuppressWarningIntervalMs) {
-      } while (!timeStampOfLastReadLockReport.compareAndSet(
-          localTimeStampOfLastReadLockReport, now));
+      } while (!timeStampOfLastReadLockReportMs.compareAndSet(
+          localTimeStampOfLastReadLockReport, nowMs));
-      long longestLockHeldInterval = longestReadLockHeldInterval.getAndSet(0);
+      long longestLockHeldIntervalMs =
+          longestReadLockHeldIntervalMs.getAndSet(0);
-          readLockInterval + " ms via\n" +
+          readLockIntervalMs + " ms via\n" +
-          "\n\tLongest read-lock held interval: " + longestLockHeldInterval);
+          "\n\tLongest read-lock held interval: " + longestLockHeldIntervalMs);
-      writeLockHeldTimeStamp = timer.monotonicNow();
+      writeLockHeldTimeStampNanos = timer.monotonicNowNanos();
-      writeLockHeldTimeStamp = timer.monotonicNow();
+      writeLockHeldTimeStampNanos = timer.monotonicNowNanos();
-    final long currentTime = timer.monotonicNow();
-    final long writeLockInterval = currentTime - writeLockHeldTimeStamp;
+    final long currentTimeNanos = timer.monotonicNowNanos();
+    final long writeLockIntervalNanos =
+        currentTimeNanos - writeLockHeldTimeStampNanos;
+    final long currentTimeMs = TimeUnit.NANOSECONDS.toMillis(currentTimeNanos);
+    final long writeLockIntervalMs =
+        TimeUnit.NANOSECONDS.toMillis(writeLockIntervalNanos);
-    long longestLockHeldInterval = 0;
-    if (needReport && writeLockInterval >= this.writeLockReportingThreshold) {
-      if (writeLockInterval > longestWriteLockHeldInterval) {
-        longestWriteLockHeldInterval = writeLockInterval;
+    long longestLockHeldIntervalMs = 0;
+    if (needReport &&
+        writeLockIntervalMs >= this.writeLockReportingThresholdMs) {
+      if (writeLockIntervalMs > longestWriteLockHeldIntervalMs) {
+        longestWriteLockHeldIntervalMs = writeLockIntervalMs;
-      if (currentTime - timeStampOfLastWriteLockReport >
-          this.lockSuppressWarningInterval) {
+      if (currentTimeMs - timeStampOfLastWriteLockReportMs >
+          this.lockSuppressWarningIntervalMs) {
-        longestLockHeldInterval = longestWriteLockHeldInterval;
-        longestWriteLockHeldInterval = 0;
-        timeStampOfLastWriteLockReport = currentTime;
+        longestLockHeldIntervalMs = longestWriteLockHeldIntervalMs;
+        longestWriteLockHeldIntervalMs = 0;
+        timeStampOfLastWriteLockReportMs = currentTimeMs;
-      addMetric(opName, writeLockInterval, true);
+      addMetric(opName, writeLockIntervalNanos, true);
-          writeLockInterval + " ms via\n" +
+          writeLockIntervalMs + " ms via\n" +
-          longestLockHeldInterval);
+          longestLockHeldIntervalMs);
-   * @param value Length of time the lock was held
+   * @param value Length of time the lock was held (nanoseconds)
-          org.apache.commons.lang.StringUtils.capitalize(operationName);
+          org.apache.commons.lang.StringUtils.capitalize(operationName) +
+          LOCK_METRIC_SUFFIX;

MOV23 INS23 INS29 INS29 INS29 INS29 INS83 INS83 INS83 INS43 INS59 INS66 INS66 INS66 INS66 UPD66 UPD42 UPD42 UPD42 INS65 UPD42 INS65 UPD42 UPD42 UPD42 INS65 UPD42 INS65 UPD42 INS42 INS42 INS45 INS60 INS60 INS60 INS66 INS66 INS66 INS66 INS83 INS39 INS59 MOV27 MOV27 INS83 INS39 INS59 INS83 INS39 INS59 UPD66 UPD42 INS42 INS32 UPD42 UPD42 INS42 INS32 INS42 INS32 UPD42 UPD42 UPD42 UPD42 INS40 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS40 INS42 INS42 INS40 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42
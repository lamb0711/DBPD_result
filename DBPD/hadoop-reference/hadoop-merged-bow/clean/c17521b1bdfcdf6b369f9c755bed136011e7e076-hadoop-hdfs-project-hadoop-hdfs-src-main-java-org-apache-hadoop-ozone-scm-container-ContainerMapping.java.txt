HDFS-12387. Ozone: Support Ratis as a first class replication mechanism. Contributed by Anu Engineer.

- * contributor license agreements.  See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership.  The ASF
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
- * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
+ * <p>Unless required by applicable law or agreed to in writing, software
-
-import org.apache.hadoop.ozone.common.statemachine.InvalidStateTransitionException;
-import org.apache.hadoop.ozone.common.statemachine.StateMachine;
-import org.apache.hadoop.ozone.protocol.proto.OzoneProtos;
+import org.apache.hadoop.ozone.protocol.proto.OzoneProtos;
+import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.Owner;
+import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.ReplicationFactor;
+import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.ReplicationType;
+import org.apache.hadoop.scm.container.common.helpers.BlockContainerInfo;
-import org.apache.hadoop.util.Time;
-import java.util.HashSet;
-import java.util.Set;
- * Mapping class contains the mapping from a name to a pipeline mapping. This is
- * used by SCM when allocating new locations and when looking up a key.
+ * Mapping class contains the mapping from a name to a pipeline mapping. This
+ * is used by SCM when
+ * allocating new locations and when looking up a key.
-  private static final Logger LOG =
-      LoggerFactory.getLogger(ContainerMapping.class);
+  private static final Logger LOG = LoggerFactory.getLogger(ContainerMapping
+      .class);
-
-  private final StateMachine<OzoneProtos.LifeCycleState,
-        OzoneProtos.LifeCycleEvent> stateMachine;
+  private final ContainerStateManager containerStateManager;
-   * Constructs a mapping class that creates mapping between container names and
-   * pipelines.
+   * Constructs a mapping class that creates mapping between container names
+   * and pipelines.
-   * healthy to place new containers.
+   * healthy to place new
+   *     containers.
-   * its nodes. This is passed to LevelDB and this memory is allocated in Native
-   * code space. CacheSize is specified in MB.
+   * its nodes. This is
+   *     passed to LevelDB and this memory is allocated in Native code space.
+   *     CacheSize is specified
+   *     in MB.
-  public ContainerMapping(final Configuration conf,
-      final NodeManager nodeManager, final int cacheSizeMB) throws IOException {
+  public ContainerMapping(
+      final Configuration conf, final NodeManager nodeManager, final int
+      cacheSizeMB)
+      throws IOException {
-    containerStore = MetadataStoreBuilder.newBuilder()
-        .setConf(conf)
-        .setDbFile(containerDBPath)
-        .setCacheSize(this.cacheSize * OzoneConsts.MB)
-        .build();
+    containerStore =
+        MetadataStoreBuilder.newBuilder()
+            .setConf(conf)
+            .setDbFile(containerDBPath)
+            .setCacheSize(this.cacheSize * OzoneConsts.MB)
+            .build();
-
-    // Initialize the container state machine.
-    Set<OzoneProtos.LifeCycleState> finalStates = new HashSet();
-    finalStates.add(OzoneProtos.LifeCycleState.OPEN);
-    finalStates.add(OzoneProtos.LifeCycleState.CLOSED);
-    finalStates.add(OzoneProtos.LifeCycleState.DELETED);
-
-    this.stateMachine = new StateMachine<>(
-        OzoneProtos.LifeCycleState.ALLOCATED, finalStates);
-    initializeStateMachine();
+    this.containerStateManager = new ContainerStateManager(conf, +this
+        .cacheSize * OzoneConsts.MB);
+    LOG.trace("Container State Manager created.");
-  // Client-driven Create State Machine
-  // States: <ALLOCATED>------------->CREATING----------------->[OPEN]
-  // Events:            (BEGIN_CREATE)    |    (COMPLETE_CREATE)
-  //                                      |
-  //                                      |(TIMEOUT)
-  //                                      V
-  //                                  DELETING----------------->[DELETED]
-  //                                           (CLEANUP)
-
-  // SCM Open/Close State Machine
-  // States: OPEN------------------>[CLOSED]
-  // Events:        (CLOSE)
-
-  // Delete State Machine
-  // States: OPEN------------------>DELETING------------------>[DELETED]
-  // Events:         (DELETE)                  (CLEANUP)
-  private void initializeStateMachine() {
-    stateMachine.addTransition(OzoneProtos.LifeCycleState.ALLOCATED,
-        OzoneProtos.LifeCycleState.CREATING,
-        OzoneProtos.LifeCycleEvent.BEGIN_CREATE);
-
-    stateMachine.addTransition(OzoneProtos.LifeCycleState.CREATING,
-        OzoneProtos.LifeCycleState.OPEN,
-        OzoneProtos.LifeCycleEvent.COMPLETE_CREATE);
-
-    stateMachine.addTransition(OzoneProtos.LifeCycleState.OPEN,
-        OzoneProtos.LifeCycleState.CLOSED,
-        OzoneProtos.LifeCycleEvent.CLOSE);
-
-    stateMachine.addTransition(OzoneProtos.LifeCycleState.OPEN,
-        OzoneProtos.LifeCycleState.DELETING,
-        OzoneProtos.LifeCycleEvent.DELETE);
-
-    stateMachine.addTransition(OzoneProtos.LifeCycleState.DELETING,
-        OzoneProtos.LifeCycleState.DELETED,
-        OzoneProtos.LifeCycleEvent.CLEANUP);
-
-    // Creating timeout -> Deleting
-    stateMachine.addTransition(OzoneProtos.LifeCycleState.CREATING,
-        OzoneProtos.LifeCycleState.DELETING,
-        OzoneProtos.LifeCycleEvent.TIMEOUT);
-  }
-
-  /**
-   * {@inheritDoc}
-   */
+  /** {@inheritDoc} */
-  public ContainerInfo getContainer(final String containerName)
-      throws IOException {
+  public ContainerInfo getContainer(final String containerName) throws
+      IOException {
-      byte[] containerBytes =
-          containerStore.get(containerName.getBytes(encoding));
+      byte[] containerBytes = containerStore.get(containerName.getBytes(
+          encoding));
-      containerInfo = ContainerInfo.fromProtobuf(
-          OzoneProtos.SCMContainerInfo.PARSER.parseFrom(containerBytes));
+      containerInfo =
+          ContainerInfo.fromProtobuf(OzoneProtos.SCMContainerInfo.PARSER
+              .parseFrom(containerBytes));
-  /**
-   * {@inheritDoc}
-   */
+  /** {@inheritDoc} */
-  public List<Pipeline> listContainer(String startName,
-      String prefixName, int count)
+  public List<Pipeline> listContainer(String startName, String prefixName,
+      int count)
-      byte[] startKey = startName == null ?
-          null : DFSUtil.string2Bytes(startName);
+      byte[] startKey = startName == null ? null : DFSUtil.string2Bytes(
+          startName);
-        ContainerInfo containerInfo =  ContainerInfo.fromProtobuf(
-            OzoneProtos.SCMContainerInfo.PARSER.parseFrom(entry.getValue()));
+        ContainerInfo containerInfo =
+            ContainerInfo.fromProtobuf(
+                OzoneProtos.SCMContainerInfo.PARSER.parseFrom(
+                    entry.getValue()));
-   * @param containerName - Name of the container.
+   * @param containerName - Name of the container.
+   * @param owner
-  public ContainerInfo allocateContainer(OzoneProtos.ReplicationType type,
-      OzoneProtos.ReplicationFactor replicationFactor,
-      final String containerName) throws IOException {
+  public ContainerInfo allocateContainer(
+      ReplicationType type,
+      ReplicationFactor replicationFactor,
+      final String containerName,
+      Owner owner)
+      throws IOException {
-      throw new SCMException("Unable to create container while in chill mode",
+      throw new SCMException(
+          "Unable to create container while in chill mode",
-      byte[] containerBytes =
-          containerStore.get(containerName.getBytes(encoding));
+      byte[] containerBytes = containerStore.get(containerName.getBytes(
+          encoding));
-        throw new SCMException("Specified container already exists. key : " +
-            containerName, SCMException.ResultCodes.CONTAINER_EXISTS);
+        throw new SCMException(
+            "Specified container already exists. key : " + containerName,
+            SCMException.ResultCodes.CONTAINER_EXISTS);
-      Pipeline pipeline = pipelineSelector.getReplicationPipeline(type,
-          replicationFactor, containerName);
-      containerInfo = new ContainerInfo.Builder()
-          .setState(OzoneProtos.LifeCycleState.ALLOCATED)
-          .setPipeline(pipeline)
-          .setStateEnterTime(Time.monotonicNow())
-          .build();
-      containerStore.put(containerName.getBytes(encoding),
-          containerInfo.getProtobuf().toByteArray());
+      containerInfo =
+          containerStateManager.allocateContainer(
+              pipelineSelector, type, replicationFactor, containerName, owner);
+      containerStore.put(
+          containerName.getBytes(encoding), containerInfo.getProtobuf()
+              .toByteArray());
-   * @throws IOException if container doesn't exist or container store failed to
-   *                     delete the specified key.
+   * @throws IOException if container doesn't exist or container store failed
+   * to delete the
+   *     specified key.
-      byte[] containerBytes =
-          containerStore.get(dbKey);
-      if(containerBytes == null) {
-        throw new SCMException("Failed to delete container "
-            + containerName + ", reason : container doesn't exist.",
+      byte[] containerBytes = containerStore.get(dbKey);
+      if (containerBytes == null) {
+        throw new SCMException(
+            "Failed to delete container " + containerName + ", reason : " +
+                "container doesn't exist.",
-        throw new SCMException("Failed to close container " + containerName +
-            ", reason : container in state " + newState,
+        throw new SCMException(
+            "Failed to close container "
+                + containerName
+                + ", reason : container in state "
+                + newState,
-  /**
-   * {@inheritDoc}
-   * Used by client to update container state on SCM.
-   */
+  /** {@inheritDoc} Used by client to update container state on SCM. */
-  public OzoneProtos.LifeCycleState updateContainerState(String containerName,
-      OzoneProtos.LifeCycleEvent event) throws IOException {
+  public OzoneProtos.LifeCycleState updateContainerState(
+      String containerName, OzoneProtos.LifeCycleEvent event) throws
+      IOException {
-            "Failed to update container state" + containerName
+            "Failed to update container state"
+                + containerName
-      containerInfo = ContainerInfo.fromProtobuf(
-          OzoneProtos.SCMContainerInfo.PARSER.parseFrom(containerBytes));
+      containerInfo =
+          ContainerInfo.fromProtobuf(OzoneProtos.SCMContainerInfo.PARSER
+              .parseFrom(containerBytes));
-      OzoneProtos.LifeCycleState newState;
-      try {
-        newState = stateMachine.getNextState(containerInfo.getState(), event);
-      } catch (InvalidStateTransitionException ex) {
-        throw new SCMException(
-            "Failed to update container state" + containerName
-                + ", reason : invalid state transition from state: "
-                + containerInfo.getState() + " upon event: " + event + ".",
-            SCMException.ResultCodes.FAILED_TO_CHANGE_CONTAINER_STATE);
-      }
-      containerInfo.setState(newState);
+      Preconditions.checkNotNull(containerInfo);
+
+      // TODO: Actual used will be updated via Container Reports later.
+      containerInfo.setState(
+          containerStateManager.updateContainerState(
+              new BlockContainerInfo(containerInfo, 0), event));
+
-      return newState;
+      return containerInfo.getState();
+  /** + * Returns the container State Manager. + * + * @return
+   * ContainerStateManager + */
+  @Override
+  public ContainerStateManager getStateManager() {
+    return containerStateManager;
+  }
+
-   * Closes this stream and releases any system resources associated with it. If
-   * the stream is already closed then invoking this method has no effect.
+   * Closes this stream and releases any system resources associated with it.
+   * If the stream is
+   * already closed then invoking this method has no effect.
+   *
-   * <p> As noted in {@link AutoCloseable#close()}, cases where the close may
-   * fail require careful attention. It is strongly advised to relinquish the
-   * underlying resources and to internally <em>mark</em> the {@code Closeable}
-   * as closed, prior to throwing the {@code IOException}.
+   *
+   * <p>As noted in {@link AutoCloseable#close()}, cases where the close may
+   * fail require careful
+   * attention. It is strongly advised to relinquish the underlying resources
+   * and to internally
+   * <em>mark</em> the {@code Closeable} as closed, prior to throwing the
+   * {@code IOException}.

MOV26 MOV26 MOV26 MOV26 MOV31 UPD40 UPD40 UPD40 UPD40 INS43 MOV65 INS44 INS29 INS78 UPD83 INS43 INS42 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD42 MOV42 UPD42 INS65 UPD43 UPD43 INS43 INS42 INS65 INS42 INS42 INS41 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 UPD66 INS66 UPD66 UPD66 INS66 INS66 INS42 UPD66 INS66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 INS42 UPD42 INS45 INS21 INS21 UPD42 INS43 INS42 INS27 INS32 INS32 MOV32 UPD42 MOV42 INS38 INS40 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS32 INS22 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 INS42 INS14 INS42 INS52 INS42 UPD43 MOV43 INS42 INS34 INS45 UPD45 UPD42 DEL40 DEL26 DEL43 DEL40 DEL43 DEL40 DEL43 DEL74 DEL42 DEL43 DEL40 DEL43 DEL74 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL21 DEL43 DEL74 DEL40 DEL42 DEL40 DEL40 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL43 DEL14 DEL40 DEL32 DEL32 DEL32 DEL32 DEL40 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL42 DEL45 DEL45 DEL42 DEL45 DEL27 DEL40 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL39 DEL42 DEL42 DEL42 DEL40 DEL40 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL40 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL40 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL40 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL40 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL40 DEL40 DEL32 DEL21 DEL8
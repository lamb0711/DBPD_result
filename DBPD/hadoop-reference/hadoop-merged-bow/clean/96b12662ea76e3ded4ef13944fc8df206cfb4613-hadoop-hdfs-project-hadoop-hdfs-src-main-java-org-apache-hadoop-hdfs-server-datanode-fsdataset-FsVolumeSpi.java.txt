HDFS-10637. Modifications to remove the assumption that FsVolumes are backed by java.io.File. (Virajith Jalaparti via lei)

+import java.net.URI;
+import java.util.LinkedList;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.DF;
+import org.apache.hadoop.hdfs.protocol.Block;
+import org.apache.hadoop.hdfs.protocol.HdfsConstants;
+import org.apache.hadoop.hdfs.server.datanode.DirectoryScanner.ReportCompiler;
+import org.apache.hadoop.hdfs.server.datanode.StorageLocation;
-  String getBasePath();
+  URI getBaseURI();
-  /** @return the path to the volume */
-  String getPath(String bpid) throws IOException;
+  DF getUsageStats(Configuration conf);
-  /** @return the directory for the finalized blocks in the block pool. */
-  File getFinalizedDir(String bpid) throws IOException;
-  
+  /** @return the {@link StorageLocation} to the volume */
+  StorageLocation getStorageLocation();
+
+  /** @return the {@link StorageType} of the volume */
+
+  /**
+   * Tracks the files and other information related to a block on the disk
+   * Missing file is indicated by setting the corresponding member
+   * to null.
+   *
+   * Because millions of these structures may be created, we try to save
+   * memory here.  So instead of storing full paths, we store path suffixes.
+   * The block file, if it exists, will have a path like this:
+   * <volume_base_path>/<block_path>
+   * So we don't need to store the volume path, since we already know what the
+   * volume is.
+   *
+   * The metadata file, if it exists, will have a path like this:
+   * <volume_base_path>/<block_path>_<genstamp>.meta
+   * So if we have a block file, there isn't any need to store the block path
+   * again.
+   *
+   * The accessor functions take care of these manipulations.
+   */
+  public static class ScanInfo implements Comparable<ScanInfo> {
+    private final long blockId;
+
+    /**
+     * The block file path, relative to the volume's base directory.
+     * If there was no block file found, this may be null. If 'vol'
+     * is null, then this is the full path of the block file.
+     */
+    private final String blockSuffix;
+
+    /**
+     * The suffix of the meta file path relative to the block file.
+     * If blockSuffix is null, then this will be the entire path relative
+     * to the volume base directory, or an absolute path if vol is also
+     * null.
+     */
+    private final String metaSuffix;
+
+    private final FsVolumeSpi volume;
+
+    /**
+     * Get the file's length in async block scan
+     */
+    private final long blockFileLength;
+
+    private final static Pattern CONDENSED_PATH_REGEX =
+        Pattern.compile("(?<!^)(\\\\|/){2,}");
+
+    private final static String QUOTED_FILE_SEPARATOR =
+        Matcher.quoteReplacement(File.separator);
+
+    /**
+     * Get the most condensed version of the path.
+     *
+     * For example, the condensed version of /foo//bar is /foo/bar
+     * Unlike {@link File#getCanonicalPath()}, this will never perform I/O
+     * on the filesystem.
+     *
+     * @param path the path to condense
+     * @return the condensed path
+     */
+    private static String getCondensedPath(String path) {
+      return CONDENSED_PATH_REGEX.matcher(path).
+          replaceAll(QUOTED_FILE_SEPARATOR);
+    }
+
+    /**
+     * Get a path suffix.
+     *
+     * @param f            The file to get the suffix for.
+     * @param prefix       The prefix we're stripping off.
+     *
+     * @return             A suffix such that prefix + suffix = path to f
+     */
+    private static String getSuffix(File f, String prefix) {
+      String fullPath = getCondensedPath(f.getAbsolutePath());
+      if (fullPath.startsWith(prefix)) {
+        return fullPath.substring(prefix.length());
+      }
+      throw new RuntimeException(prefix + " is not a prefix of " + fullPath);
+    }
+
+    /**
+     * Create a ScanInfo object for a block. This constructor will examine
+     * the block data and meta-data files.
+     *
+     * @param blockId the block ID
+     * @param blockFile the path to the block data file
+     * @param metaFile the path to the block meta-data file
+     * @param vol the volume that contains the block
+     */
+    public ScanInfo(long blockId, File blockFile, File metaFile,
+        FsVolumeSpi vol) {
+      this.blockId = blockId;
+      String condensedVolPath =
+          (vol == null || vol.getBaseURI() == null) ? null :
+            getCondensedPath(new File(vol.getBaseURI()).getAbsolutePath());
+      this.blockSuffix = blockFile == null ? null :
+        getSuffix(blockFile, condensedVolPath);
+      this.blockFileLength = (blockFile != null) ? blockFile.length() : 0;
+      if (metaFile == null) {
+        this.metaSuffix = null;
+      } else if (blockFile == null) {
+        this.metaSuffix = getSuffix(metaFile, condensedVolPath);
+      } else {
+        this.metaSuffix = getSuffix(metaFile,
+            condensedVolPath + blockSuffix);
+      }
+      this.volume = vol;
+    }
+
+    /**
+     * Returns the block data file.
+     *
+     * @return the block data file
+     */
+    public File getBlockFile() {
+      return (blockSuffix == null) ? null :
+        new File(new File(volume.getBaseURI()).getAbsolutePath(), blockSuffix);
+    }
+
+    /**
+     * Return the length of the data block. The length returned is the length
+     * cached when this object was created.
+     *
+     * @return the length of the data block
+     */
+    public long getBlockFileLength() {
+      return blockFileLength;
+    }
+
+    /**
+     * Returns the block meta data file or null if there isn't one.
+     *
+     * @return the block meta data file
+     */
+    public File getMetaFile() {
+      if (metaSuffix == null) {
+        return null;
+      } else if (blockSuffix == null) {
+        return new File(new File(volume.getBaseURI()).getAbsolutePath(),
+            metaSuffix);
+      } else {
+        return new File(new File(volume.getBaseURI()).getAbsolutePath(),
+            blockSuffix + metaSuffix);
+      }
+    }
+
+    /**
+     * Returns the block ID.
+     *
+     * @return the block ID
+     */
+    public long getBlockId() {
+      return blockId;
+    }
+
+    /**
+     * Returns the volume that contains the block that this object describes.
+     *
+     * @return the volume
+     */
+    public FsVolumeSpi getVolume() {
+      return volume;
+    }
+
+    @Override // Comparable
+    public int compareTo(ScanInfo b) {
+      if (blockId < b.blockId) {
+        return -1;
+      } else if (blockId == b.blockId) {
+        return 0;
+      } else {
+        return 1;
+      }
+    }
+
+    @Override // Object
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (!(o instanceof ScanInfo)) {
+        return false;
+      }
+      return blockId == ((ScanInfo) o).blockId;
+    }
+
+    @Override // Object
+    public int hashCode() {
+      return (int)(blockId^(blockId>>>32));
+    }
+
+    public long getGenStamp() {
+      return metaSuffix != null ? Block.getGenerationStamp(
+          getMetaFile().getName()) :
+            HdfsConstants.GRANDFATHER_GENERATION_STAMP;
+    }
+  }
+
+  /**
+   * Compile a list of {@link ScanInfo} for the blocks in
+   * the block pool with id {@code bpid}.
+   *
+   * @param bpid block pool id to scan
+   * @param report the list onto which blocks reports are placed
+   * @param reportCompiler
+   * @throws IOException
+   */
+  LinkedList<ScanInfo> compileReport(String bpid,
+      LinkedList<ScanInfo> report, ReportCompiler reportCompiler)
+      throws InterruptedException, IOException;

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS55 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 MOV29 INS83 INS42 MOV31 MOV31 MOV31 MOV31 MOV31 INS31 INS31 INS31 MOV31 MOV31 MOV31 MOV31 MOV55 MOV31 MOV31 MOV31 INS55 INS31 INS43 UPD42 INS43 INS42 INS44 INS29 INS43 INS42 INS29 MOV43 INS42 INS29 MOV83 INS83 INS42 INS74 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 MOV31 INS31 INS31 INS31 INS31 MOV31 INS31 INS31 INS31 INS31 MOV31 INS29 INS74 INS42 MOV44 INS44 INS44 INS43 MOV43 INS42 INS42 INS43 INS42 INS65 INS42 INS65 INS65 INS43 INS43 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS83 MOV43 UPD42 INS44 INS8 INS29 INS83 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS83 INS39 UPD42 INS8 INS29 INS83 INS43 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS65 INS65 INS65 INS65 INS65 INS43 INS43 INS74 INS42 INS43 INS42 INS42 INS42 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS42 INS42 INS65 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS65 INS65 INS65 INS42 MOV43 INS42 INS41 INS65 INS65 INS65 MOV43 INS42 UPD42 INS60 INS25 INS53 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS60 INS21 INS21 INS25 INS21 INS65 INS65 INS42 INS41 INS65 INS65 INS41 INS65 INS65 INS42 INS25 INS65 INS41 INS65 INS65 INS42 INS41 INS42 INS43 INS42 INS25 INS42 INS43 INS42 INS25 INS25 INS41 INS42 INS41 INS41 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS45 INS42 INS42 INS40 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS32 INS66 INS42 INS66 INS42 INS66 UPD66 INS43 INS59 INS32 INS8 INS14 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS7 INS43 INS59 INS7 INS7 INS27 INS8 INS25 INS7 INS66 INS66 INS16 INS66 INS66 INS66 INS42 INS66 INS66 INS27 INS8 INS25 INS66 UPD66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS25 INS42 INS27 INS8 INS38 INS8 INS27 INS11 INS16 INS42 INS66 INS42 INS42 INS68 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS41 INS43 INS27 INS22 INS42 INS42 INS42 INS16 INS22 INS16 INS22 INS16 INS42 INS33 INS21 INS27 INS8 INS8 INS22 INS42 INS36 INS33 INS14 INS42 INS33 INS41 INS27 INS8 INS8 INS42 INS40 INS41 INS27 INS8 INS8 INS52 INS42 INS41 INS36 INS41 INS42 INS22 INS39 INS36 INS27 INS32 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 UPD42 MOV42 INS42 INS45 INS42 INS52 INS42 INS36 INS33 INS32 INS52 INS42 INS27 INS33 INS32 INS52 INS42 INS36 INS32 INS34 INS7 INS42 INS33 INS21 INS21 INS52 INS42 INS27 INS43 INS32 INS42 INS33 INS42 INS33 INS41 INS41 INS38 INS42 INS40 INS41 INS41 INS9 INS62 INS9 INS36 INS42 INS27 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS27 INS42 INS32 INS42 INS33 INS42 INS42 INS42 INS27 INS42 INS42 INS22 INS33 INS7 INS7 INS42 INS33 INS42 INS14 INS42 INS14 INS14 INS34 INS34 INS34 INS42 INS43 INS11 INS42 INS36 INS32 INS42 INS42 INS42 INS27 INS27 INS14 INS42 INS42 INS33 INS52 INS42 INS22 INS32 INS22 INS32 INS43 INS32 INS43 INS32 INS42 INS43 INS32 INS27 INS42 INS43 INS42 INS27 INS42 INS42 INS33 INS32 INS33 INS43 INS32 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL43 DEL42 DEL42 DEL55
Merging r1539737 through r1539896 from trunk to branch HDFS-2832

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1539898 13f79535-47bb-0310-9956-ffa450edef68

-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_DESCRIPTORS_NUM_RESPONSES;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_DIRECTIVES_NUM_RESPONSES;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_DESCRIPTORS_NUM_RESPONSES_DEFAULT;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_DIRECTIVES_NUM_RESPONSES_DEFAULT;
-import java.io.Closeable;
+import org.apache.hadoop.fs.IdNotFoundException;
-import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.hdfs.protocol.BlockListAsLongs;
-import org.apache.hadoop.hdfs.protocol.BlockListAsLongs.BlockReportIterator;
-import org.apache.hadoop.hdfs.protocol.PathBasedCacheDescriptor;
-import org.apache.hadoop.hdfs.protocol.AddPathBasedCacheDirectiveException.InvalidPoolNameError;
-import org.apache.hadoop.hdfs.protocol.AddPathBasedCacheDirectiveException.UnexpectedAddPathBasedCacheDirectiveException;
-import org.apache.hadoop.hdfs.protocol.AddPathBasedCacheDirectiveException.PoolWritePermissionDeniedError;
-import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheDescriptorException.InvalidIdException;
-import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheDescriptorException.NoSuchIdException;
-import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheDescriptorException.UnexpectedRemovePathBasedCacheDescriptorException;
-import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheDescriptorException.RemovePermissionDeniedException;
-import org.apache.hadoop.hdfs.server.common.HdfsServerConstants.ReplicaState;
+import org.apache.hadoop.security.AccessControlException;
-   * listPathBasedCacheDescriptors relies on the ordering of elements in this map 
+   * listPathBasedCacheDirectives relies on the ordering of elements in this map
-  private final int maxListCacheDescriptorsResponses;
+  private final int maxListCacheDirectivesNumResponses;
-    this.maxListCacheDescriptorsResponses = conf.getInt(
-        DFS_NAMENODE_LIST_CACHE_DESCRIPTORS_NUM_RESPONSES,
-        DFS_NAMENODE_LIST_CACHE_DESCRIPTORS_NUM_RESPONSES_DEFAULT);
+    this.maxListCacheDirectivesNumResponses = conf.getInt(
+        DFS_NAMENODE_LIST_CACHE_DIRECTIVES_NUM_RESPONSES,
+        DFS_NAMENODE_LIST_CACHE_DIRECTIVES_NUM_RESPONSES_DEFAULT);
-  public PathBasedCacheDescriptor addDirective(
-      PathBasedCacheDirective directive, FSPermissionChecker pc)
-      throws IOException {
-    assert namesystem.hasWriteLock();
-    CachePool pool = cachePools.get(directive.getPool());
-    if (pool == null) {
-      LOG.info("addDirective " + directive + ": pool not found.");
-      throw new InvalidPoolNameError(directive);
-    }
-    if ((pc != null) && (!pc.checkPermission(pool, FsAction.WRITE))) {
-      LOG.info("addDirective " + directive + ": write permission denied.");
-      throw new PoolWritePermissionDeniedError(directive);
-    }
-    try {
-      directive.validate();
-    } catch (IOException ioe) {
-      LOG.info("addDirective " + directive + ": validation failed: "
-          + ioe.getClass().getName() + ": " + ioe.getMessage());
-      throw ioe;
-    }
-    
-    // Add a new entry with the next available ID.
-    PathBasedCacheEntry entry;
-    try {
-      entry = new PathBasedCacheEntry(getNextEntryId(),
-          directive.getPath().toUri().getPath(),
-          directive.getReplication(), pool);
-    } catch (IOException ioe) {
-      throw new UnexpectedAddPathBasedCacheDirectiveException(directive);
-    }
-    LOG.info("addDirective " + directive + ": added cache directive "
-        + directive);
-
-    // Success!
-    // First, add it to the various maps
+  private void addInternal(PathBasedCacheEntry entry) {
-    String path = directive.getPath().toUri().getPath();
+    String path = entry.getPath();
+  }
+
+  public PathBasedCacheDirective addDirective(
+      PathBasedCacheDirective directive, FSPermissionChecker pc)
+      throws IOException {
+    assert namesystem.hasWriteLock();
+    PathBasedCacheEntry entry;
+    try {
+      if (directive.getPool() == null) {
+        throw new IdNotFoundException("addDirective: no pool was specified.");
+      }
+      if (directive.getPool().isEmpty()) {
+        throw new IdNotFoundException("addDirective: pool name was empty.");
+      }
+      CachePool pool = cachePools.get(directive.getPool());
+      if (pool == null) {
+        throw new IdNotFoundException("addDirective: no such pool as " +
+            directive.getPool());
+      }
+      if ((pc != null) && (!pc.checkPermission(pool, FsAction.WRITE))) {
+        throw new AccessControlException("addDirective: write " +
+            "permission denied for pool " + directive.getPool());
+      }
+      if (directive.getPath() == null) {
+        throw new IOException("addDirective: no path was specified.");
+      }
+      String path = directive.getPath().toUri().getPath();
+      if (!DFSUtil.isValidName(path)) {
+        throw new IOException("addDirective: path '" + path + "' is invalid.");
+      }
+      short replication = directive.getReplication() == null ? 
+          (short)1 : directive.getReplication();
+      if (replication <= 0) {
+        throw new IOException("addDirective: replication " + replication +
+            " is invalid.");
+      }
+      long id;
+      if (directive.getId() != null) {
+        // We are loading an entry from the edit log.
+        // Use the ID from the edit log.
+        id = directive.getId();
+      } else {
+        // Add a new entry with the next available ID.
+        id = getNextEntryId();
+      }
+      entry = new PathBasedCacheEntry(id, path, replication, pool);
+      addInternal(entry);
+    } catch (IOException e) {
+      LOG.warn("addDirective " + directive + ": failed.", e);
+      throw e;
+    }
+    LOG.info("addDirective " + directive + ": succeeded.");
-    return entry.getDescriptor();
+    return entry.toDirective();
-  public void removeDescriptor(long id, FSPermissionChecker pc)
+  public void modifyDirective(PathBasedCacheDirective directive,
+      FSPermissionChecker pc) throws IOException {
+    assert namesystem.hasWriteLock();
+    String idString =
+        (directive.getId() == null) ?
+            "(null)" : directive.getId().toString();
+    try {
+      // Check for invalid IDs.
+      Long id = directive.getId();
+      if (id == null) {
+        throw new IdNotFoundException("modifyDirective: " +
+            "no ID to modify was supplied.");
+      }
+      if (id <= 0) {
+        throw new IdNotFoundException("modifyDirective " + id +
+            ": invalid non-positive directive ID.");
+      }
+      // Find the entry.
+      PathBasedCacheEntry prevEntry = entriesById.get(id);
+      if (prevEntry == null) {
+        throw new IdNotFoundException("modifyDirective " + id +
+            ": id not found.");
+      }
+      if ((pc != null) &&
+          (!pc.checkPermission(prevEntry.getPool(), FsAction.WRITE))) {
+        throw new AccessControlException("modifyDirective " + id +
+            ": permission denied for initial pool " + prevEntry.getPool());
+      }
+      String path = prevEntry.getPath();
+      if (directive.getPath() != null) {
+        path = directive.getPath().toUri().getPath();
+        if (!DFSUtil.isValidName(path)) {
+          throw new IOException("modifyDirective " + id + ": new path " +
+              path + " is not valid.");
+        }
+      }
+      short replication = (directive.getReplication() != null) ?
+          directive.getReplication() : prevEntry.getReplication();
+      if (replication <= 0) {
+        throw new IOException("modifyDirective: replication " + replication +
+            " is invalid.");
+      }
+      CachePool pool = prevEntry.getPool();
+      if (directive.getPool() != null) {
+        pool = cachePools.get(directive.getPool());
+        if (pool == null) {
+          throw new IdNotFoundException("modifyDirective " + id +
+              ": pool " + directive.getPool() + " not found.");
+        }
+        if (directive.getPool().isEmpty()) {
+          throw new IdNotFoundException("modifyDirective: pool name was " +
+              "empty.");
+        }
+        if ((pc != null) &&
+            (!pc.checkPermission(pool, FsAction.WRITE))) {
+          throw new AccessControlException("modifyDirective " + id +
+              ": permission denied for target pool " + pool);
+        }
+      }
+      removeInternal(prevEntry);
+      PathBasedCacheEntry newEntry =
+          new PathBasedCacheEntry(id, path, replication, pool);
+      addInternal(newEntry);
+    } catch (IOException e) {
+      LOG.warn("modifyDirective " + idString + ": failed.", e);
+      throw e;
+    }
+    LOG.info("modifyDirective " + idString + ": successfully applied " +
+        directive);
+  }
+
+  public void removeInternal(PathBasedCacheEntry existing)
-    // Check for invalid IDs.
-    if (id <= 0) {
-      LOG.info("removeDescriptor " + id + ": invalid non-positive " +
-          "descriptor ID.");
-      throw new InvalidIdException(id);
-    }
-    // Find the entry.
-    PathBasedCacheEntry existing = entriesById.get(id);
-    if (existing == null) {
-      LOG.info("removeDescriptor " + id + ": entry not found.");
-      throw new NoSuchIdException(id);
-    }
-    CachePool pool = cachePools.get(existing.getDescriptor().getPool());
-    if (pool == null) {
-      LOG.info("removeDescriptor " + id + ": pool not found for directive " +
-        existing.getDescriptor());
-      throw new UnexpectedRemovePathBasedCacheDescriptorException(id);
-    }
-    if ((pc != null) && (!pc.checkPermission(pool, FsAction.WRITE))) {
-      LOG.info("removeDescriptor " + id + ": write permission denied to " +
-          "pool " + pool + " for entry " + existing);
-      throw new RemovePermissionDeniedException(id);
-    }
-    
-    String path = existing.getDescriptor().getPath().toUri().getPath();
+    String path = existing.getPath();
-      throw new UnexpectedRemovePathBasedCacheDescriptorException(id);
+      throw new IdNotFoundException("removeInternal: failed to locate entry " +
+          existing.getEntryId() + " by path " + existing.getPath());
-    entriesById.remove(id);
+    entriesById.remove(existing.getEntryId());
+  }
+
+  public void removeDirective(long id, FSPermissionChecker pc)
+      throws IOException {
+    assert namesystem.hasWriteLock();
+    try {
+      // Check for invalid IDs.
+      if (id <= 0) {
+        throw new IdNotFoundException("removeDirective " + id + ": invalid " +
+            "non-positive directive ID.");
+      }
+      // Find the entry.
+      PathBasedCacheEntry existing = entriesById.get(id);
+      if (existing == null) {
+        throw new IdNotFoundException("removeDirective " + id +
+            ": id not found.");
+      }
+      if ((pc != null) &&
+          (!pc.checkPermission(existing.getPool(), FsAction.WRITE))) {
+        throw new AccessControlException("removeDirective " + id +
+            ": write permission denied on pool " +
+            existing.getPool().getPoolName());
+      }
+      removeInternal(existing);
+    } catch (IOException e) {
+      LOG.warn("removeDirective " + id + " failed.", e);
+      throw e;
+    }
-    LOG.info("removeDescriptor successful for PathCacheEntry id " + id);
+    LOG.info("removeDirective " + id + ": succeeded.");
-  public BatchedListEntries<PathBasedCacheDescriptor> 
-        listPathBasedCacheDescriptors(long prevId, String filterPool,
-            String filterPath, FSPermissionChecker pc) throws IOException {
+  public BatchedListEntries<PathBasedCacheDirective> 
+        listPathBasedCacheDirectives(long prevId,
+            PathBasedCacheDirective filter,
+            FSPermissionChecker pc) throws IOException {
-    if (filterPath != null) {
+    String filterPath = null;
+    if (filter.getId() != null) {
+      throw new IOException("we currently don't support filtering by ID");
+    }
+    if (filter.getPath() != null) {
+      filterPath = filter.getPath().toUri().getPath();
-        throw new IOException("invalid path name '" + filterPath + "'");
+        throw new IOException("listPathBasedCacheDirectives: invalid " +
+            "path name '" + filterPath + "'");
-    ArrayList<PathBasedCacheDescriptor> replies =
-        new ArrayList<PathBasedCacheDescriptor>(NUM_PRE_ALLOCATED_ENTRIES);
+    if (filter.getReplication() != null) {
+      throw new IOException("we currently don't support filtering " +
+          "by replication");
+    }
+    ArrayList<PathBasedCacheDirective> replies =
+        new ArrayList<PathBasedCacheDirective>(NUM_PRE_ALLOCATED_ENTRIES);
-    SortedMap<Long, PathBasedCacheEntry> tailMap = entriesById.tailMap(prevId + 1);
+    SortedMap<Long, PathBasedCacheEntry> tailMap =
+      entriesById.tailMap(prevId + 1);
-      if (numReplies >= maxListCacheDescriptorsResponses) {
-        return new BatchedListEntries<PathBasedCacheDescriptor>(replies, true);
+      if (numReplies >= maxListCacheDirectivesNumResponses) {
+        return new BatchedListEntries<PathBasedCacheDirective>(replies, true);
-      PathBasedCacheDirective directive = cur.getValue().getDescriptor();
-      if (filterPool != null && 
-          !directive.getPool().equals(filterPool)) {
+      PathBasedCacheDirective directive = cur.getValue().toDirective();
+      if (filter.getPool() != null && 
+          !directive.getPool().equals(filter.getPool())) {
-      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {
-        replies.add(cur.getValue().getDescriptor());
+      if ((pc == null) ||
+          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {
+        replies.add(cur.getValue().toDirective());
-    return new BatchedListEntries<PathBasedCacheDescriptor>(replies, false);
+    return new BatchedListEntries<PathBasedCacheDirective>(replies, false);
-            "processCacheReport from dead or unregistered datanode: " + datanode);
+            "processCacheReport from dead or unregistered datanode: " +
+            datanode);

MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 INS31 INS31 INS31 INS31 INS83 INS39 INS42 INS44 INS8 UPD43 MOV83 MOV39 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 MOV43 INS8 INS83 INS39 INS42 MOV44 MOV44 INS43 INS8 UPD74 MOV74 UPD42 UPD42 INS43 INS42 MOV21 INS60 MOV60 MOV25 MOV21 UPD42 INS54 INS43 INS42 INS43 INS42 INS42 INS6 INS60 INS54 MOV21 INS43 INS42 MOV6 INS60 MOV60 MOV25 MOV25 INS21 INS42 INS6 INS54 MOV25 MOV21 UPD43 MOV43 UPD42 INS60 INS25 INS25 UPD66 INS42 INS43 INS59 INS8 MOV12 INS42 INS42 INS32 MOV43 INS59 INS8 INS12 INS42 MOV43 INS59 INS32 INS32 INS8 INS12 UPD42 INS43 INS59 INS27 INS8 INS27 INS8 UPD74 MOV74 INS42 INS42 INS32 INS25 INS25 MOV60 INS25 MOV25 INS25 MOV60 INS25 INS60 INS25 INS60 INS25 INS21 INS21 UPD42 INS42 INS42 INS42 INS16 INS60 INS25 INS25 INS60 INS25 INS25 INS60 INS25 INS60 INS25 INS60 INS25 INS21 INS60 INS21 INS44 INS8 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS25 MOV60 INS25 INS25 INS21 INS44 INS8 INS42 INS42 INS33 INS32 INS33 INS53 INS32 INS21 INS32 INS33 INS53 UPD43 UPD74 MOV74 UPD42 UPD42 UPD42 INS42 INS42 INS27 INS8 INS32 INS8 MOV27 INS8 INS27 INS8 INS38 INS8 INS39 INS59 INS27 INS8 INS39 INS59 INS27 INS8 INS8 INS7 INS32 INS43 UPD42 INS21 INS53 UPD45 INS36 INS45 INS32 INS43 INS59 INS27 INS8 MOV27 INS8 INS43 INS59 INS27 INS8 INS27 INS8 MOV43 INS59 INS27 INS8 INS39 INS59 INS27 INS8 MOV43 INS59 INS27 INS8 INS32 INS43 INS59 INS32 INS43 INS42 INS21 INS53 UPD45 UPD42 UPD45 INS42 INS42 INS42 INS42 INS42 INS27 INS8 MOV27 INS8 INS27 INS8 INS32 INS43 INS42 MOV21 INS53 UPD45 INS45 INS42 INS42 INS14 INS42 INS42 INS7 INS42 INS42 INS14 UPD42 UPD74 MOV74 INS43 INS27 UPD43 INS32 INS33 INS53 INS32 INS42 INS53 MOV53 INS53 INS32 INS33 INS53 INS32 INS53 INS42 INS16 INS42 INS34 INS53 INS42 MOV32 INS33 INS21 INS21 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS27 INS32 INS42 INS42 INS42 INS32 INS42 INS33 INS53 INS53 INS42 INS42 INS32 INS42 INS33 MOV53 INS36 INS36 INS53 INS42 INS32 INS32 INS33 MOV21 INS25 INS42 INS16 INS42 INS34 INS53 MOV42 INS32 INS32 INS33 INS21 INS25 INS25 MOV25 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 UPD43 INS27 INS42 INS34 MOV53 INS53 INS36 INS36 INS53 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS43 INS45 INS42 INS32 INS43 INS27 UPD43 UPD42 INS42 MOV32 INS36 INS36 UPD42 UPD42 MOV42 UPD42 MOV42 INS14 INS42 INS42 INS14 INS14 MOV42 UPD42 MOV42 INS14 INS42 UPD42 MOV42 UPD42 MOV42 INS14 INS27 INS11 MOV32 INS14 UPD42 UPD42 INS7 INS7 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS33 INS42 INS42 INS42 INS42 INS14 INS14 INS42 INS42 INS42 INS27 INS38 INS14 INS42 INS42 INS42 INS42 INS38 INS8 INS36 INS32 INS32 INS14 INS42 INS42 INS42 INS42 INS7 MOV27 INS8 MOV32 INS8 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 UPD42 INS45 INS32 INS45 INS32 INS14 INS27 INS38 INS14 UPD42 UPD42 INS27 INS42 INS42 INS32 INS42 INS42 INS45 INS45 UPD42 UPD42 INS32 INS32 INS27 MOV32 INS43 INS45 INS43 INS45 UPD43 INS27 INS43 INS27 MOV43 INS45 MOV43 INS27 INS32 INS33 INS39 INS34 INS43 INS27 INS42 INS32 INS42 MOV32 INS45 INS42 INS45 INS42 INS42 INS43 INS27 INS43 INS27 UPD43 INS27 INS42 INS33 INS32 INS43 INS27 INS42 MOV32 INS32 MOV53 INS27 INS42 INS42 INS42 INS42 MOV43 INS27 INS42 INS32 INS53 UPD42 INS53 INS53 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 UPD43 INS27 INS43 INS27 INS42 INS33 INS32 INS43 INS27 INS45 INS42 INS45 INS32 INS42 INS43 UPD74 INS42 INS42 INS32 INS42 INS32 INS42 INS33 MOV32 INS42 INS42 UPD42 INS45 INS32 INS42 UPD45 MOV45 INS45 INS32 UPD45 MOV45 UPD42 MOV42 UPD45 MOV45 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS42 UPD45 MOV45 INS42 INS42 INS42 INS45 INS45 INS42 UPD45 MOV45 MOV42 UPD45 MOV45 UPD42 INS45 INS42 INS45 UPD42 MOV42 INS42 INS32 INS40 INS42 UPD45 MOV45 MOV42 UPD45 MOV45 INS32 INS42 INS42 INS42 INS32 INS33 INS45 INS42 INS45 MOV42 MOV42 MOV32 INS14 INS14 INS14 UPD42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS32 INS40 INS42 INS45 INS42 INS45 INS32 INS42 INS42 INS42 INS27 UPD43 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD43 INS27 INS42 INS42 UPD42 UPD42 INS43 INS27 INS43 INS27 INS43 INS27 INS42 INS42 MOV32 UPD42 MOV42 INS45 UPD45 MOV45 UPD42 UPD42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS45 INS42 UPD45 MOV45 MOV42 UPD45 MOV45 MOV42 UPD42 INS42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL32 DEL21 DEL8 DEL42 DEL44 DEL32 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL54 DEL42 DEL42 DEL42 DEL42 DEL14 DEL42 DEL42 DEL42 DEL42 DEL45 DEL45 DEL42 DEL27 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL32 DEL32 DEL59 DEL60 DEL8 DEL25 DEL42 DEL32 DEL32 DEL32 DEL59 DEL60 DEL8 DEL31 DEL42 DEL44 DEL42 DEL42
HADOOP-6218. Adds a feature where TFile can be split by Record Sequeunce number. Contributed by Hong Tang and Raghu Angadi.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@824516 13f79535-47bb-0310-9956-ffa450edef68

-   * {@link Reader#createScanner(long, long)}), or a portion of TFile with keys
+   * {@link Reader#createScannerByByteRange(long, long)}), or a portion of TFile with keys
-   * {@link Reader#createScanner(byte[], byte[])} or
-   * {@link Reader#createScanner(RawComparable, RawComparable)}).
+   * {@link Reader#createScannerByKey(byte[], byte[])} or
+   * {@link Reader#createScannerByKey(RawComparable, RawComparable)}).
+    Location getLocationByRecordNum(long recNum) throws IOException {
+      checkTFileDataIndex();
+      return tfileIndex.getLocationByRecordNum(recNum);
+    }
+
+    long getRecordNumByLocation(Location location) throws IOException {
+      checkTFileDataIndex();
+      return tfileIndex.getRecordNumByLocation(location);      
+    }
+    
+     * Get the RecordNum for the first key-value pair in a compressed block
+     * whose byte offset in the TFile is greater than or equal to the specified
+     * offset.
+     * 
+     * @param offset
+     *          the user supplied offset.
+     * @return the RecordNum to the corresponding entry. If no such entry
+     *         exists, it returns the total entry count.
+     * @throws IOException
+     */
+    public long getRecordNumNear(long offset) throws IOException {
+      return getRecordNumByLocation(getLocationNear(offset));
+    }
+    
+    /**
-    public Scanner createScanner(long offset, long length) throws IOException {
+    public Scanner createScannerByByteRange(long offset, long length) throws IOException {
+     * 
+     * @deprecated Use {@link #createScannerByKey(byte[], byte[])} instead.
+    @Deprecated
+      throws IOException {
+      return createScannerByKey(beginKey, endKey);
+    }
+    
+    /**
+     * Get a scanner that covers a portion of TFile based on keys.
+     * 
+     * @param beginKey
+     *          Begin key of the scan (inclusive). If null, scan from the first
+     *          key-value entry of the TFile.
+     * @param endKey
+     *          End key of the scan (exclusive). If null, scan up to the last
+     *          key-value entry of the TFile.
+     * @return The actual coverage of the returned scanner will cover all keys
+     *         greater than or equal to the beginKey and less than the endKey.
+     * @throws IOException
+     */
+    public Scanner createScannerByKey(byte[] beginKey, byte[] endKey)
-      return createScanner((beginKey == null) ? null : new ByteArray(beginKey,
+      return createScannerByKey((beginKey == null) ? null : new ByteArray(beginKey,
+     * 
+     * @deprecated Use {@link #createScannerByKey(RawComparable, RawComparable)}
+     *             instead.
+    @Deprecated
+      return createScannerByKey(beginKey, endKey);
+    }
+
+    /**
+     * Get a scanner that covers a specific key range.
+     * 
+     * @param beginKey
+     *          Begin key of the scan (inclusive). If null, scan from the first
+     *          key-value entry of the TFile.
+     * @param endKey
+     *          End key of the scan (exclusive). If null, scan up to the last
+     *          key-value entry of the TFile.
+     * @return The actual coverage of the returned scanner will cover all keys
+     *         greater than or equal to the beginKey and less than the endKey.
+     * @throws IOException
+     */
+    public Scanner createScannerByKey(RawComparable beginKey, RawComparable endKey)
+        throws IOException {
+     * Create a scanner that covers a range of records.
+     * 
+     * @param beginRecNum
+     *          The RecordNum for the first record (inclusive).
+     * @param endRecNum
+     *          The RecordNum for the last record (exclusive). To scan the whole
+     *          file, either specify endRecNum==-1 or endRecNum==getEntryCount().
+     * @return The TFile scanner that covers the specified range of records.
+     * @throws IOException
+     */
+    public Scanner createScannerByRecordNum(long beginRecNum, long endRecNum)
+        throws IOException {
+      if (beginRecNum < 0) beginRecNum = 0;
+      if (endRecNum < 0 || endRecNum > getEntryCount()) {
+        endRecNum = getEntryCount();
+      }
+      return new Scanner(this, getLocationByRecordNum(beginRecNum),
+          getLocationByRecordNum(endRecNum));
+    }
+
+    /**
+       * Get the RecordNum corresponding to the entry pointed by the cursor.
+       * @return The RecordNum corresponding to the entry pointed by the cursor.
+       * @throws IOException
+       */
+      public long getRecordNum() throws IOException {
+        return reader.getRecordNumByLocation(currentLocation);
+      }
+      
+      /**
+    private final ArrayList<Long> recordNumIndex;
-
+    private long sum = 0;
+    
+      recordNumIndex = new ArrayList<Long>(entryCount);
+          sum += idx.entries();
+          recordNumIndex.add(sum);
+    /**
+     * @param key
+     *          input key.
+     * @return the ID of the first block that contains key > input key. Or -1
+     *         if no such block exists.
+     */
+      recordNumIndex = new ArrayList<Long>();
+    
+    public Reader.Location getLocationByRecordNum(long recNum) {
+      int idx = Utils.upperBound(recordNumIndex, recNum);
+      long lastRecNum = (idx == 0)? 0: recordNumIndex.get(idx-1);
+      return new Reader.Location(idx, recNum-lastRecNum);
+    }
+    public long getRecordNumByLocation(Reader.Location location) {
+      int blkIndex = location.getBlockIndex();
+      long lastRecNum = (blkIndex == 0) ? 0: recordNumIndex.get(blkIndex-1);
+      return lastRecNum + location.getRecordIndex();
+    }
+    
+      sum += keyEntry.entries();
+      recordNumIndex.add(sum);

INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS23 INS31 INS31 INS43 INS42 INS44 INS43 INS8 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 UPD42 INS29 INS78 INS83 INS43 INS42 INS44 INS44 INS43 INS8 UPD42 INS29 INS78 INS83 INS43 INS42 INS44 INS44 INS43 INS8 UPD42 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS31 INS83 INS83 INS74 INS59 INS83 INS39 INS59 INS29 INS83 INS43 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS42 INS39 INS42 INS42 INS21 INS41 INS43 INS42 INS42 INS21 INS41 INS65 INS65 INS65 INS65 INS39 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS42 INS5 INS42 INS5 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS39 INS42 INS39 INS42 INS42 INS25 INS25 INS41 INS29 INS83 INS39 INS42 INS43 INS8 INS43 INS43 INS42 INS42 INS34 INS21 INS65 INS65 INS21 INS40 INS39 INS42 INS60 INS60 INS41 INS43 INS42 INS60 INS60 INS41 INS21 INS21 INS32 INS32 INS42 INS32 INS32 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS32 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS65 INS66 INS39 INS85 INS39 INS85 INS32 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS27 INS21 INS27 INS8 INS14 INS65 INS65 INS65 INS42 INS41 INS42 INS42 INS7 INS42 INS66 INS66 INS66 INS7 INS39 INS59 INS39 INS59 INS14 INS40 INS39 INS59 INS39 INS59 INS27 INS7 INS32 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS68 INS42 INS42 INS42 UPD42 INS68 INS42 INS42 INS42 INS42 INS34 INS7 INS27 INS27 INS21 INS43 INS52 INS32 INS32 INS66 INS66 INS42 INS32 INS42 INS14 INS42 INS14 INS42 INS32 INS42 INS16 INS43 INS42 INS27 INS42 INS32 INS42 INS16 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS42 INS69 INS69 INS42 INS34 INS42 INS34 INS42 INS32 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS42 INS74 INS42 INS42 INS42 INS42 INS36 INS34 INS32 INS40 INS42 INS42 INS42 INS42 INS36 INS34 INS32 INS42 INS42 INS42 INS42 INS5 INS5 INS43 INS43 INS42 INS42 INS32 INS43 INS43 INS21 INS21 INS43 INS43 INS27 INS42 INS42 INS27 INS27 INS42 INS42 INS27 INS39 INS85 INS39 INS85 INS42 INS42 INS42 INS42 INS42 INS7 INS32 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS32 INS42 INS42 INS42 INS42 INS42
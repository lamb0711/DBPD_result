HDFS-3950. QJM: misc TODO cleanup, improved log messages, etc. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1387704 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.ipc.Server;
+
+  /**
+   * Each IPC that comes from a given client contains a serial number
+   * which only increases from the client's perspective. Whenever
+   * we switch epochs, we reset this back to -1. Whenever an IPC
+   * comes from a client, we ensure that it is strictly higher
+   * than any previous IPC. This guards against any bugs in the IPC
+   * layer that would re-order IPCs or cause a stale retry from an old
+   * request to resurface and confuse things.
+   */
+  private long currentEpochIpcSerial = -1;
-    
+
+    // Check that the new epoch being proposed is in fact newer than
+    // any other that we've promised. 
-    lastPromisedEpoch.set(epoch);
+    updateLastPromisedEpoch(epoch);
+  private void updateLastPromisedEpoch(long newEpoch) throws IOException {
+    LOG.info("Updating lastPromisedEpoch from " + lastPromisedEpoch.get() +
+        " to " + newEpoch + " for client " + Server.getRemoteIp());
+    lastPromisedEpoch.set(newEpoch);
+    
+    // Since we have a new writer, reset the IPC serial - it will start
+    // counting again from 0 for this writer.
+    currentEpochIpcSerial = -1;
+  }
+
+    } else if (reqInfo.getEpoch() > lastPromisedEpoch.get()) {
+      // A newer client has arrived. Fence any previous writers by updating
+      // the promise.
+      updateLastPromisedEpoch(reqInfo.getEpoch());
-    // TODO: should other requests check the _exact_ epoch instead of
-    // the <= check? <= should probably only be necessary for the
-    // first calls
-    
-    // TODO: some check on serial number that they only increase from a given
-    // client
+    // Ensure that the IPCs are arriving in-order as expected.
+    checkSync(reqInfo.getIpcSerialNumber() > currentEpochIpcSerial,
+        "IPC serial %s from client %s was not higher than prior highest " +
+        "IPC serial %s", reqInfo.getIpcSerialNumber(),
+        Server.getRemoteIp(),
+        currentEpochIpcSerial);
+    currentEpochIpcSerial = reqInfo.getIpcSerialNumber();
+   * @throws AssertionError if the given expression is not true.
+   * The message of the exception is formatted using the 'msg' and
+   * 'formatArgs' parameters.
+   * 
+   * This should be used in preference to Java's built-in assert in
+   * non-performance-critical paths, where a failure of this invariant
+   * might cause the protocol to lose data. 
+   */
+  private void alwaysAssert(boolean expression, String msg,
+      Object... formatArgs) {
+    if (!expression) {
+      throw new AssertionError(String.format(msg, formatArgs));
+    }
+  }
+  
+  /**
-      LOG.info("Recording lastWriterEpoch = " + reqInfo.getEpoch());
+      LOG.info("Updating lastWriterEpoch from " + curLastWriterEpoch +
+          " to " + reqInfo.getEpoch() + " for client " +
+          Server.getRemoteIp());
-    // TODO: right now, a recovery of a segment when the log is
-    // completely emtpy (ie startLogSegment() but no txns)
-    // will fail this assertion here, since endTxId < startTxId
+    // Basic sanity checks that the segment is well-formed and contains
+    // at least one transaction.
+    
+    // If we previously acted on acceptRecovery() from a higher-numbered writer,
+    // this call is out of sync. We should never actually trigger this, since the
+    // checkRequest() call above should filter non-increasing epoch numbers.
-      Preconditions.checkState(oldData.getAcceptedInEpoch() <= reqInfo.getEpoch(),
+      alwaysAssert(oldData.getAcceptedInEpoch() <= reqInfo.getEpoch(),
+        // Another paranoid check: we should not be asked to synchronize a log
+        // on top of a finalized segment.
+        alwaysAssert(currentSegment.getIsInProgress(),
+            "Should never be asked to synchronize a different log on top of an " +
+            "already-finalized segment");
+        

INS26 INS40 INS23 INS31 INS31 INS29 INS83 INS39 INS59 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS65 INS42 INS38 INS39 INS42 INS42 INS21 INS21 INS21 INS21 INS21 INS65 INS39 INS42 INS43 INS42 INS43 INS42 INS25 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS34 INS32 INS32 INS7 INS25 INS32 INS7 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS38 INS8 UPD42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS38 INS27 INS8 INS42 INS27 INS27 INS32 INS32 INS42 INS42 INS32 INS42 INS53 INS45 INS32 INS45 INS42 INS45 INS32 INS34 INS32 INS32 INS21 INS32 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS32 UPD42 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS42 UPD45 INS42 INS45 INS45 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS42 INS42 INS45 INS45 DEL42 DEL42
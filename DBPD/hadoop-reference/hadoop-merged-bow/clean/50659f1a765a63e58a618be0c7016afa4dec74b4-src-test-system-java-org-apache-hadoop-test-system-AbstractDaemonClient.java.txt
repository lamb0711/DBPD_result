HADOOP-6977. Herriot daemon clients should vend statistics. Contributed by Konstantin Boudnik


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1033812 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.ArrayList;
-import java.util.ConcurrentModificationException;
-import java.util.List;
+import java.util.*;
+
-import org.apache.hadoop.fs.FileSystem;
+
+import javax.management.*;
+import javax.management.remote.JMXConnector;
+import javax.management.remote.JMXConnectorFactory;
+import javax.management.remote.JMXServiceURL;
+
+  private Boolean jmxEnabled = null;
+  private MBeanServerConnection connection;
+  private int jmxPortNumber = -1;
-  
+  private static final String HADOOP_JMX_DOMAIN = "Hadoop";
+  private static final String HADOOP_OPTS_ENV = "HADOOP_OPTS";
+
-   * @throws IOException
+   * @throws IOException in case of communication errors
+   * Abstract method to retrieve the name of a daemon specific env. var
+   * @return name of Hadoop environment variable containing a daemon options
+   */
+  abstract public String getHadoopOptsEnvName ();
+
+  /**
+   * Checks remote daemon process info to see if certain JMX sys. properties
+   * are available and reckon if the JMX service is enabled on the remote side
+   *
+   * @return <code>boolean</code> code indicating availability of remote JMX
+   * @throws IOException is throws in case of communication errors
+   */
+  public boolean isJmxEnabled() throws IOException {
+    return isJmxEnabled(HADOOP_OPTS_ENV) ||
+        isJmxEnabled(getHadoopOptsEnvName());
+  }
+
+  /**
+   * Checks remote daemon process info to see if certain JMX sys. properties
+   * are available and reckon if the JMX service is enabled on the remote side
+   *
+   * @param envivar name of an evironment variable to be searched
+   * @return <code>boolean</code> code indicating availability of remote JMX
+   * @throws IOException is throws in case of communication errors
+   */
+  protected boolean isJmxEnabled(String envivar) throws IOException {
+    if (jmxEnabled != null) return jmxEnabled;
+    boolean ret = false;
+    String jmxRemoteString = "-Dcom.sun.management.jmxremote";
+    String hadoopOpts = getProcessInfo().getEnv().get(envivar);
+    LOG.debug("Looking into " + hadoopOpts + " from " + envivar);
+    List<String> options = Arrays.asList(hadoopOpts.split(" "));
+    ret = options.contains(jmxRemoteString);
+    jmxEnabled = ret;
+    return ret;
+  }
+
+  /**
+   * Checks remote daemon process info to find remote JMX server port number
+   * By default this method will look into "HADOOP_OPTS" variable only.
+   * @return number of remote JMX server or -1 if it can't be found
+   * @throws IOException is throws in case of communication errors
+   * @throws IllegalArgumentException if non-integer port is set
+   *  in the remote process info
+   */
+  public int getJmxPortNumber() throws IOException, IllegalArgumentException {
+    int portNo = getJmxPortNumber(HADOOP_OPTS_ENV);
+    return portNo != -1 ? portNo : getJmxPortNumber(getHadoopOptsEnvName());
+  }
+
+  /**
+   * Checks remote daemon process info to find remote JMX server port number
+   *
+   * @param envivar name of the env. var. to look for JMX specific settings
+   * @return number of remote JMX server or -1 if it can't be found
+   * @throws IOException is throws in case of communication errors
+   * @throws IllegalArgumentException if non-integer port is set
+   *  in the remote process info
+   */
+  protected int getJmxPortNumber(final String envivar) throws
+      IOException, IllegalArgumentException {
+    if (jmxPortNumber != -1) return jmxPortNumber;
+    String jmxPortString = "-Dcom.sun.management.jmxremote.port";
+
+    String hadoopOpts = getProcessInfo().getEnv().get(envivar);
+    int portNumber = -1;
+    boolean found = false;
+    String[] options = hadoopOpts.split(" ");
+     for (String option : options) {
+       if (option.startsWith(jmxPortString)) {
+         found = true;
+         try {
+           portNumber = Integer.parseInt(option.split("=")[1]);
+         } catch (NumberFormatException e) {
+           throw new IllegalArgumentException("JMX port number isn't integer");
+         }
+         break;
+       }
+     }
+     if (!found)
+       throw new IllegalArgumentException("Can't detect JMX port number");
+    jmxPortNumber = portNumber;
+    return jmxPortNumber;
+  }
+
+  /**
-   * @throws java.io.FileNotFoundException when the path does not exist;
-   *         IOException see specific implementation
+   * @throws IOException see specific implementation
-   * @throws IOException
+   * @throws IOException in case of communication errors
+
+  /**
+   * Builds correct name of JMX object name from given domain, service name, type
+   * @param domain JMX domain name
+   * @param serviceName of the service where MBean is registered (NameNode)
+   * @param typeName of the MXBean class
+   * @return ObjectName for requested MXBean of <code>null</code> if one wasn't
+   *    found
+   * @throws java.io.IOException in if object name is malformed
+   */
+  protected ObjectName getJmxBeanName(String domain, String serviceName,
+                                      String typeName) throws IOException {
+    if (domain == null)
+      domain = HADOOP_JMX_DOMAIN;
+
+    ObjectName jmxBean;
+    try {
+      jmxBean = new ObjectName(domain + ":service=" + serviceName +
+        ",name=" + typeName);
+    } catch (MalformedObjectNameException e) {
+      LOG.debug(e.getStackTrace());
+      throw new IOException(e);
+    }
+    return jmxBean;
+  }
+
+  /**
+   * Create connection with the remote JMX server at given host and port
+   * @param host name of the remote JMX server host
+   * @param port port number of the remote JXM server host
+   * @return instance of MBeanServerConnection or <code>null</code> if one
+   *    hasn't been established
+   * @throws IOException in case of comminication errors
+   */
+  protected MBeanServerConnection establishJmxConnection(String host, int port)
+    throws IOException {
+    if (connection != null) return connection;
+    String urlPattern = null;
+    try {
+      urlPattern = "service:jmx:rmi:///jndi/rmi://" +
+        host + ":" + port +
+        "/jmxrmi";
+      JMXServiceURL url = new JMXServiceURL(urlPattern);
+      JMXConnector connector = JMXConnectorFactory.connect(url, null);
+      connection = connector.getMBeanServerConnection();
+    } catch (java.net.MalformedURLException badURLExc) {
+      LOG.debug("bad url: " + urlPattern, badURLExc);
+      throw new IOException(badURLExc);
+    }
+    return connection;
+  }
+
+  Hashtable<String, ObjectName> jmxObjectNames =
+    new Hashtable<String, ObjectName>();
+
+  /**
+   * Method implements all logic for receiving a bean's attribute.
+   * If any initializations such as establishing bean server connections, etc.
+   * are need it will do it.
+   * @param serviceName name of the service where MBean is registered (NameNode)
+   * @param type name of the MXBean class
+   * @param attributeName name of the attribute to be retrieved
+   * @return Object value of the attribute or <code>null</code> if not found
+   * @throws IOException is thrown in case of any errors
+   */
+  protected Object getJmxAttribute (String serviceName,
+                                    String type,
+                                    String attributeName)
+    throws IOException {
+    Object retAttribute = null;
+    String domain = null;
+    if (isJmxEnabled()) {
+      try {
+        MBeanServerConnection conn =
+          establishJmxConnection(getHostName(),
+              getJmxPortNumber(HADOOP_OPTS_ENV));
+        for (String d : conn.getDomains()) {
+          if (d != null && d.startsWith(HADOOP_JMX_DOMAIN))
+            domain = d;
+        }
+        if (!jmxObjectNames.containsKey(type))
+          jmxObjectNames.put(type, getJmxBeanName(domain, serviceName, type));
+        retAttribute =
+          conn.getAttribute(jmxObjectNames.get(type), attributeName);
+      } catch (MBeanException e) {
+        LOG.debug(e.getStackTrace());
+        throw new IOException(e);
+      } catch (AttributeNotFoundException e) {
+        LOG.warn(e.getStackTrace());
+        throw new IOException(e);
+      } catch (InstanceNotFoundException e) {
+        LOG.warn(e.getStackTrace());
+        throw new IOException(e);
+      } catch (ReflectionException e) {
+        LOG.debug(e.getStackTrace());
+        throw new IOException(e);
+      }
+    }
+    return retAttribute;
+  }
+
+  /**
+   * This method has to be implemented by appropriate concrete daemon client
+   * e.g. DNClient, NNClient, etc.
+   * Concrete implementation has to provide names of the service and bean type
+   * @param attributeName name of the attribute to be retrieved
+   * @return Object value of the given attribute
+   * @throws IOException is thrown in case of communication errors
+   */
+  public abstract Object getDaemonAttribute (String attributeName)
+    throws IOException;

MOV26 MOV26 MOV26 INS26 UPD40 UPD40 UPD40 UPD40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS39 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS42 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS43 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS74 INS59 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS43 INS42 INS42 INS33 INS42 INS42 INS42 INS38 INS42 INS42 INS45 INS42 INS42 INS45 INS65 INS65 INS42 INS65 INS65 INS65 INS42 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS42 INS25 INS60 INS60 INS60 INS21 INS60 INS21 INS21 INS41 INS65 INS65 INS65 INS65 INS42 INS42 INS60 INS41 INS65 INS65 INS65 INS65 INS65 INS83 INS43 INS42 INS42 INS42 INS25 INS60 INS60 INS60 INS60 INS60 INS70 INS25 INS21 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS42 INS25 INS60 INS54 INS41 INS43 INS43 INS43 INS42 INS14 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS41 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS34 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS27 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS27 INS41 INS39 INS59 INS43 INS59 INS43 INS59 INS32 INS74 INS59 INS7 INS7 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS39 INS59 INS16 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS27 INS41 INS43 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS5 INS59 INS44 INS42 INS8 INS38 INS53 INS7 INS42 INS42 UPD66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS40 INS66 INS42 INS42 INS42 INS27 INS21 INS43 INS59 INS8 INS12 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS27 INS41 INS43 INS59 INS8 INS12 INS42 INS42 INS42 INS42 INS74 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS8 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS32 INS32 INS42 INS33 INS42 INS42 INS9 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS27 INS43 INS43 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS27 INS42 INS32 INS42 INS38 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS38 INS42 INS9 INS43 INS85 INS42 INS32 INS43 INS42 INS25 INS42 INS14 INS42 INS42 INS42 INS33 INS7 INS42 INS42 INS21 INS44 INS8 INS42 INS33 INS42 INS42 INS42 INS33 INS21 INS60 INS60 INS21 INS44 INS8 INS43 INS43 INS43 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS54 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS42 INS32 INS34 INS32 INS42 INS42 INS34 INS42 INS42 INS42 INS45 INS42 INS32 INS8 INS43 INS45 INS42 INS42 INS7 INS43 INS42 INS21 INS53 INS7 INS43 INS59 INS43 INS59 INS7 INS43 INS42 INS21 INS53 INS42 INS42 INS42 INS8 INS12 INS12 INS12 INS12 INS42 INS32 INS42 INS42 INS42 INS45 INS34 INS42 INS32 INS42 INS42 INS42 INS42 INS21 INS54 INS10 INS42 INS42 INS14 INS42 INS32 INS14 INS42 INS27 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS32 INS40 INS32 INS14 INS60 INS70 INS25 INS21 INS44 INS8 INS44 INS8 INS44 INS8 INS44 INS8 INS42 INS42 INS7 INS8 INS12 INS43 INS27 INS42 INS42 INS32 INS43 INS42 INS45 INS42 INS45 INS42 INS45 INS43 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS27 INS42 INS43 INS42 INS43 INS59 INS44 INS32 INS8 INS38 INS21 INS7 INS43 INS42 INS21 INS53 INS43 INS42 INS21 INS53 INS43 INS42 INS21 INS53 INS43 INS42 INS21 INS53 INS42 INS9 INS21 INS44 INS8 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS25 INS32 INS32 INS42 INS32 INS42 INS32 INS14 INS42 INS32 INS14 INS42 INS32 INS14 INS42 INS32 INS14 INS7 INS43 INS42 INS53 INS42 INS32 INS32 INS42 INS27 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS42 INS27 INS32 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS43 INS45 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 INS42 INS45 DEL40 DEL66
HDDS-1530. Freon support big files larger than 2GB and add --bufferSize and --validateWrites options. Contributed by Xudong Cao. (#830)


-import java.util.Arrays;
-import java.util.concurrent.ArrayBlockingQueue;
-import org.apache.commons.lang3.ArrayUtils;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.security.MessageDigest;
+  private byte[] keyValueBuffer = null;
+
+  private static final String DIGEST_ALGORITHM = "MD5";
+  // A common initial MesssageDigest for each key without its UUID
+  private MessageDigest commonInitialMD = null;
+
-  private int keySize = 10240;
+  private long keySize = 10240;
+
+  @Option(
+      names = "--validateWrites",
+      description = "Specifies whether to validate keys after writing"
+  )
+  private boolean validateWrites = false;
+
+  @Option(
+      names = "--bufferSize",
+      description = "Specifies the buffer size while writing",
+      defaultValue = "4096"
+  )
+  private int bufferSize = 4096;
-  private byte[] keyValue = null;
-
-  private boolean validateWrites;
-  private BlockingQueue<KeyValue> validationQueue;
+  private BlockingQueue<KeyValidate> validationQueue;
-    keyValue =
-        DFSUtil.string2Bytes(RandomStringUtils.randomAscii(keySize - 36));
+    keyValueBuffer = DFSUtil.string2Bytes(
+        RandomStringUtils.randomAscii(bufferSize));
+
+    // Compute the common initial digest for all keys without their UUID
+    if (validateWrites) {
+      commonInitialMD = DigestUtils.getDigest(DIGEST_ALGORITHM);
+      int uuidLength = UUID.randomUUID().toString().length();
+      keySize = Math.max(uuidLength, keySize);
+      for (long nrRemaining = keySize - uuidLength; nrRemaining > 0;
+          nrRemaining -= bufferSize) {
+        int curSize = (int)Math.min(bufferSize, nrRemaining);
+        commonInitialMD.update(keyValueBuffer, 0, curSize);
+      }
+    }
+    LOG.info("Buffer size: {} bytes", bufferSize);
-      validationQueue =
-          new ArrayBlockingQueue<>(numOfThreads);
+      validationQueue = new LinkedBlockingQueue<>();
-   * Returns the length of the common key value initialized.
-   *
-   * @return key value length initialized.
+   * Wrapper to hold ozone keyValidate entry.
-  @VisibleForTesting
-  long getKeyValueLength() {
-    return keyValue.length;
-  }
-
-  /**
-   * Wrapper to hold ozone key-value pair.
-   */
-  private static class KeyValue {
-
+  private static class KeyValidate {
-     * Bucket name associated with the key-value.
+     * Bucket name.
-    /**
-     * Key name associated with the key-value.
-     */
-    private String key;
-    /**
-     * Value associated with the key-value.
-     */
-    private byte[] value;
-     * Constructs a new ozone key-value pair.
-     *
-     * @param key   key part
-     * @param value value part
+     * Key name.
-    KeyValue(OzoneBucket bucket, String key, byte[] value) {
+    private String keyName;
+
+    /**
+     * Digest of this key's full value.
+     */
+    private byte[] digest;
+
+    /**
+     * Constructs a new ozone keyValidate.
+     *
+     * @param bucket    bucket part
+     * @param keyName   key part
+     * @param keyName   digest of this key's full value
+     */
+    KeyValidate(OzoneBucket bucket, String keyName, byte[] digest) {
-      this.key = key;
-      this.value = value;
+      this.keyName = keyName;
+      this.digest = digest;
-                  os.write(keyValue);
+                  for (long nrRemaining = keySize - randomValue.length;
+                        nrRemaining > 0; nrRemaining -= bufferSize) {
+                    int curSize = (int)Math.min(bufferSize, nrRemaining);
+                    os.write(keyValueBuffer, 0, curSize);
+                  }
-                byte[] value = ArrayUtils.addAll(keyValue, randomValue);
+                MessageDigest tmpMD = (MessageDigest)commonInitialMD.clone();
+                tmpMD.update(randomValue);
-                    new KeyValue(bucket, key, value));
+                    new KeyValidate(bucket, key, tmpMD.digest()));
-    private int keySize;
+    private long keySize;
+    private int bufferSize;
+      this.bufferSize = RandomKeyGenerator.this.bufferSize;
-    public int getKeySize() {
+    public long getKeySize() {
+    public int getBufferSize() {
+      return bufferSize;
+    }
+
-
-      while (!completed) {
-        try {
-          KeyValue kv = validationQueue.poll(5, TimeUnit.SECONDS);
-          if (kv != null) {
+      DigestUtils dig = new DigestUtils(DIGEST_ALGORITHM);
-            OzoneInputStream is = kv.bucket.readKey(kv.key);
-            byte[] value = new byte[kv.value.length];
-            int length = is.read(value);
+      while (true) {
+        if (completed && validationQueue.isEmpty()) {
+          return;
+        }
+
+        try {
+          KeyValidate kv = validationQueue.poll(5, TimeUnit.SECONDS);
+          if (kv != null) {
+            OzoneInputStream is = kv.bucket.readKey(kv.keyName);
+            dig.getMessageDigest().reset();
+            byte[] curDigest = dig.digest(is);
-            if (length == kv.value.length && Arrays.equals(value, kv.value)) {
+            if (MessageDigest.isEqual(kv.digest, curDigest)) {
-                  kv.bucket.getVolumeName(), kv.bucket, kv.key);
+                  kv.bucket.getVolumeName(), kv.bucket, kv.keyName);
-                  DigestUtils.md5Hex(kv.value),
-                  DigestUtils.md5Hex(value));
+                  kv.digest, curDigest);
+            is.close();
-  public void setKeySize(int keySize) {
+  public void setKeySize(long keySize) {

MOV26 MOV26 MOV23 MOV23 UPD40 UPD40 INS23 INS23 INS23 INS83 INS83 INS83 INS43 INS59 INS83 INS43 INS59 UPD39 INS77 INS77 INS83 INS39 INS59 UPD74 UPD42 INS23 INS31 UPD42 INS42 INS42 INS45 INS42 INS42 INS33 INS42 INS80 INS80 INS9 INS42 INS80 INS80 INS80 INS42 INS34 UPD43 INS25 INS21 UPD42 UPD39 INS83 INS39 INS59 UPD39 INS83 INS39 INS42 INS8 UPD39 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 UPD42 INS42 INS8 INS32 UPD66 UPD42 UPD42 INS65 UPD42 UPD42 INS42 INS21 INS41 INS60 UPD42 INS21 INS60 INS21 INS24 INS42 INS42 INS45 INS42 UPD66 UPD66 UPD66 UPD66 INS42 INS66 UPD42 UPD42 UPD66 INS7 INS42 INS43 INS59 INS9 INS7 INS39 INS59 INS7 INS58 INS27 INS7 INS8 UPD42 UPD42 INS22 INS22 INS42 INS42 INS14 INS25 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS39 INS59 INS42 INS34 INS42 INS42 INS60 INS21 UPD42 UPD42 INS52 INS42 INS52 INS42 INS43 INS42 INS27 INS8 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS39 INS59 INS32 UPD74 INS42 INS42 INS42 INS32 INS41 INS32 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS34 INS42 UPD43 INS42 INS42 UPD43 INS42 INS42 INS39 INS32 UPD42 UPD42 INS21 INS21 INS42 INS42 INS42 INS42 INS32 MOV5 INS32 INS32 INS32 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD40 MOV40 INS42 INS42 INS42 UPD40 INS42 INS42 UPD42 UPD42 UPD42 INS60 INS21 UPD40 UPD40 MOV40 UPD42 MOV42 INS8 INS43 INS59 INS32 INS24 MOV21 MOV21 INS42 INS42 INS11 UPD42 MOV42 UPD42 MOV42 MOV42 INS58 INS27 INS7 INS8 INS43 INS32 INS39 INS59 INS42 INS34 INS42 INS42 INS60 MOV21 INS42 INS42 INS42 UPD43 INS32 INS42 INS27 INS39 INS59 UPD42 INS42 INS42 INS42 INS40 INS42 INS11 UPD42 INS34 INS42 INS39 INS32 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL42 DEL34 DEL27 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL78 DEL39 DEL42 DEL40 DEL41 DEL8 DEL31 DEL8 DEL39 DEL85 DEL5 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL38 DEL39 DEL85 DEL5 DEL42 DEL40 DEL3 DEL59 DEL60 DEL39 DEL42 DEL40 DEL27 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32
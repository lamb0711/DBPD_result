YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.
YARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.
MAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.util.ShutdownHookManager;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
-   * Verify that that a service is in a given state.
-   * @param state the actual state a service is in
-   * @param expectedState the desired state
-   * @throws IllegalStateException if the service state is different from
-   * the desired state
-   */
-  public static void ensureCurrentState(Service.STATE state,
-                                        Service.STATE expectedState) {
-    if (state != expectedState) {
-      throw new IllegalStateException("For this operation, the " +
-                                          "current service state must be "
-                                          + expectedState
-                                          + " instead of " + state);
-    }
-  }
-
-  /**
-   * Initialize a service.
-   * <p/>
-   * The service state is checked <i>before</i> the operation begins.
-   * This process is <i>not</i> thread safe.
-   * @param service a service that must be in the state
-   *   {@link Service.STATE#NOTINITED}
-   * @param configuration the configuration to initialize the service with
-   * @throws RuntimeException on a state change failure
-   * @throws IllegalStateException if the service is in the wrong state
-   */
-
-  public static void init(Service service, Configuration configuration) {
-    Service.STATE state = service.getServiceState();
-    ensureCurrentState(state, Service.STATE.NOTINITED);
-    service.init(configuration);
-  }
-
-  /**
-   * Start a service.
-   * <p/>
-   * The service state is checked <i>before</i> the operation begins.
-   * This process is <i>not</i> thread safe.
-   * @param service a service that must be in the state 
-   *   {@link Service.STATE#INITED}
-   * @throws RuntimeException on a state change failure
-   * @throws IllegalStateException if the service is in the wrong state
-   */
-
-  public static void start(Service service) {
-    Service.STATE state = service.getServiceState();
-    ensureCurrentState(state, Service.STATE.INITED);
-    service.start();
-  }
-
-  /**
-   * Initialize then start a service.
-   * <p/>
-   * The service state is checked <i>before</i> the operation begins.
-   * This process is <i>not</i> thread safe.
-   * @param service a service that must be in the state 
-   *   {@link Service.STATE#NOTINITED}
-   * @param configuration the configuration to initialize the service with
-   * @throws RuntimeException on a state change failure
-   * @throws IllegalStateException if the service is in the wrong state
-   */
-  public static void deploy(Service service, Configuration configuration) {
-    init(service, configuration);
-    start(service);
-  }
-
-  /**
-      Service.STATE state = service.getServiceState();
-      if (state == Service.STATE.STARTED) {
-        service.stop();
-      }
+      service.stop();
+    return stopQuietly(LOG, service);
+  }
+
+  /**
+   * Stop a service; if it is null do nothing. Exceptions are caught and
+   * logged at warn level. (but not Throwables). This operation is intended to
+   * be used in cleanup operations
+   *
+   * @param log the log to warn at
+   * @param service a service; may be null
+   * @return any exception that was caught; null if none was.
+   * @see ServiceOperations#stopQuietly(Service)
+   */
+  public static Exception stopQuietly(Log log, Service service) {
-      LOG.warn("When stopping the service " + service.getName()
-                   + " : " + e,
+      log.warn("When stopping the service " + service.getName()
+               + " : " + e,
+
+
+  /**
+   * Class to manage a list of {@link ServiceStateChangeListener} instances,
+   * including a notification loop that is robust against changes to the list
+   * during the notification process.
+   */
+  public static class ServiceListeners {
+    /**
+     * List of state change listeners; it is final to guarantee
+     * that it will never be null.
+     */
+    private final List<ServiceStateChangeListener> listeners =
+      new ArrayList<ServiceStateChangeListener>();
+
+    /**
+     * Thread-safe addition of a new listener to the end of a list.
+     * Attempts to re-register a listener that is already registered
+     * will be ignored.
+     * @param l listener
+     */
+    public synchronized void add(ServiceStateChangeListener l) {
+      if(!listeners.contains(l)) {
+        listeners.add(l);
+      }
+    }
+
+    /**
+     * Remove any registration of a listener from the listener list.
+     * @param l listener
+     * @return true if the listener was found (and then removed)
+     */
+    public synchronized boolean remove(ServiceStateChangeListener l) {
+      return listeners.remove(l);
+    }
+
+    /**
+     * Reset the listener list
+     */
+    public synchronized void reset() {
+      listeners.clear();
+    }
+
+    /**
+     * Change to a new state and notify all listeners.
+     * This method will block until all notifications have been issued.
+     * It caches the list of listeners before the notification begins,
+     * so additions or removal of listeners will not be visible.
+     * @param service the service that has changed state
+     */
+    public void notifyListeners(Service service) {
+      //take a very fast snapshot of the callback list
+      //very much like CopyOnWriteArrayList, only more minimal
+      ServiceStateChangeListener[] callbacks;
+      synchronized (this) {
+        callbacks = listeners.toArray(new ServiceStateChangeListener[listeners.size()]);
+      }
+      //iterate through the listeners outside the synchronized method,
+      //ensuring that listener registration/unregistration doesn't break anything
+      for (ServiceStateChangeListener l : callbacks) {
+        l.stateChanged(service);
+      }
+    }
+  }
+

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS55 MOV8 MOV29 INS83 INS83 INS43 INS42 MOV44 INS8 INS29 INS44 INS29 INS83 INS83 INS42 INS23 MOV31 INS31 INS31 MOV31 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS65 INS29 INS83 INS83 INS74 INS59 UPD83 UPD42 MOV29 MOV83 UPD83 MOV83 UPD39 MOV39 UPD42 MOV42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 INS8 UPD42 INS8 MOV27 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS68 INS42 UPD66 MOV66 INS65 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS65 INS43 INS43 INS42 INS14 UPD43 UPD42 INS25 UPD65 UPD43 UPD42 INS41 INS65 MOV21 INS60 INS51 INS70 INS42 INS42 INS42 INS42 INS42 INS69 UPD42 MOV42 INS66 INS66 INS42 INS42 INS74 UPD66 UPD66 UPD66 UPD42 UPD66 UPD42 INS38 INS8 UPD66 UPD42 UPD66 UPD66 UPD42 INS32 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS5 INS59 INS52 INS8 INS44 INS42 INS8 INS43 INS43 INS43 INS32 MOV21 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS43 INS85 INS42 MOV21 INS43 INS42 MOV21 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS7 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS32 INS42 UPD42 UPD42 MOV42 INS42 INS3 INS5 INS32 INS43 INS85 UPD42 MOV42 INS42 INS42 DEL65 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL40 DEL43 DEL42 DEL44 DEL40 DEL43 DEL42 DEL44 DEL42 DEL42 DEL27 DEL43 DEL45 DEL45 DEL27 DEL42 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL40 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL8 DEL31 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL25 DEL8 DEL66 DEL40 DEL42 DEL67 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL40 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL66 DEL66 DEL66 DEL40 DEL42 DEL67 DEL65 DEL42 DEL66 DEL65 DEL42 DEL40 DEL42 DEL67 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL83 DEL42 DEL32 DEL43 DEL42 DEL44 DEL8
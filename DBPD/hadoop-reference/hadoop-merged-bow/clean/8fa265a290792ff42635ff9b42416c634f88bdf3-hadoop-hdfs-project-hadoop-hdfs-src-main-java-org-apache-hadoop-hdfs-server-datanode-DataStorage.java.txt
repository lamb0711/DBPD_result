HDFS-7443. Datanode upgrade to BLOCKID_BASED_LAYOUT fails if duplicate block files are present in the same volume (cmccabe)

+import com.google.common.collect.ComparisonChain;
+import java.util.Comparator;
+import java.util.LinkedList;
+import java.util.TreeMap;
-    public File src;
-    public File dst;
+    File src;
+    File dst;
-    public LinkArgs(File src, File dst) {
+    LinkArgs(File src, File dst) {
-    final List<LinkArgs> idBasedLayoutSingleLinks = Lists.newArrayList();
+    final ArrayList<LinkArgs> idBasedLayoutSingleLinks = Lists.newArrayList();
+
+    // Detect and remove duplicate entries.
+    final ArrayList<LinkArgs> duplicates =
+        findDuplicateEntries(idBasedLayoutSingleLinks);
+    if (!duplicates.isEmpty()) {
+      LOG.error("There are " + duplicates.size() + " duplicate block " +
+          "entries within the same volume.");
+      removeDuplicateEntries(idBasedLayoutSingleLinks, duplicates);
+    }
+
-  
+
+  /**
+   * Find duplicate entries with an array of LinkArgs.
+   * Duplicate entries are entries with the same last path component.
+   */
+  static ArrayList<LinkArgs> findDuplicateEntries(ArrayList<LinkArgs> all) {
+    // Find duplicates by sorting the list by the final path component.
+    Collections.sort(all, new Comparator<LinkArgs>() {
+      /**
+       * Compare two LinkArgs objects, such that objects with the same
+       * terminal source path components are grouped together.
+       */
+      @Override
+      public int compare(LinkArgs a, LinkArgs b) {
+        return ComparisonChain.start().
+            compare(a.src.getName(), b.src.getName()).
+            compare(a.src, b.src).
+            compare(a.dst, b.dst).
+            result();
+      }
+    });
+    final ArrayList<LinkArgs> duplicates = Lists.newArrayList();
+    Long prevBlockId = null;
+    boolean prevWasMeta = false;
+    boolean addedPrev = false;
+    for (int i = 0; i < all.size(); i++) {
+      LinkArgs args = all.get(i);
+      long blockId = Block.getBlockId(args.src.getName());
+      boolean isMeta = Block.isMetaFilename(args.src.getName());
+      if ((prevBlockId == null) ||
+          (prevBlockId.longValue() != blockId)) {
+        prevBlockId = blockId;
+        addedPrev = false;
+      } else if (isMeta == prevWasMeta) {
+        // If we saw another file for the same block ID previously,
+        // and it had the same meta-ness as this file, we have a
+        // duplicate.
+        duplicates.add(args);
+        if (!addedPrev) {
+          duplicates.add(all.get(i - 1));
+        }
+        addedPrev = true;
+      } else {
+        addedPrev = false;
+      }
+      prevWasMeta = isMeta;
+    }
+    return duplicates;
+  }
+
+  /**
+   * Remove duplicate entries from the list.
+   * We do this by choosing:
+   * 1. the entries with the highest genstamp (this takes priority),
+   * 2. the entries with the longest block files,
+   * 3. arbitrarily, if neither #1 nor #2 gives a clear winner.
+   *
+   * Block and metadata files form a pair-- if you take a metadata file from
+   * one subdirectory, you must also take the block file from that
+   * subdirectory.
+   */
+  private static void removeDuplicateEntries(ArrayList<LinkArgs> all,
+                                             ArrayList<LinkArgs> duplicates) {
+    // Maps blockId -> metadata file with highest genstamp
+    TreeMap<Long, List<LinkArgs>> highestGenstamps =
+        new TreeMap<Long, List<LinkArgs>>();
+    for (LinkArgs duplicate : duplicates) {
+      if (!Block.isMetaFilename(duplicate.src.getName())) {
+        continue;
+      }
+      long blockId = Block.getBlockId(duplicate.src.getName());
+      List<LinkArgs> prevHighest = highestGenstamps.get(blockId);
+      if (prevHighest == null) {
+        List<LinkArgs> highest = new LinkedList<LinkArgs>();
+        highest.add(duplicate);
+        highestGenstamps.put(blockId, highest);
+        continue;
+      }
+      long prevGenstamp =
+          Block.getGenerationStamp(prevHighest.get(0).src.getName());
+      long genstamp = Block.getGenerationStamp(duplicate.src.getName());
+      if (genstamp < prevGenstamp) {
+        continue;
+      }
+      if (genstamp > prevGenstamp) {
+        prevHighest.clear();
+      }
+      prevHighest.add(duplicate);
+    }
+
+    // Remove data / metadata entries that don't have the highest genstamp
+    // from the duplicates list.
+    for (Iterator<LinkArgs> iter = duplicates.iterator(); iter.hasNext(); ) {
+      LinkArgs duplicate = iter.next();
+      long blockId = Block.getBlockId(duplicate.src.getName());
+      List<LinkArgs> highest = highestGenstamps.get(blockId);
+      if (highest != null) {
+        boolean found = false;
+        for (LinkArgs high : highest) {
+          if (high.src.getParent().equals(duplicate.src.getParent())) {
+            found = true;
+            break;
+          }
+        }
+        if (!found) {
+          LOG.warn("Unexpectedly low genstamp on " +
+                   duplicate.src.getAbsolutePath() + ".");
+          iter.remove();
+        }
+      }
+    }
+
+    // Find the longest block files
+    // We let the "last guy win" here, since we're only interested in
+    // preserving one block file / metadata file pair.
+    TreeMap<Long, LinkArgs> longestBlockFiles = new TreeMap<Long, LinkArgs>();
+    for (LinkArgs duplicate : duplicates) {
+      if (Block.isMetaFilename(duplicate.src.getName())) {
+        continue;
+      }
+      long blockId = Block.getBlockId(duplicate.src.getName());
+      LinkArgs prevLongest = longestBlockFiles.get(blockId);
+      if (prevLongest == null) {
+        longestBlockFiles.put(blockId, duplicate);
+        continue;
+      }
+      long blockLength = duplicate.src.length();
+      long prevBlockLength = prevLongest.src.length();
+      if (blockLength < prevBlockLength) {
+        LOG.warn("Unexpectedly short length on " +
+            duplicate.src.getAbsolutePath() + ".");
+        continue;
+      }
+      if (blockLength > prevBlockLength) {
+        LOG.warn("Unexpectedly short length on " +
+            prevLongest.src.getAbsolutePath() + ".");
+      }
+      longestBlockFiles.put(blockId, duplicate);
+    }
+
+    // Remove data / metadata entries that aren't the longest, or weren't
+    // arbitrarily selected by us.
+    for (Iterator<LinkArgs> iter = all.iterator(); iter.hasNext(); ) {
+      LinkArgs args = iter.next();
+      long blockId = Block.getBlockId(args.src.getName());
+      LinkArgs bestDuplicate = longestBlockFiles.get(blockId);
+      if (bestDuplicate == null) {
+        continue; // file has no duplicates
+      }
+      if (!bestDuplicate.src.getParent().equals(args.src.getParent())) {
+        LOG.warn("Discarding " + args.src.getAbsolutePath() + ".");
+        iter.remove();
+      }
+    }
+  }
+

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS31 INS29 INS83 INS74 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS60 INS25 INS65 INS43 INS43 INS74 INS42 INS21 INS60 INS60 INS60 INS60 INS24 INS41 INS65 INS74 INS42 INS74 INS42 INS60 INS70 INS24 INS60 INS70 INS24 INS74 INS83 INS74 INS59 INS38 INS8 INS66 INS66 INS42 INS42 INS43 INS43 INS32 INS83 INS74 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS43 INS43 INS43 INS43 INS74 INS59 INS44 INS42 INS8 INS58 INS32 INS8 INS74 INS59 INS44 INS42 INS8 INS58 INS32 INS8 INS43 INS43 INS43 INS43 INS42 INS32 INS32 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS14 INS43 INS43 INS42 INS32 INS42 INS42 INS33 INS42 INS9 INS42 INS9 INS39 INS59 INS42 INS32 INS42 INS60 INS60 INS60 INS25 INS21 INS42 INS42 INS42 INS42 INS43 INS43 MOV74 INS42 INS14 INS43 INS42 INS25 INS60 INS60 INS25 INS60 INS60 INS25 INS25 INS21 INS74 INS59 INS42 INS42 INS60 INS60 INS60 INS25 INS43 INS43 INS43 INS42 INS14 INS43 INS42 INS25 INS60 INS60 INS25 INS60 INS60 INS25 INS25 INS21 INS74 INS59 INS42 INS42 INS60 INS60 INS60 INS25 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS74 INS1 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS43 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS25 INS7 INS42 INS42 INS74 INS42 INS38 INS8 INS39 INS59 INS74 INS59 INS27 INS8 INS39 INS59 INS39 INS59 INS27 INS8 INS27 INS8 INS32 INS43 INS43 INS42 INS32 INS43 INS59 INS39 INS59 INS74 INS59 INS27 INS8 INS42 INS42 INS42 INS74 INS42 INS32 INS8 INS39 INS59 INS43 INS59 INS27 INS8 INS39 INS59 INS39 INS59 INS27 INS8 INS27 INS8 INS32 INS43 INS43 INS42 INS32 INS43 INS59 INS39 INS59 INS43 INS59 INS27 INS8 INS38 INS8 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS43 INS31 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS36 INS36 INS21 INS21 INS27 INS8 INS8 INS42 INS42 INS43 INS43 INS74 INS32 INS18 INS42 INS32 INS43 INS43 INS42 INS32 INS42 INS33 INS60 INS21 INS21 INS18 INS42 INS32 INS42 INS32 INS42 INS42 INS18 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS43 INS43 INS42 INS32 INS42 INS33 INS60 INS70 INS25 INS43 INS43 INS43 INS42 INS42 INS32 INS18 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS18 INS42 INS32 INS42 INS32 INS42 INS42 INS21 INS18 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS18 INS32 INS21 INS21 INS45 INS32 INS45 INS45 INS42 INS42 INS29 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS27 INS27 INS7 INS7 INS42 INS42 INS21 INS25 INS21 INS21 INS42 INS42 INS43 INS43 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS74 INS59 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS39 INS59 INS44 INS42 INS8 INS38 INS8 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS40 INS42 INS40 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS32 INS42 INS42 INS65 INS42 INS43 INS42 INS43 INS42 INS41 INS40 INS42 INS40 INS42 INS42 INS33 INS32 INS42 INS42 INS42 INS42 INS9 INS32 INS38 INS8 INS7 INS7 INS42 INS42 INS40 INS42 INS40 INS42 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS42 INS9 INS43 INS42 INS25 INS42 INS21 INS21 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS40 INS42 INS40 INS42 INS40 INS42 INS42 INS42 INS27 INS42 INS42 INS66 INS66 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS9 INS42 INS9 INS42 INS42 INS74 INS32 INS42 INS42 INS32 INS8 INS32 INS32 INS45 INS32 INS45 INS45 INS32 INS45 INS45 INS32 INS45 INS32 INS42 INS32 INS43 INS43 INS42 INS42 INS34 INS32 INS42 INS32 INS21 INS10 INS42 INS42 INS27 INS42 INS42 INS40 INS42 INS40 INS42 INS40 INS42 INS32 INS42 INS40 INS40 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS40 INS42 INS7 INS45 INS32 INS45 INS32 INS42 INS40 INS40 INS42 INS42 INS27 INS42 INS9 INS40 INS42 INS32 INS42 INS32 INS32 INS42 INS34 INS42 INS42 INS40 INS42 INS40 INS42 DEL83 DEL83 DEL83
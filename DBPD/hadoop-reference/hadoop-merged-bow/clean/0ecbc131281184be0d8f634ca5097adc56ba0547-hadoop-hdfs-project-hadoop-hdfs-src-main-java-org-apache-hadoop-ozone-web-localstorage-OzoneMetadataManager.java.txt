HDFS-10278. Ozone: Add paging support to list Volumes. Contributed by Anu Engineer.

-import org.apache.hadoop.hdfs.server.datanode.fsdataset.LengthInputStream;
-import org.apache.hadoop.ozone.web.handlers.ListArgs;
-import org.apache.hadoop.ozone.web.response.KeyInfo;
-import org.apache.hadoop.ozone.web.response.ListKeys;
-import org.slf4j.LoggerFactory;
-import org.slf4j.Logger;
+import com.google.common.base.Preconditions;
+import org.apache.commons.codec.digest.DigestUtils;
+import org.apache.hadoop.hdfs.server.datanode.fsdataset.LengthInputStream;
+import org.apache.hadoop.ozone.OzoneConsts;
+import org.apache.hadoop.ozone.web.handlers.ListArgs;
+import org.apache.hadoop.ozone.web.response.KeyInfo;
+import org.apache.hadoop.ozone.web.response.ListKeys;
-import org.apache.hadoop.ozone.OzoneConsts;
-import org.apache.commons.codec.digest.DigestUtils;
+import org.iq80.leveldb.DBIterator;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.io.FileOutputStream;
-import java.io.FileOutputStream;
-  public ListVolumes listVolumes(UserArgs args) throws OzoneException {
+  public ListVolumes listVolumes(ListArgs args) throws OzoneException {
-      byte[] volumeList = userDB.get(args.getUserName().getBytes(encoding));
-      if (volumeList == null) {
-        throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, args);
+      Preconditions.checkState(args.getArgs() instanceof UserArgs);
+
+      if (args.isRootScan()) {
+        return listAllVolumes(args);
-      return ListVolumes.parse(new String(volumeList, encoding));
+
+      UserArgs uArgs = (UserArgs) args.getArgs();
+      byte[] volumeList = userDB.get(uArgs.getUserName().getBytes(encoding));
+      if (volumeList == null) {
+        throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, uArgs);
+      }
+
+      String prefix = args.getPrefix();
+      int maxCount = args.getMaxKeys();
+      String prevKey = args.getPrevKey();
+      if (prevKey != null) {
+        // Format is username/volumeName, in local mode we don't use the
+        // user name since we have a userName DB.
+        String[] volName = args.getPrevKey().split("/");
+        if (volName.length < 2) {
+          throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, uArgs);
+        }
+        prevKey = volName[1];
+      }
+      return getFilteredVolumes(volumeList, prefix, prevKey, maxCount);
-      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args, ex);
+      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args.getArgs(), ex);
+   * Returns a List of Volumes that meet the prefix, prevkey and maxCount
+   * constraints.
+   *
+   * @param volumeList - Byte Array of Volume Info.
+   * @param prefix     - prefix string.
+   * @param prevKey    - PrevKey
+   * @param maxCount   - Maximum Count.
+   * @return ListVolumes.
+   * @throws IOException
+   */
+  private ListVolumes getFilteredVolumes(byte[] volumeList, String prefix,
+                                         String prevKey, int maxCount) throws
+      IOException {
+    ListVolumes volumes = ListVolumes.parse(new String(volumeList,
+        encoding));
+    int currentCount = 0;
+    ListIterator<VolumeInfo> iter = volumes.getVolumes().listIterator();
+    ListVolumes filteredVolumes = new ListVolumes();
+    while (currentCount < maxCount && iter.hasNext()) {
+      VolumeInfo vInfo = iter.next();
+      if (isMatchingPrefix(prefix, vInfo) && isAfterKey(prevKey, vInfo)) {
+        filteredVolumes.addVolume(vInfo);
+        currentCount++;
+      }
+    }
+    return filteredVolumes;
+  }
+
+  /**
+   * Returns all volumes in a cluster.
+   *
+   * @param args - ListArgs.
+   * @return ListVolumes.
+   * @throws OzoneException
+   */
+  public ListVolumes listAllVolumes(ListArgs args) throws OzoneException,
+      IOException {
+    String prefix = args.getPrefix();
+    String prevKey = args.getPrevKey();
+    int maxCount = args.getMaxKeys();
+    String userName = null;
+    DBIterator iterator = this.userDB.getDB().iterator();
+
+    if (prevKey != null) {
+      // Format is username/volumeName
+
+      String[] volName = args.getPrevKey().split("/");
+      if (volName.length < 2) {
+        throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, args.getArgs());
+      }
+      seekToUser(iterator, volName[0]);
+      userName = new String(iterator.peekNext().getKey(), encoding);
+      prevKey = volName[1];
+    } else {
+      userName = getFirstUser(iterator);
+    }
+
+    if (userName == null || userName.isEmpty()) {
+      throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, args.getArgs());
+    }
+
+    ListVolumes returnSet = new ListVolumes();
+    int count = maxCount - returnSet.getVolumes().size();
+
+    // we need to iterate through users until we get maxcount volumes
+    // or no more volumes are left.
+    while (iterator.hasNext() && count > 0) {
+
+      userName = new String(iterator.next().getKey(), encoding);
+
+      byte[] volumeList = userDB.get(userName.getBytes(encoding));
+      if (volumeList == null) {
+        throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, args.getArgs());
+      }
+
+      returnSet.getVolumes().addAll(
+          getFilteredVolumes(volumeList, prefix, prevKey, count).getVolumes());
+      count = maxCount - returnSet.getVolumes().size();
+    }
+    return returnSet;
+  }
+
+  /**
+   * Returns the first user name from the UserDB.
+   *
+   * @return - UserName.
+   * @throws IOException
+   */
+  String getFirstUser(DBIterator iterator) throws IOException {
+    iterator.seekToFirst();
+    if (iterator.hasNext()) {
+      return new String(iterator.peekNext().getKey(), encoding);
+    }
+    return null;
+  }
+
+  /**
+   * Reposition the DB cursor to the user name.
+   *
+   * @param iterator - Current Iterator.
+   * @param userName - userName to seek to
+   * @return - DBIterator.
+   * @throws IOException
+   */
+  DBIterator seekToUser(DBIterator iterator, String userName) throws
+      IOException {
+    iterator.seek(userName.getBytes(encoding));
+    return iterator;
+  }
+
+  /**
+   * Checks if a name starts with a matching prefix.
+   *
+   * @param prefix - prefix string.
+   * @param vInfo  - volume info.
+   * @return true or false.
+   */
+  private boolean isMatchingPrefix(String prefix, VolumeInfo vInfo) {
+    if (prefix == null || prefix.isEmpty()) {
+      return true;
+    }
+    return vInfo.getVolumeName().startsWith(prefix);
+  }
+
+  /**
+   * Checks if the key is after the prevKey.
+   *
+   * @param prevKey - String prevKey.
+   * @param vInfo   - volume Info.
+   * @return - true or false.
+   */
+  private boolean isAfterKey(String prevKey, VolumeInfo vInfo) {
+    if (prevKey == null || prevKey.isEmpty()) {
+      return true;
+    }
+    return prevKey.compareTo(vInfo.getVolumeName()) < 0;
+  }
+
+  /**
-  public ListBuckets listBuckets(VolumeArgs args) throws OzoneException {
+  public ListBuckets listBuckets(ListArgs args) throws OzoneException {
-      String userVolKey = args.getUserName() + "/" + args.getVolumeName();
+      Preconditions.checkState(args.getArgs() instanceof VolumeArgs);
+      VolumeArgs vArgs = (VolumeArgs) args.getArgs();
+      String userVolKey = vArgs.getUserName() + "/" + vArgs.getVolumeName();
+      // TODO : Query using Prefix and PrevKey
-        throw ErrorTable.newError(ErrorTable.INVALID_VOLUME_NAME, args);
+        throw ErrorTable.newError(ErrorTable.INVALID_VOLUME_NAME,
+            args.getArgs());
-      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args, ex);
+      throw ErrorTable.newError(ErrorTable.SERVER_ERROR, args.getArgs(), ex);
-   *  Creates a key and returns a stream to which this key can be written to.
-   * @param args  KeyArgs
+   * Creates a key and returns a stream to which this key can be written to.
+   *
+   * @param args KeyArgs
-        if(!f.delete()) {
+        if (!f.delete()) {
-     // f.createNewFile();
+      // f.createNewFile();
-
-   * commit keys moves an In progress object into the metadata store
-   * so that key is visible in the metadata operations from that point
-   * onwards.
+   * commit keys moves an In progress object into the metadata store so that key
+   * is visible in the metadata operations from that point onwards.
-   *
-              bInfo.toDBString().getBytes(encoding));
+          bInfo.toDBString().getBytes(encoding));
-   *
-        if(!f.delete()) {
+        if (!f.delete()) {
-              bInfo.toDBString().getBytes(encoding));
+          bInfo.toDBString().getBytes(encoding));
-   *
-   *
+   *
-   * @return  List of keys.
+   * @return List of keys.
+    // TODO : Support Prefix and PrevKey lookup.
-      byte[] bucketInfo = metadataDB.get(args.getResourceName()
+      Preconditions.checkState(args.getArgs() instanceof BucketArgs);
+      BucketArgs bArgs = (BucketArgs) args.getArgs();
+      byte[] bucketInfo = metadataDB.get(bArgs.getResourceName()
-        throw ErrorTable.newError(ErrorTable.INVALID_BUCKET_NAME, args);
+        throw ErrorTable.newError(ErrorTable.INVALID_BUCKET_NAME, bArgs);
-      byte[] bucketListBytes = userDB.get(args.getResourceName()
+      byte[] bucketListBytes = userDB.get(bArgs.getResourceName()
-        throw ErrorTable.newError(ErrorTable.INVALID_BUCKET_NAME, args);
+        throw ErrorTable.newError(ErrorTable.INVALID_BUCKET_NAME, bArgs);

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS43 INS8 INS29 INS43 INS42 INS44 INS43 INS8 INS29 INS43 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS43 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS5 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS60 INS60 INS60 INS60 INS61 INS41 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS25 INS25 INS60 INS60 INS61 INS41 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS21 INS25 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS21 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS25 INS41 INS65 INS65 INS65 INS65 MOV43 INS42 INS43 INS42 INS25 INS41 INS43 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS39 INS85 INS42 INS42 INS43 INS59 INS39 INS59 INS74 INS59 INS43 INS59 INS27 INS8 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS39 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS27 INS8 INS43 INS59 INS39 INS59 INS27 INS8 INS42 INS66 INS66 INS42 INS42 INS32 INS32 INS8 INS33 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS32 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS27 INS42 UPD66 UPD66 UPD66 UPD66 INS21 INS25 INS60 INS60 INS60 INS60 INS25 INS42 INS42 MOV32 INS42 INS34 INS43 INS43 INS42 INS32 INS42 INS42 INS14 INS27 INS32 INS60 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS21 INS21 INS21 INS21 INS27 INS32 INS53 INS42 INS42 INS14 INS42 INS27 INS32 INS27 INS21 INS60 INS25 INS21 INS21 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS32 INS27 INS32 INS41 INS32 INS42 INS42 INS27 INS32 INS41 INS32 INS34 INS21 INS60 INS21 INS60 INS32 INS32 INS8 MOV43 INS59 INS43 INS59 INS39 INS59 INS43 INS59 INS27 INS8 INS32 INS42 INS42 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS5 INS59 INS27 INS8 INS32 INS7 INS7 INS7 INS42 INS33 INS42 INS42 INS32 INS43 INS42 INS32 INS42 INS42 INS42 INS34 INS7 INS5 INS59 INS27 INS8 INS32 INS7 INS14 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS9 INS42 INS42 INS42 INS33 INS42 INS42 INS9 INS42 INS42 INS32 INS32 MOV43 INS59 INS43 INS32 INS43 INS59 MOV5 MOV5 INS42 INS42 INS62 INS42 INS42 INS41 INS42 INS11 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS21 INS21 INS22 INS42 INS43 INS85 INS42 INS32 INS40 INS34 INS53 INS42 INS42 INS2 INS42 INS14 INS42 INS2 INS42 INS32 INS42 INS42 INS40 INS32 INS42 INS32 INS42 INS42 INS14 INS39 INS85 INS42 INS32 INS42 INS33 INS53 INS32 INS42 INS32 INS42 INS27 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS62 INS42 INS11 INS42 INS42 INS42 INS62 INS42 INS42 INS11 INS32 INS43 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS59 INS27 INS8 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS37 INS52 INS42 INS42 INS32 INS42 INS45 INS32 INS42 INS34 INS43 INS32 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS43 INS43 INS32 INS32 INS32 INS43 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS43 INS85 INS42 INS32 INS40 INS34 INS53 INS42 INS2 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS32 INS42 INS45 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS40 INS42 DEL66
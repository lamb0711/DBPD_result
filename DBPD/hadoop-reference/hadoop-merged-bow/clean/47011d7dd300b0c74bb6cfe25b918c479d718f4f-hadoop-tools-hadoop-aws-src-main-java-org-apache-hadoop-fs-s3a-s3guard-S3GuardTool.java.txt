HADOOP-14220 Enhance S3GuardTool with bucket-info and set-capacity commands, tests. Contributed by Steve Loughran

+import org.apache.commons.lang.StringUtils;
-import org.apache.hadoop.fs.s3a.Constants;
+import org.apache.hadoop.fs.s3a.S3AUtils;
+import org.apache.hadoop.util.ExitUtil;
+import static org.apache.hadoop.service.launcher.LauncherExitCodes.*;
+      "\t" + BucketInfo.NAME + " - " + BucketInfo.PURPOSE + "\n" +
-      "\t" + Prune.NAME + " - " + Prune.PURPOSE + "\n";
+      "\t" + Prune.NAME + " - " + Prune.PURPOSE + "\n" +
+      "\t" + SetCapacity.NAME + " - " +SetCapacity.PURPOSE + "\n";
-      = "(all data in S3 is preserved";
+      = "(all data in S3 is preserved)";
-  static final int SUCCESS = 0;
-  static final int INVALID_ARGUMENT = 1;
-  static final int ERROR = 99;
+  static final int SUCCESS = EXIT_SUCCESS;
+  static final int INVALID_ARGUMENT = EXIT_COMMAND_ARGUMENT_ERROR;
+  static final int E_USAGE = EXIT_USAGE;
+  static final int ERROR = EXIT_FAIL;
+  static final int E_BAD_STATE = EXIT_NOT_ACCEPTABLE;
+  static final int E_NOT_FOUND = EXIT_NOT_FOUND;
-  private static final String META_FLAG = "meta";
-  private static final String DAYS_FLAG = "days";
-  private static final String HOURS_FLAG = "hours";
-  private static final String MINUTES_FLAG = "minutes";
-  private static final String SECONDS_FLAG = "seconds";
+  public static final String META_FLAG = "meta";
+  public static final String DAYS_FLAG = "days";
+  public static final String HOURS_FLAG = "hours";
+  public static final String MINUTES_FLAG = "minutes";
+  public static final String SECONDS_FLAG = "seconds";
-  private static final String REGION_FLAG = "region";
-  private static final String READ_FLAG = "read";
-  private static final String WRITE_FLAG = "write";
+  public static final String REGION_FLAG = "region";
+  public static final String READ_FLAG = "read";
+  public static final String WRITE_FLAG = "write";
+   * @param opts any boolean options to support
-  protected S3GuardTool(Configuration conf) {
+  protected S3GuardTool(Configuration conf, String...opts) {
-    commandFormat = new CommandFormat(0, Integer.MAX_VALUE);
+    commandFormat = new CommandFormat(0, Integer.MAX_VALUE, opts);
-   * @return false for invalid parameters.
+   * @throws ExitUtil.ExitException on validation errors
-  boolean parseDynamoDBRegion(List<String> paths) throws IOException {
+  void parseDynamoDBRegion(List<String> paths) throws IOException {
-        System.err.println("No region provided with -" + REGION_FLAG + " flag");
-        return false;
+        throw invalidArgs("No region provided with -" + REGION_FLAG + " flag");
-        System.err.println("Providing both an S3 path and the -" + REGION_FLAG
+        throw invalidArgs("Providing both an S3 path and the"
+            + " -" + REGION_FLAG
-        return false;
-      return true;
+      return;
-        System.err.printf("No region provided with config %s, %n",
+        throw invalidArgs("No region provided with config %s",
-        return false;
-      return true;
+      return;
-      return true;
+      return;
-    System.err.println("No region found from -" + REGION_FLAG + " flag, " +
+    throw invalidArgs("No region found from -" + REGION_FLAG + " flag, " +
-    return false;
-      LOG.info("create metadata store: {}", uri + " scheme: "
+      LOG.info("Create metadata store: {}", uri + " scheme: "
-   * Initialize S3A FileSystem instance.
+   * Create and initialize a new S3A FileSystem instance.
+   * This instance is always created without S3Guard, so allowing
+   * a previously created metastore to be patched in.
+   *
+   * Note: this is a bit convoluted as it needs to also handle the situation
+   * of a per-bucket option in core-site.xml, which isn't easily overridden.
+   * The new config and the setting of the values before any
+   * {@code Configuration.get()} calls are critical.
-   * @throws IOException
+   * @throws IOException failure to init filesystem
+   * @throws ExitUtil.ExitException if the FS is not an S3A FS
-    URI uri;
-    try {
-      uri = new URI(path);
-    } catch (URISyntaxException e) {
-      throw new IOException(e);
-    }
+    URI uri = toUri(path);
-    Configuration conf = getConf();
-    conf.setClass(S3_METADATA_STORE_IMPL, NullMetadataStore.class,
-        MetadataStore.class);
-    FileSystem fs = FileSystem.get(uri, getConf());
+    Configuration conf = new Configuration(getConf());
+    String nullStore = NullMetadataStore.class.getName();
+    conf.set(S3_METADATA_STORE_IMPL, nullStore);
+    String bucket = uri.getHost();
+    S3AUtils.setBucketOption(conf,
+        bucket,
+        S3_METADATA_STORE_IMPL, S3GUARD_METASTORE_NULL);
+    String updatedBucketOption = S3AUtils.getBucketOption(conf, bucket,
+        S3_METADATA_STORE_IMPL);
+    LOG.debug("updated bucket store option {}", updatedBucketOption);
+    Preconditions.checkState(S3GUARD_METASTORE_NULL.equals(updatedBucketOption),
+        "Expected bucket option to be %s but was %s",
+        S3GUARD_METASTORE_NULL, updatedBucketOption);
+
+    FileSystem fs = FileSystem.newInstance(uri, conf);
-      throw new IOException(
-          String.format("URI %s is not a S3A file system: %s", uri,
-              fs.getClass().getName()));
+      throw invalidArgs("URI %s is not a S3A file system: %s",
+          uri, fs.getClass().getName());
-   * The options are stored in {@link #commandFormat}
+   * The options are stored in {@link #commandFormat}.
+  @Override
+  public final int run(String[] args) throws Exception {
+    return run(args, System.out);
+  }
+
+  /**
+   * Run the tool, capturing the output (if the tool supports that).
+   *
+   * As well as returning an exit code, the implementations can choose to
+   * throw an instance of {@link ExitUtil.ExitException} with their exit
+   * code set to the desired exit value. The exit code of auch an exception
+   * is used for the tool's exit code, and the stack trace only logged at
+   * debug.
+   * @param args argument list
+   * @param out output stream
+   * @return the exit code to return.
+   * @throws Exception on any failure
+   * @throws ExitUtil.ExitException for an alternative clean exit
+   */
+  public abstract int run(String[] args, PrintStream out) throws Exception;
+
-    private static final String NAME = "init";
+    public static final String NAME = "init";
-    public int run(String[] args) throws IOException {
+    public int run(String[] args, PrintStream out) throws Exception {
-      if (!parseDynamoDBRegion(paths)) {
-        System.err.println(USAGE);
-        return INVALID_ARGUMENT;
+      try {
+        parseDynamoDBRegion(paths);
+      } catch (ExitUtil.ExitException e) {
+        errorln(USAGE);
+        throw e;
-      initMetadataStore(true);
+      MetadataStore store = initMetadataStore(true);
+      printStoreDiagnostics(out, store);
+   * Change the capacity of the metadata store.
+   */
+  static class SetCapacity extends S3GuardTool {
+    public static final String NAME = "set-capacity";
+    public static final String PURPOSE = "Alter metadata store IO capacity";
+    private static final String USAGE = NAME + " [OPTIONS] [s3a://BUCKET]\n" +
+        "\t" + PURPOSE + "\n\n" +
+        "Common options:\n" +
+        "  -" + META_FLAG + " URL - Metadata repository details " +
+          "(implementation-specific)\n" +
+        "\n" +
+        "Amazon DynamoDB-specific options:\n" +
+        "  -" + READ_FLAG + " UNIT - Provisioned read throughput units\n" +
+        "  -" + WRITE_FLAG + " UNIT - Provisioned write through put units\n" +
+        "\n" +
+        "  URLs for Amazon DynamoDB are of the form dynamodb://TABLE_NAME.\n" +
+        "  Specifying both the -" + REGION_FLAG + " option and an S3A path\n" +
+        "  is not supported.";
+
+    SetCapacity(Configuration conf) {
+      super(conf);
+      // read capacity.
+      getCommandFormat().addOptionWithValue(READ_FLAG);
+      // write capacity.
+      getCommandFormat().addOptionWithValue(WRITE_FLAG);
+    }
+
+    @Override
+    String getName() {
+      return NAME;
+    }
+
+    @Override
+    public String getUsage() {
+      return USAGE;
+    }
+
+    @Override
+    public int run(String[] args, PrintStream out) throws Exception {
+      List<String> paths = parseArgs(args);
+      Map<String, String> options = new HashMap<>();
+
+      String readCap = getCommandFormat().getOptValue(READ_FLAG);
+      if (StringUtils.isNotEmpty(readCap)) {
+        S3GuardTool.println(out, "Read capacity set to %s", readCap);
+        options.put(S3GUARD_DDB_TABLE_CAPACITY_READ_KEY, readCap);
+      }
+      String writeCap = getCommandFormat().getOptValue(WRITE_FLAG);
+      if (StringUtils.isNotEmpty(writeCap)) {
+        S3GuardTool.println(out, "Write capacity set to %s", writeCap);
+        options.put(S3GUARD_DDB_TABLE_CAPACITY_WRITE_KEY, writeCap);
+      }
+
+      // Validate parameters.
+      try {
+        parseDynamoDBRegion(paths);
+      } catch (ExitUtil.ExitException e) {
+        errorln(USAGE);
+        throw e;
+      }
+      MetadataStore store = initMetadataStore(false);
+      store.updateParameters(options);
+      printStoreDiagnostics(out, store);
+      return SUCCESS;
+    }
+  }
+
+
+  /**
-    private static final String NAME = "destroy";
+    public static final String NAME = "destroy";
-    public int run(String[] args) throws IOException {
+    public int run(String[] args, PrintStream out) throws Exception {
-      if (!parseDynamoDBRegion(paths)) {
-        System.err.println(USAGE);
-        return INVALID_ARGUMENT;
+      try {
+        parseDynamoDBRegion(paths);
+      } catch (ExitUtil.ExitException e) {
+        errorln(USAGE);
+        throw e;
+        println(out, "Metadata Store does not exist.");
-        LOG.info("Metadata Store does not exist.");
-      LOG.info("Metadata store is deleted.");
+      println(out, "Metadata store is deleted.");
-    private static final String NAME = "import";
+    public static final String NAME = "import";
-    public int run(String[] args) throws IOException {
+    public int run(String[] args, PrintStream out) throws Exception {
-        System.err.println(getUsage());
-        return INVALID_ARGUMENT;
+        errorln(getUsage());
+        throw invalidArgs("no arguments");
-      URI uri;
-      try {
-        uri = new URI(s3Path);
-      } catch (URISyntaxException e) {
-        throw new IOException(e);
-      }
+      URI uri = toUri(s3Path);
-      initMetadataStore(false);
+      try {
+        initMetadataStore(false);
+      } catch (FileNotFoundException e) {
+        throw storeNotFound(e);
+      }
-      System.out.printf("Inserted %d items into Metadata Store%n", items);
+      println(out, "Inserted %d items into Metadata Store", items);
+
-    private static final String NAME = "diff";
+    public static final String NAME = "diff";
-          out.printf("%s%s%s%n", S3_PREFIX, SEP, formatFileStatus(s3Status));
+          println(out, "%s%s%s", S3_PREFIX, SEP, formatFileStatus(s3Status));
-          out.printf("%s%s%s%n", MS_PREFIX, SEP, formatFileStatus(msStatus));
+          println(out, "%s%s%s", MS_PREFIX, SEP, formatFileStatus(msStatus));
+        /* ignored */
-        return INVALID_ARGUMENT;
+        throw invalidArgs("no arguments");
-      initMetadataStore(true);
+      initMetadataStore(false);
-      URI uri;
-      try {
-        uri = new URI(s3Path);
-      } catch (URISyntaxException e) {
-        throw new IOException(e);
-      }
+      URI uri = toUri(s3Path);
-    @Override
-    public int run(String[] args) throws IOException {
-      return run(args, System.out);
-    }
-    private static final String NAME = "prune";
+    public static final String NAME = "prune";
-    @VisibleForTesting
-      if (!parseDynamoDBRegion(paths)) {
-        System.err.println(USAGE);
-        return INVALID_ARGUMENT;
+      try {
+        parseDynamoDBRegion(paths);
+      } catch (ExitUtil.ExitException e) {
+        errorln(USAGE);
+        throw e;
-      long confDelta = conf.getLong(Constants.S3GUARD_CLI_PRUNE_AGE, 0);
+      long confDelta = conf.getLong(S3GUARD_CLI_PRUNE_AGE, 0);
-        System.err.println(
-            "You must specify a positive age for metadata to prune.");
+        errorln("You must specify a positive age for metadata to prune.");
-    @Override
-    public int run(String[] args) throws InterruptedException, IOException {
-      return run(args, System.out);
+  }
+
+  /**
+   * Get info about a bucket and its S3Guard integration status.
+   */
+  static class BucketInfo extends S3GuardTool {
+    public static final String NAME = "bucket-info";
+    public static final String GUARDED_FLAG = "guarded";
+    public static final String UNGUARDED_FLAG = "unguarded";
+    public static final String AUTH_FLAG = "auth";
+    public static final String NONAUTH_FLAG = "nonauth";
+    public static final String ENCRYPTION_FLAG = "encryption";
+
+    public static final String PURPOSE = "provide/check S3Guard information"
+        + " about a specific bucket";
+    private static final String USAGE = NAME + " [OPTIONS] s3a://BUCKET\n"
+        + "\t" + PURPOSE + "\n\n"
+        + "Common options:\n"
+        + "  -" + GUARDED_FLAG + " - Require S3Guard\n"
+        + "  -" + ENCRYPTION_FLAG
+        + " -require {none, sse-s3, sse-kms} - Require encryption policy";
+
+    BucketInfo(Configuration conf) {
+      super(conf, GUARDED_FLAG, UNGUARDED_FLAG, AUTH_FLAG, NONAUTH_FLAG);
+      CommandFormat format = getCommandFormat();
+      format.addOptionWithValue(ENCRYPTION_FLAG);
+
+    @Override
+    String getName() {
+      return NAME;
+    }
+
+    @Override
+    public String getUsage() {
+      return USAGE;
+    }
+
+    public int run(String[] args, PrintStream out)
+        throws InterruptedException, IOException {
+      List<String> paths = parseArgs(args);
+      if (paths.isEmpty()) {
+        errorln(getUsage());
+        throw invalidArgs("No bucket specified");
+      }
+      String s3Path = paths.get(0);
+      S3AFileSystem fs = (S3AFileSystem) FileSystem.newInstance(
+          toUri(s3Path), getConf());
+      setFilesystem(fs);
+      Configuration conf = fs.getConf();
+      URI fsUri = fs.getUri();
+      MetadataStore store = fs.getMetadataStore();
+      println(out, "Filesystem %s", fsUri);
+      println(out, "Location: %s", fs.getBucketLocation());
+      boolean usingS3Guard = !(store instanceof NullMetadataStore);
+      boolean authMode = false;
+      if (usingS3Guard) {
+        out.printf("Filesystem %s is using S3Guard with store %s%n",
+            fsUri, store.toString());
+        printOption(out, "Authoritative S3Guard",
+            METADATASTORE_AUTHORITATIVE, "false");
+        authMode = conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);
+        printStoreDiagnostics(out, store);
+      } else {
+        println(out, "Filesystem %s is not using S3Guard", fsUri);
+      }
+      println(out, "%nS3A Client");
+
+      String endpoint = conf.getTrimmed(ENDPOINT, "");
+      println(out, "\tEndpoint: %s=%s",
+          ENDPOINT,
+          StringUtils.isNotEmpty(endpoint) ? endpoint : "(unset)");
+      String encryption =
+          printOption(out, "\tEncryption", SERVER_SIDE_ENCRYPTION_ALGORITHM,
+              "none");
+      printOption(out, "\tInput seek policy", INPUT_FADVISE, INPUT_FADV_NORMAL);
+
+      CommandFormat commands = getCommandFormat();
+      if (usingS3Guard) {
+        if (commands.getOpt(UNGUARDED_FLAG)) {
+          throw badState("S3Guard is enabled for %s", fsUri);
+        }
+        if (commands.getOpt(AUTH_FLAG) && !authMode) {
+          throw badState("S3Guard is enabled for %s,"
+              + " but not in authoritative mode", fsUri);
+        }
+        if (commands.getOpt(NONAUTH_FLAG) && authMode) {
+          throw badState("S3Guard is enabled in authoritative mode for %s",
+              fsUri);
+        }
+      } else {
+        if (commands.getOpt(GUARDED_FLAG)) {
+          throw badState("S3Guard is not enabled for %s", fsUri);
+        }
+      }
+
+      String desiredEncryption = getCommandFormat()
+          .getOptValue(ENCRYPTION_FLAG);
+      if (StringUtils.isNotEmpty(desiredEncryption)
+          && !desiredEncryption.equalsIgnoreCase(encryption)) {
+        throw badState("Bucket %s: required encryption is %s"
+                    + " but actual encryption is %s",
+                fsUri, desiredEncryption, encryption);
+      }
+
+      out.flush();
+      return SUCCESS;
+    }
+
+    private String printOption(PrintStream out,
+        String description, String key, String defVal) {
+      String t = getFilesystem().getConf().getTrimmed(key, defVal);
+      println(out, "%s: %s=%s", description, key, t);
+      return t;
+    }
+
+  /**
+   * Convert a path to a URI, catching any {@code URISyntaxException}
+   * and converting to an invalid args exception.
+   * @param s3Path path to convert to a URI
+   * @return a URI of the path
+   * @throws ExitUtil.ExitException INVALID_ARGUMENT if the URI is invalid
+   */
+  protected static URI toUri(String s3Path) {
+    URI uri;
+    try {
+      uri = new URI(s3Path);
+    } catch (URISyntaxException e) {
+      throw invalidArgs("Not a valid fileystem path: %s", s3Path);
+    }
+    return uri;
+  }
+
-      System.err.println("Usage: hadoop " + USAGE);
-      System.err.println("\tperform S3Guard metadata store " +
+      errorln("Usage: hadoop " + USAGE);
+      errorln("\tperform S3Guard metadata store " +
-      System.err.println("Usage: hadoop " + command.getUsage());
+      errorln("Usage: hadoop " + command.getUsage());
+    errorln();
+    errorln(COMMON_USAGE);
+  }
+
+  private static void errorln() {
-    System.err.println(COMMON_USAGE);
+  }
+
+  private static void errorln(String x) {
+    System.err.println(x);
+  }
+
+  /**
+   * Print a formatted string followed by a newline to the output stream.
+   * @param out destination
+   * @param format format string
+   * @param args optional arguments
+   */
+  private static void println(PrintStream out, String format, Object... args) {
+    out.println(String.format(format, args));
+  }
+
+  /**
+   * Retrieve and Print store diagnostics.
+   * @param out output stream
+   * @param store store
+   * @throws IOException Failure to retrieve the data.
+   */
+  protected static void printStoreDiagnostics(PrintStream out,
+      MetadataStore store)
+      throws IOException {
+    Map<String, String> diagnostics = store.getDiagnostics();
+    out.println("Metadata Store Diagnostics:");
+    for (Map.Entry<String, String> entry : diagnostics.entrySet()) {
+      println(out, "\t%s=%s", entry.getKey(), entry.getValue());
+    }
+  }
+
+
+  /**
+   * Handle store not found by converting to an exit exception
+   * with specific error code.
+   * @param e exception
+   * @return a new exception to throw
+   */
+  protected static ExitUtil.ExitException storeNotFound(
+      FileNotFoundException e) {
+    return new ExitUtil.ExitException(
+        E_NOT_FOUND, e.toString(), e);
+  }
+
+  /**
+   * Build the exception to raise on invalid arguments.
+   * @param format string format
+   * @param args optional arguments for the string
+   * @return a new exception to throw
+   */
+  protected static ExitUtil.ExitException invalidArgs(
+      String format, Object...args) {
+    return new ExitUtil.ExitException(INVALID_ARGUMENT,
+        String.format(format, args));
+  }
+
+  /**
+   * Build the exception to raise on a bad store/bucket state.
+   * @param format string format
+   * @param args optional arguments for the string
+   * @return a new exception to throw
+   */
+  protected static ExitUtil.ExitException badState(
+      String format, Object...args) {
+    return new ExitUtil.ExitException(E_BAD_STATE,
+        String.format(format, args));
-   * @param args command specific arguments.
+   * @param args command specific arguments.
-  public static int run(String[] args, Configuration conf) throws
+  public static int run(Configuration conf, String...args) throws
-      return INVALID_ARGUMENT;
+      throw new ExitUtil.ExitException(E_USAGE, "No arguments provided");
+    LOG.debug("Executing command {}", subCommand);
+    case BucketInfo.NAME:
+      command = new BucketInfo(conf);
+      break;
+    case SetCapacity.NAME:
+      command = new SetCapacity(conf);
+      break;
-      return INVALID_ARGUMENT;
+      throw new ExitUtil.ExitException(E_USAGE,
+          "Unknown command " + subCommand);
-      int ret = run(args, new Configuration());
-      System.exit(ret);
+      int ret = run(new Configuration(), args);
+      exit(ret, "");
-      System.err.println(e.getMessage());
+      errorln(e.getMessage());
-      System.exit(INVALID_ARGUMENT);
+      exit(E_USAGE, e.getMessage());
+    } catch (ExitUtil.ExitException e) {
+      // explicitly raised exit code
+      exit(e.getExitCode(), e.toString());
-      System.exit(ERROR);
+      exit(ERROR, e.toString());
+
+  protected static void exit(int status, String text) {
+    ExitUtil.terminate(status, text);
+  }

MOV26 INS26 INS26 INS26 INS40 UPD40 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS55 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 INS44 MOV65 UPD39 MOV29 MOV39 MOV42 MOV44 MOV43 INS8 MOV78 INS83 INS83 INS39 INS42 INS44 INS43 MOV8 INS29 INS83 INS83 INS39 INS42 MOV44 INS44 INS43 INS29 INS83 INS42 INS43 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS29 INS83 INS42 INS43 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 MOV43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 MOV65 INS44 INS83 INS83 INS39 INS42 INS44 INS44 INS8 UPD45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS65 INS43 INS42 UPD65 INS53 INS65 INS60 INS60 INS60 INS21 INS60 INS21 INS60 INS21 INS21 INS60 MOV25 MOV21 INS5 INS42 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS42 UPD83 INS44 UPD43 INS65 INS42 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS42 INS44 INS8 INS78 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS8 MOV78 INS83 INS39 INS42 MOV44 INS44 INS43 INS8 UPD83 INS44 UPD43 UPD83 INS44 UPD43 MOV54 UPD83 UPD83 INS65 INS42 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS42 INS44 INS8 INS78 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS83 INS39 INS42 MOV44 INS44 MOV43 MOV43 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS8 INS65 INS65 INS65 INS65 INS42 INS43 INS42 MOV60 MOV54 INS41 INS21 MOV21 INS43 INS42 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS21 INS70 INS65 INS65 INS65 INS40 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS40 INS43 INS42 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS40 INS43 INS42 INS43 INS42 INS41 INS43 INS42 INS21 MOV10 MOV10 INS39 INS42 INS43 INS42 INS21 INS40 INS45 INS40 INS45 INS45 INS45 INS40 INS45 INS40 INS45 INS42 INS66 INS42 INS40 UPD66 MOV32 UPD66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS40 INS66 MOV43 INS59 INS43 INS59 INS43 INS59 INS32 INS43 INS59 INS32 INS43 INS59 INS32 INS32 MOV43 INS59 INS66 INS43 INS85 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS40 INS66 INS42 INS43 INS42 UPD42 INS54 INS60 INS66 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS27 UPD43 MOV43 UPD42 MOV42 INS46 INS21 INS21 INS42 INS42 INS41 INS42 INS42 INS41 INS43 INS42 UPD42 MOV42 INS60 INS60 INS60 INS25 INS60 INS25 INS54 INS60 INS21 INS21 INS41 INS43 INS42 UPD42 INS54 INS43 INS42 UPD42 MOV21 INS54 INS66 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS27 INS43 INS42 INS46 INS60 INS21 INS42 INS42 INS41 INS42 INS42 INS41 INS43 INS42 INS60 INS25 INS60 INS60 INS21 MOV60 INS60 INS60 MOV21 INS21 INS60 INS60 INS25 INS21 INS60 INS21 INS60 INS21 INS60 INS25 INS60 INS25 INS21 INS41 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 MOV60 INS21 INS41 INS66 INS65 INS66 INS42 INS66 INS66 INS40 INS66 INS42 INS42 INS32 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS74 INS59 INS32 INS44 INS32 INS8 INS66 INS66 INS42 INS66 INS66 INS42 INS14 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS14 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS14 INS42 INS32 INS49 INS21 INS10 INS21 INS10 INS49 INS53 INS12 INS42 INS32 UPD42 INS66 INS42 INS32 INS42 INS42 INS14 INS42 INS42 MOV32 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS45 INS42 INS42 INS42 INS32 INS42 INS40 INS42 INS8 INS12 MOV43 INS59 INS32 INS42 INS45 INS45 INS42 INS45 INS45 INS45 INS42 INS45 INS45 INS45 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS45 INS45 INS45 INS42 INS45 INS45 UPD42 INS42 INS32 INS32 INS42 INS42 INS42 INS74 INS59 INS74 INS59 INS43 INS59 INS32 INS8 INS43 INS59 INS32 INS8 INS8 INS12 INS43 INS59 INS32 INS32 INS42 INS42 INS8 INS12 INS42 INS8 INS12 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS42 INS74 INS59 INS32 INS8 INS43 INS59 INS43 INS59 INS32 INS43 INS59 INS43 INS59 INS32 INS32 INS39 INS59 INS39 INS59 INS42 INS8 INS8 INS32 INS43 INS59 INS32 INS43 INS59 INS32 INS43 INS59 INS42 INS8 INS8 INS43 INS59 INS27 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS66 INS42 UPD42 INS40 INS42 INS42 INS42 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS45 INS74 INS42 INS42 INS42 INS21 INS43 INS42 INS32 INS42 INS43 INS42 INS32 INS43 INS42 INS32 INS53 INS42 INS42 INS45 INS42 INS40 INS7 INS40 INS7 INS14 MOV21 MOV21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS21 INS44 INS8 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS21 INS21 INS44 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS44 INS8 MOV21 UPD42 UPD42 INS53 INS32 UPD42 INS42 UPD45 INS53 INS32 INS21 INS44 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS42 INS21 INS53 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS32 INS42 INS38 INS42 INS9 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS16 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS25 INS25 INS25 INS25 INS42 INS42 INS32 INS32 INS38 INS53 INS42 INS42 INS42 UPD42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS32 INS40 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS14 INS43 INS42 INS27 INS43 INS42 INS21 INS53 INS53 INS53 UPD45 INS42 INS42 UPD42 MOV32 INS43 INS42 MOV21 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS32 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS32 INS32 MOV32 INS43 INS42 INS21 INS53 INS42 INS9 INS32 INS43 INS42 MOV21 INS53 INS32 INS42 INS42 INS32 UPD43 INS32 INS42 INS42 MOV32 INS43 INS42 MOV21 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS34 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS32 INS32 INS7 INS32 INS32 INS42 INS42 INS42 INS45 INS32 INS42 INS45 INS42 INS42 INS45 INS42 INS45 INS42 INS32 INS8 INS27 INS8 INS27 INS8 INS32 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 UPD42 INS42 INS42 INS32 UPD42 UPD42 UPD42 INS40 INS42 INS42 INS42 INS42 INS45 INS32 INS32 INS43 INS42 INS45 INS43 INS42 INS43 INS42 INS40 INS45 INS42 MOV42 INS45 INS40 INS32 MOV32 INS32 INS32 INS42 INS42 INS40 INS42 INS43 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS40 INS32 INS42 MOV42 MOV42 INS40 INS42 UPD42 INS42 INS45 INS42 INS9 UPD42 INS32 INS42 INS45 INS40 INS42 UPD42 INS42 INS32 INS42 INS45 INS42 INS42 INS42 INS32 MOV32 INS62 INS42 INS42 INS45 INS42 INS32 INS42 INS42 INS45 INS42 INS45 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS53 INS32 INS38 INS53 INS32 INS42 INS53 INS42 INS42 INS42 INS53 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS32 UPD42 MOV42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 UPD42 INS32 UPD42 INS42 INS42 INS32 INS32 INS32 UPD42 UPD42 MOV42 MOV27 UPD42 MOV42 UPD45 MOV45 MOV42 UPD42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS9 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS45 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 UPD45 INS42 UPD45 INS42 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS45 INS42 UPD45 MOV45 INS45 INS45 INS45 DEL34 DEL34 DEL34 DEL40 DEL21 DEL9 DEL41 DEL40 DEL32 DEL21 DEL9 DEL41 DEL9 DEL40 DEL32 DEL21 DEL9 DEL41 DEL9 DEL9 DEL40 DEL21 DEL9 DEL41 DEL42 DEL42 DEL57 DEL42 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL44 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL40 DEL38 DEL42 DEL41 DEL8 DEL25 DEL40 DEL38 DEL42 DEL41 DEL8 DEL25 DEL40 DEL42 DEL41 DEL42 DEL42 DEL43 DEL42 DEL14 DEL7 DEL42 DEL43 DEL42 DEL14 DEL40 DEL42 DEL42 DEL42 DEL41 DEL42 DEL9 DEL32 DEL21 DEL83 DEL39 DEL42 DEL42 DEL42 DEL40 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL40 DEL38 DEL42 DEL41 DEL8 DEL25 DEL40 DEL40 DEL83 DEL39 DEL42 DEL31 DEL42 DEL43 DEL42 DEL14 DEL40 DEL40 DEL40 DEL40 DEL42 DEL41 DEL42 DEL41 DEL42 DEL40 DEL42
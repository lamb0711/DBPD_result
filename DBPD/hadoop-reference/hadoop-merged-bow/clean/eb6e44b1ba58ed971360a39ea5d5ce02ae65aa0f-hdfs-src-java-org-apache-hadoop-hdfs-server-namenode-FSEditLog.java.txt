HDFS-2227. getRemoteEditLogManifest should pull its information from FileJournalManager during checkpoint process. Contributed by Ivan Kelly and Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1155977 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collections;
+import java.util.SortedSet;
-import org.apache.hadoop.hdfs.protocol.Block;
-import org.apache.hadoop.hdfs.server.namenode.NNStorageRetentionManager.StoragePurger;
-import org.apache.hadoop.io.BytesWritable;
-import org.apache.hadoop.io.LongWritable;
-import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.hdfs.server.protocol.RemoteEditLog;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Multimaps;
+import com.google.common.collect.Sets;
-import static org.apache.hadoop.hdfs.server.namenode.FSEditLogOpCodes.*;
-  }
-  
-  /**
-   * Initialize the list of edit journals
-   */
-  synchronized void initJournals() {
-    assert journals.isEmpty();
-    Preconditions.checkState(state == State.UNINITIALIZED,
-        "Bad state: %s", state);
-    Preconditions.checkState(state == State.UNINITIALIZED);
-    initJournals();
+    Preconditions.checkState(state == State.BETWEEN_LOG_SEGMENTS);
-  public RemoteEditLogManifest getEditLogManifest(long sinceTxId)
-      throws IOException {
-    FSImageTransactionalStorageInspector inspector =
-        new FSImageTransactionalStorageInspector();
-
-    for (StorageDirectory sd : storage.dirIterable(NameNodeDirType.EDITS)) {
-      inspector.inspectDirectory(sd);
+  public synchronized RemoteEditLogManifest getEditLogManifest(
+      long fromTxId) throws IOException {
+    // Collect RemoteEditLogs available from each FileJournalManager
+    List<RemoteEditLog> allLogs = Lists.newArrayList();
+    for (JournalAndStream j : journals) {
+      if (j.getManager() instanceof FileJournalManager) {
+        FileJournalManager fjm = (FileJournalManager)j.getManager();
+        try {
+          allLogs.addAll(fjm.getRemoteEditLogs(fromTxId));
+        } catch (Throwable t) {
+          LOG.warn("Cannot list edit logs in " + fjm, t);
+        }
+      }
-    return inspector.getEditLogManifest(sinceTxId);
+    // Group logs by their starting txid
+    ImmutableListMultimap<Long, RemoteEditLog> logsByStartTxId =
+      Multimaps.index(allLogs, RemoteEditLog.GET_START_TXID);
+    long curStartTxId = fromTxId;
+
+    List<RemoteEditLog> logs = Lists.newArrayList();
+    while (true) {
+      ImmutableList<RemoteEditLog> logGroup = logsByStartTxId.get(curStartTxId);
+      if (logGroup.isEmpty()) {
+        // we have a gap in logs - for example because we recovered some old
+        // storage directory with ancient logs. Clear out any logs we've
+        // accumulated so far, and then skip to the next segment of logs
+        // after the gap.
+        SortedSet<Long> startTxIds = Sets.newTreeSet(logsByStartTxId.keySet());
+        startTxIds = startTxIds.tailSet(curStartTxId);
+        if (startTxIds.isEmpty()) {
+          break;
+        } else {
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Found gap in logs at " + curStartTxId + ": " +
+                "not returning previous logs in manifest.");
+          }
+          logs.clear();
+          curStartTxId = startTxIds.first();
+          continue;
+        }
+      }
+
+      // Find the one that extends the farthest forward
+      RemoteEditLog bestLog = Collections.max(logGroup);
+      logs.add(bestLog);
+      // And then start looking from after that point
+      curStartTxId = bestLog.getEndTxId() + 1;
+    }
+    RemoteEditLogManifest ret = new RemoteEditLogManifest(logs);
+    
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Generated manifest for logs since " + fromTxId + ":"
+          + ret);      
+    }
+    return ret;
-  
+ 
-    private void abort() {
+    @VisibleForTesting
+    void abort() {

MOV26 MOV26 MOV26 MOV26 MOV26 INS26 UPD40 INS40 UPD40 UPD40 UPD40 UPD40 UPD40 INS31 MOV29 INS83 MOV83 MOV43 INS42 INS44 MOV43 INS8 MOV70 INS25 INS21 INS39 INS42 INS60 INS70 INS60 INS60 INS60 INS61 MOV60 INS25 MOV41 INS78 INS32 INS8 INS7 INS74 INS59 INS44 INS42 INS8 INS74 INS59 INS39 INS59 INS74 INS59 INS9 INS8 UPD43 INS32 INS8 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS21 MOV42 MOV40 INS43 INS43 INS42 INS32 INS43 INS42 INS25 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS43 INS43 INS42 INS32 INS60 INS25 INS60 INS21 INS21 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV21 INS42 INS32 UPD40 INS42 INS42 INS42 INS42 INS42 INS62 INS8 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD40 MOV40 INS42 INS42 INS42 INS42 INS74 INS59 INS32 INS8 INS43 INS59 INS32 INS7 UPD43 INS42 INS42 INS42 INS42 MOV45 INS32 INS43 INS60 INS54 INS43 INS43 INS42 INS32 INS42 INS42 INS60 INS21 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS27 UPD42 UPD42 UPD42 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS59 INS8 INS12 INS42 INS42 INS42 INS42 UPD42 MOV42 INS74 INS59 INS7 INS32 INS8 INS8 INS42 INS42 INS42 INS32 INS34 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS11 INS21 INS44 INS8 INS43 INS43 INS42 INS32 INS42 INS32 INS42 INS42 INS10 MOV25 INS21 MOV21 INS18 INS42 INS42 INS42 INS43 INS32 INS32 INS43 INS42 MOV21 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 UPD27 UPD42 INS42 INS42 INS45 UPD42 UPD42 INS27 INS45 INS42 INS45 INS45 DEL66 DEL65 DEL29 DEL39 DEL42 DEL32 DEL6 DEL8 DEL31 DEL42 DEL32 DEL21 DEL40 DEL45 DEL42 DEL42 DEL42 DEL42 DEL32 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL40 DEL32 DEL8 DEL70 DEL8 DEL31 DEL83
HDFS-3693. JNStorage should read its storage info even before a writer becomes active. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1365794 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.common.base.Preconditions;
+
-  private boolean lazyInitted = false;
+  private StorageState state;
+   * @throws IOException 
-  protected JNStorage(File logDir, StorageErrorReporter errorReporter) {
+  protected JNStorage(File logDir, StorageErrorReporter errorReporter) throws IOException {
+    
+    analyzeStorage();
-  void analyzeStorage(NamespaceInfo nsInfo) throws IOException {
-    if (lazyInitted) {
-      checkConsistentNamespace(nsInfo);
-      return;
-    }
-    
-    StorageState state = sd.analyzeStorage(StartupOption.REGULAR, this);
-    switch (state) {
-    case NON_EXISTENT:
-    case NOT_FORMATTED:
+  public void formatIfNecessary(NamespaceInfo nsInfo) throws IOException {
+    if (state == StorageState.NOT_FORMATTED ||
+        state == StorageState.NON_EXISTENT) {
-      // In the NORMAL case below, analyzeStorage() has already locked the
-      // directory for us. But in the case that we format it, we have to
-      // lock it here.
-      // The directory is unlocked in close() when the node shuts down.
-      sd.lock();
-      break;
-    case NORMAL:
-      // Storage directory is already locked by analyzeStorage() - no
-      // need to lock it here.
-      readProperties(sd);
-      checkConsistentNamespace(nsInfo);
-      break;
+      analyzeStorage();
+      assert state == StorageState.NORMAL :
+        "Unexpected state after formatting: " + state;
+    } else {
+      Preconditions.checkState(state == StorageState.NORMAL,
+          "Unhandled storage state in %s: %s", this, state);
+      assert getNamespaceID() != 0;
-    default:
-      LOG.warn("TODO: unhandled state for storage dir " + sd + ": " + state);
+      checkConsistentNamespace(nsInfo);
-    lazyInitted  = true;
+  }
+
+  private void analyzeStorage() throws IOException {
+    this.state = sd.analyzeStorage(StartupOption.REGULAR, this);
+    if (state == StorageState.NORMAL) {
+      readProperties(sd);
+    }

INS26 INS40 INS31 INS31 MOV43 INS43 INS83 MOV39 UPD42 MOV42 MOV44 INS43 INS8 INS83 INS39 INS42 MOV43 INS8 UPD42 INS65 INS42 INS21 INS42 INS25 MOV21 INS25 INS42 INS66 INS32 INS27 INS8 INS8 INS27 INS8 INS42 INS27 INS27 MOV21 INS21 INS6 INS21 INS6 MOV21 INS22 MOV32 INS42 INS40 MOV21 INS42 INS40 INS42 INS40 MOV32 INS27 INS27 MOV32 INS27 INS52 INS42 UPD42 INS42 INS40 INS45 INS42 UPD42 UPD42 INS27 INS45 INS52 INS42 INS32 INS34 UPD42 MOV42 INS40 INS42 DEL39 DEL9 DEL42 DEL45 DEL45 DEL42 DEL27 DEL42 DEL9 DEL42 DEL42 DEL42 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL59 DEL60 DEL42 DEL42 DEL49 DEL42 DEL49 DEL21 DEL10 DEL42 DEL49 DEL10 DEL49 DEL21 DEL50 DEL8 DEL31
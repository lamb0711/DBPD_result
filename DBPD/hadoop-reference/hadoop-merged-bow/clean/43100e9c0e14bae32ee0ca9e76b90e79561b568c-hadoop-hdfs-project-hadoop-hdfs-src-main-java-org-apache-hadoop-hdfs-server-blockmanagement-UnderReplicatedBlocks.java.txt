HDFS-1765. Block Replication should respect under-replication block priority. Contributed by Uma Maheswara Rao G


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1213537 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Map;
+
+  /** Stores the replication index for each priority */
+  private Map<Integer, Integer> priorityToReplIdx = new HashMap<Integer, Integer>(LEVEL);
+  
+      priorityToReplIdx.put(i, 0);
+  
+  /**
+   * Get a list of block lists to be replicated. The index of block lists
+   * represents its replication priority. Replication index will be tracked for
+   * each priority list separately in priorityToReplIdx map. Iterates through
+   * all priority lists and find the elements after replication index. Once the
+   * last priority lists reaches to end, all replication indexes will be set to
+   * 0 and start from 1st priority list to fulfill the blockToProces count.
+   * 
+   * @param blocksToProcess - number of blocks to fetch from underReplicated blocks.
+   * @return Return a list of block lists to be replicated. The block list index
+   *         represents its replication priority.
+   */
+  public synchronized List<List<Block>> chooseUnderReplicatedBlocks(
+      int blocksToProcess) {
+    // initialize data structure for the return value
+    List<List<Block>> blocksToReplicate = new ArrayList<List<Block>>(LEVEL);
+    for (int i = 0; i < LEVEL; i++) {
+      blocksToReplicate.add(new ArrayList<Block>());
+    }
+
+    if (size() == 0) { // There are no blocks to collect.
+      return blocksToReplicate;
+    }
+    
+    int blockCount = 0;
+    for (int priority = 0; priority < LEVEL; priority++) { 
+      // Go through all blocks that need replications with current priority.
+      BlockIterator neededReplicationsIterator = iterator(priority);
+      Integer replIndex = priorityToReplIdx.get(priority);
+      
+      // skip to the first unprocessed block, which is at replIndex
+      for (int i = 0; i < replIndex && neededReplicationsIterator.hasNext(); i++) {
+        neededReplicationsIterator.next();
+      }
+
+      blocksToProcess = Math.min(blocksToProcess, size());
+      
+      if (blockCount == blocksToProcess) {
+        break;  // break if already expected blocks are obtained
+      }
+      
+      // Loop through all remaining blocks in the list.
+      while (blockCount < blocksToProcess
+          && neededReplicationsIterator.hasNext()) {
+        Block block = neededReplicationsIterator.next();
+        blocksToReplicate.get(priority).add(block);
+        replIndex++;
+        blockCount++;
+      }
+      
+      if (!neededReplicationsIterator.hasNext()
+          && neededReplicationsIterator.getPriority() == LEVEL - 1) {
+        // reset all priorities replication index to 0 because there is no
+        // recently added blocks in any list.
+        for (int i = 0; i < LEVEL; i++) {
+          priorityToReplIdx.put(i, 0);
+        }
+        break;
+      }
+      priorityToReplIdx.put(priority, replIndex); 
+    }
+    return blocksToReplicate;
+  }
+
+  /**
+   * This method is to decrement the replication index for the given priority
+   * 
+   * @param priority  - int priority level
+   */
+  public void decrementReplicationIndex(int priority) {
+    Integer replIdx = priorityToReplIdx.get(priority);
+    priorityToReplIdx.put(priority, --replIdx); 
+  }

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS29 INS83 INS74 INS59 INS29 INS83 INS83 INS74 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS65 INS43 INS43 INS43 INS42 INS14 INS65 INS65 INS65 INS43 INS74 INS39 INS42 INS60 INS24 INS25 INS60 INS24 INS41 INS65 INS65 INS39 INS42 INS60 INS21 INS66 INS42 INS42 INS42 INS74 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS43 INS43 INS74 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS66 INS42 INS66 INS43 INS59 INS32 INS43 INS43 INS43 INS21 INS42 INS42 INS43 INS74 INS42 INS14 INS39 INS59 INS42 INS42 INS42 INS21 INS32 INS34 INS41 INS42 INS34 INS39 INS59 INS42 INS42 INS42 INS60 INS60 INS24 INS21 INS25 INS61 INS25 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS38 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS74 INS42 INS42 INS34 INS32 INS42 INS42 INS42 INS34 INS43 INS59 INS43 INS59 INS58 INS27 INS37 INS8 INS7 INS27 INS8 INS27 INS8 INS27 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS43 INS74 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS39 INS59 INS27 INS32 INS42 INS21 INS42 INS32 INS42 INS42 INS10 INS27 INS32 INS60 INS21 INS21 INS21 INS38 INS27 INS24 INS10 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS37 INS37 INS32 INS32 INS27 INS58 INS27 INS37 INS8 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS39 INS59 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS42 INS42 INS42 INS34
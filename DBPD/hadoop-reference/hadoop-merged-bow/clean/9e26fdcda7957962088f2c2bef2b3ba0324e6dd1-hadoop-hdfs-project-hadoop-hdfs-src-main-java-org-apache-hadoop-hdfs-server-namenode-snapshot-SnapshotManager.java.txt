HDFS-4111. Support snapshot of subtrees. Contributed by Tsz Wo (Nicholas), Sze.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1402684 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;
+import org.apache.hadoop.hdfs.server.namenode.INode;
-import org.apache.hadoop.hdfs.server.namenode.Namesystem;
+import org.apache.hadoop.hdfs.server.namenode.INodeFile;
+import org.apache.hadoop.hdfs.server.namenode.INodeFileUnderConstruction;
+import org.apache.hadoop.hdfs.server.namenode.INodeSymlink;
-  private final Namesystem namesystem;
+  private final FSNamesystem namesystem;
+  private final FSDirectory fsdir;
-  public SnapshotManager(final Namesystem namesystem) {
+  public SnapshotManager(final FSNamesystem namesystem,
+      final FSDirectory fsdir) {
+    this.fsdir = fsdir;
-  public void setSnapshottable(final String path, final int snapshotQuota,
-      final FSDirectory fsdir) throws IOException {
+  public void setSnapshottable(final String path, final int snapshotQuota
+      ) throws IOException {
-  /** Create a snapshot of given path. */
-  public void createSnapshot(final String snapshotName, final String path,
-      final FSDirectory fsdir) throws IOException {
-    final INodeDirectorySnapshottable d = INodeDirectorySnapshottable.valueOf(
-        fsdir.getINode(path), path);
+  /**
+   * Create a snapshot of the given path.
+   * 
+   * @param snapshotName The name of the snapshot.
+   * @param path The directory path where the snapshot will be taken.
+   */
+  public void createSnapshot(final String snapshotName, final String path
+      ) throws IOException {
+    new SnapshotCreation(path).run(snapshotName);
+  }
+  
+  /**
+   * Create a snapshot of subtrees for recursively coping the directory
+   * structure from the source directory to the snapshot destination directory.
+   * This creation algorithm requires O(N) running time and O(N) memory,
+   * where N = # files + # directories + # symlinks. 
+   */
+  class SnapshotCreation {
+    /** The source root directory path where the snapshot is taken. */
+    final INodeDirectorySnapshottable srcRoot;
+    
+    /** 
+     * Constructor.
+     * @param path The path must be a snapshottable directory.
+     */
+    private SnapshotCreation(final String path) throws IOException {
+      srcRoot = INodeDirectorySnapshottable.valueOf(fsdir.getINode(path), path);
+    }
+    
+    void run(final String name) throws IOException {
+      final INodeDirectorySnapshotRoot root = srcRoot.addSnapshotRoot(name);
+      processRecursively(srcRoot, root);
+    }
-    //TODO: check ns quota
+    /** Process snapshot creation recursively. */
+    private void processRecursively(final INodeDirectory srcDir,
+        final INodeDirectory dstDir) throws IOException {
+      final List<INode> children = srcDir.getChildren();
+      if (children != null) {
+        final List<INode> inodes = new ArrayList<INode>(children.size());
+        for(final INode c : children) {
+          final INode i;
+          if (c == null) {
+            i = null;
+          } else if (c instanceof INodeDirectory) {
+            //also handle INodeDirectoryWithQuota
+            i = processINodeDirectory((INodeDirectory)c);
+          } else if (c instanceof INodeFileUnderConstruction) {
+            //TODO: support INodeFileUnderConstruction
+            throw new IOException("Not yet supported.");
+          } else if (c instanceof INodeFile) {
+            i = processINodeFile(srcDir, (INodeFile)c);
+          } else if (c instanceof INodeSymlink) {
+            i = new INodeSymlink((INodeSymlink)c);
+          } else {
+            throw new AssertionError("Unknow INode type: " + c.getClass()
+                + ", inode = " + c);
+          }
+          inodes.add(i);
+        }
+        dstDir.setChildren(inodes);
+      }
+    }
-    final INodeDirectorySnapshotRoot root = d.addSnapshotRoot(snapshotName);
-    
-    //TODO: create the remaining subtree
+    /**
+     * Create destination INodeDirectory and make the recursive call. 
+     * @return destination INodeDirectory.
+     */
+    private INodeDirectory processINodeDirectory(final INodeDirectory srcChild
+        ) throws IOException {
+      final INodeDirectory dstChild = new INodeDirectory(srcChild);
+      dstChild.setChildren(null);
+      processRecursively(srcChild, dstChild);
+      return dstChild;
+    }
+
+    /**
+     * Create destination INodeFileSnapshot and update source INode type.
+     * @return destination INodeFileSnapshot.
+     */
+    private INodeFileSnapshot processINodeFile(final INodeDirectory parent,
+        final INodeFile file) {
+      final INodeFileSnapshot snapshot = new INodeFileSnapshot(
+          file, file.computeFileSize(true)); 
+
+      final INodeFileWithLink srcWithLink;
+      //check source INode type
+      if (file instanceof INodeFileWithLink) {
+        srcWithLink = (INodeFileWithLink)file;
+      } else {
+        //source is an INodeFile, replace the source.
+        srcWithLink = new INodeFileWithLink(file);
+        file.removeNode();
+        parent.addChild(srcWithLink, false);
+
+        //update block map
+        namesystem.getBlockManager().addBlockCollection(srcWithLink);
+      }
+      
+      //insert the snapshot to src's linked list.
+      srcWithLink.insert(snapshot);
+      return snapshot;
+    }

MOV26 INS26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS40 INS23 INS31 INS55 UPD43 INS83 INS83 INS43 INS59 MOV44 MOV29 MOV83 MOV39 MOV42 MOV44 INS44 INS43 INS8 INS29 INS42 INS23 INS31 INS31 INS31 INS31 INS31 UPD42 INS42 INS42 UPD43 INS21 INS65 INS65 INS83 INS43 INS42 INS42 INS21 INS65 INS29 INS83 MOV43 INS59 INS29 INS83 INS42 MOV44 MOV43 INS8 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 MOV44 INS44 INS43 MOV8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 UPD42 INS7 UPD66 INS42 INS66 INS42 INS66 INS42 INS32 INS66 INS66 INS66 INS66 INS65 INS42 INS65 INS65 INS21 INS83 INS43 INS42 INS42 INS60 INS21 INS65 UPD43 UPD42 INS83 INS43 INS42 INS42 INS25 INS65 INS65 INS42 INS83 INS43 INS42 INS42 INS60 INS21 INS21 INS41 INS65 INS65 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS60 INS60 INS25 INS21 INS41 INS22 INS42 INS14 INS42 INS42 INS66 INS66 INS42 INS66 INS7 INS42 INS83 MOV43 INS59 INS32 INS66 UPD42 INS42 INS74 INS27 INS8 INS66 INS66 INS42 INS83 INS43 INS59 INS32 INS32 INS42 INS66 INS66 INS42 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS62 INS8 INS8 INS32 INS42 INS52 INS42 INS43 INS42 INS42 MOV32 INS42 INS32 INS42 INS42 INS42 INS43 INS43 UPD42 INS32 INS42 INS33 MOV60 INS70 INS21 INS42 INS42 INS14 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS43 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS44 INS42 INS8 INS32 INS43 INS42 INS43 INS42 INS32 INS42 INS7 INS7 INS32 INS32 INS32 INS43 INS43 INS42 INS14 INS83 INS43 INS42 INS60 INS25 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS11 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS9 INS32 INS42 INS42 INS42 INS42 INS74 INS32 INS42 INS83 INS43 INS59 INS27 INS8 INS25 INS32 INS43 INS42 INS43 INS42 INS42 INS42 INS43 INS43 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS33 INS21 INS62 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS43 INS21 INS62 INS8 INS25 INS42 INS33 INS42 INS7 INS42 INS43 INS53 INS62 INS8 INS25 INS42 INS32 INS42 INS14 INS42 INS43 INS21 INS62 INS8 INS8 INS42 INS11 INS43 INS45 INS42 INS7 INS42 INS43 INS21 INS53 INS43 INS42 INS42 INS42 INS32 INS42 INS7 INS14 INS42 INS42 INS42 INS11 INS42 INS14 INS43 INS27 INS43 INS42 INS43 INS11 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL31
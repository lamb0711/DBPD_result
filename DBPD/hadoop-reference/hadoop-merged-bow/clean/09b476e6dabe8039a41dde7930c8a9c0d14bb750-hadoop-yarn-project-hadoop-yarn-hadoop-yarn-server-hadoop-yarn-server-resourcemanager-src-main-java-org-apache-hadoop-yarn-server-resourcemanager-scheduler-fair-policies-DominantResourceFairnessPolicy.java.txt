YARN-6612. Update fair scheduler policies to be aware of resource types. (Contributed by Daniel Templeton via Yufei Gu)

+import java.util.Arrays;
-import org.apache.hadoop.yarn.server.resourcemanager.resource.ResourceType;
-import org.apache.hadoop.yarn.server.resourcemanager.resource.ResourceWeights;
+import org.apache.hadoop.yarn.api.records.ResourceInformation;
-
-
-import static org.apache.hadoop.yarn.server.resourcemanager.resource.ResourceType.*;
+import org.apache.hadoop.yarn.util.resource.ResourceUtils;
-    for (ResourceType type : ResourceType.values()) {
-      ComputeFairShares.computeShares(schedulables, totalResources, type);
+    for (ResourceInformation info: ResourceUtils.getResourceTypesArray()) {
+      ComputeFairShares.computeShares(schedulables, totalResources,
+          info.getName());
-    for (ResourceType type : ResourceType.values()) {
-      ComputeFairShares.computeSteadyShares(queues, totalResources, type);
+    for (ResourceInformation info: ResourceUtils.getResourceTypesArray()) {
+      ComputeFairShares.computeSteadyShares(queues, totalResources,
+          info.getName());
-  public static class DominantResourceFairnessComparator implements Comparator<Schedulable> {
-    private static final int NUM_RESOURCES = ResourceType.values().length;
-
+  /**
+   * This class compares two {@link Schedulable} instances according to the
+   * DRF policy. If neither instance is below min share, approximate fair share
+   * ratios are compared.
+   */
+  public static class DominantResourceFairnessComparator
+      implements Comparator<Schedulable> {
-      ResourceWeights sharesOfCluster1 = new ResourceWeights();
-      ResourceWeights sharesOfCluster2 = new ResourceWeights();
-      ResourceWeights sharesOfMinShare1 = new ResourceWeights();
-      ResourceWeights sharesOfMinShare2 = new ResourceWeights();
-      ResourceType[] resourceOrder1 = new ResourceType[NUM_RESOURCES];
-      ResourceType[] resourceOrder2 = new ResourceType[NUM_RESOURCES];
+      ResourceInformation[] info = ResourceUtils.getResourceTypesArray();
+      Resource usage1 = s1.getResourceUsage();
+      Resource usage2 = s2.getResourceUsage();
+      Resource minShare1 = s1.getMinShare();
+      Resource minShare2 = s2.getMinShare();
-      // Calculate shares of the cluster for each resource both schedulables.
-      calculateShares(s1.getResourceUsage(),
-          clusterCapacity, sharesOfCluster1, resourceOrder1, s1.getWeights());
-      calculateShares(s1.getResourceUsage(),
-          s1.getMinShare(), sharesOfMinShare1, null, ResourceWeights.NEUTRAL);
-      calculateShares(s2.getResourceUsage(),
-          clusterCapacity, sharesOfCluster2, resourceOrder2, s2.getWeights());
-      calculateShares(s2.getResourceUsage(),
-          s2.getMinShare(), sharesOfMinShare2, null, ResourceWeights.NEUTRAL);
-      
+      // These arrays hold the usage, fair, and min share ratios for each
+      // resource type. ratios[0][x] are the usage ratios, ratios[1][x] are
+      // the fair share ratios, and ratios[2][x] are the min share ratios.
+      float[][] ratios1 = new float[info.length][3];
+      float[][] ratios2 = new float[info.length][3];
+
+      // Calculate cluster shares and approximate fair shares for each
+      // resource type of both schedulables.
+      int dominant1 = calculateClusterAndFairRatios(usage1, clusterCapacity,
+          ratios1, s1.getWeight());
+      int dominant2 = calculateClusterAndFairRatios(usage2, clusterCapacity,
+          ratios2, s2.getWeight());
+
-      // (with respect to the cluster capacity) is below its configured min share
-      // for that resource
-      boolean s1Needy = sharesOfMinShare1.getWeight(resourceOrder1[0]) < 1.0f;
-      boolean s2Needy = sharesOfMinShare2.getWeight(resourceOrder2[0]) < 1.0f;
+      // (with respect to the cluster capacity) is below its configured min
+      // share for that resource
+      boolean s1Needy =
+          usage1.getResources()[dominant1].getValue() <
+          minShare1.getResources()[dominant1].getValue();
+      boolean s2Needy =
+          usage2.getResources()[dominant2].getValue() <
+          minShare2.getResources()[dominant2].getValue();
+
-        res = compareShares(sharesOfCluster1, sharesOfCluster2,
-            resourceOrder1, resourceOrder2);
+        // Sort shares by usage ratio and compare them by approximate fair share
+        // ratio
+        sortRatios(ratios1, ratios2);
+        res = compareRatios(ratios1, ratios2, 1);
-        res = compareShares(sharesOfMinShare1, sharesOfMinShare2,
-            resourceOrder1, resourceOrder2);
+        // Calculate the min share ratios, then sort by usage ratio, and compare
+        // by min share ratio
+        calculateMinShareRatios(usage1, minShare1, ratios1);
+        calculateMinShareRatios(usage2, minShare2, ratios2);
+        sortRatios(ratios1, ratios2);
+        res = compareRatios(ratios1, ratios2, 2);
+
+
+
+
+    /**
+     * Sort both ratios arrays according to the usage ratios (the
+     * first index of the inner arrays, e.g. {@code ratios1[x][0]}).
+     *
+     * @param ratios1 the first ratios array
+     * @param ratios2 the second ratios array
+     */
+    @VisibleForTesting
+    void sortRatios(float[][] ratios1, float[][]ratios2) {
+      // sort order descending by resource share
+      Arrays.sort(ratios1, (float[] o1, float[] o2) ->
+          (int) Math.signum(o2[0] - o1[0]));
+      Arrays.sort(ratios2, (float[] o1, float[] o2) ->
+          (int) Math.signum(o2[0] - o1[0]));
+    }
+
+    /**
+     * Calculate a resource's usage ratio and approximate fair share ratio.
+     * The {@code shares} array will be populated with both the usage ratio
+     * and the approximate fair share ratio for each resource type. The usage
+     * ratio is calculated as {@code resource} divided by {@code cluster}.
+     * The approximate fair share ratio is calculated as the usage ratio
+     * divided by {@code weight}. If the cluster's resources are 100MB and
+     * 10 vcores, and the usage ({@code resource}) is 10 MB and 5 CPU, the
+     * usage ratios will be 0.1 and 0.5. If the weights are 2, the fair
+     * share ratios will be 0.05 and 0.25.
+     *
+     * The approximate fair share ratio is the usage divided by the
+     * approximate fair share, i.e. the cluster resources times the weight.
+     * The approximate fair share is an acceptable proxy for the fair share
+     * because when comparing resources, the resource with the higher weight
+     * will be assigned by the scheduler a proportionally higher fair share.
+     *
+     * The {@code shares} array must be at least <i>n</i> x 2, where <i>n</i>
+     * is the number of resource types. Only the first and second indices of
+     * the inner arrays in the {@code shares} array will be used, e.g.
+     * {@code shares[x][0]} and {@code shares[x][1]}.
+     *
+     * The return value will be the index of the dominant resource type in the
+     * {@code shares} array. The dominant resource is the resource type for
+     * which {@code resource} has the largest usage ratio.
+     *
+     * @param resource the resource for which to calculate ratios
+     * @param cluster the total cluster resources
+     * @param ratios the shares array to populate
+     * @param weight the resource weight
+     * @return the index of the resource type with the largest cluster share
+     */
+    @VisibleForTesting
+    int calculateClusterAndFairRatios(Resource resource, Resource cluster,
+        float[][] ratios, float weight) {
+      ResourceInformation[] resourceInfo = resource.getResources();
+      ResourceInformation[] clusterInfo = cluster.getResources();
+      int max = 0;
+
+      for (int i = 0; i < clusterInfo.length; i++) {
+        // First calculate the cluster share
+        ratios[i][0] =
+            resourceInfo[i].getValue() / (float) clusterInfo[i].getValue();
+
+        // Use the cluster share to find the dominant resource
+        if (ratios[i][0] > ratios[max][0]) {
+          max = i;
+        }
+
+        // Now divide by the weight to get the approximate fair share.
+        // It's OK if the weight is zero, because the floating point division
+        // will yield Infinity, i.e. this Schedulable will lose out to any
+        // other Schedulable with non-zero weight.
+        ratios[i][1] = ratios[i][0] / weight;
+      }
+
+      return max;
+    }
-     * Calculates and orders a resource's share of a pool in terms of two vectors.
-     * The shares vector contains, for each resource, the fraction of the pool that
-     * it takes up.  The resourceOrder vector contains an ordering of resources
-     * by largest share.  So if resource=<10 MB, 5 CPU>, and pool=<100 MB, 10 CPU>,
-     * shares will be [.1, .5] and resourceOrder will be [CPU, MEMORY].
+     * Calculate a resource's min share ratios. The {@code ratios} array will be
+     * populated with the {@code resource} divided by {@code minShare} for each
+     * resource type. If the min shares are 5 MB and 10 vcores, and the usage
+     * ({@code resource}) is 10 MB and 5 CPU, the ratios will be 2 and 0.5.
+     *
+     * The {@code ratios} array must be <i>n</i> x 3, where <i>n</i> is the
+     * number of resource types. Only the third index of the inner arrays in
+     * the {@code ratios} array will be used, e.g. {@code ratios[x][2]}.
+     *
+     * @param resource the resource for which to calculate min shares
+     * @param minShare the min share
+     * @param ratios the shares array to populate
-    void calculateShares(Resource resource, Resource pool,
-        ResourceWeights shares, ResourceType[] resourceOrder, ResourceWeights weights) {
-      shares.setWeight(MEMORY, (float)resource.getMemorySize() /
-          (pool.getMemorySize() * weights.getWeight(MEMORY)));
-      shares.setWeight(CPU, (float)resource.getVirtualCores() /
-          (pool.getVirtualCores() * weights.getWeight(CPU)));
-      // sort order vector by resource share
-      if (resourceOrder != null) {
-        if (shares.getWeight(MEMORY) > shares.getWeight(CPU)) {
-          resourceOrder[0] = MEMORY;
-          resourceOrder[1] = CPU;
-        } else  {
-          resourceOrder[0] = CPU;
-          resourceOrder[1] = MEMORY;
-        }
+    void calculateMinShareRatios(Resource resource, Resource minShare,
+        float[][] ratios) {
+      ResourceInformation[] resourceInfo = resource.getResources();
+      ResourceInformation[] minShareInfo = minShare.getResources();
+
+      for (int i = 0; i < minShareInfo.length; i++) {
+        ratios[i][2] =
+            resourceInfo[i].getValue() / (float) minShareInfo[i].getValue();
-    
-    private int compareShares(ResourceWeights shares1, ResourceWeights shares2,
-        ResourceType[] resourceOrder1, ResourceType[] resourceOrder2) {
-      for (int i = 0; i < resourceOrder1.length; i++) {
-        int ret = (int)Math.signum(shares1.getWeight(resourceOrder1[i])
-            - shares2.getWeight(resourceOrder2[i]));
+
+    /**
+     * Compare the two ratios arrays and return -1, 0, or 1 if the first array
+     * is less than, equal to, or greater than the second array, respectively.
+     * The {@code index} parameter determines which index of the inner arrays
+     * will be used for the comparisons. 0 is for usage ratios, 1 is for
+     * fair share ratios, and 2 is for the min share ratios. The ratios arrays
+     * are assumed to be sorted in descending order by usage ratio.
+     *
+     * @param ratios1 the first shares array
+     * @param ratios2 the second shares array
+     * @param index the outer index of the ratios arrays to compare. 0 is for
+     * usage ratio, 1 is for approximate fair share ratios, and 1 is for min
+     * share ratios
+     * @return -1, 0, or 1 if the first array is less than, equal to, or
+     * greater than the second array, respectively
+     */
+    @VisibleForTesting
+    int compareRatios(float[][] ratios1, float[][] ratios2, int index) {
+      int ret = 0;
+
+      for (int i = 0; i < ratios1.length; i++) {
+        ret = (int) Math.signum(ratios1[i][index] - ratios2[i][index]);
+
-          return ret;
+          break;
-      return 0;
+
+      return ret;

MOV26 UPD40 UPD40 UPD40 INS29 INS31 INS31 INS31 INS31 INS65 MOV60 MOV29 MOV78 MOV39 UPD42 MOV42 MOV44 MOV44 INS8 INS29 INS78 INS39 INS42 MOV44 MOV44 INS44 INS44 INS8 INS29 INS78 UPD39 MOV39 UPD42 MOV42 MOV44 MOV44 INS44 INS8 INS29 INS78 INS39 INS42 INS44 INS44 INS44 MOV8 INS66 INS65 INS66 INS66 INS66 INS60 INS60 INS60 INS60 INS65 INS65 INS65 INS5 INS42 UPD5 UPD42 INS21 INS21 INS65 INS65 INS65 INS65 INS65 INS65 INS42 UPD42 INS5 INS42 INS39 INS42 INS60 INS60 INS60 INS24 INS41 INS65 INS65 INS65 INS65 INS42 UPD43 UPD42 UPD43 UPD42 INS5 INS42 INS60 INS60 INS24 INS65 INS65 INS65 INS65 INS65 INS42 INS5 INS42 INS5 INS42 INS39 INS42 INS60 MOV41 UPD43 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 INS42 INS5 UPD43 MOV43 INS59 INS43 INS59 UPD43 UPD43 UPD5 UPD5 INS39 INS59 INS39 INS59 UPD66 MOV66 UPD66 MOV66 INS65 INS66 INS42 UPD66 MOV66 INS42 UPD66 MOV66 INS39 INS85 INS85 INS39 INS85 INS32 INS32 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS39 INS85 INS85 INS5 INS59 INS5 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS66 UPD42 UPD42 INS39 INS85 INS85 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS39 INS85 INS85 INS39 INS85 INS85 INS39 INS59 UPD42 UPD42 INS43 INS85 UPD42 INS32 UPD42 UPD42 MOV42 MOV32 UPD42 MOV42 INS42 MOV32 UPD42 UPD42 MOV32 UPD42 UPD42 MOV32 INS39 INS85 UPD42 INS39 INS85 UPD42 INS42 INS32 INS42 INS32 INS21 UPD66 MOV66 INS42 INS42 UPD42 MOV42 INS86 UPD42 MOV42 UPD42 MOV42 INS42 INS86 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS34 INS39 INS59 INS42 INS40 INS42 INS21 INS25 MOV21 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD43 MOV43 MOV85 INS42 INS32 UPD43 MOV43 MOV85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS21 INS66 INS42 INS34 UPD40 INS21 INS32 INS32 UPD42 MOV42 INS42 INS42 UPD5 INS40 INS34 UPD5 INS40 INS34 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 INS32 INS32 INS32 INS44 INS44 INS11 INS44 INS44 INS11 INS42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS34 INS7 INS27 INS8 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS34 INS7 INS7 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS39 INS85 INS39 INS85 UPD42 UPD42 INS2 INS42 INS2 INS42 INS2 INS42 INS2 INS42 INS42 INS42 INS42 INS21 INS21 INS21 INS5 INS42 INS5 INS42 UPD39 MOV39 MOV32 INS5 INS42 INS5 INS42 INS39 INS32 INS2 INS27 INS2 INS2 MOV21 INS27 INS2 INS27 INS42 INS11 INS10 INS32 INS42 INS32 UPD42 MOV42 INS32 INS42 INS32 UPD42 MOV42 UPD42 UPD42 UPD42 INS34 INS32 INS32 INS32 INS39 INS85 INS39 INS85 UPD42 UPD42 INS27 INS39 INS85 INS39 INS85 UPD42 MOV42 UPD42 MOV42 INS27 INS2 INS34 MOV32 INS11 INS2 MOV34 INS2 UPD34 MOV34 INS2 INS2 INS42 INS2 INS34 INS32 INS11 MOV39 MOV32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS2 INS2 INS2 INS42 INS42 INS2 UPD42 INS39 INS32 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 MOV42 INS42 INS2 INS34 INS42 INS42 INS2 INS42 INS39 INS32 UPD42 UPD42 UPD42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS42 INS2 UPD42 MOV42 INS42 INS42 INS42 INS42 INS2 INS42 INS2 INS2 INS42 INS42 INS42 INS42 INS2 INS42 INS2 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL22 DEL59 DEL23 DEL43 DEL42 DEL43 DEL14 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL14 DEL42 DEL43 DEL14 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL40 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL40 DEL32 DEL21 DEL34 DEL2 DEL34 DEL34 DEL2 DEL34 DEL42 DEL42 DEL42 DEL42 DEL65 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL2 DEL42 DEL42 DEL42 DEL2 DEL32 DEL42 DEL42 DEL2 DEL32 DEL39 DEL42 DEL11 DEL59 DEL60 DEL34 DEL41 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL11 DEL32 DEL42 DEL32 DEL27 DEL36 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL39 DEL32 DEL11 DEL32 DEL42 DEL42 DEL42 DEL32 DEL27 DEL36 DEL27 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL2 DEL42 DEL7 DEL21 DEL2 DEL42 DEL7 DEL21 DEL8 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL83 DEL5 DEL42 DEL44 DEL5 DEL42 DEL44 DEL31
HDFS-13818. Extend OIV to detect FSImage corruption. Contributed by Adam Antal.

Signed-off-by: Wei-Chiu Chuang <weichiu@apache.org>

+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.text.StringEscapeUtils;
+import java.util.concurrent.atomic.AtomicInteger;
+  static final String DEFAULT_DELIMITER = "\t";
+  static final String CRLF = StringUtils.CR + StringUtils.LF;
+
+
+    /** Returns the name of inode. */
+    String getName(long id) throws IOException;
+
+    /**
+     * Returns the id of the parent's inode, if mentioned in
+     * INodeDirectorySection, throws IgnoreSnapshotException otherwise.
+     */
+    long getParentId(long id) throws IOException;
-      private String getPath() {
+      String getPath() throws IgnoreSnapshotException {
-          return "/";
+          if (this.inode == INodeId.ROOT_INODE_ID) {
+            return "/";
+          } else {
+            if (LOG.isDebugEnabled()) {
+              LOG.debug("Not root inode with id {} having no parent.", inode);
+            }
+            throw PBImageTextWriter.createIgnoredSnapshotException(inode);
+          }
-          this.name = null;
+      String getName() throws IgnoreSnapshotException {
+        return name;
+      }
+
+      long getId() {
+        return inode;
+      }
+
+    /**
+     * If the Dir entry does not exist (i.e. the inode was not contained in
+     * INodeSection) we still create a Dir entry which throws exceptions
+     * for calls other than getId().
+     * We can make sure this way, the getId and getParentId calls will
+     * always succeed if we have the information.
+     */
+    private static class CorruptedDir extends Dir {
+      CorruptedDir(long inode) {
+        super(inode, null);
+      }
+
+      @Override
+      String getPath() throws IgnoreSnapshotException {
+        throw PBImageTextWriter.createIgnoredSnapshotException(getId());
+      }
+
+      @Override
+      String getName() throws IgnoreSnapshotException {
+        throw PBImageTextWriter.createIgnoredSnapshotException(getId());
+      }
+    }
+
+    private Dir getOrCreateCorrupted(long id) {
+      Dir dir = dirMap.get(id);
+      if (dir == null) {
+        dir = new CorruptedDir(id);
+        dirMap.put(id, dir);
+      }
+      return dir;
+    }
+
-      Dir parent = dirMap.get(parentId);
-      Dir child = dirMap.get(childId);
-      if (child != null) {
-        child.setParent(parent);
-      }
+      Dir parent = getOrCreateCorrupted(parentId);
+      Dir child = getOrCreateCorrupted(childId);
+      child.setParent(parent);
-        return "";
+        return "/";
-        PBImageTextWriter.ignoreSnapshotName(inode);
+        throw PBImageTextWriter.createIgnoredSnapshotException(inode);
+
+    @Override
+    public String getName(long id) throws IgnoreSnapshotException {
+      Dir dir = dirMap.get(id);
+      if (dir != null) {
+        return dir.getName();
+      }
+      throw PBImageTextWriter.createIgnoredSnapshotException(id);
+    }
+
+    @Override
+    public long getParentId(long id) throws IgnoreSnapshotException {
+      Dir parentDir = dirChildMap.get(id);
+      if (parentDir != null) {
+        return parentDir.getId();
+      }
+      throw PBImageTextWriter.createIgnoredSnapshotException(id);
+    }
-    @Override
-    public String getParentPath(long inode) throws IOException {
-      if (inode == INodeId.ROOT_INODE_ID) {
-        return "/";
-      }
+    private long getFromDirChildMap(long inode) throws IOException {
-        PBImageTextWriter.ignoreSnapshotName(inode);
+        throw PBImageTextWriter.createIgnoredSnapshotException(inode);
-      long parent = toLong(bytes);
+      return toLong(bytes);
+    }
+
+    @Override
+    public String getParentPath(long inode) throws IOException {
+      if (inode == INodeId.ROOT_INODE_ID) {
+        return "/";
+      }
+      long parent = getFromDirChildMap(inode);
-        bytes = dirMap.get(toBytes(parent));
+        byte[] bytes = dirMap.get(toBytes(parent));
-          PBImageTextWriter.ignoreSnapshotName(parent);
+          throw PBImageTextWriter.createIgnoredSnapshotException(inode);
-                parentName.isEmpty()? "/" : parentName).toString();
+                parentName.isEmpty() ? "/" : parentName).toString();
+
+    @Override
+    public String getName(long id) throws IOException {
+      byte[] bytes = dirMap.get(toBytes(id));
+      if (bytes != null) {
+        return toString(bytes);
+      }
+      throw PBImageTextWriter.createIgnoredSnapshotException(id);
+    }
+
+    @Override
+    public long getParentId(long id) throws IOException {
+      return getFromDirChildMap(id);
+    }
+  private String delimiter;
-  PBImageTextWriter(PrintStream out, String tempPath) throws IOException {
+  PBImageTextWriter(PrintStream out, String delimiter, String tempPath)
+      throws IOException {
+    this.delimiter = delimiter;
+  void append(StringBuffer buffer, int field) {
+    buffer.append(delimiter);
+    buffer.append(field);
+  }
+
+  void append(StringBuffer buffer, long field) {
+    buffer.append(delimiter);
+    buffer.append(field);
+  }
+
+  void append(StringBuffer buffer, String field) {
+    buffer.append(delimiter);
+
+    String escapedField = StringEscapeUtils.escapeCsv(field);
+    if (escapedField.contains(CRLF)) {
+      escapedField = escapedField.replace(CRLF, "%x0D%x0A");
+    } else if (escapedField.contains(StringUtils.LF)) {
+      escapedField = escapedField.replace(StringUtils.LF, "%x0A");
+    }
+
+    buffer.append(escapedField);
+  }
+
+  /**
+   * Method called at the end of output() phase after all the inodes
+   * with known parentPath has been printed out. Can be used to print
+   * additional data depending on the written inodes.
+   */
+  abstract protected void afterOutput() throws IOException;
+
+  void putDirChildToMetadataMap(long parentId, long childId)
+      throws IOException {
+    metadataMap.putDirChild(parentId, childId);
+  }
+
+  String getNodeName(long id) throws IOException {
+    return metadataMap.getName(id);
+  }
+
+  long getParentId(long id) throws IOException {
+    return metadataMap.getParentId(id);
+  }
+
+    afterOutput();
+   * Checks the inode (saves if directory), and counts them. Can be overridden
+   * if additional steps are taken when iterating through INodeSection.
+   */
+  protected void checkNode(INode p, AtomicInteger numDirs) throws IOException {
+    if (p.hasDirectory()) {
+      metadataMap.putDir(p);
+      numDirs.incrementAndGet();
+    }
+  }
+
+  /**
-  private void loadDirectoriesInINodeSection(InputStream in) throws IOException {
+  private void loadDirectoriesInINodeSection(InputStream in)
+      throws IOException {
-    int numDirs = 0;
+    AtomicInteger numDirs = new AtomicInteger(0);
-      if (p.hasDirectory()) {
-        metadataMap.putDir(p);
-        numDirs++;
-      }
+      checkNode(p, numDirs);
-  private void buildNamespace(InputStream in, List<Long> refIdList)
+  protected void buildNamespace(InputStream in, List<Long> refIdList)
+  void printIfNotEmpty(String line) {
+    if (!line.isEmpty()) {
+      out.println(line);
+    }
+  }
+
-        out.println(getEntry(parentPath, p));
+        printIfNotEmpty(getEntry(parentPath, p));
-  static void ignoreSnapshotName(long inode) throws IOException {
+  private static IgnoreSnapshotException createIgnoredSnapshotException(
+      long inode) {
-    throw new IgnoreSnapshotException();
+    return new IgnoreSnapshotException();

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS31 INS31 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS43 INS59 INS44 INS39 INS42 INS44 INS44 INS8 INS39 INS42 INS44 INS44 INS8 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS43 INS39 INS42 INS44 INS44 MOV43 INS8 INS43 INS42 INS44 INS43 INS8 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 UPD83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS42 INS42 INS45 INS42 INS42 INS27 INS29 INS43 INS42 INS44 INS43 INS29 INS39 INS42 INS44 INS43 INS31 INS31 INS29 INS83 INS83 INS42 INS43 INS31 INS31 INS31 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS43 INS42 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS43 INS8 INS42 INS42 INS43 INS42 INS21 INS43 INS42 INS39 INS42 INS21 INS21 INS43 INS42 INS39 INS42 INS21 INS21 INS43 INS42 INS43 INS42 INS21 INS60 INS25 INS21 INS65 INS42 INS39 INS42 INS39 INS42 INS21 INS42 INS39 INS42 INS42 INS41 INS39 INS42 INS42 INS41 INS21 INS65 INS43 INS42 INS43 INS42 INS42 MOV25 INS43 INS42 INS25 INS42 INS41 INS40 INS40 INS65 INS42 INS39 INS42 INS42 INS65 INS39 INS42 INS42 INS43 INS43 INS42 INS43 INS8 INS39 INS42 INS8 INS65 INS42 INS42 INS44 INS8 INS78 INS43 INS42 INS43 INS8 INS78 INS43 INS42 INS43 INS8 INS42 INS39 INS42 INS60 INS25 INS41 MOV21 INS42 INS42 INS39 INS42 INS42 INS60 INS25 INS53 INS42 INS39 INS42 INS42 INS60 INS25 INS53 INS39 INS42 INS42 MOV60 INS25 MOV25 INS41 INS42 INS42 INS39 INS42 INS42 INS60 INS25 INS53 INS42 INS39 INS42 INS42 INS41 INS42 INS7 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS25 INS32 INS66 INS66 INS66 INS32 INS32 INS32 INS32 INS66 INS66 INS42 INS42 INS43 INS42 INS38 INS8 MOV14 INS66 INS66 INS66 INS42 INS25 INS42 INS42 INS41 INS41 INS66 INS66 INS66 INS66 INS66 INS39 INS42 INS46 INS42 INS42 INS42 INS53 INS42 INS42 INS42 INS53 MOV43 INS59 INS27 INS8 INS42 INS43 INS43 INS59 INS27 INS8 INS32 INS43 INS59 INS27 INS8 INS32 MOV27 INS8 MOV32 INS5 INS59 INS27 INS8 INS32 INS32 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS21 INS32 INS21 MOV27 INS8 INS42 INS42 INS42 INS33 INS32 INS32 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS53 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS42 INS53 INS32 INS60 INS39 INS85 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS40 INS21 INS32 INS43 INS34 INS32 INS42 INS42 INS32 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS7 INS32 UPD42 UPD42 UPD45 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS5 INS59 INS42 INS42 INS32 INS32 INS42 INS32 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 MOV8 INS8 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS42 MOV32 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS32 INS22 INS40 MOV25 INS53 INS43 INS42 INS32 INS42 INS42 INS40 INS45 UPD42 INS52 INS42 INS32 INS8 INS32 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS21 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 DEL83 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL42 DEL42 DEL42 DEL33 DEL27 DEL8 DEL25 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL7 DEL21 DEL32 DEL21 DEL42 DEL37 DEL39 DEL34 DEL42 DEL39 DEL42 DEL53
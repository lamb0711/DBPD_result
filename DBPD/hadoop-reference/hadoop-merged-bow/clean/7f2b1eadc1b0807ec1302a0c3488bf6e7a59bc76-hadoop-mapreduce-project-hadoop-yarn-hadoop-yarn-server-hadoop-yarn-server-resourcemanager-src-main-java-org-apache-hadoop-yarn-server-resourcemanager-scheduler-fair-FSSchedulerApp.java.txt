MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import org.apache.hadoop.classification.InterfaceAudience.Private;
+import org.apache.hadoop.classification.InterfaceStability.Stable;
+import org.apache.hadoop.yarn.api.records.ApplicationId;
+import org.apache.hadoop.yarn.api.records.ContainerId;
+import org.apache.hadoop.yarn.api.records.ContainerStatus;
+import org.apache.hadoop.yarn.api.records.NodeId;
+import org.apache.hadoop.yarn.api.records.Resource;
+import org.apache.hadoop.yarn.factories.RecordFactory;
+import org.apache.hadoop.yarn.factory.providers.RecordFactoryProvider;
+import org.apache.hadoop.yarn.server.resourcemanager.RMAuditLogger;
+import org.apache.hadoop.yarn.server.resourcemanager.RMAuditLogger.AuditConstants;
+import org.apache.hadoop.yarn.server.resourcemanager.resource.Resources;
+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttemptState;
+import org.apache.hadoop.yarn.server.resourcemanager.rmcontainer.RMContainerEvent;
+import org.apache.hadoop.yarn.server.resourcemanager.rmcontainer.RMContainerEventType;
+import org.apache.hadoop.yarn.server.resourcemanager.rmcontainer.RMContainerFinishedEvent;
+import org.apache.hadoop.yarn.server.resourcemanager.rmcontainer.RMContainerImpl;
+import org.apache.hadoop.yarn.server.resourcemanager.rmcontainer.RMContainerReservedEvent;
+import org.apache.hadoop.yarn.server.resourcemanager.rmnode.RMNode;
+import org.apache.hadoop.yarn.server.resourcemanager.rmnode.RMNodeCleanContainerEvent;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.AppSchedulingInfo;
-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerApp;
-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerNode;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerApplication;
-/**
- * This class extends the application lifecycle management contained with
- * the {@link SchedulerApp} class and adds delay-scheduling information
- * specific to the FairScheduler.
- */
-public class FSSchedulerApp extends SchedulerApp {
-  private static final Log LOG = LogFactory.getLog(SchedulerApp.class);
+import com.google.common.collect.HashMultiset;
+import com.google.common.collect.Multiset;
+
+public class FSSchedulerApp extends SchedulerApplication {
+
+  private static final Log LOG = LogFactory.getLog(FSSchedulerApp.class);
+
+  private final RecordFactory recordFactory = RecordFactoryProvider
+      .getRecordFactory(null);
+
+  private final AppSchedulingInfo appSchedulingInfo;
+  private final Queue queue;
+
+  private final Resource currentConsumption = recordFactory
+      .newRecordInstance(Resource.class);
+  private Resource resourceLimit = recordFactory
+      .newRecordInstance(Resource.class);
+
+  private Map<ContainerId, RMContainer> liveContainers
+  = new HashMap<ContainerId, RMContainer>();
+  private List<RMContainer> newlyAllocatedContainers = 
+      new ArrayList<RMContainer>();
+
+  final Map<Priority, Map<NodeId, RMContainer>> reservedContainers = 
+      new HashMap<Priority, Map<NodeId, RMContainer>>();
+  
+  /**
+   * Count how many times the application has been given an opportunity
+   * to schedule a task at each priority. Each time the scheduler
+   * asks the application for a task at this priority, it is incremented,
+   * and each time the application successfully schedules a task, it
+   * is reset to 0.
+   */
+  Multiset<Priority> schedulingOpportunities = HashMultiset.create();
+  
+  Multiset<Priority> reReservations = HashMultiset.create();
+
+  Resource currentReservation = recordFactory
+      .newRecordInstance(Resource.class);
+
+  private final RMContext rmContext;
+  public FSSchedulerApp(ApplicationAttemptId applicationAttemptId, 
+      String user, Queue queue, ActiveUsersManager activeUsersManager,
+      RMContext rmContext, ApplicationStore store) {
+    this.rmContext = rmContext;
+    this.appSchedulingInfo = 
+        new AppSchedulingInfo(applicationAttemptId, user, queue,  
+            activeUsersManager, store);
+    this.queue = queue;
+  }
+
+  public ApplicationId getApplicationId() {
+    return this.appSchedulingInfo.getApplicationId();
+  }
+
+  @Override
+  public ApplicationAttemptId getApplicationAttemptId() {
+    return this.appSchedulingInfo.getApplicationAttemptId();
+  }
+
+  public String getUser() {
+    return this.appSchedulingInfo.getUser();
+  }
+
+  public synchronized void updateResourceRequests(
+      List<ResourceRequest> requests) {
+    this.appSchedulingInfo.updateResourceRequests(requests);
+  }
+
+  public Map<String, ResourceRequest> getResourceRequests(Priority priority) {
+    return this.appSchedulingInfo.getResourceRequests(priority);
+  }
+
+  public int getNewContainerId() {
+    return this.appSchedulingInfo.getNewContainerId();
+  }
+  
+  public Collection<Priority> getPriorities() {
+    return this.appSchedulingInfo.getPriorities();
+  }
+
+  public ResourceRequest getResourceRequest(Priority priority, String nodeAddress) {
+    return this.appSchedulingInfo.getResourceRequest(priority, nodeAddress);
+  }
+
+  public synchronized int getTotalRequiredResources(Priority priority) {
+    return getResourceRequest(priority, RMNode.ANY).getNumContainers();
+  }
+  
+  public Resource getResource(Priority priority) {
+    return this.appSchedulingInfo.getResource(priority);
+  }
+
+  /**
+   * Is this application pending?
+   * @return true if it is else false.
+   */
+  @Override
+  public boolean isPending() {
+    return this.appSchedulingInfo.isPending();
+  }
+
+  public String getQueueName() {
+    return this.appSchedulingInfo.getQueueName();
+  }
+
+  /**
+   * Get the list of live containers
+   * @return All of the live containers
+   */
+  @Override
+  public synchronized Collection<RMContainer> getLiveContainers() {
+    return new ArrayList<RMContainer>(liveContainers.values());
+  }
+
+  public synchronized void stop(RMAppAttemptState rmAppAttemptFinalState) {
+    // Cleanup all scheduling information
+    this.appSchedulingInfo.stop(rmAppAttemptFinalState);
+  }
+
+  @SuppressWarnings("unchecked")
+  public synchronized void containerLaunchedOnNode(ContainerId containerId,
+      NodeId nodeId) {
+    // Inform the container
+    RMContainer rmContainer = 
+        getRMContainer(containerId);
+    if (rmContainer == null) {
+      // Some unknown container sneaked into the system. Kill it.
+      this.rmContext.getDispatcher().getEventHandler()
+        .handle(new RMNodeCleanContainerEvent(nodeId, containerId));
+      return;
+    }
+
+    rmContainer.handle(new RMContainerEvent(containerId,
+      RMContainerEventType.LAUNCHED));
+  }
+
+  synchronized public void containerCompleted(RMContainer rmContainer,
+      ContainerStatus containerStatus, RMContainerEventType event) {
+    
+    Container container = rmContainer.getContainer();
+    ContainerId containerId = container.getId();
+    
+    // Inform the container
+    rmContainer.handle(
+        new RMContainerFinishedEvent(
+            containerId,
+            containerStatus, 
+            event)
+        );
+    LOG.info("Completed container: " + rmContainer.getContainerId() + 
+        " in state: " + rmContainer.getState() + " event:" + event);
+    
+    // Remove from the list of containers
+    liveContainers.remove(rmContainer.getContainerId());
+
+    RMAuditLogger.logSuccess(getUser(), 
+        AuditConstants.RELEASE_CONTAINER, "SchedulerApp", 
+        getApplicationId(), containerId);
+    
+    // Update usage metrics 
+    Resource containerResource = rmContainer.getContainer().getResource();
+    queue.getMetrics().releaseResources(getUser(), 1, containerResource);
+    Resources.subtractFrom(currentConsumption, containerResource);
+  }
+
+  synchronized public List<Container> pullNewlyAllocatedContainers() {
+    List<Container> returnContainerList = new ArrayList<Container>(
+        newlyAllocatedContainers.size());
+    for (RMContainer rmContainer : newlyAllocatedContainers) {
+      rmContainer.handle(new RMContainerEvent(rmContainer.getContainerId(),
+          RMContainerEventType.ACQUIRED));
+      returnContainerList.add(rmContainer.getContainer());
+    }
+    newlyAllocatedContainers.clear();
+    return returnContainerList;
+  }
+
+  public Resource getCurrentConsumption() {
+    return this.currentConsumption;
+  }
+
+  synchronized public void showRequests() {
+    if (LOG.isDebugEnabled()) {
+      for (Priority priority : getPriorities()) {
+        Map<String, ResourceRequest> requests = getResourceRequests(priority);
+        if (requests != null) {
+          LOG.debug("showRequests:" + " application=" + getApplicationId() + 
+              " headRoom=" + getHeadroom() + 
+              " currentConsumption=" + currentConsumption.getMemory());
+          for (ResourceRequest request : requests.values()) {
+            LOG.debug("showRequests:" + " application=" + getApplicationId()
+                + " request=" + request);
+          }
+        }
+      }
+    }
+  }
+
+  public synchronized RMContainer getRMContainer(ContainerId id) {
+    return liveContainers.get(id);
+  }
+
+  synchronized public void addSchedulingOpportunity(Priority priority) {
+    this.schedulingOpportunities.setCount(priority,
+        schedulingOpportunities.count(priority) + 1);
+  }
+
+  /**
+   * Return the number of times the application has been given an opportunity
+   * to schedule a task at the given priority since the last time it
+   * successfully did so.
+   */
+  synchronized public int getSchedulingOpportunities(Priority priority) {
+    return this.schedulingOpportunities.count(priority);
+  }
+
+  synchronized void resetReReservations(Priority priority) {
+    this.reReservations.setCount(priority, 0);
+  }
+
+  synchronized void addReReservation(Priority priority) {
+    this.reReservations.add(priority);
+  }
+
+  synchronized public int getReReservations(Priority priority) {
+    return this.reReservations.count(priority);
+  }
+
+  public synchronized int getNumReservedContainers(Priority priority) {
+    Map<NodeId, RMContainer> reservedContainers = 
+        this.reservedContainers.get(priority);
+    return (reservedContainers == null) ? 0 : reservedContainers.size();
+  }
+  
+  /**
+   * Get total current reservations.
+   * Used only by unit tests
+   * @return total current reservations
+   */
+  @Stable
+  @Private
+  public synchronized Resource getCurrentReservation() {
+    return currentReservation;
+  }
+
+  public synchronized RMContainer reserve(FSSchedulerNode node, Priority priority,
+      RMContainer rmContainer, Container container) {
+    // Create RMContainer if necessary
+    if (rmContainer == null) {
+      rmContainer = 
+          new RMContainerImpl(container, getApplicationAttemptId(), 
+              node.getNodeID(), rmContext.getDispatcher().getEventHandler(), 
+              rmContext.getContainerAllocationExpirer());
+        
+      Resources.addTo(currentReservation, container.getResource());
+      
+      // Reset the re-reservation count
+      resetReReservations(priority);
+    } else {
+      // Note down the re-reservation
+      addReReservation(priority);
+    }
+    rmContainer.handle(new RMContainerReservedEvent(container.getId(), 
+        container.getResource(), node.getNodeID(), priority));
+    
+    Map<NodeId, RMContainer> reservedContainers = 
+        this.reservedContainers.get(priority);
+    if (reservedContainers == null) {
+      reservedContainers = new HashMap<NodeId, RMContainer>();
+      this.reservedContainers.put(priority, reservedContainers);
+    }
+    reservedContainers.put(node.getNodeID(), rmContainer);
+    
+    LOG.info("Application " + getApplicationId() 
+        + " reserved container " + rmContainer
+        + " on node " + node + ", currently has " + reservedContainers.size()
+        + " at priority " + priority 
+        + "; currentReservation " + currentReservation.getMemory());
+    
+    return rmContainer;
+  }
+
+  public synchronized void unreserve(FSSchedulerNode node, Priority priority) {
+    Map<NodeId, RMContainer> reservedContainers = 
+        this.reservedContainers.get(priority);
+    RMContainer reservedContainer = reservedContainers.remove(node.getNodeID());
+    if (reservedContainers.isEmpty()) {
+      this.reservedContainers.remove(priority);
+    }
+    
+    // Reset the re-reservation count
+    resetReReservations(priority);
+
+    Resource resource = reservedContainer.getContainer().getResource();
+    Resources.subtractFrom(currentReservation, resource);
+
+    LOG.info("Application " + getApplicationId() + " unreserved " + " on node "
+        + node + ", currently has " + reservedContainers.size() + " at priority "
+        + priority + "; currentReservation " + currentReservation);
+  }
+
+  /**
+   * Has the application reserved the given <code>node</code> at the
+   * given <code>priority</code>?
+   * @param node node to be checked
+   * @param priority priority of reserved container
+   * @return true is reserved, false if not
+   */
+  public synchronized boolean isReserved(FSSchedulerNode node, Priority priority) {
+    Map<NodeId, RMContainer> reservedContainers = 
+        this.reservedContainers.get(priority);
+    if (reservedContainers != null) {
+      return reservedContainers.containsKey(node.getNodeID());
+    }
+    return false;
+  }
+
+  public synchronized float getLocalityWaitFactor(
+      Priority priority, int clusterNodes) {
+    // Estimate: Required unique resources (i.e. hosts + racks)
+    int requiredResources = 
+        Math.max(this.getResourceRequests(priority).size() - 1, 0);
+    
+    // waitFactor can't be more than '1' 
+    // i.e. no point skipping more than clustersize opportunities
+    return Math.min(((float)requiredResources / clusterNodes), 1.0f);
+  }
+
+  /**
+   * Get the list of reserved containers
+   * @return All of the reserved containers.
+   */
+  @Override
+  public synchronized List<RMContainer> getReservedContainers() {
+    List<RMContainer> reservedContainers = new ArrayList<RMContainer>();
+    for (Map.Entry<Priority, Map<NodeId, RMContainer>> e : 
+      this.reservedContainers.entrySet()) {
+      reservedContainers.addAll(e.getValue().values());
+    }
+    return reservedContainers;
+  }
+  
+  public synchronized void setHeadroom(Resource globalLimit) {
+    this.resourceLimit = globalLimit; 
+  }
+
+  /**
+   * Get available headroom in terms of resources for the application's user.
+   * @return available resource headroom
+   */
+  public synchronized Resource getHeadroom() {
+    // Corner case to deal with applications being slightly over-limit
+    if (resourceLimit.getMemory() < 0) {
+      resourceLimit.setMemory(0);
+    }
+    
+    return resourceLimit;
+  }
+
+  public Queue getQueue() {
+    return queue;
+  }
-  public FSSchedulerApp(ApplicationAttemptId applicationAttemptId,
-      String user, Queue queue, ActiveUsersManager activeUsersManager,
-      RMContext rmContext, ApplicationStore store) {
-    super(applicationAttemptId, user, queue, activeUsersManager,
-        rmContext, store);
-  }
-
-    super.resetSchedulingOpportunities(priority);
+    this.schedulingOpportunities.setCount(priority, 0);
-  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,
+  synchronized public RMContainer allocate(NodeType type, FSSchedulerNode node,
-    return super.allocate(type, node, priority, request, container);
+
+    // Required sanity check - AM can call 'allocate' to update resource 
+    // request without locking the scheduler, hence we need to check
+    if (getTotalRequiredResources(priority) <= 0) {
+      return null;
+    }
+    
+    // Create RMContainer
+    RMContainer rmContainer = new RMContainerImpl(container, this
+        .getApplicationAttemptId(), node.getNodeID(), this.rmContext
+        .getDispatcher().getEventHandler(), this.rmContext
+        .getContainerAllocationExpirer());
+
+    // Add it to allContainers list.
+    newlyAllocatedContainers.add(rmContainer);
+    liveContainers.put(container.getId(), rmContainer);    
+
+    // Update consumption and track allocations
+    appSchedulingInfo.allocate(type, node, priority, request, container);
+    Resources.addTo(currentConsumption, container.getResource());
+
+    // Inform the container
+    rmContainer.handle(
+        new RMContainerEvent(container.getId(), RMContainerEventType.START));
+
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("allocate: applicationAttemptId=" 
+          + container.getId().getApplicationAttemptId() 
+          + " container=" + container.getId() + " host="
+          + container.getNodeId().getHost() + " type=" + type);
+    }
+    RMAuditLogger.logSuccess(getUser(), 
+        AuditConstants.ALLOC_CONTAINER, "SchedulerApp", 
+        getApplicationId(), container.getId());
+    
+    return rmContainer;

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 INS40 INS40 UPD43 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 UPD42 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS74 INS59 INS83 INS74 INS59 INS83 INS74 INS59 INS29 INS74 INS59 INS74 INS59 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS74 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS74 INS42 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS8 INS29 INS78 INS83 INS39 INS42 INS8 INS83 INS43 INS42 INS8 INS29 INS78 INS83 INS83 INS74 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS79 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS83 INS74 INS42 INS8 INS83 INS43 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS78 INS78 INS83 INS83 INS43 INS42 INS8 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS78 INS83 INS83 INS74 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS74 INS42 INS14 INS65 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS21 INS21 INS21 INS42 INS41 INS42 INS42 INS41 INS42 INS41 INS74 INS42 INS21 INS43 INS43 INS43 INS43 INS42 INS41 INS41 INS43 INS43 INS41 INS42 INS43 INS42 INS43 INS42 INS41 INS43 INS42 INS41 INS42 INS43 INS42 INS41 INS65 INS65 INS42 INS41 INS42 INS41 INS65 INS65 INS42 INS43 INS43 INS41 INS43 INS42 INS21 INS42 INS45 INS43 INS42 INS43 INS42 INS60 INS25 INS21 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS21 INS21 INS21 INS21 INS60 INS21 INS21 INS43 INS43 INS60 INS70 INS21 INS41 INS42 INS41 INS25 INS42 INS43 INS42 INS41 INS43 INS42 INS21 INS65 INS43 INS42 INS41 INS43 INS42 INS21 INS43 INS42 INS21 INS43 INS42 INS41 INS43 INS42 INS60 INS41 INS65 INS65 INS42 INS42 INS42 INS41 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS21 INS60 INS25 INS21 INS21 INS41 INS43 INS42 INS43 INS42 INS60 INS60 INS25 INS21 INS60 INS21 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS25 INS41 INS43 INS42 INS39 INS42 INS60 INS41 INS65 INS65 INS42 INS43 INS43 INS60 INS70 INS41 INS43 INS42 INS21 INS65 INS65 INS42 INS25 INS41 INS42 INS41 UPD43 INS25 INS60 INS21 INS21 INS21 INS21 INS21 INS25 INS21 INS41 INS42 INS42 INS33 INS42 INS42 INS57 INS42 INS42 INS57 INS42 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS43 INS43 INS43 INS74 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS57 INS7 INS7 INS7 INS32 INS32 INS32 INS43 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS66 INS66 INS32 INS32 INS66 INS66 INS42 INS42 INS14 INS42 INS32 INS42 INS42 INS43 INS59 INS27 INS8 INS32 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS32 INS32 INS32 INS43 INS59 INS32 INS32 INS42 INS42 INS74 INS59 INS44 INS42 INS8 INS32 INS42 INS22 INS32 INS8 INS42 INS32 INS42 INS32 INS66 INS66 INS66 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS74 INS59 INS16 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS8 INS32 INS74 INS59 INS27 INS8 INS32 INS32 INS42 INS42 INS42 INS74 INS59 INS43 INS59 INS32 INS8 INS32 INS43 INS59 INS32 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS74 INS59 INS27 INS8 INS9 INS42 INS39 INS59 INS32 INS66 INS66 INS42 INS42 INS74 INS59 INS44 INS32 INS8 INS42 INS42 INS7 INS66 INS66 INS27 INS8 INS42 INS42 INS32 UPD42 INS27 INS8 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS32 INS8 INS32 INS42 UPD43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS42 INS42 INS42 INS43 INS43 INS74 INS43 INS22 INS42 INS22 INS14 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS32 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS74 INS32 INS22 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS41 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS32 INS40 INS45 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS34 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS14 INS43 INS42 INS21 INS21 INS42 INS42 INS52 INS42 INS42 INS42 INS70 INS42 INS42 INS42 INS22 INS42 INS42 INS27 INS22 INS42 INS42 INS22 INS42 INS42 INS34 INS22 INS42 INS42 INS22 INS42 INS42 INS43 INS43 INS43 INS42 INS32 INS36 INS34 INS32 INS42 INS33 INS21 INS21 INS21 INS21 INS42 INS42 INS14 INS43 INS43 INS43 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS43 INS43 INS43 INS42 INS32 INS42 INS33 INS41 INS42 INS32 INS42 INS42 INS36 INS34 INS43 INS43 INS42 INS14 INS74 INS42 INS22 INS42 INS21 INS22 INS42 INS32 INS34 INS21 INS22 INS42 INS42 INS34 INS32 INS34 INS41 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS21 INS42 INS42 INS32 INS40 INS45 INS32 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS52 INS42 INS52 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS40 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS43 INS42 INS42 INS52 INS42 INS42 INS42 INS32 INS43 INS42 INS40 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS32 INS42 INS32 INS32 INS44 INS32 INS8 INS52 INS42 INS32 INS34 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS27 INS42 INS42 INS7 INS32 INS32 INS32 INS43 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS7 INS32 INS42 INS42 INS45 INS32 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS32 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS45 INS32 INS45 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS32 INS42 INS42 INS27 INS34 INS27 INS42 INS42 INS74 INS43 INS43 INS74 INS52 INS42 INS32 INS52 INS42 INS42 INS42 INS32 INS52 INS42 INS42 INS42 INS33 INS43 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS32 INS40 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS43 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS52 INS42 INS42 INS33 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS14 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS32 INS32 INS34 INS11 INS42 INS43 INS43 INS40 INS42 INS43 INS43 INS43 INS42 INS42 INS32 INS42 INS42 INS34 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS43 INS32 INS40 INS42 INS42 INS42 INS74 INS59 INS27 INS8 INS43 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS74 INS52 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS39 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS22 INS42 INS52 INS42 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS32 INS42 INS33 INS21 INS70 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS43 INS43 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS43 INS42 INS42 INS42 INS21 INS27 INS32 INS45 INS32 INS45 INS32 INS42 INS32 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS32 INS45 INS42 INS45 INS45 INS42 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL46 DEL42 DEL42 DEL48 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL48 DEL41
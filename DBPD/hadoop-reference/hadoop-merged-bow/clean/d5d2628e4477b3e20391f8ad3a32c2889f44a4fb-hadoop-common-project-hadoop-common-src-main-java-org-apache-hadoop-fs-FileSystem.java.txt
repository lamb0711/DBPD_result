Merge r1360400 through r1399945 from trunk.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1399950 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collections;
+import org.apache.hadoop.fs.Options.ChecksumOpt;
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.util.DataChecksum;
+import com.google.common.annotations.VisibleForTesting;
+
+      @Override
-   * the only user of this value, and uses it to lookup this filesystem's
-   * service tokens.  The token cache will not attempt to acquire tokens if the
-   * service is null.
+   * the only user of the canonical service name, and uses it to lookup this
+   * filesystem's service tokens.
+   * If file system provides a token of its own then it must have a canonical
+   * name, otherwise canonical name can be null.
+   * 
+   * Default Impl: If the file system has child file systems 
+   * (such as an embedded file system) then it is assumed that the fs has no
+   * tokens of its own and hence returns a null name; otherwise a service
+   * name is built using Uri and port.
+   * 
+  @InterfaceAudience.LimitedPrivate({ "HDFS", "MapReduce" })
-    return SecurityUtil.buildDTServiceName(getUri(), getDefaultPort());
+    return (getChildFileSystems() == null)
+      ? SecurityUtil.buildDTServiceName(getUri(), getDefaultPort())
+      : null;
-    if (scheme == null) {                       // no scheme: use default FS
+    if (scheme == null && authority == null) {     // use default FS
-    if (authority == null) {                       // no authority
+    if (scheme != null && authority == null) {     // no authority
+      @Override
-   * Deprecated  - use @link {@link #getDelegationTokens(String)}
+   * This is an internal method that should have been declared protected
+   * but wasn't historically.
+   * Callers should use {@link #addDelegationTokens(String, Credentials)}
+   * 
-  @InterfaceAudience.LimitedPrivate({"HDFS", "MapReduce"})
-  @Deprecated
+  @InterfaceAudience.Private()
-   * Get one or more delegation tokens associated with the filesystem. Normally
-   * a file system returns a single delegation token. A file system that manages
-   * multiple file systems underneath, could return set of delegation tokens for
-   * all the file systems it manages.
+   * Obtain all delegation tokens used by this FileSystem that are not
+   * already present in the given Credentials.  Existing tokens will neither
+   * be verified as valid nor having the given renewer.  Missing tokens will
+   * be acquired and added to the given Credentials.
-   * @param renewer the account name that is allowed to renew the token.
+   * Default Impl: works for simple fs with its own token
+   * and also for an embedded fs whose tokens are those of its
+   * children file system (i.e. the embedded fs has not tokens of its
+   * own).
+   * 
+   * @param renewer the user allowed to renew the delegation tokens
+   * @param credentials cache in which to add new delegation tokens
-   *    If delegation tokens not supported then return a list of size zero.
-   * @throws IOException
-   */
-  @InterfaceAudience.LimitedPrivate( { "HDFS", "MapReduce" })
-  public List<Token<?>> getDelegationTokens(String renewer) throws IOException {
-    return new ArrayList<Token<?>>(0);
-  }
-  
-  /**
-   * @see #getDelegationTokens(String)
-   * This is similar to getDelegationTokens, with the added restriction that if
-   * a token is already present in the passed Credentials object - that token
-   * is returned instead of a new delegation token. 
-   * 
-   * If the token is found to be cached in the Credentials object, this API does
-   * not verify the token validity or the passed in renewer. 
-   * 
-   * 
-   * @param renewer the account name that is allowed to renew the token.
-   * @param credentials a Credentials object containing already knowing 
-   *   delegationTokens.
-   * @return a list of delegation tokens.
-  public List<Token<?>> getDelegationTokens(String renewer,
-      Credentials credentials) throws IOException {
-    List<Token<?>> allTokens = getDelegationTokens(renewer);
-    List<Token<?>> newTokens = new ArrayList<Token<?>>();
-    if (allTokens != null) {
-      for (Token<?> token : allTokens) {
-        Token<?> knownToken = credentials.getToken(token.getService());
-        if (knownToken == null) {
-          newTokens.add(token);
-        } else {
-          newTokens.add(knownToken);
+  public Token<?>[] addDelegationTokens(
+      final String renewer, Credentials credentials) throws IOException {
+    if (credentials == null) {
+      credentials = new Credentials();
+    }
+    final List<Token<?>> tokens = new ArrayList<Token<?>>();
+    collectDelegationTokens(renewer, credentials, tokens);
+    return tokens.toArray(new Token<?>[tokens.size()]);
+  }
+  
+  /**
+   * Recursively obtain the tokens for this FileSystem and all descended
+   * FileSystems as determined by getChildFileSystems().
+   * @param renewer the user allowed to renew the delegation tokens
+   * @param credentials cache in which to add the new delegation tokens
+   * @param tokens list in which to add acquired tokens
+   * @throws IOException
+   */
+  private void collectDelegationTokens(final String renewer,
+                                       final Credentials credentials,
+                                       final List<Token<?>> tokens)
+                                           throws IOException {
+    final String serviceName = getCanonicalServiceName();
+    // Collect token of the this filesystem and then of its embedded children
+    if (serviceName != null) { // fs has token, grab it
+      final Text service = new Text(serviceName);
+      Token<?> token = credentials.getToken(service);
+      if (token == null) {
+        token = getDelegationToken(renewer);
+        if (token != null) {
+          tokens.add(token);
+          credentials.addToken(service, token);
-    return newTokens;
+    // Now collect the tokens from the children
+    final FileSystem[] children = getChildFileSystems();
+    if (children != null) {
+      for (final FileSystem fs : children) {
+        fs.collectDelegationTokens(renewer, credentials, tokens);
+      }
+    }
+  /**
+   * Get all the immediate child FileSystems embedded in this FileSystem.
+   * It does not recurse and get grand children.  If a FileSystem
+   * has multiple child FileSystems, then it should return a unique list
+   * of those FileSystems.  Default is to return null to signify no children.
+   * 
+   * @return FileSystems used by this FileSystem
+   */
+  @InterfaceAudience.LimitedPrivate({ "HDFS" })
+  @VisibleForTesting
+  public FileSystem[] getChildFileSystems() {
+    return null;
+  }
+  
-    if (file.getLen() < start) {
+    if (file.getLen() <= start) {
+    // CRC32 is chosen as default as it is available in all 
+    // releases that support checksum.
+    // The client trash configuration is ignored.
-        conf.getInt("io.file.buffer.size", 4096));
+        conf.getInt("io.file.buffer.size", 4096),
+        false,
+        CommonConfigurationKeysPublic.FS_TRASH_INTERVAL_DEFAULT,
+        DataChecksum.Type.CRC32);
-    // only DFS support this
-    return create(f, permission, flags.contains(CreateFlag.OVERWRITE), bufferSize, replication, blockSize, progress);
+    return create(f, permission, flags, bufferSize, replication,
+        blockSize, progress, null);
-  
+  /**
+   * Create an FSDataOutputStream at the indicated Path with a custom
+   * checksum option
+   * @param f the file name to open
+   * @param permission
+   * @param flags {@link CreateFlag}s to use for this stream.
+   * @param bufferSize the size of the buffer to be used.
+   * @param replication required block replication for the file.
+   * @param blockSize
+   * @param progress
+   * @param checksumOpt checksum parameter. If null, the values
+   *        found in conf will be used.
+   * @throws IOException
+   * @see #setPermission(Path, FsPermission)
+   */
+  public FSDataOutputStream create(Path f,
+      FsPermission permission,
+      EnumSet<CreateFlag> flags,
+      int bufferSize,
+      short replication,
+      long blockSize,
+      Progressable progress,
+      ChecksumOpt checksumOpt) throws IOException {
+    // Checksum options are ignored by default. The file systems that
+    // implement checksum need to override this method. The full
+    // support is currently only available in DFS.
+    return create(f, permission, flags.contains(CreateFlag.OVERWRITE), 
+        bufferSize, replication, blockSize, progress);
+  }
+
-     int bytesPerChecksum) throws IOException {
+     ChecksumOpt checksumOpt) throws IOException {
+  
+  /**
+   * Cancel the deletion of the path when the FileSystem is closed
+   * @param f the path to cancel deletion
+   */
+  public boolean cancelDeleteOnExit(Path f) {
+    synchronized (deleteOnExit) {
+      return deleteOnExit.remove(f);
+    }
+  }
-          delete(path, true);
+          if (exists(path)) {
+            delete(path, true);
+          }
-      public boolean accept(Path file) {
-        return true;
-      }     
-    };
+    @Override
+    public boolean accept(Path file) {
+      return true;
+    }
+  };
-   * Return an array of FileStatus objects whose path names match pathPattern
-   * and is accepted by the user-supplied path filter. Results are sorted by
-   * their path names.
-   * Return null if pathPattern has no glob and the path does not exist.
-   * Return an empty array if pathPattern has a glob and no path matches it. 
+   * Return an array of FileStatus objects whose path names match
+   * {@code pathPattern} and is accepted by the user-supplied path filter.
+   * Results are sorted by their path names.
-   * @param pathPattern
-   *          a regular expression specifying the path pattern
-   * @param filter
-   *          a user-supplied path filter
-   * @return an array of FileStatus objects
+   * @param pathPattern a regular expression specifying the path pattern
+   * @param filter a user-supplied path filter
+   * @return null if {@code pathPattern} has no glob and the path does not exist
+   *         an empty array if {@code pathPattern} has a glob and no path
+   *         matches it else an array of {@link FileStatus} objects matching the
+   *         pattern
-    List<String> filePatterns = GlobExpander.expand(filename);
-    if (filePatterns.size() == 1) {
-      return globStatusInternal(pathPattern, filter);
-    } else {
-      List<FileStatus> results = new ArrayList<FileStatus>();
-      for (String filePattern : filePatterns) {
-        FileStatus[] files = globStatusInternal(new Path(filePattern), filter);
-        for (FileStatus file : files) {
-          results.add(file);
-        }
-      }
-      return results.toArray(new FileStatus[results.size()]);
-    }
-  }
-
-  private FileStatus[] globStatusInternal(Path pathPattern, PathFilter filter)
-      throws IOException {
-    Path[] parents = new Path[1];
-    int level = 0;
-    String filename = pathPattern.toUri().getPath();
+    List<FileStatus> allMatches = null;
-    // path has only zero component
-    if ("".equals(filename) || Path.SEPARATOR.equals(filename)) {
-      return getFileStatus(new Path[]{pathPattern});
-    }
-
-    // path has at least one component
-    String[] components = filename.split(Path.SEPARATOR);
-    // get the first component
-    if (pathPattern.isAbsolute()) {
-      parents[0] = new Path(Path.SEPARATOR);
-      level = 1;
-    } else {
-      parents[0] = new Path(Path.CUR_DIR);
-    }
-
-    // glob the paths that match the parent path, i.e., [0, components.length-1]
-    boolean[] hasGlob = new boolean[]{false};
-    Path[] parentPaths = globPathsLevel(parents, components, level, hasGlob);
-    FileStatus[] results;
-    if (parentPaths == null || parentPaths.length == 0) {
-      results = null;
-    } else {
-      // Now work on the last component of the path
-      GlobFilter fp = new GlobFilter(components[components.length - 1], filter);
-      if (fp.hasPattern()) { // last component has a pattern
-        // list parent directories and then glob the results
-        results = listStatus(parentPaths, fp);
-        hasGlob[0] = true;
-      } else { // last component does not have a pattern
-        // remove the quoting of metachars in a non-regexp expansion
-        String name = unquotePathComponent(components[components.length - 1]);
-        // get all the path names
-        ArrayList<Path> filteredPaths = new ArrayList<Path>(parentPaths.length);
-        for (int i = 0; i < parentPaths.length; i++) {
-          parentPaths[i] = new Path(parentPaths[i], name);
-          if (fp.accept(parentPaths[i])) {
-            filteredPaths.add(parentPaths[i]);
-          }
+    List<String> filePatterns = GlobExpander.expand(filename);
+    for (String filePattern : filePatterns) {
+      Path path = new Path(filePattern.isEmpty() ? Path.CUR_DIR : filePattern);
+      List<FileStatus> matches = globStatusInternal(path, filter);
+      if (matches != null) {
+        if (allMatches == null) {
+          allMatches = matches;
+        } else {
+          allMatches.addAll(matches);
-        // get all their statuses
-        results = getFileStatus(
-            filteredPaths.toArray(new Path[filteredPaths.size()]));
-
-    // Decide if the pathPattern contains a glob or not
-    if (results == null) {
-      if (hasGlob[0]) {
-        results = new FileStatus[0];
-      }
-    } else {
-      if (results.length == 0 ) {
-        if (!hasGlob[0]) {
-          results = null;
-        }
-      } else {
-        Arrays.sort(results);
-      }
+    
+    FileStatus[] results = null;
+    if (allMatches != null) {
+      results = allMatches.toArray(new FileStatus[allMatches.size()]);
+    } else if (filePatterns.size() > 1) {
+      // no matches with multiple expansions is a non-matching glob 
+      results = new FileStatus[0];
-  /*
-   * For a path of N components, return a list of paths that match the
-   * components [<code>level</code>, <code>N-1</code>].
-   */
-  private Path[] globPathsLevel(Path[] parents, String[] filePattern,
-      int level, boolean[] hasGlob) throws IOException {
-    if (level == filePattern.length - 1)
-      return parents;
-    if (parents == null || parents.length == 0) {
-      return null;
+  // sort gripes because FileStatus Comparable isn't parameterized...
+  @SuppressWarnings("unchecked") 
+  private List<FileStatus> globStatusInternal(Path pathPattern,
+      PathFilter filter) throws IOException {
+    boolean patternHasGlob = false;       // pathPattern has any globs
+    List<FileStatus> matches = new ArrayList<FileStatus>();
+
+    // determine starting point
+    int level = 0;
+    String baseDir = Path.CUR_DIR;
+    if (pathPattern.isAbsolute()) {
+      level = 1; // need to skip empty item at beginning of split list
+      baseDir = Path.SEPARATOR;
-    GlobFilter fp = new GlobFilter(filePattern[level]);
-    if (fp.hasPattern()) {
-      parents = FileUtil.stat2Paths(listStatus(parents, fp));
-      hasGlob[0] = true;
-    } else { // the component does not have a pattern
-      // remove the quoting of metachars in a non-regexp expansion
-      String name = unquotePathComponent(filePattern[level]);
-      for (int i = 0; i < parents.length; i++) {
-        parents[i] = new Path(parents[i], name);
+    
+    // parse components and determine if it's a glob
+    String[] components = null;
+    GlobFilter[] filters = null;
+    String filename = pathPattern.toUri().getPath();
+    if (!filename.isEmpty() && !Path.SEPARATOR.equals(filename)) {
+      components = filename.split(Path.SEPARATOR);
+      filters = new GlobFilter[components.length];
+      for (int i=level; i < components.length; i++) {
+        filters[i] = new GlobFilter(components[i]);
+        patternHasGlob |= filters[i].hasPattern();
+      }
+      if (!patternHasGlob) {
+        baseDir = unquotePathComponent(filename);
+        components = null; // short through to filter check
-    return globPathsLevel(parents, filePattern, level + 1, hasGlob);
+    
+    // seed the parent directory path, return if it doesn't exist
+    try {
+      matches.add(getFileStatus(new Path(baseDir)));
+    } catch (FileNotFoundException e) {
+      return patternHasGlob ? matches : null;
+    }
+    
+    // skip if there are no components other than the basedir
+    if (components != null) {
+      // iterate through each path component
+      for (int i=level; (i < components.length) && !matches.isEmpty(); i++) {
+        List<FileStatus> children = new ArrayList<FileStatus>();
+        for (FileStatus match : matches) {
+          // don't look for children in a file matched by a glob
+          if (!match.isDirectory()) {
+            continue;
+          }
+          try {
+            if (filters[i].hasPattern()) {
+              // get all children matching the filter
+              FileStatus[] statuses = listStatus(match.getPath(), filters[i]);
+              children.addAll(Arrays.asList(statuses));
+            } else {
+              // the component does not have a pattern
+              String component = unquotePathComponent(components[i]);
+              Path child = new Path(match.getPath(), component);
+              children.add(getFileStatus(child));
+            }
+          } catch (FileNotFoundException e) {
+            // don't care
+          }
+        }
+        matches = children;
+      }
+    }
+    // remove anything that didn't match the filter
+    if (!matches.isEmpty()) {
+      Iterator<FileStatus> iter = matches.iterator();
+      while (iter.hasNext()) {
+        if (!filter.accept(iter.next().getPath())) {
+          iter.remove();
+        }
+      }
+    }
+    // no final paths, if there were any globs return empty list
+    if (matches.isEmpty()) {
+      return patternHasGlob ? matches : null;
+    }
+    Collections.sort(matches);
+    return matches;
+  @Override
-   * Return a list of file status objects that corresponds to the list of paths
-   * excluding those non-existent paths.
-   * 
-   * @param paths
-   *          the list of paths we want information from
-   * @return a list of FileStatus objects
-   * @throws IOException
-   *           see specific implementation
-   */
-  private FileStatus[] getFileStatus(Path[] paths) throws IOException {
-    if (paths == null) {
-      return null;
-    }
-    ArrayList<FileStatus> results = new ArrayList<FileStatus>(paths.length);
-    for (int i = 0; i < paths.length; i++) {
-      try {
-        results.add(getFileStatus(paths[i]));
-      } catch (FileNotFoundException e) { // do nothing
-      }
-    }
-    return results.toArray(new FileStatus[results.size()]);
-  }
-  
-  /**
+      @Override
-      /** {@inheritDoc} */
+      @Override
-      /** {@inheritDoc} */
+      @Override
-      /** {@inheritDoc} */
+      @Override
+    @Override

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 MOV79 INS77 MOV79 INS5 UPD42 MOV44 MOV43 INS8 UPD83 INS39 UPD42 INS44 INS44 MOV43 INS8 INS29 INS79 INS78 INS83 INS5 INS42 MOV8 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS44 MOV43 MOV8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 MOV5 INS42 MOV44 MOV44 MOV43 INS8 INS79 INS83 INS74 INS42 MOV44 MOV44 MOV43 INS8 INS78 MOV65 INS40 INS65 MOV65 MOV74 INS85 INS83 INS25 MOV60 INS21 INS41 UPD65 UPD65 MOV65 INS83 INS83 INS43 INS42 INS83 MOV74 INS42 INS60 MOV25 INS60 INS25 INS65 INS65 INS40 INS4 INS42 INS43 INS85 INS41 INS65 MOV65 INS65 MOV65 UPD65 MOV65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 UPD43 MOV43 UPD42 MOV42 INS74 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS65 INS65 INS43 INS42 INS51 INS65 INS65 INS65 INS65 MOV65 MOV60 INS60 MOV60 INS70 MOV60 INS25 MOV41 INS42 INS45 INS43 INS43 INS60 MOV60 MOV60 INS60 INS25 MOV60 INS60 MOV60 INS25 INS54 INS25 INS25 INS25 INS21 INS41 INS42 INS78 UPD66 UPD66 INS66 INS66 INS66 INS66 UPD66 INS66 INS16 INS27 INS27 INS66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 INS66 UPD66 INS66 UPD66 INS66 UPD66 INS42 INS66 INS27 INS8 INS83 INS32 INS32 UPD66 UPD66 UPD66 UPD66 INS42 UPD66 UPD42 MOV42 INS83 INS43 MOV59 INS83 INS5 INS59 INS27 INS8 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS66 INS45 INS42 UPD27 INS32 UPD66 MOV66 INS66 UPD42 UPD66 INS42 UPD42 INS66 INS65 UPD66 INS42 UPD66 INS42 INS66 INS42 INS42 INS42 INS66 INS66 INS42 INS68 INS42 UPD42 INS43 INS43 UPD42 MOV42 UPD42 MOV42 INS42 INS66 INS42 INS66 MOV42 INS42 INS8 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 MOV74 MOV59 MOV44 INS42 INS8 INS27 INS8 MOV25 INS42 INS42 INS39 INS59 INS74 MOV43 INS59 MOV32 INS8 MOV5 INS5 INS59 UPD27 MOV27 INS8 INS8 INS12 INS27 INS8 INS38 INS8 INS32 INS8 INS32 INS42 INS78 INS78 INS78 INS78 INS42 INS36 MOV32 INS33 MOV27 MOV27 INS27 INS27 INS42 INS33 INS21 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS3 UPD42 MOV42 UPD42 UPD42 INS60 MOV60 MOV25 INS43 INS85 INS42 INS32 INS42 INS33 INS70 INS9 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS69 INS69 INS42 INS42 MOV41 INS66 INS66 INS66 INS42 UPD42 INS33 INS60 MOV60 INS25 INS33 INS42 INS33 INS21 UPD27 MOV27 INS42 INS9 INS43 INS43 UPD42 INS42 INS40 MOV21 MOV21 INS42 INS33 MOV43 INS85 INS42 INS33 INS38 INS38 INS21 INS21 MOV24 INS25 MOV21 INS44 INS8 INS42 INS33 INS24 INS32 MOV60 INS61 UPD42 MOV42 UPD42 MOV42 INS41 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS33 INS42 INS33 MOV42 MOV33 UPD42 INS69 INS7 INS5 INS32 UPD42 INS83 INS43 INS59 INS8 INS42 INS42 INS44 INS42 INS8 MOV43 INS43 INS78 MOV43 INS59 INS74 INS27 INS8 INS7 INS42 INS42 INS32 MOV32 INS7 INS7 MOV37 INS38 INS8 INS43 UPD42 MOV42 INS41 INS58 INS27 MOV37 INS8 INS42 INS42 UPD74 INS32 INS8 INS16 INS32 INS33 INS43 INS42 INS14 MOV74 INS85 INS42 INS42 INS42 INS42 INS14 UPD42 UPD42 INS21 INS25 INS83 INS43 INS42 INS21 INS42 UPD42 INS42 INS42 INS42 INS42 INS14 INS43 INS43 UPD42 UPD42 MOV42 MOV33 INS25 INS42 MOV32 INS42 INS40 MOV42 INS42 INS42 MOV32 INS42 INS3 UPD40 INS21 INS42 MOV21 MOV21 UPD42 UPD42 INS32 INS42 INS16 INS39 INS59 INS36 INS38 MOV60 INS70 INS21 UPD43 INS42 INS32 INS42 INS42 INS25 INS42 INS42 INS33 INS78 INS42 INS78 INS42 INS43 INS43 INS42 UPD42 MOV42 INS7 INS27 INS8 INS42 INS32 INS8 MOV43 INS16 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 INS27 MOV8 INS8 UPD42 INS5 INS40 INS42 INS7 UPD42 MOV42 INS14 INS42 INS42 INS33 INS42 INS42 INS27 INS32 INS74 INS44 INS42 INS8 INS7 UPD42 INS42 INS42 INS38 INS8 INS42 INS42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS33 MOV21 MOV21 INS42 INS42 INS42 INS42 INS42 INS25 INS32 INS40 INS42 INS42 INS33 INS21 MOV43 INS85 INS42 INS32 UPD42 INS32 UPD42 MOV43 INS42 INS42 UPD40 MOV40 INS42 INS42 INS43 INS43 UPD42 MOV43 INS42 INS25 INS54 INS42 INS42 INS32 INS21 INS42 INS42 INS32 MOV8 INS42 INS42 INS32 UPD42 UPD42 MOV43 MOV2 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS74 INS38 INS8 INS8 MOV12 UPD42 MOV42 UPD42 MOV42 MOV32 INS32 UPD42 UPD42 UPD42 INS42 UPD42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 UPD42 INS43 INS43 INS32 INS18 INS25 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 MOV8 INS8 UPD42 MOV42 INS42 INS2 UPD42 MOV42 MOV21 INS60 INS60 INS21 INS42 INS42 MOV5 INS32 MOV43 INS59 MOV43 INS59 INS32 UPD42 INS42 INS42 INS32 INS42 INS32 INS42 INS14 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 UPD42 MOV42 INS2 MOV43 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 INS42 DEL42 DEL78 DEL66 DEL40 DEL45 DEL45 DEL4 DEL79 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL74 DEL43 DEL74 DEL34 DEL14 DEL41 DEL8 DEL42 DEL42 DEL43 DEL69 DEL68 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL32 DEL8 DEL8 DEL42 DEL44 DEL42 DEL8 DEL70 DEL43 DEL43 DEL76 DEL74 DEL74 DEL60 DEL42 DEL41 DEL8 DEL39 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL43 DEL85 DEL5 DEL42 DEL42 DEL33 DEL42 DEL34 DEL2 DEL42 DEL34 DEL2 DEL9 DEL42 DEL42 DEL42 DEL40 DEL34 DEL27 DEL2 DEL32 DEL45 DEL42 DEL32 DEL34 DEL42 DEL37 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL2 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL85 DEL5 DEL42 DEL32 DEL3 DEL32 DEL32 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL14 DEL7 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL8 DEL24 DEL42 DEL42 DEL43 DEL74 DEL40 DEL14 DEL42 DEL42 DEL2 DEL65 DEL29 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL42 DEL42 DEL14 DEL42 DEL32 DEL59 DEL60 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL70 DEL41 DEL8 DEL25 DEL8 DEL31 DEL83 DEL43 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL34 DEL3 DEL59 DEL60 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL60 DEL42 DEL34 DEL2 DEL42 DEL43 DEL40 DEL14 DEL7 DEL21 DEL8 DEL42 DEL34 DEL2 DEL42 DEL43 DEL40 DEL14 DEL7 DEL21 DEL8 DEL25 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL9 DEL4 DEL3 DEL59 DEL60 DEL27 DEL40 DEL34 DEL27 DEL27 DEL42 DEL43 DEL42 DEL42 DEL40 DEL34 DEL27 DEL2 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL40 DEL14 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL40 DEL34 DEL27 DEL42 DEL34 DEL2 DEL38 DEL8 DEL25 DEL8 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL83 DEL85 DEL5 DEL42 DEL85 DEL5 DEL44 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL34 DEL27 DEL27 DEL42 DEL41 DEL25 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL42 DEL34 DEL2 DEL9 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL27 DEL33 DEL41 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL32 DEL21 DEL8 DEL54 DEL8 DEL24 DEL42 DEL43 DEL85 DEL5 DEL32 DEL3 DEL32 DEL41 DEL8 DEL31 DEL65 DEL66 DEL65 DEL29 DEL65 DEL66 DEL65 DEL29 DEL65 DEL66 DEL65 DEL29
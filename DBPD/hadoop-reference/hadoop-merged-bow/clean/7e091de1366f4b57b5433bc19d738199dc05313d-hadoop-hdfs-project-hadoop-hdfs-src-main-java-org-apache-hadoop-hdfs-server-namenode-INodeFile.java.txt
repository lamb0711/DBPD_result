HDFS-8058. Erasure coding: use BlockInfo[] for both striped and contiguous blocks in INodeFile. Contributed by Zhe Zhang and Yi Liu.

-import org.apache.hadoop.hdfs.server.blockmanagement.BlockInfoContiguousUnderConstruction;
-import org.apache.hadoop.hdfs.server.blockmanagement.BlockInfoStripedUnderConstruction;
-   * [4-bit storagePolicyID][12-bit replication][48-bit preferredBlockSize]
+   * [4-bit storagePolicyID][1-bit isStriped]
+   * [11-bit replication][48-bit preferredBlockSize]
-    REPLICATION(PREFERRED_BLOCK_SIZE.BITS, 12, 0),
-    STORAGE_POLICY_ID(REPLICATION.BITS, BlockStoragePolicySuite.ID_BIT_LENGTH,
+    REPLICATION(PREFERRED_BLOCK_SIZE.BITS, 11, 0),
+    IS_STRIPED(REPLICATION.BITS, 1, 0),
+    STORAGE_POLICY_ID(IS_STRIPED.BITS, BlockStoragePolicySuite.ID_BIT_LENGTH,
+    static boolean isStriped(long header) {
+      long isStriped = IS_STRIPED.BITS.retrieve(header);
+      Preconditions.checkState(isStriped == 0 || isStriped == 1);
+      return isStriped == 1;
+    }
+
-        byte storagePolicyID) {
+        boolean isStriped, byte storagePolicyID) {
-      h = REPLICATION.BITS.combine(replication, h);
+      // Replication factor for striped files is zero
+      if (isStriped) {
+        h = REPLICATION.BITS.combine(0L, h);
+        h = IS_STRIPED.BITS.combine(1L, h);
+      } else {
+        h = REPLICATION.BITS.combine(replication, h);
+        h = IS_STRIPED.BITS.combine(0L, h);
+      }
-  private BlockInfoContiguous[] blocks;
+  private BlockInfo[] blocks;
-            long atime, BlockInfoContiguous[] blklist, short replication,
+            long atime, BlockInfo[] blklist, short replication,
-         preferredBlockSize, (byte) 0);
+        preferredBlockSize, (byte) 0, false);
-      long atime, BlockInfoContiguous[] blklist, short replication,
-      long preferredBlockSize, byte storagePolicyID) {
+      long atime, BlockInfo[] blklist, short replication,
+      long preferredBlockSize, byte storagePolicyID, boolean isStriped) {
-    header = HeaderFormat.toLong(preferredBlockSize, replication, storagePolicyID);
-    this.blocks = blklist;
+    header = HeaderFormat.toLong(preferredBlockSize, replication, isStriped,
+        storagePolicyID);
+    if (blklist != null && blklist.length > 0) {
+      for (BlockInfo b : blklist) {
+        Preconditions.checkArgument(b.isStriped() == isStriped);
+      }
+    }
+    setBlocks(blklist);
-  /* Start of StripedBlock Feature */
-
-  public final FileWithStripedBlocksFeature getStripedBlocksFeature() {
-    return getFeature(FileWithStripedBlocksFeature.class);
-  }
-
-  public FileWithStripedBlocksFeature addStripedBlocksFeature() {
-    assert blocks == null || blocks.length == 0:
-        "The file contains contiguous blocks";
-    assert !isStriped();
-    this.setFileReplication((short) 0);
-    FileWithStripedBlocksFeature sb = new FileWithStripedBlocksFeature();
-    addFeature(sb);
-    return sb;
-  }
-
-  /** Used to make sure there is no contiguous block related info */
-  private boolean hasNoContiguousBlock() {
-    return (blocks == null || blocks.length == 0) && getFileReplication() == 0;
-  }
-
-      assertAllBlocksComplete(getBlocks());
+      assertAllBlocksComplete();
-  private void assertAllBlocksComplete(BlockInfo[] blks) {
-    if (blks == null) {
+  private void assertAllBlocksComplete() {
+    if (blocks == null) {
-    for (int i = 0; i < blks.length; i++) {
-      Preconditions.checkState(blks[i].isComplete(), "Failed to finalize"
+    for (int i = 0; i < blocks.length; i++) {
+      Preconditions.checkState(blocks[i].isComplete(), "Failed to finalize"
-          getClass().getSimpleName(), this, i, Arrays.asList(blks));
+          getClass().getSimpleName(), this, i, Arrays.asList(blocks));
-  /**
-   * Instead of adding a new block, this function is usually used while loading
-   * fsimage or converting the last block to UC/Complete.
-   */
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      assert !blk.isStriped();
-      this.blocks[index] = (BlockInfoContiguous) blk;
-    } else {
-      assert blk.isStriped();
-      assert hasNoContiguousBlock();
-      sb.setBlock(index, (BlockInfoStriped) blk);
-    }
+    Preconditions.checkArgument(blk.isStriped() == this.isStriped());
+    this.blocks[index] = blk;
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      assert !lastBlock.isStriped();
-      ucBlock = ((BlockInfoContiguous) lastBlock)
+    if (isStriped()) {
+      Preconditions.checkState(lastBlock.isStriped());
+      ucBlock = ((BlockInfoStriped) lastBlock)
-      assert hasNoContiguousBlock();
-      assert lastBlock.isStriped();
-      ucBlock = ((BlockInfoStriped) lastBlock)
+      Preconditions.checkState(!lastBlock.isStriped());
+      ucBlock = ((BlockInfoContiguous) lastBlock)
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      if (blocks == null || blocks.length == 0) {
-        return null;
-      }
-      int size_1 = blocks.length - 1;
-      if (!blocks[size_1].equals(oldblock)) {
-        return null;
-      }
-
-      BlockInfoContiguousUnderConstruction uc =
-          (BlockInfoContiguousUnderConstruction)blocks[size_1];
-      //copy to a new list
-      BlockInfoContiguous[] newlist = new BlockInfoContiguous[size_1];
-      System.arraycopy(blocks, 0, newlist, 0, size_1);
-      setContiguousBlocks(newlist);
-      return uc;
-    } else {
-      assert hasNoContiguousBlock();
-      return sb.removeLastBlock(oldblock);
+    if (blocks == null || blocks.length == 0) {
+      return null;
+    int size_1 = blocks.length - 1;
+    if (!blocks[size_1].equals(oldblock)) {
+      return null;
+    }
+
+    BlockInfoUnderConstruction uc =
+        (BlockInfoUnderConstruction)blocks[size_1];
+    //copy to a new list
+    BlockInfo[] newlist = new BlockInfo[size_1];
+    System.arraycopy(blocks, 0, newlist, 0, size_1);
+    setBlocks(newlist);
+    return uc;
-  // TODO striped
+  // TODO properly handle striped files
+
+  /**
+   * @return true if the file is in the striping layout.
+   */
+  @VisibleForTesting
+  @Override
+  public boolean isStriped() {
+    return HeaderFormat.isStriped(header);
+  }
+
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb != null) {
-      assert hasNoContiguousBlock();
-      return sb.getBlocks();
-    } else {
-      return this.blocks;
-    }
-  }
-
-  /** Used by snapshot diff */
-  public BlockInfoContiguous[] getContiguousBlocks() {
-  private void updateBlockCollection() {
-    if (blocks != null && blocks.length > 0) {
-      for(BlockInfoContiguous b : blocks) {
+  void updateBlockCollection() {
+    if (blocks != null) {
+      for(BlockInfo b : blocks) {
-    } else {
-      FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-      if (sb != null) {
-        sb.updateBlockCollection(this);
-      }
+      Preconditions.checkState(f.isStriped() == this.isStriped());
-    BlockInfoContiguous[] newlist =
-        new BlockInfoContiguous[size + totalAddedBlocks];
+    BlockInfo[] newlist =
+        new BlockInfo[size + totalAddedBlocks];
-    setContiguousBlocks(newlist);
+    setBlocks(newlist);
-   * add a contiguous block to the block list
+   * add a block to the block list
-  private void addContiguousBlock(BlockInfoContiguous newblock) {
+  void addBlock(BlockInfo newblock) {
+    Preconditions.checkArgument(newblock.isStriped() == this.isStriped());
-      this.setContiguousBlocks(new BlockInfoContiguous[]{newblock});
+      this.setBlocks(new BlockInfo[]{newblock});
-      BlockInfoContiguous[] newlist = new BlockInfoContiguous[size + 1];
+      BlockInfo[] newlist = new BlockInfo[size + 1];
-      this.setContiguousBlocks(newlist);
-    }
-  }
-
-  /** add a striped or contiguous block */
-  void addBlock(BlockInfo newblock) {
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      assert !newblock.isStriped();
-      addContiguousBlock((BlockInfoContiguous) newblock);
-    } else {
-      assert newblock.isStriped();
-      assert hasNoContiguousBlock();
-      sb.addBlock((BlockInfoStriped) newblock);
+      this.setBlocks(newlist);
-  public void setContiguousBlocks(BlockInfoContiguous[] blocks) {
+  private void setBlocks(BlockInfo[] blocks) {
+  public void clearBlocks() {
+    setBlocks(null);
+  }
+
-    BlockInfo[] blks = getBlocks();
-    if (blks != null && reclaimContext.collectedBlocks != null) {
-      for (BlockInfo blk : blks) {
+    if (blocks != null && reclaimContext.collectedBlocks != null) {
+      for (BlockInfo blk : blocks) {
-    setContiguousBlocks(null);
-
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb != null) {
-      sb.clear();
-    }
+    clearBlocks();
-    
+
-                                    boolean usePreferredBlockSize4LastUcBlock) {
-    BlockInfo[] blockInfos = getBlocks();
-    // In case of contiguous blocks
-    if (blockInfos == null || blockInfos.length == 0) {
+      boolean usePreferredBlockSize4LastUcBlock) {
+    if (blocks == null || blocks.length == 0) {
-    final int last = blockInfos.length - 1;
+    final int last = blocks.length - 1;
-    long size = blockInfos[last].getNumBytes();
-    if (blockInfos[last] instanceof BlockInfoContiguousUnderConstruction) {
-      if (!includesLastUcBlock) {
-        size = 0;
-      } else if (usePreferredBlockSize4LastUcBlock) {
-        size = getPreferredBlockSize();
-      }
-    } else if (blockInfos[last] instanceof BlockInfoStripedUnderConstruction) {
-      if (!includesLastUcBlock) {
-        size = 0;
-      } else if (usePreferredBlockSize4LastUcBlock) {
-        BlockInfoStripedUnderConstruction blockInfoStripedUC
-            = (BlockInfoStripedUnderConstruction) blockInfos[last];
-        size = getPreferredBlockSize() * blockInfoStripedUC.getDataBlockNum();
-      }
+    BlockInfo lastBlk = blocks[last];
+    long size = lastBlk.getNumBytes();
+    if (lastBlk instanceof BlockInfoUnderConstruction) {
+       if (!includesLastUcBlock) {
+         size = 0;
+       } else if (usePreferredBlockSize4LastUcBlock) {
+         size = isStriped()?
+             getPreferredBlockSize() *
+                 ((BlockInfoStriped)lastBlk).getDataBlockNum() :
+             getPreferredBlockSize();
+       }
-      size += blockInfos[i].getNumBytes();
+      size += blocks[i].getNumBytes();
-      return storagespaceConsumedWithStriped();
+      return storagespaceConsumedStriped();
-      return storagespaceConsumedWithReplication(bsp);
+      return storagespaceConsumedContiguous(bsp);
-  public final QuotaCounts storagespaceConsumedWithStriped() {
+  public final QuotaCounts storagespaceConsumedStriped() {
-    BlockInfo[] blockInfos = getBlocks();
-    if (blockInfos == null || blockInfos.length == 0) {
+    if (blocks == null || blocks.length == 0) {
-    long size;
-    final int last = blockInfos.length - 1;
-    if (blockInfos[last] instanceof BlockInfoStripedUnderConstruction) {
-      BlockInfoStripedUnderConstruction blockInfoStripedUC
-          =(BlockInfoStripedUnderConstruction)blockInfos[last];
-      size = getPreferredBlockSize() * blockInfoStripedUC.getTotalBlockNum();
-    } else {
-      // In case of last block is complete
-      BlockInfoStriped blockInfoStriped = (BlockInfoStriped)blockInfos[last];
-      size = blockInfoStriped.spaceConsumed();
+    for (BlockInfo b : blocks) {
+      Preconditions.checkState(b.isStriped());
+      long blockSize = b.isComplete() ?
+          ((BlockInfoStriped)b).spaceConsumed() : getPreferredBlockSize() *
+          ((BlockInfoStriped)b).getTotalBlockNum();
+      counts.addStorageSpace(blockSize);
-    for (int i = 0; i < last; i++) {
-      BlockInfoStriped blockInfoStriped = (BlockInfoStriped)blockInfos[i];
-      size += blockInfoStriped.spaceConsumed();
-    }
-
-    counts.addStorageSpace(size);
-  public final QuotaCounts storagespaceConsumedWithReplication(
+  public final QuotaCounts storagespaceConsumedContiguous(
-        BlockInfoContiguous[] diffBlocks = diff.getBlocks();
+        BlockInfo[] diffBlocks = diff.getBlocks();
-    BlockInfo[] blks = getBlocks();
-    return (blks == null || blks.length <= 1) ?
-        null : blks[blks.length - 2];
+    if (blocks == null || blocks.length <= 1) {
+      return null;
+    }
+    return blocks[blocks.length - 2];
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      return blocks == null || blocks.length == 0 ?
-          null : blocks[blocks.length - 1];
-    } else {
-      assert hasNoContiguousBlock();
-      return sb.getLastBlock();
-    }
+    return blocks == null || blocks.length == 0? null: blocks[blocks.length-1];
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      return blocks == null ? 0 : blocks.length;
-    } else {
-      assert hasNoContiguousBlock();
-      return sb.numBlocks();
-    }
+    return blocks == null ? 0 : blocks.length;
-    BlockInfo[] blks = getBlocks();
-    out.print(blks == null || blks.length == 0? null: blks[0]);
+    out.print(blocks == null || blocks.length == 0? null: blocks[0]);
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      truncateContiguousBlocks(n);
-    } else {
-      sb.truncateStripedBlocks(n);
-    }
-  }
-
-  private void truncateContiguousBlocks(int n) {
-    final BlockInfoContiguous[] newBlocks;
+    final BlockInfo[] newBlocks;
-      newBlocks = BlockInfoContiguous.EMPTY_ARRAY;
+      newBlocks = BlockInfo.EMPTY_ARRAY;
-      newBlocks = new BlockInfoContiguous[n];
-      System.arraycopy(blocks, 0, newBlocks, 0, n);
+      newBlocks = new BlockInfo[n];
+      System.arraycopy(getBlocks(), 0, newBlocks, 0, n);
-    setContiguousBlocks(newBlocks);
+    setBlocks(newBlocks);
-  public void collectBlocksBeyondSnapshot(BlockInfoContiguous[] snapshotBlocks,
+  public void collectBlocksBeyondSnapshot(BlockInfo[] snapshotBlocks,
-    BlockInfoContiguous[] oldBlocks = this.blocks;
-    if (snapshotBlocks == null || oldBlocks == null)
+    Preconditions.checkState(!isStriped());
+    BlockInfo[] oldBlocks = getBlocks();
+    if(snapshotBlocks == null || oldBlocks == null)
-    truncateContiguousBlocks(n);
+    truncateBlocksTo(n);
-    BlockInfoContiguous[] snapshotBlocks =
+    BlockInfo[] snapshotBlocks =
-  boolean isBlockInLatestSnapshot(BlockInfoContiguous block) {
+  boolean isBlockInLatestSnapshot(BlockInfo block) {
-    BlockInfoContiguous[] snapshotBlocks = getDiffs()
+    BlockInfo[] snapshotBlocks = getDiffs()
-
-  /**
-   * @return true if the file is in the striping layout.
-   */
-  @VisibleForTesting
-  @Override
-  public boolean isStriped() {
-    return getStripedBlocksFeature() != null;
-  }

MOV31 MOV31 INS72 INS31 UPD5 INS44 MOV8 MOV8 MOV29 MOV78 MOV78 INS39 INS42 INS8 MOV29 MOV78 MOV5 UPD42 UPD42 UPD83 UPD42 INS83 UPD42 INS8 UPD42 UPD42 MOV8 MOV8 UPD42 UPD34 INS42 INS40 INS34 INS34 UPD40 INS83 INS39 INS42 INS44 INS8 INS44 UPD43 UPD5 UPD5 INS39 INS42 INS25 INS21 MOV8 MOV21 MOV41 UPD43 INS21 MOV5 MOV21 MOV21 INS60 INS25 INS70 INS25 INS41 MOV5 INS21 MOV60 UPD43 INS66 UPD66 INS39 INS42 INS60 INS21 INS41 INS39 INS42 INS25 UPD42 UPD43 INS9 UPD43 INS27 INS8 INS32 INS32 INS32 UPD43 MOV5 MOV27 UPD5 UPD66 UPD42 INS32 UPD43 MOV43 MOV27 INS43 INS39 INS59 MOV62 MOV8 MOV27 INS44 INS42 INS8 INS27 INS8 INS2 UPD5 INS32 UPD5 UPD42 UPD5 INS39 INS59 INS32 INS27 INS42 INS8 INS8 UPD42 UPD42 INS27 INS27 INS70 INS42 INS42 UPD42 UPD40 INS42 INS42 INS27 INS42 INS42 INS21 INS21 UPD42 UPD42 UPD42 UPD42 INS42 INS21 UPD43 UPD42 INS42 INS42 INS27 MOV42 UPD42 INS33 UPD42 INS42 UPD42 INS2 INS42 INS32 INS42 UPD43 INS43 INS42 INS21 INS60 MOV21 MOV27 MOV27 INS41 UPD42 MOV42 MOV27 UPD43 UPD42 INS42 INS42 MOV38 UPD42 UPD42 UPD43 UPD43 INS42 INS32 INS42 INS42 INS27 INS42 INS34 INS21 INS21 MOV21 INS21 INS42 INS42 INS33 INS40 INS34 INS44 INS42 INS8 MOV32 INS32 INS32 INS32 UPD43 UPD5 INS32 UPD42 UPD5 MOV32 INS32 UPD5 UPD42 UPD42 UPD40 UPD42 MOV42 MOV42 INS42 INS42 UPD42 MOV38 MOV8 UPD42 MOV42 INS32 INS39 INS59 UPD42 UPD40 INS33 UPD40 UPD42 MOV42 UPD42 UPD42 INS40 INS42 INS42 INS27 INS27 INS7 INS7 INS7 INS43 INS42 INS21 INS52 INS42 UPD42 MOV42 INS42 MOV32 INS42 INS42 MOV38 UPD42 UPD43 UPD43 INS42 INS42 INS27 UPD43 INS52 INS42 UPD42 UPD43 UPD42 UPD42 UPD42 INS42 INS42 INS32 UPD42 MOV42 INS16 UPD42 MOV60 UPD42 UPD40 MOV32 INS42 INS34 INS42 INS34 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 UPD42 UPD42 UPD42 INS32 INS32 UPD42 UPD5 UPD42 UPD5 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS27 UPD42 UPD40 MOV5 INS40 INS42 INS34 INS42 INS40 INS42 INS34 INS42 INS40 INS42 INS34 INS42 INS42 INS42 INS27 UPD42 INS42 INS42 INS52 INS42 UPD43 UPD43 UPD42 INS42 INS42 INS36 INS42 MOV32 INS32 UPD42 INS32 INS42 UPD42 UPD42 INS16 MOV11 INS36 UPD42 MOV42 MOV42 INS42 INS42 INS32 INS27 MOV32 INS42 INS11 INS42 MOV32 MOV32 MOV43 INS42 INS36 INS11 MOV43 INS42 DEL40 DEL26 DEL40 DEL26 DEL52 DEL42 DEL22 DEL42 DEL7 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL45 DEL6 DEL6 DEL52 DEL42 DEL39 DEL34 DEL11 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL36 DEL42 DEL32 DEL34 DEL27 DEL27 DEL41 DEL8 DEL31 DEL42 DEL32 DEL42 DEL44 DEL66 DEL66 DEL65 DEL29 DEL38 DEL6 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL6 DEL42 DEL32 DEL6 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL32 DEL6 DEL6 DEL6 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL32 DEL6 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL32 DEL6 DEL8 DEL52 DEL42 DEL22 DEL41 DEL8 DEL25 DEL8 DEL66 DEL65 DEL29 DEL42 DEL43 DEL85 DEL5 DEL83 DEL40 DEL34 DEL27 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL83 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL38 DEL6 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL6 DEL42 DEL32 DEL6 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL39 DEL2 DEL42 DEL32 DEL42 DEL42 DEL2 DEL42 DEL38 DEL42 DEL34 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL2 DEL11 DEL59 DEL60 DEL42 DEL27 DEL42 DEL42 DEL2 DEL42 DEL43 DEL62 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL25 DEL25 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL42 DEL42 DEL2 DEL39 DEL42 DEL59 DEL60 DEL83 DEL39 DEL42 DEL40 DEL34 DEL27 DEL59 DEL60 DEL42 DEL42 DEL2 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL2 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL27 DEL7 DEL21 DEL8 DEL42 DEL59 DEL60 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL2 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL43 DEL85 DEL5 DEL60 DEL42 DEL59 DEL60 DEL27 DEL36 DEL33 DEL2 DEL16 DEL41 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL32 DEL6 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL32 DEL6 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL59 DEL60 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL83 DEL39 DEL42 DEL42 DEL32 DEL33 DEL27 DEL41 DEL8 DEL31
YARN-5109. timestamps are stored unencoded causing parse errors (Varun Saxena via sjlee)

-  SPACE(" ", "%2$");
+  SPACE(" ", "%2$"),
+
+  /**
+   * separator in values, often used to avoid having these in qualifiers and
+   * names.
+   */
+  TAB("\t", "%3$");
-  private static final byte[] EMPTY_BYTES = new byte[0];
+  /**
+   * Indicator for variable size of an individual segment in a split. The
+   * segment ends wherever separator is encountered.
+   * Typically used for string.
+   * Also used to indicate that there is no fixed number of splits which need to
+   * be returned. If split limit is specified as this, all possible splits are
+   * returned.
+   */
+  public static final int VARIABLE_SIZE = 0;
+
+
+  /** empty string. */
+  public static final String EMPTY_STRING = "";
+
+  /** empty bytes. */
+  public static final byte[] EMPTY_BYTES = new byte[0];
-
-    return TimelineStorageUtils.split(source, this.bytes, limit);
+    return split(source, this.bytes, limit);
+  }
+
+  /**
+   * Splits the source array into multiple array segments using this separator.
+   * The sizes indicate the sizes of the relative components/segments.
+   * In case one of the segments contains this separator before the specified
+   * size is reached, the separator will be considered part of that segment and
+   * we will continue till size is reached.
+   * Variable length strings cannot contain this separator and are indiced with
+   * a size of {@value #VARIABLE_SIZE}. Such strings are encoded for this
+   * separator and decoded after the results from split is returned.
+   *
+   * @param source byte array to be split.
+   * @param sizes sizes of relative components/segments.
+   * @return source split by this separator as per the sizes specified..
+   */
+  public byte[][] split(byte[] source, int[] sizes) {
+    return split(source, this.bytes, sizes);
-   * @param source to be split
+   * @param source byte array to be split
-    return TimelineStorageUtils.split(source, this.bytes);
+    return split(source, this.bytes);
+  }
+
+  /**
+   * Returns a list of ranges identifying [start, end) -- closed, open --
+   * positions within the source byte array that would be split using the
+   * separator byte array.
+   * The sizes indicate the sizes of the relative components/segments.
+   * In case one of the segments contains this separator before the specified
+   * size is reached, the separator will be considered part of that segment and
+   * we will continue till size is reached.
+   * Variable length strings cannot contain this separator and are indiced with
+   * a size of {@value #VARIABLE_SIZE}. Such strings are encoded for this
+   * separator and decoded after the results from split is returned.
+   *
+   * @param source the source data
+   * @param separator the separator pattern to look for
+   * @param sizes indicate the sizes of the relative components/segments.
+   * @return a list of ranges.
+   */
+  private static List<Range> splitRanges(byte[] source, byte[] separator,
+      int[] sizes) {
+    List<Range> segments = new ArrayList<Range>();
+    if (source == null || separator == null) {
+      return segments;
+    }
+    // VARIABLE_SIZE here indicates that there is no limit to number of segments
+    // to return.
+    int limit = VARIABLE_SIZE;
+    if (sizes != null && sizes.length > 0) {
+      limit = sizes.length;
+    }
+    int start = 0;
+    int currentSegment = 0;
+    itersource: for (int i = 0; i < source.length; i++) {
+      for (int j = 0; j < separator.length; j++) {
+        if (source[i + j] != separator[j]) {
+          continue itersource;
+        }
+      }
+      // all separator elements matched
+      if (limit > VARIABLE_SIZE) {
+        if (segments.size() >= (limit - 1)) {
+          // everything else goes in one final segment
+          break;
+        }
+        if (sizes != null) {
+          int currentSegExpectedSize = sizes[currentSegment];
+          if (currentSegExpectedSize > VARIABLE_SIZE) {
+            int currentSegSize = i - start;
+            if (currentSegSize < currentSegExpectedSize) {
+              // Segment not yet complete. More bytes to parse.
+              continue itersource;
+            } else if (currentSegSize > currentSegExpectedSize) {
+              // Segment is not as per size.
+              throw new IllegalArgumentException(
+                  "Segments not separated as per expected sizes");
+            }
+          }
+        }
+      }
+      segments.add(new Range(start, i));
+      start = i + separator.length;
+      // i will be incremented again in outer for loop
+      i += separator.length - 1;
+      currentSegment++;
+    }
+    // add in remaining to a final range
+    if (start <= source.length) {
+      if (sizes != null) {
+        // Check if final segment is as per size specified.
+        if (sizes[currentSegment] > VARIABLE_SIZE &&
+            source.length - start > sizes[currentSegment]) {
+          // Segment is not as per size.
+          throw new IllegalArgumentException(
+              "Segments not separated as per expected sizes");
+        }
+      }
+      segments.add(new Range(start, source.length));
+    }
+    return segments;
+  }
+
+  /**
+   * Splits based on segments calculated based on limit/sizes specified for the
+   * separator.
+   *
+   * @param source byte array to be split.
+   * @param segments specifies the range for each segment.
+   * @return a byte[][] split as per the segment ranges.
+   */
+  private static byte[][] split(byte[] source, List<Range> segments) {
+    byte[][] splits = new byte[segments.size()][];
+    for (int i = 0; i < segments.size(); i++) {
+      Range r = segments.get(i);
+      byte[] tmp = new byte[r.length()];
+      if (tmp.length > 0) {
+        System.arraycopy(source, r.start(), tmp, 0, r.length());
+      }
+      splits[i] = tmp;
+    }
+    return splits;
+  }
+
+  /**
+   * Splits the source array into multiple array segments using the given
+   * separator based on the sizes. This will naturally produce copied byte
+   * arrays for each of the split segments.
+   *
+   * @param source source array.
+   * @param separator separator represented as a byte array.
+   * @param sizes sizes of relative components/segments.
+   * @return byte[][] after splitting the source.
+   */
+  private static byte[][] split(byte[] source, byte[] separator, int[] sizes) {
+    List<Range> segments = splitRanges(source, separator, sizes);
+    return split(source, segments);
+  }
+
+  /**
+   * Splits the source array into multiple array segments using the given
+   * separator. This will naturally produce copied byte arrays for each of the
+   * split segments.
+   *
+   * @param source Source array.
+   * @param separator Separator represented as a byte array.
+   * @return byte[][] after splitting the source.
+   */
+  private static byte[][] split(byte[] source, byte[] separator) {
+    return split(source, separator, (int[]) null);
+  }
+
+  /**
+   * Splits the source array into multiple array segments using the given
+   * separator, up to a maximum of count items. This will naturally produce
+   * copied byte arrays for each of the split segments.
+   *
+   * @param source Source array.
+   * @param separator Separator represented as a byte array.
+   * @param limit a non-positive value indicates no limit on number of segments.
+   * @return byte[][] after splitting the input source.
+   */
+  private static byte[][] split(byte[] source, byte[] separator, int limit) {
+    int[] sizes = null;
+    if (limit > VARIABLE_SIZE) {
+      sizes = new int[limit];
+    }
+    List<Range> segments = splitRanges(source, separator, sizes);
+    return split(source, segments);

INS72 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS42 INS45 INS45 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS43 INS59 INS29 UPD83 INS29 INS83 INS5 INS42 INS44 INS44 MOV8 INS8 INS29 INS83 INS83 INS74 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS44 INS8 INS65 INS65 INS42 INS34 INS65 INS42 INS42 INS45 INS65 INS65 INS65 INS65 INS65 INS39 INS85 INS85 INS5 INS42 INS5 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS43 INS5 INS42 INS5 INS42 INS5 INS42 INS60 INS25 INS60 INS25 INS60 INS60 INS30 INS25 INS41 INS65 INS65 INS65 INS65 INS39 INS85 INS85 INS5 INS42 INS74 INS42 INS60 INS24 INS41 INS65 INS65 INS65 INS65 INS65 INS39 INS85 INS85 INS5 INS42 INS5 INS42 INS5 INS42 INS60 INS41 INS65 INS65 INS65 INS65 INS39 INS85 INS85 INS5 INS42 INS5 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS39 INS85 INS85 INS5 INS42 INS5 INS42 INS39 INS42 INS60 INS25 INS60 INS41 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS39 INS85 INS39 INS85 UPD66 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS39 INS85 INS39 INS85 INS39 INS85 INS74 INS59 INS27 INS8 INS39 INS59 INS27 INS8 INS39 INS59 INS39 INS59 INS42 INS24 INS27 INS8 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS39 INS85 INS43 INS43 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS39 INS85 INS39 INS85 INS39 INS85 INS74 INS59 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS39 INS85 INS39 INS85 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS39 INS85 INS39 INS85 INS5 INS59 INS27 INS8 INS74 INS59 INS32 INS67 INS42 INS42 INS42 INS22 INS67 INS43 INS43 INS42 INS14 INS27 INS27 INS41 INS42 INS42 INS27 INS27 INS21 INS42 INS34 INS42 INS34 INS58 INS27 INS37 INS8 INS42 INS40 INS25 INS21 INS42 INS42 INS39 INS85 INS85 INS42 INS3 INS39 INS59 INS42 INS32 INS42 INS60 INS60 INS25 INS21 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS39 INS85 INS42 INS33 INS42 INS42 INS21 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS74 INS42 INS33 INS42 INS33 INS42 INS42 INS33 INS40 INS34 INS7 INS39 INS59 INS42 INS40 INS42 INS24 INS25 INS21 INS21 INS21 INS21 INS27 INS8 INS32 INS5 INS32 INS42 INS34 INS42 INS42 INS43 INS59 INS5 INS59 INS27 INS8 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS33 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS40 INS42 INS34 INS58 INS27 INS37 INS8 INS27 INS8 INS32 INS7 INS7 INS37 INS42 INS33 INS25 INS42 INS42 INS14 INS39 INS85 INS85 INS42 INS42 INS42 INS42 INS32 INS39 INS85 INS42 INS3 INS40 INS34 INS21 INS2 INS42 INS39 INS85 INS42 INS3 INS42 INS42 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS42 INS25 INS25 INS42 INS42 INS14 INS42 INS27 INS42 INS27 INS42 INS27 INS8 INS43 INS42 INS40 INS42 INS42 INS42 INS5 INS32 INS32 INS42 INS42 INS5 INS42 INS42 INS34 INS27 INS8 INS27 INS8 INS27 INS8 INS43 INS42 INS42 INS42 INS40 INS40 INS34 INS27 INS27 INS53 INS42 INS39 INS85 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS32 INS39 INS85 INS2 INS2 INS18 INS32 INS36 INS10 INS42 INS33 INS60 INS25 INS42 INS2 INS42 INS27 INS2 INS14 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS27 INS39 INS59 INS27 INS8 INS42 INS42 INS40 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS34 INS42 INS2 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS39 INS59 INS27 INS8 INS25 INS42 INS27 INS42 INS42 INS18 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS53 INS14 INS43 INS45 INS42 DEL42 DEL42
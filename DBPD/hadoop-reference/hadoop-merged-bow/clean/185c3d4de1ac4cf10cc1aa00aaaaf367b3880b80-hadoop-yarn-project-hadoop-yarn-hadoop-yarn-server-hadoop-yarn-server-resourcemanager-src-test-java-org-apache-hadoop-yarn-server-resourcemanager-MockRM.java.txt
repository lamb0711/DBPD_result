YARN-4807. MockAM#waitForState sleep duration is too long. (Yufei Gu via kasha)

-  
-  final private boolean useNullRMNodeLabelsManager;
+  private static final int SECOND = 1000;
+  private static final int TIMEOUT_MS_FOR_ATTEMPT = 40 * SECOND;
+  private static final int TIMEOUT_MS_FOR_CONTAINER_AND_NODE = 10 * SECOND;
+  private static final int WAIT_MS_PER_LOOP = 10;
+
+  private final boolean useNullRMNodeLabelsManager;
+  /**
+   * Wait until an application has reached a specified state.
+   * The timeout is 80 seconds.
+   * @param appId the id of an application
+   * @param finalState the application state waited
+   * @throws InterruptedException
+   *         if interrupted while waiting for the state transition
+   */
-      throws Exception {
+      throws InterruptedException {
-    final int timeoutMsecs = 80000;
-    final int waitMsPerLoop = 500;
-    int loop = 0;
-    while (!finalState.equals(app.getState()) &&
-        ((waitMsPerLoop * loop) < timeoutMsecs)) {
+    final int timeoutMsecs = 80 * SECOND;
+    int timeWaiting = 0;
+    while (!finalState.equals(app.getState())) {
+      if (timeWaiting >= timeoutMsecs) {
+        break;
+      }
+
-          " Waiting for state : " + finalState);
-      Thread.yield();
-      Thread.sleep(waitMsPerLoop);
-      loop++;
+              " Waiting for state : " + finalState);
+      Thread.sleep(WAIT_MS_PER_LOOP);
+      timeWaiting += WAIT_MS_PER_LOOP;
-    int waitedMsecs = waitMsPerLoop * loop;
+
-    if (waitedMsecs >= timeoutMsecs) {
-      Assert.fail("App state is not correct (timedout): expected: " +
-          finalState + " actual: " + app.getState() +
-          " for the application " + appId);
-    }
+    Assert.assertEquals("App State is not correct (timeout).", finalState,
+      app.getState());
+  /**
+   * Wait until an attempt has reached a specified state.
+   * The timeout is 40 seconds.
+   * @param attemptId the id of an attempt
+   * @param finalState the attempt state waited
+   * @throws InterruptedException
+   *         if interrupted while waiting for the state transition
+   */
-      RMAppAttemptState finalState)
-      throws Exception {
-    waitForState(attemptId, finalState, 40000);
+      RMAppAttemptState finalState) throws InterruptedException {
+    waitForState(attemptId, finalState, TIMEOUT_MS_FOR_ATTEMPT);
+  /**
+   * Wait until an attempt has reached a specified state.
+   * The timeout can be specified by the parameter.
+   * @param attemptId the id of an attempt
+   * @param finalState the attempt state waited
+   * @param timeoutMsecs the length of timeout in milliseconds
+   * @throws InterruptedException
+   *         if interrupted while waiting for the state transition
+   */
-      RMAppAttemptState finalState, int timeoutMsecs) throws Exception {
+      RMAppAttemptState finalState, int timeoutMsecs)
+      throws InterruptedException {
-    final int minWaitMsecs = 1000;
-    final int waitMsPerLoop = 10;
-    int loop = 0;
-    while (!finalState.equals(attempt.getAppAttemptState())
-        && waitMsPerLoop * loop < timeoutMsecs) {
-      LOG.info("AppAttempt : " + attemptId + " State is : " +
+    MockRM.waitForState(attempt, finalState, timeoutMsecs);
+  }
+
+  /**
+   * Wait until an attempt has reached a specified state.
+   * The timeout is 40 seconds.
+   * @param attempt an attempt
+   * @param finalState the attempt state waited
+   * @throws InterruptedException
+   *         if interrupted while waiting for the state transition
+   */
+  public static void waitForState(RMAppAttempt attempt,
+      RMAppAttemptState finalState) throws InterruptedException {
+    waitForState(attempt, finalState, TIMEOUT_MS_FOR_ATTEMPT);
+  }
+
+  /**
+   * Wait until an attempt has reached a specified state.
+   * The timeout can be specified by the parameter.
+   * @param attempt an attempt
+   * @param finalState the attempt state waited
+   * @param timeoutMsecs the length of timeout in milliseconds
+   * @throws InterruptedException
+   *         if interrupted while waiting for the state transition
+   */
+  public static void waitForState(RMAppAttempt attempt,
+      RMAppAttemptState finalState, int timeoutMsecs)
+      throws InterruptedException {
+    int timeWaiting = 0;
+    while (!finalState.equals(attempt.getAppAttemptState())) {
+      if (timeWaiting >= timeoutMsecs) {
+        break;
+      }
+
+      LOG.info("AppAttempt : " + attempt.getAppAttemptId() + " State is : " +
-      Thread.yield();
-      Thread.sleep(waitMsPerLoop);
-      loop++;
+      Thread.sleep(WAIT_MS_PER_LOOP);
+      timeWaiting += WAIT_MS_PER_LOOP;
-    int waitedMsecs = waitMsPerLoop * loop;
-    if (minWaitMsecs > waitedMsecs) {
-      Thread.sleep(minWaitMsecs - waitedMsecs);
-    }
+
-    if (waitedMsecs >= timeoutMsecs) {
-      Assert.fail("Attempt state is not correct (timedout): expected: "
-          + finalState + " actual: " + attempt.getAppAttemptState()+
-          " for the application attempt " + attemptId);
-    }
-  }
-
-  public void waitForContainerState(ContainerId containerId,
-      RMContainerState state) throws Exception {
-    // This method will assert if state is not expected after timeout.
-    Assert.assertTrue(waitForContainerState(containerId, state, 8 * 1000));
-  }
-
-  public boolean waitForContainerState(ContainerId containerId,
-      RMContainerState containerState, int timeoutMillisecs) throws Exception {
-    RMContainer container = getResourceScheduler().getRMContainer(containerId);
-    int timeoutSecs = 0;
-    while (((container == null) || !containerState.equals(container.getState()))
-        && timeoutSecs++ < timeoutMillisecs / 100) {
-      if(container == null){
-        container = getResourceScheduler().getRMContainer(containerId);
-      }
-      System.out.println("Container : " + containerId +
-          " Waiting for state : " + containerState);
-
-      Thread.sleep(100);
-
-      if (timeoutMillisecs <= timeoutSecs * 100) {
-        return false;
-      }
-    }
-
-    System.out.println("Container State is : " + container.getState());
-    Assert.assertEquals("Container state is not correct (timedout)",
-        containerState, container.getState());
-    return true;
-  }
-
-  public void waitForContainerAllocated(MockNM nm, ContainerId containerId)
-      throws Exception {
-    int timeoutSecs = 0;
-    while (getResourceScheduler().getRMContainer(containerId) == null
-        && timeoutSecs++ < 40) {
-      System.out.println("Waiting for" + containerId + " to be allocated.");
-      nm.nodeHeartbeat(true);
-      Thread.sleep(200);
-    }
-    Assert.assertNotNull("Failed in waiting for " + containerId + " " +
-        "allocation.", getResourceScheduler().getRMContainer(containerId));
+    Assert.assertEquals("Attempt state is not correct (timeout).", finalState,
+      attempt.getState());
-      Thread.sleep(200);
+      Thread.sleep(WAIT_MS_PER_LOOP);
-      Thread.sleep(200);
+      Thread.sleep(WAIT_MS_PER_LOOP);
+  /**
+   * Wait until a container has reached a specified state.
+   * The timeout is 10 seconds.
+   * @param nm A mock nodemanager
+   * @param containerId the id of a container
+   * @param containerState the container state waited
+   * @return if reach the state before timeout; false otherwise.
+   * @throws Exception
+   *         if interrupted while waiting for the state transition
+   *         or an unexpected error while MockNM is hearbeating.
+   */
-    // default is wait for 30,000 ms
-    return waitForState(nm, containerId, containerState, 30 * 1000);
+    return waitForState(nm, containerId, containerState,
+      TIMEOUT_MS_FOR_CONTAINER_AND_NODE);
-  
+
+  /**
+   * Wait until a container has reached a specified state.
+   * The timeout is specified by the parameter.
+   * @param nm A mock nodemanager
+   * @param containerId the id of a container
+   * @param containerState the container state waited
+   * @param timeoutMsecs the length of timeout in milliseconds
+   * @return if reach the state before timeout; false otherwise.
+   * @throws Exception
+   *         if interrupted while waiting for the state transition
+   *         or an unexpected error while MockNM is hearbeating.
+   */
-      RMContainerState containerState, int timeoutMillisecs) throws Exception {
+      RMContainerState containerState, int timeoutMsecs) throws Exception {
-        timeoutMillisecs);
+      timeoutMsecs);
-  
+
+  /**
+   * Wait until a container has reached a specified state.
+   * The timeout is 10 seconds.
+   * @param nms array of mock nodemanagers
+   * @param containerId the id of a container
+   * @param containerState the container state waited
+   * @return if reach the state before timeout; false otherwise.
+   * @throws Exception
+   *         if interrupted while waiting for the state transition
+   *         or an unexpected error while MockNM is hearbeating.
+   */
-      RMContainerState containerState, int timeoutMillisecs) throws Exception {
+      RMContainerState containerState) throws Exception {
+    return waitForState(nms, containerId, containerState,
+      TIMEOUT_MS_FOR_CONTAINER_AND_NODE);
+  }
+
+  /**
+   * Wait until a container has reached a specified state.
+   * The timeout is specified by the parameter.
+   * @param nms array of mock nodemanagers
+   * @param containerId the id of a container
+   * @param containerState the container state waited
+   * @param timeoutMsecs the length of timeout in milliseconds
+   * @return if reach the state before timeout; false otherwise.
+   * @throws Exception
+   *         if interrupted while waiting for the state transition
+   *         or an unexpected error while MockNM is hearbeating.
+   */
+  public boolean waitForState(Collection<MockNM> nms, ContainerId containerId,
+      RMContainerState containerState, int timeoutMsecs) throws Exception {
-    int timeoutSecs = 0;
-    while(container == null && timeoutSecs++ < timeoutMillisecs / 100) {
+    int timeWaiting = 0;
+    while (container == null) {
+      if (timeWaiting >= timeoutMsecs) {
+        return false;
+      }
+
-      Thread.sleep(100);
-      
-      if (timeoutMillisecs <= timeoutSecs * 100) {
+      Thread.sleep(WAIT_MS_PER_LOOP);
+      timeWaiting += WAIT_MS_PER_LOOP;
+    }
+
+    while (!containerState.equals(container.getState())) {
+      if (timeWaiting >= timeoutMsecs) {
-    }
-    Assert.assertNotNull("Container shouldn't be null", container);
-    while (!containerState.equals(container.getState())
-        && timeoutSecs++ < timeoutMillisecs / 100) {
+
-      Thread.sleep(100);
-
-      if (timeoutMillisecs <= timeoutSecs * 100) {
-        return false;
-      }
+      Thread.sleep(WAIT_MS_PER_LOOP);
+      timeWaiting += WAIT_MS_PER_LOOP;
-    
+
-    Assert.assertEquals("Container state is not correct (timedout)",
-      containerState, container.getState());
-  public void NMwaitForState(NodeId nodeid, NodeState finalState)
-      throws Exception {
-    RMNode node = getRMContext().getRMNodes().get(nodeid);
+  /**
+   * Wait until a node has reached a specified state.
+   * The timeout is 10 seconds.
+   * @param nodeId the id of a node
+   * @param finalState the node state waited
+   * @throws InterruptedException
+   *         if interrupted while waiting for the state transition
+   */
+  public void waitForState(NodeId nodeId, NodeState finalState)
+      throws InterruptedException {
+    RMNode node = getRMContext().getRMNodes().get(nodeId);
-    int timeoutSecs = 0;
-    while (!finalState.equals(node.getState()) && timeoutSecs++ < 20) {
+    int timeWaiting = 0;
+    while (!finalState.equals(node.getState())) {
+      if (timeWaiting >= TIMEOUT_MS_FOR_CONTAINER_AND_NODE) {
+        break;
+      }
+
-      Thread.sleep(500);
+      Thread.sleep(WAIT_MS_PER_LOOP);
+      timeWaiting += WAIT_MS_PER_LOOP;
+
-    am.waitForState(RMAppAttemptState.ALLOCATED);
+    waitForState(appAttemptId, RMAppAttemptState.ALLOCATED);
-    am.waitForState(RMAppAttemptState.ALLOCATED);
+    waitForState(am.getApplicationAttemptId(), RMAppAttemptState.ALLOCATED);
-    am.waitForState(RMAppAttemptState.FINISHING);
+    rm.waitForState(am.getApplicationAttemptId(), RMAppAttemptState.FINISHING);
-    am.waitForState(RMAppAttemptState.FINISHED);
+    rm.waitForState(am.getApplicationAttemptId(), RMAppAttemptState.FINISHED);

INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 MOV83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS39 MOV59 INS29 UPD43 INS29 INS83 INS39 INS42 MOV44 MOV44 INS43 INS8 INS29 INS83 INS39 INS42 MOV44 MOV44 MOV44 INS43 INS8 INS29 MOV83 INS83 MOV39 UPD42 MOV42 MOV44 MOV44 UPD43 MOV43 MOV8 INS29 INS83 UPD39 UPD42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 MOV44 MOV44 MOV44 MOV43 INS8 INS29 INS29 MOV83 MOV39 MOV42 INS44 MOV44 MOV44 MOV43 MOV8 INS29 INS29 UPD42 UPD43 INS42 INS34 UPD42 MOV42 INS27 UPD42 MOV42 INS27 UPD42 MOV42 UPD34 MOV34 INS65 INS65 INS65 INS65 UPD42 MOV21 INS65 INS65 INS65 INS65 INS42 INS21 INS65 INS65 INS65 INS65 INS65 INS42 MOV60 MOV21 MOV60 MOV21 INS65 INS65 INS65 INS65 UPD43 UPD42 UPD43 UPD42 UPD42 INS65 INS65 INS65 INS65 INS65 UPD43 UPD42 INS43 INS42 UPD42 UPD42 MOV42 MOV60 MOV61 MOV21 MOV21 INS65 INS65 INS65 INS65 INS65 INS65 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD42 INS65 INS65 INS65 INS65 INS65 INS65 INS74 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD42 INS65 INS65 INS65 INS65 UPD42 UPD42 INS34 INS42 INS34 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 MOV38 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 UPD42 UPD42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 UPD42 INS42 MOV38 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS43 INS43 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 MOV27 MOV38 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 MOV38 INS27 UPD42 INS25 UPD42 INS45 INS42 MOV32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 INS21 UPD45 UPD42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 UPD42 INS42 UPD42 INS25 INS21 INS25 INS21 UPD42 INS25 INS21 INS42 INS42 INS32 UPD42 INS32 UPD42 INS32 INS34 INS42 INS27 INS8 INS7 UPD27 INS7 UPD42 INS27 MOV8 INS7 INS27 MOV8 INS7 UPD42 INS27 INS8 INS7 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS10 UPD42 INS42 INS42 UPD42 INS42 INS10 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS10 INS42 INS42 INS42 UPD45 INS32 INS45 MOV32 UPD42 INS42 INS42 DEL83 DEL39 DEL23 DEL34 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL27 DEL36 DEL42 DEL27 DEL36 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL37 DEL39 DEL42 DEL42 DEL42 DEL27 DEL59 DEL60 DEL45 DEL42 DEL45 DEL45 DEL42 DEL27 DEL42 DEL42 DEL27 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL34 DEL34 DEL27 DEL32 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL83 DEL39 DEL34 DEL59 DEL60 DEL83 DEL39 DEL34 DEL59 DEL60 DEL39 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL27 DEL27 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL32 DEL45 DEL42 DEL27 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL37 DEL21 DEL8 DEL61 DEL39 DEL42 DEL42 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL27 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL42 DEL45 DEL42 DEL45 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL31 DEL42 DEL33 DEL27 DEL36 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL27 DEL36 DEL42 DEL37 DEL42 DEL34 DEL27 DEL27 DEL27 DEL33 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL40 DEL42 DEL34 DEL42 DEL42 DEL34 DEL27 DEL27 DEL9 DEL41 DEL8 DEL25 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL9 DEL41 DEL8 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL37 DEL34 DEL27 DEL27 DEL40 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL9 DEL32 DEL21 DEL34 DEL32 DEL21 DEL8 DEL61 DEL42 DEL42 DEL45 DEL42 DEL45 DEL45 DEL27 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL31 DEL34 DEL34 DEL31 DEL34 DEL34 DEL27 DEL42 DEL37 DEL42 DEL34 DEL27 DEL27 DEL27 DEL34 DEL42 DEL42 DEL34 DEL27 DEL27 DEL25 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL37 DEL42 DEL34 DEL27 DEL27 DEL27 DEL34 DEL42 DEL42 DEL34 DEL27 DEL27 DEL25 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL37 DEL34 DEL27 DEL27 DEL34 DEL42
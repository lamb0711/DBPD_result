HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.

+import org.apache.hadoop.util.Time;
-import static org.apache.hadoop.util.Time.now;
+  @Deprecated
-    final boolean status = renameToInternal(fsd, pc, src, dst, logRetryCache);
+    final boolean status = renameTo(fsd, pc, src, dst, logRetryCache);
+   * <br>
+   * Note: This is to be used by {@link FSEditLogLoader} only.
+   * <br>
+   */
+  @Deprecated
+  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,
+      long timestamp) throws IOException {
+    if (fsd.isDir(dst)) {
+      dst += Path.SEPARATOR + new Path(src).getName();
+    }
+    final INodesInPath srcIIP = fsd.getINodesInPath4Write(src, false);
+    final INodesInPath dstIIP = fsd.getINodesInPath4Write(dst, false);
+    return unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp);
+  }
+
+  /**
-  static boolean unprotectedRenameTo(
-      FSDirectory fsd, String src, String dst, long timestamp)
+  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,
+      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)
-    INodesInPath srcIIP = fsd.getINodesInPath4Write(src, false);
-      validateRenameSource(src, srcIIP);
+      validateRenameSource(srcIIP);
-    if (fsd.isDir(dst)) {
-      dst += Path.SEPARATOR + new Path(src).getName();
-    }
-
-    INodesInPath dstIIP = fsd.getINodesInPath4Write(dst, false);
-    renameToInternal(fsd, pc, src, dst, logRetryCache, collectedBlocks,
-        options);
+    renameTo(fsd, pc, src, dst, collectedBlocks, logRetryCache, options);
-  static void renameTo(
-      FSDirectory fsd, String src, String dst, long mtime,
-      BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)
-      throws IOException {
+  static void renameTo(FSDirectory fsd, FSPermissionChecker pc, String src,
+      String dst, BlocksMapUpdateInfo collectedBlocks, boolean logRetryCache,
+      Options.Rename... options) throws IOException {
+    final INodesInPath srcIIP = fsd.getINodesInPath4Write(src, false);
+    final INodesInPath dstIIP = fsd.getINodesInPath4Write(dst, false);
+    if (fsd.isPermissionEnabled()) {
+      // Rename does not operate on link targets
+      // Do not resolveLink when checking permissions of src and dst
+      // Check write access to parent of src
+      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,
+          false);
+      // Check write access to ancestor of dst
+      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null, null,
+          false);
+    }
+
+    final long mtime = Time.now();
-      if (unprotectedRenameTo(fsd, src, dst, mtime, collectedBlocks, options)) {
+      if (unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, mtime,
+          collectedBlocks, options)) {
+    fsd.getEditLog().logRename(src, dst, mtime, logRetryCache, options);
-   * .namenode.FSEditLog} only.
+   * .namenode.FSEditLogLoader} only.
-    boolean ret = unprotectedRenameTo(fsd, src, dst, timestamp,
+    final INodesInPath srcIIP = fsd.getINodesInPath4Write(src, false);
+    final INodesInPath dstIIP = fsd.getINodesInPath4Write(dst, false);
+    boolean ret = unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,
-  static boolean unprotectedRenameTo(
-      FSDirectory fsd, String src, String dst, long timestamp,
+  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,
+      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp,
-    final INodesInPath srcIIP = fsd.getINodesInPath4Write(src, false);
-    validateRenameSource(src, srcIIP);
+    validateRenameSource(srcIIP);
-    INodesInPath dstIIP = fsd.getINodesInPath4Write(dst, false);
-        if ((removedNum = fsd.removeLastINode(dstIIP)) != -1) {
-          removedDst = dstIIP.getLastINode();
+        if ((removedNum = fsd.removeLastINode(tx.dstIIP)) != -1) {
+          removedDst = tx.dstIIP.getLastINode();
-            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {
+            if (!removedDst.isInLatestSnapshot(tx.dstIIP.getLatestSnapshotId())) {
-                  Snapshot.CURRENT_STATE_ID, dstIIP.getLatestSnapshotId(),
+                  Snapshot.CURRENT_STATE_ID, tx.dstIIP.getLatestSnapshotId(),
-          fsd.addLastINodeNoQuotaCheck(dstIIP, removedDst);
+          fsd.addLastINodeNoQuotaCheck(tx.dstIIP, removedDst);
-   * @see #unprotectedRenameTo(FSDirectory, String, String, long)
-  private static boolean renameTo(
-      FSDirectory fsd, String src, String dst, long mtime)
-      throws IOException {
-    if (NameNode.stateChangeLog.isDebugEnabled()) {
-      NameNode.stateChangeLog.debug("DIR* FSDirectory.renameTo: " + src + " to "
-          + dst);
-    }
-    boolean stat = false;
-    fsd.writeLock();
-    try {
-      stat = unprotectedRenameTo(fsd, src, dst, mtime);
-    } finally {
-      fsd.writeUnlock();
-    }
-    return stat;
-  }
-
-  /**
-   * @deprecated See {@link #renameTo(FSDirectory, String, String, long)}
-   */
-  @Deprecated
-  private static boolean renameToInternal(
-      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,
-      boolean logRetryCache)
-      throws IOException {
+  private static boolean renameTo(FSDirectory fsd, FSPermissionChecker pc,
+      String src, String dst, boolean logRetryCache) throws IOException {
+    // Rename does not operate on link targets
+    // Do not resolveLink when checking permissions of src and dst
+    // Check write access to parent of src
+    final INodesInPath srcIIP = fsd.getINodesInPath4Write(src, false);
+    // Note: We should not be doing this.  This is move() not renameTo().
+    final String actualDst = fsd.isDir(dst) ?
+        dst + Path.SEPARATOR + new Path(src).getName() : dst;
+    final INodesInPath dstIIP = fsd.getINodesInPath4Write(actualDst, false);
-      //We should not be doing this.  This is move() not renameTo().
-      //but for now,
-      //NOTE: yes, this is bad!  it's assuming much lower level behavior
-      //      of rewriting the dst
-      String actualdst = fsd.isDir(dst) ? dst + Path.SEPARATOR + new Path
-          (src).getName() : dst;
-      // Rename does not operates on link targets
-      // Do not resolveLink when checking permissions of src and dst
-      // Check write access to parent of src
-      INodesInPath srcIIP = fsd.getINodesInPath(src, false);
-      INodesInPath dstIIP = fsd.getINodesInPath(actualdst, false);
-    long mtime = now();
-    @SuppressWarnings("deprecation")
-    final boolean stat = renameTo(fsd, src, dst, mtime);
+    if (NameNode.stateChangeLog.isDebugEnabled()) {
+      NameNode.stateChangeLog.debug("DIR* FSDirectory.renameTo: " + src + " to "
+          + dst);
+    }
+    final long mtime = Time.now();
+    boolean stat = false;
+    fsd.writeLock();
+    try {
+      stat = unprotectedRenameTo(fsd, src, actualDst, srcIIP, dstIIP, mtime);
+    } finally {
+      fsd.writeUnlock();
+    }
-  private static void renameToInternal(
-      FSDirectory fsd, FSPermissionChecker pc, String src, String dst,
-      boolean logRetryCache, BlocksMapUpdateInfo collectedBlocks,
-      Options.Rename... options)
-      throws IOException {
-    if (fsd.isPermissionEnabled()) {
-      // Rename does not operates on link targets
-      // Do not resolveLink when checking permissions of src and dst
-      // Check write access to parent of src
-      INodesInPath srcIIP = fsd.getINodesInPath(src, false);
-      fsd.checkPermission(pc, srcIIP, false, null, FsAction.WRITE, null, null,
-          false);
-      // Check write access to ancestor of dst
-      INodesInPath dstIIP = fsd.getINodesInPath(dst, false);
-      fsd.checkPermission(pc, dstIIP, false, FsAction.WRITE, null, null, null,
-          false);
-    }
-
-    long mtime = now();
-    renameTo(fsd, src, dst, mtime, collectedBlocks, options);
-    fsd.getEditLog().logRename(src, dst, mtime, logRetryCache, options);
-  }
-
-  private static void validateRenameSource(String src, INodesInPath srcIIP)
+  private static void validateRenameSource(INodesInPath srcIIP)
-      error = "rename source " + src + " is not found.";
+      error = "rename source " + srcIIP.getPath() + " is not found.";
-      isSrcInSnapshot = srcChild.isInLatestSnapshot(srcIIP
-          .getLatestSnapshotId());
+      isSrcInSnapshot = srcChild.isInLatestSnapshot(srcIIP.getLatestSnapshotId());

MOV26 MOV31 UPD40 INS78 INS29 UPD42 MOV44 MOV44 MOV44 INS8 INS44 INS44 MOV44 MOV44 INS44 INS44 MOV29 MOV79 UPD42 INS42 INS65 INS39 INS42 MOV25 INS60 MOV60 INS41 INS83 INS43 INS42 INS83 MOV43 INS42 UPD39 MOV39 INS60 INS60 INS25 INS60 MOV21 MOV60 INS60 INS83 MOV43 INS42 INS83 INS43 INS42 MOV60 MOV60 MOV60 MOV25 MOV25 MOV60 MOV21 INS54 INS66 INS66 INS65 INS66 INS66 INS83 INS43 INS59 INS83 MOV43 INS32 INS42 INS83 INS43 INS59 INS83 MOV43 INS59 MOV32 INS8 INS83 INS39 INS59 INS83 MOV43 MOV59 INS42 INS83 INS83 INS83 INS83 INS8 MOV8 INS42 UPD42 MOV42 INS42 INS32 MOV42 MOV42 MOV42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS32 INS42 INS32 MOV21 MOV21 INS42 INS32 UPD40 UPD42 INS21 UPD42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS7 INS42 INS42 INS42 INS32 UPD42 MOV42 MOV42 MOV42 INS42 INS42 UPD42 MOV42 MOV42 INS32 INS42 INS42 INS40 INS40 INS40 INS40 INS40 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL32 DEL7 DEL21 DEL8 DEL54 DEL42 DEL41 DEL8 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL66 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL65 DEL29 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL8 DEL25 DEL42 DEL45 DEL79 DEL83 DEL39 DEL42 DEL32 DEL59 DEL60 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL40 DEL43 DEL42 DEL44 DEL42 DEL43 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42
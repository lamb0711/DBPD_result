Merging r1543613 through r1543709 from trunk to branch HDFS-2832

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1543710 13f79535-47bb-0310-9956-ffa450edef68

-public class ZlibDecompressor implements Decompressor,DirectDecompressor {
+public class ZlibDecompressor implements Decompressor {
-    this.directBufferSize = directBufferSize;
+    this.directBufferSize = directBufferSize;    
-    userBuf = null;
-    
-  private int put(ByteBuffer dst, ByteBuffer src) {
-    // this will lop off data from src[pos:limit] into dst[pos:limit], using the
-    // min() of both remaining()
-    int l1 = src.remaining();
-    int l2 = dst.remaining();
-    int pos1 = src.position();
-    int pos2 = dst.position();
-    int len = Math.min(l1, l2);
-
-    if (len == 0) {
-      return 0;
-    }
-
-    ByteBuffer slice = src.slice();
-    slice.limit(len);
-    dst.put(slice);
-    src.position(pos1 + len);
-    return len;
-  }
-
-  public int decompress(ByteBuffer dst, ByteBuffer src) throws IOException {
-    assert dst.remaining() > 0 : "dst.remaining == 0";
-    int n = 0;
-    
-    /* fast path for clean state and direct buffers */
-    if((src != null && src.isDirect()) && dst.isDirect() && userBuf == null) {
-      /*
-       * TODO: fix these assumptions in inflateDirect(), eventually by allowing
-       * it to read position()/limit() directly
-       */
-      boolean cleanDst = (dst.position() == 0 && dst.remaining() == dst.capacity() && dst.remaining() >= directBufferSize);
-      boolean cleanState = (compressedDirectBufLen == 0 && uncompressedDirectBuf.remaining() == 0);
-      /* use the buffers directly */
-      if(cleanDst && cleanState) {
-        Buffer originalCompressed = compressedDirectBuf;
-        Buffer originalUncompressed = uncompressedDirectBuf;
-        int originalBufferSize = directBufferSize;
-        compressedDirectBuf = src;
-        compressedDirectBufOff = src.position();
-        compressedDirectBufLen = src.remaining();
-        uncompressedDirectBuf = dst;
-        directBufferSize = dst.remaining();
-        // Compress data
-        n = inflateBytesDirect();
-        dst.position(n);
-        if(compressedDirectBufLen > 0) {
-          src.position(compressedDirectBufOff);
-        } else {
-          src.position(src.limit());
-        }
-        compressedDirectBuf = originalCompressed;
-        uncompressedDirectBuf = originalUncompressed;        
-        compressedDirectBufOff = 0;
-        compressedDirectBufLen = 0;
-        directBufferSize = originalBufferSize;
-        return n;
-      }
-    }
-    
-    // Check if there is compressed data
-    if (uncompressedDirectBuf.remaining() > 0) {
-      n = put(dst, (ByteBuffer) uncompressedDirectBuf);
-    }
-
-    if (dst.remaining() == 0) {
-      return n;
-    } else {
-      if (needsInput()) {
-        // this does not update buffers if we have no userBuf
-        if (userBufLen <= 0) {
-          compressedDirectBufOff = 0;
-          compressedDirectBufLen = 0;
-          compressedDirectBuf.rewind().limit(directBufferSize);
-        }
-        if (src != null) {
-          assert src.remaining() > 0 : "src.remaining() == 0";
-        }
-      }
-
-      // if we have drained userBuf, read from src (ideally, do not mix buffer
-      // modes, but sometimes you can)
-      if (userBufLen == 0 && src != null && src.remaining() > 0) {
-        compressedDirectBufLen += put(((ByteBuffer) compressedDirectBuf), src);
-      }
-      
-      // Re-initialize the zlib's output direct buffer
-      uncompressedDirectBuf.rewind();
-      uncompressedDirectBuf.limit(directBufferSize);
-
-      // Compress data
-      int more = inflateBytesDirect();
-
-      uncompressedDirectBuf.limit(more);
-
-      // Get atmost 'len' bytes
-      int fill = put(dst, ((ByteBuffer) uncompressedDirectBuf));
-      return n + fill;
-    }
-  }
-
-  
+    
+  int inflateDirect(ByteBuffer src, ByteBuffer dst) throws IOException {
+    assert (this instanceof ZlibDirectDecompressor);
+    
+    ByteBuffer presliced = dst;
+    if (dst.position() > 0) {
+      presliced = dst;
+      dst = dst.slice();
+    }
+
+    Buffer originalCompressed = compressedDirectBuf;
+    Buffer originalUncompressed = uncompressedDirectBuf;
+    int originalBufferSize = directBufferSize;
+    compressedDirectBuf = src;
+    compressedDirectBufOff = src.position();
+    compressedDirectBufLen = src.remaining();
+    uncompressedDirectBuf = dst;
+    directBufferSize = dst.remaining();
+    int n = 0;
+    try {
+      n = inflateBytesDirect();
+      presliced.position(presliced.position() + n);
+      if (compressedDirectBufLen > 0) {
+        src.position(compressedDirectBufOff);
+      } else {
+        src.position(src.limit());
+      }
+    } finally {
+      compressedDirectBuf = originalCompressed;
+      uncompressedDirectBuf = originalUncompressed;
+      compressedDirectBufOff = 0;
+      compressedDirectBufLen = 0;
+      directBufferSize = originalBufferSize;
+    }
+    return n;
+  }
+  
+  public static class ZlibDirectDecompressor 
+      extends ZlibDecompressor implements DirectDecompressor {
+    public ZlibDirectDecompressor() {
+      super(CompressionHeader.DEFAULT_HEADER, 0);
+    }
+
+    public ZlibDirectDecompressor(CompressionHeader header, int directBufferSize) {
+      super(header, directBufferSize);
+    }
+    
+    @Override
+    public boolean finished() {
+      return (endOfInput && super.finished());
+    }
+    
+    @Override
+    public void reset() {
+      super.reset();
+      endOfInput = true;
+    }
+    
+    private boolean endOfInput;
+
+    @Override
+    public synchronized void decompress(ByteBuffer src, ByteBuffer dst)
+        throws IOException {
+      assert dst.isDirect() : "dst.isDirect()";
+      assert src.isDirect() : "src.isDirect()";
+      assert dst.remaining() > 0 : "dst.remaining() > 0";      
+      this.inflateDirect(src, dst);
+      endOfInput = !src.hasRemaining();
+    }
+
+    @Override
+    public synchronized void setDictionary(byte[] b, int off, int len) {
+      throw new UnsupportedOperationException(
+          "byte[] arrays are not supported for DirectDecompressor");
+    }
+
+    @Override
+    public synchronized int decompress(byte[] b, int off, int len) {
+      throw new UnsupportedOperationException(
+          "byte[] arrays are not supported for DirectDecompressor");
+    }
+  }

MOV31 INS83 INS42 MOV44 INS55 INS42 MOV8 MOV83 INS83 INS42 INS43 MOV43 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS31 INS6 INS60 INS25 MOV60 INS54 INS42 UPD83 MOV83 UPD42 MOV42 INS8 INS83 INS42 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS83 INS39 INS59 INS78 INS83 INS83 INS39 INS42 MOV44 MOV44 INS43 INS8 INS78 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS36 MOV43 INS59 UPD27 MOV27 INS8 INS8 INS8 INS46 INS43 INS42 INS39 INS42 INS46 INS42 INS41 INS42 INS21 INS21 UPD42 MOV42 INS42 INS42 INS6 INS6 MOV6 INS21 INS21 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS53 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS53 INS62 INS42 INS42 INS21 INS21 MOV21 MOV21 MOV25 MOV21 MOV21 MOV21 MOV21 MOV21 INS40 INS34 INS42 INS42 INS42 INS36 INS48 INS7 MOV32 INS45 MOV32 INS45 UPD45 INS32 INS7 INS39 INS85 INS14 INS39 INS85 INS14 INS52 INS43 INS7 INS7 INS27 INS42 INS42 INS9 INS52 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS38 INS43 INS45 INS43 INS45 INS42 INS42 INS42 INS42 INS32 UPD42 INS27 INS42 INS48 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS42 DEL42 DEL42 DEL33 DEL7 DEL21 DEL39 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL34 DEL41 DEL8 DEL25 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL42 DEL33 DEL27 DEL27 DEL36 DEL42 DEL33 DEL27 DEL27 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL27 DEL42 DEL42 DEL32 DEL42 DEL27 DEL27 DEL36 DEL59 DEL60 DEL39 DEL42 DEL42 DEL34 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL36 DEL59 DEL60 DEL42 DEL42 DEL27 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL41 DEL8 DEL42 DEL32 DEL42 DEL34 DEL27 DEL42 DEL34 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL45 DEL6 DEL8 DEL25 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL41 DEL8 DEL25 DEL8
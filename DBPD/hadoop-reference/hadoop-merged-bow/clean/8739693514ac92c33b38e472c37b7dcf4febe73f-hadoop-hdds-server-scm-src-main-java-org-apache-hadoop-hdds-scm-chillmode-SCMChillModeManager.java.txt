HDDS-1217. Refactor ChillMode rules and chillmode manager. (#558)



+
+import java.util.HashSet;
+import java.util.Set;
- * ContainerChillModeRule defines the only exit criteria right now.
- * On every new datanode registration event this class adds replicas
- * for reported containers and validates if cutoff threshold for
- * containers is meet.
+ *
+ * Current ChillMode rules:
+ * 1. ContainerChillModeRule:
+ * On every new datanode registration, it fires
+ * {@link SCMEvents#NODE_REGISTRATION_CONT_REPORT}.  This rule handles this
+ * event. This rule process this report, increment the
+ * containerWithMinReplicas count when this reported replica is in the
+ * containerMap. Then validates if cutoff threshold for containers is meet.
+ *
+ * 2. DatanodeChillModeRule:
+ * On every new datanode registration, it fires
+ * {@link SCMEvents#NODE_REGISTRATION_CONT_REPORT}. This rule handles this
+ * event. This rule process this report, and check if this is new node, add
+ * to its reported node list. Then validate it cutoff threshold for minimum
+ * number of datanode registered is met or not.
+ *
+ * 3. HealthyPipelineChillModeRule:
+ * Once the pipelineReportHandler processes the
+ * {@link SCMEvents#PIPELINE_REPORT}, it fires
+ * {@link SCMEvents#PROCESSED_PIPELINE_REPORT}. This rule handles this
+ * event. This rule processes this report, and check if pipeline is healthy
+ * and increments current healthy pipeline count. Then validate it cutoff
+ * threshold for healthy pipeline is met or not.
+ *
+ * 4. OneReplicaPipelineChillModeRule:
+ * Once the pipelineReportHandler processes the
+ * {@link SCMEvents#PIPELINE_REPORT}, it fires
+ * {@link SCMEvents#PROCESSED_PIPELINE_REPORT}. This rule handles this
+ * event. This rule processes this report, and add the reported pipeline to
+ * reported pipeline set. Then validate it cutoff threshold for one replica
+ * per pipeline is met or not.
+ *
+  private Set<String> validatedRules = new HashSet<>();
+
-          new ContainerChillModeRule(config, allContainers, this);
+          new ContainerChillModeRule(CONT_EXIT_RULE, eventQueue, config,
+              allContainers, this);
-          new DataNodeChillModeRule(config, this);
+          new DataNodeChillModeRule(DN_EXIT_RULE, eventQueue, config, this);
-      eventPublisher.addHandler(SCMEvents.NODE_REGISTRATION_CONT_REPORT,
-          containerChillModeRule);
-      eventPublisher.addHandler(SCMEvents.NODE_REGISTRATION_CONT_REPORT,
-          dataNodeChillModeRule);
-
-        HealthyPipelineChillModeRule rule = new HealthyPipelineChillModeRule(
-            pipelineManager, this, config);
+        HealthyPipelineChillModeRule healthyPipelineChillModeRule =
+            new HealthyPipelineChillModeRule(HEALTHY_PIPELINE_EXIT_RULE,
+                eventQueue, pipelineManager,
+                this, config);
-            new OneReplicaPipelineChillModeRule(pipelineManager, this, conf);
-        exitRules.put(HEALTHY_PIPELINE_EXIT_RULE, rule);
+            new OneReplicaPipelineChillModeRule(
+                ATLEAST_ONE_DATANODE_REPORTED_PIPELINE_EXIT_RULE, eventQueue,
+                pipelineManager, this, conf);
+        exitRules.put(HEALTHY_PIPELINE_EXIT_RULE, healthyPipelineChillModeRule);
-        eventPublisher.addHandler(SCMEvents.PROCESSED_PIPELINE_REPORT, rule);
-        eventPublisher.addHandler(SCMEvents.PROCESSED_PIPELINE_REPORT,
-            oneReplicaPipelineChillModeRule);
-  public void validateChillModeExitRules(EventPublisher eventQueue) {
-    for (ChillModeExitRule exitRule : exitRules.values()) {
-      if (!exitRule.validate()) {
-        return;
-      }
+
+  public synchronized void validateChillModeExitRules(String ruleName,
+      EventPublisher eventQueue) {
+
+    if (exitRules.get(ruleName) != null) {
+      validatedRules.add(ruleName);
+    } else {
+      // This should never happen
+      LOG.error("No Such Exit rule {}", ruleName);
-    exitChillMode(eventQueue);
+
+
+    if (validatedRules.size() == exitRules.size()) {
+      // All rules are satisfied, we can exit chill mode.
+      LOG.info("ScmChillModeManager, all rules are successfully validated");
+      exitChillMode(eventQueue);
+    }
+
-    for (ChillModeExitRule e : exitRules.values()) {
-      e.cleanup();
-    }

INS26 INS26 INS40 INS40 INS23 INS83 INS74 INS59 INS83 INS44 INS8 INS66 UPD66 UPD66 INS65 INS66 INS66 INS66 UPD66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 UPD66 INS43 INS43 INS42 INS14 UPD43 MOV43 UPD42 MOV42 INS25 MOV25 INS67 INS67 INS67 INS67 INS67 INS67 INS42 INS42 INS74 UPD42 INS27 INS8 INS8 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS33 INS21 INS21 INS32 INS32 INS21 MOV21 INS42 MOV43 MOV43 MOV42 UPD42 MOV42 INS42 INS32 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 MOV43 INS42 INS42 MOV43 INS42 INS42 MOV43 MOV43 UPD42 UPD42 MOV43 INS42 INS42 MOV43 INS42 INS42 DEL42 DEL42 DEL40 DEL42 DEL32 DEL21 DEL42 DEL42 DEL40 DEL42 DEL32 DEL21 DEL42 DEL42 DEL40 DEL42 DEL32 DEL21 DEL42 DEL42 DEL40 DEL42 DEL32 DEL21 DEL32 DEL38 DEL41 DEL44 DEL32 DEL8 DEL70 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70
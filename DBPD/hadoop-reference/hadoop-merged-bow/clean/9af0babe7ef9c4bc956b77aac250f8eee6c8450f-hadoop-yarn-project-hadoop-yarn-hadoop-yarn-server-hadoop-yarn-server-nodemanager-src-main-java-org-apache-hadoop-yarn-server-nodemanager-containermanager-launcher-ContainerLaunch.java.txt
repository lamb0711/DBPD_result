Merging trunk after fixing conflict with HDFS-4434.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1470089 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
-  public static final String CONTAINER_SCRIPT = Shell.WINDOWS ?
-    "launch_container.cmd" : "launch_container.sh";
+  public static final String CONTAINER_SCRIPT =
+    Shell.appendScriptExtension("launch_container");
-        sanitizeEnv(environment, containerWorkDir, appDirs);
+        sanitizeEnv(environment, containerWorkDir, appDirs, localResources);
-      line(String.format("@%s symlink \"%s\" \"%s\"", Shell.WINUTILS,
-        new File(dst.toString()).getPath(),
-        new File(src.toUri().getPath()).getPath()));
+      File srcFile = new File(src.toUri().getPath());
+      String srcFileStr = srcFile.getPath();
+      String dstFileStr = new File(dst.toString()).getPath();
+      // If not on Java7+ on Windows, then copy file instead of symlinking.
+      // See also FileUtil#symLink for full explanation.
+      if (!Shell.isJava7OrAbove() && srcFile.isFile()) {
+        line(String.format("@copy \"%s\" \"%s\"", srcFileStr, dstFileStr));
+      } else {
+        line(String.format("@%s symlink \"%s\" \"%s\"", Shell.WINUTILS,
+          dstFileStr, srcFileStr));
+      }
-      Path pwd, List<Path> appDirs) throws IOException {
+      Path pwd, List<Path> appDirs, Map<Path, List<String>> resources)
+      throws IOException {
-    // TODO: Remove Windows check and use this approach on all platforms after
-    // additional testing.  See YARN-358.
-    if (Shell.WINDOWS) {
-      String inputClassPath = environment.get(Environment.CLASSPATH.name());
-      if (inputClassPath != null && !inputClassPath.isEmpty()) {
-        environment.put(Environment.CLASSPATH.name(),
-            FileUtil.createJarWithClassPath(inputClassPath, pwd));
-      }
-    }
-
+
+    // TODO: Remove Windows check and use this approach on all platforms after
+    // additional testing.  See YARN-358.
+    if (Shell.WINDOWS) {
+      String inputClassPath = environment.get(Environment.CLASSPATH.name());
+      if (inputClassPath != null && !inputClassPath.isEmpty()) {
+        StringBuilder newClassPath = new StringBuilder(inputClassPath);
+
+        // Localized resources do not exist at the desired paths yet, because the
+        // container launch script has not run to create symlinks yet.  This
+        // means that FileUtil.createJarWithClassPath can't automatically expand
+        // wildcards to separate classpath entries for each file in the manifest.
+        // To resolve this, append classpath entries explicitly for each
+        // resource.
+        for (Map.Entry<Path,List<String>> entry : resources.entrySet()) {
+          boolean targetIsDirectory = new File(entry.getKey().toUri().getPath())
+            .isDirectory();
+
+          for (String linkName : entry.getValue()) {
+            // Append resource.
+            newClassPath.append(File.pathSeparator).append(pwd.toString())
+              .append(Path.SEPARATOR).append(linkName);
+
+            // FileUtil.createJarWithClassPath must use File.toURI to convert
+            // each file to a URI to write into the manifest's classpath.  For
+            // directories, the classpath must have a trailing '/', but
+            // File.toURI only appends the trailing '/' if it is a directory that
+            // already exists.  To resolve this, add the classpath entries with
+            // explicit trailing '/' here for any localized resource that targets
+            // a directory.  Then, FileUtil.createJarWithClassPath will guarantee
+            // that the resulting entry in the manifest's classpath will have a
+            // trailing '/', and thus refer to a directory instead of a file.
+            if (targetIsDirectory) {
+              newClassPath.append(Path.SEPARATOR);
+            }
+          }
+        }
+
+        // When the container launches, it takes the parent process's environment
+        // and then adds/overwrites with the entries from the container launch
+        // context.  Do the same thing here for correct substitution of
+        // environment variables in the classpath jar manifest.
+        Map<String, String> mergedEnv = new HashMap<String, String>(
+          System.getenv());
+        mergedEnv.putAll(environment);
+
+        String classPathJar = FileUtil.createJarWithClassPath(
+          newClassPath.toString(), pwd, mergedEnv);
+        environment.put(Environment.CLASSPATH.name(), classPathJar);
+      }
+    }

INS26 INS40 INS44 MOV25 INS32 INS8 INS74 INS42 INS42 INS42 INS45 INS60 INS60 INS60 INS25 INS43 INS43 INS74 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS42 INS42 INS43 INS43 INS42 INS42 MOV14 INS42 INS42 INS32 INS42 INS42 MOV32 INS38 INS32 INS21 MOV21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS60 INS70 INS60 INS21 INS60 INS21 INS42 INS42 INS42 INS32 INS43 INS59 INS44 INS32 INS8 INS74 INS59 INS32 INS43 INS59 INS32 INS42 INS42 INS42 INS45 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS14 INS74 INS42 INS42 INS42 INS60 INS70 INS43 INS43 INS43 INS42 INS14 INS42 INS42 MOV42 INS42 INS42 INS32 INS42 INS42 MOV32 INS42 INS43 INS42 INS43 INS43 INS74 INS39 INS59 INS44 INS32 INS8 INS42 INS42 INS42 INS74 INS32 MOV42 MOV42 INS32 MOV42 INS42 INS42 INS40 INS42 INS43 INS43 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS25 INS43 INS43 INS43 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS8 INS42 INS42 INS42 INS43 INS32 INS32 INS42 INS42 INS21 INS42 INS32 INS42 INS32 INS42 INS40 INS32 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 DEL40 DEL45 DEL45 DEL16 DEL32 DEL8 DEL42 DEL32 DEL32 DEL21
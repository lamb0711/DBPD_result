Complete commit of prior merge.

The previous merge accidentally only committed the hdfs project instead of common and MR
as well.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1463203 13f79535-47bb-0310-9956-ffa450edef68

-
-package org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair;
+package org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.modes;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.classification.InterfaceAudience.Private;
-import org.apache.hadoop.classification.InterfaceStability.Unstable;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.Resources;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.Schedulable;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.SchedulingMode;
-/**
- * Utility class containing scheduling algorithms used in the fair scheduler.
- */
-@Private
-@Unstable
-class SchedulingAlgorithms {
-  public static final Log LOG = LogFactory.getLog(
-      SchedulingAlgorithms.class.getName());
+import com.google.common.annotations.VisibleForTesting;
-  /**
-   * Compare Schedulables in order of priority and then submission time, as in
-   * the default FIFO scheduler in Hadoop.
-   */
-  public static class FifoComparator implements Comparator<Schedulable>, Serializable {
-    private static final long serialVersionUID = -5905036205491177060L;
+public class FairSchedulingMode extends SchedulingMode {
+  @VisibleForTesting
+  public static final String NAME = "FairShare";
+  private FairShareComparator comparator = new FairShareComparator();
-    @Override
-    public int compare(Schedulable s1, Schedulable s2) {
-      int res = s1.getPriority().compareTo(s2.getPriority());
-      if (res == 0) {
-        res = (int) Math.signum(s1.getStartTime() - s2.getStartTime());
-      }
-      if (res == 0) {
-        // In the rare case where jobs were submitted at the exact same time,
-        // compare them by name (which will be the JobID) to get a deterministic
-        // ordering, so we don't alternately launch tasks from different jobs.
-        res = s1.getName().compareTo(s2.getName());
-      }
-      return res;
-    }
+  @Override
+  public String getName() {
+    return NAME;
-   *
+   * 
-   *
+   * 
-  public static class FairShareComparator implements Comparator<Schedulable>, Serializable {
+  private static class FairShareComparator implements Comparator<Schedulable>,
+      Serializable {
-      minShareRatio1 = (double) s1.getResourceUsage().getMemory() /
-          Resources.max(minShare1, one).getMemory();
-      minShareRatio2 = (double) s2.getResourceUsage().getMemory() /
-          Resources.max(minShare2, one).getMemory();
+      minShareRatio1 = (double) s1.getResourceUsage().getMemory()
+          / Resources.max(minShare1, one).getMemory();
+      minShareRatio2 = (double) s2.getResourceUsage().getMemory()
+          / Resources.max(minShare2, one).getMemory();
-      else // Neither schedulable is needy
+      else
+        // Neither schedulable is needy
+  @Override
+  public Comparator<Schedulable> getComparator() {
+    return comparator;
+  }
+
+  @Override
+  public void computeShares(Collection<? extends Schedulable> schedulables,
+      Resource totalResources) {
+    computeFairShares(schedulables, totalResources);
+  }
+
-   * be set beforehand. We compute the fairest possible allocation of shares
-   * to the Schedulables that respects their min shares and demands.
-   *
+   * be set beforehand. We compute the fairest possible allocation of shares to
+   * the Schedulables that respects their min shares and demands.
+   * 
-   * Schedulable and all slots were assigned. Minimum shares and demands add
-   * two further twists:
-   * - Some Schedulables may not have enough tasks to fill all their share.
-   * - Some Schedulables may have a min share higher than their assigned share.
-   *
-   * To deal with these possibilities, we define an assignment of slots as
-   * being fair if there exists a ratio R such that:
-   * - Schedulables S where S.demand < R * S.weight are assigned share S.demand
-   * - Schedulables S where S.minShare > R * S.weight are given share S.minShare
-   * - All other Schedulables S are assigned share R * S.weight
-   * - The sum of all the shares is totalSlots.
-   *
+   * Schedulable and all slots were assigned. Minimum shares and demands add two
+   * further twists: - Some Schedulables may not have enough tasks to fill all
+   * their share. - Some Schedulables may have a min share higher than their
+   * assigned share.
+   * 
+   * To deal with these possibilities, we define an assignment of slots as being
+   * fair if there exists a ratio R such that: - Schedulables S where S.demand <
+   * R * S.weight are assigned share S.demand - Schedulables S where S.minShare
+   * > R * S.weight are given share S.minShare - All other Schedulables S are
+   * assigned share R * S.weight - The sum of all the shares is totalSlots.
+   * 
-   *
+   * 
-   * To do this, we use binary search. Given a ratio R, we compute the number
-   * of slots that would be used in total with this ratio (the sum of the shares
+   * To do this, we use binary search. Given a ratio R, we compute the number of
+   * slots that would be used in total with this ratio (the sum of the shares
-   *
+   * 
-   * either use more than totalSlots slots or we fulfill all jobs' demands).
-   * The helper method slotsUsedWithWeightToSlotRatio computes the total number
-   * of slots used with a given value of R.
-   *
+   * either use more than totalSlots slots or we fulfill all jobs' demands). The
+   * helper method slotsUsedWithWeightToSlotRatio computes the total number of
+   * slots used with a given value of R.
+   * 
-    for (Schedulable sched: schedulables) {
+    for (Schedulable sched : schedulables) {
-    while (Resources.lessThan(resUsedWithWeightToResRatio(rMax, schedulables), cap)) {
+    while (Resources.lessThan(resUsedWithWeightToResRatio(rMax, schedulables),
+        cap)) {
-      if (Resources.lessThan(resUsedWithWeightToResRatio(mid, schedulables), cap)) {
+      if (Resources.lessThan(resUsedWithWeightToResRatio(mid, schedulables),
+          cap)) {
-    for (Schedulable sched: schedulables) {
+    for (Schedulable sched : schedulables) {
-   * Compute the number of slots that would be used given a weight-to-slot
-   * ratio w2sRatio, for use in the computeFairShares algorithm as described
-   * in #{@link SchedulingAlgorithms#computeFairShares(Collection, double)}.
+   * Compute the number of slots that would be used given a weight-to-slot ratio
+   * w2sRatio, for use in the computeFairShares algorithm as described in #
+   * {@link SchedulingAlgorithms#computeFairShares(Collection, double)}.
-    for (Schedulable sched: schedulables) {
+    for (Schedulable sched : schedulables) {
-   * res-to-slot ratio r2sRatio, for use in computeFairShares as described
-   * in #{@link SchedulingAlgorithms#computeFairShares(Collection, double)}.
+   * res-to-slot ratio r2sRatio, for use in computeFairShares as described in #
+   * {@link SchedulingAlgorithms#computeFairShares(Collection, double)}.

MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 INS83 INS42 INS43 INS23 INS23 INS31 INS31 INS31 INS42 INS78 MOV83 MOV83 MOV83 UPD43 MOV43 INS59 INS83 INS43 INS59 MOV78 INS83 INS43 INS42 INS8 UPD83 INS78 INS83 MOV74 INS42 INS8 INS78 MOV83 UPD39 MOV39 UPD42 MOV42 MOV44 MOV44 INS8 INS29 MOV29 INS42 UPD42 UPD42 MOV42 INS45 INS42 INS42 INS14 UPD42 MOV42 INS41 INS42 INS41 INS42 INS74 UPD42 UPD43 UPD42 MOV21 INS65 INS43 INS42 INS42 INS43 INS76 UPD42 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 MOV65 INS66 UPD66 UPD66 INS42 INS42 INS43 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 DEL66 DEL65 DEL29 DEL42 DEL78 DEL42 DEL78 DEL42 DEL42 DEL42 DEL43 DEL57 DEL42 DEL32 DEL32 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL42 DEL34 DEL27 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL55 DEL43 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL7 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29
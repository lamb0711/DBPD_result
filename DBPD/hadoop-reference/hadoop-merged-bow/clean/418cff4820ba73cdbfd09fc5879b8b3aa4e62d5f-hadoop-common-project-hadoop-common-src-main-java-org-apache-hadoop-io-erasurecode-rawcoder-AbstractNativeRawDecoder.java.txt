Merge remote-tracking branch 'apache-commit/trunk' into HDDS-48

+import java.util.concurrent.locks.ReentrantReadWriteLock;
+  // Protect ISA-L coder data structure in native layer from being accessed and
+  // updated concurrently by the init, release and decode functions.
+  protected final ReentrantReadWriteLock decoderLock =
+      new ReentrantReadWriteLock();
+
-  protected synchronized void doDecode(ByteBufferDecodingState decodingState)
+  protected void doDecode(ByteBufferDecodingState decodingState)
-    if (nativeCoder == 0) {
-      throw new IOException(String.format("%s closed",
-          getClass().getSimpleName()));
-    }
-    int[] inputOffsets = new int[decodingState.inputs.length];
-    int[] outputOffsets = new int[decodingState.outputs.length];
-
-    ByteBuffer buffer;
-    for (int i = 0; i < decodingState.inputs.length; ++i) {
-      buffer = decodingState.inputs[i];
-      if (buffer != null) {
-        inputOffsets[i] = buffer.position();
+    decoderLock.readLock().lock();
+    try {
+      if (nativeCoder == 0) {
+        throw new IOException(String.format("%s closed",
+            getClass().getSimpleName()));
-    }
+      int[] inputOffsets = new int[decodingState.inputs.length];
+      int[] outputOffsets = new int[decodingState.outputs.length];
-    for (int i = 0; i < decodingState.outputs.length; ++i) {
-      buffer = decodingState.outputs[i];
-      outputOffsets[i] = buffer.position();
-    }
+      ByteBuffer buffer;
+      for (int i = 0; i < decodingState.inputs.length; ++i) {
+        buffer = decodingState.inputs[i];
+        if (buffer != null) {
+          inputOffsets[i] = buffer.position();
+        }
+      }
-    performDecodeImpl(decodingState.inputs, inputOffsets,
-        decodingState.decodeLength, decodingState.erasedIndexes,
-        decodingState.outputs, outputOffsets);
+      for (int i = 0; i < decodingState.outputs.length; ++i) {
+        buffer = decodingState.outputs[i];
+        outputOffsets[i] = buffer.position();
+      }
+
+      performDecodeImpl(decodingState.inputs, inputOffsets,
+          decodingState.decodeLength, decodingState.erasedIndexes,
+          decodingState.outputs, outputOffsets);
+    } finally {
+      decoderLock.readLock().unlock();
+    }

INS26 INS40 INS23 INS83 INS83 INS43 INS59 INS8 INS42 INS42 INS14 INS21 INS54 INS43 INS32 MOV8 INS8 INS42 INS32 INS42 INS21 INS42 INS42 INS32 INS32 INS42 INS42 INS42 DEL83
HDFS-8543. Erasure Coding: processOverReplicatedBlock() handles striped block. Contributed by Walter Su.

+import java.util.BitSet;
-    chooseExcessReplicates(nonExcess, block, replication, 
-        addedNode, delNodeHint, placementPolicies.getPolicy(false));
+    chooseExcessReplicates(nonExcess, block, replication, addedNode,
+        delNodeHint);
+  private void chooseExcessReplicates(
+      final Collection<DatanodeStorageInfo> nonExcess,
+      BlockInfo storedBlock, short replication,
+      DatanodeDescriptor addedNode,
+      DatanodeDescriptor delNodeHint) {
+    assert namesystem.hasWriteLock();
+    // first form a rack to datanodes map and
+    BlockCollection bc = getBlockCollection(storedBlock);
+    final BlockStoragePolicy storagePolicy = storagePolicySuite.getPolicy(
+        bc.getStoragePolicyID());
+    final List<StorageType> excessTypes = storagePolicy.chooseExcess(
+        replication, DatanodeStorageInfo.toStorageTypes(nonExcess));
+    if (!storedBlock.isStriped()) {
+      chooseExcessReplicasContiguous(bc, nonExcess, storedBlock,
+          replication, addedNode, delNodeHint, excessTypes);
+    } else {
+      chooseExcessReplicasStriped(bc, nonExcess, storedBlock, delNodeHint,
+          excessTypes);
+    }
+  }
-  private void chooseExcessReplicates(final Collection<DatanodeStorageInfo> nonExcess, 
-                              BlockInfo storedBlock, short replication,
-                              DatanodeDescriptor addedNode,
-                              DatanodeDescriptor delNodeHint,
-                              BlockPlacementPolicy replicator) {
-    assert namesystem.hasWriteLock();
-    // first form a rack to datanodes map and
-    BlockCollection bc = getBlockCollection(storedBlock);
-    final BlockStoragePolicy storagePolicy = storagePolicySuite.getPolicy(
-        bc.getStoragePolicyID());
-    final List<StorageType> excessTypes = storagePolicy.chooseExcess(
-        replication, DatanodeStorageInfo.toStorageTypes(nonExcess));
-
-
+  private void chooseExcessReplicasContiguous(BlockCollection bc,
+      final Collection<DatanodeStorageInfo> nonExcess,
+      BlockInfo storedBlock, short replication,
+      DatanodeDescriptor addedNode,
+      DatanodeDescriptor delNodeHint,
+      List<StorageType> excessTypes) {
+    BlockPlacementPolicy replicator = placementPolicies.getPolicy(false);
-
-      nonExcess.remove(cur);
-      addToExcessReplicate(cur.getDatanodeDescriptor(), storedBlock);
-
-      //
-      // The 'excessblocks' tracks blocks until we get confirmation
-      // that the datanode has deleted them; the only way we remove them
-      // is when we get a "removeBlock" message.  
-      //
-      // The 'invalidate' list is used to inform the datanode the block 
-      // should be deleted.  Items are removed from the invalidate list
-      // upon giving instructions to the datanodes.
-      //
-      final Block blockToInvalidate = getBlockToInvalidate(storedBlock, cur);
-      addToInvalidates(blockToInvalidate, cur.getDatanodeDescriptor());
-      blockLog.info("BLOCK* chooseExcessReplicates: "
-                +"({}, {}) is added to invalidated blocks set", cur, storedBlock);
+      processChosenExcessReplica(nonExcess, cur, storedBlock);
+  /**
+   * We want block group has every internal block, but we have redundant
+   * internal blocks (which have the same index).
+   * In this method, we delete the redundant internal blocks until only one
+   * left for each index.
+   *
+   * The block placement policy will make sure that the left internal blocks are
+   * spread across racks and also try hard to pick one with least free space.
+   */
+  private void chooseExcessReplicasStriped(BlockCollection bc,
+      final Collection<DatanodeStorageInfo> nonExcess,
+      BlockInfo storedBlock,
+      DatanodeDescriptor delNodeHint,
+      List<StorageType> excessTypes) {
+    assert storedBlock instanceof BlockInfoStriped;
+    BlockInfoStriped sblk = (BlockInfoStriped) storedBlock;
+    short groupSize = sblk.getTotalBlockNum();
+    if (nonExcess.size() <= groupSize) {
+      return;
+    }
+    BlockPlacementPolicy placementPolicy = placementPolicies.getPolicy(true);
+    List<DatanodeStorageInfo> empty = new ArrayList<>(0);
+
+    // find all duplicated indices
+    BitSet found = new BitSet(groupSize); //indices found
+    BitSet duplicated = new BitSet(groupSize); //indices found more than once
+    HashMap<DatanodeStorageInfo, Integer> storage2index = new HashMap<>();
+    for (DatanodeStorageInfo storage : nonExcess) {
+      int index = sblk.getStorageBlockIndex(storage);
+      assert index >= 0;
+      if (found.get(index)) {
+        duplicated.set(index);
+      }
+      found.set(index);
+      storage2index.put(storage, index);
+    }
+
+    // use delHint only if delHint is duplicated
+    final DatanodeStorageInfo delStorageHint =
+        DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);
+    if (delStorageHint != null) {
+      Integer index = storage2index.get(delStorageHint);
+      if (index != null && duplicated.get(index)) {
+        processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);
+      }
+    }
+
+    // for each duplicated index, delete some replicas until only one left
+    for (int targetIndex = duplicated.nextSetBit(0); targetIndex >= 0;
+         targetIndex = duplicated.nextSetBit(targetIndex + 1)) {
+      List<DatanodeStorageInfo> candidates = new ArrayList<>();
+      for (DatanodeStorageInfo storage : nonExcess) {
+        int index = storage2index.get(storage);
+        if (index == targetIndex) {
+          candidates.add(storage);
+        }
+      }
+      Block internalBlock = new Block(storedBlock);
+      internalBlock.setBlockId(storedBlock.getBlockId() + targetIndex);
+      while (candidates.size() > 1) {
+        DatanodeStorageInfo target = placementPolicy.chooseReplicaToDelete(bc,
+            internalBlock, (short)1, candidates, empty, excessTypes);
+        processChosenExcessReplica(nonExcess, target, storedBlock);
+        candidates.remove(target);
+      }
+      duplicated.clear(targetIndex);
+    }
+  }
+
+  private void processChosenExcessReplica(
+      final Collection<DatanodeStorageInfo> nonExcess,
+      final DatanodeStorageInfo chosen, BlockInfo storedBlock) {
+    nonExcess.remove(chosen);
+    addToExcessReplicate(chosen.getDatanodeDescriptor(), storedBlock);
+    //
+    // The 'excessblocks' tracks blocks until we get confirmation
+    // that the datanode has deleted them; the only way we remove them
+    // is when we get a "removeBlock" message.
+    //
+    // The 'invalidate' list is used to inform the datanode the block
+    // should be deleted.  Items are removed from the invalidate list
+    // upon giving instructions to the datanodes.
+    //
+    final Block blockToInvalidate = getBlockToInvalidate(storedBlock, chosen);
+    addToInvalidates(blockToInvalidate, chosen.getDatanodeDescriptor());
+    blockLog.info("BLOCK* chooseExcessReplicates: "
+        +"({}, {}) is added to invalidated blocks set", chosen, storedBlock);
+  }
+

INS26 INS40 INS31 INS31 INS31 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS8 UPD42 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS74 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS43 INS42 MOV6 MOV60 MOV60 MOV60 INS25 INS43 INS42 INS74 INS42 INS60 INS65 INS43 INS42 INS83 INS74 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS6 INS60 INS60 INS25 INS60 INS60 INS60 INS60 INS60 INS70 INS60 INS25 INS24 INS83 INS74 INS42 INS83 INS43 INS42 INS43 INS42 INS21 INS21 INS60 INS21 INS21 INS43 INS43 INS42 INS42 INS42 INS38 INS8 INS8 INS42 INS43 INS43 MOV43 INS59 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS43 INS43 INS42 INS42 INS43 INS43 INS62 INS43 INS59 INS39 INS59 INS27 INS8 INS43 INS59 INS74 INS59 INS43 INS59 INS43 INS59 INS74 INS59 INS44 INS42 INS8 INS83 INS43 INS59 INS27 INS8 INS58 INS27 INS7 INS8 INS43 INS43 INS42 INS42 INS32 INS32 INS83 MOV43 INS59 INS32 INS32 INS42 INS42 INS32 INS21 INS21 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS11 INS42 INS32 INS32 INS42 INS41 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS43 INS43 INS43 INS42 INS14 INS43 INS42 INS60 INS6 INS25 INS21 INS21 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS39 INS59 INS42 INS34 INS42 INS32 INS60 INS70 INS60 INS21 INS61 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 MOV27 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS74 INS34 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS74 INS42 INS39 INS59 INS27 INS32 INS8 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS32 INS42 INS42 INS27 INS74 INS59 INS44 INS42 INS8 INS43 INS59 INS32 INS27 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS43 INS42 INS42 INS43 INS42 INS32 INS42 INS34 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS32 INS21 INS42 INS42 INS34 INS42 INS34 INS43 INS43 INS42 INS14 INS43 INS42 INS60 INS25 INS42 INS42 INS14 INS42 INS42 INS27 INS32 INS34 INS60 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS32 INS42 INS42 INS74 INS42 INS39 INS59 INS27 INS8 INS43 INS42 INS32 INS42 INS42 INS42 INS43 INS59 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS34 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21
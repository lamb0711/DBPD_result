Merge branch 'trunk' into HADOOP-12756

-import org.apache.hadoop.yarn.util.ConverterUtils;
+import java.io.IOException;
-import java.security.SecureRandom;
-
-  public static final Log LOG = LogFactory.getLog(ZKRMStateStore.class);
-  private final SecureRandom random = new SecureRandom();
-
-  protected static final String ROOT_ZNODE_NAME = "ZKRMStateRoot";
-  protected static final Version CURRENT_VERSION_INFO = Version
-      .newInstance(1, 3);
+  private static final Log LOG = LogFactory.getLog(ZKRMStateStore.class);
+  protected static final String ROOT_ZNODE_NAME = "ZKRMStateRoot";
+  protected static final Version CURRENT_VERSION_INFO =
+      Version.newInstance(1, 3);
-  /** Znode paths */
+  /* Znode paths */
+
-  /** Fencing related variables */
+  /* Fencing related variables */
-  /** ACL and auth info */
+  /* ACL and auth info */
-  public static final int CREATE_DELETE_PERMS =
+
+  private static final int CREATE_DELETE_PERMS =
+
-   * Given the {@link Configuration} and {@link ACL}s used (zkAcl) for
+   * Given the {@link Configuration} and {@link ACL}s used (sourceACLs) for
-   * In the constructed {@link ACL}, all the users allowed by zkAcl are given
-   * rwa access, while the current RM has exclude create-delete access.
+   * In the constructed {@link ACL}, all the users allowed by sourceACLs are
+   * given read-write-admin access, while the current RM has exclusive
+   * create-delete access.
-   * To be called only when HA is enabled and the configuration doesn't set ACL
-   * for the root node.
+   * To be called only when HA is enabled and the configuration doesn't set an
+   * ACL for the root node.
+   * @param conf the configuration
+   * @param sourceACLs the source ACLs
+   * @return ACLs for the store's root node
+   * @throws java.security.NoSuchAlgorithmException thrown if the digest
+   * algorithm used by Zookeeper cannot be found
-  protected List<ACL> constructZkRootNodeACL(
-      Configuration conf, List<ACL> sourceACLs) throws NoSuchAlgorithmException {
-    List<ACL> zkRootNodeAcl = new ArrayList<>();
+  protected List<ACL> constructZkRootNodeACL(Configuration conf,
+      List<ACL> sourceACLs) throws NoSuchAlgorithmException {
+    List<ACL> zkRootNodeAclList = new ArrayList<>();
+
-      zkRootNodeAcl.add(new ACL(
+      zkRootNodeAclList.add(new ACL(
-        DigestAuthenticationProvider.generateDigest(
-            zkRootNodeUsername + ":" + resourceManager.getZkRootNodePassword()));
-    zkRootNodeAcl.add(new ACL(CREATE_DELETE_PERMS, rmId));
-    return zkRootNodeAcl;
+        DigestAuthenticationProvider.generateDigest(zkRootNodeUsername + ":"
+            + resourceManager.getZkRootNodePassword()));
+    zkRootNodeAclList.add(new ACL(CREATE_DELETE_PERMS, rmId));
+
+    return zkRootNodeAclList;
-  public synchronized void initInternal(Configuration conf) throws Exception {
-
+  public synchronized void initInternal(Configuration conf)
+      throws IOException, NoSuchAlgorithmException {
+
+
+
-          LOG.error("Invalid format for " +
-              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);
+          LOG.error("Invalid format for "
+              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);
+
-
+
+
+
+
+
+
+
+
+
-      String planNodePath = getNodePath(reservationRoot, planName);
+      String planNodePath = getNodePath(reservationRoot, planName);
+
-        String reservationNodePath = getNodePath(planNodePath,
-            reservationNodeName);
+        String reservationNodePath =
+            getNodePath(planNodePath, reservationNodeName);
+
+
+
-          rmState.getReservationState().put(planName,
-              new HashMap<ReservationId, ReservationAllocationStateProto>());
+          rmState.getReservationState().put(planName, new HashMap<>());
+
+
-      return;
+    } else {
+      AMRMTokenSecretManagerStatePBImpl stateData =
+          new AMRMTokenSecretManagerStatePBImpl(
+            AMRMTokenSecretManagerStateProto.parseFrom(data));
+      rmState.amrmTokenSecretManagerState =
+          AMRMTokenSecretManagerState.newInstance(
+            stateData.getCurrentMasterKey(), stateData.getNextMasterKey());
-    AMRMTokenSecretManagerStatePBImpl stateData =
-        new AMRMTokenSecretManagerStatePBImpl(
-          AMRMTokenSecretManagerStateProto.parseFrom(data));
-    rmState.amrmTokenSecretManagerState =
-        AMRMTokenSecretManagerState.newInstance(
-          stateData.getCurrentMasterKey(), stateData.getNextMasterKey());
-    List<String> childNodes =
-        getChildren(dtMasterKeysRootPath);
+    List<String> childNodes = getChildren(dtMasterKeysRootPath);
+
-      DataInputStream fsIn = new DataInputStream(is);
-      try {
+      try (DataInputStream fsIn = new DataInputStream(is)) {
+
-      } finally {
-        is.close();
+
-      DataInputStream seqIn = new DataInputStream(seqIs);
-      try {
+      try (DataInputStream seqIn = new DataInputStream(seqIs)) {
-      } finally {
-        seqIn.close();
+
-      DataInputStream fsIn = new DataInputStream(is);
-      try {
+      try (DataInputStream fsIn = new DataInputStream(is)) {
+
-      } finally {
-        is.close();
+
+
+
+
-          throw new YarnRuntimeException("The child node name is different " +
-              "from the application id");
+          throw new YarnRuntimeException("The child node name is different "
+              + "from the application id");
+
+
+
+
-
-  public synchronized void updateApplicationStateInternal(ApplicationId appId,
-      ApplicationStateData appStateDataPB) throws Exception {
+  protected synchronized void updateApplicationStateInternal(
+      ApplicationId appId, ApplicationStateData appStateDataPB)
+      throws Exception {
+
-  public synchronized void storeApplicationAttemptStateInternal(
+  protected synchronized void storeApplicationAttemptStateInternal(
+
-    safeCreate(nodeCreatePath, attemptStateData, zkAcl,
-        CreateMode.PERSISTENT);
+    safeCreate(nodeCreatePath, attemptStateData, zkAcl, CreateMode.PERSISTENT);
-  public synchronized void updateApplicationAttemptStateInternal(
+  protected synchronized void updateApplicationAttemptStateInternal(
+
+
-  public synchronized void removeApplicationAttemptInternal(
-      ApplicationAttemptId appAttemptId)
-      throws Exception {
+  protected synchronized void removeApplicationAttemptInternal(
+      ApplicationAttemptId appAttemptId) throws Exception {
-    String attemptIdRemovePath = getNodePath(appIdRemovePath,
-        appAttemptId.toString());
+    String attemptIdRemovePath =
+        getNodePath(appIdRemovePath, appAttemptId.toString());
+
-  public synchronized void removeApplicationStateInternal(
-      ApplicationStateData  appState)
-      throws Exception {
+  protected synchronized void removeApplicationStateInternal(
+      ApplicationStateData appState) throws Exception {
-      String attemptRemovePath = getNodePath(appIdRemovePath, attemptId.toString());
+      String attemptRemovePath =
+          getNodePath(appIdRemovePath, attemptId.toString());
+
+
+
+
+
-    String nodeCreatePath =
-        getNodePath(delegationTokensRootPath, DELEGATION_TOKEN_PREFIX
-            + rmDTIdentifier.getSequenceNumber());
-    ByteArrayOutputStream seqOs = new ByteArrayOutputStream();
-    DataOutputStream seqOut = new DataOutputStream(seqOs);
+    String nodeCreatePath = getNodePath(delegationTokensRootPath,
+        DELEGATION_TOKEN_PREFIX + rmDTIdentifier.getSequenceNumber());
-    try {
+    ByteArrayOutputStream seqOs = new ByteArrayOutputStream();
+
+    try (DataOutputStream seqOut = new DataOutputStream(seqOs)) {
-        LOG.debug((isUpdate ? "Storing " : "Updating ") + "RMDelegationToken_" +
-            rmDTIdentifier.getSequenceNumber());
+        LOG.debug((isUpdate ? "Storing " : "Updating ") + "RMDelegationToken_"
+            + rmDTIdentifier.getSequenceNumber());
+
-          LOG.debug((isUpdate ? "Storing " : "Updating ") +
-              dtSequenceNumberPath + ". SequenceNumber: "
+          LOG.debug((isUpdate ? "Storing " : "Updating ")
+              + dtSequenceNumberPath + ". SequenceNumber: "
+
-    } finally {
-      seqOs.close();
-    String nodeCreatePath =
-        getNodePath(dtMasterKeysRootPath, DELEGATION_KEY_PREFIX
-            + delegationKey.getKeyId());
-    ByteArrayOutputStream os = new ByteArrayOutputStream();
-    DataOutputStream fsOut = new DataOutputStream(os);
+    String nodeCreatePath = getNodePath(dtMasterKeysRootPath,
+        DELEGATION_KEY_PREFIX + delegationKey.getKeyId());
-    delegationKey.write(fsOut);
-    try {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    try(DataOutputStream fsOut = new DataOutputStream(os)) {
+      delegationKey.write(fsOut);
-    } finally {
-      os.close();
+
+
-  public synchronized void storeOrUpdateAMRMTokenSecretManagerState(
+  protected synchronized void storeOrUpdateAMRMTokenSecretManagerState(
+
-      String reservationIdName)
-      throws Exception {
-    String planNodePath =
-        getNodePath(reservationRoot, planName);
-    String reservationPath = getNodePath(planNodePath,
-        reservationIdName);
+      String reservationIdName) throws Exception {
+    String planNodePath = getNodePath(reservationRoot, planName);
+    String reservationPath = getNodePath(planNodePath, reservationIdName);
+
-      LOG.debug("Removing reservationallocation " + reservationIdName + " for" +
-          " plan " + planName);
+      LOG.debug("Removing reservationallocation " + reservationIdName
+          + " for" + " plan " + planName);
+
+
-      String reservationIdName)
-      throws Exception {
+      String reservationIdName) throws Exception {
-    addOrUpdateReservationState(
-        reservationAllocation, planName, reservationIdName, trx, false);
+    addOrUpdateReservationState(reservationAllocation, planName,
+        reservationIdName, trx, false);
+
+
-      transactionFinal =
-          transaction.create()
-              .withMode(CreateMode.PERSISTENT).withACL(zkAcl)
-              .forPath(fencingNodePath, new byte[0]).and();
+      transactionFinal = transaction.create()
+          .withMode(CreateMode.PERSISTENT).withACL(zkAcl)
+          .forPath(fencingNodePath, new byte[0]).and();
+    @Override
-        while (true) {
-          if(isFencedState()) {
-            break;
-          }
+        while (!isFencedState()) {
-        LOG.info(VerifyActiveStatusThread.class.getName() + " thread " +
-            "interrupted! Exiting!");
+        LOG.info(getName() + " thread interrupted! Exiting!");
+        interrupt();

MOV26 MOV23 MOV23 UPD40 UPD83 UPD83 UPD43 INS43 UPD83 UPD83 UPD83 UPD83 UPD83 MOV60 MOV60 UPD83 INS65 INS65 INS65 INS65 UPD42 INS42 INS78 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS42 INS66 INS42 INS66 INS66 INS40 INS66 INS66 UPD42 INS8 INS58 INS58 INS42 UPD42 UPD42 MOV60 MOV21 MOV43 MOV59 MOV43 MOV59 MOV21 INS58 INS58 INS58 UPD42 MOV43 MOV59 MOV43 MOV59 MOV43 MOV59 INS38 INS21 MOV32 INS32 INS42 UPD45 UPD74 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL66 DEL65 DEL29 DEL66 DEL65 DEL29 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL41 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL9 DEL10 DEL8 DEL25 DEL42 DEL43 DEL57 DEL45
Merge from trunk to branch

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1603993 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.Condition;
+import java.util.ListIterator;
+import org.apache.hadoop.classification.InterfaceAudience;
-/*************************************************
- * FSDirectory stores the filesystem directory state.
- * It handles writing/loading values to disk, and logging
- * changes as we go.
- *
- * It keeps the filename->blockset mapping always-current
- * and logged to disk.
- * 
- *************************************************/
+/**
+ * Both FSDirectory and FSNamesystem manage the state of the namespace.
+ * FSDirectory is a pure in-memory data structure, all of whose operations
+ * happen entirely in memory. In contrast, FSNamesystem persists the operations
+ * to the disk.
+ * @see org.apache.hadoop.hdfs.server.namenode.FSNamesystem
+ **/
+@InterfaceAudience.Private
-  private volatile boolean ready = false;
-  private final Condition cond;
-    this.cond = dirLock.writeLock().newCondition();
-   * Notify that loading of this FSDirectory is complete, and
-   * it is ready for use 
-   */
-  void imageLoadComplete() {
-    Preconditions.checkState(!ready, "FSDirectory already loaded");
-    setReady();
-  }
-
-  void setReady() {
-    if(ready) return;
-    writeLock();
-    try {
-      setReady(true);
-      this.nameCache.initialized();
-      cond.signalAll();
-    } finally {
-      writeUnlock();
-    }
-  }
-  
-  //This is for testing purposes only
-  @VisibleForTesting
-  boolean isReady() {
-    return ready;
-  }
-
-  // exposed for unit tests
-  protected void setReady(boolean flag) {
-    ready = flag;
-  }
-
-  /**
-  /**
-   * Block until the object is ready to be used.
-   */
-  void waitForReady() {
-    if (!ready) {
-      writeLock();
-      try {
-        while (!ready) {
-          try {
-            cond.await(5000, TimeUnit.MILLISECONDS);
-          } catch (InterruptedException ignored) {
-          }
-        }
-      } finally {
-        writeUnlock();
-      }
+  void markNameCacheInitialized() {
+    writeLock();
+    try {
+      nameCache.initialized();
+    } finally {
+      writeUnlock();
-    waitForReady();
+                            List<XAttr> xAttrs,
+        if (xAttrs != null) {
+          XAttrStorage.updateINodeXAttrs(newNode, xAttrs,
+              Snapshot.CURRENT_STATE_ID);
+        }
-    waitForReady();
-
-    waitForReady();
-
-    waitForReady();
-    waitForReady();
-    waitForReady();
-      waitForReady();
-    waitForReady();
-    if (!ready) {
+    if (!namesystem.isImageLoaded()) {
-    if (!ready || skipQuotaCheck) {
+    if (!namesystem.isImageLoaded() || skipQuotaCheck) {
-      if (!ready) {
+      if (!namesystem.isImageLoaded()) {
-      if (ready) {
+      if (namesystem.isImageLoaded()) {
-      if (ready) {
+      if (namesystem.isImageLoaded()) {
-      setReady(false);
-  XAttr removeXAttr(String src, XAttr xAttr) throws IOException {
+  /**
+   * Removes a list of XAttrs from an inode at a path.
+   *
+   * @param src path of inode
+   * @param toRemove XAttrs to be removed
+   * @return List of XAttrs that were removed
+   * @throws IOException if the inode does not exist, if quota is exceeded
+   */
+  List<XAttr> removeXAttrs(final String src, final List<XAttr> toRemove)
+      throws IOException {
-      return unprotectedRemoveXAttr(src, xAttr);
+      return unprotectedRemoveXAttrs(src, toRemove);
-  
-  XAttr unprotectedRemoveXAttr(String src,
-      XAttr xAttr) throws IOException {
+
+  List<XAttr> unprotectedRemoveXAttrs(final String src,
+      final List<XAttr> toRemove) throws IOException {
-    List<XAttr> newXAttrs = filterINodeXAttr(existingXAttrs, xAttr);
+    List<XAttr> removedXAttrs = Lists.newArrayListWithCapacity(toRemove.size());
+    List<XAttr> newXAttrs = filterINodeXAttrs(existingXAttrs, toRemove,
+        removedXAttrs);
-      return xAttr;
+      return removedXAttrs;
-  
-  List<XAttr> filterINodeXAttr(List<XAttr> existingXAttrs, 
-      XAttr xAttr) throws QuotaExceededException {
-    if (existingXAttrs == null || existingXAttrs.isEmpty()) {
+
+  /**
+   * Filter XAttrs from a list of existing XAttrs. Removes matched XAttrs from
+   * toFilter and puts them into filtered. Upon completion,
+   * toFilter contains the filter XAttrs that were not found, while
+   * fitleredXAttrs contains the XAttrs that were found.
+   *
+   * @param existingXAttrs Existing XAttrs to be filtered
+   * @param toFilter XAttrs to filter from the existing XAttrs
+   * @param filtered Return parameter, XAttrs that were filtered
+   * @return List of XAttrs that does not contain filtered XAttrs
+   */
+  @VisibleForTesting
+  List<XAttr> filterINodeXAttrs(final List<XAttr> existingXAttrs,
+      final List<XAttr> toFilter, final List<XAttr> filtered) {
+    if (existingXAttrs == null || existingXAttrs.isEmpty() ||
+        toFilter == null || toFilter.isEmpty()) {
-    
-    List<XAttr> xAttrs = Lists.newArrayListWithCapacity(existingXAttrs.size());
+
+    // Populate a new list with XAttrs that pass the filter
+    List<XAttr> newXAttrs =
+        Lists.newArrayListWithCapacity(existingXAttrs.size());
-      if (!(a.getNameSpace() == xAttr.getNameSpace()
-          && a.getName().equals(xAttr.getName()))) {
-        xAttrs.add(a);
+      boolean add = true;
+      for (ListIterator<XAttr> it = toFilter.listIterator(); it.hasNext()
+          ;) {
+        XAttr filter = it.next();
+        if (a.equalsIgnoreValue(filter)) {
+          add = false;
+          it.remove();
+          filtered.add(filter);
+          break;
+        }
+      }
+      if (add) {
+        newXAttrs.add(a);
-    
-    return xAttrs;
+
+    return newXAttrs;
-      unprotectedSetXAttr(src, keyIdXAttr, EnumSet.of(XAttrSetFlag.CREATE));
+      List<XAttr> xattrs = Lists.newArrayListWithCapacity(1);
+      xattrs.add(keyIdXAttr);
+      unprotectedSetXAttrs(src, xattrs, EnumSet.of(XAttrSetFlag.CREATE));
-  XAttr deleteEncryptionZone(String src)
+  List<XAttr> deleteEncryptionZone(String src)
-      final XAttr removedXAttr = unprotectedRemoveXAttr(src, keyIdXAttr);
-      if (removedXAttr == null) {
+      List<XAttr> xattrs = Lists.newArrayListWithCapacity(1);
+      xattrs.add(keyIdXAttr);
+      final List<XAttr> removedXAttrs = unprotectedRemoveXAttrs(src, xattrs);
+      if (removedXAttrs == null || removedXAttrs.isEmpty()) {
-      return removedXAttr;
+      return removedXAttrs;
-  void setXAttr(String src, XAttr xAttr, EnumSet<XAttrSetFlag> flag)
-          throws IOException {
+  void setXAttrs(final String src, final List<XAttr> xAttrs,
+      final EnumSet<XAttrSetFlag> flag) throws IOException {
-      unprotectedSetXAttr(src, xAttr, flag);
+      unprotectedSetXAttrs(src, xAttrs, flag);
-  void unprotectedSetXAttr(String src, XAttr xAttr, 
-      EnumSet<XAttrSetFlag> flag) throws IOException {
+  void unprotectedSetXAttrs(final String src, final List<XAttr> xAttrs,
+      final EnumSet<XAttrSetFlag> flag)
+      throws QuotaExceededException, IOException {
-    List<XAttr> newXAttrs = setINodeXAttr(existingXAttrs, xAttr, flag);
+    List<XAttr> newXAttrs = setINodeXAttrs(existingXAttrs, xAttrs, flag);
-  
-  List<XAttr> setINodeXAttr(List<XAttr> existingXAttrs, XAttr xAttr, 
-      EnumSet<XAttrSetFlag> flag) throws QuotaExceededException, IOException {
-    List<XAttr> xAttrs = Lists.newArrayListWithCapacity(
-        existingXAttrs != null ? existingXAttrs.size() + 1 : 1);
+
+  List<XAttr> setINodeXAttrs(final List<XAttr> existingXAttrs,
+      final List<XAttr> toSet, final EnumSet<XAttrSetFlag> flag)
+      throws IOException {
+    // Check for duplicate XAttrs in toSet
+    // We need to use a custom comparator, so using a HashSet is not suitable
+    for (int i = 0; i < toSet.size(); i++) {
+      for (int j = i + 1; j < toSet.size(); j++) {
+        if (toSet.get(i).equalsIgnoreValue(toSet.get(j))) {
+          throw new IOException("Cannot specify the same XAttr to be set " +
+              "more than once");
+        }
+      }
+    }
+
+    // Count the current number of user-visible XAttrs for limit checking
-    boolean exist = false;
+
+    // The XAttr list is copied to an exactly-sized array when it's stored,
+    // so there's no need to size it precisely here.
+    int newSize = (existingXAttrs != null) ? existingXAttrs.size() : 0;
+    newSize += toSet.size();
+    List<XAttr> xAttrs = Lists.newArrayListWithCapacity(newSize);
+
+    // Check if the XAttr already exists to validate with the provided flag
+    for (XAttr xAttr: toSet) {
+      boolean exist = false;
+      if (existingXAttrs != null) {
+        for (XAttr a : existingXAttrs) {
+          if (a.equalsIgnoreValue(xAttr)) {
+            exist = true;
+            break;
+          }
+        }
+      }
+      XAttrSetFlag.validate(xAttr.getName(), exist, flag);
+      // add the new XAttr since it passed validation
+      xAttrs.add(xAttr);
+      if (isUserVisible(xAttr)) {
+        userVisibleXAttrsNum++;
+      }
+    }
+
+    // Add the existing xattrs back in, if they weren't already set
-      for (XAttr a: existingXAttrs) {
-        if ((a.getNameSpace() == xAttr.getNameSpace()
-            && a.getName().equals(xAttr.getName()))) {
-          exist = true;
-        } else {
-          xAttrs.add(a);
-          
-          if (isUserVisible(a)) {
+      for (XAttr existing : existingXAttrs) {
+        boolean alreadySet = false;
+        for (XAttr set : toSet) {
+          if (set.equalsIgnoreValue(existing)) {
+            alreadySet = true;
+            break;
+          }
+        }
+        if (!alreadySet) {
+          xAttrs.add(existing);
+          if (isUserVisible(existing)) {
-    
-    XAttrSetFlag.validate(xAttr.getName(), exist, flag);
-    xAttrs.add(xAttr);
-    
-    if (isUserVisible(xAttr)) {
-      userVisibleXAttrsNum++;
-    }
-    
+
-    
+

MOV26 MOV31 UPD40 UPD40 INS78 INS31 INS65 INS40 UPD42 INS44 INS29 INS74 UPD42 MOV42 MOV44 MOV44 MOV43 MOV8 INS74 UPD42 INS29 MOV78 UPD42 INS44 INS74 UPD42 MOV44 MOV43 UPD42 INS44 MOV43 MOV43 UPD42 MOV44 MOV60 UPD66 UPD66 UPD66 UPD66 INS40 MOV21 INS74 INS42 INS65 INS65 INS65 UPD65 MOV65 INS65 INS43 INS43 INS83 INS83 INS74 UPD42 INS43 INS43 INS83 INS83 INS74 UPD42 INS60 INS65 INS65 INS65 INS65 INS65 INS83 INS83 INS74 UPD42 INS83 INS74 INS42 INS43 INS43 INS83 INS83 INS74 UPD42 INS83 INS83 INS83 INS74 UPD42 INS83 INS74 INS42 INS83 INS74 INS83 UPD74 UPD42 INS83 INS24 INS21 INS60 INS70 INS25 INS43 INS43 INS66 INS42 INS66 INS42 INS66 UPD66 INS42 INS66 INS42 UPD42 MOV42 INS43 INS43 INS42 INS42 INS43 INS43 INS74 INS59 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS43 INS43 INS43 INS27 UPD42 INS42 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 UPD43 UPD43 INS58 INS27 INS37 INS8 INS39 INS7 MOV74 INS59 MOV44 INS42 INS8 INS27 INS8 INS42 INS42 INS32 INS42 MOV42 INS42 MOV42 INS43 INS43 INS42 INS32 INS42 MOV42 UPD42 MOV42 INS42 INS27 INS32 UPD42 INS60 INS24 INS25 INS60 INS21 INS60 INS21 INS42 MOV42 INS42 MOV42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS39 INS59 INS42 INS32 INS42 INS24 INS42 MOV16 INS42 INS32 INS42 INS32 MOV60 MOV25 MOV21 MOV21 MOV25 INS42 INS33 INS70 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 UPD42 INS42 UPD42 UPD42 MOV27 INS27 INS42 INS42 INS39 INS59 INS58 INS32 INS8 INS42 MOV8 INS74 INS59 INS32 INS74 INS59 INS32 INS74 INS27 UPD42 MOV42 MOV42 UPD42 UPD42 INS42 INS34 INS42 INS42 INS58 INS27 INS37 INS8 INS36 MOV32 INS34 INS42 INS42 INS42 INS42 INS42 INS44 INS42 INS8 INS42 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS33 INS42 INS9 INS74 INS59 UPD42 MOV42 UPD42 MOV42 INS60 INS25 INS43 INS43 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS43 INS43 UPD42 INS27 INS32 UPD42 UPD42 INS39 INS59 INS42 INS32 INS42 INS25 MOV27 MOV43 INS42 INS60 INS70 MOV25 INS27 INS8 INS42 INS42 INS43 MOV43 INS42 INS32 MOV43 INS59 INS32 INS8 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS34 INS42 INS42 UPD42 UPD42 UPD42 MOV42 MOV33 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS8 INS39 INS59 INS44 INS42 INS8 INS38 INS42 INS33 INS21 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 MOV42 UPD42 MOV42 INS42 INS21 INS21 INS21 INS10 UPD42 INS42 INS34 INS32 INS42 INS32 INS53 INS25 INS42 INS9 MOV43 INS42 INS25 INS42 INS32 INS42 INS42 INS7 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS32 MOV8 INS32 INS8 INS42 INS42 INS42 INS42 INS40 INS42 INS9 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS10 INS42 INS42 INS42 INS21 INS10 UPD42 UPD42 INS42 INS45 INS45 INS7 INS42 INS9 DEL66 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL42 DEL42 DEL38 DEL45 DEL32 DEL21 DEL42 DEL32 DEL21 DEL8 DEL31 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL41 DEL25 DEL42 DEL32 DEL21 DEL42 DEL9 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL29 DEL39 DEL42 DEL42 DEL38 DEL42 DEL38 DEL42 DEL42 DEL34 DEL40 DEL32 DEL21 DEL8 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL31 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL43 DEL31 DEL43 DEL43 DEL43 DEL32 DEL32 DEL27 DEL32 DEL42 DEL32 DEL32 DEL27 DEL36 DEL38 DEL25 DEL27 DEL43 DEL43 DEL34 DEL27 DEL34 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL36
Merge trunk into auto-failover branch.

Addressed two semantic conflicts after the commit of HADOOP-8077 -- test code was referencing the old constant for the fencing methods config key.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3042@1310174 13f79535-47bb-0310-9956-ffa450edef68

-package org.apache.hadoop.hdfs.server.namenode;
+package org.apache.hadoop.hdfs.server.journalservice;
-import org.apache.hadoop.hdfs.DFSUtil;
-import org.apache.hadoop.hdfs.server.common.StorageInfo;
+import org.apache.hadoop.hdfs.server.common.StorageInfo;
+
-  private final boolean internalRpcServer;
-  private volatile State state = State.INIT;
-  private RPC.Server rpcServer;
+  private final StateHandler stateHandler = new StateHandler();
+  private final RPC.Server rpcServer;
-    INIT,
-    STARTING_UP,
-    RUNNING,
-    STOPPED;
+    /** The service is initialized and ready to start. */
+    INIT(false, false),
+    /**
+     * RPC server is started.
+     * The service is ready to receive requests from namenode.
+     */
+    STARTED(false, false),
+    /** The service is fenced by a namenode and waiting for roll. */
+    WAITING_FOR_ROLL(false, true),
+    /**
+     * The existing log is syncing with another source
+     * and it accepts journal from Namenode.
+     */
+    SYNCING(true, true),
+    /** The existing log is in sync and it accepts journal from Namenode. */
+    IN_SYNC(true, true),
+    /** The service is stopped. */
+    STOPPED(false, false);
+
+    final boolean isJournalAllowed;
+    final boolean isStartLogSegmentAllowed;
+    
+    State(boolean isJournalAllowed, boolean isStartLogSegmentAllowed) {
+      this.isJournalAllowed = isJournalAllowed;
+      this.isStartLogSegmentAllowed = isStartLogSegmentAllowed;
+    }
-  /**
-   * JournalListener is a callback interface to handle journal records
-   * received from the namenode.
-   */
-  public interface JournalListener {
-    /**
-     * Check the namespace information returned by a namenode
-     * @param service service that is making the callback
-     * @param info returned namespace information from the namenode
-     * 
-     * The application using {@link JournalService} can stop the service if
-     * {@code info} validation fails.
-     */
-    public void verifyVersion(JournalService service, NamespaceInfo info);
+  static class StateHandler {
+    State current = State.INIT;
-    /**
-     * Process the received Journal record
-     * @param service {@link JournalService} making the callback
-     * @param firstTxnId first transaction Id in the journal
-     * @param numTxns number of records
-     * @param records journal records
-     * @throws IOException on error
-     * 
-     * Any IOException thrown from the listener is thrown back in 
-     * {@link JournalProtocol#journal}
-     */
-    public void journal(JournalService service, long firstTxnId, int numTxns,
-        byte[] records) throws IOException;
-    
-    /**
-     * Roll the editlog
-     * @param service {@link JournalService} making the callback
-     * @param txid transaction ID to roll at
-     * 
-     * Any IOException thrown from the listener is thrown back in 
-     * {@link JournalProtocol#startLogSegment}
-     */
-    public void rollLogs(JournalService service, long txid) throws IOException;
-  }
-  
-  /**
-   * Constructor to create {@link JournalService} based on an existing RPC server.
-   * After creating the service, the caller needs to start the RPC server.
-   * 
-   * @param conf Configuration
-   * @param nnAddr host:port for the active Namenode's RPC server
-   * @param listener call-back interface to listen to journal activities
-   * @param rpcServer RPC server if the application has already one, which can be
-   *          reused. If this is null, then the RPC server is started by
-   *          {@link JournalService}
-   * @param reg namenode registration information if there is one already, say
-   *          if you are using this service in namenode. If it is null, then the
-   *          service creates a new registration.
-   * @throws IOException on error
-   */
-  JournalService(Configuration conf, InetSocketAddress nnAddr,
-      JournalListener listener, RPC.Server rpcServer, NamenodeRegistration reg)
-      throws IOException {
-    this.nnAddress = nnAddr;
-    this.listener = listener;
-    this.registration = reg;
-    this.internalRpcServer = false;
-    this.namenode = NameNodeProxies.createNonHAProxy(conf, nnAddr,
-        NamenodeProtocol.class, UserGroupInformation.getCurrentUser(), true)
-        .getProxy();
-    initRpcServer(conf, rpcServer);
+    synchronized void start() {
+      if (current != State.INIT) {
+        throw new IllegalStateException("Service cannot be started in "
+            + current + " state.");
+      }
+      current = State.STARTED;
+    }
+
+    synchronized void waitForRoll() {
+      if (current != State.STARTED) {
+        throw new IllegalStateException("Cannot wait-for-roll in " + current
+            + " state.");
+      }
+      current = State.WAITING_FOR_ROLL;
+    }
+
+    synchronized void startLogSegment() throws IOException {
+      if (current == State.WAITING_FOR_ROLL) {
+        current = State.SYNCING;
+      }
+    }
+
+    synchronized void isStartLogSegmentAllowed() throws IOException {
+      if (!current.isStartLogSegmentAllowed) {
+        throw new IOException("Cannot start log segment in " + current
+            + " state.");
+      }
+    }
+
+    synchronized void isJournalAllowed() throws IOException {
+      if (!current.isJournalAllowed) {
+        throw new IOException("Cannot journal in " + current + " state.");
+      }
+    }
+
+    synchronized boolean isStopped() {
+      if (current == State.STOPPED) {
+        LOG.warn("Ignore stop request since the service is in " + current
+            + " state.");
+        return true;
+      }
+      current = State.STOPPED;
+      return false;
+    }
-    this.internalRpcServer = true;
-    initRpcServer(conf, serverAddress);
+    this.rpcServer = createRpcServer(conf, serverAddress, this);
+
-    synchronized(this) {
-      if (state != State.INIT) {
-        LOG.info("Service cannot be started in state - " + state);
-        return;
-      }
-      state = State.STARTING_UP;
-    }
+    stateHandler.start();
+
-    if (internalRpcServer) {
-      LOG.info("Starting rpc server");
-      rpcServer.start();
-    }
-    
-    boolean registered = false;
-    boolean handshakeComplete = false;
-    boolean rollEdits = false;
-    while (state == State.STARTING_UP) {
+    LOG.info("Starting rpc server");
+    rpcServer.start();
+
+    for(boolean registered = false, handshakeComplete = false; ; ) {
-        }
-        
-        if (!rollEdits) {
-          namenode.rollEditLog();
-          rollEdits = true;
-          LOG.info("Editlog roll completed");
-    synchronized(this) {
-      state = State.RUNNING;
+
+    stateHandler.waitForRoll();
+    try {
+      namenode.rollEditLog();
+    } catch (IOException e) {
+      LOG.warn("Encountered exception ", e);
-    
-    synchronized (this) {
-      if (state == State.STOPPED) {
-        return;
-      }
-      state = State.STOPPED;
-    }
-    if (internalRpcServer && rpcServer != null) {
+    if (!stateHandler.isStopped()) {
-      rpcServer = null;
+    stateHandler.isJournalAllowed();
+    stateHandler.isStartLogSegmentAllowed();
+    stateHandler.startLogSegment();
-  /** 
-   * Stand alone mode where RPC Server is created and managed by this service 
-   */
-  private void initRpcServer(Configuration conf, InetSocketAddress serverAddress)
-      throws IOException {
+  /** Create an RPC server. */
+  private static RPC.Server createRpcServer(Configuration conf,
+      InetSocketAddress address, JournalProtocol impl) throws IOException {
-        new JournalProtocolServerSideTranslatorPB(this);
+        new JournalProtocolServerSideTranslatorPB(impl);
-    rpcServer = RPC.getServer(JournalProtocolPB.class, service,
-        serverAddress.getHostName(), serverAddress.getPort(), 1, false, conf,
-        null);
-  }
-
-  /**
-   * RPC Server is created and managed by the application - used by this service
-   */
-  private void initRpcServer(Configuration conf, RPC.Server server)
-      throws IOException {
-    rpcServer = server;
-    JournalProtocolServerSideTranslatorPB xlator = 
-        new JournalProtocolServerSideTranslatorPB(this);
-    BlockingService service = 
-        JournalProtocolService.newReflectiveBlockingService(xlator);
-    DFSUtil.addPBProtocol(conf, JournalProtocolPB.class, service, rpcServer);
+    return RPC.getServer(JournalProtocolPB.class, service,
+        address.getHostName(), address.getPort(), 1, false, conf, null);

MOV26 UPD40 INS23 INS71 INS55 INS31 MOV83 MOV83 INS43 MOV59 INS83 MOV42 MOV72 INS72 INS72 INS72 INS72 INS72 INS23 INS23 INS31 INS83 INS42 INS23 INS31 MOV31 INS31 INS31 INS31 INS31 MOV29 INS83 INS39 INS42 INS8 INS83 MOV43 UPD42 INS44 INS42 UPD42 INS14 INS29 INS9 INS9 INS29 INS42 INS9 INS9 INS29 INS42 INS9 INS9 INS29 INS42 INS9 INS9 INS29 INS42 INS9 INS9 INS29 INS42 INS9 INS9 INS83 INS39 INS59 INS83 INS39 INS59 INS42 MOV44 MOV44 INS8 MOV43 INS59 INS83 INS39 INS42 INS8 UPD83 UPD42 INS8 UPD83 MOV83 MOV39 UPD42 MOV42 MOV43 INS8 INS83 INS39 INS42 MOV43 INS8 INS83 INS39 INS42 MOV43 INS8 INS83 INS39 INS42 INS8 INS21 MOV21 MOV21 MOV21 INS24 MOV21 INS54 INS25 INS21 INS21 INS21 UPD42 INS43 INS42 INS41 INS43 INS65 MOV65 MOV65 UPD65 MOV65 UPD65 MOV65 UPD65 MOV65 INS42 INS42 UPD39 UPD42 INS39 INS42 MOV21 MOV21 INS42 INS40 INS25 MOV21 MOV25 MOV21 INS25 INS25 INS25 INS25 INS21 INS41 INS7 INS58 MOV8 INS32 INS8 INS12 INS38 MOV8 INS32 INS32 INS32 UPD66 INS42 MOV43 INS32 INS42 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS27 INS8 INS7 UPD27 INS27 INS8 INS38 INS8 INS38 INS8 INS27 INS8 INS7 INS9 MOV22 INS32 UPD42 INS42 INS39 MOV59 MOV59 INS42 INS42 MOV21 INS44 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 MOV57 MOV42 MOV32 MOV32 MOV34 MOV9 MOV42 MOV33 UPD42 UPD42 INS42 INS40 INS53 INS42 INS40 UPD42 UPD40 INS53 UPD42 UPD40 INS42 INS40 MOV21 INS40 INS53 INS40 INS53 INS42 INS40 INS21 INS41 INS42 INS40 UPD42 UPD42 MOV42 MOV42 MOV42 INS52 INS43 INS42 MOV21 UPD42 MOV42 UPD42 MOV42 MOV43 INS42 UPD42 UPD42 UPD42 UPD42 INS14 INS14 INS14 INS14 INS32 INS9 INS42 INS32 INS43 INS27 INS43 INS27 UPD42 INS40 MOV43 INS27 INS43 INS27 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 INS45 INS42 UPD42 MOV42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 UPD42 MOV42 INS45 INS42 INS45 INS45 INS42 INS45 INS10 DEL40 DEL26 DEL39 DEL42 DEL59 DEL23 DEL40 DEL83 DEL83 DEL23 DEL42 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL52 DEL8 DEL51 DEL42 DEL42 DEL33 DEL27 DEL27 DEL25 DEL8 DEL42 DEL42 DEL72 DEL42 DEL72 DEL42 DEL72 DEL71 DEL29 DEL83 DEL42 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL66 DEL65 DEL42 DEL66 DEL42 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL42 DEL42 DEL67 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL31 DEL66 DEL65 DEL42 DEL66 DEL42 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL42 DEL42 DEL67 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31 DEL55 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL42 DEL65 DEL65 DEL42 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL40 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL42 DEL42 DEL32 DEL9 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL31 DEL9 DEL7 DEL21 DEL32 DEL21 DEL42 DEL45 DEL42 DEL27 DEL42 DEL38 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL45 DEL32 DEL21 DEL10 DEL8 DEL25 DEL42 DEL40 DEL7 DEL42 DEL40 DEL7 DEL52 DEL42 DEL40 DEL27 DEL41 DEL8 DEL25 DEL8 DEL51 DEL42 DEL8 DEL25 DEL39 DEL60 DEL39 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL40 DEL27 DEL61 DEL52 DEL8 DEL51 DEL42 DEL33 DEL7 DEL21 DEL39 DEL52 DEL42 DEL32 DEL7 DEL21 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL52 DEL14 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL21 DEL8 DEL31
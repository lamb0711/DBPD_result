HDFS-8979. Clean up checkstyle warnings in hadoop-hdfs-client module. Contributed by Mingliang Liu.

- * BlockReaderLocalLegacy enables local short circuited reads. If the DFS client is on
- * the same machine as the datanode, then the client can read files directly
- * from the local file system rather than going through the datanode for better
- * performance. <br>
+ * BlockReaderLocalLegacy enables local short circuited reads. If the DFS client
+ * is on the same machine as the datanode, then the client can read files
+ * directly from the local file system rather than going through the datanode
+ * for better performance. <br>
-      int hashTableCapacity = (int) Math.ceil(cacheSize / hashTableLoadFactor) + 1;
+      int hashTableCapacity = (int) Math.ceil(cacheSize / hashTableLoadFactor)
+          + 1;
-    
+
-    private void setBlockLocalPathInfo(ExtendedBlock b, BlockLocalPathInfo info) {
+    private void setBlockLocalPathInfo(ExtendedBlock b,
+        BlockLocalPathInfo info) {
-  
+
-  private static final Map<Integer, LocalDatanodeInfo> localDatanodeInfoMap = new HashMap<Integer, LocalDatanodeInfo>();
+  private static final Map<Integer, LocalDatanodeInfo> localDatanodeInfoMap =
+      new HashMap<>();
-  
+
-      Token<BlockTokenIdentifier> token, DatanodeInfo node, 
+      Token<BlockTokenIdentifier> token, DatanodeInfo node,
-        localBlockReader = new BlockReaderLocalLegacy(scConf, file, blk, token,
-            startOffset, length, pathinfo, checksum, true, dataIn,
-            firstChunkOffset, checksumIn, tracer);
+        localBlockReader = new BlockReaderLocalLegacy(scConf, file, blk,
+            startOffset, checksum, true, dataIn, firstChunkOffset, checksumIn,
+            tracer);
-        localBlockReader = new BlockReaderLocalLegacy(scConf, file, blk, token,
-            startOffset, length, pathinfo, dataIn, tracer);
+        localBlockReader = new BlockReaderLocalLegacy(scConf, file, blk,
+            startOffset, dataIn, tracer);
-  
+
-  
+
-    LocalDatanodeInfo localDatanodeInfo = getLocalDatanodeInfo(node.getIpcPort());
-    BlockLocalPathInfo pathinfo = null;
+    LocalDatanodeInfo localDatanodeInfo =
+        getLocalDatanodeInfo(node.getIpcPort());
+    BlockLocalPathInfo pathinfo;
-      // We cannot cache the path information for a replica on transient storage.
+      // We can't cache the path information for a replica on transient storage.
-  
+
-      ExtendedBlock block, Token<BlockTokenIdentifier> token, long startOffset,
-      long length, BlockLocalPathInfo pathinfo, FileInputStream dataIn,
+      ExtendedBlock block, long startOffset, FileInputStream dataIn,
-    this(conf, hdfsfile, block, token, startOffset, length, pathinfo,
+    this(conf, hdfsfile, block, startOffset,
-      ExtendedBlock block, Token<BlockTokenIdentifier> token, long startOffset,
-      long length, BlockLocalPathInfo pathinfo, DataChecksum checksum,
+      ExtendedBlock block, long startOffset, DataChecksum checksum,
-    slowReadBuff = bufferPool.getBuffer(bytesPerChecksum * chunksPerChecksumRead);
+    slowReadBuff = bufferPool.getBuffer(
+        bytesPerChecksum * chunksPerChecksumRead);
-      // Skip both input streams to beginning of the chunk containing startOffset
+      // Skip both input streams to beginning of the chunk containing
+      // startOffset
-        long checkSumOffset = (firstChunkOffset / bytesPerChecksum) * checksumSize;
+        long checkSumOffset = (firstChunkOffset / bytesPerChecksum) *
+            checksumSize;
-    TraceScope scope = tracer.
-        newScope("BlockReaderLocalLegacy#fillBuffer(" + blockId + ")");
-    try {
+    try (TraceScope ignored = tracer.
+        newScope("BlockReaderLocalLegacy#fillBuffer(" + blockId + ")")) {
-    } finally {
-      scope.close();
-  
+
-        int fromSlowReadBuff = Math.min(buf.remaining(), slowReadBuff.remaining());
+        int fromSlowReadBuff = Math.min(buf.remaining(),
+            slowReadBuff.remaining());
-      if ((buf.remaining() > 0 && buf.remaining() < bytesPerChecksum) || offsetFromChunkBoundary > 0) {
-        int toRead = Math.min(buf.remaining(), bytesPerChecksum - offsetFromChunkBoundary);
+      if ((buf.remaining() > 0 && buf.remaining() < bytesPerChecksum) ||
+          offsetFromChunkBoundary > 0) {
+        int toRead = Math.min(buf.remaining(),
+            bytesPerChecksum - offsetFromChunkBoundary);
-      // Non-checksummed reads are much easier; we can just fill the buffer directly.
+      // Non-checksummed reads are much easier; we can just fill the buffer
+      // directly.
-    int dataRead = -1;
+    int dataRead;
-      // Equivalent to (int)Math.ceil(toChecksum.remaining() * 1.0 / bytesPerChecksum );
+      // Equivalent to
+      // (int)Math.ceil(toChecksum.remaining() * 1.0 / bytesPerChecksum );
-        (toChecksum.remaining() + bytesPerChecksum - 1) / bytesPerChecksum;
+          (toChecksum.remaining() + bytesPerChecksum - 1) / bytesPerChecksum;
-    int nRead = -1;
+    int nRead;
-          (bytesPerChecksum - ((len + offsetFromChunkBoundary) % bytesPerChecksum));
+          (bytesPerChecksum -
+              ((len + offsetFromChunkBoundary) % bytesPerChecksum));
-  public synchronized int read(byte[] buf, int off, int len) throws IOException {
+  public synchronized int read(byte[] buf, int off, int len)
+      throws IOException {
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  public int available() throws IOException {
+  public int available() {
-  
+

UPD66 UPD66 UPD66 UPD66 UPD74 INS58 MOV43 MOV59 UPD42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL34 DEL38 DEL34 DEL38 DEL42 DEL43
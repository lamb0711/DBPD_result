HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.

+import org.apache.commons.io.Charsets;
+import static org.apache.hadoop.hdfs.server.namenode.snapshot.Snapshot.CURRENT_STATE_ID;
-   * @throws FileAlreadyExistsException
-   * @throws QuotaExceededException
-   * @throws UnresolvedLinkException
-   * @throws SnapshotAccessControlException 
+   * @return the new INodesInPath instance that contains the new INode
-  INodeFile addFile(INodesInPath iip, String path, PermissionStatus permissions,
-                    short replication, long preferredBlockSize,
-                    String clientName, String clientMachine)
+  INodesInPath addFile(INodesInPath existing, String localName, PermissionStatus
+      permissions, short replication, long preferredBlockSize,
+      String clientName, String clientMachine)
+    newNode.setLocalName(localName.getBytes(Charsets.UTF_8));
-    boolean added = false;
+    INodesInPath newiip;
-      added = addINode(iip, newNode);
+      newiip = addINode(existing, newNode);
-    if (!added) {
-      NameNode.stateChangeLog.info("DIR* addFile: failed to add " + path);
+    if (newiip == null) {
+      NameNode.stateChangeLog.info("DIR* addFile: failed to add " +
+          existing.getPath() + "/" + localName);
-      NameNode.stateChangeLog.debug("DIR* addFile: " + path + " is added");
+      NameNode.stateChangeLog.debug("DIR* addFile: " + localName + " is added");
-    return newNode;
+    return newiip;
-  INodeFile unprotectedAddFile(long id,
-                            INodesInPath iip,
-                            PermissionStatus permissions,
-                            List<AclEntry> aclEntries,
-                            List<XAttr> xAttrs,
-                            short replication,
-                            long modificationTime,
-                            long atime,
-                            long preferredBlockSize,
-                            boolean underConstruction,
-                            String clientName,
-                            String clientMachine,
-                            byte storagePolicyId) {
+  INodeFile addFileForEditLog(long id, INodesInPath existing, byte[] localName,
+      PermissionStatus permissions, List<AclEntry> aclEntries,
+      List<XAttr> xAttrs, short replication, long modificationTime, long atime,
+      long preferredBlockSize, boolean underConstruction, String clientName,
+      String clientMachine, byte storagePolicyId) {
+    newNode.setLocalName(localName);
-      if (addINode(iip, newNode)) {
+      INodesInPath iip = addINode(existing, newNode);
+      if (iip != null) {
-          AclStorage.updateINodeAcl(newNode, aclEntries,
-            Snapshot.CURRENT_STATE_ID);
+          AclStorage.updateINodeAcl(newNode, aclEntries, CURRENT_STATE_ID);
-          XAttrStorage.updateINodeXAttrs(newNode, xAttrs,
-              Snapshot.CURRENT_STATE_ID);
+          XAttrStorage.updateINodeXAttrs(newNode, xAttrs, CURRENT_STATE_ID);
-                + iip.getPath() + " to the file system", e);
+                + existing.getPath() + " to the file system", e);
-      Quota.Counts counts = targetNode.cleanSubtree(Snapshot.CURRENT_STATE_ID,
+      Quota.Counts counts = targetNode.cleanSubtree(CURRENT_STATE_ID,
-   * @param iip the INodesInPath instance containing all the ancestral INodes
+   * @param existing the INodesInPath containing all the ancestral INodes
+   * @param child the new INode to add
+   * @return a new INodesInPath instance containing the new child INode. Null
+   * if the adding fails.
-  boolean addINode(INodesInPath iip, INode child)
+  INodesInPath addINode(INodesInPath existing, INode child)
-    child.setLocalName(iip.getLastLocalName());
-      return addLastINode(iip, child, true);
+      return addLastINode(existing, child, true);
-    final int count = parent.getChildrenList(Snapshot.CURRENT_STATE_ID).size();
+    final int count = parent.getChildrenList(CURRENT_STATE_ID).size();
-   * The same as {@link #addChild(INodesInPath, int, INode, boolean)}
-   * with pos = length - 1.
+   * Add a child to the end of the path specified by INodesInPath.
+   * @return an INodesInPath instance containing the new INode
-  private boolean addLastINode(INodesInPath inodesInPath, INode inode,
+  INodesInPath addLastINode(INodesInPath existing, INode inode,
-    final int pos = inodesInPath.length() - 1;
-    return addChild(inodesInPath, pos, inode, checkQuota);
-  }
+    assert existing.getLastINode() != null &&
+        existing.getLastINode().isDirectory();
-  /** Add a node child to the inodes at index pos. 
-   * Its ancestors are stored at [0, pos-1].
-   * @return false if the child with this name already exists; 
-   *         otherwise return true;
-   * @throws QuotaExceededException is thrown if it violates quota limit
-   */
-  boolean addChild(INodesInPath iip, int pos, INode child, boolean checkQuota)
-      throws QuotaExceededException {
+    final int pos = existing.length();
-    if (pos == 1 && iip.getINode(0) == rootDir && isReservedName(child)) {
+    if (pos == 1 && existing.getINode(0) == rootDir && isReservedName(inode)) {
-          "File name \"" + child.getLocalName() + "\" is reserved and cannot "
+          "File name \"" + inode.getLocalName() + "\" is reserved and cannot "
-    final INodeDirectory parent = iip.getINode(pos-1).asDirectory();
+    final INodeDirectory parent = existing.getINode(pos - 1).asDirectory();
-      final String parentPath = iip.getPath(pos - 1);
-      verifyMaxComponentLength(child.getLocalNameBytes(), parentPath);
+      final String parentPath = existing.getPath(pos - 1);
+      verifyMaxComponentLength(inode.getLocalNameBytes(), parentPath);
-    verifyINodeName(child.getLocalNameBytes());
-    
-    final Quota.Counts counts = child.computeQuotaUsage();
-    updateCount(iip, pos,
+    verifyINodeName(inode.getLocalNameBytes());
+
+    final Quota.Counts counts = inode.computeQuotaUsage();
+    updateCount(existing, pos,
-    boolean isRename = (child.getParent() != null);
+    boolean isRename = (inode.getParent() != null);
-      added = parent.addChild(child, true, iip.getLatestSnapshotId());
+      added = parent.addChild(inode, true, existing.getLatestSnapshotId());
-      updateCountNoQuotaCheck(iip, pos,
+      updateCountNoQuotaCheck(existing, pos,
-      updateCountNoQuotaCheck(iip, pos,
+      updateCountNoQuotaCheck(existing, pos,
+      return null;
-        AclStorage.copyINodeDefaultAcl(child);
+        AclStorage.copyINodeDefaultAcl(inode);
-      addToInodeMap(child);
+      addToInodeMap(inode);
-    return added;
+    return INodesInPath.append(existing, inode, inode.getLocalNameBytes());
-  
-  boolean addLastINodeNoQuotaCheck(INodesInPath inodesInPath, INode i) {
+
+  INodesInPath addLastINodeNoQuotaCheck(INodesInPath existing, INode i) {
-      return addLastINode(inodesInPath, i, false);
+      return addLastINode(existing, i, false);
-    return false;
+    return null;
-  
+
-  long removeLastINode(final INodesInPath iip)
-      throws QuotaExceededException {
+  long removeLastINode(final INodesInPath iip) throws QuotaExceededException {

INS26 INS26 INS40 INS40 UPD43 UPD42 INS44 INS43 INS43 INS42 MOV44 MOV44 MOV43 UPD65 UPD42 UPD42 UPD42 INS21 UPD42 INS5 INS42 INS21 INS65 INS65 INS42 UPD42 MOV42 UPD42 INS6 INS60 MOV60 UPD42 UPD66 INS32 INS43 INS27 UPD42 INS39 INS85 INS32 UPD42 UPD66 INS42 INS66 INS66 INS66 UPD66 UPD66 INS27 INS83 INS39 INS59 MOV43 INS32 INS33 INS42 INS42 INS32 INS42 UPD42 INS42 INS33 INS42 INS42 INS42 INS60 INS25 INS27 INS32 INS42 INS32 UPD42 INS32 MOV60 UPD42 INS41 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS43 INS59 INS27 MOV8 INS32 INS33 INS32 INS42 INS42 INS42 UPD42 MOV32 INS42 MOV43 UPD42 UPD42 INS33 INS42 INS42 UPD42 INS42 INS42 INS32 INS42 INS33 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 UPD42 INS32 INS45 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL39 DEL9 DEL42 DEL38 DEL42 DEL40 DEL40 DEL32 DEL25 DEL40 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL40 DEL66 DEL42 DEL69 DEL39 DEL69 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL42 DEL66 DEL65 DEL39 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL42 DEL39 DEL9
HDFS-2560. Refactor BPOfferService to be a static inner class. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203444 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.common.StorageInfo;
-        BPOfferService bpos = new BPOfferService(isa);
+        BPOfferService bpos = new BPOfferService(isa, DataNode.this);
-            BPOfferService bpos = new BPOfferService(nnaddr);
+            BPOfferService bpos = new BPOfferService(nnaddr, DataNode.this);
-
-          for (BPOfferService bpos : toShutdown) {
-            remove(bpos);
-          }
+        
+        // stoping the BPOSes causes them to call remove() on their own when they
+        // clean up.
+        
-  boolean resetBlockReportTime = true;
-  long lastDeletedReport = 0;
+    assert data != null;
-  class BPOfferService implements Runnable {
+  static class BPOfferService implements Runnable {
+    long lastDeletedReport = 0;
+
+    boolean resetBlockReportTime = true;
+
-    private boolean isBlockTokenInitialized = false;
+    private final DataNode dn;
-    BPOfferService(InetSocketAddress isa) {
-      this.bpRegistration = new DatanodeRegistration(getMachineName());
-      bpRegistration.setInfoPort(infoServer.getPort());
-      bpRegistration.setIpcPort(getIpcPort());
-      this.nnAddr = isa;
+    BPOfferService(InetSocketAddress nnAddr, DataNode dn) {
+      this.dn = dn;
+      this.bpRegistration = dn.createRegistration();
+      this.nnAddr = nnAddr;
-      blockPoolManager.addBlockPool(this);
-      while (shouldRun && shouldServiceRun) {
+      while (dn.shouldRun && shouldServiceRun) {
-    void setupBP(Configuration conf, AbstractList<File> dataDirs) 
+    void setupBP(Configuration conf) 
-      synchronized(DataNode.this) {
-        // we do not allow namenode from different cluster to register
-        if(clusterId != null && !clusterId.equals(nsInfo.clusterID)) {
-          throw new IOException(
-              "cannot register with the namenode because clusterid do not match:"
-              + " nn=" + nsInfo.getBlockPoolID() + "; nn cid=" + nsInfo.clusterID + 
-              ";dn cid=" + clusterId);
-        }
-
-        setupBPStorage();
-
-        setClusterId(nsInfo.clusterID);
-      }
-    
-      initPeriodicScanners(conf);
-    }
-    
-    void setupBPStorage() throws IOException {
-      StartupOption startOpt = getStartupOption(conf);
-      assert startOpt != null : "Startup option must be set.";
-
-      boolean simulatedFSDataset = conf.getBoolean(
-          DFS_DATANODE_SIMULATEDDATASTORAGE_KEY,
-          DFS_DATANODE_SIMULATEDDATASTORAGE_DEFAULT);
+      dn.initBlockPool(this, nsInfo);
-      if (simulatedFSDataset) {
-        initFsDataSet(conf, dataDirs);
-        bpRegistration.setStorageID(getStorageId()); //same as DN
+      bpRegistration.setStorageID(dn.getStorageId());
+      StorageInfo storageInfo = dn.storage.getBPStorage(blockPoolId);
+      if (storageInfo == null) {
+        // it's null in the case of SimulatedDataSet
-        bpRegistration.storageInfo.namespaceID = bpNSInfo.namespaceID;
-        bpRegistration.storageInfo.clusterID = bpNSInfo.clusterID;
+        bpRegistration.setStorageInfo(nsInfo);
-        // read storage info, lock data dirs and transition fs state if necessary          
-        storage.recoverTransitionRead(DataNode.this, blockPoolId, bpNSInfo,
-            dataDirs, startOpt);
-        LOG.info("setting up storage: nsid=" + storage.namespaceID + ";bpid="
-            + blockPoolId + ";lv=" + storage.layoutVersion + ";nsInfo="
-            + bpNSInfo);
-
-        bpRegistration.setStorageID(getStorageId());
-        bpRegistration.setStorageInfo(storage.getBPStorage(blockPoolId));
-        initFsDataSet(conf, dataDirs);
+        bpRegistration.setStorageInfo(storageInfo);
-      data.addBlockPool(blockPoolId, conf);
-
+    
-        - ( blockReportInterval - DFSUtil.getRandom().nextInt((int)(delay)));
+        - ( dn.blockReportInterval - DFSUtil.getRandom().nextInt((int)(delay)));
-        lastBlockReport = lastHeartbeat - blockReportInterval;
+        lastBlockReport = lastHeartbeat - dn.blockReportInterval;
-      if (startTime - lastBlockReport > blockReportInterval) {
+      if (startTime - lastBlockReport > dn.blockReportInterval) {
-        BlockListAsLongs bReport = data.getBlockReport(blockPoolId);
+        BlockListAsLongs bReport = dn.data.getBlockReport(blockPoolId);
-        metrics.addBlockReport(brSendCost);
+        dn.metrics.addBlockReport(brSendCost);
-          lastBlockReport = startTime - DFSUtil.getRandom().nextInt((int)(blockReportInterval));
+          lastBlockReport = startTime - DFSUtil.getRandom().nextInt((int)(dn.blockReportInterval));
-          blockReportInterval * blockReportInterval;
+          dn.blockReportInterval * dn.blockReportInterval;
-          data.getCapacity(),
-          data.getDfsUsed(),
-          data.getRemaining(),
-          data.getBlockPoolUsed(blockPoolId),
-          xmitsInProgress.get(),
-          getXceiverCount(), data.getNumFailedVolumes());
+          dn.data.getCapacity(),
+          dn.data.getDfsUsed(),
+          dn.data.getRemaining(),
+          dn.data.getBlockPoolUsed(blockPoolId),
+          dn.xmitsInProgress.get(),
+          dn.getXceiverCount(), dn.data.getNumFailedVolumes());
-      
-      blockPoolManager.remove(this);
-      if (blockScanner != null) {
-        blockScanner.removeBlockPool(this.getBlockPoolId());
-      }
-    
-      if (data != null) { 
-        data.shutdownBlockPool(this.getBlockPoolId());
-      }
-
-      if (storage != null) {
-        storage.removeBlockPoolStorage(this.getBlockPoolId());
-      }
+      dn.shutdownBlockPool(this);
-          + deleteReportInterval + " msec " + " BLOCKREPORT_INTERVAL of "
-          + blockReportInterval + "msec" + " Initial delay: "
-          + initialBlockReportDelay + "msec" + "; heartBeatInterval="
-          + heartBeatInterval);
+          + dn.deleteReportInterval + " msec " + " BLOCKREPORT_INTERVAL of "
+          + dn.blockReportInterval + "msec" + " Initial delay: "
+          + dn.initialBlockReportDelay + "msec" + "; heartBeatInterval="
+          + dn.heartBeatInterval);
-      while (shouldRun && shouldServiceRun) {
+      while (dn.shouldRun && shouldServiceRun) {
-          if (startTime - lastHeartbeat > heartBeatInterval) {
+          if (startTime - lastHeartbeat > dn.heartBeatInterval) {
-            if (!heartbeatsDisabledForTests) {
+            if (!dn.heartbeatsDisabledForTests) {
-              metrics.addHeartbeat(now() - startTime);
+              dn.metrics.addHeartbeat(now() - startTime);
-              || (startTime - lastDeletedReport > deleteReportInterval)) {
+              || (startTime - lastDeletedReport > dn.deleteReportInterval)) {
-          if (blockScanner != null) {
-            blockScanner.addBlockPool(this.blockPoolId);
+          if (dn.blockScanner != null) {
+            dn.blockScanner.addBlockPool(this.blockPoolId);
-          long waitTime = heartBeatInterval - 
+          long waitTime = dn.heartBeatInterval - 
-            long sleepTime = Math.min(1000, heartBeatInterval);
+            long sleepTime = Math.min(1000, dn.heartBeatInterval);
-      while(shouldRun && shouldServiceRun) {
+      while(dn.shouldRun && shouldServiceRun) {
-          NetUtils.getHostname();
-          hostName = bpRegistration.getHost();
-
-      if (storage.getStorageID().equals("")) {
-        storage.setStorageID(bpRegistration.getStorageID());
-        storage.writeAll();
-        LOG.info("New storage id " + bpRegistration.getStorageID()
-            + " is assigned to data-node " + bpRegistration.getName());
-      } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {
-        throw new IOException("Inconsistent storage IDs. Name-node returned "
-            + bpRegistration.getStorageID() 
-            + ". Expecting " + storage.getStorageID());
-      }
-
-      if (!isBlockTokenInitialized) {
-        /* first time registering with NN */
-        ExportedBlockKeys keys = bpRegistration.exportedKeys;
-        isBlockTokenEnabled = keys.isBlockTokenEnabled();
-        if (isBlockTokenEnabled) {
-          long blockKeyUpdateInterval = keys.getKeyUpdateInterval();
-          long blockTokenLifetime = keys.getTokenLifetime();
-          LOG.info("Block token params received from NN: for block pool " +
-              blockPoolId + " keyUpdateInterval="
-              + blockKeyUpdateInterval / (60 * 1000)
-              + " min(s), tokenLifetime=" + blockTokenLifetime / (60 * 1000)
-              + " min(s)");
-          final BlockTokenSecretManager secretMgr = 
-            new BlockTokenSecretManager(false, 0, blockTokenLifetime);
-          blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);
-        }
-        isBlockTokenInitialized = true;
-      }
-
-      if (isBlockTokenEnabled) {
-        blockPoolTokenSecretManager.setKeys(blockPoolId,
-            bpRegistration.exportedKeys);
-        bpRegistration.exportedKeys = ExportedBlockKeys.DUMMY_KEYS;
-      }
+      
+      dn.bpRegistrationSucceeded(bpRegistration, blockPoolId);
-      scheduleBlockReport(initialBlockReportDelay);
+      scheduleBlockReport(dn.initialBlockReportDelay);
-      LOG.info(bpRegistration + "In BPOfferService.run, data = " + data
+      LOG.info(bpRegistration + "In BPOfferService.run, data = " + dn.data
-          setupBP(conf, dataDirs);
+          setupBP(dn.conf);
-        while (shouldRun && shouldServiceRun) {
+        while (dn.shouldRun && shouldServiceRun) {
-            if (shouldRun && shouldServiceRun) {
+            if (dn.shouldRun && shouldServiceRun) {
-            + blockPoolId);
+            + blockPoolId + " thread " + Thread.currentThread().getId());
-        transferBlocks(bcmd.getBlockPoolId(), bcmd.getBlocks(), bcmd.getTargets());
-        metrics.incrBlocksReplicated(bcmd.getBlocks().length);
+        dn.transferBlocks(bcmd.getBlockPoolId(), bcmd.getBlocks(), bcmd.getTargets());
+        dn.metrics.incrBlocksReplicated(bcmd.getBlocks().length);
-          if (blockScanner != null) {
-            blockScanner.deleteBlocks(bcmd.getBlockPoolId(), toDelete);
+          if (dn.blockScanner != null) {
+            dn.blockScanner.deleteBlocks(bcmd.getBlockPoolId(), toDelete);
-          data.invalidate(bcmd.getBlockPoolId(), toDelete);
+          dn.data.invalidate(bcmd.getBlockPoolId(), toDelete);
-          checkDiskError();
+          dn.checkDiskError();
-        metrics.incrBlocksRemoved(toDelete.length);
+        dn.metrics.incrBlocksRemoved(toDelete.length);
-        if (shouldRun && shouldServiceRun) {
+        if (dn.shouldRun && shouldServiceRun) {
-        storage.finalizeUpgrade(((FinalizeCommand) cmd)
+        dn.storage.finalizeUpgrade(((FinalizeCommand) cmd)
-        recoverBlocks(((BlockRecoveryCommand)cmd).getRecoveringBlocks());
+        dn.recoverBlocks(((BlockRecoveryCommand)cmd).getRecoveringBlocks());
-        if (isBlockTokenEnabled) {
-          blockPoolTokenSecretManager.setKeys(blockPoolId, 
+        if (dn.isBlockTokenEnabled) {
+          dn.blockPoolTokenSecretManager.setKeys(blockPoolId, 
-                       (DataXceiverServer) dataXceiverServer.getRunnable();
+                       (DataXceiverServer) dn.dataXceiverServer.getRunnable();
-          new UpgradeManagerDatanode(DataNode.this, blockPoolId);
+          new UpgradeManagerDatanode(dn, blockPoolId);
+  /**
+   * Check that the registration returned from a NameNode is consistent
+   * with the information in the storage. If the storage is fresh/unformatted,
+   * sets the storage ID based on this registration.
+   * Also updates the block pool's state in the secret manager.
+   */
+  private synchronized void bpRegistrationSucceeded(DatanodeRegistration bpRegistration,
+      String blockPoolId)
+      throws IOException {
+    hostName = bpRegistration.getHost();
+
+    if (storage.getStorageID().equals("")) {
+      // This is a fresh datanode -- take the storage ID provided by the
+      // NN and persist it.
+      storage.setStorageID(bpRegistration.getStorageID());
+      storage.writeAll();
+      LOG.info("New storage id " + bpRegistration.getStorageID()
+          + " is assigned to data-node " + bpRegistration.getName());
+    } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {
+      throw new IOException("Inconsistent storage IDs. Name-node returned "
+          + bpRegistration.getStorageID() 
+          + ". Expecting " + storage.getStorageID());
+    }
+    
+    registerBlockPoolWithSecretManager(bpRegistration, blockPoolId);
+  }
+  
+  /**
+   * After the block pool has contacted the NN, registers that block pool
+   * with the secret manager, updating it with the secrets provided by the NN.
+   * @param bpRegistration
+   * @param blockPoolId
+   * @throws IOException
+   */
+  private void registerBlockPoolWithSecretManager(DatanodeRegistration bpRegistration,
+      String blockPoolId) throws IOException {
+    ExportedBlockKeys keys = bpRegistration.exportedKeys;
+    isBlockTokenEnabled = keys.isBlockTokenEnabled();
+    // TODO should we check that all federated nns are either enabled or
+    // disabled?
+    if (!isBlockTokenEnabled) return;
+    
+    if (!blockPoolTokenSecretManager.isBlockPoolRegistered(blockPoolId)) {
+      long blockKeyUpdateInterval = keys.getKeyUpdateInterval();
+      long blockTokenLifetime = keys.getTokenLifetime();
+      LOG.info("Block token params received from NN: for block pool " +
+          blockPoolId + " keyUpdateInterval="
+          + blockKeyUpdateInterval / (60 * 1000)
+          + " min(s), tokenLifetime=" + blockTokenLifetime / (60 * 1000)
+          + " min(s)");
+      final BlockTokenSecretManager secretMgr = 
+        new BlockTokenSecretManager(false, 0, blockTokenLifetime);
+      blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);
+    }
+    
+    blockPoolTokenSecretManager.setKeys(blockPoolId,
+        bpRegistration.exportedKeys);
+    bpRegistration.exportedKeys = ExportedBlockKeys.DUMMY_KEYS;
+  }
+
+  /**
+   * Remove the given block pool from the block scanner, dataset, and storage.
+   */
+  private void shutdownBlockPool(BPOfferService bpos) {
+    blockPoolManager.remove(bpos);
+
+    String bpId = bpos.getBlockPoolId();
+    if (blockScanner != null) {
+      blockScanner.removeBlockPool(bpId);
+    }
+  
+    if (data != null) { 
+      data.shutdownBlockPool(bpId);
+    }
+
+    if (storage != null) {
+      storage.removeBlockPoolStorage(bpId);
+    }
+  }
+
+  void initBlockPool(BPOfferService bpOfferService,
+      NamespaceInfo nsInfo) throws IOException {
+    String blockPoolId = nsInfo.getBlockPoolID();
+
+    blockPoolManager.addBlockPool(bpOfferService);
+
+    synchronized (this) {
+      // we do not allow namenode from different cluster to register
+      if(clusterId != null && !clusterId.equals(nsInfo.clusterID)) {
+        throw new IOException(
+            "cannot register with the namenode because clusterid do not match:"
+            + " nn=" + nsInfo.getBlockPoolID() + "; nn cid=" + nsInfo.clusterID + 
+            ";dn cid=" + clusterId);
+      }
+
+      setClusterId(nsInfo.clusterID);
+    }
+    
+    StartupOption startOpt = getStartupOption(conf);
+    assert startOpt != null : "Startup option must be set.";
+
+    boolean simulatedFSDataset = conf.getBoolean(
+        DFS_DATANODE_SIMULATEDDATASTORAGE_KEY,
+        DFS_DATANODE_SIMULATEDDATASTORAGE_DEFAULT);
+    
+    if (!simulatedFSDataset) {
+      // read storage info, lock data dirs and transition fs state if necessary          
+      storage.recoverTransitionRead(DataNode.this, blockPoolId, nsInfo,
+          dataDirs, startOpt);
+      StorageInfo bpStorage = storage.getBPStorage(blockPoolId);
+      LOG.info("setting up storage: nsid=" +
+          bpStorage.getNamespaceID() + ";bpid="
+          + blockPoolId + ";lv=" + storage.getLayoutVersion() +
+          ";nsInfo=" + nsInfo);
+    }
+    initFsDataSet();
+    initPeriodicScanners(conf);    
+    data.addBlockPool(nsInfo.getBlockPoolID(), conf);
+  }
+
+  private DatanodeRegistration createRegistration() {
+    DatanodeRegistration reg = new DatanodeRegistration(getMachineName());
+    reg.setInfoPort(infoServer.getPort());
+    reg.setIpcPort(getIpcPort());
+    return reg;
+  }
+
-  private synchronized void initFsDataSet(Configuration conf,
-      AbstractList<File> dataDirs) throws IOException {
+  private synchronized void initFsDataSet() throws IOException {

INS26 INS40 MOV23 MOV31 INS31 INS31 INS31 INS31 MOV31 INS83 MOV23 MOV23 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 MOV8 INS29 INS83 INS39 INS42 MOV44 INS8 INS39 INS42 INS44 INS44 MOV43 INS8 INS83 INS43 INS42 INS6 INS83 INS43 UPD42 INS44 INS44 UPD42 MOV44 MOV43 INS8 INS65 INS43 INS42 INS43 INS42 INS42 MOV21 MOV25 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS25 INS21 INS65 INS21 INS60 INS25 INS25 INS25 INS43 INS42 INS43 INS42 INS60 INS21 MOV51 MOV60 MOV6 MOV60 INS25 INS21 MOV21 INS21 UPD42 MOV42 INS60 INS41 INS27 INS42 UPD42 INS43 INS42 INS43 UPD42 MOV42 INS21 INS21 MOV21 MOV60 MOV21 MOV60 MOV21 MOV21 MOV21 INS60 INS25 MOV25 MOV21 MOV21 MOV21 MOV21 INS66 INS66 INS66 INS66 INS42 INS42 INS32 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS38 INS41 INS38 INS32 INS66 INS32 INS43 INS59 MOV27 INS8 MOV27 INS8 MOV27 INS8 INS42 INS42 INS43 INS59 INS32 INS38 INS8 INS32 INS32 INS43 INS59 INS42 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS7 INS7 INS43 INS59 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 MOV40 MOV40 MOV40 INS42 INS42 INS42 INS42 INS42 INS32 INS21 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS21 INS60 INS21 INS42 INS42 INS42 INS32 INS42 INS42 INS42 MOV14 UPD42 UPD42 INS22 INS42 MOV22 INS32 UPD42 INS40 UPD42 UPD42 INS52 UPD42 INS42 INS42 INS32 UPD42 MOV42 INS33 MOV21 MOV21 MOV21 INS40 UPD42 MOV52 INS40 INS40 INS42 UPD42 UPD42 INS40 MOV8 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS32 INS43 INS59 INS32 INS42 INS42 MOV43 INS52 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS40 INS40 INS40 INS40 INS40 INS42 INS40 INS40 INS40 INS40 INS40 INS40 INS42 INS40 INS25 INS40 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV52 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS27 UPD42 UPD42 MOV42 INS42 INS40 INS40 INS27 INS8 MOV43 INS42 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS42 MOV43 INS52 INS40 INS40 INS45 INS32 INS40 INS33 INS21 INS40 UPD42 INS40 INS42 INS42 INS42 INS42 MOV42 INS40 INS40 INS40 INS32 INS42 INS32 INS42 MOV43 MOV43 INS40 INS40 INS40 INS42 INS42 INS40 INS42 MOV32 INS42 INS40 INS40 INS40 INS40 INS40 MOV43 MOV52 INS40 INS40 INS40 INS40 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL39 DEL9 DEL39 DEL43 DEL43 DEL74 DEL44 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL32 DEL42 DEL40 DEL40 DEL7 DEL21 DEL40 DEL40 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL40 DEL45 DEL42 DEL45 DEL40 DEL45 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL52 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL52 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL38 DEL25 DEL42 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44
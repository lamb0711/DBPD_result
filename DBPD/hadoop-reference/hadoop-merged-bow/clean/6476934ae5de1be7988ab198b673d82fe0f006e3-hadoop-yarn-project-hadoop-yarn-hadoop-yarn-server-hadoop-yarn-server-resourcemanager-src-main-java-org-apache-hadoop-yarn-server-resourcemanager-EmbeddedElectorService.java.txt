YARN-5677. RM should transition to standby when connection is lost for an extended period. (Daniel Templeton via kasha)

+import com.google.common.annotations.VisibleForTesting;
+import java.util.Timer;
+import java.util.TimerTask;
+  private long zkSessionTimeout;
+  private Timer zkDisconnectTimer;
+  @VisibleForTesting
+  final Object zkDisconnectLock = new Object();
-    long zkSessionTimeout = conf.getLong(YarnConfiguration.RM_ZK_TIMEOUT_MS,
+    zkSessionTimeout = conf.getLong(YarnConfiguration.RM_ZK_TIMEOUT_MS,
+    cancelDisconnectTimer();
+
+    cancelDisconnectTimer();
+
+  /**
+   * Stop the disconnect timer.  Any running tasks will be allowed to complete.
+   */
+  private void cancelDisconnectTimer() {
+    synchronized (zkDisconnectLock) {
+      if (zkDisconnectTimer != null) {
+        zkDisconnectTimer.cancel();
+        zkDisconnectTimer = null;
+      }
+    }
+  }
+
+  /**
+   * When the ZK client loses contact with ZK, this method will be called to
+   * allow the RM to react. Because the loss of connection can be noticed
+   * before the session timeout happens, it is undesirable to transition
+   * immediately. Instead the method starts a timer that will wait
+   * {@link YarnConfiguration#RM_ZK_TIMEOUT_MS} milliseconds before
+   * initiating the transition into standby state.
+   */
-    /**
-     * Possibly due to transient connection issues. Do nothing.
-     * TODO: Might want to keep track of how long in this state and transition
-     * to standby.
-     */
+    LOG.warn("Lost contact with Zookeeper. Transitioning to standby in "
+        + zkSessionTimeout + " ms if connection is not reestablished.");
+
+    // If we've just become disconnected, start a timer.  When the time's up,
+    // we'll transition to standby.
+    synchronized (zkDisconnectLock) {
+      if (zkDisconnectTimer == null) {
+        zkDisconnectTimer = new Timer("Zookeeper disconnect timer");
+        zkDisconnectTimer.schedule(new TimerTask() {
+          @Override
+          public void run() {
+            synchronized (zkDisconnectLock) {
+              // Only run if the timer hasn't been cancelled
+              if (zkDisconnectTimer != null) {
+                becomeStandby();
+              }
+            }
+          }
+        }, zkSessionTimeout);
+      }
+    }

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS23 INS31 INS83 INS39 INS59 INS83 INS43 INS59 INS78 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS8 INS29 INS78 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS21 INS21 INS21 INS65 INS51 INS65 INS42 INS21 INS51 INS43 INS7 INS32 INS32 INS66 INS42 INS8 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS32 INS42 INS8 INS42 INS42 MOV32 INS42 INS42 INS25 INS67 INS42 INS42 INS27 INS25 INS27 INS8 INS42 INS42 INS45 INS42 INS45 INS27 INS8 INS42 INS33 INS21 INS21 INS42 INS33 INS21 INS21 INS32 INS7 INS7 INS32 INS42 INS42 INS42 INS33 INS42 INS14 INS42 INS42 INS14 INS42 INS43 INS45 INS43 INS1 INS42 INS42 INS31 MOV78 INS83 INS39 INS42 INS8 INS51 INS42 INS8 INS25 INS27 INS8 INS42 INS33 INS21 INS32 INS42 DEL39 DEL42 DEL59 DEL60 DEL8
HADOOP-12846. Credential Provider Recursive Dependencies. Contributed by Larry McCay.

+import java.io.IOException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.security.alias.CredentialProviderFactory;
-public class ProviderUtils {
+/**
+ * Utility methods for both key and credential provider APIs.
+ *
+ */
+public final class ProviderUtils {
+  private static final Log LOG = LogFactory.getLog(ProviderUtils.class);
+
+  /**
+   * Hidden ctor to ensure that this utility class isn't
+   * instantiated explicitly.
+   */
+  private ProviderUtils() {
+    // hide ctor for checkstyle compliance
+  }
+
-    String[] parts = nestedUri.getAuthority().split("@", 2);
-    StringBuilder result = new StringBuilder(parts[0]);
-    result.append("://");
-    if (parts.length == 2) {
-      result.append(parts[1]);
+    StringBuilder result = new StringBuilder();
+    String authority = nestedUri.getAuthority();
+    if (authority != null) {
+      String[] parts = nestedUri.getAuthority().split("@", 2);
+      result.append(parts[0]);
+      result.append("://");
+      if (parts.length == 2) {
+        result.append(parts[1]);
+      }
+  /**
+   * There are certain integrations of the credential provider API in
+   * which a recursive dependency between the provider and the hadoop
+   * filesystem abstraction causes a problem. These integration points
+   * need to leverage this utility method to remove problematic provider
+   * types from the existing provider path within the configuration.
+   *
+   * @param config the existing configuration with provider path
+   * @param fileSystemClass the class which providers must be compatible
+   * @return Configuration clone with new provider path
+   */
+  public static Configuration excludeIncompatibleCredentialProviders(
+      Configuration config, Class<? extends FileSystem> fileSystemClass)
+          throws IOException {
+
+    String providerPath = config.get(
+        CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH);
+
+    if (providerPath == null) {
+      return config;
+    }
+    StringBuffer newProviderPath = new StringBuffer();
+    String[] providers = providerPath.split(",");
+    Path path = null;
+    for (String provider: providers) {
+      try {
+        path = unnestUri(new URI(provider));
+        Class<? extends FileSystem> clazz = null;
+        try {
+          String scheme = path.toUri().getScheme();
+          clazz = FileSystem.getFileSystemClass(scheme, config);
+        } catch (IOException ioe) {
+          // not all providers are filesystem based
+          // for instance user:/// will not be able to
+          // have a filesystem class associated with it.
+          if (newProviderPath.length() > 0) {
+            newProviderPath.append(",");
+          }
+          newProviderPath.append(provider);
+        }
+        if (clazz != null) {
+          if (fileSystemClass.isAssignableFrom(clazz)) {
+            LOG.debug("Filesystem based provider" +
+                " excluded from provider path due to recursive dependency: "
+                + provider);
+          } else {
+            if (newProviderPath.length() > 0) {
+              newProviderPath.append(",");
+            }
+            newProviderPath.append(provider);
+          }
+        }
+      } catch (URISyntaxException e) {
+        LOG.warn("Credential Provider URI is invalid." + provider);
+      }
+    }
+
+    String effectivePath = newProviderPath.toString();
+    if (effectivePath.equals(providerPath)) {
+      return config;
+    }
+
+    Configuration conf = new Configuration(config);
+    if (effectivePath.equals("")) {
+      conf.unset(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH);
+    } else {
+      conf.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH,
+          effectivePath);
+    }
+    return conf;
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS29 INS83 INS23 INS31 INS31 INS65 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS42 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS66 INS42 INS42 INS32 INS65 INS60 INS25 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS74 INS42 INS42 INS60 INS25 INS60 INS60 INS60 INS70 INS60 INS25 INS60 INS25 INS41 INS42 INS42 INS57 INS66 INS66 MOV43 INS43 INS59 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS43 INS76 INS43 INS59 INS27 INS8 INS43 INS59 INS5 INS59 INS43 INS59 INS44 INS42 INS8 INS43 INS59 INS32 INS8 INS43 INS59 INS32 INS8 INS8 INS42 INS43 INS42 INS42 INS32 INS42 INS33 MOV60 INS21 MOV21 MOV25 INS42 INS43 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS14 INS43 INS85 INS42 INS32 INS42 INS42 INS33 INS43 INS42 INS54 INS42 INS42 INS32 INS42 INS42 INS42 INS41 INS42 INS42 INS14 INS42 INS42 INS45 INS21 INS21 INS42 MOV43 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS42 INS43 INS42 INS42 INS42 INS45 INS42 INS8 INS12 INS42 INS42 INS42 INS43 INS42 INS32 INS32 INS42 INS42 MOV2 INS42 INS21 INS60 INS54 INS25 INS44 INS8 INS42 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS7 INS74 INS59 INS8 INS12 INS27 INS8 INS43 INS42 INS21 INS42 INS32 INS43 INS76 INS42 INS33 INS60 INS21 INS44 INS8 INS42 INS33 INS25 INS42 INS32 INS42 INS14 INS42 INS43 INS43 INS59 INS7 INS43 INS42 INS25 INS21 INS32 INS8 INS8 INS42 INS42 INS27 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS27 INS8 INS32 INS42 INS42 INS42 INS21 INS25 INS21 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS21 INS42 INS42 INS42 INS32 INS27 INS8 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS32 INS34 INS21 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS45
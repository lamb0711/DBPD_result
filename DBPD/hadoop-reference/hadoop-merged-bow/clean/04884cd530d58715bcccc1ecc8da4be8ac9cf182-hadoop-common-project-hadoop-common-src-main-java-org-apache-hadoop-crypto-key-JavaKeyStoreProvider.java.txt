Merging r1616894 through r1617376 from trunk.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-6584@1617377 13f79535-47bb-0310-9956-ffa450edef68

+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+  private static Logger LOG =
+      LoggerFactory.getLogger(JavaKeyStoreProvider.class);
+
+        if (pwdFile == null) {
+          // Provided Password file does not exist
+          throw new IOException("Password file does not exists");
+        }
+      Path oldPath = constructOldPath(path);
+      Path newPath = constructNewPath(path);
+      FsPermission perm = null;
-        // save off permissions in case we need to
-        // rewrite the keystore in flush()
-        FileStatus s = fs.getFileStatus(path);
-        permissions = s.getPermission();
-
-        keyStore.load(fs.open(path), password);
+        // flush did not proceed to completion
+        // _NEW should not exist
+        if (fs.exists(newPath)) {
+          throw new IOException(
+              String.format("Keystore not loaded due to some inconsistency "
+              + "('%s' and '%s' should not exist together)!!", path, newPath));
+        }
+        perm = tryLoadFromPath(path, oldPath);
-        permissions = new FsPermission("700");
-        // required to create an empty keystore. *sigh*
-        keyStore.load(null, password);
+        perm = tryLoadIncompleteFlush(oldPath, newPath);
+      // Need to save off permissions in case we need to
+      // rewrite the keystore in flush()
+      permissions = perm;
+  /**
+   * Try loading from the user specified path, else load from the backup
+   * path in case Exception is not due to bad/wrong password
+   * @param path Actual path to load from
+   * @param backupPath Backup path (_OLD)
+   * @return The permissions of the loaded file
+   * @throws NoSuchAlgorithmException
+   * @throws CertificateException
+   * @throws IOException
+   */
+  private FsPermission tryLoadFromPath(Path path, Path backupPath)
+      throws NoSuchAlgorithmException, CertificateException,
+      IOException {
+    FsPermission perm = null;
+    try {
+      perm = loadFromPath(path, password);
+      // Remove _OLD if exists
+      if (fs.exists(backupPath)) {
+        fs.delete(backupPath, true);
+      }
+      LOG.debug("KeyStore loaded successfully !!");
+    } catch (IOException ioe) {
+      // If file is corrupted for some reason other than
+      // wrong password try the _OLD file if exits
+      if (!isBadorWrongPassword(ioe)) {
+        perm = loadFromPath(backupPath, password);
+        // Rename CURRENT to CORRUPTED
+        renameOrFail(path, new Path(path.toString() + "_CORRUPTED_"
+            + System.currentTimeMillis()));
+        renameOrFail(backupPath, path);
+        LOG.debug(String.format(
+            "KeyStore loaded successfully from '%s' since '%s'"
+                + "was corrupted !!", backupPath, path));
+      } else {
+        throw ioe;
+      }
+    }
+    return perm;
+  }
+
+  /**
+   * The KeyStore might have gone down during a flush, In which case either the
+   * _NEW or _OLD files might exists. This method tries to load the KeyStore
+   * from one of these intermediate files.
+   * @param oldPath the _OLD file created during flush
+   * @param newPath the _NEW file created during flush
+   * @return The permissions of the loaded file
+   * @throws IOException
+   * @throws NoSuchAlgorithmException
+   * @throws CertificateException
+   */
+  private FsPermission tryLoadIncompleteFlush(Path oldPath, Path newPath)
+      throws IOException, NoSuchAlgorithmException, CertificateException {
+    FsPermission perm = null;
+    // Check if _NEW exists (in case flush had finished writing but not
+    // completed the re-naming)
+    if (fs.exists(newPath)) {
+      perm = loadAndReturnPerm(newPath, oldPath);
+    }
+    // try loading from _OLD (An earlier Flushing MIGHT not have completed
+    // writing completely)
+    if ((perm == null) && fs.exists(oldPath)) {
+      perm = loadAndReturnPerm(oldPath, newPath);
+    }
+    // If not loaded yet,
+    // required to create an empty keystore. *sigh*
+    if (perm == null) {
+      keyStore.load(null, password);
+      LOG.debug("KeyStore initialized anew successfully !!");
+      perm = new FsPermission("700");
+    }
+    return perm;
+  }
+
+  private FsPermission loadAndReturnPerm(Path pathToLoad, Path pathToDelete)
+      throws NoSuchAlgorithmException, CertificateException,
+      IOException {
+    FsPermission perm = null;
+    try {
+      perm = loadFromPath(pathToLoad, password);
+      renameOrFail(pathToLoad, path);
+      LOG.debug(String.format("KeyStore loaded successfully from '%s'!!",
+          pathToLoad));
+      if (fs.exists(pathToDelete)) {
+        fs.delete(pathToDelete, true);
+      }
+    } catch (IOException e) {
+      // Check for password issue : don't want to trash file due
+      // to wrong password
+      if (isBadorWrongPassword(e)) {
+        throw e;
+      }
+    }
+    return perm;
+  }
+
+  private boolean isBadorWrongPassword(IOException ioe) {
+    // As per documentation this is supposed to be the way to figure
+    // if password was correct
+    if (ioe.getCause() instanceof UnrecoverableKeyException) {
+      return true;
+    }
+    // Unfortunately that doesn't seem to work..
+    // Workaround :
+    if ((ioe.getCause() == null)
+        && (ioe.getMessage() != null)
+        && ((ioe.getMessage().contains("Keystore was tampered")) || (ioe
+            .getMessage().contains("password was incorrect")))) {
+      return true;
+    }
+    return false;
+  }
+
+  private FsPermission loadFromPath(Path p, char[] password)
+      throws IOException, NoSuchAlgorithmException, CertificateException {
+    FileStatus s = fs.getFileStatus(p);
+    keyStore.load(fs.open(p), password);
+    return s.getPermission();
+  }
+
+  private Path constructNewPath(Path path) {
+    Path newPath = new Path(path.toString() + "_NEW");
+    return newPath;
+  }
+
+  private Path constructOldPath(Path path) {
+    Path oldPath = new Path(path.toString() + "_OLD");
+    return oldPath;
+  }
+
+    Path newPath = constructNewPath(path);
+    Path oldPath = constructOldPath(path);
+      // Might exist if a backup has been restored etc.
+      if (fs.exists(newPath)) {
+        renameOrFail(newPath, new Path(newPath.toString()
+            + "_ORPHANED_" + System.currentTimeMillis()));
+      }
+      if (fs.exists(oldPath)) {
+        renameOrFail(oldPath, new Path(oldPath.toString()
+            + "_ORPHANED_" + System.currentTimeMillis()));
+      }
+
+      // Save old File first
+      boolean fileExisted = backupToOld(oldPath);
-      FSDataOutputStream out = FileSystem.create(fs, path, permissions);
+      // Write to _NEW path first :
-        keyStore.store(out, password);
-      } catch (KeyStoreException e) {
-        throw new IOException("Can't store keystore " + this, e);
-      } catch (NoSuchAlgorithmException e) {
-        throw new IOException("No such algorithm storing keystore " + this, e);
-      } catch (CertificateException e) {
-        throw new IOException("Certificate exception storing keystore " + this,
-            e);
+        writeToNew(newPath);
+      } catch (IOException ioe) {
+        // rename _OLD back to curent and throw Exception
+        revertFromOld(oldPath, fileExisted);
+        throw ioe;
-      out.close();
+      // Rename _NEW to CURRENT and delete _OLD
+      cleanupNewAndOld(newPath, oldPath);
+  private void cleanupNewAndOld(Path newPath, Path oldPath) throws IOException {
+    // Rename _NEW to CURRENT
+    renameOrFail(newPath, path);
+    // Delete _OLD
+    if (fs.exists(oldPath)) {
+      fs.delete(oldPath, true);
+    }
+  }
+
+  private void writeToNew(Path newPath) throws IOException {
+    FSDataOutputStream out =
+        FileSystem.create(fs, newPath, permissions);
+    try {
+      keyStore.store(out, password);
+    } catch (KeyStoreException e) {
+      throw new IOException("Can't store keystore " + this, e);
+    } catch (NoSuchAlgorithmException e) {
+      throw new IOException(
+          "No such algorithm storing keystore " + this, e);
+    } catch (CertificateException e) {
+      throw new IOException(
+          "Certificate exception storing keystore " + this, e);
+    }
+    out.close();
+  }
+
+  private void revertFromOld(Path oldPath, boolean fileExisted)
+      throws IOException {
+    if (fileExisted) {
+      renameOrFail(oldPath, path);
+    }
+  }
+
+  private boolean backupToOld(Path oldPath)
+      throws IOException {
+    boolean fileExisted = false;
+    if (fs.exists(path)) {
+      renameOrFail(path, oldPath);
+      fileExisted = true;
+    }
+    return fileExisted;
+  }
+
+  private void renameOrFail(Path src, Path dest)
+      throws IOException {
+    if (!fs.rename(src, dest)) {
+      throw new IOException("Rename unsuccessful : "
+          + String.format("'%s' to '%s'", src, dest));
+    }
+  }
+

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS43 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS43 INS43 INS8 INS83 INS43 INS42 INS44 INS44 INS43 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS43 INS43 INS43 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS8 MOV78 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 UPD83 INS42 INS44 MOV8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS42 INS42 INS32 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS60 INS25 INS25 INS25 INS41 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS60 INS54 INS41 INS43 INS42 INS25 INS25 INS41 INS42 INS43 INS42 INS5 INS42 INS42 INS42 INS42 INS60 INS21 INS41 INS42 INS43 INS42 INS60 INS41 INS42 INS43 INS42 INS60 INS41 INS42 INS60 INS60 MOV21 MOV54 INS43 INS42 INS43 INS42 INS42 INS21 INS25 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS25 INS43 INS42 INS42 INS60 INS25 INS41 INS43 INS42 INS43 INS42 INS42 INS25 INS42 INS42 INS57 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS8 INS12 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS27 INS8 INS27 MOV8 MOV21 INS42 INS42 INS42 INS43 INS59 INS8 INS12 INS42 INS42 INS62 INS8 INS27 INS8 INS9 INS42 INS39 INS85 MOV43 INS59 INS32 MOV32 INS42 INS43 INS59 INS42 INS42 INS43 INS59 INS42 INS43 INS59 INS43 INS59 INS8 INS42 INS42 INS32 INS32 INS8 INS42 INS42 INS42 INS8 INS42 INS39 INS59 INS32 INS8 INS42 INS42 INS42 INS38 INS8 INS43 INS60 INS60 INS60 INS21 INS42 INS42 INS33 INS21 INS25 INS21 INS44 INS8 INS42 INS42 INS33 INS42 INS42 INS42 INS21 INS36 INS32 INS21 INS42 INS33 INS21 INS42 INS42 INS33 INS21 INS21 INS21 INS25 INS44 INS8 INS32 INS43 INS41 INS36 INS36 INS36 INS41 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 MOV25 INS25 INS25 MOV70 INS60 INS54 INS21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS9 INS42 INS42 INS42 INS21 INS21 INS32 INS53 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS8 INS8 INS7 INS7 INS32 INS8 INS32 INS43 INS42 INS25 INS7 INS27 INS42 INS42 INS42 INS7 INS32 INS7 INS32 INS32 INS32 INS8 INS43 INS42 INS25 INS42 INS42 INS42 INS9 INS27 INS27 INS27 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS43 INS27 INS42 INS42 INS42 INS42 INS32 INS8 INS32 INS8 INS39 INS59 INS8 INS12 INS32 INS32 UPD42 INS32 INS32 INS7 INS42 INS42 INS42 INS42 INS14 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS33 INS25 MOV21 MOV21 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS42 INS42 INS45 INS42 INS38 INS8 INS8 INS42 INS32 INS42 INS33 INS42 INS32 INS42 INS42 INS45 UPD42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS42 INS32 INS8 INS32 INS33 INS32 INS33 INS36 INS36 INS42 INS32 INS45 INS42 INS32 INS45 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS21 INS42 INS32 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS43 INS27 INS27 INS8 INS42 INS42 INS42 INS42 INS32 INS8 INS7 INS42 INS42 INS42 INS32 INS32 INS21 INS21 INS21 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS32 INS42 INS42 INS53 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS43 INS42 INS21 INS53 INS42 INS45 INS32 INS42 INS33 INS53 INS42 INS42 INS42 INS53 UPD42 INS32 INS42 INS32 INS42 INS42 INS42 INS9 INS42 INS42 INS7 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS9 INS42 INS32 INS42 INS45 INS32 INS42 INS45 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS14 INS14 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS27 INS43 INS27 INS42 INS42 INS42 INS43 INS45 INS43 INS32 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS45 INS32 INS42 INS32 INS45 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS27 MOV42 INS42 INS42 INS32 INS45 INS32 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL8
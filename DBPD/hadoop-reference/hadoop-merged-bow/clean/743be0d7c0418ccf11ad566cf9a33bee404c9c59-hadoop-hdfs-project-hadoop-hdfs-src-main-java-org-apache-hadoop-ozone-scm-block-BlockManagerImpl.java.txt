HDFS-12235. Ozone: DeleteKey-3: KSM SCM block deletion message and ACK interactions. Contributed by Weiwei Yang and Yuanbo Liu.

+import java.util.HashMap;
-          throw new SCMException("Fail to find any container to allocate block " +
-              "of size " + size + ".", FAILED_TO_FIND_CONTAINER_WITH_SAPCE);
+          throw new SCMException("Fail to find any container to allocate block "
+              + "of size " + size + ".", FAILED_TO_FIND_CONTAINER_WITH_SAPCE);
-   * Given a block key, delete a block.
-   * @param key - block key assigned by SCM.
-   * @throws IOException
+   * Deletes a list of blocks in an atomic operation. Internally, SCM
+   * writes these blocks into a {@link DeletedBlockLog} and deletes them
+   * from SCM DB. If this is successful, given blocks are entering pending
+   * deletion state and becomes invisible from SCM namespace.
+   *
+   * @param blockIDs block IDs. This is often the list of blocks of
+   *                 a particular object key.
+   * @throws IOException if exception happens, non of the blocks is deleted.
-  public void deleteBlock(final String key) throws IOException {
+  public void deleteBlocks(List<String> blockIDs) throws IOException {
+    LOG.info("Deleting blocks {}", String.join(",", blockIDs));
+    Map<String, List<String>> containerBlocks = new HashMap<>();
+    BatchOperation batch = new BatchOperation();
+    BatchOperation rollbackBatch = new BatchOperation();
+    // TODO: track the block size info so that we can reclaim the container
+    // TODO: used space when the block is deleted.
-      byte[] containerBytes = blockStore.get(DFSUtil.string2Bytes(key));
-      if (containerBytes == null) {
-        throw new SCMException("Specified block key does not exist. key : " +
-            key, FAILED_TO_FIND_BLOCK);
+      for (String blockKey : blockIDs) {
+        byte[] blockKeyBytes = DFSUtil.string2Bytes(blockKey);
+        byte[] containerBytes = blockStore.get(blockKeyBytes);
+        if (containerBytes == null) {
+          throw new SCMException(
+              "Specified block key does not exist. key : " + blockKey,
+              FAILED_TO_FIND_BLOCK);
+        }
+        batch.delete(blockKeyBytes);
+        rollbackBatch.put(blockKeyBytes, containerBytes);
+
+        // Merge blocks to a container to blocks mapping,
+        // prepare to persist this info to the deletedBlocksLog.
+        String containerName = DFSUtil.bytes2String(containerBytes);
+        if (containerBlocks.containsKey(containerName)) {
+          containerBlocks.get(containerName).add(blockKey);
+        } else {
+          List<String> item = new ArrayList<>();
+          item.add(blockKey);
+          containerBlocks.put(containerName, item);
+        }
-      // TODO: track the block size info so that we can reclaim the container
-      // TODO: used space when the block is deleted.
-      BatchOperation batch = new BatchOperation();
-      String deletedKeyName = getDeletedKeyName(key);
-      // Add a tombstone for the deleted key
-      batch.put(DFSUtil.string2Bytes(deletedKeyName), containerBytes);
-      // Delete the block key
-      batch.delete(DFSUtil.string2Bytes(key));
+
+      // We update SCM DB first, so if this step fails, we end up here,
+      // nothing gets into the delLog so no blocks will be accidentally
+      // removed. If we write the log first, once log is written, the
+      // async deleting service will start to scan and might be picking
+      // up some blocks to do real deletions, that might cause data loss.
-      // TODO: Add async tombstone clean thread to send delete command to
-      // datanodes in the pipeline to clean up the blocks from containers.
+      try {
+        deletedBlockLog.addTransactions(containerBlocks);
+      } catch (IOException e) {
+        try {
+          // If delLog update is failed, we need to rollback the changes.
+          blockStore.writeBatch(rollbackBatch);
+        } catch (IOException rollbackException) {
+          // This is a corner case. AddTX fails and rollback also fails,
+          // this will leave these blocks in inconsistent state. They were
+          // moved to pending deletion state in SCM DB but were not written
+          // into delLog so real deletions would not be done. Blocks become
+          // to be invisible from namespace but actual data are not removed.
+          // We log an error here so admin can manually check and fix such
+          // errors.
+          LOG.error("Blocks might be in inconsistent state because"
+                  + " they were moved to pending deletion state in SCM DB but"
+                  + " not written into delLog. Admin can manually add them"
+                  + " into delLog for deletions. Inconsistent block list: {}",
+              String.join(",", blockIDs), e);
+          throw rollbackException;
+        }
+        throw new IOException("Skip writing the deleted blocks info to"
+            + " the delLog because addTransaction fails. Batch skipped: "
+            + String.join(",", blockIDs), e);
+      }

INS26 INS40 UPD42 INS74 INS42 INS21 INS60 MOV60 INS60 UPD66 INS66 INS65 INS66 INS66 INS66 UPD42 UPD66 INS66 INS66 INS43 MOV43 INS32 INS74 INS59 INS43 INS59 INS42 INS42 INS42 INS42 INS45 INS32 INS43 INS43 INS74 INS42 INS14 INS42 INS42 INS14 INS70 INS54 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS43 INS74 INS43 INS44 INS42 INS8 INS8 INS12 INS42 INS42 INS43 INS42 MOV43 INS42 INS60 MOV60 MOV25 INS21 INS21 MOV60 INS25 INS21 INS44 INS8 INS42 MOV5 INS59 INS5 INS32 INS32 INS43 INS32 INS8 INS8 INS32 INS43 INS42 INS54 INS53 INS42 INS32 INS39 INS85 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS21 INS60 INS21 INS21 INS42 INS42 UPD42 MOV42 INS42 INS8 INS12 INS14 INS42 INS42 INS42 UPD42 MOV42 UPD42 UPD42 INS42 INS32 INS74 INS59 INS32 INS32 INS21 INS44 INS8 INS43 INS27 INS42 INS32 INS42 UPD42 MOV42 INS43 INS43 INS42 INS14 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS43 INS42 MOV21 INS53 INS42 INS45 INS45 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS43 UPD42 UPD42 INS27 INS42 INS42 INS45 INS45 INS45 INS45 UPD42 UPD42 INS45 UPD42 DEL83 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21
HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.

-import java.util.LinkedList;
-
-import org.apache.hadoop.util.LightWeightGSet;
- * BlockInfo class maintains for a given block
- * the {@link BlockCollection} it is part of and datanodes where the replicas of 
- * the block are stored.
+ * Subclass of {@link BlockInfo}, used for a block with replication scheme.
-public class BlockInfoContiguous extends Block
-    implements LightWeightGSet.LinkedElement {
+public class BlockInfoContiguous extends BlockInfo {
-  private BlockCollection bc;
-
-  /** For implementing {@link LightWeightGSet.LinkedElement} interface */
-  private LightWeightGSet.LinkedElement nextLinkedElement;
-
-  /**
-   * This array contains triplets of references. For each i-th storage, the
-   * block belongs to triplets[3*i] is the reference to the
-   * {@link DatanodeStorageInfo} and triplets[3*i+1] and triplets[3*i+2] are
-   * references to the previous and the next blocks, respectively, in the list
-   * of blocks belonging to this storage.
-   * 
-   * Using previous and next in Object triplets is done instead of a
-   * {@link LinkedList} list to efficiently use memory. With LinkedList the cost
-   * per replica is 42 bytes (LinkedList#Entry object per replica) versus 16
-   * bytes using the triplets.
-   */
-  private Object[] triplets;
-
-  /**
-   * Construct an entry for blocksmap
-   * @param replication the block's replication factor
-   */
-  public BlockInfoContiguous(short replication) {
-    this.triplets = new Object[3*replication];
-    this.bc = null;
+  public BlockInfoContiguous(short size) {
+    super(size);
-  
-  public BlockInfoContiguous(Block blk, short replication) {
-    super(blk);
-    this.triplets = new Object[3*replication];
-    this.bc = null;
+
+  public BlockInfoContiguous(Block blk, short size) {
+    super(blk, size);
-   * This is used to convert BlockInfoUnderConstruction
-   * @param from BlockInfo to copy from.
+   * This is used to convert BlockReplicationInfoUnderConstruction
+   * @param from BlockReplicationInfo to copy from.
-    super(from);
+    this(from, from.getBlockCollection().getBlockReplication());
-    this.bc = from.bc;
+    this.setBlockCollection(from.getBlockCollection());
-    if(triplets.length >= (last+num)*3)
+    if (triplets.length >= (last+num)*3) {
-    /* Not enough space left. Create a new array. Should normally 
+    }
+    /* Not enough space left. Create a new array. Should normally
-  /**
-   * Count the number of data-nodes the block belongs to.
-   */
-  public int numNodes() {
-    assert this.triplets != null : "BlockInfo is not initialized";
-    assert triplets.length % 3 == 0 : "Malformed BlockInfo";
-    for(int idx = getCapacity()-1; idx >= 0; idx--) {
-      if(getDatanode(idx) != null)
-        return idx+1;
-    }
-    return 0;
-  }
-
-  /**
-   * Add a {@link DatanodeStorageInfo} location for a block
-   */
-  boolean addStorage(DatanodeStorageInfo storage) {
+  @Override
+  boolean addStorage(DatanodeStorageInfo storage, Block reportedBlock) {
-  /**
-   * Remove {@link DatanodeStorageInfo} location for a block
-   */
+  @Override
-    if(dnIndex < 0) // the node is not found
+    if (dnIndex < 0) { // the node is not found
-    assert getPrevious(dnIndex) == null && getNext(dnIndex) == null : 
-      "Block is still in the list and must be removed first.";
+    }
+    assert getPrevious(dnIndex) == null && getNext(dnIndex) == null :
+        "Block is still in the list and must be removed first.";
-    int lastNode = numNodes()-1; 
-    // replace current node triplet by the lastNode one 
+    int lastNode = numNodes()-1;
+    // replace current node triplet by the lastNode one
-    setNext(dnIndex, getNext(lastNode)); 
-    setPrevious(dnIndex, getPrevious(lastNode)); 
+    setNext(dnIndex, getNext(lastNode));
+    setPrevious(dnIndex, getPrevious(lastNode));
-    setNext(lastNode, null); 
-    setPrevious(lastNode, null); 
+    setNext(lastNode, null);
+    setPrevious(lastNode, null);
-  /**
-   * Find specified DatanodeStorageInfo.
-   * @return DatanodeStorageInfo or null if not found.
-   */
-  DatanodeStorageInfo findStorageInfo(DatanodeDescriptor dn) {
-    int len = getCapacity();
-    for(int idx = 0; idx < len; idx++) {
-      DatanodeStorageInfo cur = getStorageInfo(idx);
-      if(cur == null)
-        break;
-      if(cur.getDatanodeDescriptor() == dn)
-        return cur;
-    }
-    return null;
-  }
-  
-  /**
-   * Find specified DatanodeStorageInfo.
-   * @return index or -1 if not found.
-   */
-  int findStorageInfo(DatanodeStorageInfo storageInfo) {
-    int len = getCapacity();
-    for(int idx = 0; idx < len; idx++) {
-      DatanodeStorageInfo cur = getStorageInfo(idx);
-      if (cur == storageInfo) {
-        return idx;
-      }
-      if (cur == null) {
-        break;
+  @Override
+  public int numNodes() {
+    assert this.triplets != null : "BlockInfo is not initialized";
+    assert triplets.length % 3 == 0 : "Malformed BlockInfo";
+
+    for (int idx = getCapacity()-1; idx >= 0; idx--) {
+      if (getDatanode(idx) != null) {
+        return idx + 1;
-    return -1;
+    return 0;
-  /**
-   * Insert this block into the head of the list of blocks 
-   * related to the specified DatanodeStorageInfo.
-   * If the head is null then form a new list.
-   * @return current block as the new head of the list.
-   */
-  BlockInfoContiguous listInsert(BlockInfoContiguous head,
-      DatanodeStorageInfo storage) {
-    int dnIndex = this.findStorageInfo(storage);
-    assert dnIndex >= 0 : "Data node is not found: current";
-    assert getPrevious(dnIndex) == null && getNext(dnIndex) == null : 
-            "Block is already in the list and cannot be inserted.";
-    this.setPrevious(dnIndex, null);
-    this.setNext(dnIndex, head);
-    if(head != null)
-      head.setPrevious(head.findStorageInfo(storage), this);
-    return this;
-  }
+  @Override
+  void replaceBlock(BlockInfo newBlock) {
+    assert newBlock instanceof BlockInfoContiguous;
+    for (int i = this.numNodes() - 1; i >= 0; i--) {
+      final DatanodeStorageInfo storage = this.getStorageInfo(i);
+      final boolean removed = storage.removeBlock(this);
+      assert removed : "currentBlock not found.";
-  /**
-   * Remove this block from the list of blocks 
-   * related to the specified DatanodeStorageInfo.
-   * If this block is the head of the list then return the next block as 
-   * the new head.
-   * @return the new head of the list or null if the list becomes
-   * empy after deletion.
-   */
-  BlockInfoContiguous listRemove(BlockInfoContiguous head,
-      DatanodeStorageInfo storage) {
-    if(head == null)
-      return null;
-    int dnIndex = this.findStorageInfo(storage);
-    if(dnIndex < 0) // this block is not on the data-node list
-      return head;
-
-    BlockInfoContiguous next = this.getNext(dnIndex);
-    BlockInfoContiguous prev = this.getPrevious(dnIndex);
-    this.setNext(dnIndex, null);
-    this.setPrevious(dnIndex, null);
-    if(prev != null)
-      prev.setNext(prev.findStorageInfo(storage), next);
-    if(next != null)
-      next.setPrevious(next.findStorageInfo(storage), prev);
-    if(this == head)  // removing the head
-      head = next;
-    return head;
-  }
-
-  /**
-   * Remove this block from the list of blocks related to the specified
-   * DatanodeDescriptor. Insert it into the head of the list of blocks.
-   *
-   * @return the new head of the list.
-   */
-  public BlockInfoContiguous moveBlockToHead(BlockInfoContiguous head,
-      DatanodeStorageInfo storage, int curIndex, int headIndex) {
-    if (head == this) {
-      return this;
+      final DatanodeStorageInfo.AddBlockResult result = storage.addBlock(
+          newBlock, newBlock);
+      assert result == DatanodeStorageInfo.AddBlockResult.ADDED :
+          "newBlock already exists.";
-    BlockInfoContiguous next = this.setNext(curIndex, head);
-    BlockInfoContiguous prev = this.setPrevious(curIndex, null);
-
-    head.setPrevious(headIndex, this);
-    prev.setNext(prev.findStorageInfo(storage), next);
-    if (next != null) {
-      next.setPrevious(next.findStorageInfo(storage), prev);
-    }
-    return this;
-  }
-
-  /**
-   * BlockInfo represents a block that is not being constructed.
-   * In order to start modifying the block, the BlockInfo should be converted
-   * to {@link BlockInfoContiguousUnderConstruction}.
-   * @return {@link BlockUCState#COMPLETE}
-   */
-  public BlockUCState getBlockUCState() {
-    return BlockUCState.COMPLETE;
-  }
-
-  /**
-   * Is this block complete?
-   * 
-   * @return true if the state of the block is {@link BlockUCState#COMPLETE}
-   */
-  public boolean isComplete() {
-    return getBlockUCState().equals(BlockUCState.COMPLETE);
-        (BlockInfoContiguousUnderConstruction)this;
+        (BlockInfoContiguousUnderConstruction) this;
-
-  @Override
-  public int hashCode() {
-    // Super implementation is sufficient
-    return super.hashCode();
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    // Sufficient to rely on super's implementation
-    return (this == obj) || super.equals(obj);
-  }
-
-  @Override
-  public LightWeightGSet.LinkedElement getNext() {
-    return nextLinkedElement;
-  }
-
-  @Override
-  public void setNext(LightWeightGSet.LinkedElement next) {
-    this.nextLinkedElement = next;
-  }

MOV31 INS43 INS31 UPD42 MOV42 MOV78 INS44 MOV78 MOV78 MOV78 INS39 INS42 MOV44 INS8 UPD66 UPD66 UPD42 INS46 UPD42 INS17 MOV43 INS42 UPD43 UPD42 INS6 INS24 UPD42 INS42 INS42 UPD66 UPD66 INS42 INS32 INS32 INS8 INS8 UPD42 INS62 MOV58 UPD27 MOV27 UPD37 MOV37 INS8 INS32 INS42 INS52 INS42 INS32 MOV41 MOV41 INS42 MOV43 UPD42 INS34 UPD42 MOV60 MOV60 MOV6 INS60 INS6 INS42 INS42 INS42 INS42 INS8 UPD42 INS27 INS83 MOV43 INS83 UPD39 INS42 UPD45 INS83 INS43 INS59 INS27 INS45 MOV41 INS32 INS34 UPD42 UPD42 INS40 UPD42 MOV42 INS32 UPD42 MOV42 INS40 INS52 INS42 INS52 UPD42 UPD42 UPD42 INS52 MOV42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL40 DEL43 DEL83 DEL43 DEL42 DEL59 DEL23 DEL66 DEL40 DEL65 DEL66 DEL65 DEL29 DEL83 DEL40 DEL43 DEL42 DEL59 DEL23 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL23 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL52 DEL42 DEL22 DEL42 DEL43 DEL85 DEL5 DEL34 DEL42 DEL27 DEL3 DEL7 DEL21 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL85 DEL5 DEL34 DEL42 DEL27 DEL3 DEL7 DEL21 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL42 DEL46 DEL52 DEL42 DEL22 DEL40 DEL7 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL66 DEL65 DEL29 DEL34 DEL42 DEL42 DEL43 DEL52 DEL42 DEL34 DEL27 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL10 DEL25 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL41 DEL25 DEL8 DEL24 DEL33 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL39 DEL42 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL10 DEL8 DEL25 DEL8 DEL24 DEL34 DEL38 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL45 DEL6 DEL52 DEL42 DEL42 DEL33 DEL32 DEL21 DEL52 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL52 DEL32 DEL21 DEL25 DEL52 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL33 DEL41 DEL25 DEL39 DEL42 DEL52 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL41 DEL25 DEL42 DEL43 DEL42 DEL52 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL52 DEL42 DEL42 DEL32 DEL59 DEL60 DEL52 DEL42 DEL42 DEL33 DEL32 DEL21 DEL52 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL25 DEL52 DEL42 DEL27 DEL42 DEL42 DEL7 DEL21 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL52 DEL27 DEL52 DEL41 DEL8 DEL25 DEL42 DEL43 DEL52 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL52 DEL42 DEL42 DEL33 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL52 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL42 DEL65 DEL66 DEL65 DEL66 DEL42 DEL42 DEL67 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL40 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL42 DEL42 DEL67 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL48 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL27 DEL36 DEL42 DEL42 DEL48 DEL27 DEL41 DEL8 DEL31 DEL83 DEL40 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL40 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31
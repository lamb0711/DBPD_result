HADOOP-14768. Honoring sticky bit during Deletion when authorization is enabled in WASB
Contributed by Varada Hemeswari

+import java.util.Stack;
+import java.util.HashMap;
+import static org.apache.hadoop.fs.azure.NativeAzureFileSystemHelper.*;
+
-   * Delete the specified file or folder. The parameter
-   * skipParentFolderLastModifiedTimeUpdate
-   * is used in the case of atomic folder rename redo. In that case, there is
-   * a lease on the parent folder, so (without reworking the code) modifying
-   * the parent folder update time will fail because of a conflict with the
-   * lease. Since we are going to delete the folder soon anyway so accurate
-   * modified time is not necessary, it's easier to just skip
-   * the modified time update.
-   *
-   * @param f file path to be deleted.
-   * @param recursive specify deleting recursively or not.
-   * @param skipParentFolderLastModifiedTimeUpdate If true, don't update the folder last
-   * modified time.
-   * @return true if and only if the file is deleted
-   * @throws IOException Thrown when fail to delete file or directory.
+   * Delete file or folder with authorization checks. Most of the code
+   * is duplicate of the actual delete implementation and will be merged
+   * once the performance and funcional aspects are guaranteed not to
+   * regress existing delete semantics.
-  public boolean delete(Path f, boolean recursive,
+  private boolean deleteWithAuthEnabled(Path f, boolean recursive,
-    LOG.debug("Deleting file: {}", f.toString());
+    LOG.debug("Deleting file: {}", f);
-    performAuthCheck(parentPath, WasbAuthorizationOperations.WRITE, "delete", absolutePath);
+    // If delete is issued for 'root', parentPath will be null
+    // In that case, we perform auth check for root itself before
+    // proceeding for deleting contents under root.
+    if (parentPath != null) {
+      performAuthCheck(parentPath, WasbAuthorizationOperations.WRITE, "delete", absolutePath);
+    } else {
+      performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, "delete", absolutePath);
+    }
+
+    String key = pathToKey(absolutePath);
+
+    // Capture the metadata for the path.
+    FileMetadata metaFile = null;
+    try {
+      metaFile = store.retrieveMetadata(key);
+    } catch (IOException e) {
+
+      Throwable innerException = checkForAzureStorageException(e);
+
+      if (innerException instanceof StorageException
+          && isFileNotFoundException((StorageException) innerException)) {
+
+        return false;
+      }
+      throw e;
+    }
+
+    if (null == metaFile) {
+      // The path to be deleted does not exist.
+      return false;
+    }
+
+    FileMetadata parentMetadata = null;
+    String parentKey = null;
+    if (parentPath != null) {
+      parentKey = pathToKey(parentPath);
+
+      try {
+        parentMetadata = store.retrieveMetadata(parentKey);
+      } catch (IOException e) {
+         Throwable innerException = checkForAzureStorageException(e);
+         if (innerException instanceof StorageException) {
+           // Invalid State.
+           // A FileNotFoundException is not thrown here as the API returns false
+           // if the file not present. But not retrieving metadata here is an
+           // unrecoverable state and can only happen if there is a race condition
+           // hence throwing a IOException
+           if (isFileNotFoundException((StorageException) innerException)) {
+             throw new IOException("File " + f + " has a parent directory "
+               + parentPath + " whose metadata cannot be retrieved. Can't resolve");
+           }
+         }
+         throw e;
+      }
+
+      // Same case as unable to retrieve metadata
+      if (parentMetadata == null) {
+          throw new IOException("File " + f + " has a parent directory "
+              + parentPath + " whose metadata cannot be retrieved. Can't resolve");
+      }
+
+      if (!parentMetadata.isDir()) {
+         // Invalid state: the parent path is actually a file. Throw.
+         throw new AzureException("File " + f + " has a parent directory "
+             + parentPath + " which is also a file. Can't resolve.");
+      }
+    }
+
+    // The path exists, determine if it is a folder containing objects,
+    // an empty folder, or a simple file and take the appropriate actions.
+    if (!metaFile.isDir()) {
+      // The path specifies a file. We need to check the parent path
+      // to make sure it's a proper materialized directory before we
+      // delete the file. Otherwise we may get into a situation where
+      // the file we were deleting was the last one in an implicit directory
+      // (e.g. the blob store only contains the blob a/b and there's no
+      // corresponding directory blob a) and that would implicitly delete
+      // the directory as well, which is not correct.
+
+      if (parentPath != null && parentPath.getParent() != null) {// Not root
+
+        if (parentMetadata.getBlobMaterialization() == BlobMaterialization.Implicit) {
+          LOG.debug("Found an implicit parent directory while trying to"
+              + " delete the file {}. Creating the directory blob for"
+              + " it in {}.", f, parentKey);
+
+          store.storeEmptyFolder(parentKey,
+              createPermissionStatus(FsPermission.getDefault()));
+        } else {
+          if (!skipParentFolderLastModifiedTimeUpdate) {
+            updateParentFolderLastModifiedTime(key);
+          }
+        }
+      }
+
+      // check if the file can be deleted based on sticky bit check
+      // This check will be performed only when authorization is enabled
+      if (isStickyBitCheckViolated(metaFile, parentMetadata)) {
+        throw new WasbAuthorizationException(String.format("%s has sticky bit set. "
+          + "File %s cannot be deleted.", parentPath, f));
+      }
+
+      try {
+        if (store.delete(key)) {
+          instrumentation.fileDeleted();
+        } else {
+          return false;
+        }
+      } catch(IOException e) {
+
+        Throwable innerException = checkForAzureStorageException(e);
+
+        if (innerException instanceof StorageException
+            && isFileNotFoundException((StorageException) innerException)) {
+          return false;
+        }
+
+       throw e;
+      }
+    } else {
+      // The path specifies a folder. Recursively delete all entries under the
+      // folder.
+      LOG.debug("Directory Delete encountered: {}", f);
+      if (parentPath != null && parentPath.getParent() != null) {
+
+        if (parentMetadata.getBlobMaterialization() == BlobMaterialization.Implicit) {
+          LOG.debug("Found an implicit parent directory while trying to"
+                  + " delete the directory {}. Creating the directory blob for"
+                  + " it in {}. ", f, parentKey);
+
+          store.storeEmptyFolder(parentKey,
+                  createPermissionStatus(FsPermission.getDefault()));
+        }
+      }
+
+      // check if the folder can be deleted based on sticky bit check on parent
+      // This check will be performed only when authorization is enabled.
+      if (!metaFile.getKey().equals("/")
+          && isStickyBitCheckViolated(metaFile, parentMetadata)) {
+
+        throw new WasbAuthorizationException(String.format("%s has sticky bit set. "
+          + "File %s cannot be deleted.", parentPath, f));
+      }
+
+      // Iterate through folder contents and get the list of files
+      // and folders that can be deleted. We might encounter IOException
+      // while listing blobs. In such cases, we return false.
+      ArrayList<FileMetadata> fileMetadataList = new ArrayList<>();
+      boolean isPartialDelete = false;
+
+      // Start time for list operation
+      long start = Time.monotonicNow();
+
+      try {
+        // Get list of files/folders that can be deleted
+        // based on authorization checks and stickybit checks
+        isPartialDelete = getFolderContentsToDelete(metaFile, fileMetadataList);
+      } catch (IOException e) {
+        Throwable innerException = checkForAzureStorageException(e);
+
+        if (innerException instanceof StorageException
+            && isFileNotFoundException((StorageException) innerException)) {
+            return false;
+        }
+        throw e;
+      }
+
+      long end = Time.monotonicNow();
+      LOG.debug("Time taken to list {} blobs for delete operation: {} ms",
+        fileMetadataList.size(), (end - start));
+
+      // Here contents holds the list of metadata of the files and folders that can be deleted
+      // under the path that is requested for delete(excluding itself).
+      final FileMetadata[] contents = fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);
+
+      if (contents.length > 0 && !recursive) {
+          // The folder is non-empty and recursive delete was not specified.
+          // Throw an exception indicating that a non-recursive delete was
+          // specified for a non-empty folder.
+          throw new IOException("Non-recursive delete of non-empty directory "
+              + f);
+      }
+
+      // Delete all files / folders in current directory stored as list in 'contents'.
+      AzureFileSystemThreadTask task = new AzureFileSystemThreadTask() {
+        @Override
+        public boolean execute(FileMetadata file) throws IOException{
+          if (!deleteFile(file.getKey(), file.isDir())) {
+            LOG.warn("Attempt to delete non-existent {} {}",
+                file.isDir() ? "directory" : "file",
+                file.getKey());
+          }
+          return true;
+        }
+      };
+
+      AzureFileSystemThreadPoolExecutor executor = getThreadPoolExecutor(this.deleteThreadCount,
+          "AzureBlobDeleteThread", "Delete", key, AZURE_DELETE_THREADS);
+
+      if (!executor.executeParallel(contents, task)) {
+        LOG.error("Failed to delete files / subfolders in blob {}", key);
+        return false;
+      }
+
+      if (metaFile.getKey().equals("/")) {
+        LOG.error("Cannot delete root directory {}", f);
+        return false;
+      }
+
+      // Delete the current directory if all underlying contents are deleted
+      if (isPartialDelete || (store.retrieveMetadata(metaFile.getKey()) != null
+          && !deleteFile(metaFile.getKey(), metaFile.isDir()))) {
+        LOG.error("Failed delete directory : {}", f);
+        return false;
+      }
+
+      // Update parent directory last modified time
+      Path parent = absolutePath.getParent();
+      if (parent != null && parent.getParent() != null) { // not root
+        if (!skipParentFolderLastModifiedTimeUpdate) {
+          updateParentFolderLastModifiedTime(key);
+        }
+      }
+    }
+
+    // File or directory was successfully deleted.
+    LOG.debug("Delete Successful for : {}", f);
+    return true;
+  }
+
+  private boolean deleteWithoutAuth(Path f, boolean recursive,
+      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {
+
+    LOG.debug("Deleting file: {}", f);
+
+    Path absolutePath = makeAbsolute(f);
+    Path parentPath = absolutePath.getParent();
-      Throwable innerException = NativeAzureFileSystemHelper.checkForAzureStorageException(e);
+      Throwable innerException = checkForAzureStorageException(e);
-          && NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {
+          && isFileNotFoundException((StorageException) innerException)) {
-          Throwable innerException = NativeAzureFileSystemHelper.checkForAzureStorageException(e);
+          Throwable innerException = checkForAzureStorageException(e);
-            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {
+            if (isFileNotFoundException((StorageException) innerException)) {
-        Throwable innerException = NativeAzureFileSystemHelper.checkForAzureStorageException(e);
+        Throwable innerException = checkForAzureStorageException(e);
-            && NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {
+            && isFileNotFoundException((StorageException) innerException)) {
-      LOG.debug("Directory Delete encountered: {}", f.toString());
+      LOG.debug("Directory Delete encountered: {}", f);
-          Throwable innerException = NativeAzureFileSystemHelper.checkForAzureStorageException(e);
+          Throwable innerException = checkForAzureStorageException(e);
-            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {
+            if (isFileNotFoundException((StorageException) innerException)) {
-          Throwable innerException = NativeAzureFileSystemHelper.checkForAzureStorageException(e);
+          Throwable innerException = checkForAzureStorageException(e);
-              && NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {
+              && isFileNotFoundException((StorageException) innerException)) {
-          throw new IOException("Non-recursive delete of non-empty directory "
-              + f.toString());
-        }
-        else {
-          // Check write-permissions on sub-tree including current folder
-          // NOTE: Ideally the subtree needs read-write-execute access check.
-          // But we will simplify it to write-access check.
-          if (metaFile.isDir()) { // the absolute-path
-            performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, "delete", absolutePath);
-          }
-          for (FileMetadata meta : contents) {
-            if (meta.isDir()) {
-              Path subTreeDir = keyToPath(meta.getKey());
-              performAuthCheck(subTreeDir, WasbAuthorizationOperations.WRITE, "delete", absolutePath);
-            }
-          }
+          throw new IOException("Non-recursive delete of non-empty directory "+ f);
-      if (store.retrieveMetadata(metaFile.getKey()) != null && !deleteFile(metaFile.getKey(), metaFile.isDir())) {
-        LOG.error("Failed delete directory {}", f.toString());
+      if (store.retrieveMetadata(metaFile.getKey()) != null
+          && !deleteFile(metaFile.getKey(), metaFile.isDir())) {
+        LOG.error("Failed delete directory : {}", f);
-    LOG.debug("Delete Successful for : {}", f.toString());
+    LOG.debug("Delete Successful for : {}", f);
+  /**
+   * Delete the specified file or folder. The parameter
+   * skipParentFolderLastModifiedTimeUpdate
+   * is used in the case of atomic folder rename redo. In that case, there is
+   * a lease on the parent folder, so (without reworking the code) modifying
+   * the parent folder update time will fail because of a conflict with the
+   * lease. Since we are going to delete the folder soon anyway so accurate
+   * modified time is not necessary, it's easier to just skip
+   * the modified time update.
+   *
+   * @param f file path to be deleted.
+   * @param recursive specify deleting recursively or not.
+   * @param skipParentFolderLastModifiedTimeUpdate If true, don't update the folder last
+   * modified time.
+   * @return true if and only if the file is deleted
+   * @throws IOException Thrown when fail to delete file or directory.
+   */
+  public boolean delete(Path f, boolean recursive,
+      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {
+
+    if (this.azureAuthorization) {
+      return deleteWithAuthEnabled(f, recursive,
+        skipParentFolderLastModifiedTimeUpdate);
+    } else {
+      return deleteWithoutAuth(f, recursive,
+        skipParentFolderLastModifiedTimeUpdate);
+    }
+  }
+
+   * Gets list of contents that can be deleted based on authorization check calls
+   * performed on the sub-tree for the folderToDelete.
+   *
+   * @param folderToDelete - metadata of the folder whose delete is requested.
+   * @param finalList - list of metadata of all files/folders that can be deleted .
+   *
+   * @return 'true' only if all the contents of the folderToDelete can be deleted
+   * @throws IOException Thrown when current user cannot be retrieved.
+   */
+  private boolean getFolderContentsToDelete(FileMetadata folderToDelete,
+      ArrayList<FileMetadata> finalList) throws IOException {
+
+    final int maxListingDepth = 1;
+    Stack<FileMetadata> foldersToProcess = new Stack<FileMetadata>();
+    HashMap<String, FileMetadata> folderContentsMap = new HashMap<String, FileMetadata>();
+
+    boolean isPartialDelete = false;
+
+    Path pathToDelete = makeAbsolute(keyToPath(folderToDelete.getKey()));
+    foldersToProcess.push(folderToDelete);
+
+    while (!foldersToProcess.empty()) {
+
+      FileMetadata currentFolder = foldersToProcess.pop();
+      Path currentPath = makeAbsolute(keyToPath(currentFolder.getKey()));
+      boolean canDeleteChildren = true;
+
+      // If authorization is enabled, check for 'write' permission on current folder
+      // This check maps to subfolders 'write' check for deleting contents recursively.
+      try {
+        performAuthCheck(currentPath, WasbAuthorizationOperations.WRITE, "delete", pathToDelete);
+      } catch (WasbAuthorizationException we) {
+        LOG.debug("Authorization check failed for {}", currentPath);
+        // We cannot delete the children of currentFolder since 'write' check on parent failed
+        canDeleteChildren = false;
+      }
+
+      if (canDeleteChildren) {
+
+        // get immediate children list
+        ArrayList<FileMetadata> fileMetadataList = getChildrenMetadata(currentFolder.getKey(),
+            maxListingDepth);
+
+        // Process children of currentFolder and add them to list of contents
+        // that can be deleted. We Perform stickybit check on every file and
+        // folder under currentFolder in case stickybit is set on currentFolder.
+        for (FileMetadata childItem : fileMetadataList) {
+          if (isStickyBitCheckViolated(childItem, currentFolder, false)) {
+            // Stickybit check failed for the childItem that is being processed.
+            // This file/folder cannot be deleted and neither can the parent paths be deleted.
+            // Remove parent paths from list of contents that can be deleted.
+            canDeleteChildren = false;
+            Path filePath = makeAbsolute(keyToPath(childItem.getKey()));
+            LOG.error("User does not have permissions to delete {}. "
+              + "Parent directory has sticky bit set.", filePath);
+          } else {
+            // push the child directories to the stack to process their contents
+            if (childItem.isDir()) {
+              foldersToProcess.push(childItem);
+            }
+            // Add items to list of contents that can be deleted.
+            folderContentsMap.put(childItem.getKey(), childItem);
+          }
+        }
+
+      } else {
+        // Cannot delete children since parent permission check has not passed and
+        // if there are files/folders under currentFolder they will not be deleted.
+        LOG.error("Authorization check failed. Files or folders under {} "
+          + "will not be processed for deletion.", currentPath);
+      }
+
+      if (!canDeleteChildren) {
+        // We reach here if
+        // 1. cannot delete children since 'write' check on parent failed or
+        // 2. One of the files under the current folder cannot be deleted due to stickybit check.
+        // In this case we remove all the parent paths from the list of contents
+        // that can be deleted till we reach the original path of delete request
+        String pathToRemove = currentFolder.getKey();
+        while (!pathToRemove.equals(folderToDelete.getKey())) {
+          if (folderContentsMap.containsKey(pathToRemove)) {
+            LOG.debug("Cannot delete {} since some of its contents "
+              + "cannot be deleted", pathToRemove);
+            folderContentsMap.remove(pathToRemove);
+          }
+          Path parentPath = keyToPath(pathToRemove).getParent();
+          pathToRemove = pathToKey(parentPath);
+        }
+        // Since one or more files/folders cannot be deleted return value should indicate
+        // partial delete, so that the delete on the path requested by user is not performed
+        isPartialDelete = true;
+      }
+    }
+
+    // final list of contents that can be deleted
+    for (HashMap.Entry<String, FileMetadata> entry : folderContentsMap.entrySet()) {
+      finalList.add(entry.getValue());
+    }
+
+    return isPartialDelete;
+  }
+
+  private ArrayList<FileMetadata> getChildrenMetadata(String key, int maxListingDepth)
+    throws IOException {
+
+    String priorLastKey = null;
+    ArrayList<FileMetadata> fileMetadataList = new ArrayList<FileMetadata>();
+    do {
+       PartialListing listing = store.listAll(key, AZURE_LIST_ALL,
+         maxListingDepth, priorLastKey);
+       for (FileMetadata file : listing.getFiles()) {
+         fileMetadataList.add(file);
+       }
+       priorLastKey = listing.getPriorLastKey();
+    } while (priorLastKey != null);
+
+    return fileMetadataList;
+  }
+
+  private boolean isStickyBitCheckViolated(FileMetadata metaData,
+    FileMetadata parentMetadata, boolean throwOnException) throws IOException {
+      try {
+        return isStickyBitCheckViolated(metaData, parentMetadata);
+      } catch (FileNotFoundException ex) {
+        if (throwOnException) {
+          throw ex;
+        } else {
+          LOG.debug("Encountered FileNotFoundException while performing "
+            + "stickybit check operation for {}", metaData.getKey());
+          // swallow exception and return that stickyBit check has been violated
+          return true;
+        }
+      }
+  }
+
+  /**
+   * Checks if the Current user is not permitted access to a file/folder when
+   * sticky bit is set on parent path. Only the owner of parent path
+   * and owner of the file/folder itself are permitted to perform certain
+   * operations on file/folder based on sticky bit check. Sticky bit check will
+   * be performed only when authorization is enabled.
+   *
+   * @param metaData - metadata of the file/folder whose parent has sticky bit set.
+   * @param parentMetadata - metadata of the parent.
+   *
+   * @return true if Current user violates stickybit check
+   * @throws IOException Thrown when current user cannot be retrieved.
+   */
+   private boolean isStickyBitCheckViolated(FileMetadata metaData,
+    FileMetadata parentMetadata) throws IOException {
+
+    // In case stickybit check should not be performed,
+    // return value should indicate stickybit check is not violated.
+    if (!this.azureAuthorization) {
+      return false;
+    }
+
+    // This should never happen when the sticky bit check is invoked.
+    if (parentMetadata == null) {
+      throw new FileNotFoundException(
+        String.format("Parent metadata for '%s' not found!", metaData.getKey()));
+    }
+
+    // stickybit is not set on parent and hence cannot be violated
+    if (!parentMetadata.getPermissionStatus().getPermission().getStickyBit()) {
+      return false;
+    }
+
+    String currentUser = UserGroupInformation.getCurrentUser().getShortUserName();
+    String parentDirectoryOwner = parentMetadata.getPermissionStatus().getUserName();
+    String currentFileOwner = metaData.getPermissionStatus().getUserName();
+
+    // Files/Folders with no owner set will not pass stickybit check
+    if ((parentDirectoryOwner.equalsIgnoreCase(currentUser))
+      || currentFileOwner.equalsIgnoreCase(currentUser)) {
+
+      return false;
+    }
+    return true;
+  }
+
+  /**

INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 UPD83 UPD42 INS44 INS44 INS44 INS43 MOV8 MOV29 INS83 INS39 INS42 MOV44 MOV44 MOV44 MOV43 INS8 INS29 INS83 INS39 INS42 MOV44 INS44 INS43 INS8 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS65 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS21 INS60 INS60 MOV25 INS60 INS60 MOV54 INS25 INS60 INS60 INS25 INS25 INS21 INS41 INS43 INS42 INS39 INS42 INS39 INS42 INS42 MOV60 MOV60 MOV60 MOV60 MOV54 MOV25 INS25 INS21 MOV41 INS25 INS65 INS65 INS65 INS65 INS65 UPD42 INS74 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS21 INS61 INS70 INS41 INS43 INS43 INS43 INS42 INS39 INS42 INS42 INS60 INS60 INS19 INS41 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS54 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS25 INS25 INS25 INS60 INS60 INS60 INS25 INS41 INS66 INS66 INS66 INS66 INS42 INS32 INS43 INS59 INS43 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS27 INS8 INS38 INS8 INS8 INS32 INS9 INS42 INS8 MOV38 INS8 MOV8 INS32 INS22 INS8 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS43 INS43 INS83 INS39 INS59 INS74 INS59 INS74 INS59 INS39 INS59 MOV43 INS59 INS32 INS38 INS8 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS43 INS59 INS74 INS59 INS8 INS27 INS42 INS42 INS42 INS8 INS12 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS38 INS8 INS27 INS8 INS38 INS8 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS9 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 MOV21 INS42 INS42 INS32 INS42 INS42 INS33 INS33 INS42 INS41 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS33 INS21 MOV54 INS25 INS25 INS32 INS25 INS25 MOV54 INS21 INS25 INS25 INS60 INS60 INS60 MOV54 INS60 INS21 INS60 INS25 INS60 INS60 INS25 INS25 MOV25 INS60 INS25 INS42 INS42 INS45 INS42 UPD45 MOV42 INS21 MOV25 INS54 INS21 INS25 MOV60 MOV60 MOV60 MOV19 MOV60 MOV21 MOV60 INS25 MOV60 MOV60 MOV25 MOV25 MOV60 MOV25 INS42 INS42 INS45 INS42 INS52 INS42 INS41 INS41 INS42 INS42 INS42 INS34 INS43 INS43 INS42 INS14 INS43 INS43 INS43 INS42 INS14 INS42 INS9 INS42 INS32 INS42 INS42 INS42 INS32 INS60 INS60 INS60 INS54 INS25 INS25 INS74 INS42 INS42 INS42 INS21 INS42 INS42 INS33 INS43 INS43 INS42 INS14 INS60 INS70 INS21 INS42 INS33 INS41 INS44 INS8 INS22 INS41 INS42 INS33 INS53 INS32 INS41 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS36 INS32 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS7 INS27 INS8 INS38 INS8 INS42 INS42 INS27 INS8 INS32 INS8 INS32 INS27 INS8 INS27 INS8 INS74 INS59 INS39 INS59 INS39 INS59 INS8 INS39 INS59 INS32 INS83 INS5 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS38 INS8 INS32 INS8 INS27 INS43 INS59 INS27 INS8 INS7 INS25 INS8 INS8 INS12 INS32 MOV27 INS8 INS27 INS8 INS27 INS8 INS32 INS32 INS42 INS42 INS74 INS42 INS42 INS42 INS74 INS42 INS32 INS42 INS42 INS43 INS59 INS43 INS59 INS39 INS59 INS8 INS12 INS42 INS8 INS8 INS38 INS8 INS43 INS43 INS43 INS32 INS42 INS42 INS74 INS43 INS59 INS44 INS32 INS8 INS7 INS32 INS43 INS42 INS25 INS52 INS42 INS9 INS14 INS32 INS42 INS9 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS9 INS42 INS32 INS42 INS33 INS53 INS32 INS53 INS27 INS27 INS25 INS42 INS42 INS42 INS53 INS42 INS42 INS45 INS42 INS27 INS27 INS25 INS38 INS32 INS53 INS43 INS43 INS42 INS14 INS42 INS9 INS42 INS32 INS21 INS42 INS32 INS42 INS42 INS45 INS32 INS36 INS43 INS85 INS42 INS32 MOV27 INS38 INS53 INS42 INS42 INS14 INS42 INS42 INS32 INS32 INS21 INS41 INS32 INS42 INS45 INS21 INS41 INS42 INS36 INS42 INS42 INS32 INS27 INS27 INS25 INS42 INS32 INS27 INS8 MOV60 MOV60 INS54 MOV25 MOV25 MOV25 INS25 INS44 INS8 INS42 INS42 INS45 INS42 MOV60 MOV60 INS54 MOV25 MOV25 INS54 INS40 INS34 INS25 INS27 INS38 MOV21 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS9 INS21 INS44 INS8 INS60 INS70 INS21 INS42 INS60 INS61 INS21 INS40 INS42 INS42 INS42 INS42 INS32 INS43 INS43 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS8 INS8 INS43 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS33 INS32 INS33 INS27 INS8 INS8 INS14 INS42 INS33 INS32 INS33 INS27 INS8 INS32 INS42 INS42 INS42 INS14 INS42 INS42 INS74 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS3 INS42 INS14 INS43 INS1 INS42 INS22 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS9 INS42 INS42 INS32 INS9 MOV27 INS42 INS42 INS42 INS33 INS32 INS33 INS38 INS8 INS42 INS42 INS42 MOV62 MOV32 INS41 MOV8 INS12 INS32 INS8 INS8 INS43 INS42 INS60 INS25 INS53 INS8 INS12 MOV8 INS12 MOV38 INS8 INS32 INS33 INS32 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS43 INS42 INS21 INS21 INS74 INS59 INS44 INS42 INS8 INS32 INS43 INS59 INS38 INS8 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS53 INS21 INS41 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS43 INS27 INS43 INS27 INS42 INS42 INS32 INS40 INS21 INS21 INS25 INS43 INS32 INS42 INS42 INS32 INS40 INS21 INS21 INS32 INS42 INS45 INS43 INS32 INS43 INS42 INS32 INS42 INS42 INS5 INS32 MOV43 INS27 INS42 INS31 INS52 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 UPD45 MOV42 INS42 INS42 INS42 INS21 INS9 INS44 INS8 INS42 INS42 INS42 INS21 INS41 INS42 INS43 INS59 INS27 INS8 INS42 INS21 INS44 INS8 INS44 INS8 INS53 INS42 INS42 INS32 UPD42 MOV42 MOV32 INS32 UPD42 UPD42 UPD45 UPD42 INS42 INS32 INS42 INS42 INS40 INS45 INS42 INS42 INS32 INS7 INS43 INS43 INS42 INS32 INS43 INS42 INS25 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS32 INS25 INS60 INS21 INS42 INS9 INS42 INS42 INS42 INS42 INS32 INS9 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS32 INS32 INS38 INS8 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS42 INS45 INS42 INS78 INS83 INS39 INS42 INS44 INS43 INS8 INS32 INS43 INS42 INS60 MOV25 INS53 INS32 INS9 INS42 INS42 INS32 INS62 INS32 INS41 INS7 INS43 INS42 INS60 INS25 INS53 INS43 INS42 INS60 INS25 INS53 INS14 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS9 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS8 INS8 INS45 INS45 INS42 INS42 INS42 INS42 INS32 INS32 INS8 INS43 INS59 INS7 INS42 INS42 INS27 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS21 INS45 INS45 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS45 INS45 INS42 INS42 INS43 INS42 INS42 INS25 INS41 INS42 INS42 INS42 INS43 INS59 INS62 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS11 INS9 INS42 INS32 INS42 INS43 INS59 INS62 INS8 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS9 INS21 INS60 INS21 INS25 INS21 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS32 INS42 INS32 INS45 INS45 INS42 INS42 INS45 INS45 INS45 INS42 INS32 INS32 INS45 INS45 INS45 INS42 INS32 INS42 INS38 INS8 INS9 INS42 INS42 INS32 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS25 INS42 INS42 INS32 INS62 INS32 INS41 INS42 INS45 INS42 INS7 INS43 INS59 INS32 INS32 INS8 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS21 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 MOV8 INS42 INS42 INS42 INS43 INS42 INS11 INS9 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS11 INS42 INS11 INS42 INS43 INS42 INS42 INS32 INS45 INS45 INS32 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS16 INS32 INS43 INS42 INS43 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS45 INS45 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 UPD45 INS42 INS45 INS42 INS45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL8 DEL42 DEL42 DEL32 DEL40 DEL32 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL8 DEL70 DEL8 DEL25 DEL25 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8
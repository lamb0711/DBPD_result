HDFS-9731. Erasure Coding: Rename BlockECRecoveryCommand to BlockECReconstructionCommand. Contributed by Rakesh R.

Change-Id: I405365a8395770e494b92bfe9651f4f0366d8f28

-import org.apache.hadoop.hdfs.server.protocol.BlockECRecoveryCommand.BlockECRecoveryInfo;
+import org.apache.hadoop.hdfs.server.protocol.BlockECReconstructionCommand.BlockECReconstructionInfo;
- * ErasureCodingWorker handles the erasure coding recovery work commands. These
- * commands would be issued from Namenode as part of Datanode's heart beat
- * response. BPOfferService delegates the work to this class for handling EC
- * commands.
+ * ErasureCodingWorker handles the erasure coding reconstruction work commands.
+ * These commands would be issued from Namenode as part of Datanode's heart
+ * beat response. BPOfferService delegates the work to this class for handling
+ * EC commands.
-  private ThreadPoolExecutor STRIPED_BLK_RECOVERY_THREAD_POOL;
-  private ThreadPoolExecutor STRIPED_READ_THREAD_POOL;
-  private final int STRIPED_READ_TIMEOUT_MILLIS;
-  private final int STRIPED_READ_BUFFER_SIZE;
+  private ThreadPoolExecutor EC_RECONSTRUCTION_STRIPED_BLK_THREAD_POOL;
+  private ThreadPoolExecutor EC_RECONSTRUCTION_STRIPED_READ_THREAD_POOL;
+  private final int EC_RECONSTRUCTION_STRIPED_READ_TIMEOUT_MILLIS;
+  private final int EC_RECONSTRUCTION_STRIPED_READ_BUFFER_SIZE;
-    STRIPED_READ_TIMEOUT_MILLIS = conf.getInt(
-        DFSConfigKeys.DFS_DATANODE_STRIPED_READ_TIMEOUT_MILLIS_KEY,
-        DFSConfigKeys.DFS_DATANODE_STRIPED_READ_TIMEOUT_MILLIS_DEFAULT);
+    EC_RECONSTRUCTION_STRIPED_READ_TIMEOUT_MILLIS = conf.getInt(
+        DFSConfigKeys.DFS_DN_EC_RECONSTRUCTION_STRIPED_READ_TIMEOUT_MILLIS_KEY,
+        DFSConfigKeys.DFS_DN_EC_RECONSTRUCTION_STRIPED_READ_TIMEOUT_MILLIS_DEFAULT);
-        DFSConfigKeys.DFS_DATANODE_STRIPED_READ_THREADS_KEY, 
-        DFSConfigKeys.DFS_DATANODE_STRIPED_READ_THREADS_DEFAULT));
-    STRIPED_READ_BUFFER_SIZE = conf.getInt(
-        DFSConfigKeys.DFS_DATANODE_STRIPED_READ_BUFFER_SIZE_KEY,
-        DFSConfigKeys.DFS_DATANODE_STRIPED_READ_BUFFER_SIZE_DEFAULT);
+        DFSConfigKeys.DFS_DN_EC_RECONSTRUCTION_STRIPED_READ_THREADS_KEY,
+        DFSConfigKeys.DFS_DN_EC_RECONSTRUCTION_STRIPED_READ_THREADS_DEFAULT));
+    EC_RECONSTRUCTION_STRIPED_READ_BUFFER_SIZE = conf.getInt(
+        DFSConfigKeys.DFS_DN_EC_RECONSTRUCTION_STRIPED_READ_BUFFER_SIZE_KEY,
+        DFSConfigKeys.DFS_DN_EC_RECONSTRUCTION_STRIPED_READ_BUFFER_SIZE_DEFAULT);
-    initializeStripedBlkRecoveryThreadPool(conf.getInt(
-        DFSConfigKeys.DFS_DATANODE_STRIPED_BLK_RECOVERY_THREADS_KEY,
-        DFSConfigKeys.DFS_DATANODE_STRIPED_BLK_RECOVERY_THREADS_DEFAULT));
+    initializeStripedBlkReconstructionThreadPool(conf.getInt(
+        DFSConfigKeys.DFS_DN_EC_RECONSTRUCTION_STRIPED_BLK_THREADS_KEY,
+        DFSConfigKeys.DFS_DN_EC_RECONSTRUCTION_STRIPED_BLK_THREADS_DEFAULT));
-    STRIPED_READ_THREAD_POOL = new ThreadPoolExecutor(1, num, 60,
-        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
+    EC_RECONSTRUCTION_STRIPED_READ_THREAD_POOL = new ThreadPoolExecutor(1, num,
+        60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-    STRIPED_READ_THREAD_POOL.allowCoreThreadTimeOut(true);
+    EC_RECONSTRUCTION_STRIPED_READ_THREAD_POOL.allowCoreThreadTimeOut(true);
-  private void initializeStripedBlkRecoveryThreadPool(int num) {
-    LOG.debug("Using striped block recovery; pool threads=" + num);
-    STRIPED_BLK_RECOVERY_THREAD_POOL = new ThreadPoolExecutor(2, num, 60,
-        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
+  private void initializeStripedBlkReconstructionThreadPool(int num) {
+    LOG.debug("Using striped block reconstruction; pool threads=" + num);
+    EC_RECONSTRUCTION_STRIPED_BLK_THREAD_POOL = new ThreadPoolExecutor(2, num,
+        60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
-            t.setName("stripedBlockRecovery-" + threadIdx.getAndIncrement());
+            t.setName(
+                "stripedBlockReconstruction-" + threadIdx.getAndIncrement());
-    STRIPED_BLK_RECOVERY_THREAD_POOL.allowCoreThreadTimeOut(true);
+    EC_RECONSTRUCTION_STRIPED_BLK_THREAD_POOL.allowCoreThreadTimeOut(true);
-   * Handles the Erasure Coding recovery work commands.
-   * 
+   * Handles the Erasure Coding reconstruction work commands.
+   *
-   *          BlockECRecoveryInfo
+   *          BlockECReconstructionInfo
-  public void processErasureCodingTasks(Collection<BlockECRecoveryInfo> ecTasks) {
-    for (BlockECRecoveryInfo recoveryInfo : ecTasks) {
+  public void processErasureCodingTasks(
+      Collection<BlockECReconstructionInfo> ecTasks) {
+    for (BlockECReconstructionInfo reconstructionInfo : ecTasks) {
-        STRIPED_BLK_RECOVERY_THREAD_POOL
-            .submit(new ReconstructAndTransferBlock(recoveryInfo));
+        EC_RECONSTRUCTION_STRIPED_BLK_THREAD_POOL
+            .submit(new ReconstructAndTransferBlock(reconstructionInfo));
-        LOG.warn("Failed to recover striped block "
-            + recoveryInfo.getExtendedBlock().getLocalBlock(), e);
+        LOG.warn("Failed to reconstruct striped block "
+            + reconstructionInfo.getExtendedBlock().getLocalBlock(), e);
-   * ReconstructAndTransferBlock recover one or more missed striped block in the
-   * striped block group, the minimum number of live striped blocks should be
-   * no less than data block number.
+   * ReconstructAndTransferBlock reconstruct one or more missed striped block
+   * in the striped block group, the minimum number of live striped blocks
+   * should be no less than data block number.
-   * We use following steps to recover striped block group, in each round, we
-   * recover <code>bufferSize</code> data until finish, the 
+   * We use following steps to reconstruct striped block group, in each round,
+   * we reconstruct <code>bufferSize</code> data until finish, the
-   *        required by recovery.
+   *        required by reconstruction.
-   * In step2, typically if source blocks we read are all data blocks, we 
+   * In step2, typically if source blocks we read are all data blocks, we
-   * decode. Notice we only read once and recover all missed striped block 
+   * decode. Notice we only read once and reconstruct all missed striped block
-   * In step3, send the recovered data to targets by constructing packet 
-   * and send them directly. Same as continuous block replication, we 
-   * don't check the packet ack. Since the datanode doing the recovery work
-   * are one of the source datanodes, so the recovered data are sent 
+   * In step3, send the reconstructed data to targets by constructing packet
+   * and send them directly. Same as continuous block replication, we
+   * don't check the packet ack. Since the datanode doing the reconstruction
+   * work are one of the source datanodes, so the reconstructed data are sent
-   * 2. We need to check the packet ack for EC recovery? Since EC recovery
-   *    is more expensive than continuous block replication, it needs to 
-   *    read from several other datanodes, should we make sure the 
-   *    recovered result received by targets? 
+   * 2. We need to check the packet ack for EC reconstruction? Since EC
+   *    reconstruction is more expensive than continuous block replication,
+   *    it needs to read from several other datanodes, should we make sure
+   *    the reconstructed result received by targets?
-        new ExecutorCompletionService<>(STRIPED_READ_THREAD_POOL);
+        new ExecutorCompletionService<>(
+            EC_RECONSTRUCTION_STRIPED_READ_THREAD_POOL);
-    ReconstructAndTransferBlock(BlockECRecoveryInfo recoveryInfo) {
-      ErasureCodingPolicy ecPolicy = recoveryInfo.getErasureCodingPolicy();
+    ReconstructAndTransferBlock(BlockECReconstructionInfo reconstructionInfo) {
+      ErasureCodingPolicy ecPolicy = reconstructionInfo
+          .getErasureCodingPolicy();
-      blockGroup = recoveryInfo.getExtendedBlock();
+      blockGroup = reconstructionInfo.getExtendedBlock();
-      liveIndices = recoveryInfo.getLiveBlockIndices();
-      sources = recoveryInfo.getSourceDnInfos();
+      liveIndices = reconstructionInfo.getLiveBlockIndices();
+      sources = reconstructionInfo.getSourceDnInfos();
-      targets = recoveryInfo.getTargetDnInfos();
-      targetStorageTypes = recoveryInfo.getTargetStorageTypes();
+      targets = reconstructionInfo.getTargetDnInfos();
+      targetStorageTypes = reconstructionInfo.getTargetStorageTypes();
-              + "recovery, block id: " + blockGroup.getBlockId();
+              + "reconstruction, block id: " + blockGroup.getBlockId();
-          final int toRecover = (int) Math.min(
+          final int toReconstruct = (int) Math.min(
-            success = readMinimumStripedData4Recovery(success, toRecover,
-                corruptionMap);
+            success = readMinimumStripedData4Reconstruction(success,
+                toReconstruct, corruptionMap);
-          recoverTargets(success, targetsStatus, toRecover);
+          reconstructTargets(success, targetsStatus, toReconstruct);
-          positionInBlock += toRecover;
+          positionInBlock += toReconstruct;
-        LOG.warn("Failed to recover striped block: " + blockGroup, e);
+        LOG.warn("Failed to reconstruct striped block: " + blockGroup, e);
-        int readBufferSize = STRIPED_READ_BUFFER_SIZE;
+        int readBufferSize = EC_RECONSTRUCTION_STRIPED_READ_BUFFER_SIZE;
-    /** the reading length should not exceed the length for recovery */
-    private int getReadLength(int index, int recoverLength) {
+    /** the reading length should not exceed the length for reconstruction. */
+    private int getReadLength(int index, int reconstructLength) {
-      return (int) Math.min(remaining, recoverLength);
+      return (int) Math.min(remaining, reconstructLength);
-     * @param recoverLength the length to recover.
+     * @param reconstructLength the length to reconstruct.
-    private int[] readMinimumStripedData4Recovery(final int[] success,
-        int recoverLength, Map<ExtendedBlock, Set<DatanodeInfo>> corruptionMap)
-        throws IOException {
-      Preconditions.checkArgument(recoverLength >= 0 &&
-          recoverLength <= bufferSize);
+    private int[] readMinimumStripedData4Reconstruction(final int[] success,
+        int reconstructLength,
+        Map<ExtendedBlock, Set<DatanodeInfo>> corruptionMap)
+            throws IOException {
+      Preconditions.checkArgument(reconstructLength >= 0 &&
+          reconstructLength <= bufferSize);
-            recoverLength);
+            reconstructLength);
-          StripingChunkReadResult result =
-              StripedBlockUtil.getNextCompletedStripedRead(
-                  readService, futures, STRIPED_READ_TIMEOUT_MILLIS);
+          StripingChunkReadResult result = StripedBlockUtil
+              .getNextCompletedStripedRead(readService, futures,
+                  EC_RECONSTRUCTION_STRIPED_READ_TIMEOUT_MILLIS);
-            resultIndex = scheduleNewRead(used, recoverLength, corruptionMap);
+            resultIndex = scheduleNewRead(used, reconstructLength,
+                corruptionMap);
-            resultIndex = scheduleNewRead(used, recoverLength, corruptionMap);
+            resultIndex = scheduleNewRead(used, reconstructLength,
+                corruptionMap);
-    private void recoverTargets(int[] success, boolean[] targetsStatus,
-        int toRecoverLen) {
+    private void reconstructTargets(int[] success, boolean[] targetsStatus,
+        int toReconstructLen) {
-        paddingBufferToLen(buffer, toRecoverLen);
+        paddingBufferToLen(buffer, toReconstructLen);
-          paddingBufferToLen(buffer, toRecoverLen);
+          paddingBufferToLen(buffer, toReconstructLen);
-          targetBuffers[i].limit(toRecoverLen);
+          targetBuffers[i].limit(toReconstructLen);
-          } else if (remaining < toRecoverLen) {
+          } else if (remaining < toReconstructLen) {
-    private int scheduleNewRead(BitSet used, int recoverLength,
+    private int scheduleNewRead(BitSet used, int reconstructLen,
-        toRead = getReadLength(liveIndices[m], recoverLength);
+        toRead = getReadLength(liveIndices[m], reconstructLen);
-          toRead = getReadLength(liveIndices[i], recoverLength);
+          toRead = getReadLength(liveIndices[i], reconstructLen);

UPD40 UPD42 UPD66 UPD66 UPD66 UPD66 UPD42 UPD42 UPD42 UPD42 UPD74 UPD42 UPD42 UPD66 UPD66 UPD43 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD66 UPD42 UPD66 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD45 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42
HDFS-11926. Ozone: Implement a common helper to return a range of KVs in levelDB. Contributed by  Weiwei Yang.

+import org.apache.hadoop.utils.LevelDBKeyFilters.LevelDBKeyFilter;
+import org.iq80.leveldb.Options;
-import org.iq80.leveldb.Options;
+import org.iq80.leveldb.Snapshot;
+import org.iq80.leveldb.ReadOptions;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Map.Entry;
+
+  private static final Logger LOG =
+      LoggerFactory.getLogger(LevelDBStore.class);
+
+
+  /**
+   * Returns a certain range of key value pairs as a list based on a startKey
+   * or count.
+   *
+   * @param keyPrefix start key.
+   * @param count number of entries to return.
+   * @return a range of entries or an empty list if nothing found.
+   * @throws IOException
+   *
+   * @see #getRangeKVs(byte[], int, LevelDBKeyFilter...)
+   */
+  public List<Entry<byte[], byte[]>> getRangeKVs(byte[] keyPrefix, int count)
+      throws IOException {
+    LevelDBKeyFilter emptyFilter = (preKey, currentKey, nextKey) -> true;
+    return getRangeKVs(keyPrefix, count, emptyFilter);
+  }
+
+  /**
+   * Returns a certain range of key value pairs as a list based on a
+   * startKey or count. Further a {@link LevelDBKeyFilter} can be added to
+   * filter keys if necessary. To prevent race conditions while listing
+   * entries, this implementation takes a snapshot and lists the entries from
+   * the snapshot. This may, on the other hand, cause the range result slight
+   * different with actual data if data is updating concurrently.
+   * <p>
+   * If the startKey is specified and found in levelDB, this key and the keys
+   * after this key will be included in the result. If the startKey is null
+   * all entries will be included as long as other conditions are satisfied.
+   * If the given startKey doesn't exist, an IOException will be thrown.
+   * <p>
+   * The count argument is to limit number of total entries to return,
+   * the value for count must be an integer greater than 0.
+   * <p>
+   * This method allows to specify one or more {@link LevelDBKeyFilter}
+   * to filter keys by certain condition. Once given, only the entries
+   * whose key passes all the filters will be included in the result.
+   *
+   * @param startKey a start key.
+   * @param count max number of entries to return.
+   * @param filters customized one or more {@link LevelDBKeyFilter}.
+   * @return a list of entries found in the database.
+   * @throws IOException if an invalid startKey is given or other I/O errors.
+   * @throws IllegalArgumentException if count is less than 0.
+   */
+  public List<Entry<byte[], byte[]>> getRangeKVs(byte[] startKey,
+      int count, LevelDBKeyFilter... filters) throws IOException {
+    List<Entry<byte[], byte[]>> result = new ArrayList<>();
+    long start = System.currentTimeMillis();
+    if (count < 0) {
+      throw new IllegalArgumentException(
+          "Invalid count given " + count + ", count must be greater than 0");
+    }
+    Snapshot snapShot = null;
+    DBIterator dbIter = null;
+    try {
+      snapShot = db.getSnapshot();
+      ReadOptions readOptions = new ReadOptions().snapshot(snapShot);
+      dbIter = db.iterator(readOptions);
+      dbIter.seekToFirst();
+      if (startKey == null) {
+        dbIter.seekToFirst();
+      } else {
+        if (db.get(startKey) == null) {
+          throw new IOException("Invalid start key, not found in current db.");
+        }
+        dbIter.seek(startKey);
+      }
+      while (dbIter.hasNext() && result.size() < count) {
+        byte[] preKey = dbIter.hasPrev() ? dbIter.peekPrev().getKey() : null;
+        byte[] nextKey = dbIter.hasNext() ? dbIter.peekNext().getKey() : null;
+        Entry<byte[], byte[]> current = dbIter.next();
+        if (filters == null || Arrays.asList(filters).stream()
+            .allMatch(entry -> entry.filterKey(preKey,
+                current.getKey(), nextKey))) {
+          result.add(current);
+        }
+      }
+    } finally {
+      if (snapShot != null) {
+        snapShot.close();
+      }
+      if (dbIter != null) {
+        dbIter.close();
+      }
+      long end = System.currentTimeMillis();
+      long timeConsumed = end - start;
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Time consumed for getRangeKVs() is {},"
+                + " result length is {}.",
+            timeConsumed, result.size());
+      }
+    }
+    return result;
+  }

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS74 INS42 INS44 INS44 INS44 INS43 INS8 INS42 INS42 INS32 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS74 INS5 INS42 INS39 INS42 INS42 INS60 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS74 INS5 INS42 INS39 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS60 INS60 INS54 INS41 INS42 INS42 INS57 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS68 INS42 INS43 INS5 INS5 INS39 INS85 INS43 INS59 INS32 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS5 INS5 INS39 INS85 INS42 INS74 INS59 INS39 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS8 INS8 INS42 INS43 INS42 INS69 INS69 INS69 INS42 INS39 INS85 INS39 INS85 INS42 INS42 INS86 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS39 INS85 INS43 INS74 INS42 INS14 INS42 INS32 INS42 INS34 INS53 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS60 INS21 INS21 INS25 INS61 INS25 INS25 INS60 INS60 INS25 INS42 INS5 INS39 INS43 INS59 INS59 INS59 INS9 INS42 INS43 INS5 INS5 INS74 INS42 INS42 INS14 INS7 INS43 INS59 INS7 INS32 INS27 INS8 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS39 INS59 INS39 INS59 INS32 INS8 INS39 INS85 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS39 INS85 INS43 INS43 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS33 INS21 INS25 INS21 INS32 INS27 INS60 INS60 INS60 INS25 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS32 INS42 INS27 INS42 INS42 INS21 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS8 INS32 INS42 INS42 INS32 INS42 INS5 INS59 INS5 INS59 INS74 INS59 INS27 INS8 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS32 INS33 INS53 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS42 INS16 INS39 INS85 INS42 INS16 INS43 INS5 INS5 INS42 INS32 INS27 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS42 INS42 INS14 INS32 INS32 INS33 INS32 INS32 INS33 INS42 INS39 INS85 INS39 INS85 INS42 INS42 INS42 INS33 INS32 INS42 INS86 INS32 INS45 INS45 INS42 INS42 INS43 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42
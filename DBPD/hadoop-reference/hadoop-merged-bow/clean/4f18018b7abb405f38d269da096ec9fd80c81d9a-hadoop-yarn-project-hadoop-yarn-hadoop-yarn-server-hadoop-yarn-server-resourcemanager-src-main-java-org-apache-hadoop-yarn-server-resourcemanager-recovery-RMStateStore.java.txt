YARN-2946. Fixed potential deadlock in RMStateStore. Contributed by Rohith Sharmaks

+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
+  private final ReadLock readLock;
+  private final WriteLock writeLock;
+      .addTransition(RMStateStoreState.ACTIVE, RMStateStoreState.ACTIVE,
+          RMStateStoreEventType.STORE_MASTERKEY,
+              new StoreRMDTMasterKeyTransition())
+      .addTransition(RMStateStoreState.ACTIVE, RMStateStoreState.ACTIVE,
+          RMStateStoreEventType.REMOVE_MASTERKEY,
+              new RemoveRMDTMasterKeyTransition())
+      .addTransition(RMStateStoreState.ACTIVE, RMStateStoreState.ACTIVE,
+          RMStateStoreEventType.STORE_DELEGATION_TOKEN,
+              new StoreRMDTTransition())
+      .addTransition(RMStateStoreState.ACTIVE, RMStateStoreState.ACTIVE,
+          RMStateStoreEventType.REMOVE_DELEGATION_TOKEN,
+              new RemoveRMDTTransition())
+      .addTransition(RMStateStoreState.ACTIVE, RMStateStoreState.ACTIVE,
+          RMStateStoreEventType.UPDATE_DELEGATION_TOKEN,
+              new UpdateRMDTTransition())
+       .addTransition(RMStateStoreState.ACTIVE, RMStateStoreState.ACTIVE,
+           RMStateStoreEventType.UPDATE_AMRM_TOKEN,
+              new StoreOrUpdateAMRMTokenTransition())
-          RMStateStoreEventType.FENCED));
+          RMStateStoreEventType.FENCED,
+          RMStateStoreEventType.STORE_MASTERKEY,
+          RMStateStoreEventType.REMOVE_MASTERKEY,
+          RMStateStoreEventType.STORE_DELEGATION_TOKEN,
+          RMStateStoreEventType.REMOVE_DELEGATION_TOKEN,
+          RMStateStoreEventType.UPDATE_DELEGATION_TOKEN,
+          RMStateStoreEventType.UPDATE_AMRM_TOKEN));
+  private static class StoreRMDTTransition implements
+      SingleArcTransition<RMStateStore, RMStateStoreEvent> {
+    @Override
+    public void transition(RMStateStore store, RMStateStoreEvent event) {
+      if (!(event instanceof RMStateStoreRMDTEvent)) {
+        // should never happen
+        LOG.error("Illegal event type: " + event.getClass());
+        return;
+      }
+      RMStateStoreRMDTEvent dtEvent = (RMStateStoreRMDTEvent) event;
+      try {
+        LOG.info("Storing RMDelegationToken and SequenceNumber");
+        store.storeRMDelegationTokenAndSequenceNumberState(
+            dtEvent.getRmDTIdentifier(), dtEvent.getRenewDate(),
+            dtEvent.getLatestSequenceNumber());
+      } catch (Exception e) {
+        LOG.error("Error While Storing RMDelegationToken and SequenceNumber ",
+            e);
+        store.notifyStoreOperationFailed(e);
+      }
+    }
+  }
+
+  private static class RemoveRMDTTransition implements
+      SingleArcTransition<RMStateStore, RMStateStoreEvent> {
+    @Override
+    public void transition(RMStateStore store, RMStateStoreEvent event) {
+      if (!(event instanceof RMStateStoreRMDTEvent)) {
+        // should never happen
+        LOG.error("Illegal event type: " + event.getClass());
+        return;
+      }
+      RMStateStoreRMDTEvent dtEvent = (RMStateStoreRMDTEvent) event;
+      try {
+        LOG.info("Removing RMDelegationToken and SequenceNumber");
+        store.removeRMDelegationTokenState(dtEvent.getRmDTIdentifier());
+      } catch (Exception e) {
+        LOG.error("Error While Removing RMDelegationToken and SequenceNumber ",
+            e);
+        store.notifyStoreOperationFailed(e);
+      }
+    }
+  }
+
+  private static class UpdateRMDTTransition implements
+      SingleArcTransition<RMStateStore, RMStateStoreEvent> {
+    @Override
+    public void transition(RMStateStore store, RMStateStoreEvent event) {
+      if (!(event instanceof RMStateStoreRMDTEvent)) {
+        // should never happen
+        LOG.error("Illegal event type: " + event.getClass());
+        return;
+      }
+
+      RMStateStoreRMDTEvent dtEvent = (RMStateStoreRMDTEvent) event;
+      try {
+        LOG.info("Updating RMDelegationToken and SequenceNumber");
+        store.updateRMDelegationTokenAndSequenceNumberInternal(
+            dtEvent.getRmDTIdentifier(), dtEvent.getRenewDate(),
+            dtEvent.getLatestSequenceNumber());
+      } catch (Exception e) {
+        LOG.error("Error While Updating RMDelegationToken and SequenceNumber ",
+            e);
+        store.notifyStoreOperationFailed(e);
+      }
+    }
+  }
+
+  private static class StoreRMDTMasterKeyTransition implements
+      SingleArcTransition<RMStateStore, RMStateStoreEvent> {
+    @Override
+    public void transition(RMStateStore store, RMStateStoreEvent event) {
+      if (!(event instanceof RMStateStoreRMDTMasterKeyEvent)) {
+        // should never happen
+        LOG.error("Illegal event type: " + event.getClass());
+        return;
+      }
+      RMStateStoreRMDTMasterKeyEvent dtEvent =
+          (RMStateStoreRMDTMasterKeyEvent) event;
+      try {
+        LOG.info("Storing RMDTMasterKey.");
+        store.storeRMDTMasterKeyState(dtEvent.getDelegationKey());
+      } catch (Exception e) {
+        LOG.error("Error While Storing RMDTMasterKey.", e);
+        store.notifyStoreOperationFailed(e);
+      }
+    }
+  }
+
+  private static class RemoveRMDTMasterKeyTransition implements
+      SingleArcTransition<RMStateStore, RMStateStoreEvent> {
+    @Override
+    public void transition(RMStateStore store, RMStateStoreEvent event) {
+      if (!(event instanceof RMStateStoreRMDTMasterKeyEvent)) {
+        // should never happen
+        LOG.error("Illegal event type: " + event.getClass());
+        return;
+      }
+      RMStateStoreRMDTMasterKeyEvent dtEvent =
+          (RMStateStoreRMDTMasterKeyEvent) event;
+      try {
+        LOG.info("Removing RMDTMasterKey.");
+        store.removeRMDTMasterKeyState(dtEvent.getDelegationKey());
+      } catch (Exception e) {
+        LOG.error("Error While Removing RMDTMasterKey.", e);
+        store.notifyStoreOperationFailed(e);
+      }
+    }
+  }
+
+  private static class StoreOrUpdateAMRMTokenTransition implements
+      SingleArcTransition<RMStateStore, RMStateStoreEvent> {
+    @Override
+    public void transition(RMStateStore store, RMStateStoreEvent event) {
+      if (!(event instanceof RMStateStoreAMRMTokenEvent)) {
+        // should never happen
+        LOG.error("Illegal event type: " + event.getClass());
+        return;
+      }
+      RMStateStoreAMRMTokenEvent amrmEvent = (RMStateStoreAMRMTokenEvent) event;
+
+      try {
+        LOG.info("Updating AMRMToken");
+        store.storeOrUpdateAMRMTokenSecretManagerState(
+            amrmEvent.getAmrmTokenSecretManagerState(), amrmEvent.isUpdate());
+      } catch (Exception e) {
+        LOG.error("Error storing info for AMRMTokenSecretManager", e);
+        store.notifyStoreOperationFailed(e);
+      }
+    }
+  }
+
+    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
+    this.readLock = lock.readLock();
+    this.writeLock = lock.writeLock();
-  public synchronized void updateFencedState() {
-    this.stateMachine.doTransition(RMStateStoreEventType.FENCED,
-         new RMStateStoreEvent(RMStateStoreEventType.FENCED));
+  public void updateFencedState() {
+    handleStoreEvent(new RMStateStoreEvent(RMStateStoreEventType.FENCED));
-  public synchronized void storeRMDelegationTokenAndSequenceNumber(
+  public void storeRMDelegationTokenAndSequenceNumber(
-    if(isFencedState()) {
-      LOG.info("State store is in Fenced state. Can't store RM Delegation Token.");
-      return;
-    }
-    try {
-      storeRMDelegationTokenAndSequenceNumberState(rmDTIdentifier, renewDate,
-          latestSequenceNumber);
-    } catch (Exception e) {
-      notifyStoreOperationFailed(e);
-    }
+    handleStoreEvent(new RMStateStoreRMDTEvent(rmDTIdentifier, renewDate,
+        latestSequenceNumber, RMStateStoreEventType.STORE_DELEGATION_TOKEN));
-  public synchronized void removeRMDelegationToken(
+  public void removeRMDelegationToken(
-    if(isFencedState()) {
-      LOG.info("State store is in Fenced state. Can't remove RM Delegation Token.");
-      return;
-    }
-    try {
-      removeRMDelegationTokenState(rmDTIdentifier);
-    } catch (Exception e) {
-      notifyStoreOperationFailed(e);
-    }
+    handleStoreEvent(new RMStateStoreRMDTEvent(rmDTIdentifier, null,
+        sequenceNumber, RMStateStoreEventType.REMOVE_DELEGATION_TOKEN));
-  public synchronized void updateRMDelegationTokenAndSequenceNumber(
+  public void updateRMDelegationTokenAndSequenceNumber(
-    if(isFencedState()) {
-      LOG.info("State store is in Fenced state. Can't update RM Delegation Token.");
-      return;
-    }
-    try {
-      updateRMDelegationTokenAndSequenceNumberInternal(rmDTIdentifier, renewDate,
-          latestSequenceNumber);
-    } catch (Exception e) {
-      notifyStoreOperationFailed(e);
-    }
+    handleStoreEvent(new RMStateStoreRMDTEvent(rmDTIdentifier, renewDate,
+        latestSequenceNumber, RMStateStoreEventType.UPDATE_DELEGATION_TOKEN));
-  public synchronized void storeRMDTMasterKey(DelegationKey delegationKey) {
-    if(isFencedState()) {
-      LOG.info("State store is in Fenced state. Can't store RM Delegation " +
-               "Token Master key.");
-      return;
-    }
-    try {
-      storeRMDTMasterKeyState(delegationKey);
-    } catch (Exception e) {
-      notifyStoreOperationFailed(e);
-    }
+  public void storeRMDTMasterKey(DelegationKey delegationKey) {
+    handleStoreEvent(new RMStateStoreRMDTMasterKeyEvent(delegationKey,
+        RMStateStoreEventType.STORE_MASTERKEY));
-  public synchronized void removeRMDTMasterKey(DelegationKey delegationKey) {
-   if(isFencedState()) {
-      LOG.info("State store is in Fenced state. Can't remove RM Delegation " +
-               "Token Master key.");
-      return;
-    }
-    try {
-      removeRMDTMasterKeyState(delegationKey);
-    } catch (Exception e) {
-      notifyStoreOperationFailed(e);
-    }
+  public void removeRMDTMasterKey(DelegationKey delegationKey) {
+    handleStoreEvent(new RMStateStoreRMDTMasterKeyEvent(delegationKey,
+        RMStateStoreEventType.REMOVE_MASTERKEY));
-  public abstract void storeOrUpdateAMRMTokenSecretManagerState(
-      AMRMTokenSecretManagerState amrmTokenSecretManagerState,
-      boolean isUpdate);
+  protected abstract void storeOrUpdateAMRMTokenSecretManagerState(
+      AMRMTokenSecretManagerState amrmTokenSecretManagerState, boolean isUpdate)
+      throws Exception;
+
+  /**
+   * Store or Update state of AMRMToken Master Key
+   */
+  public void storeOrUpdateAMRMTokenSecretManager(
+      AMRMTokenSecretManagerState amrmTokenSecretManagerState, boolean isUpdate) {
+    handleStoreEvent(new RMStateStoreAMRMTokenEvent(
+        amrmTokenSecretManagerState, isUpdate,
+        RMStateStoreEventType.UPDATE_AMRM_TOKEN));
+  }
-  synchronized boolean isFencedState() {
-    return (RMStateStoreState.FENCED == this.stateMachine.getCurrentState());
+  protected boolean isFencedState() {
+    return (RMStateStoreState.FENCED == getRMStateStoreState());
+    this.writeLock.lock();
+
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Processing event of type " + event.getType());
+      }
+
+      final RMStateStoreState oldState = getRMStateStoreState();
+
+
+      if (oldState != getRMStateStoreState()) {
+        LOG.info("RMStateStore state change from " + oldState + " to "
+            + getRMStateStoreState());
+      }
+
+    } finally {
+      this.writeLock.unlock();
+
+  public RMStateStoreState getRMStateStoreState() {
+    this.readLock.lock();
+    try {
+      return this.stateMachine.getCurrentState();
+    } finally {
+      this.readLock.unlock();
+    }
+  }

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS55 INS55 INS55 INS55 INS55 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS42 INS74 MOV31 INS83 INS83 INS42 INS74 MOV31 INS83 INS83 INS42 INS74 MOV31 INS83 INS83 INS42 INS74 MOV31 INS83 INS83 INS42 INS74 MOV31 INS83 INS83 INS42 INS74 INS31 MOV29 INS83 INS39 INS42 MOV44 MOV44 MOV44 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV44 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV44 MOV44 INS8 MOV29 INS83 INS39 INS42 MOV44 INS8 MOV29 INS83 INS39 INS42 MOV44 INS8 UPD83 INS43 INS29 INS83 INS39 INS42 INS44 INS44 INS8 UPD83 INS8 INS83 INS43 INS42 INS8 INS42 INS42 INS42 INS42 INS32 INS43 INS43 INS43 INS78 INS42 INS44 INS44 INS43 INS43 INS43 INS78 UPD42 INS44 INS44 INS43 INS43 INS43 INS78 UPD42 INS44 INS44 INS43 INS43 INS43 INS78 INS42 INS44 INS44 INS43 INS43 INS43 INS78 UPD42 INS44 INS44 INS43 INS43 INS43 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS65 INS43 INS42 INS39 INS42 INS21 INS41 INS21 INS42 INS21 INS54 INS32 INS42 INS40 INS40 INS32 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS60 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS60 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS60 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS60 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS60 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS25 INS60 INS54 INS43 INS59 INS7 INS7 INS32 INS32 INS32 INS32 INS32 INS66 INS42 INS32 INS36 INS32 INS8 INS8 INS32 MOV8 INS8 INS32 INS42 INS40 INS40 INS40 INS42 INS42 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS42 INS42 INS38 INS43 INS59 INS42 INS42 INS38 INS43 INS59 INS42 INS42 INS38 INS43 INS59 INS42 INS42 INS38 INS43 INS59 INS42 INS42 INS38 INS43 INS59 INS42 INS42 INS38 INS8 INS43 INS59 INS8 INS12 INS42 INS42 INS14 INS22 INS32 INS22 INS32 INS42 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS27 INS22 INS42 INS25 INS60 MOV21 INS25 INS21 INS22 INS42 INS21 INS32 INS42 INS40 INS40 INS40 INS14 INS36 INS42 INS42 INS11 INS21 INS44 INS36 INS42 INS42 INS11 INS21 MOV44 INS36 INS42 INS42 INS11 INS21 MOV44 INS36 INS42 INS42 INS11 INS21 MOV44 INS36 INS42 INS42 INS11 INS21 MOV44 INS36 INS21 INS41 INS42 INS42 INS11 INS21 INS21 MOV44 INS8 INS43 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS40 INS43 INS42 INS33 INS42 INS40 INS43 INS42 INS42 INS42 INS40 INS43 INS42 INS40 INS43 INS42 INS40 INS43 INS42 INS42 INS40 INS40 INS32 INS52 INS42 INS32 INS8 INS83 INS43 INS59 INS27 INS8 INS32 INS52 INS42 MOV32 INS32 INS32 INS42 INS40 INS40 INS40 INS14 INS43 INS62 INS43 INS42 INS32 INS43 INS42 INS21 INS62 INS43 INS42 INS32 INS21 INS62 INS43 INS42 INS32 INS21 INS62 INS43 INS42 INS32 INS21 INS62 INS43 INS42 INS32 INS21 INS62 INS32 INS43 INS42 INS32 INS32 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS32 INS42 INS32 INS21 INS22 INS42 INS22 INS42 INS32 INS42 INS40 INS40 INS40 INS14 INS43 INS42 INS42 INS43 UPD42 INS27 INS42 INS42 INS42 INS45 INS42 INS32 INS32 INS32 INS42 INS32 INS42 INS43 UPD42 INS27 INS42 INS42 INS42 INS45 INS42 INS32 INS32 INS42 INS43 UPD42 INS27 INS42 INS42 INS42 INS45 INS42 INS32 INS32 INS32 INS32 INS42 INS43 UPD42 INS42 INS42 INS42 INS45 INS42 INS32 INS32 INS42 INS43 UPD42 INS42 INS42 INS42 INS45 INS42 INS32 INS32 INS42 INS43 INS42 INS42 INS27 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS32 INS52 INS42 INS52 INS42 MOV32 INS42 INS40 INS40 INS40 INS14 INS43 INS42 INS42 INS45 INS32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS32 INS42 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS42 UPD45 INS32 INS42 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS42 UPD45 INS32 INS42 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS27 UPD40 UPD40 UPD40 MOV40 INS14 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS42 INS45 INS32 UPD40 UPD40 INS14 INS43 INS42 INS42 INS42 INS42 INS43 INS42 INS42 DEL42 DEL42 DEL40 DEL40 DEL40 DEL40 DEL40 DEL32 DEL83 DEL42 DEL42 DEL32 DEL45 DEL83 DEL42 DEL32 DEL45 DEL83 DEL42 DEL32 DEL45 DEL83 DEL42 DEL42 DEL32 DEL45 DEL83 DEL42 DEL32 DEL45 DEL83 DEL52 DEL42 DEL22 DEL42 DEL40 DEL8 DEL40 DEL27 DEL36
HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68

-        final BlocksMapUpdateInfo collectedBlocks) {
+        final BlocksMapUpdateInfo collectedBlocks, 
+        final List<INodeReference> refNodes) {
+        } else {
+          refNodes.add(d.asReference());
+            } else {
+              // if the node is a reference node, we should continue the 
+              // snapshot deletion process
+              try {
+                // use null as prior here because we are handling a reference
+                // node stored in the created list of a snapshot diff. This 
+                // snapshot diff must be associated with the latest snapshot of
+                // the dst tree before the rename operation. In this scenario,
+                // the prior snapshot should be the one created in the src tree,
+                // and it can be identified by the cleanSubtree since we call
+                // recordModification before the rename.
+                counts.add(inode.cleanSubtree(posterior.snapshot, null,
+                    collectedBlocks));
+              } catch (QuotaExceededException e) {
+                String error = "should not have QuotaExceededException while deleting snapshot";
+                LOG.error(error, e);
+              }
-      counts.add(diff.destroyDeletedList(collectedBlocks));
+      List<INodeReference> refNodes = new ArrayList<INodeReference>();
+      counts.add(diff.destroyDeletedList(collectedBlocks, refNodes));
+      for (INodeReference ref : refNodes) {
+        // if the node is a reference node, we should continue the 
+        // snapshot deletion process
+        try {
+          // Use null as prior snapshot. We are handling a reference node stored
+          // in the delete list of this snapshot diff. We need to destroy this 
+          // snapshot diff because it is the very first one in history.
+          // If the ref node is a WithName instance acting as the src node of
+          // the rename operation, there will not be any snapshot before the
+          // snapshot to be deleted. If the ref node presents the dst node of a 
+          // rename operation, we can identify the corresponding prior snapshot 
+          // when we come into the subtree of the ref node.
+          counts.add(ref.cleanSubtree(this.snapshot, null, collectedBlocks));
+        } catch (QuotaExceededException e) {
+          String error = 
+              "should not have QuotaExceededException while deleting snapshot " 
+              + this.snapshot;
+          LOG.error(error, e);
+        }
+      }
-    return isInLatestSnapshot(latest)?
-        saveSelf2Snapshot(latest, null): this;
+    if (isInLatestSnapshot(latest) && !isInSrcSnapshot(latest)) {
+      return saveSelf2Snapshot(latest, null);
+    }
+    return this;
-  public INodeReference.WithName replaceRemovedChild4Reference(
-      INode oldChild, INodeReference.WithCount newChild, byte[] childName) {
-    final INodeReference.WithName ref = new INodeReference.WithName(this,
-        newChild, childName);
-    newChild.incrementReferenceCount();
-    replaceRemovedChild(oldChild, ref);
-    return ref;
-  }
-
-  /** The child just has been removed, replace it with a reference. */
-      Snapshot s = getDiffs().getPrior(snapshot);
-      if (s != null && 
-          (prior == null || Snapshot.ID_COMPARATOR.compare(s, prior) > 0)) {
-        prior = s;
-      }
+      prior = getDiffs().updatePrior(snapshot, prior);

INS8 INS44 INS25 INS41 INS83 INS74 INS42 INS60 INS70 INS27 MOV8 INS52 INS43 INS43 INS74 INS59 INS44 INS42 INS8 MOV32 INS38 INS21 INS42 INS42 INS43 INS43 INS42 INS14 INS43 INS42 INS54 INS32 MOV32 INS7 INS8 INS42 INS42 INS74 INS42 INS42 INS8 INS12 INS42 INS42 INS42 INS32 INS21 INS43 INS43 INS21 INS44 INS8 MOV32 UPD42 MOV42 UPD42 MOV42 MOV42 INS32 INS42 INS42 INS32 INS43 INS42 INS60 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS22 INS33 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS52 INS42 INS45 INS22 INS8 INS52 INS42 INS54 INS8 INS12 INS21 INS44 INS8 INS32 INS43 INS42 INS60 INS21 INS42 INS42 INS32 INS42 INS43 INS59 INS32 INS42 INS42 INS40 INS33 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 DEL52 DEL16 DEL66 DEL65 DEL29 DEL83 DEL40 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL40 DEL43 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL83 DEL40 DEL43 DEL42 DEL40 DEL43 DEL52 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL40 DEL32 DEL34 DEL27 DEL27 DEL36 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25
HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).

Contributed by Gabor Bota.

Change-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9

- * Some mutating operations, notably {@link #deleteSubtree(Path)} and
- * {@link #move(Collection, Collection)}, are less efficient with this schema.
+ * Some mutating operations, notably
+ * {@link MetadataStore#deleteSubtree(Path, ITtlTimeProvider)} and
+ * {@link MetadataStore#move(Collection, Collection, ITtlTimeProvider)},
+ * are less efficient with this schema.
-  public void delete(Path path) throws IOException {
-    innerDelete(path, true);
+  public void delete(Path path, ITtlTimeProvider ttlTimeProvider)
+      throws IOException {
+    innerDelete(path, true, ttlTimeProvider);
-    innerDelete(path, false);
+    innerDelete(path, false, null);
+   * @param ttlTimeProvider The time provider to set last_updated. Must not
+   *                        be null if tombstone is true.
-  private void innerDelete(final Path path, boolean tombstone)
+  private void innerDelete(final Path path, boolean tombstone,
+      ITtlTimeProvider ttlTimeProvider)
+      Preconditions.checkArgument(ttlTimeProvider != null, "ttlTimeProvider "
+          + "must not be null");
+      final PathMetadata pmTombstone = PathMetadata.tombstone(path);
+      // update the last updated field of record when putting a tombstone
+      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());
-          new DDBPathMetadata(PathMetadata.tombstone(path)));
+          new DDBPathMetadata(pmTombstone));
-  public void deleteSubtree(Path path) throws IOException {
+  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)
+      throws IOException {
-      innerDelete(desc.next().getPath(), true);
+      innerDelete(desc.next().getPath(), true, ttlTimeProvider);
-      Collection<PathMetadata> pathsToCreate) throws IOException {
+      Collection<PathMetadata> pathsToCreate, ITtlTimeProvider ttlTimeProvider)
+      throws IOException {
-        newItems.add(new DDBPathMetadata(PathMetadata.tombstone(meta)));
+        Preconditions.checkArgument(ttlTimeProvider != null, "ttlTimeProvider"
+            + " must not be null");
+        final PathMetadata pmTombstone = PathMetadata.tombstone(meta);
+        pmTombstone.setLastUpdated(ttlTimeProvider.getNow());
+        newItems.add(new DDBPathMetadata(pmTombstone));
-  private ItemCollection<ScanOutcome> expiredFiles(long modTime,
-      String keyPrefix) throws IOException {
-    String filterExpression =
-        "mod_time < :mod_time and begins_with(parent, :parent)";
-    String projectionExpression = "parent,child";
-    ValueMap map = new ValueMap()
-        .withLong(":mod_time", modTime)
-        .withString(":parent", keyPrefix);
+  private ItemCollection<ScanOutcome> expiredFiles(PruneMode pruneMode,
+      long cutoff, String keyPrefix) throws IOException {
+
+    String filterExpression;
+    String projectionExpression;
+    ValueMap map;
+
+    switch (pruneMode) {
+    case ALL_BY_MODTIME:
+      filterExpression =
+          "mod_time < :mod_time and begins_with(parent, :parent)";
+      projectionExpression = "parent,child";
+      map = new ValueMap()
+          .withLong(":mod_time", cutoff)
+          .withString(":parent", keyPrefix);
+      break;
+    case TOMBSTONES_BY_LASTUPDATED:
+      filterExpression =
+          "last_updated < :last_updated and begins_with(parent, :parent) "
+              + "and is_deleted = :is_deleted";
+      projectionExpression = "parent,child";
+      map = new ValueMap()
+          .withLong(":last_updated", cutoff)
+          .withString(":parent", keyPrefix)
+          .withBoolean(":is_deleted", true);
+      break;
+    default:
+      throw new UnsupportedOperationException("Unsupported prune mode: "
+          + pruneMode);
+    }
+
-  public void prune(long modTime) throws IOException {
-    prune(modTime, "/");
+  public void prune(PruneMode pruneMode, long cutoff) throws IOException {
+    prune(pruneMode, cutoff, "/");
-   * @param modTime Oldest modification time to allow
+   *
+   * @param pruneMode The mode of operation for the prune For details see
+   *                  {@link MetadataStore#prune(PruneMode, long)}
+   * @param cutoff Oldest modification time to allow
-  public void prune(long modTime, String keyPrefix) throws IOException {
+  public void prune(PruneMode pruneMode, long cutoff, String keyPrefix)
+      throws IOException {
+    final ItemCollection<ScanOutcome> items =
+        expiredFiles(pruneMode, cutoff, keyPrefix);
+    innerPrune(items);
+  }
+
+  private void innerPrune(ItemCollection<ScanOutcome> items)
+      throws IOException {
-      for (Item item : expiredFiles(modTime, keyPrefix)) {
+      for (Item item : items) {

INS31 INS44 INS44 INS44 INS44 INS44 INS44 MOV29 MOV78 MOV78 INS83 INS39 INS42 INS44 INS44 MOV44 INS43 INS8 UPD83 UPD42 UPD66 INS66 UPD66 INS43 INS42 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 UPD42 INS50 INS43 INS42 UPD42 INS65 INS43 INS42 INS39 INS42 INS42 INS60 INS21 INS74 INS42 MOV69 INS42 INS42 INS66 INS66 INS42 INS42 INS42 INS42 MOV43 MOV43 INS42 INS49 INS21 INS21 INS21 INS10 INS49 INS21 INS21 INS21 INS10 INS49 INS53 INS42 INS42 INS66 INS65 UPD42 INS42 INS83 INS74 INS59 INS32 INS43 INS43 INS42 INS69 INS42 INS69 INS42 INS33 INS21 INS21 INS60 INS42 INS7 INS7 INS7 INS42 INS7 INS7 INS7 INS14 UPD42 INS42 INS68 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS43 INS32 INS83 INS43 INS32 MOV43 INS59 INS42 INS45 INS42 INS45 INS42 MOV32 INS42 INS27 INS42 INS45 INS42 INS32 INS43 INS27 INS42 INS42 INS69 INS69 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS32 INS42 INS21 INS60 INS21 INS45 INS45 INS32 INS42 INS45 INS9 INS42 INS45 INS42 INS43 INS39 INS42 INS33 INS45 INS45 INS42 INS42 INS42 INS42 INS14 INS32 INS83 INS43 INS59 INS32 UPD42 INS32 INS42 INS45 INS42 INS42 MOV43 INS42 INS42 INS42 INS27 INS27 INS42 INS42 MOV32 INS42 INS42 INS32 INS14 INS42 INS45 INS42 INS42 INS33 INS45 INS45 INS42 INS42 INS42 INS43 INS42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL45 DEL45 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32
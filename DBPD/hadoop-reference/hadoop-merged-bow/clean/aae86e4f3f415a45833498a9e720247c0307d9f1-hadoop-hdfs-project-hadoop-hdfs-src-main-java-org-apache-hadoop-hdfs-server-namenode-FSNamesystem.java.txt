merge changes from trunk to HDFS-4949 branch

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524865 13f79535-47bb-0310-9956-ffa450edef68

+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY;
-import org.apache.hadoop.hdfs.server.namenode.NameNode;
+import org.apache.hadoop.hdfs.util.ChunkedArrayList;
+import org.apache.hadoop.security.token.TokenIdentifier;
+import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;
-      logger.logAuditEvent(succeeded, ugi.toString(), addr,
-          cmd, src, dst, status);
+      if (logger instanceof HdfsAuditLogger) {
+        HdfsAuditLogger hdfsLogger = (HdfsAuditLogger) logger;
+        hdfsLogger.logAuditEvent(succeeded, ugi.toString(), addr, cmd, src, dst,
+            status, ugi, dtSecretManager);
+      } else {
+        logger.logAuditEvent(succeeded, ugi.toString(), addr,
+            cmd, src, dst, status);
+      }
-  Daemon smmthread = null;  // SafeModeMonitor thread
+  volatile Daemon smmthread = null;  // SafeModeMonitor thread
-      final INodeFile myFile = INodeFile.valueOf(inode, src, true);
+      INodeFile myFile = INodeFile.valueOf(inode, src, true);
-
+      
+      // recoverLeaseInternal may create a new InodeFile via 
+      // finalizeINodeFileUnderConstruction so we need to refresh 
+      // the referenced file.  
+      myFile = INodeFile.valueOf(dir.getINode(src), src, true);
+      
-    List<INode> removedINodes = new ArrayList<INode>();
+    List<INode> removedINodes = new ChunkedArrayList<INode>();
-    int start = 0;
-    int end = 0;
-    while (start < toDeleteList.size()) {
-      end = BLOCK_DELETION_INCREMENT + start;
-      end = end > toDeleteList.size() ? toDeleteList.size() : end;
+    Iterator<Block> iter = toDeleteList.iterator();
+    while (iter.hasNext()) {
-        for (int i = start; i < end; i++) {
-          blockManager.removeBlock(toDeleteList.get(i));
+        for (int i = 0; i < BLOCK_DELETION_INCREMENT && iter.hasNext(); i++) {
+          blockManager.removeBlock(iter.next());
-      start = end;
-  ContentSummary getContentSummary(String src) throws AccessControlException,
-      FileNotFoundException, UnresolvedLinkException, StandbyException {
+  /**
+   * Get the content summary for a specific file/dir.
+   *
+   * @param src The string representation of the path to the file
+   *
+   * @throws AccessControlException if access is denied
+   * @throws UnresolvedLinkException if a symlink is encountered.
+   * @throws FileNotFoundException if no file exists
+   * @throws StandbyException
+   * @throws IOException for issues with writing to the audit log
+   *
+   * @return object containing information regarding the file
+   *         or null if file not found
+   */
+  ContentSummary getContentSummary(String src) throws IOException {
+    boolean success = true;
+
+    } catch (AccessControlException ace) {
+      success = false;
+      throw ace;
+      logAuditEvent(success, "contentSummary", src);
-        DatanodeDescriptor[] descriptors = null;
+        List<DatanodeDescriptor> targetList =
+            new ArrayList<DatanodeDescriptor>(newtargets.length);
-          descriptors = new DatanodeDescriptor[newtargets.length];
-          for(int i = 0; i < newtargets.length; i++) {
-            descriptors[i] = blockManager.getDatanodeManager().getDatanode(
-                newtargets[i]);
+          for (DatanodeID newtarget : newtargets) {
+            // try to get targetNode
+            DatanodeDescriptor targetNode =
+                blockManager.getDatanodeManager().getDatanode(newtarget);
+            if (targetNode != null)
+              targetList.add(targetNode);
+            else if (LOG.isDebugEnabled()) {
+              LOG.debug("DatanodeDescriptor (=" + newtarget + ") not found");
+            }
-        if ((closeFile) && (descriptors != null)) {
+        if ((closeFile) && !targetList.isEmpty()) {
-          for (int i = 0; i < descriptors.length; i++) {
-            descriptors[i].addBlock(storedBlock);
+          for (DatanodeDescriptor targetNode : targetList) {
+            targetNode.addBlock(storedBlock);
-        pendingFile.setLastBlock(storedBlock, descriptors);
+        DatanodeDescriptor[] targetArray =
+            new DatanodeDescriptor[targetList.size()];
+        pendingFile.setLastBlock(storedBlock, targetList.toArray(targetArray));
-      if (needEnter()) {
+      // if smmthread is already running, the block threshold must have been 
+      // reached before, there is no need to enter the safe mode again
+      if (smmthread == null && needEnter()) {
-      // the threshold is reached
+      // the threshold is reached or was reached before
-      smmthread = new Daemon(new SafeModeMonitor());
-      smmthread.start();
-      reportStatus("STATE* Safe mode extension entered.", true);
+      if (smmthread == null) {
+        smmthread = new Daemon(new SafeModeMonitor());
+        smmthread.start();
+        reportStatus("STATE* Safe mode extension entered.", true);
+      }
-      while (fsRunning && (safeMode != null && !safeMode.canLeave())) {
+      while (fsRunning) {
+        writeLock();
+        try {
+          if (safeMode == null) { // Not in safe mode.
+            break;
+          }
+          if (safeMode.canLeave()) {
+            // Leave safe mode.
+            safeMode.leave();
+            smmthread = null;
+            break;
+          }
+        } finally {
+          writeUnlock();
+        }
+
-      } else {
-        // leave safe mode and stop the monitor
-        leaveSafeMode();
-      smmthread = null;
-        DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL, this);
+        DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL,
+        conf.getBoolean(DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY,
+            DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT),
+        this);
+      innerinfo.put("version", node.getSoftwareVersion());
+  @Override // NameNodeMxBean
+  public String getJournalTransactionInfo() {
+    Map<String, String> txnIdMap = new HashMap<String, String>();
+    txnIdMap.put("LastAppliedOrWrittenTxId",
+        Long.toString(this.getFSImage().getLastAppliedOrWrittenTxId()));
+    txnIdMap.put("MostRecentCheckpointTxId",
+        Long.toString(this.getFSImage().getMostRecentCheckpointTxId()));
+    return JSON.toString(txnIdMap);
+  }
+  
+  @Override  //NameNodeMXBean
+  public int getDistinctVersionCount() {
+    return blockManager.getDatanodeManager().getDatanodesSoftwareVersions()
+      .size();
+  }
+
+  @Override  //NameNodeMXBean
+  public Map<String, Integer> getDistinctVersions() {
+    return blockManager.getDatanodeManager().getDatanodesSoftwareVersions();
+  }
+
+  @Override  //NameNodeMXBean
+  public String getSoftwareVersion() {
+    return VersionInfo.getVersion();
+  }
+
+    checkOperation(OperationCategory.WRITE);
-      List<INode> removedINodes = new ArrayList<INode>();
+      List<INode> removedINodes = new ChunkedArrayList<INode>();
-  private static class DefaultAuditLogger implements AuditLogger {
+  private static class DefaultAuditLogger extends HdfsAuditLogger {
+
+    private boolean logTokenTrackingId;
-      // Nothing to do.
+      logTokenTrackingId = conf.getBoolean(
+          DFSConfigKeys.DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY,
+          DFSConfigKeys.DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT);
-        FileStatus status) {
+        FileStatus status, UserGroupInformation ugi,
+        DelegationTokenSecretManager dtSecretManager) {
+        if (logTokenTrackingId) {
+          sb.append("\t").append("trackingId=");
+          String trackingId = null;
+          if (ugi != null && dtSecretManager != null
+              && ugi.getAuthenticationMethod() == AuthenticationMethod.TOKEN) {
+            for (TokenIdentifier tid: ugi.getTokenIdentifiers()) {
+              if (tid instanceof DelegationTokenIdentifier) {
+                DelegationTokenIdentifier dtid =
+                    (DelegationTokenIdentifier)tid;
+                trackingId = dtSecretManager.getTokenTrackingId(dtid);
+                break;
+              }
+            }
+          }
+          sb.append(trackingId);
+        }

MOV26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS83 MOV29 MOV39 MOV42 MOV44 INS8 INS29 INS42 UPD43 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS74 INS42 INS8 INS78 INS83 INS43 INS42 INS8 UPD43 INS23 MOV60 MOV60 INS61 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD42 INS60 INS42 INS42 INS60 INS21 INS21 INS41 INS42 INS41 INS42 INS43 INS43 INS43 INS41 INS42 INS42 INS41 INS21 UPD42 INS83 INS39 INS59 INS44 INS44 INS8 INS59 INS74 INS32 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS66 INS66 INS66 INS39 INS59 INS12 INS25 INS74 INS59 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS21 INS43 INS42 INS43 INS42 INS25 INS21 INS42 INS14 INS43 INS43 INS42 INS32 INS42 INS42 MOV21 INS54 INS42 INS9 INS44 INS8 INS21 INS27 INS27 INS8 INS42 INS32 INS21 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS45 INS32 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS32 INS42 INS32 UPD42 MOV42 INS42 INS42 INS42 INS40 INS7 INS42 INS42 INS62 INS8 MOV8 INS7 INS74 INS42 INS42 INS42 INS42 INS8 MOV8 MOV43 INS42 INS21 INS53 INS32 INS27 MOV32 INS42 INS33 MOV21 MOV21 MOV21 INS21 INS54 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS74 INS42 UPD42 MOV42 INS32 INS42 UPD42 MOV42 INS32 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS25 INS42 INS43 INS60 INS21 INS42 INS32 INS43 MOV43 INS24 INS7 INS42 INS42 INS42 INS45 INS42 INS60 INS42 INS33 INS32 INS8 INS8 INS42 INS42 INS45 INS32 INS43 INS43 INS43 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS8 INS42 INS43 INS59 INS32 INS42 INS42 INS32 INS42 INS9 INS42 MOV58 INS27 MOV37 INS8 INS42 INS9 INS74 MOV59 INS8 MOV5 INS59 INS42 INS25 INS25 INS21 INS42 INS42 INS42 INS42 INS42 INS52 UPD42 MOV42 INS52 UPD42 MOV42 UPD74 INS21 INS60 INS25 INS21 INS42 INS42 INS11 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 MOV32 MOV21 INS43 INS43 UPD42 INS70 INS38 INS70 INS42 INS3 INS32 INS27 INS8 MOV32 INS8 INS32 UPD43 INS32 INS43 INS59 INS27 INS8 INS32 INS43 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 UPD42 INS32 INS42 INS42 UPD74 INS40 INS44 INS42 INS8 INS32 INS44 INS42 INS8 MOV5 INS32 UPD42 MOV42 INS42 INS42 INS42 INS33 INS10 INS21 MOV21 INS10 INS42 UPD42 INS32 INS42 INS45 INS42 INS42 INS33 INS27 INS27 INS70 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS43 INS42 INS60 INS25 INS42 INS42 INS43 INS42 MOV21 INS42 INS42 INS32 INS42 INS42 INS45 INS27 INS27 INS32 INS40 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS21 INS25 INS42 INS42 INS42 INS42 INS33 INS42 INS33 INS42 INS42 INS43 INS42 INS42 INS42 INS25 INS42 INS42 MOV32 UPD42 MOV42 INS33 INS32 INS32 INS8 INS42 INS42 INS62 INS8 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 INS42 INS43 INS60 INS21 INS10 INS32 INS42 INS43 INS59 INS7 INS42 INS42 INS27 INS42 INS42 INS11 INS42 INS32 INS45 INS42 INS45 INS43 INS42 INS42 INS42 INS42 INS42 DEL83 DEL39 DEL42 DEL34 DEL42 DEL42 DEL42 DEL27 DEL7 DEL39 DEL42 DEL34 DEL59 DEL60 DEL27 DEL42 DEL42 DEL32 DEL27 DEL32 DEL42 DEL16 DEL7 DEL21 DEL39 DEL42 DEL42 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL8 DEL54 DEL42 DEL42 DEL7 DEL21 DEL8 DEL61 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL33 DEL59 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL7 DEL42 DEL40 DEL3 DEL7 DEL21 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL8 DEL42 DEL33 DEL27 DEL36 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL42 DEL42 DEL33 DEL27 DEL38 DEL27 DEL36 DEL27 DEL42 DEL32 DEL21 DEL8
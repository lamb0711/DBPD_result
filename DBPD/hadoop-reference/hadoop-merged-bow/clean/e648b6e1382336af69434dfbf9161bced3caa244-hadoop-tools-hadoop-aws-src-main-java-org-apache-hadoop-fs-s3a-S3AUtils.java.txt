HADOOP-13336 S3A to support per-bucket configuration. Contributed by Steve Loughran

+
+import com.google.common.collect.Lists;
+import java.util.Collection;
+import java.util.List;
-import static org.apache.hadoop.fs.s3a.Constants.ACCESS_KEY;
-import static org.apache.hadoop.fs.s3a.Constants.AWS_CREDENTIALS_PROVIDER;
-import static org.apache.hadoop.fs.s3a.Constants.ENDPOINT;
-import static org.apache.hadoop.fs.s3a.Constants.MULTIPART_MIN_SIZE;
-import static org.apache.hadoop.fs.s3a.Constants.SECRET_KEY;
+import static org.apache.hadoop.fs.s3a.Constants.*;
+  /**
+   * Core property for provider path. Duplicated here for consistent
+   * code across Hadoop version: {@value}.
+   */
+  static final String CREDENTIAL_PROVIDER_PATH =
+      "hadoop.security.credential.provider.path";
+
+
+  /**
+   * Propagates bucket-specific settings into generic S3A configuration keys.
+   * This is done by propagating the values of the form
+   * {@code fs.s3a.bucket.${bucket}.key} to
+   * {@code fs.s3a.key}, for all values of "key" other than a small set
+   * of unmodifiable values.
+   *
+   * The source of the updated property is set to the key name of the bucket
+   * property, to aid in diagnostics of where things came from.
+   *
+   * Returns a new configuration. Why the clone?
+   * You can use the same conf for different filesystems, and the original
+   * values are not updated.
+   *
+   * The {@code fs.s3a.impl} property cannot be set, nor can
+   * any with the prefix {@code fs.s3a.bucket}.
+   *
+   * This method does not propagate security provider path information from
+   * the S3A property into the Hadoop common provider: callers must call
+   * {@link #patchSecurityCredentialProviders(Configuration)} explicitly.
+   * @param source Source Configuration object.
+   * @param bucket bucket name. Must not be empty.
+   * @return a (potentially) patched clone of the original.
+   */
+  public static Configuration propagateBucketOptions(Configuration source,
+      String bucket) {
+
+    Preconditions.checkArgument(StringUtils.isNotEmpty(bucket), "bucket");
+    final String bucketPrefix = FS_S3A_BUCKET_PREFIX + bucket +'.';
+    LOG.debug("Propagating entries under {}", bucketPrefix);
+    final Configuration dest = new Configuration(source);
+    for (Map.Entry<String, String> entry : source) {
+      final String key = entry.getKey();
+      // get the (unexpanded) value.
+      final String value = entry.getValue();
+      if (!key.startsWith(bucketPrefix) || bucketPrefix.equals(key)) {
+        continue;
+      }
+      // there's a bucket prefix, so strip it
+      final String stripped = key.substring(bucketPrefix.length());
+      if (stripped.startsWith("bucket.") || "impl".equals(stripped)) {
+        //tell user off
+        LOG.debug("Ignoring bucket option {}", key);
+      }  else {
+        // propagate the value, building a new origin field.
+        // to track overwrites, the generic key is overwritten even if
+        // already matches the new one.
+        final String generic = FS_S3A_PREFIX + stripped;
+        LOG.debug("Updating {}", generic);
+        dest.set(generic, value, key);
+      }
+    }
+    return dest;
+  }
+
+  /**
+   * Patch the security credential provider information in
+   * {@link #CREDENTIAL_PROVIDER_PATH}
+   * with the providers listed in
+   * {@link Constants#S3A_SECURITY_CREDENTIAL_PROVIDER_PATH}.
+   *
+   * This allows different buckets to use different credential files.
+   * @param conf configuration to patch
+   */
+  static void patchSecurityCredentialProviders(Configuration conf) {
+    Collection<String> customCredentials = conf.getStringCollection(
+        S3A_SECURITY_CREDENTIAL_PROVIDER_PATH);
+    Collection<String> hadoopCredentials = conf.getStringCollection(
+        CREDENTIAL_PROVIDER_PATH);
+    if (!customCredentials.isEmpty()) {
+      List<String> all = Lists.newArrayList(customCredentials);
+      all.addAll(hadoopCredentials);
+      String joined = StringUtils.join(all, ',');
+      LOG.debug("Setting {} to {}", CREDENTIAL_PROVIDER_PATH,
+          joined);
+      conf.set(CREDENTIAL_PROVIDER_PATH, joined,
+          "patch of " + S3A_SECURITY_CREDENTIAL_PROVIDER_PATH);
+    }
+  }

MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 INS23 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS65 INS42 INS42 INS45 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS21 INS60 INS21 INS60 INS70 INS41 INS65 INS65 INS43 INS42 INS60 INS60 INS25 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS83 INS43 INS59 INS32 INS83 INS43 INS59 INS44 INS42 INS8 INS42 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS74 INS59 INS74 INS59 INS38 INS8 INS66 INS66 INS66 INS68 INS42 INS42 INS32 INS45 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS14 INS74 INS42 INS60 INS60 INS25 INS60 INS25 INS67 INS67 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS32 INS32 INS60 INS21 INS60 INS21 INS21 INS42 INS69 INS42 INS42 INS42 INS42 INS42 INS13 INS43 INS42 INS43 INS43 INS43 INS83 INS43 INS59 INS83 INS43 INS59 INS27 INS8 INS83 INS43 INS59 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS59 INS32 INS43 INS59 INS32 INS32 INS43 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS38 INS32 INS18 INS42 INS42 INS32 INS32 INS32 INS21 INS60 INS21 INS21 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS45 INS42 INS42 INS32 INS83 INS43 INS59 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS13 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26
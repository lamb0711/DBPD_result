HDDS-1262. In OM HA OpenKey call Should happen only leader OM. (#626)


-import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;
+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos
+    .KeyArgs;
+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos
+    .KeyInfo;
+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos
+    .KeyLocation;
-      OzoneManagerProtocolProtos.KeyLocation keyLocation) throws IOException {
+      KeyLocation keyLocation) throws IOException {
-    metadataManager.getOpenKeyTable().put(openKey, keyInfo);
+
+    // When OM is not managed via ratis we should write in to Om db in
+    // openKey call.
+    if (!isRatisEnabled) {
+      metadataManager.getOpenKeyTable().put(openKey, keyInfo);
+    }
+  public void applyOpenKey(KeyArgs omKeyArgs,
+      KeyInfo keyInfo, long clientID) throws IOException {
+    Preconditions.checkNotNull(omKeyArgs);
+    String volumeName = omKeyArgs.getVolumeName();
+    String bucketName = omKeyArgs.getBucketName();
+
+    // Do we need to call again validateBucket, as this is just called after
+    // start Transaction from applyTransaction. Can we remove this double
+    // check?
+    validateBucket(volumeName, bucketName);
+
+    metadataManager.getLock().acquireBucketLock(volumeName, bucketName);
+    String keyName = omKeyArgs.getKeyName();
+
+    // TODO: here if on OM machines clocks are skewed and there is a chance
+    //  for override of the openKey entries.
+    try {
+      String openKey = metadataManager.getOpenKey(
+          volumeName, bucketName, keyName, clientID);
+
+      OmKeyInfo omKeyInfo = OmKeyInfo.getFromProtobuf(keyInfo);
+
+      metadataManager.getOpenKeyTable().put(openKey,
+          omKeyInfo);
+    } catch (IOException ex) {
+      LOG.error("Apply Open Key failed for volume:{} bucket:{} key:{}",
+          volumeName, bucketName, keyName, ex);
+      throw new OMException(ex.getMessage(),
+          ResultCodes.KEY_ALLOCATION_ERROR);
+    } finally {
+      metadataManager.getLock().releaseBucketLock(volumeName, bucketName);
+    }
+  }
+
-    Preconditions.checkNotNull(omKeyArgs);
-    String volumeName = omKeyArgs.getVolumeName();
-    String bucketName = omKeyArgs.getBucketName();
-    String keyName = omKeyArgs.getKeyName();
+    long time = Time.monotonicNowNanos();
+    String uploadID = UUID.randomUUID().toString() + "-" + time;
+    return applyInitiateMultipartUpload(omKeyArgs, uploadID);
+  }
+
+  public OmMultipartInfo applyInitiateMultipartUpload(OmKeyArgs keyArgs,
+      String multipartUploadID) throws IOException {
+    Preconditions.checkNotNull(keyArgs);
+    Preconditions.checkNotNull(multipartUploadID);
+    String volumeName = keyArgs.getVolumeName();
+    String bucketName = keyArgs.getBucketName();
+    String keyName = keyArgs.getKeyName();
-      long time = Time.monotonicNowNanos();
-      String uploadID = UUID.randomUUID().toString() + "-" + Long.toString(
-          time);
-          bucketName, keyName, uploadID);
+          bucketName, keyName, multipartUploadID);
-      OmMultipartKeyInfo multipartKeyInfo = new OmMultipartKeyInfo(uploadID,
-          partKeyInfoMap);
+      OmMultipartKeyInfo multipartKeyInfo = new OmMultipartKeyInfo(
+          multipartUploadID, partKeyInfoMap);
-          .setVolumeName(omKeyArgs.getVolumeName())
-          .setBucketName(omKeyArgs.getBucketName())
-          .setKeyName(omKeyArgs.getKeyName())
+          .setVolumeName(keyArgs.getVolumeName())
+          .setBucketName(keyArgs.getBucketName())
+          .setKeyName(keyArgs.getKeyName())
-          .setReplicationType(omKeyArgs.getType())
-          .setReplicationFactor(omKeyArgs.getFactor())
+          .setReplicationType(keyArgs.getType())
+          .setReplicationFactor(keyArgs.getFactor())
-        return new OmMultipartInfo(volumeName, bucketName, keyName, uploadID);
+        return new OmMultipartInfo(volumeName, bucketName, keyName,
+            multipartUploadID);
-              "key:{}", volumeName, bucketName, keyName, ex);
+          "key:{}", volumeName, bucketName, keyName, ex);

INS26 INS26 UPD40 INS40 INS40 INS31 INS31 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 MOV78 INS83 INS43 INS42 MOV44 INS43 INS8 UPD42 INS44 INS44 UPD43 INS25 INS43 INS42 INS43 INS42 INS39 INS42 INS42 MOV21 MOV60 MOV60 INS21 INS21 MOV60 INS54 INS42 INS42 MOV60 MOV60 INS41 INS43 INS42 MOV43 INS42 INS21 INS21 INS60 INS60 INS60 INS42 INS38 INS8 INS42 INS42 INS32 INS32 INS8 INS12 INS8 INS32 INS42 INS32 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS42 MOV21 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS60 INS60 INS21 INS44 INS8 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS43 INS42 INS21 INS53 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 MOV43 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS14 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS32 INS40 INS42 INS42 UPD42 MOV43 UPD42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL40 DEL42 DEL42 DEL42 DEL32
HDFS-2108. Move datanode heartbeat handling from namenode package to blockmanagement package.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1154042 13f79535-47bb-0310-9956-ffa450edef68

-import static org.apache.hadoop.hdfs.server.common.Util.now;
-
+import org.apache.hadoop.hdfs.protocol.ExtendedBlock;
-  /** get the block key update interval */
-  public long getBlockKeyUpdateInterval() {
-    return blockKeyUpdateInterval;
-  }
-
-  
+  private final HeartbeatManager heartbeatManager;
+
-  public int maxReplicationStreams;
+  int maxReplicationStreams;
-
-  /**
-   * Update access keys.
-   */
-  public void updateBlockKey() throws IOException {
-    this.blockTokenSecretManager.updateKeys();
-    synchronized (namesystem.heartbeats) {
-      for (DatanodeDescriptor nodeInfo : namesystem.heartbeats) {
-        nodeInfo.needKeyUpdate = true;
-      }
-    }
-  }
-    datanodeManager = new DatanodeManager(fsn, conf);
+    datanodeManager = new DatanodeManager(this, fsn, conf);
+    heartbeatManager = datanodeManager.getHeartbeatManager();
+
+  /** @return maxReplicationStreams */
+  public int getMaxReplicationStreams() {
+    return maxReplicationStreams;
+  }
+
-      return namesystem.createLocatedBlock(uc, locations, pos, false);
+      final ExtendedBlock eb = new ExtendedBlock(namesystem.getBlockPoolId(), blk);
+      return new LocatedBlock(eb, locations, pos, false);
-    return namesystem.createLocatedBlock(blk, machines, pos, isCorrupt);
+    final ExtendedBlock eb = new ExtendedBlock(namesystem.getBlockPoolId(), blk);
+    return new LocatedBlock(eb, machines, pos, isCorrupt);
-  /** Remove a datanode. */
-  public void removeDatanode(final DatanodeDescriptor node) {
+  /** Remove the blocks associated to the given datanode. */
+  void removeBlocksAssociatedTo(final DatanodeDescriptor node) {
-    datanodeManager.getNetworkTopology().remove(node);
-
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("remove datanode " + node.getName());
-    }
-  public int computeInvalidateWork(int nodesToProcess) {
+  int computeInvalidateWork(int nodesToProcess) {
-  public int computeReplicationWork(int blocksToProcess) throws IOException {
+  private int computeReplicationWork(int blocksToProcess) throws IOException {
-  private void processOverReplicatedBlocksOnReCommission(
+  void processOverReplicatedBlocksOnReCommission(
+
+  /** Should the access keys be updated? */
+  boolean shouldUpdateBlockKey(final long updateTime) throws IOException {
+    final boolean b = isBlockTokenEnabled && blockKeyUpdateInterval < updateTime;
+    if (b) {
+      blockTokenSecretManager.updateKeys();
+    }
+    return b;
+  }
+
-   * Change, if appropriate, the admin state of a datanode to 
-   * decommission completed. Return true if decommission is complete.
-   */
-  boolean checkDecommissionStateInternal(DatanodeDescriptor node) {
-    // Check to see if all blocks in this decommissioned
-    // node has reached their target replication factor.
-    if (node.isDecommissionInProgress()) {
-      if (!isReplicationInProgress(node)) {
-        node.setDecommissioned();
-        LOG.info("Decommission complete for node " + node.getName());
-      }
-    }
-    return node.isDecommissioned();
-  }
-
-  /** Start decommissioning the specified datanode. */
-  void startDecommission(DatanodeDescriptor node) throws IOException {
-    if (!node.isDecommissionInProgress() && !node.isDecommissioned()) {
-      LOG.info("Start Decommissioning node " + node.getName() + " with " + 
-          node.numBlocks() +  " blocks.");
-      synchronized (namesystem.heartbeats) {
-        namesystem.updateStats(node, false);
-        node.startDecommission();
-        namesystem.updateStats(node, true);
-      }
-      node.decommissioningStatus.setStartTime(now());
-      
-      // all the blocks that reside on this node have to be replicated.
-      checkDecommissionStateInternal(node);
-    }
-  }
-
-  /** Stop decommissioning the specified datanodes. */
-  void stopDecommission(DatanodeDescriptor node) throws IOException {
-    if (node.isDecommissionInProgress() || node.isDecommissioned()) {
-      LOG.info("Stop Decommissioning node " + node.getName());
-      synchronized (namesystem.heartbeats) {
-        namesystem.updateStats(node, false);
-        node.stopDecommission();
-        namesystem.updateStats(node, true);
-      }
-      processOverReplicatedBlocksOnReCommission(node);
-    }
-  }
-
-  /**
-    static final int INVALIDATE_WORK_PCT_PER_ITERATION = 32;
-    static final float REPLICATION_WORK_MULTIPLIER_PER_ITERATION = 2;
+    private static final int INVALIDATE_WORK_PCT_PER_ITERATION = 32;
+    private static final int REPLICATION_WORK_MULTIPLIER_PER_ITERATION = 2;
-    int blocksToProcess = 0;
-    int nodesToProcess = 0;
-    synchronized (namesystem.heartbeats) {
-      blocksToProcess = (int) (namesystem.heartbeats.size() * ReplicationMonitor.REPLICATION_WORK_MULTIPLIER_PER_ITERATION);
-      nodesToProcess = (int) Math.ceil((double) namesystem.heartbeats.size()
-          * ReplicationMonitor.INVALIDATE_WORK_PCT_PER_ITERATION / 100);
-    }
+    final int numlive = heartbeatManager.getLiveDatanodeCount();
+    final int blocksToProcess = numlive
+        * ReplicationMonitor.REPLICATION_WORK_MULTIPLIER_PER_ITERATION;
+    final int nodesToProcess = (int) Math.ceil(numlive
+        * ReplicationMonitor.INVALIDATE_WORK_PCT_PER_ITERATION / 100.0);

MOV26 MOV31 MOV31 UPD40 INS23 INS83 INS83 INS43 INS59 INS83 UPD39 UPD42 UPD42 UPD83 UPD39 UPD42 MOV60 UPD42 MOV42 INS42 INS21 UPD65 INS60 INS41 INS83 INS39 UPD42 INS60 INS25 INS41 INS83 INS83 UPD39 INS60 INS60 INS7 UPD66 INS42 INS83 INS43 INS59 INS14 UPD66 UPD66 INS83 INS39 INS59 INS42 INS8 INS42 INS83 INS83 MOV39 INS59 INS83 INS39 INS59 INS42 INS32 INS60 INS41 INS42 INS42 INS14 INS43 INS42 INS42 INS42 INS42 INS42 INS27 MOV21 UPD42 INS32 INS42 INS27 INS42 INS11 INS52 INS42 INS42 INS83 INS43 INS59 INS14 INS43 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 MOV40 MOV39 MOV32 INS42 INS42 INS14 INS43 INS42 INS42 INS42 INS9 INS42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 INS43 INS32 INS42 INS42 UPD34 INS42 MOV42 INS42 INS42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL40 DEL42 DEL43 DEL42 DEL44 DEL40 DEL40 DEL9 DEL7 DEL21 DEL8 DEL70 DEL8 DEL51 DEL8 DEL31 DEL66 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL41 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL83 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL83 DEL83 DEL42 DEL43 DEL42 DEL9 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL32 DEL21 DEL40 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL51 DEL40 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL40 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL51 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL34 DEL59 DEL60 DEL34 DEL39 DEL40 DEL42 DEL32 DEL11 DEL40 DEL42 DEL39 DEL40 DEL42 DEL32 DEL27 DEL36 DEL11 DEL7 DEL21 DEL42 DEL11 DEL7 DEL21 DEL8 DEL51
HDFS-8269. getBlockLocations() does not resolve the .reserved path and generates incorrect edit logs when updating the atime. Contributed by Haohui Mai.

-    final INodesInPath iip;
+    final boolean updateAccessTime;
-      return iip != null;
+      return updateAccessTime;
-    private GetBlockLocationsResult(INodesInPath iip, LocatedBlocks blocks) {
-      this.iip = iip;
+    private GetBlockLocationsResult(
+        boolean updateAccessTime, LocatedBlocks blocks) {
+      this.updateAccessTime = updateAccessTime;
-  LocatedBlocks getBlockLocations(String clientMachine, String src,
+  LocatedBlocks getBlockLocations(String clientMachine, String srcArg,
+    FSPermissionChecker pc = getPermissionChecker();
-      res = getBlockLocations(src, offset, length, true, true);
+      res = getBlockLocations(pc, srcArg, offset, length, true, true);
-      logAuditEvent(false, "open", src);
+      logAuditEvent(false, "open", srcArg);
-    logAuditEvent(true, "open", src);
+    logAuditEvent(true, "open", srcArg);
+      byte[][] pathComponents = FSDirectory.getPathComponentsForReservedPath(
+          srcArg);
+      String src = srcArg;
-        INode inode = res.iip.getLastINode();
-        boolean updateAccessTime = now > inode.getAccessTime() +
-            getAccessTimePrecision();
+        /**
+         * Resolve the path again and update the atime only when the file
+         * exists.
+         *
+         * XXX: Races can still occur even after resolving the path again.
+         * For example:
+         *
+         * <ul>
+         *   <li>Get the block location for "/a/b"</li>
+         *   <li>Rename "/a/b" to "/c/b"</li>
+         *   <li>The second resolution still points to "/a/b", which is
+         *   wrong.</li>
+         * </ul>
+         *
+         * The behavior is incorrect but consistent with the one before
+         * HDFS-7463. A better fix is to change the edit log of SetTime to
+         * use inode id instead of a path.
+         */
+        src = dir.resolvePath(pc, srcArg, pathComponents);
+        final INodesInPath iip = dir.getINodesInPath(src, true);
+        INode inode = iip.getLastINode();
+        boolean updateAccessTime = inode != null &&
+            now > inode.getAccessTime() + getAccessTimePrecision();
-              inode, -1, now, false, res.iip.getLatestSnapshotId());
+              inode, -1, now, false, iip.getLatestSnapshotId());
-      String src, long offset, long length, boolean needBlockToken,
-      boolean checkSafeMode) throws IOException {
+      FSPermissionChecker pc, String src, long offset, long length,
+      boolean needBlockToken, boolean checkSafeMode) throws IOException {
-        src, offset, length, needBlockToken);
+        pc, src, offset, length, needBlockToken);
-      final String srcArg, long offset, long length, boolean needBlockToken)
+      FSPermissionChecker pc, final String srcArg, long offset, long length,
+      boolean needBlockToken)
-    FSPermissionChecker pc = getPermissionChecker();
-    src = dir.resolvePath(pc, src, pathComponents);
+    src = dir.resolvePath(pc, srcArg, pathComponents);
-    return new GetBlockLocationsResult(updateAccessTime ? iip : null, blocks);
+    return new GetBlockLocationsResult(updateAccessTime, blocks);

INS44 INS44 INS39 UPD42 MOV60 INS43 INS42 INS43 INS42 UPD42 INS39 INS42 INS42 INS42 INS42 UPD42 INS60 INS60 INS42 UPD42 INS5 INS59 INS43 INS59 INS42 UPD42 UPD42 INS39 INS85 INS85 INS42 INS32 INS42 INS42 INS42 INS21 INS60 INS42 UPD42 UPD42 INS42 INS42 INS42 INS7 INS83 INS43 INS59 INS42 INS32 INS42 INS42 INS32 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS27 MOV27 INS42 INS33 INS42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL40 DEL40 DEL42 DEL42 DEL33 DEL16
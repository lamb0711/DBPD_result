YARN-5355: YARN Timeline Service v.2: alpha 2 (varunsaxena)

-
+import org.apache.hadoop.yarn.server.api.records.AppCollectorData;
-
-                      .getRegisteredCollectors());
+                      .getRegisteringCollectors());
-            updateTimelineClientsAddress(response);
+            updateTimelineCollectorData(response);
-    private void updateTimelineClientsAddress(
+    private void updateTimelineCollectorData(
-      Map<ApplicationId, String> knownCollectorsMap =
-          response.getAppCollectorsMap();
-      if (knownCollectorsMap == null) {
+      Map<ApplicationId, AppCollectorData> incomingCollectorsMap =
+          response.getAppCollectors();
+      if (incomingCollectorsMap == null) {
-      } else {
-        Set<Map.Entry<ApplicationId, String>> rmKnownCollectors =
-            knownCollectorsMap.entrySet();
-        for (Map.Entry<ApplicationId, String> entry : rmKnownCollectors) {
-          ApplicationId appId = entry.getKey();
-          String collectorAddr = entry.getValue();
+        return;
+      }
+      Map<ApplicationId, AppCollectorData> knownCollectors =
+          context.getKnownCollectors();
+      for (Map.Entry<ApplicationId, AppCollectorData> entry
+          : incomingCollectorsMap.entrySet()) {
+        ApplicationId appId = entry.getKey();
+        AppCollectorData collectorData = entry.getValue();
-          // Only handle applications running on local node.
-          // Not include apps with timeline collectors running in local
-          Application application = context.getApplications().get(appId);
-          // TODO this logic could be problematic if the collector address
-          // gets updated due to NM restart or collector service failure
-          if (application != null &&
-              !context.getRegisteredCollectors().containsKey(appId)) {
+        // Only handle applications running on local node.
+        Application application = context.getApplications().get(appId);
+        if (application != null) {
+          // Update collector data if the newly received data happens after
+          // the known data (updates the known data).
+          AppCollectorData existingData = knownCollectors.get(appId);
+          if (AppCollectorData.happensBefore(existingData, collectorData)) {
-              LOG.debug("Sync a new collector address: " + collectorAddr +
-                      " for application: " + appId + " from RM.");
+              LOG.debug("Sync a new collector address: "
+                  + collectorData.getCollectorAddr()
+                  + " for application: " + appId + " from RM.");
+            // Update information for clients.
-                  application.getAppId(), collectorAddr);
+                  application.getAppId(), collectorData.getCollectorAddr());
+            // Update information for the node manager itself.
+            knownCollectors.put(appId, collectorData);
+        // Remove the registering collector data
+        context.getRegisteringCollectors().remove(entry.getKey());

INS26 INS40 UPD42 MOV8 MOV60 INS25 UPD74 INS27 MOV8 UPD74 INS32 UPD43 UPD42 INS42 INS33 INS41 UPD43 MOV43 UPD43 MOV43 UPD42 UPD74 INS42 INS42 INS25 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 MOV27 INS8 INS32 UPD42 UPD42 UPD42 INS60 MOV25 INS32 INS42 INS32 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS21 INS42 INS42 INS42 INS32 UPD42 UPD42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 UPD42 MOV42 INS42 INS42 DEL40 DEL43 DEL74 DEL42 DEL32 DEL32 DEL38 DEL27 DEL42 DEL42 DEL33 DEL27 DEL25 DEL8
HADOOP-13208. S3A listFiles(recursive=true) to do a bulk listObjects instead of walking the pseudo-tree of directories. Contributed by Steve Loughran.

+import static org.apache.hadoop.fs.s3a.Listing.ACCEPT_ALL;
+  private Listing listing;
+      listing = new Listing(this);
-  /* Turns a path (relative or otherwise) into an S3 key
+  /**
+   * Turns a path (relative or otherwise) into an S3 key.
+   *
+   * @param path input path, may be relative to the working dir
+   * @return a key excluding the leading "/", or, if it is the root path, ""
+  /**
+   * Turns a path (relative or otherwise) into an S3 key, adding a trailing
+   * "/" if the path is not the root <i>and</i> does not already have a "/"
+   * at the end.
+   *
+   * @param key s3 key or ""
+   * @return the with a trailing "/", or, if it is the root key, "",
+   */
+  private String maybeAddTrailingSlash(String key) {
+    if (!key.isEmpty() && !key.endsWith("/")) {
+      return key + '/';
+    } else {
+      return key;
+    }
+  }
+
+  /**
+   * Convert a path back to a key.
+   * @param key input key
+   * @return the path from this key
+   */
+   * Convert a key to a fully qualified path.
+   * @param key input key
+   * @return the fully qualified path including URI scheme and bucket name.
+   */
+  Path keyToQualifiedPath(String key) {
+    return qualify(keyToPath(key));
+  }
+
+  /**
+   * Qualify a path.
+   * @param path path to qualify
+   * @return a qualified path.
+   */
+  Path qualify(Path path) {
+    return path.makeQualified(uri, workingDir);
+  }
+
+  /**
-     * Opens an FSDataInputStream at the indicated Path.
-     * @param f the file name to open
-     * @param bufferSize the size of the buffer to be used.
-     */
+   * Opens an FSDataInputStream at the indicated Path.
+   * @param f the file name to open
+   * @param bufferSize the size of the buffer to be used.
+   */
-    incrementStatistic(OBJECT_LIST_REQUESTS);
+    incrementStatistic(OBJECT_CONTINUE_LIST_REQUESTS);
-        ListObjectsRequest request = new ListObjectsRequest();
-        request.setBucketName(bucket);
-        request.setPrefix(key);
-        // Hopefully not setting a delimiter will cause this to find everything
-        //request.setDelimiter("/");
-        request.setMaxKeys(maxKeys);
+        ListObjectsRequest request = createListObjectsRequest(key, null);
-    String key = pathToKey(f);
-    LOG.debug("List status for path: {}", f);
+    Path path = qualify(f);
+    String key = pathToKey(path);
+    LOG.debug("List status for path: {}", path);
-    final List<FileStatus> result = new ArrayList<FileStatus>();
-    final FileStatus fileStatus =  getFileStatus(f);
+    List<FileStatus> result;
+    final FileStatus fileStatus =  getFileStatus(path);
-        key = key + "/";
+        key = key + '/';
-      ListObjectsRequest request = new ListObjectsRequest();
-      request.setBucketName(bucket);
-      request.setPrefix(key);
-      request.setDelimiter("/");
-      request.setMaxKeys(maxKeys);
-
+      ListObjectsRequest request = createListObjectsRequest(key, "/");
-      ObjectListing objects = listObjects(request);
-
-      Path fQualified = f.makeQualified(uri, workingDir);
-
-      while (true) {
-        for (S3ObjectSummary summary : objects.getObjectSummaries()) {
-          Path keyPath = keyToPath(summary.getKey()).makeQualified(uri, workingDir);
-          // Skip over keys that are ourselves and old S3N _$folder$ files
-          if (keyPath.equals(fQualified) ||
-              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {
-            LOG.debug("Ignoring: {}", keyPath);
-          } else {
-            S3AFileStatus status = createFileStatus(keyPath, summary,
-                getDefaultBlockSize(keyPath));
-            result.add(status);
-            LOG.debug("Adding: {}", status);
-          }
-        }
-
-        for (String prefix : objects.getCommonPrefixes()) {
-          Path keyPath = keyToPath(prefix).makeQualified(uri, workingDir);
-          if (!keyPath.equals(f)) {
-            result.add(new S3AFileStatus(true, false, keyPath));
-            LOG.debug("Adding: rd: {}", keyPath);
-          }
-        }
-
-        if (objects.isTruncated()) {
-          LOG.debug("listStatus: list truncated - getting next batch");
-          objects = continueListObjects(objects);
-        } else {
-          break;
-        }
+      Listing.FileStatusListingIterator files =
+          listing.createFileStatusListingIterator(path,
+              request,
+              ACCEPT_ALL,
+              new Listing.AcceptAllButSelfAndS3nDirs(path));
+      result = new ArrayList<>(files.getBatchSize());
+      while (files.hasNext()) {
+        result.add(files.next());
+      return result.toArray(new FileStatus[result.size()]);
-      LOG.debug("Adding: rd (not a dir): {}", f);
-      result.add(fileStatus);
+      LOG.debug("Adding: rd (not a dir): {}", path);
+      FileStatus[] stats = new FileStatus[1];
+      stats[0]= fileStatus;
+      return stats;
+  }
-    return result.toArray(new FileStatus[result.size()]);
+  /**
+   * Create a {@code ListObjectsRequest} request against this bucket,
+   * with the maximum keys returned in a query set by {@link #maxKeys}.
+   * @param key key for request
+   * @param delimiter any delimiter
+   * @return the request
+   */
+  private ListObjectsRequest createListObjectsRequest(String key,
+      String delimiter) {
+    ListObjectsRequest request = new ListObjectsRequest();
+    request.setBucketName(bucket);
+    request.setMaxKeys(maxKeys);
+    request.setPrefix(key);
+    if (delimiter != null) {
+      request.setDelimiter(delimiter);
+    }
+    return request;
-  public S3AFileStatus getFileStatus(Path f) throws IOException {
-    String key = pathToKey(f);
+  public S3AFileStatus getFileStatus(final Path f) throws IOException {
-    LOG.debug("Getting path status for {}  ({})", f , key);
-
+    final Path path = qualify(f);
+    String key = pathToKey(path);
+    LOG.debug("Getting path status for {}  ({})", path , key);
-              f.makeQualified(uri, workingDir));
+              path);
-              f.makeQualified(uri, workingDir),
-              getDefaultBlockSize(f.makeQualified(uri, workingDir)));
+              path,
+              getDefaultBlockSize(path));
-          throw translateException("getFileStatus", f, e);
+          throw translateException("getFileStatus", path, e);
-        throw translateException("getFileStatus", f, e);
+        throw translateException("getFileStatus", path, e);
-            return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));
+            return new S3AFileStatus(true, true, path);
-                f.makeQualified(uri, workingDir),
-                getDefaultBlockSize(f.makeQualified(uri, workingDir)));
+                path,
+                getDefaultBlockSize(path));
-      if (!key.isEmpty() && !key.endsWith("/")) {
-        key = key + "/";
-      }
+      key = maybeAddTrailingSlash(key);
-        return new S3AFileStatus(true, false,
-            f.makeQualified(uri, workingDir));
+        return new S3AFileStatus(true, false, path);
-        return new S3AFileStatus(true, true, f.makeQualified(uri, workingDir));
+        return new S3AFileStatus(true, true, path);
-    LOG.debug("Not Found: {}", f);
-    throw new FileNotFoundException("No such file or directory: " + f);
+    LOG.debug("Not Found: {}", path);
+    throw new FileNotFoundException("No such file or directory: " + path);
-   * Override superclass so as to add statistic collection.
+   * Get the maximum key count.
+   * @return a value, valid after initialization
+   */
+  int getMaxKeys() {
+    return maxKeys;
+  }
+
+  /**
+   * Increments the statistic {@link Statistic#INVOCATION_GLOB_STATUS}.
-  public RemoteIterator<LocatedFileStatus> listLocatedStatus(Path f)
-      throws FileNotFoundException, IOException {
-    incrementStatistic(INVOCATION_LIST_LOCATED_STATUS);
-    return super.listLocatedStatus(f);
-  }
-
-  @Override
-  public RemoteIterator<LocatedFileStatus> listFiles(Path f,
-      boolean recursive) throws FileNotFoundException, IOException {
-    incrementStatistic(INVOCATION_LIST_FILES);
-    return super.listFiles(f, recursive);
-  }
-
-  /**
-   * Override superclass so as to add statistic collection.
-   * {@inheritDoc}
-   */
-  @Override
+   * {@inheritDoc}.
+   *
+   * This implementation is optimized for S3, which can do a bulk listing
+   * off all entries under a path in one single operation. Thus there is
+   * no need to recursively walk the directory tree.
+   *
+   * Instead a {@link ListObjectsRequest} is created requesting a (windowed)
+   * listing of all entries under the given path. This is used to construct
+   * an {@code ObjectListingIterator} instance, iteratively returning the
+   * sequence of lists of elements under the path. This is then iterated
+   * over in a {@code FileStatusListingIterator}, which generates
+   * {@link S3AFileStatus} instances, one per listing entry.
+   * These are then translated into {@link LocatedFileStatus} instances.
+   *
+   * This is essentially a nested and wrapped set of iterators, with some
+   * generator classes; an architecture which may become less convoluted
+   * using lambda-expressions.
+   * @param f a path
+   * @param recursive if the subdirectories need to be traversed recursively
+   *
+   * @return an iterator that traverses statuses of the files/directories
+   *         in the given path
+   * @throws FileNotFoundException if {@code path} does not exist
+   * @throws IOException if any I/O error occurred
+   */
+  @Override
+  public RemoteIterator<LocatedFileStatus> listFiles(Path f,
+      boolean recursive) throws FileNotFoundException, IOException {
+    incrementStatistic(INVOCATION_LIST_FILES);
+    Path path = qualify(f);
+    LOG.debug("listFiles({}, {})", path, recursive);
+    try {
+      // lookup dir triggers existence check
+      final FileStatus fileStatus = getFileStatus(path);
+      if (fileStatus.isFile()) {
+        // simple case: File
+        LOG.debug("Path is a file");
+        return new Listing.SingleStatusRemoteIterator(
+            toLocatedFileStatus(fileStatus));
+      } else {
+        // directory: do a bulk operation
+        String key = maybeAddTrailingSlash(pathToKey(path));
+        String delimiter = recursive ? null : "/";
+        LOG.debug("Requesting all entries under {} with delimiter '{}'",
+            key, delimiter);
+        return listing.createLocatedFileStatusIterator(
+            listing.createFileStatusListingIterator(path,
+                createListObjectsRequest(key, delimiter),
+                ACCEPT_ALL,
+                new Listing.AcceptFilesOnly(path)));
+      }
+    } catch (AmazonClientException e) {
+      throw translateException("listFiles", path, e);
+    }
+  }
+
+  /**
+   * Override superclass so as to add statistic collection.
+   * {@inheritDoc}
+   */
+  @Override
+  public RemoteIterator<LocatedFileStatus> listLocatedStatus(Path f)
+      throws FileNotFoundException, IOException {
+    return listLocatedStatus(f, ACCEPT_ALL);
+  }
+
+  /**
+   * {@inheritDoc}.
+   *
+   * S3 Optimized directory listing. The initial operation performs the
+   * first bulk listing; extra listings will take place
+   * when all the current set of results are used up.
+   * @param f a path
+   * @param filter a path filter
+   * @return an iterator that traverses statuses of the files/directories
+   *         in the given path
+   * @throws FileNotFoundException if {@code path} does not exist
+   * @throws IOException if any I/O error occurred
+   */
+  @Override
+  public RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f,
+      final PathFilter filter)
+      throws FileNotFoundException, IOException {
+    incrementStatistic(INVOCATION_LIST_LOCATED_STATUS);
+    Path path = qualify(f);
+    LOG.debug("listLocatedStatus({}, {}", path, filter);
+    try {
+      // lookup dir triggers existence check
+      final FileStatus fileStatus = getFileStatus(path);
+      if (fileStatus.isFile()) {
+        // simple case: File
+        LOG.debug("Path is a file");
+        return new Listing.SingleStatusRemoteIterator(
+            filter.accept(path) ? toLocatedFileStatus(fileStatus) : null);
+      } else {
+        // directory: trigger a lookup
+        String key = maybeAddTrailingSlash(pathToKey(path));
+        return listing.createLocatedFileStatusIterator(
+            listing.createFileStatusListingIterator(path,
+                createListObjectsRequest(key, "/"),
+                filter,
+                new Listing.AcceptAllButSelfAndS3nDirs(path)));
+      }
+    } catch (AmazonClientException e) {
+      throw translateException("listLocatedStatus", path, e);
+    }
+  }
+
+  /**
+   * Build a {@link LocatedFileStatus} from a {@link FileStatus} instance.
+   * @param status file status
+   * @return a located status with block locations set up from this FS.
+   * @throws IOException IO Problems.
+   */
+  LocatedFileStatus toLocatedFileStatus(FileStatus status)
+      throws IOException {
+    return new LocatedFileStatus(status,
+        status.isFile() ?
+          getFileBlockLocations(status, 0, status.getLen())
+          : null);
+  }
+
+  /**
-  /**
-   * This is a simple encapsulation of the
-   * S3 access key and secret.
-   */
-  static class AWSAccessKeys {
-    private String accessKey = null;
-    private String accessSecret = null;
-
-    /**
-     * Constructor.
-     * @param key - AWS access key
-     * @param secret - AWS secret key
-     */
-    public AWSAccessKeys(String key, String secret) {
-      accessKey = key;
-      accessSecret = secret;
-    }
-
-    /**
-     * Return the AWS access key.
-     * @return key
-     */
-    public String getAccessKey() {
-      return accessKey;
-    }
-
-    /**
-     * Return the AWS secret key.
-     * @return secret
-     */
-    public String getAccessSecret() {
-      return accessSecret;
-    }
-  }

INS26 MOV31 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV31 INS83 INS43 INS59 INS29 INS29 INS83 MOV43 INS42 INS44 INS8 INS29 INS29 INS43 INS42 MOV44 INS8 INS29 INS43 INS42 INS44 INS8 MOV29 INS83 MOV5 INS42 MOV44 MOV43 MOV43 MOV43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 MOV60 INS29 INS39 INS42 INS8 INS29 MOV78 INS83 MOV74 INS42 MOV44 MOV44 MOV43 MOV43 INS8 MOV29 INS78 INS74 UPD42 MOV44 INS43 INS43 INS29 MOV78 MOV83 MOV74 UPD42 MOV42 MOV44 INS44 MOV43 MOV43 INS8 UPD43 UPD42 INS44 INS43 INS42 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 MOV25 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS41 INS65 INS65 INS65 INS42 INS43 INS42 INS41 INS60 INS60 MOV21 MOV21 MOV60 MOV60 INS25 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 MOV60 MOV21 MOV21 MOV21 INS25 INS41 INS83 INS60 INS65 INS65 INS41 INS65 INS65 INS65 INS65 INS65 INS65 MOV21 INS60 MOV21 INS54 INS42 INS43 INS43 INS42 INS42 MOV65 INS65 INS65 UPD65 MOV65 UPD65 MOV65 UPD65 MOV65 INS83 INS43 INS42 INS83 INS43 INS42 MOV21 INS60 MOV21 INS54 INS65 INS65 UPD42 INS43 INS42 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 MOV42 INS8 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS32 INS66 INS42 INS66 INS66 INS42 INS32 MOV43 INS59 MOV43 MOV59 MOV32 INS8 INS8 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS42 INS83 INS43 INS59 INS66 INS66 INS42 UPD66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS66 MOV43 INS59 INS8 INS12 INS42 INS42 INS32 INS65 INS66 UPD66 INS66 UPD66 INS42 INS66 INS42 INS66 UPD66 INS66 UPD42 UPD66 INS65 INS66 UPD42 UPD66 INS42 INS42 MOV43 INS59 INS32 INS8 INS12 INS66 INS65 INS66 INS65 UPD66 INS42 INS66 UPD66 INS42 INS66 INS42 INS14 INS21 INS41 INS41 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 INS42 INS32 UPD42 MOV25 MOV60 MOV21 INS60 INS21 INS61 MOV41 MOV21 INS60 INS21 INS41 INS66 INS67 INS42 INS33 INS21 INS42 INS42 INS32 UPD42 INS21 UPD42 INS67 INS42 INS66 INS66 INS42 INS42 INS66 INS42 INS32 UPD45 UPD42 INS42 INS60 INS25 INS44 INS8 INS42 INS42 INS42 INS66 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS60 INS25 INS44 INS8 INS42 INS42 INS43 INS42 INS16 INS7 INS27 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD43 INS43 MOV59 INS7 INS32 INS8 INS5 INS59 INS7 INS42 INS42 INS32 INS42 INS42 UPD42 INS7 UPD42 INS42 INS42 INS42 INS42 INS83 MOV43 INS59 MOV32 MOV8 MOV8 INS43 INS42 INS53 INS42 INS42 INS83 INS43 INS59 INS32 INS8 INS8 INS43 INS42 INS53 INS42 INS32 INS32 INS33 INS42 INS14 MOV42 INS13 INS60 UPD42 UPD42 INS40 UPD42 INS42 MOV14 UPD42 MOV42 UPD42 MOV42 INS21 UPD45 UPD42 INS43 INS85 UPD42 MOV42 INS3 INS2 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS32 INS42 INS32 UPD42 UPD42 INS41 INS60 INS60 INS41 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS21 MOV41 INS60 INS41 INS42 INS32 INS42 INS42 INS42 INS42 INS34 INS32 INS43 INS52 MOV43 INS59 UPD42 UPD42 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS14 UPD74 INS32 INS32 UPD42 MOV42 INS5 INS34 INS42 INS34 INS42 INS42 INS42 INS42 INS14 MOV43 INS59 MOV43 INS59 INS32 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS14 MOV43 INS59 INS32 INS42 INS45 INS42 INS42 INS42 INS42 INS42 MOV42 INS32 INS43 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS43 INS85 MOV43 INS42 UPD45 INS43 INS32 INS42 INS32 INS42 INS16 UPD45 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS45 INS43 INS16 INS42 INS32 INS42 INS42 INS32 UPD42 MOV42 MOV42 INS33 INS13 INS40 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV43 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS33 INS45 INS42 UPD42 MOV42 INS42 INS32 INS42 INS14 INS40 INS32 INS32 INS33 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS14 MOV43 INS42 MOV43 MOV32 MOV32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS43 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS40 INS40 UPD42 MOV42 MOV43 INS42 MOV43 MOV32 MOV32 INS42 UPD42 MOV42 DEL42 DEL45 DEL27 DEL7 DEL21 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL83 DEL45 DEL32 DEL32 DEL42 DEL83 DEL42 DEL43 DEL60 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL9 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL60 DEL42 DEL32 DEL32 DEL32 DEL27 DEL8 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL44 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL43 DEL9 DEL9 DEL42 DEL14 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL10 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL42 DEL48 DEL41 DEL8 DEL31 DEL42 DEL32 DEL7 DEL21 DEL32 DEL21 DEL42 DEL42 DEL42 DEL48 DEL42 DEL42 DEL42 DEL7 DEL42 DEL83 DEL42 DEL29 DEL83 DEL42 DEL83 DEL42 DEL33 DEL59 DEL23 DEL83 DEL42 DEL33 DEL59 DEL23 DEL29 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL8 DEL31 DEL55
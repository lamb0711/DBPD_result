Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1242635 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.FilenameFilter;
-public class FSDataset implements FSDatasetInterface {
+class FSDataset implements FSDatasetInterface {
-  class FSDir {
-    File dir;
+  private class FSDir {
+    final File dir;
-    /**
-     */
-    public FSDir(File dir) 
+
+    private FSDir(File dir) 
-    public File addBlock(Block b, File src) throws IOException {
+    private File addBlock(Block b, File src) throws IOException {
-    void getVolumeMap(String bpid, ReplicasMap volumeMap, FSVolume volume) 
+    private void getVolumeMap(String bpid, ReplicasMap volumeMap, FSVolume volume) 
-    public void checkDirTree() throws DiskErrorException {
+    private void checkDirTree() throws DiskErrorException {
-    void clearPath(File f) {
+    private void clearPath(File f) {
-        
+
+    @Override
-  class BlockPoolSlice {
+  private class BlockPoolSlice {
-    
-    File getCurrentDir() {
-      return currentDir;
-    }
-    
+
-      return FSDataset.createTmpFile(b, f);
+      return DatanodeUtil.createTmpFile(b, f);
-      return FSDataset.createTmpFile(b, f);
+      return DatanodeUtil.createTmpFile(b, f);
-      File metaFile = getMetaFile(blockFile , b.getGenerationStamp());
+      File metaFile = DatanodeUtil.getMetaFile(blockFile, b.getGenerationStamp());
-        File metaFile = new File(getMetaFileName(blockFile.toString(), genStamp));
+        final File metaFile = DatanodeUtil.getMetaFile(blockFile, genStamp);
-        if (version != FSDataset.METADATA_VERSION) {
+        if (version != BlockMetadataHeader.VERSION) {
-  class FSVolume {
+  class FSVolume implements FSVolumeInterface {
-
-    /** Return storage directory corresponding to the volume */
-    public File getDir() {
-      return currentDir.getParentFile();
-    }
-    public File getCurrentDir() {
+    File getCurrentDir() {
-    public File getRbwDir(String bpid) throws IOException {
+    File getRbwDir(String bpid) throws IOException {
-      
-    long getAvailable() throws IOException {
+
+    @Override
+    public long getAvailable() throws IOException {
-    
-    BlockPoolSlice getBlockPoolSlice(String bpid) throws IOException {
+
+    private BlockPoolSlice getBlockPoolSlice(String bpid) throws IOException {
-    
+
+    @Override
+    public File getDirectory(String bpid) throws IOException {
+      return getBlockPoolSlice(bpid).getDirectory();
+    }
+
+    @Override
+    public File getFinalizedDir(String bpid) throws IOException {
+      return getBlockPoolSlice(bpid).getFinalizedDir();
+    }
+
-    String[] getBlockPoolList() {
+    @Override
+    public String[] getBlockPoolList() {
-      
+
+    @Override
-    private volatile List<FSVolume> volumes = null;
+    private volatile List<FSVolumeInterface> volumes = null;
+
-    FSVolumeSet(FSVolume[] volumes, int failedVols, BlockVolumeChoosingPolicy blockChooser) {
-      List<FSVolume> list = Arrays.asList(volumes);
-      this.volumes = Collections.unmodifiableList(list);
+    FSVolumeSet(List<FSVolumeInterface> volumes, int failedVols,
+        BlockVolumeChoosingPolicy blockChooser) {
+      this.volumes = Collections.unmodifiableList(volumes);
-    private int numberOfVolumes() {
-      return volumes.size();
-    }
-
-      return blockChooser.chooseVolume(volumes, blockSize);
+      return (FSVolume)blockChooser.chooseVolume(volumes, blockSize);
-      for (FSVolume vol : volumes) {
-        dfsUsed += vol.getDfsUsed();
+      for (FSVolumeInterface v : volumes) {
+        dfsUsed += ((FSVolume)v).getDfsUsed();
-      for (FSVolume vol : volumes) {
-        dfsUsed += vol.getBlockPoolUsed(bpid);
+      for (FSVolumeInterface v : volumes) {
+        dfsUsed += ((FSVolume)v).getBlockPoolUsed(bpid);
-      for (FSVolume vol : volumes) {
-        capacity += vol.getCapacity();
+      for (FSVolumeInterface v : volumes) {
+        capacity += ((FSVolume)v).getCapacity();
-      for (FSVolume vol : volumes) {
+      for (FSVolumeInterface vol : volumes) {
-      for (FSVolume vol : volumes) {
-        vol.getVolumeMap(volumeMap);
+      for (FSVolumeInterface v : volumes) {
+        ((FSVolume)v).getVolumeMap(volumeMap);
-      for (FSVolume vol : volumes) {
-        vol.getVolumeMap(bpid, volumeMap);
+      for (FSVolumeInterface v : volumes) {
+        ((FSVolume)v).getVolumeMap(bpid, volumeMap);
-      List<FSVolume> volumeList = new ArrayList<FSVolume>(getVolumes());
+      final List<FSVolumeInterface> volumeList = new ArrayList<FSVolumeInterface>(volumes);
-        FSVolume fsv = volumeList.get(idx);
+        FSVolume fsv = (FSVolume)volumeList.get(idx);
-        List<FSVolume> newVols = new ArrayList<FSVolume>();
-        for (FSVolume vol : volumeList) {
+        List<FSVolumeInterface> newVols = new ArrayList<FSVolumeInterface>();
+        for (FSVolumeInterface vol : volumeList) {
-      
+
+    @Override
-    boolean isValid(FSVolume volume) {
-      for (FSVolume vol : volumes) {
-        if (vol == volume) {
-          return true;
-        }
-      }
-      return false;
-    }
-      for (FSVolume v : volumes) {
-        v.addBlockPool(bpid, conf);
+      for (FSVolumeInterface v : volumes) {
+        ((FSVolume)v).addBlockPool(bpid, conf);
-      for (FSVolume v : volumes) {
-        v.shutdownBlockPool(bpid);
+      for (FSVolumeInterface v : volumes) {
+        ((FSVolume)v).shutdownBlockPool(bpid);
-    
-    /**
-     * @return unmodifiable list of volumes
-     */
-    public List<FSVolume> getVolumes() {
-      return volumes;
-    }
-      for (FSVolume volume : volumes) {
+      for (FSVolumeInterface volume : volumes) {
-          volume.shutdown();
+          ((FSVolume)volume).shutdown();
-  //Find better place?
-  public static final String METADATA_EXTENSION = ".meta";
-  public static final short METADATA_VERSION = 1;
-  static final String UNLINK_BLOCK_SUFFIX = ".unlinked";
-
-    return name.endsWith(UNLINK_BLOCK_SUFFIX);
-  }
-  
-  static File getUnlinkTmpFile(File f) {
-    return new File(f.getParentFile(), f.getName()+UNLINK_BLOCK_SUFFIX);
+    return name.endsWith(DatanodeUtil.UNLINK_BLOCK_SUFFIX);
-        fileName.substring(0, fileName.length()-UNLINK_BLOCK_SUFFIX.length()));
-  }
-  
-  static String getMetaFileName(String blockFileName, long genStamp) {
-    return blockFileName + "_" + genStamp + METADATA_EXTENSION;
-  }
-  
-  static File getMetaFile(File f , long genStamp) {
-    return new File(getMetaFileName(f.getAbsolutePath(), genStamp));
+        fileName.substring(0,
+            fileName.length() - DatanodeUtil.UNLINK_BLOCK_SUFFIX.length()));
-    return getMetaFile(getBlockFile(b), b.getGenerationStamp());
+    return DatanodeUtil.getMetaFile(getBlockFile(b), b.getGenerationStamp());
-
-  /** Find the corresponding meta data file from a given block file */
-  private static File findMetaFile(final File blockFile) throws IOException {
-    final String prefix = blockFile.getName() + "_";
-    final File parent = blockFile.getParentFile();
-    File[] matches = parent.listFiles(new FilenameFilter() {
-      public boolean accept(File dir, String name) {
-        return dir.equals(parent)
-            && name.startsWith(prefix) && name.endsWith(METADATA_EXTENSION);
-      }
-    });
-
-    if (matches == null || matches.length == 0) {
-      throw new IOException("Meta file not found, blockFile=" + blockFile);
-    }
-    else if (matches.length > 1) {
-      throw new IOException("Found more than one meta files: " 
-          + Arrays.asList(matches));
-    }
-    return matches[0];
-  }
-        metaname.length() - METADATA_EXTENSION.length());
+        metaname.length() - DatanodeUtil.METADATA_EXTENSION.length());
-  /** Return the block file for the given ID */ 
-  public File findBlockFile(String bpid, long blockId) {
-    return getFile(bpid, blockId);
+  @Override // FSDatasetInterface
+  public List<FSVolumeInterface> getVolumes() {
+    return volumes.volumes;
-    File blockfile = findBlockFile(bpid, blkid);
+    File blockfile = getFile(bpid, blkid);
-    File metafile = findMetaFile(blockfile);
+    final File metafile = DatanodeUtil.findMetaFile(blockfile);
-
-  static File createTmpFile(Block b, File f) throws IOException {
-    if (f.exists()) {
-      throw new IOException("Unexpected problem in creating temporary file for "+
-                            b + ".  File " + f + " should not be present, but is.");
-    }
-    // Create the zero-length temp file
-    //
-    boolean fileCreated = false;
-    try {
-      fileCreated = f.createNewFile();
-    } catch (IOException ioe) {
-      throw (IOException)new IOException(DISK_ERROR +f).initCause(ioe);
-    }
-    if (!fileCreated) {
-      throw new IOException("Unexpected problem in creating temporary file for "+
-                            b + ".  File " + f + " should be creatable, but is already present.");
-    }
-    return f;
-  }
-  public FSDataset(DataNode datanode, DataStorage storage, Configuration conf)
+  FSDataset(DataNode datanode, DataStorage storage, Configuration conf)
-    FSVolume[] volArray = new FSVolume[storage.getNumStorageDirs()];
+    final List<FSVolumeInterface> volArray = new ArrayList<FSVolumeInterface>(
+        storage.getNumStorageDirs());
-      volArray[idx] = new FSVolume(storage.getStorageDir(idx).getCurrentDir(),
-          conf);
-      DataNode.LOG.info("FSDataset added volume - "
-          + storage.getStorageDir(idx).getCurrentDir());
+      final File dir = storage.getStorageDir(idx).getCurrentDir();
+      volArray.add(new FSVolume(dir, conf));
+      DataNode.LOG.info("FSDataset added volume - " + dir);
-    return volumes.numberOfVolumes() >= validVolsRequired; 
+    return getVolumes().size() >= validVolsRequired; 
-  public File getBlockFile(ExtendedBlock b) throws IOException {
+  private File getBlockFile(ExtendedBlock b) throws IOException {
-  public File getBlockFile(String bpid, Block b)
-      throws IOException {
+  File getBlockFile(String bpid, Block b) throws IOException {
-    File f = getFile(b.getBlockPoolId(), b.getLocalBlock());
+    final File f;
+    synchronized(this) {
+      f = getFile(b.getBlockPoolId(), b.getLocalBlock().getBlockId());
+    }
-  private ReplicaInfo getReplicaInfo(ExtendedBlock b)
+  ReplicaInfo getReplicaInfo(ExtendedBlock b)
-    final File srcmeta = getMetaFile(srcfile, b.getGenerationStamp());
-    final File dstmeta = getMetaFile(dstfile, b.getGenerationStamp());
+    final File srcmeta = DatanodeUtil.getMetaFile(srcfile, b.getGenerationStamp());
+    final File dstmeta = DatanodeUtil.getMetaFile(dstfile, b.getGenerationStamp());
-  private final static String DISK_ERROR = "Possible disk error on file creation: ";
-  /** Get the cause of an I/O exception if caused by a possible disk error
-   * @param ioe an I/O exception
-   * @return cause if the I/O exception is caused by a possible disk error;
-   *         null otherwise.
-   */ 
-  static IOException getCauseIfDiskError(IOException ioe) {
-    if (ioe.getMessage()!=null && ioe.getMessage().startsWith(DISK_ERROR)) {
-      return (IOException)ioe.getCause();
-    } else {
-      return null;
-    }
-  }
-    FSVolume v = replicaInfo.getVolume();
+    FSVolume v = (FSVolume)replicaInfo.getVolume();
-    final FSVolume v = temp.getVolume();
+    final FSVolume v = (FSVolume)temp.getVolume();
-        vol = volumeMap.get(bpid, blk).getVolume();
+        vol = (FSVolume)volumeMap.get(bpid, blk).getVolume();
-      FSVolume v = replicaInfo.getVolume();
+      FSVolume v = (FSVolume)replicaInfo.getVolume();
-  synchronized List<Block> getFinalizedBlocks(String bpid) {
+  @Override
+  public synchronized List<Block> getFinalizedBlocks(String bpid) {
-    File f = getFile(bpid, b);
+    final File f;
+    synchronized(this) {
+      f = getFile(bpid, b.getBlockId());
+    }
-    final File metafile = getMetaFile(f, r.getGenerationStamp());
+    final File metafile = DatanodeUtil.getMetaFile(f, r.getGenerationStamp());
-        f = getFile(bpid, invalidBlks[i]);
+        f = getFile(bpid, invalidBlks[i].getBlockId());
-        v = dinfo.getVolume();
+        v = (FSVolume)dinfo.getVolume();
-      File metaFile = getMetaFile(f, invalidBlks[i].getGenerationStamp());
+      File metaFile = DatanodeUtil.getMetaFile(f, invalidBlks[i].getGenerationStamp());
-  /**
-   * Turn the block identifier into a filename; ignore generation stamp!!!
-   */
-  public synchronized File getFile(String bpid, Block b) {
-    return getFile(bpid, b.getBlockId());
+  @Override // {@link FSDatasetInterface}
+  public synchronized boolean contains(final ExtendedBlock block) {
+    final long blockId = block.getLocalBlock().getBlockId();
+    return getFile(block.getBlockPoolId(), blockId) != null;
-  private File getFile(String bpid, long blockId) {
+  File getFile(final String bpid, final long blockId) {
+  @Override
-      File diskMetaFile, FSVolume vol) {
+      File diskMetaFile, FSVolumeInterface vol) {
-        File memMetaFile = getMetaFile(diskFile, 
+        File memMetaFile = DatanodeUtil.getMetaFile(diskFile, 
-  /**
-   * get list of all bpids
-   * @return list of bpids
-   */
-  public String [] getBPIdlist() {
+  @Override
+  public String[] getBlockPoolList() {
-  static class VolumeInfo {
+  private static class VolumeInfo {
-  
-  Collection<VolumeInfo> getVolumeInfo() {
+
+  private Collection<VolumeInfo> getVolumeInfo() {
-    for (FSVolume volume : volumes.volumes) {
+    for (FSVolumeInterface v : volumes.volumes) {
+      final FSVolume volume = (FSVolume)v;
-  
+
+  @Override
+  public Map<String, Object> getVolumeInfoMap() {
+    final Map<String, Object> info = new HashMap<String, Object>();
+    Collection<VolumeInfo> volumes = getVolumeInfo();
+    for (VolumeInfo v : volumes) {
+      final Map<String, Object> innerInfo = new HashMap<String, Object>();
+      innerInfo.put("usedSpace", v.usedSpace);
+      innerInfo.put("freeSpace", v.freeSpace);
+      innerInfo.put("reservedSpace", v.reservedSpace);
+      info.put(v.directory, innerInfo);
+    }
+    return info;
+  }
+
-      for (FSVolume volume : volumes.volumes) {
-        if (!volume.isBPDirEmpty(bpid)) {
+      for (FSVolumeInterface volume : volumes.volumes) {
+        if (!((FSVolume)volume).isBPDirEmpty(bpid)) {
-    for (FSVolume volume : volumes.volumes) {
-      volume.deleteBPDirectories(bpid, force);
+    for (FSVolumeInterface volume : volumes.volumes) {
+      ((FSVolume)volume).deleteBPDirectories(bpid, force);
-    File metafile = getMetaFile(datafile, block.getGenerationStamp());
+    File metafile = DatanodeUtil.getMetaFile(datafile, block.getGenerationStamp());

MOV31 MOV31 MOV31 INS31 INS31 INS31 INS83 INS83 INS43 MOV31 INS78 INS83 INS74 UPD42 MOV42 MOV8 MOV29 MOV78 UPD83 INS39 INS42 UPD83 MOV60 INS78 INS83 INS78 UPD83 MOV83 UPD83 MOV83 INS39 INS42 INS44 INS8 INS78 INS78 UPD42 INS83 INS83 INS78 MOV83 INS74 INS42 INS8 INS83 UPD83 UPD83 INS83 UPD83 INS83 INS78 INS42 INS78 INS83 INS83 INS78 UPD42 INS44 MOV43 INS78 MOV43 UPD42 MOV44 MOV43 INS78 INS83 INS78 UPD74 INS78 INS42 INS43 INS43 INS51 INS42 INS60 INS51 INS42 MOV83 INS43 INS42 MOV60 INS41 INS83 MOV43 INS83 INS42 UPD43 INS42 INS42 INS43 MOV43 INS43 INS60 INS60 INS70 MOV41 INS42 INS42 INS42 MOV43 INS42 INS42 INS42 MOV42 INS42 INS42 INS42 UPD43 INS74 MOV41 MOV41 INS42 UPD42 MOV42 UPD42 MOV42 INS40 MOV43 INS83 MOV43 INS83 INS74 UPD27 INS83 MOV43 INS52 INS8 MOV43 MOV43 INS83 MOV43 INS59 INS52 INS8 UPD42 MOV42 INS39 INS27 UPD42 UPD42 MOV42 UPD42 MOV42 INS83 INS74 INS59 INS74 INS59 INS44 INS42 INS8 INS42 INS42 INS32 UPD42 INS43 INS43 INS11 INS83 UPD74 INS40 INS42 INS43 INS43 INS14 INS60 INS32 UPD42 INS21 UPD42 UPD42 INS11 INS11 INS42 INS21 UPD42 INS32 MOV33 UPD43 UPD42 INS60 INS43 MOV43 INS43 INS42 INS14 INS43 INS43 INS42 INS32 UPD43 MOV43 UPD42 MOV42 INS60 INS21 INS21 INS21 INS21 UPD43 UPD42 UPD42 INS32 UPD42 INS32 INS42 INS42 INS42 MOV43 MOV32 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD43 UPD42 UPD43 UPD42 UPD43 INS43 INS43 UPD43 UPD42 INS42 INS42 INS42 INS74 MOV32 INS83 MOV43 INS59 INS32 MOV32 INS42 INS7 INS42 UPD42 INS42 UPD42 MOV43 MOV32 MOV43 MOV32 INS43 INS7 INS42 INS32 UPD42 INS42 INS32 UPD42 MOV42 UPD42 INS83 MOV43 INS59 INS42 UPD42 MOV42 INS74 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS83 INS74 INS59 INS32 INS32 INS32 INS32 UPD42 INS42 INS42 INS83 UPD42 MOV42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD74 INS42 INS43 UPD74 INS42 INS42 UPD42 INS43 INS43 INS42 MOV32 INS42 INS42 INS14 INS42 MOV32 INS42 INS11 INS42 MOV32 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS11 INS43 MOV43 INS43 INS43 MOV43 INS43 INS42 INS14 UPD42 MOV42 UPD42 MOV42 INS45 INS40 UPD42 MOV42 UPD42 MOV42 INS45 INS40 UPD42 MOV42 UPD42 MOV42 INS45 INS40 INS42 INS42 INS40 INS42 UPD43 INS36 INS32 UPD40 INS36 INS36 INS43 INS42 INS11 UPD43 UPD43 INS36 INS36 INS40 INS40 INS42 UPD42 MOV42 MOV43 INS42 MOV42 INS42 INS32 MOV43 MOV32 INS42 INS43 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS74 UPD42 INS11 INS42 UPD42 MOV42 MOV42 MOV42 INS36 INS36 INS36 INS11 INS11 INS42 MOV43 MOV32 UPD42 UPD74 UPD42 INS11 INS11 MOV32 INS42 INS11 INS32 INS11 INS42 INS43 MOV43 INS43 INS43 INS42 INS11 INS11 INS11 INS43 INS42 INS43 INS42 INS43 MOV43 INS42 MOV43 INS42 INS36 INS43 MOV32 INS42 INS42 MOV32 MOV42 INS43 MOV32 INS42 UPD42 MOV42 INS42 INS36 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS11 INS42 UPD42 INS42 INS11 INS42 INS42 INS42 MOV43 INS42 INS43 INS42 INS42 INS42 DEL40 DEL26 DEL83 DEL29 DEL42 DEL43 DEL42 DEL32 DEL32 DEL14 DEL83 DEL66 DEL65 DEL29 DEL42 DEL85 DEL5 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8 DEL70 DEL9 DEL41 DEL8 DEL31 DEL42 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL83 DEL83 DEL83 DEL42 DEL45 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL42 DEL45 DEL59 DEL23 DEL42 DEL83 DEL43 DEL42 DEL43 DEL42 DEL44 DEL31 DEL42 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL44 DEL83 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL43 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL27 DEL41 DEL8 DEL31 DEL1 DEL14 DEL32 DEL59 DEL60 DEL42 DEL27 DEL40 DEL34 DEL27 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL40 DEL34 DEL27 DEL42 DEL43 DEL45 DEL42 DEL42 DEL42 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL25 DEL42 DEL34 DEL2 DEL41 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL27 DEL14 DEL66 DEL65 DEL29 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL83 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL27 DEL14 DEL42 DEL42 DEL32 DEL11 DEL53 DEL8 DEL12 DEL54 DEL42 DEL38 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL83 DEL85 DEL5 DEL85 DEL5 DEL3 DEL42 DEL42 DEL2 DEL14 DEL7 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL45 DEL42 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL83 DEL83 DEL83 DEL83 DEL42 DEL45 DEL59 DEL23 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL43 DEL42 DEL44 DEL32 DEL33 DEL27 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL32 DEL11 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL8 DEL31 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL83 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL42
YARN-1707. Introduce APIs to add/remove/resize queues in the CapacityScheduler. Contributed by Carlo Curino and Subru Krishnan
(cherry picked from commit aac47fda7fecda9fc18ade34d633eca895865a70)

Conflicts:
	hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java

+import java.util.HashSet;
+import java.util.Set;
+import org.apache.hadoop.yarn.api.records.ReservationId;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.common.QueueEntitlement;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerDynamicEditException;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.Queue;
+
-    for (String queue : queues.keySet()) {
-      if (!newQueues.containsKey(queue)) {
-        throw new IOException(queue + " cannot be found during refresh!");
+    // check that all static queues are included in the newQueues list
+    for (Map.Entry<String, CSQueue> e : queues.entrySet()) {
+      if (!(e.getValue() instanceof ReservationQueue)) {
+        if (!newQueues.containsKey(e.getKey())) {
+          throw new IOException(e.getKey() + " cannot be found during refresh!");
+        }
+    String fullQueueName =
+        (parent == null) ? queueName
+            : (parent.getQueuePath() + "." + queueName);
-      conf.getQueues((parent == null) ? 
-          queueName : (parent.getQueuePath()+"."+queueName));
+      conf.getQueues(fullQueueName);
+    boolean isReservableQueue = conf.isReservableQueue(fullQueueName);
-      queue = 
-          new LeafQueue(csContext, queueName, parent, oldQueues.get(queueName));
-      
-      // Used only for unit tests
-      queue = hook.hook(queue);
+      // Check if the queue will be dynamically managed by the Reservation
+      // system
+      if (isReservableQueue) {
+        queue =
+            new PlanQueue(csContext, queueName, parent,
+                oldQueues.get(queueName));
+      } else {
+        queue =
+            new LeafQueue(csContext, queueName, parent,
+                oldQueues.get(queueName));
+
+        // Used only for unit tests
+        queue = hook.hook(queue);
+      }
+      if (isReservableQueue) {
+        throw new IllegalStateException(
+            "Only Leaf Queues can be reservable for " + queueName);
+      }
-      
+
-  synchronized CSQueue getQueue(String queueName) {
+  public synchronized CSQueue getQueue(String queueName) {
-    		" finalState=" + rmAppAttemptFinalState);
+        " finalState=" + rmAppAttemptFinalState);
-      addApplication(appAddedEvent.getApplicationId(),
-        appAddedEvent.getQueue(),
-        appAddedEvent.getUser(), appAddedEvent.getIsAppRecovering());
+      String queueName =
+          resolveReservationQueueName(appAddedEvent.getQueue(),
+              appAddedEvent.getApplicationId(),
+              appAddedEvent.getReservationID());
+      if (queueName != null) {
+        addApplication(appAddedEvent.getApplicationId(),
+            queueName,
+            appAddedEvent.getUser(),
+            appAddedEvent.getIsAppRecovering());
+      }
+  private synchronized String resolveReservationQueueName(String queueName,
+      ApplicationId applicationId, ReservationId reservationID) {
+    CSQueue queue = getQueue(queueName);
+    // Check if the queue is a plan queue
+    if ((queue == null) || !(queue instanceof PlanQueue)) {
+      return queueName;
+    }
+    if (reservationID != null) {
+      String resQName = reservationID.toString();
+      queue = getQueue(resQName);
+      if (queue == null) {
+        String message =
+            "Application "
+                + applicationId
+                + " submitted to a reservation which is not yet currently active: "
+                + resQName;
+        this.rmContext.getDispatcher().getEventHandler()
+            .handle(new RMAppRejectedEvent(applicationId, message));
+        return null;
+      }
+      // use the reservation queue to run the app
+      queueName = resQName;
+    } else {
+      // use the default child queue of the plan for unreserved apps
+      queueName = queueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;
+    }
+    return queueName;
+  }
+
+  @Override
+  public synchronized void removeQueue(String queueName)
+      throws SchedulerDynamicEditException {
+    LOG.info("Removing queue: " + queueName);
+    CSQueue q = this.getQueue(queueName);
+    if (!(q instanceof ReservationQueue)) {
+      throw new SchedulerDynamicEditException("The queue that we are asked "
+          + "to remove (" + queueName + ") is not a ReservationQueue");
+    }
+    ReservationQueue disposableLeafQueue = (ReservationQueue) q;
+    // at this point we should have no more apps
+    if (disposableLeafQueue.getNumApplications() > 0) {
+      throw new SchedulerDynamicEditException("The queue " + queueName
+          + " is not empty " + disposableLeafQueue.getApplications().size()
+          + " active apps " + disposableLeafQueue.pendingApplications.size()
+          + " pending apps");
+    }
+
+    ((PlanQueue) disposableLeafQueue.getParent()).removeChildQueue(q);
+    this.queues.remove(queueName);
+    LOG.info("Removal of ReservationQueue " + queueName + " has succeeded");
+  }
+
+  @Override
+  public synchronized void addQueue(Queue queue)
+      throws SchedulerDynamicEditException {
+
+    if (!(queue instanceof ReservationQueue)) {
+      throw new SchedulerDynamicEditException("Queue " + queue.getQueueName()
+          + " is not a ReservationQueue");
+    }
+
+    ReservationQueue newQueue = (ReservationQueue) queue;
+
+    if (newQueue.getParent() == null
+        || !(newQueue.getParent() instanceof PlanQueue)) {
+      throw new SchedulerDynamicEditException("ParentQueue for "
+          + newQueue.getQueueName()
+          + " is not properly set (should be set and be a PlanQueue)");
+    }
+
+    PlanQueue parentPlan = (PlanQueue) newQueue.getParent();
+    String queuename = newQueue.getQueueName();
+    parentPlan.addChildQueue(newQueue);
+    this.queues.put(queuename, newQueue);
+    LOG.info("Creation of ReservationQueue " + newQueue + " succeeded");
+  }
+
+  @Override
+  public synchronized void setEntitlement(String inQueue,
+      QueueEntitlement entitlement) throws SchedulerDynamicEditException,
+      YarnException {
+    LeafQueue queue = getAndCheckLeafQueue(inQueue);
+    ParentQueue parent = (ParentQueue) queue.getParent();
+
+    if (!(queue instanceof ReservationQueue)) {
+      throw new SchedulerDynamicEditException("Entitlement can not be"
+          + " modified dynamically since queue " + inQueue
+          + " is not a ReservationQueue");
+    }
+
+    if (!(parent instanceof PlanQueue)) {
+      throw new SchedulerDynamicEditException("The parent of ReservationQueue "
+          + inQueue + " must be an PlanQueue");
+    }
+
+    ReservationQueue newQueue = (ReservationQueue) queue;
+
+    float sumChilds = ((PlanQueue) parent).sumOfChildCapacities();
+    float newChildCap = sumChilds - queue.getCapacity() + entitlement.getCapacity();
+
+    if (newChildCap >= 0 && newChildCap < 1.0f + CSQueueUtils.EPSILON) {
+      // note: epsilon checks here are not ok, as the epsilons might accumulate
+      // and become a problem in aggregate
+      if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) == 0
+          && Math.abs(entitlement.getMaxCapacity() - queue.getMaximumCapacity()) == 0) {
+        return;
+      }
+      newQueue.setEntitlement(entitlement);
+    } else {
+      throw new SchedulerDynamicEditException(
+          "Sum of child queues would exceed 100% for PlanQueue: "
+              + parent.getQueueName());
+    }
+    LOG.info("Set entitlement for ReservationQueue " + inQueue + "  to "
+        + queue.getCapacity() + " request was (" + entitlement.getCapacity() + ")");
+  }
+
-    LeafQueue dest = getAndCheckLeafQueue(targetQueueName);
+    String destQueueName = handleMoveToPlanQueue(targetQueueName);
+    LeafQueue dest = getAndCheckLeafQueue(destQueueName);
-      dest.submitApplication(appId, user, targetQueueName);
+      dest.submitApplication(appId, user, destQueueName);
-        + sourceQueueName + " to: " + targetQueueName);
+        + sourceQueueName + " to: " + destQueueName);
+  
+  private String handleMoveToPlanQueue(String targetQueueName) {
+    CSQueue dest = getQueue(targetQueueName);
+    if (dest != null && dest instanceof PlanQueue) {
+      // use the default child reservation queue of the plan
+      targetQueueName = targetQueueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;
+    }
+    return targetQueueName;
+  }
+
+  @Override
+  public Set<String> getPlanQueues() {
+    Set<String> ret = new HashSet<String>();
+    for (Map.Entry<String, CSQueue> l : queues.entrySet()) {
+      if (l.getValue() instanceof PlanQueue) {
+        ret.add(l.getKey());
+      }
+    }
+    return ret;
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS8 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS74 INS42 INS8 INS60 INS60 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS25 INS25 INS41 INS42 INS43 INS42 INS42 INS21 INS60 INS25 INS60 INS25 INS21 INS21 INS21 INS42 INS43 INS42 INS42 INS25 INS60 INS25 INS60 INS60 INS21 INS21 INS21 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS60 INS60 INS25 INS25 INS60 INS60 INS60 INS25 INS21 INS60 INS42 INS43 INS42 INS60 INS25 INS41 INS42 INS43 INS43 INS60 INS70 INS41 INS8 MOV43 MOV5 INS59 INS39 INS59 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS27 INS8 INS8 INS42 INS42 INS32 INS43 INS59 INS38 INS8 INS43 INS59 INS27 INS8 INS32 INS32 INS32 INS42 INS38 INS8 INS43 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS32 INS32 INS32 INS42 INS42 MOV43 INS59 INS43 INS59 INS38 INS8 INS38 INS8 INS43 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS8 INS32 INS43 INS59 INS43 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS42 INS74 INS59 INS44 INS32 INS8 INS42 INS74 INS42 UPD42 INS25 UPD42 MOV16 INS42 INS32 INS42 INS32 INS25 INS25 INS60 INS25 INS42 INS42 INS32 INS36 INS38 INS41 INS42 INS33 INS60 INS21 INS25 INS21 INS21 INS42 INS42 INS27 INS42 INS42 INS32 INS36 INS53 INS42 INS42 INS11 INS32 INS34 INS53 INS36 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS27 INS36 INS53 INS42 INS42 INS11 INS27 INS38 INS53 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS11 INS36 INS53 INS36 INS53 INS42 INS42 INS11 INS42 INS32 INS42 INS27 INS27 INS27 INS25 INS21 INS53 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS27 INS62 INS21 INS43 INS43 INS42 INS14 INS74 INS42 INS42 INS42 INS25 INS43 INS43 INS43 INS38 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS8 INS8 INS42 INS8 INS43 INS59 INS27 INS8 INS42 INS42 INS27 INS36 INS42 INS43 INS59 INS7 INS27 INS8 INS7 INS7 INS45 INS42 INS52 INS42 INS42 INS62 INS14 INS43 INS42 INS42 INS42 INS14 INS11 INS52 INS42 INS45 INS42 INS45 INS62 INS14 INS43 INS42 INS32 INS33 INS36 INS14 INS43 INS32 INS42 INS42 INS52 INS42 INS45 INS42 INS45 INS42 INS42 INS43 INS32 INS62 INS14 INS62 INS14 INS43 INS42 INS36 INS42 INS27 INS32 INS42 INS34 INS42 INS27 INS27 INS8 INS32 INS14 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS33 INS42 INS43 INS7 INS42 INS42 INS74 INS43 INS43 INS43 INS62 INS8 INS40 INS42 INS42 INS36 MOV25 INS21 MOV21 MOV21 INS53 INS42 INS42 INS32 INS42 INS33 MOV21 INS42 INS33 INS62 INS42 INS42 INS32 INS42 INS32 INS42 INS33 INS60 INS21 INS41 INS42 INS42 INS42 INS27 INS42 INS43 INS43 INS27 INS42 INS43 INS27 INS43 INS32 INS42 INS43 INS43 INS27 INS42 INS42 INS42 INS62 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS27 INS42 INS43 INS43 INS27 INS42 INS11 INS42 INS32 INS42 INS42 INS34 INS40 INS27 INS27 INS41 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS27 INS43 INS43 INS40 INS42 INS42 INS32 INS43 INS21 INS62 INS7 INS14 INS42 MOV32 INS32 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS33 INS42 INS40 INS42 INS42 INS27 INS42 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS43 INS42 INS45 INS32 INS45 INS42 INS42 INS27 INS42 INS45 INS42 INS42 INS45 INS42 INS45 INS43 INS42 INS42 INS42 INS32 INS34 INS32 INS34 INS42 INS45 INS32 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS43 INS42 INS14 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS42 INS14 INS45 INS45 INS32 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS32 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS52 INS42 INS42 INS42 DEL42 DEL42 DEL8 DEL42 DEL42 DEL32
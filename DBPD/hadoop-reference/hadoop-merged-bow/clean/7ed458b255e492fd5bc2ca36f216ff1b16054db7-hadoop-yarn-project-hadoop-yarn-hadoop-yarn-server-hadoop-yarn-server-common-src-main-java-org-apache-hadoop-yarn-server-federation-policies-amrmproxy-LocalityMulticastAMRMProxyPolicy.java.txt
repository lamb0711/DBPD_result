YARN-8697. LocalityMulticastAMRMProxyPolicy should fallback to random sub-cluster when cannot resolve resource. Contributed by Botong Huang.

+import java.util.Iterator;
+import java.util.Map.Entry;
+import java.util.Random;
+  private static Random rand = new Random();
+
-      // any cluster. Defaulting to home subcluster.
+      // any cluster. Pick a random sub-cluster from active and enabled ones.
+      targetId = getSubClusterForUnResolvedRequest(bookkeeper,
+          rr.getAllocationRequestId());
-            + rr.getResourceName() + " we are falling back to homeSubCluster:"
-            + homeSubcluster);
+            + rr.getResourceName() + ", picked a random subcluster to forward:"
+            + targetId);
-
-      // If home-subcluster is not active, ignore node/rack request
-      if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {
-        if (targetIds != null && targetIds.size() > 0) {
-          bookkeeper.addRackRR(homeSubcluster, rr);
-        } else {
-          bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);
-        }
+      if (targetIds != null && targetIds.size() > 0) {
+        bookkeeper.addRackRR(targetId, rr);
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("The homeSubCluster (" + homeSubcluster + ") we are "
-              + "defaulting to is not active, the ResourceRequest "
-              + "will be ignored.");
-        }
+        bookkeeper.addLocalizedNodeRR(targetId, rr);
+   * For unit test to override.
+   */
+  protected SubClusterId getSubClusterForUnResolvedRequest(
+      AllocationBookkeeper bookKeeper, long allocationId) {
+    return bookKeeper.getSubClusterForUnResolvedRequest(allocationId);
+  }
+
+  /**
-  private final class AllocationBookkeeper {
+  protected final class AllocationBookkeeper {
+    private Map<SubClusterId, Set<Long>> maskForRackDeletion = new HashMap<>();
+    // Store the randomly selected subClusterId for unresolved resource requests
+    // keyed by requestId
+    private Map<Long, SubClusterId> unResolvedRequestLocation = new HashMap<>();
+
+      maskForRackDeletion.clear();
-      internalAddToAnswer(targetId, rr);
+      internalAddToAnswer(targetId, rr, false);
-    public void addRackRR(SubClusterId targetId, ResourceRequest rr) {
+    private void addRackRR(SubClusterId targetId, ResourceRequest rr) {
-      internalAddToAnswer(targetId, rr);
+      internalAddToAnswer(targetId, rr, true);
-      internalAddToAnswer(targetId, rr);
+      internalAddToAnswer(targetId, rr, false);
-        ResourceRequest partialRR) {
+        ResourceRequest partialRR, boolean isRack) {
+      if (!isRack) {
+        if (!maskForRackDeletion.containsKey(targetId)) {
+          maskForRackDeletion.put(targetId, new HashSet<Long>());
+        }
+        maskForRackDeletion.get(targetId)
+            .add(partialRR.getAllocationRequestId());
+      }
+     * For requests whose location cannot be resolved, choose an active and
+     * enabled sub-cluster to forward this requestId to.
+     */
+    private SubClusterId getSubClusterForUnResolvedRequest(long allocationId) {
+      if (unResolvedRequestLocation.containsKey(allocationId)) {
+        return unResolvedRequestLocation.get(allocationId);
+      }
+      int id = rand.nextInt(activeAndEnabledSC.size());
+      for (SubClusterId subclusterId : activeAndEnabledSC) {
+        if (id == 0) {
+          unResolvedRequestLocation.put(allocationId, subclusterId);
+          return subclusterId;
+        }
+        id--;
+      }
+      throw new RuntimeException(
+          "Should not be here. activeAndEnabledSC size = "
+              + activeAndEnabledSC.size() + " id = " + id);
+    }
+
+    /**
+      Iterator<Entry<SubClusterId, List<ResourceRequest>>> answerIter =
+          answer.entrySet().iterator();
+      // Remove redundant rack RR before returning the answer
+      while (answerIter.hasNext()) {
+        Entry<SubClusterId, List<ResourceRequest>> entry = answerIter.next();
+        SubClusterId scId = entry.getKey();
+        Set<Long> mask = maskForRackDeletion.get(scId);
+        if (mask != null) {
+          Iterator<ResourceRequest> rrIter = entry.getValue().iterator();
+          while (rrIter.hasNext()) {
+            ResourceRequest rr = rrIter.next();
+            if (!mask.contains(rr.getAllocationRequestId())) {
+              rrIter.remove();
+            }
+          }
+        }
+        if (mask == null || entry.getValue().size() == 0) {
+          answerIter.remove();
+          LOG.info("removing {} from output because it has only rack RR",
+              scId);
+        }
+      }

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS31 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS44 INS44 INS8 UPD83 INS23 INS23 INS31 INS42 INS42 INS14 INS65 INS42 INS43 INS42 INS39 INS42 INS41 INS83 INS74 INS59 INS83 INS74 INS59 UPD83 INS44 INS29 INS83 INS43 INS42 INS44 INS8 INS8 INS43 INS66 INS42 INS32 INS43 INS43 INS74 INS42 INS14 INS43 INS43 INS43 INS42 INS14 INS21 INS39 INS42 INS25 INS65 INS42 INS39 INS42 INS25 INS60 INS70 INS53 INS60 INS61 MOV41 INS42 INS21 MOV25 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS74 INS42 INS42 INS42 INS74 INS32 INS38 INS8 INS66 INS66 INS32 INS8 INS39 INS59 INS44 INS42 INS8 INS14 INS74 INS59 INS32 INS8 INS7 INS42 INS42 INS43 INS43 INS42 INS42 INS9 INS9 INS9 INS42 INS25 INS21 INS42 INS42 INS42 INS41 INS42 INS32 INS43 INS42 INS25 INS21 INS43 INS27 INS43 INS74 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS25 INS25 INS42 INS32 INS42 INS42 INS38 INS8 INS32 INS32 INS42 INS42 INS32 INS42 INS27 INS8 INS37 INS42 INS45 INS32 INS45 INS42 INS42 INS43 INS43 INS74 INS32 INS42 INS74 INS59 INS43 INS59 INS74 INS59 INS27 INS8 INS27 INS8 INS42 MOV42 INS32 INS32 INS21 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS43 INS43 INS74 INS42 INS32 INS42 INS42 INS32 INS43 INS43 INS42 INS32 INS42 INS33 INS60 INS61 INS27 INS27 INS21 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS59 INS32 INS8 INS42 INS33 INS32 INS34 INS32 INS32 UPD45 UPD42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS42 INS60 INS25 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS74 INS42 INS42 INS32 INS42 INS43 INS59 INS38 INS8 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS32 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 DEL32 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL45 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8
HDFS-11246. FSNameSystem#logAuditEvent should be called outside the read or write locks. Contributed by He Xiaoqiao, Kuhu Shukla.

Signed-off-by: Wei-Chiu Chuang <weichiu@apache.org>
Co-authored-by: Kuhu Shukla <kshukla@apache.org>

-    readLock();
-      checkOperation(OperationCategory.READ);
-      if(openFilesTypes.contains(OpenFilesType.ALL_OPEN_FILES)) {
-        batchedListEntries = leaseManager.getUnderConstructionFiles(prevId,
-            path);
-      } else {
-        if(openFilesTypes.contains(OpenFilesType.BLOCKING_DECOMMISSION)) {
-          batchedListEntries = getFilesBlockingDecom(prevId, path);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        if (openFilesTypes.contains(OpenFilesType.ALL_OPEN_FILES)) {
+          batchedListEntries = leaseManager.getUnderConstructionFiles(prevId,
+              path);
-          throw new IllegalArgumentException("Unknown OpenFileType: "
-              + openFilesTypes);
+          if (openFilesTypes.contains(OpenFilesType.BLOCKING_DECOMMISSION)) {
+            batchedListEntries = getFilesBlockingDecom(prevId, path);
+          } else {
+            throw new IllegalArgumentException("Unknown OpenFileType: "
+                + openFilesTypes);
+          }
+      } finally {
+        readUnlock(operationName);
-    } finally {
-      readUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot set permission for " + src);
-      auditStat = FSDirAttrOp.setPermission(dir, pc, src, permission);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot set permission for " + src);
+        auditStat = FSDirAttrOp.setPermission(dir, pc, src, permission);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot set owner for " + src);
-      auditStat = FSDirAttrOp.setOwner(dir, pc, src, username, group);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot set owner for " + src);
+        auditStat = FSDirAttrOp.setOwner(dir, pc, src, username, group);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    readLock();
-      checkOperation(OperationCategory.READ);
-      res = FSDirStatAndListingOp.getBlockLocations(
-          dir, pc, srcArg, offset, length, true);
-      if (isInSafeMode()) {
-        for (LocatedBlock b : res.blocks.getLocatedBlocks()) {
-          // if safemode & no block locations yet then throw safemodeException
-          if ((b.getLocations() == null) || (b.getLocations().length == 0)) {
-            SafeModeException se = newSafemodeException(
-                "Zero blocklocations for " + srcArg);
-            if (haEnabled && haContext != null &&
-                (haContext.getState().getServiceState() == ACTIVE ||
-                    haContext.getState().getServiceState() == OBSERVER)) {
-              throw new RetriableException(se);
-            } else {
-              throw se;
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        res = FSDirStatAndListingOp.getBlockLocations(
+            dir, pc, srcArg, offset, length, true);
+        if (isInSafeMode()) {
+          for (LocatedBlock b : res.blocks.getLocatedBlocks()) {
+            // if safemode & no block locations yet then throw safemodeException
+            if ((b.getLocations() == null) || (b.getLocations().length == 0)) {
+              SafeModeException se = newSafemodeException(
+                  "Zero blocklocations for " + srcArg);
+              if (haEnabled && haContext != null &&
+                  (haContext.getState().getServiceState() == ACTIVE ||
+                      haContext.getState().getServiceState() == OBSERVER)) {
+                throw new RetriableException(se);
+              } else {
+                throw se;
+              }
+            }
+          }
+        } else if (haEnabled && haContext != null &&
+            haContext.getState().getServiceState() == OBSERVER) {
+          for (LocatedBlock b : res.blocks.getLocatedBlocks()) {
+            if (b.getLocations() == null || b.getLocations().length == 0) {
+              throw new ObserverRetryOnActiveException("Zero blocklocations "
+                  + "for " + srcArg);
-      } else if (haEnabled && haContext != null &&
-          haContext.getState().getServiceState() == OBSERVER) {
-        for (LocatedBlock b : res.blocks.getLocatedBlocks()) {
-          if (b.getLocations() == null || b.getLocations().length == 0) {
-            throw new ObserverRetryOnActiveException("Zero blocklocations for "
-                + srcArg);
-          }
-        }
+      } finally {
+        readUnlock(operationName);
-    } finally {
-      readUnlock(operationName);
-      writeLock();
-      final long now = now();
-        checkOperation(OperationCategory.WRITE);
-        /**
-         * Resolve the path again and update the atime only when the file
-         * exists.
-         *
-         * XXX: Races can still occur even after resolving the path again.
-         * For example:
-         *
-         * <ul>
-         *   <li>Get the block location for "/a/b"</li>
-         *   <li>Rename "/a/b" to "/c/b"</li>
-         *   <li>The second resolution still points to "/a/b", which is
-         *   wrong.</li>
-         * </ul>
-         *
-         * The behavior is incorrect but consistent with the one before
-         * HDFS-7463. A better fix is to change the edit log of SetTime to
-         * use inode id instead of a path.
-         */
-        final INodesInPath iip = dir.resolvePath(pc, srcArg, DirOp.READ);
-        src = iip.getPath();
+        writeLock();
+        final long now = now();
+        try {
+          checkOperation(OperationCategory.WRITE);
+          /**
+           * Resolve the path again and update the atime only when the file
+           * exists.
+           *
+           * XXX: Races can still occur even after resolving the path again.
+           * For example:
+           *
+           * <ul>
+           *   <li>Get the block location for "/a/b"</li>
+           *   <li>Rename "/a/b" to "/c/b"</li>
+           *   <li>The second resolution still points to "/a/b", which is
+           *   wrong.</li>
+           * </ul>
+           *
+           * The behavior is incorrect but consistent with the one before
+           * HDFS-7463. A better fix is to change the edit log of SetTime to
+           * use inode id instead of a path.
+           */
+          final INodesInPath iip = dir.resolvePath(pc, srcArg, DirOp.READ);
+          src = iip.getPath();
-        INode inode = iip.getLastINode();
-        boolean updateAccessTime = inode != null &&
-            now > inode.getAccessTime() + dir.getAccessTimePrecision();
-        if (!isInSafeMode() && updateAccessTime) {
-          boolean changed = FSDirAttrOp.setTimes(dir, iip, -1, now, false);
-          if (changed) {
-            getEditLog().logTimes(src, -1, now);
+          INode inode = iip.getLastINode();
+          boolean updateAccessTime = inode != null &&
+              now > inode.getAccessTime() + dir.getAccessTimePrecision();
+          if (!isInSafeMode() && updateAccessTime) {
+            boolean changed = FSDirAttrOp.setTimes(dir, iip, -1, now, false);
+            if (changed) {
+              getEditLog().logTimes(src, -1, now);
+            }
+        } finally {
+          writeUnlock(operationName);
-      } finally {
-        writeUnlock(operationName);
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot concat " + target);
-      stat = FSDirConcatOp.concat(dir, pc, target, srcs, logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot concat " + target);
+        stat = FSDirConcatOp.concat(dir, pc, target, srcs, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, Arrays.toString(srcs),
+      logAuditEvent(false, operationName, Arrays.toString(srcs),
-      writeUnlock(operationName);
-      if (success) {
-        getEditLog().logSync();
-      }
+      getEditLog().logSync();
-    logAuditEvent(success, operationName, Arrays.toString(srcs), target, stat);
+    logAuditEvent(true, operationName, Arrays.toString(srcs), target, stat);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot set times " + src);
-      auditStat = FSDirAttrOp.setTimes(dir, pc, src, mtime, atime);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot set times " + src);
+        auditStat = FSDirAttrOp.setTimes(dir, pc, src, mtime, atime);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot create symlink " + link);
-      auditStat = FSDirSymlinkOp.createSymlinkInt(this, target, link, dirPerms,
-                                                  createParent, logRetryCache);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot create symlink " + link);
+        auditStat = FSDirSymlinkOp.createSymlinkInt(this, target, link,
+            dirPerms, createParent, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot set replication for " + src);
-      success = FSDirAttrOp.setReplication(dir, pc, blockManager, src,
-          replication);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot set replication for " + src);
+        success = FSDirAttrOp.setReplication(dir, pc, blockManager, src,
+            replication);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot set storage policy for " + src);
-      auditStat = FSDirAttrOp.setStoragePolicy(dir, pc, blockManager, src,
-                                               policyName);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot set storage policy for " + src);
+        auditStat = FSDirAttrOp.setStoragePolicy(dir, pc, blockManager, src,
+            policyName);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot satisfy storage policy for " + src);
-      auditStat = FSDirSatisfyStoragePolicyOp.satisfyStoragePolicy(
-          dir, blockManager, src, logRetryCache);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot satisfy storage policy for " + src);
+        auditStat = FSDirSatisfyStoragePolicyOp.satisfyStoragePolicy(
+            dir, blockManager, src, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot unset storage policy for " + src);
-      auditStat = FSDirAttrOp.unsetStoragePolicy(dir, pc, blockManager, src);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot unset storage policy for " + src);
+        auditStat = FSDirAttrOp.unsetStoragePolicy(dir, pc, blockManager, src);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot rename " + src);
-      ret = FSDirRenameOp.renameToInt(dir, pc, src, dst, logRetryCache);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot rename " + src);
+        ret = FSDirRenameOp.renameToInt(dir, pc, src, dst, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot rename " + src);
-      res = FSDirRenameOp.renameToInt(dir, pc, src, dst, logRetryCache,
-          options);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot rename " + src);
+        res = FSDirRenameOp.renameToInt(dir, pc, src, dst, logRetryCache,
+            options);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot delete " + src);
-      toRemovedBlocks = FSDirDeleteOp.delete(
-          this, pc, src, recursive, logRetryCache);
-      ret = toRemovedBlocks != null;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot delete " + src);
+        toRemovedBlocks = FSDirDeleteOp.delete(
+            this, pc, src, recursive, logRetryCache);
+        ret = toRemovedBlocks != null;
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    readLock();
-      checkOperation(OperationCategory.READ);
-      stat = FSDirStatAndListingOp.getFileInfo(
-          dir, pc, src, resolveLink, needLocation, needBlockToken);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        stat = FSDirStatAndListingOp.getFileInfo(
+            dir, pc, src, resolveLink, needLocation, needBlockToken);
+      } finally {
+        readUnlock(operationName);
+      }
-    } finally {
-      readUnlock(operationName);
-    readLock();
-      checkOperation(OperationCategory.READ);
-      return FSDirStatAndListingOp.isFileClosed(dir, pc, src);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        return FSDirStatAndListingOp.isFileClosed(dir, pc, src);
+      } finally {
+        readUnlock(operationName);
+      }
-    } finally {
-      readUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot create directory " + src);
-      auditStat = FSDirMkdirOp.mkdirs(this, pc, src, permissions,
-          createParent);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot create directory " + src);
+        auditStat = FSDirMkdirOp.mkdirs(this, pc, src, permissions,
+            createParent);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    boolean success = true;
-    readLock();
-      checkOperation(OperationCategory.READ);
-      cs = FSDirStatAndListingOp.getContentSummary(dir, pc, src);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        cs = FSDirStatAndListingOp.getContentSummary(dir, pc, src);
+      } finally {
+        readUnlock(operationName);
+      }
-      success = false;
-      logAuditEvent(success, operationName, src);
+      logAuditEvent(false, operationName, src);
-    } finally {
-      readUnlock(operationName);
-    logAuditEvent(success, operationName, src);
+    logAuditEvent(true, operationName, src);
-    readLock();
-    boolean success = true;
-      checkOperation(OperationCategory.READ);
-      quotaUsage = FSDirStatAndListingOp.getQuotaUsage(dir, pc, src);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        quotaUsage = FSDirStatAndListingOp.getQuotaUsage(dir, pc, src);
+      } finally {
+        readUnlock(operationName);
+      }
-      success = false;
-      logAuditEvent(success, operationName, src);
+      logAuditEvent(false, operationName, src);
-    } finally {
-      readUnlock(operationName);
-    logAuditEvent(success, operationName, src);
+    logAuditEvent(true, operationName, src);
-    writeLock();
-    boolean success = false;
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot set quota on " + src);
-      FSDirAttrOp.setQuota(dir, pc, src, nsQuota, ssQuota, type);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot set quota on " + src);
+        FSDirAttrOp.setQuota(dir, pc, src, nsQuota, ssQuota, type);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, src);
+      logAuditEvent(false, operationName, src);
-      writeUnlock(operationName);
-      if (success) {
-        getEditLog().logSync();
-      }
+      getEditLog().logSync();
-    logAuditEvent(success, operationName, src);
+    logAuditEvent(true, operationName, src);
-    readLock();
-      checkOperation(NameNode.OperationCategory.READ);
-      dl = getListingInt(dir, pc, src, startAfter, needLocation);
+      readLock();
+      try {
+        checkOperation(NameNode.OperationCategory.READ);
+        dl = getListingInt(dir, pc, src, startAfter, needLocation);
+      } finally {
+        readUnlock(operationName);
+      }
-    } finally {
-      readUnlock(operationName);
-      readUnlock("getDatanodeStorageReport");
+      readUnlock(operationName);
-      writeUnlock("getDelegationToken");
+      writeUnlock(operationName);
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot renew delegation token");
-      if (!isAllowedDelegationTokenOp()) {
-        throw new IOException(
-            "Delegation Token can be renewed only with kerberos or web authentication");
+        checkNameNodeSafeMode("Cannot renew delegation token");
+        if (!isAllowedDelegationTokenOp()) {
+          throw new IOException(
+              "Delegation Token can be renewed only with kerberos or web "
+                  + "authentication");
+        }
+        String renewer = getRemoteUser().getShortUserName();
+        expiryTime = dtSecretManager.renewToken(token, renewer);
+        final DelegationTokenIdentifier id = DFSUtil.decodeDelegationToken(
+            token);
+        getEditLog().logRenewDelegationToken(id, expiryTime);
+        tokenId = id.toStringStable();
+      } finally {
+        writeUnlock(operationName);
-      String renewer = getRemoteUser().getShortUserName();
-      expiryTime = dtSecretManager.renewToken(token, renewer);
-      final DelegationTokenIdentifier id = DFSUtil.decodeDelegationToken(token);
-      getEditLog().logRenewDelegationToken(id, expiryTime);
-      tokenId = id.toStringStable();
-      success = true;
-      logAuditEvent(success, operationName, tokenId);
+      logAuditEvent(false, operationName, tokenId);
-    } finally {
-      writeUnlock("renewDelegationToken");
-    logAuditEvent(success, operationName, tokenId);
+    logAuditEvent(true, operationName, tokenId);
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-
-      checkNameNodeSafeMode("Cannot cancel delegation token");
-      String canceller = getRemoteUser().getUserName();
-      DelegationTokenIdentifier id = dtSecretManager
-        .cancelToken(token, canceller);
-      getEditLog().logCancelDelegationToken(id);
-      tokenId = id.toStringStable();
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot cancel delegation token");
+        String canceller = getRemoteUser().getUserName();
+        DelegationTokenIdentifier id = dtSecretManager
+            .cancelToken(token, canceller);
+        getEditLog().logCancelDelegationToken(id);
+        tokenId = id.toStringStable();
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, tokenId);
+      logAuditEvent(false, operationName, tokenId);
-    } finally {
-      writeUnlock("cancelDelegationToken");
-    logAuditEvent(success, operationName, tokenId);
+    logAuditEvent(true, operationName, tokenId);
-    boolean success = false;
-      success = true;
-    logAuditEvent(success, operationName, path, null, null);
+    logAuditEvent(true, operationName, path, null, null);
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot create snapshot for " + snapshotRoot);
-      snapshotPath = FSDirSnapshotOp.createSnapshot(dir, pc,
-          snapshotManager, snapshotRoot, snapshotName, logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot create snapshot for " + snapshotRoot);
+        snapshotPath = FSDirSnapshotOp.createSnapshot(dir, pc,
+            snapshotManager, snapshotRoot, snapshotName, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, snapshotRoot,
+      logAuditEvent(false, operationName, snapshotRoot,
-    } finally {
-      writeUnlock(operationName);
-    logAuditEvent(success, operationName, snapshotRoot,
+    logAuditEvent(true, operationName, snapshotRoot,
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot rename snapshot for " + path);
-      FSDirSnapshotOp.renameSnapshot(dir, pc, snapshotManager, path,
-          snapshotOldName, snapshotNewName, logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot rename snapshot for " + path);
+        FSDirSnapshotOp.renameSnapshot(dir, pc, snapshotManager, path,
+            snapshotOldName, snapshotNewName, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, oldSnapshotRoot,
+      logAuditEvent(false, operationName, oldSnapshotRoot,
-    } finally {
-      writeUnlock(operationName);
-    logAuditEvent(success, operationName, oldSnapshotRoot,
+    logAuditEvent(true, operationName, oldSnapshotRoot,
-    boolean success = false;
-    readLock();
-      checkOperation(OperationCategory.READ);
-      status = FSDirSnapshotOp.getSnapshottableDirListing(dir, pc,
-          snapshotManager);
-      success = true;
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        status = FSDirSnapshotOp.getSnapshottableDirListing(dir, pc,
+            snapshotManager);
+      } finally {
+        readUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, null, null, null);
+      logAuditEvent(false, operationName, null, null, null);
-    } finally {
-      readUnlock(operationName);
-    logAuditEvent(success, operationName, null, null, null);
+    logAuditEvent(true, operationName, null, null, null);
-    boolean success = false;
-    readLock();
-      checkOperation(OperationCategory.READ);
-      diffs = FSDirSnapshotOp.getSnapshotDiffReport(dir, pc, snapshotManager,
-          path, fromSnapshot, toSnapshot);
-      success = true;
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        diffs = FSDirSnapshotOp.getSnapshotDiffReport(dir, pc, snapshotManager,
+            path, fromSnapshot, toSnapshot);
+      } finally {
+        readUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, fromSnapshotRoot,
+      logAuditEvent(false, operationName, fromSnapshotRoot,
-    } finally {
-      readUnlock(operationName);
-
-    logAuditEvent(success, operationName, fromSnapshotRoot,
+    logAuditEvent(true, operationName, fromSnapshotRoot,
-    boolean success = false;
-    readLock();
-      checkOperation(OperationCategory.READ);
-      diffs = FSDirSnapshotOp
-          .getSnapshotDiffReportListing(dir, pc, snapshotManager, path,
-              fromSnapshot, toSnapshot, startPath, index,
-              snapshotDiffReportLimit);
-      success = true;
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        diffs = FSDirSnapshotOp
+            .getSnapshotDiffReportListing(dir, pc, snapshotManager, path,
+                fromSnapshot, toSnapshot, startPath, index,
+                snapshotDiffReportLimit);
+      } finally {
+        readUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, fromSnapshotRoot, toSnapshotRoot,
+      logAuditEvent(false, operationName, fromSnapshotRoot, toSnapshotRoot,
-    } finally {
-      readUnlock(operationName);
-    logAuditEvent(success, operationName, fromSnapshotRoot, toSnapshotRoot,
+    logAuditEvent(true, operationName, fromSnapshotRoot, toSnapshotRoot,
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot delete snapshot for " + snapshotRoot);
-      rootPath = Snapshot.getSnapshotPath(snapshotRoot, snapshotName);
-      blocksToBeDeleted = FSDirSnapshotOp.deleteSnapshot(dir, pc,
-          snapshotManager, snapshotRoot, snapshotName, logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot delete snapshot for " + snapshotRoot);
+        rootPath = Snapshot.getSnapshotPath(snapshotRoot, snapshotName);
+        blocksToBeDeleted = FSDirSnapshotOp.deleteSnapshot(dir, pc,
+            snapshotManager, snapshotRoot, snapshotName, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, rootPath, null, null);
+      logAuditEvent(false, operationName, rootPath, null, null);
-    } finally {
-      writeUnlock(operationName);
-    logAuditEvent(success, operationName, rootPath, null, null);
+    logAuditEvent(true, operationName, rootPath, null, null);
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot add cache directive");
-      effectiveDirective = FSNDNCacheOp.addCacheDirective(this, cacheManager,
-          directive, flags, logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot add cache directive");
+        effectiveDirective = FSNDNCacheOp.addCacheDirective(this, cacheManager,
+            directive, flags, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, null,
+      logAuditEvent(false, operationName, null,
-      writeUnlock(operationName);
-      if (success) {
-        getEditLog().logSync();
-      }
+      getEditLog().logSync();
-    logAuditEvent(success, operationName, effectiveDirectiveStr,
+    logAuditEvent(true, operationName, effectiveDirectiveStr,
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot add cache directive");
-      FSNDNCacheOp.modifyCacheDirective(this, cacheManager, directive, flags,
-          logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot add cache directive");
+        FSNDNCacheOp.modifyCacheDirective(this, cacheManager, directive, flags,
+            logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, idStr,
+      logAuditEvent(false, operationName, idStr,
-      writeUnlock(operationName);
-      if (success) {
-        getEditLog().logSync();
-      }
+      getEditLog().logSync();
-    logAuditEvent(success, operationName, idStr,
+    logAuditEvent(true, operationName, idStr,
-    boolean success = false;
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot remove cache directives");
-      FSNDNCacheOp.removeCacheDirective(this, cacheManager, id, logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot remove cache directives");
+        FSNDNCacheOp.removeCacheDirective(this, cacheManager, id,
+            logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, idStr, null, null);
+      logAuditEvent(false, operationName, idStr, null, null);
-    } finally {
-      writeUnlock(operationName);
-    logAuditEvent(success, operationName, idStr, null, null);
+    logAuditEvent(true, operationName, idStr, null, null);
-    readLock();
-    boolean success = false;
-      checkOperation(OperationCategory.READ);
-      results = FSNDNCacheOp.listCacheDirectives(this, cacheManager, startId,
-          filter);
-      success = true;
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        results = FSNDNCacheOp.listCacheDirectives(this, cacheManager, startId,
+            filter);
+      } finally {
+        readUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, filter.toString(), null,
+      logAuditEvent(false, operationName, filter.toString(), null,
-    } finally {
-      readUnlock(operationName);
-    logAuditEvent(success, operationName, filter.toString(), null,
+    logAuditEvent(true, operationName, filter.toString(), null,
-    writeLock();
-    boolean success = false;
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot add cache pool"
-          + (req == null ? null : req.getPoolName()));
-      CachePoolInfo info = FSNDNCacheOp.addCachePool(this, cacheManager, req,
-          logRetryCache);
-      poolInfoStr = info.toString();
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot add cache pool"
+            + (req == null ? null : req.getPoolName()));
+        CachePoolInfo info = FSNDNCacheOp.addCachePool(this, cacheManager, req,
+            logRetryCache);
+        poolInfoStr = info.toString();
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, poolInfoStr, null, null);
+      logAuditEvent(false, operationName, poolInfoStr, null, null);
-    } finally {
-      writeUnlock(operationName);
-    logAuditEvent(success, operationName, poolInfoStr, null, null);
+    logAuditEvent(true, operationName, poolInfoStr, null, null);
-    writeLock();
-    boolean success = false;
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot modify cache pool"
-          + (req == null ? null : req.getPoolName()));
-      FSNDNCacheOp.modifyCachePool(this, cacheManager, req, logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot modify cache pool"
+            + (req == null ? null : req.getPoolName()));
+        FSNDNCacheOp.modifyCachePool(this, cacheManager, req, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, poolNameStr,
+      logAuditEvent(false, operationName, poolNameStr,
-    } finally {
-      writeUnlock(operationName);
-    logAuditEvent(success, operationName, poolNameStr,
+    logAuditEvent(true, operationName, poolNameStr,
-    writeLock();
-    boolean success = false;
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot modify cache pool" + cachePoolName);
-      FSNDNCacheOp.removeCachePool(this, cacheManager, cachePoolName,
-          logRetryCache);
-      success = true;
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot modify cache pool" + cachePoolName);
+        FSNDNCacheOp.removeCachePool(this, cacheManager, cachePoolName,
+            logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, poolNameStr, null, null);
+      logAuditEvent(false, operationName, poolNameStr, null, null);
-    } finally {
-      writeUnlock(operationName);
-    logAuditEvent(success, operationName, poolNameStr, null, null);
+    logAuditEvent(true, operationName, poolNameStr, null, null);
-    boolean success = false;
-    readLock();
-      checkOperation(OperationCategory.READ);
-      results = FSNDNCacheOp.listCachePools(this, cacheManager, prevKey);
-      success = true;
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        results = FSNDNCacheOp.listCachePools(this, cacheManager, prevKey);
+      } finally {
+        readUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, null, null, null);
+      logAuditEvent(false, operationName, null, null, null);
-    } finally {
-      readUnlock(operationName);
-    logAuditEvent(success, operationName, null, null, null);
+    logAuditEvent(true, operationName, null, null, null);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot modify ACL entries on " + src);
-      auditStat = FSDirAclOp.modifyAclEntries(dir, pc, src, aclSpec);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot modify ACL entries on " + src);
+        auditStat = FSDirAclOp.modifyAclEntries(dir, pc, src, aclSpec);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot remove ACL entries on " + src);
-      auditStat = FSDirAclOp.removeAclEntries(dir, pc, src, aclSpec);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot remove ACL entries on " + src);
+        auditStat = FSDirAclOp.removeAclEntries(dir, pc, src, aclSpec);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot remove default ACL entries on " + src);
-      auditStat = FSDirAclOp.removeDefaultAcl(dir, pc, src);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot remove default ACL entries on " + src);
+        auditStat = FSDirAclOp.removeDefaultAcl(dir, pc, src);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot remove ACL on " + src);
-      auditStat = FSDirAclOp.removeAcl(dir, pc, src);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot remove ACL on " + src);
+        auditStat = FSDirAclOp.removeAcl(dir, pc, src);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot set ACL on " + src);
-      auditStat = FSDirAclOp.setAcl(dir, pc, src, aclSpec);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot set ACL on " + src);
+        auditStat = FSDirAclOp.setAcl(dir, pc, src, aclSpec);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    readLock();
-      checkOperation(OperationCategory.READ);
-      ret = FSDirAclOp.getAclStatus(dir, pc, src);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        ret = FSDirAclOp.getAclStatus(dir, pc, src);
+      } finally {
+        readUnlock(operationName);
+      }
-    } finally {
-      readUnlock(operationName);
-    boolean success = false;
-    readLock();
-      checkOperation(OperationCategory.READ);
-      Entry<EncryptionZone, FileStatus> ezForPath = FSDirEncryptionZoneOp
-          .getEZForPath(dir, srcArg, pc);
-      success = true;
-      resultingStat = ezForPath.getValue();
-      encryptionZone = ezForPath.getKey();
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        Entry<EncryptionZone, FileStatus> ezForPath = FSDirEncryptionZoneOp
+            .getEZForPath(dir, srcArg, pc);
+        resultingStat = ezForPath.getValue();
+        encryptionZone = ezForPath.getKey();
+      } finally {
+        readUnlock(operationName);
+      }
-      logAuditEvent(success, operationName, srcArg, null, resultingStat);
+      logAuditEvent(false, operationName, srcArg, null, resultingStat);
-    } finally {
-      readUnlock(operationName);
-    logAuditEvent(success, operationName, srcArg, null, resultingStat);
+    logAuditEvent(true, operationName, srcArg, null, resultingStat);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot enable erasure coding policy "
-          + ecPolicyName);
-      success = FSDirErasureCodingOp.enableErasureCodingPolicy(this,
-          ecPolicyName, logRetryCache);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot enable erasure coding policy "
+            + ecPolicyName);
+        success = FSDirErasureCodingOp.enableErasureCodingPolicy(this,
+            ecPolicyName, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot disable erasure coding policy "
-          + ecPolicyName);
-      success = FSDirErasureCodingOp.disableErasureCodingPolicy(this,
-          ecPolicyName, logRetryCache);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot disable erasure coding policy "
+            + ecPolicyName);
+        success = FSDirErasureCodingOp.disableErasureCodingPolicy(this,
+            ecPolicyName, logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-      writeUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot set XAttr on " + src);
-      auditStat = FSDirXAttrOp.setXAttr(dir, pc, src, xAttr, flag,
-          logRetryCache);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot set XAttr on " + src);
+        auditStat = FSDirXAttrOp.setXAttr(dir, pc, src, xAttr, flag,
+            logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    readLock();
-      checkOperation(OperationCategory.READ);
-      fsXattrs = FSDirXAttrOp.getXAttrs(dir, pc, src, xAttrs);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        fsXattrs = FSDirXAttrOp.getXAttrs(dir, pc, src, xAttrs);
+      } finally {
+        readUnlock(operationName);
+      }
-    } finally {
-      readUnlock(operationName);
-    readLock();
-      checkOperation(OperationCategory.READ);
-      fsXattrs = FSDirXAttrOp.listXAttrs(dir, pc, src);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        fsXattrs = FSDirXAttrOp.listXAttrs(dir, pc, src);
+      } finally {
+        readUnlock(operationName);
+      }
-    } finally {
-      readUnlock(operationName);
-    writeLock();
-      checkOperation(OperationCategory.WRITE);
-      checkNameNodeSafeMode("Cannot remove XAttr entry on " + src);
-      auditStat = FSDirXAttrOp.removeXAttr(dir, pc, src, xAttr, logRetryCache);
+      writeLock();
+      try {
+        checkOperation(OperationCategory.WRITE);
+        checkNameNodeSafeMode("Cannot remove XAttr entry on " + src);
+        auditStat = FSDirXAttrOp.removeXAttr(dir, pc, src, xAttr,
+            logRetryCache);
+      } finally {
+        writeUnlock(operationName);
+      }
-    } finally {
-      writeUnlock(operationName);
-    readLock();
-      checkOperation(OperationCategory.READ);
-      final INodesInPath iip = dir.resolvePath(pc, src, DirOp.READ);
-      src = iip.getPath();
-      INode inode = iip.getLastINode();
-      if (inode == null) {
-        throw new FileNotFoundException("Path not found");
-      }
-      if (isPermissionEnabled) {
-        dir.checkPathAccess(pc, iip, mode);
+      readLock();
+      try {
+        checkOperation(OperationCategory.READ);
+        final INodesInPath iip = dir.resolvePath(pc, src, DirOp.READ);
+        src = iip.getPath();
+        INode inode = iip.getLastINode();
+        if (inode == null) {
+          throw new FileNotFoundException("Path not found");
+        }
+        if (isPermissionEnabled) {
+          dir.checkPathAccess(pc, iip, mode);
+        }
+      } finally {
+        readUnlock(operationName);
-    } finally {
-      readUnlock(operationName);

INS54 INS54 INS54 INS54 INS54 INS54 INS54 INS54 INS54 INS54 INS54 INS54 INS54 INS54 INS54 MOV21 INS54 INS54 INS54 INS8 INS8 INS8 INS8 INS8 MOV8 INS8 INS8 INS8 INS8 INS8 INS8 INS8 INS8 INS8 INS8 INS8 INS8 INS8 INS12 INS8 INS12 INS8 INS12 MOV8 INS8 INS8 INS8 INS8 INS12 INS8 INS12 INS8 INS12 INS8 INS12 INS8 INS12 INS8 INS12 INS8 INS12 MOV8 INS8 INS12 MOV8 INS8 INS12 INS8 INS12 INS8 INS12 INS8 INS12 INS8 INS12 INS8 INS12 INS8 INS8 INS8 INS8 INS8 INS8 INS8 INS12 INS8 INS8 INS8 MOV8 INS8 INS8 INS8 INS8 INS8 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 INS9 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 MOV54 INS44 INS8 INS9 MOV21 MOV54 INS44 INS8 INS9 MOV21 MOV54 INS44 INS8 INS9 MOV21 INS54 MOV21 INS54 INS9 MOV21 INS54 INS9 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV32 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV32 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 MOV54 MOV44 INS8 INS9 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 MOV54 MOV44 INS8 INS9 MOV21 INS54 MOV25 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV21 INS54 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 INS8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 INS43 INS42 INS21 INS53 INS43 INS42 INS21 INS53 INS43 INS42 INS21 INS53 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 INS21 MOV53 INS21 MOV53 INS21 MOV53 INS21 MOV53 INS21 MOV53 INS21 MOV53 INS21 MOV53 INS21 MOV53 INS21 MOV53 INS21 MOV53 INS21 MOV53 MOV21 MOV53 INS21 MOV53 INS21 MOV53 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 INS21 MOV53 MOV8 INS8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV21 MOV60 INS54 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS21 MOV8 MOV8 INS9 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS42 INS9 INS9 INS42 INS9 INS42 INS42 INS42 INS33 INS42 INS9 INS42 INS42 INS42 INS33 INS42 INS9 INS42 INS33 INS33 INS33 INS42 INS9 INS42 INS42 INS42 INS33 INS42 INS9 INS42 INS42 INS42 INS33 INS42 INS9 INS42 INS42 INS33 INS33 INS42 INS9 INS42 INS33 INS33 INS33 INS42 INS9 INS42 INS42 MOV32 INS33 INS42 INS9 INS42 INS42 INS33 INS33 INS42 INS9 INS42 MOV32 INS33 INS33 INS42 INS9 INS42 INS42 INS33 INS33 INS9 INS42 INS9 INS42 INS42 INS33 INS33 INS42 INS9 INS42 INS33 INS33 INS33 INS42 INS9 INS42 INS42 INS33 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS45 INS45 UPD45 INS45 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL25 DEL42 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL9 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL45 DEL45 DEL39 DEL42 DEL9 DEL59 DEL60 DEL45 DEL42 DEL9 DEL7 DEL21 DEL45 DEL42 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL45 DEL42 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL33 DEL33 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL33 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL33 DEL33 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL25 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL25 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL33 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL33 DEL33 DEL32 DEL21 DEL8 DEL12 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL33 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL8 DEL12 DEL42 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL33 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL33 DEL33 DEL33 DEL32 DEL21 DEL8 DEL12 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL33 DEL42 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL42 DEL32 DEL21
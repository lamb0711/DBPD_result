MAPREDUCE-7277. IndexCache totalMemoryUsed differs from cache contents. Contributed by Jon Eagles (jeagles).

+            Thread.currentThread().interrupt();
-      LOG.debug("IndexCache HIT: MapId " + mapId + " found");
+      LOG.debug("IndexCache HIT: MapId {} found", mapId);
+            Thread.currentThread().interrupt();
-      LOG.debug("IndexCache HIT: MapId " + mapId + " found");
+      LOG.debug("IndexCache HIT: MapId {} found", mapId);
-    LOG.debug("IndexCache MISS: MapId " + mapId + " not found") ;
+    LOG.debug("IndexCache MISS: MapId {} not found", mapId);
+    boolean success = false;
-    } catch (Throwable e) { 
+      success = true;
+    } catch (Throwable e) {
+      if (e instanceof InterruptedException) {
+        Thread.currentThread().interrupt();
+      }
-    } finally { 
-      synchronized (newInd) { 
+    } finally {
+      synchronized (newInd) {
+        if (success) {
+          // Only add mapId to the queue for successful read and after added to
+          // the cache. Once in the queue, it is now eligible for removal once
+          // construction is finished.
+          queue.add(mapId);
+          if (totalMemoryUsed.addAndGet(newInd.getSize()) > totalMemoryAllowed) {
+            freeIndexInformation();
+          }
+        }
-    queue.add(mapId);
-    
-    if (totalMemoryUsed.addAndGet(newInd.getSize()) > totalMemoryAllowed) {
-      freeIndexInformation();
-    }
+
-   * This method removes the map from the cache if index information for this
-   * map is loaded(size>0), index information entry in cache will not be 
-   * removed if it is in the loading phrase(size=0), this prevents corruption  
-   * of totalMemoryUsed. It should be called when a map output on this tracker 
-   * is discarded.
+   * This method removes the map from the cache if it is present in the queue.
-  public void removeMap(String mapId) {
-    IndexInformation info = cache.get(mapId);
-    if (info == null || isUnderConstruction(info)) {
+  public void removeMap(String mapId) throws IOException {
+    // Successfully removing the mapId from the queue enters into a contract
+    // that this thread will remove the corresponding mapId from the cache.
+    if (!queue.remove(mapId)) {
+      LOG.debug("Map ID {} not found in queue", mapId);
-    info = cache.remove(mapId);
-    if (info != null) {
-      totalMemoryUsed.addAndGet(-info.getSize());
-      if (!queue.remove(mapId)) {
-        LOG.warn("Map ID" + mapId + " not found in queue!!");
+    removeMapInternal(mapId);
+  }
+
+  /** This method should only be called upon successful removal of mapId from
+   * the queue. The mapId will be removed from the cache and totalUsedMemory
+   * will be decremented.
+   * @param mapId the cache item to be removed
+   * @throws IOException
+   */
+  private void removeMapInternal(String mapId) throws IOException {
+    IndexInformation info = cache.remove(mapId);
+    if (info == null) {
+      // Inconsistent state as presence in queue implies presence in cache
+      LOG.warn("Map ID " + mapId + " not found in cache");
+      return;
+    }
+    try {
+      synchronized(info) {
+        while (isUnderConstruction(info)) {
+          info.wait();
+        }
+        totalMemoryUsed.getAndAdd(-info.getSize());
-    } else {
-      LOG.info("Map ID " + mapId + " not found in cache");
+    } catch (InterruptedException e) {
+      totalMemoryUsed.getAndAdd(-info.getSize());
+      Thread.currentThread().interrupt();
+      throw new IOException("Interrupted waiting for construction", e);
-   * This method checks if cache and totolMemoryUsed is consistent.
+   * This method checks if cache and totalMemoryUsed is consistent.
-   * @return True if cache and totolMemoryUsed is consistent
+   * @return True if cache and totalMemoryUsed is consistent
-  private synchronized void freeIndexInformation() {
+  private synchronized void freeIndexInformation() throws IOException {
-      String s = queue.remove();
-      IndexInformation info = cache.remove(s);
-      if (info != null) {
-        totalMemoryUsed.addAndGet(-info.getSize());
+      if(queue.isEmpty()) {
+        break;
+      String mapId = queue.remove();
+      removeMapInternal(mapId);

INS31 INS31 MOV29 MOV83 MOV39 MOV42 MOV44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS43 INS60 UPD42 MOV42 INS25 MOV21 INS65 INS65 INS65 INS43 INS42 INS42 INS60 INS25 INS54 INS42 INS39 INS59 UPD66 MOV38 INS8 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS42 MOV43 INS59 MOV27 MOV8 INS8 INS12 UPD66 UPD66 INS45 INS42 INS42 INS9 INS21 INS21 MOV41 INS42 INS42 INS42 MOV32 INS41 INS51 INS44 MOV8 INS25 INS21 INS7 INS25 INS8 INS32 INS42 INS8 INS43 INS42 INS21 INS53 INS32 INS8 INS32 INS45 INS42 INS45 INS42 INS42 INS9 INS62 INS8 MOV21 INS25 MOV21 UPD42 MOV42 UPD42 MOV42 INS45 MOV42 UPD42 INS61 MOV21 INS42 INS32 INS14 INS42 INS42 INS10 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS21 INS42 INS8 MOV32 INS8 UPD42 INS32 INS42 INS43 INS45 INS42 INS42 INS32 MOV21 MOV25 MOV21 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 INS21 INS21 INS32 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 DEL45 DEL42 DEL45 DEL27 DEL45 DEL42 DEL45 DEL27 DEL45 DEL42 DEL45 DEL27 DEL8 DEL66 DEL66 DEL66 DEL66 DEL42 DEL7 DEL45 DEL42 DEL45 DEL27 DEL43 DEL42 DEL32 DEL59 DEL60 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25
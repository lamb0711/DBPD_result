HADOOP-17079. Optimize UGI#getGroups by adding UGI#getGroupsSet. (#2085)


-import java.util.concurrent.Callable;
-  private final LoadingCache<String, List<String>> cache;
-  private final AtomicReference<Map<String, List<String>>> staticMapRef =
+  private final LoadingCache<String, Set<String>> cache;
+  private final AtomicReference<Map<String, Set<String>>> staticMapRef =
-    Map<String, List<String>> staticUserToGroupsMap =
-        new HashMap<String, List<String>>();
+    Map<String, Set<String>> staticUserToGroupsMap = new HashMap<>();
-      List<String> groups = Collections.emptyList();
+      Set<String> groups = Collections.emptySet();
-        groups = (List<String>) StringUtils
-            .getStringCollection(userToGroupsArray[1]);
+        groups = new LinkedHashSet(StringUtils
+            .getStringCollection(userToGroupsArray[1]));
+   * Note this method can be expensive as it involves Set->List conversion.
+   * For user with large group membership (i.e., > 1000 groups), we recommend
+   * using getGroupSet to avoid the conversion and fast membership look up via
+   * contains().
-   * @return the group memberships of the user
+   * @return the group memberships of the user as list
+   * @throws IOException if user does not exist
+   * @deprecated Use {@link #getGroupsSet(String user)} instead.
+   */
+  @Deprecated
+  public List<String> getGroups(final String user) throws IOException {
+    return Collections.unmodifiableList(new ArrayList<>(
+        getGroupInternal(user)));
+  }
+
+  /**
+   * Get the group memberships of a given user.
+   * If the user's group is not cached, this method may block.
+   * This provide better performance when user has large group membership via
+   * 1) avoid set->list->set conversion for the caller UGI/PermissionCheck
+   * 2) fast lookup using contains() via Set instead of List
+   * @param user User's name
+   * @return the group memberships of the user as set
-  public List<String> getGroups(final String user) throws IOException {
+  public Set<String> getGroupsSet(final String user) throws IOException {
+    return Collections.unmodifiableSet(getGroupInternal(user));
+  }
+
+  /**
+   * Get the group memberships of a given user.
+   * If the user's group is not cached, this method may block.
+   * @param user User's name
+   * @return the group memberships of the user as Set
+   * @throws IOException if user does not exist
+   */
+  private Set<String> getGroupInternal(final String user) throws IOException {
-    Map<String, List<String>> staticUserToGroupsMap = staticMapRef.get();
+    Map<String, Set<String>> staticUserToGroupsMap = staticMapRef.get();
-      List<String> staticMapping = staticUserToGroupsMap.get(user);
+      Set<String> staticMapping = staticUserToGroupsMap.get(user);
-  private class GroupCacheLoader extends CacheLoader<String, List<String>> {
+  private class GroupCacheLoader extends CacheLoader<String, Set<String>> {
-    public List<String> load(String user) throws Exception {
+    public Set<String> load(String user) throws Exception {
-      List<String> groups = null;
+      Set<String> groups = null;
-        groups = fetchGroupList(user);
+        groups = fetchGroupSet(user);
-      // return immutable de-duped list
-      return Collections.unmodifiableList(
-          new ArrayList<>(new LinkedHashSet<>(groups)));
+      return groups;
-    public ListenableFuture<List<String>> reload(final String key,
-                                                 List<String> oldValue)
+    public ListenableFuture<Set<String>> reload(final String key,
+                                                 Set<String> oldValue)
-      ListenableFuture<List<String>> listenableFuture =
-          executorService.submit(new Callable<List<String>>() {
-            @Override
-            public List<String> call() throws Exception {
-              backgroundRefreshQueued.decrementAndGet();
-              backgroundRefreshRunning.incrementAndGet();
-              List<String> results = load(key);
-              return results;
-            }
+      ListenableFuture<Set<String>> listenableFuture =
+          executorService.submit(() -> {
+            backgroundRefreshQueued.decrementAndGet();
+            backgroundRefreshRunning.incrementAndGet();
+            Set<String> results = load(key);
+            return results;
-      Futures.addCallback(listenableFuture, new FutureCallback<List<String>>() {
+      Futures.addCallback(listenableFuture, new FutureCallback<Set<String>>() {
-        public void onSuccess(List<String> result) {
+        public void onSuccess(Set<String> result) {
-     * Queries impl for groups belonging to the user. This could involve I/O and take awhile.
+     * Queries impl for groups belonging to the user.
+     * This could involve I/O and take awhile.
-    private List<String> fetchGroupList(String user) throws IOException {
+    private Set<String> fetchGroupSet(String user) throws IOException {
-      List<String> groupList = impl.getGroups(user);
+      Set<String> groups = impl.getGroupsSet(user);
-
-      return groupList;
+      return groups;

INS31 INS31 UPD74 UPD74 INS29 INS78 INS83 MOV74 INS42 INS44 INS43 INS8 INS29 INS83 INS74 INS42 INS44 INS43 INS8 UPD83 UPD74 UPD42 UPD74 UPD74 UPD74 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS43 MOV43 INS83 INS43 INS42 INS42 INS41 UPD43 UPD74 INS74 UPD74 UPD74 UPD42 UPD43 UPD74 UPD74 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS65 INS66 INS42 INS32 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS32 UPD66 UPD42 UPD74 UPD43 INS43 INS43 MOV43 UPD74 UPD74 UPD43 UPD42 UPD43 UPD74 INS68 INS42 INS42 INS14 INS42 INS42 INS32 INS43 UPD74 UPD42 INS42 INS42 UPD74 INS42 UPD43 UPD43 UPD74 UPD66 INS66 UPD42 UPD74 UPD42 UPD42 UPD43 MOV43 UPD74 UPD74 INS42 INS69 MOV74 INS32 INS42 INS42 INS42 UPD43 UPD74 UPD43 UPD42 UPD42 MOV43 UPD74 UPD43 UPD42 UPD42 UPD43 INS43 INS42 INS42 INS42 UPD42 UPD43 UPD42 UPD43 INS86 UPD74 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 MOV8 UPD74 INS14 UPD42 UPD43 MOV43 MOV32 UPD74 UPD42 UPD74 UPD43 UPD43 UPD42 UPD42 DEL40 DEL26 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL43 DEL42 DEL43 DEL74 DEL11 DEL42 DEL42 DEL74 DEL42 DEL14 DEL14 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL31 DEL1 DEL14
HDDS-358. Use DBStore and TableStore for DeleteKeyService. Contributed by Anu Engineer

- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership.  The ASF
+ * licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+import com.google.common.annotations.VisibleForTesting;
-import org.apache.hadoop.ozone.common.DeleteBlockGroupResult;
-import org.apache.hadoop.ozone.common.BlockGroup;
-import org.apache.hadoop.util.StringUtils;
+import org.apache.hadoop.hdfs.DFSUtil;
+import org.apache.hadoop.ozone.common.BlockGroup;
+import org.apache.hadoop.ozone.common.DeleteBlockGroupResult;
+import org.apache.hadoop.utils.db.Table;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import java.util.concurrent.atomic.AtomicLong;
- * This is the background service to delete keys.
- * Scan the metadata of om periodically to get
- * the keys with prefix "#deleting" and ask scm to
- * delete metadata accordingly, if scm returns
- * success for keys, then clean up those keys.
+ * This is the background service to delete keys. Scan the metadata of om
+ * periodically to get the keys from DeletedTable and ask scm to delete
+ * metadata accordingly, if scm returns success for keys, then clean up those
+ * keys.
-
+  private final AtomicLong deletedKeyCount;
+  private final AtomicLong runCount;
+    this.deletedKeyCount = new AtomicLong(0);
+    this.runCount = new AtomicLong(0);
+  }
+
+  /**
+   * Returns the number of times this Background service has run.
+   *
+   * @return Long, run count.
+   */
+  @VisibleForTesting
+  public AtomicLong getRunCount() {
+    return runCount;
+  }
+
+  /**
+   * Returns the number of keys deleted by the background service.
+   *
+   * @return Long count.
+   */
+  @VisibleForTesting
+  public AtomicLong getDeletedKeyCount() {
+    return deletedKeyCount;
-   * A key deleting task scans OM DB and looking for a certain number
-   * of pending-deletion keys, sends these keys along with their associated
-   * blocks to SCM for deletion. Once SCM confirms keys are deleted (once
-   * SCM persisted the blocks info in its deletedBlockLog), it removes
-   * these keys from the DB.
+   * A key deleting task scans OM DB and looking for a certain number of
+   * pending-deletion keys, sends these keys along with their associated blocks
+   * to SCM for deletion. Once SCM confirms keys are deleted (once SCM persisted
+   * the blocks info in its deletedBlockLog), it removes these keys from the
+   * DB.
+      runCount.incrementAndGet();
-        if (keyBlocksList.size() > 0) {
-          LOG.info("Found {} to-delete keys in OM", keyBlocksList.size());
+        if (keyBlocksList != null && keyBlocksList.size() > 0) {
-          for (DeleteBlockGroupResult result : results) {
-            if (result.isSuccess()) {
-              try {
-                // Purge key from OM DB.
-                manager.deletePendingDeletionKey(result.getObjectKey());
-                LOG.debug("Key {} deleted from OM DB", result.getObjectKey());
-              } catch (IOException e) {
-                // if a pending deletion key is failed to delete,
-                // print a warning here and retain it in this state,
-                // so that it can be attempt to delete next time.
-                LOG.warn("Failed to delete pending-deletion key {}",
-                    result.getObjectKey(), e);
-              }
-            } else {
-              // Key deletion failed, retry in next interval.
-              LOG.warn("Key {} deletion failed because some of the blocks"
-                  + " were failed to delete, failed blocks: {}",
-                  result.getObjectKey(),
-                  StringUtils.join(",", result.getFailedBlocks()));
-            }
+          if (results != null) {
+            int delCount = deleteAllKeys(results);
+            LOG.debug("Number of keys deleted: {}, elapsed time: {}ms",
+                delCount, Time.monotonicNow() - startTime);
+            deletedKeyCount.addAndGet(delCount);
-
-          if (!results.isEmpty()) {
-            LOG.info("Number of key deleted from OM DB: {},"
-                + " task elapsed time: {}ms",
-                results.size(), Time.monotonicNow() - startTime);
-          }
-
-          return results::size;
-        } else {
-          LOG.debug("No pending deletion key found in OM");
-        LOG.error("Unable to get pending deletion keys, retry in"
-            + " next interval", e);
+        LOG.error("Error while running delete keys background task. Will " +
+            "retry at next run.", e);
+      // By desing, no one cares about the results of this call back.
+
+    /**
+     * Deletes all the keys that SCM has acknowledged and queued for delete.
+     *
+     * @param results DeleteBlockGroups returned by SCM.
+     * @throws RocksDBException on Error.
+     * @throws IOException      on Error
+     */
+    private int deleteAllKeys(List<DeleteBlockGroupResult> results)
+        throws RocksDBException, IOException {
+      Table deletedTable = manager.getMetadataManager().getDeletedTable();
+      // Put all keys to delete in a single transaction and call for delete.
+      int deletedCount = 0;
+      try (WriteBatch writeBatch = new WriteBatch()) {
+        for (DeleteBlockGroupResult result : results) {
+          if (result.isSuccess()) {
+            // Purge key from OM DB.
+            writeBatch.delete(deletedTable.getHandle(),
+                DFSUtil.string2Bytes(result.getObjectKey()));
+            LOG.debug("Key {} deleted from OM DB", result.getObjectKey());
+            deletedCount++;
+          }
+        }
+        // Write a single transaction for delete.
+        manager.getMetadataManager().getStore().write(writeBatch);
+      }
+      return deletedCount;
+    }

MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS29 INS78 INS83 INS43 INS42 INS8 INS29 INS78 INS83 INS43 INS42 INS8 INS31 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS42 INS42 INS42 INS21 INS21 INS65 INS65 INS42 INS42 INS41 INS65 INS65 INS42 INS42 INS41 INS29 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS7 INS7 INS66 INS66 INS42 INS66 INS66 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 INS21 INS65 INS65 INS65 INS65 INS74 INS42 INS42 INS42 INS60 INS60 INS54 INS41 INS22 INS14 INS22 INS14 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS43 INS43 INS43 INS59 INS39 INS59 INS58 INS8 INS42 INS52 INS42 INS43 INS34 INS52 INS42 INS43 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS43 INS59 MOV70 INS21 INS42 INS42 INS27 INS8 INS32 INS42 INS42 INS42 INS14 MOV8 INS32 INS27 MOV27 MOV60 INS25 INS42 INS42 INS43 INS25 INS32 INS42 INS42 INS42 INS33 INS27 INS8 INS42 MOV32 MOV8 INS32 INS42 INS42 INS33 INS60 MOV21 MOV21 UPD45 UPD45 INS21 INS42 INS42 INS39 INS59 INS32 INS37 INS42 INS32 UPD42 INS45 UPD42 MOV42 UPD42 INS42 UPD42 INS42 INS42 INS32 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 DEL66 DEL66 DEL45 DEL45 DEL27 DEL42 DEL32 DEL45 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL32 DEL38 DEL8 DEL25 DEL42 DEL42 DEL90 DEL41 DEL8 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8
HDFS-5923. Do not persist the ACL bit in the FsPermission. Contributed by Haohui Mai.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1567784 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.common.collect.ImmutableList;
-    if (!parent.getFsPermission().getAclBit()) {
-      return;
-    }
-
-    // The default ACL is applicable to new child files and directories only.
-    if (!child.isFile() && !child.isDirectory()) {
+    AclFeature parentAclFeature = parent.getAclFeature();
+    if (parentAclFeature == null || !(child.isFile() || child.isDirectory())) {
-    FsPermission perm = inode.getFsPermission(snapshotId);
-    if (perm.getAclBit()) {
-      return inode.getAclFeature(snapshotId).getEntries();
-    } else {
-      return Collections.emptyList();
-    }
+    AclFeature f = inode.getAclFeature(snapshotId);
+    return f == null ? ImmutableList.<AclEntry> of() : f.getEntries();
-    final List<AclEntry> existingAcl;
-    if (perm.getAclBit()) {
-      // Split ACL entries stored in the feature into access vs. default.
-      List<AclEntry> featureEntries = inode.getAclFeature().getEntries();
-      ScopedAclEntries scoped = new ScopedAclEntries(featureEntries);
-      List<AclEntry> accessEntries = scoped.getAccessEntries();
-      List<AclEntry> defaultEntries = scoped.getDefaultEntries();
-
-      // Pre-allocate list size for the explicit entries stored in the feature
-      // plus the 3 implicit entries (owner, group and other) from the permission
-      // bits.
-      existingAcl = Lists.newArrayListWithCapacity(featureEntries.size() + 3);
-
-      if (!accessEntries.isEmpty()) {
-        // Add owner entry implied from user permission bits.
-        existingAcl.add(new AclEntry.Builder()
-          .setScope(AclEntryScope.ACCESS)
-          .setType(AclEntryType.USER)
-          .setPermission(perm.getUserAction())
-          .build());
-
-        // Next add all named user and group entries taken from the feature.
-        existingAcl.addAll(accessEntries);
-
-        // Add mask entry implied from group permission bits.
-        existingAcl.add(new AclEntry.Builder()
-          .setScope(AclEntryScope.ACCESS)
-          .setType(AclEntryType.MASK)
-          .setPermission(perm.getGroupAction())
-          .build());
-
-        // Add other entry implied from other permission bits.
-        existingAcl.add(new AclEntry.Builder()
-          .setScope(AclEntryScope.ACCESS)
-          .setType(AclEntryType.OTHER)
-          .setPermission(perm.getOtherAction())
-          .build());
-      } else {
-        // It's possible that there is a default ACL but no access ACL.  In this
-        // case, add the minimal access ACL implied by the permission bits.
-        existingAcl.addAll(getMinimalAcl(perm));
-      }
-
-      // Add all default entries after the access entries.
-      existingAcl.addAll(defaultEntries);
-    } else {
-      // If the inode doesn't have an extended ACL, then return a minimal ACL.
-      existingAcl = getMinimalAcl(perm);
+    AclFeature f = inode.getAclFeature();
+    if (f == null) {
+      return getMinimalAcl(perm);
+    final List<AclEntry> existingAcl;
+    // Split ACL entries stored in the feature into access vs. default.
+    List<AclEntry> featureEntries = f.getEntries();
+    ScopedAclEntries scoped = new ScopedAclEntries(featureEntries);
+    List<AclEntry> accessEntries = scoped.getAccessEntries();
+    List<AclEntry> defaultEntries = scoped.getDefaultEntries();
+
+    // Pre-allocate list size for the explicit entries stored in the feature
+    // plus the 3 implicit entries (owner, group and other) from the permission
+    // bits.
+    existingAcl = Lists.newArrayListWithCapacity(featureEntries.size() + 3);
+
+    if (!accessEntries.isEmpty()) {
+      // Add owner entry implied from user permission bits.
+      existingAcl.add(new AclEntry.Builder().setScope(AclEntryScope.ACCESS)
+          .setType(AclEntryType.USER).setPermission(perm.getUserAction())
+          .build());
+
+      // Next add all named user and group entries taken from the feature.
+      existingAcl.addAll(accessEntries);
+
+      // Add mask entry implied from group permission bits.
+      existingAcl.add(new AclEntry.Builder().setScope(AclEntryScope.ACCESS)
+          .setType(AclEntryType.MASK).setPermission(perm.getGroupAction())
+          .build());
+
+      // Add other entry implied from other permission bits.
+      existingAcl.add(new AclEntry.Builder().setScope(AclEntryScope.ACCESS)
+          .setType(AclEntryType.OTHER).setPermission(perm.getOtherAction())
+          .build());
+    } else {
+      // It's possible that there is a default ACL but no access ACL. In this
+      // case, add the minimal access ACL implied by the permission bits.
+      existingAcl.addAll(getMinimalAcl(perm));
+    }
+
+    // Add all default entries after the access entries.
+    existingAcl.addAll(defaultEntries);
+
-    FsPermission perm = inode.getFsPermission();
-    if (perm.getAclBit()) {
-      List<AclEntry> featureEntries = inode.getAclFeature().getEntries();
-      final FsAction groupPerm;
-      if (featureEntries.get(0).getScope() == AclEntryScope.ACCESS) {
-        // Restore group permissions from the feature's entry to permission
-        // bits, overwriting the mask, which is not part of a minimal ACL.
-        AclEntry groupEntryKey = new AclEntry.Builder()
-          .setScope(AclEntryScope.ACCESS)
-          .setType(AclEntryType.GROUP)
-          .build();
-        int groupEntryIndex = Collections.binarySearch(featureEntries,
-          groupEntryKey, AclTransformation.ACL_ENTRY_COMPARATOR);
-        assert groupEntryIndex >= 0;
-        groupPerm = featureEntries.get(groupEntryIndex).getPermission();
-      } else {
-        groupPerm = perm.getGroupAction();
-      }
+    AclFeature f = inode.getAclFeature();
+    if (f == null) {
+      return;
+    }
-      // Remove the feature and turn off the ACL bit.
-      inode.removeAclFeature(snapshotId);
-      FsPermission newPerm = new FsPermission(perm.getUserAction(),
-        groupPerm, perm.getOtherAction(),
-        perm.getStickyBit(), false);
+    FsPermission perm = inode.getFsPermission();
+    List<AclEntry> featureEntries = f.getEntries();
+    if (featureEntries.get(0).getScope() == AclEntryScope.ACCESS) {
+      // Restore group permissions from the feature's entry to permission
+      // bits, overwriting the mask, which is not part of a minimal ACL.
+      AclEntry groupEntryKey = new AclEntry.Builder()
+          .setScope(AclEntryScope.ACCESS).setType(AclEntryType.GROUP).build();
+      int groupEntryIndex = Collections.binarySearch(featureEntries,
+          groupEntryKey, AclTransformation.ACL_ENTRY_COMPARATOR);
+      assert groupEntryIndex >= 0;
+      FsAction groupPerm = featureEntries.get(groupEntryIndex).getPermission();
+      FsPermission newPerm = new FsPermission(perm.getUserAction(), groupPerm,
+          perm.getOtherAction(), perm.getStickyBit());
+
+    inode.removeAclFeature(snapshotId);
-      if (perm.getAclBit()) {
+      if (inode.getAclFeature() != null) {
-      if (perm.getAclBit()) {
+      if (inode.getAclFeature() != null) {
-      existingPerm.getStickyBit(), true);
+      existingPerm.getStickyBit());
-      existingPerm.getStickyBit(), false);
+      existingPerm.getStickyBit());

INS26 INS40 MOV8 MOV8 MOV60 INS60 INS41 MOV60 INS60 INS25 MOV60 MOV41 INS25 MOV60 INS43 INS59 UPD27 UPD43 INS16 INS43 INS59 INS27 INS8 INS43 INS27 MOV8 MOV74 INS42 INS42 INS32 INS27 UPD42 UPD42 MOV32 INS27 INS32 INS32 INS42 INS42 INS32 INS42 INS33 INS41 INS42 UPD42 INS42 INS33 UPD42 INS32 INS60 INS60 MOV21 MOV42 UPD42 MOV42 INS42 INS33 INS36 INS42 INS33 UPD42 MOV42 INS43 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 MOV32 INS42 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 MOV43 INS59 INS27 INS27 INS27 INS42 INS42 MOV32 INS42 INS14 MOV32 INS33 MOV32 INS33 MOV32 MOV32 MOV43 MOV32 INS42 MOV32 MOV32 INS42 INS42 DEL42 DEL32 DEL32 DEL38 DEL25 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL9 DEL14 DEL83 DEL42 DEL59 DEL60 DEL42 DEL7 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL9 DEL9
YARN-7091. Rename application to service in yarn-native-services. Contributed by Jian He

+import org.apache.hadoop.yarn.api.records.FinalApplicationStatus;
-import org.apache.hadoop.yarn.service.api.records.Application;
+import org.apache.hadoop.yarn.service.api.records.Service;
+import org.apache.hadoop.yarn.service.api.records.ServiceState;
+import static org.apache.hadoop.yarn.service.utils.ServiceApiUtil.jsonSerDeser;
-  private YarnClient yarnClient;
+  //TODO disable retry so that client / rest API doesn't block?
+  protected YarnClient yarnClient;
-  private Map<String, ClientAMProtocol> cachedAMProxies = new ConcurrentHashMap<>();
-      EnumSet.of(NEW, NEW_SAVING, SUBMITTED, RUNNING);
+      EnumSet.of(NEW, NEW_SAVING, SUBMITTED, ACCEPTED, RUNNING);
+  private static EnumSet<YarnApplicationState> preRunningStates =
+      EnumSet.of(NEW, NEW_SAVING, SUBMITTED, ACCEPTED);
-  private Application loadAppJsonFromLocalFS(
+  private Service loadAppJsonFromLocalFS(
-    Application application = ServiceApiUtil.jsonSerDeser
+    Service service = jsonSerDeser
-      application.setLifetime(args.lifetime);
+      service.setLifetime(args.lifetime);
-    application.setName(args.getClusterName());
-    return application;
+    service.setName(args.getClusterName());
+    return service;
-  public int actionBuild(Application application)
+  public int actionBuild(Service service)
-    Path appDir = checkAppNotExistOnHdfs(application);
-    ServiceApiUtil.validateAndResolveApplication(application, fs, getConfig());
-    createDirAndPersistApp(appDir, application);
+    Path appDir = checkAppNotExistOnHdfs(service);
+    ServiceApiUtil.validateAndResolveService(service, fs, getConfig());
+    createDirAndPersistApp(appDir, service);
-  public ApplicationId actionCreate(Application application)
+  public ApplicationId actionCreate(Service service)
-    String appName = application.getName();
-    validateClusterName(appName);
-    ServiceApiUtil.validateAndResolveApplication(application, fs, getConfig());
-    verifyNoLiveAppInRM(appName, "create");
-    Path appDir = checkAppNotExistOnHdfs(application);
+    String serviceName = service.getName();
+    ServiceApiUtil.validateNameFormat(serviceName, getConfig());
+    ServiceApiUtil.validateAndResolveService(service, fs, getConfig());
+    verifyNoLiveAppInRM(serviceName, "create");
+    Path appDir = checkAppNotExistOnHdfs(service);
-    createDirAndPersistApp(appDir, application);
-    ApplicationId appId = submitApp(application);
-    cachedAppIds.put(appName, appId);
-    application.setId(appId.toString());
+    createDirAndPersistApp(appDir, service);
+    ApplicationId appId = submitApp(service);
+    cachedAppIds.put(serviceName, appId);
+    service.setId(appId.toString());
-    persistAppDef(appDir, application);
+    persistAppDef(appDir, service);
-    Application persistedApp =
-        ServiceApiUtil.loadApplication(fs, flexArgs.getClusterName());
-    if (!StringUtils.isEmpty(persistedApp.getId())) {
-      cachedAppIds.put(persistedApp.getName(),
-          ApplicationId.fromString(persistedApp.getId()));
+    Service persistedService =
+        ServiceApiUtil.loadService(fs, flexArgs.getClusterName());
+    if (!StringUtils.isEmpty(persistedService.getId())) {
+      cachedAppIds.put(persistedService.getName(),
+          ApplicationId.fromString(persistedService.getId()));
+    } else {
+      throw new YarnException(persistedService.getName()
+          + " appId is null, may be not submitted to YARN yet");
+
-      ServiceApiUtil.validateCompName(compName);
-      Component component = persistedApp.getComponent(compName);
+      ServiceApiUtil.validateNameFormat(compName, getConfig());
+      Component component = persistedService.getComponent(compName);
-    flexComponents(args.getClusterName(), componentCounts, persistedApp);
+    flexComponents(args.getClusterName(), componentCounts, persistedService);
-  public Map<String, Long> flexByRestService(String appName,
+  public Map<String, Long> flexByRestService(String serviceName,
-    Application persistedApp = ServiceApiUtil.loadApplication(fs, appName);
-    cachedAppIds.put(persistedApp.getName(),
-        ApplicationId.fromString(persistedApp.getId()));
-    return flexComponents(appName, componentCounts, persistedApp);
+    Service persistedService = ServiceApiUtil.loadService(fs, serviceName);
+    if (StringUtils.isEmpty(persistedService.getId())) {
+      throw new YarnException(
+          serviceName + " appId is null, may be not submitted to YARN yet");
+    }
+    cachedAppIds.put(persistedService.getName(),
+        ApplicationId.fromString(persistedService.getId()));
+    return flexComponents(serviceName, componentCounts, persistedService);
-  private Map<String, Long> flexComponents(String appName,
-      Map<String, Long> componentCounts, Application persistedApp)
+  private Map<String, Long> flexComponents(String serviceName,
+      Map<String, Long> componentCounts, Service persistedService)
-    validateClusterName(appName);
+    ServiceApiUtil.validateNameFormat(serviceName, getConfig());
-    for (Component persistedComp : persistedApp.getComponents()) {
+    for (Component persistedComp : persistedService.getComponents()) {
-    ServiceApiUtil.jsonSerDeser
-        .save(fs.getFileSystem(), ServiceApiUtil.getAppJsonPath(fs, appName),
-            persistedApp, true);
-    ClientAMProtocol proxy = getAMProxy(appName);
-    if (proxy == null) {
-      String message = appName + " is not running";
+    jsonSerDeser
+        .save(fs.getFileSystem(), ServiceApiUtil.getServiceJsonPath(fs, serviceName),
+            persistedService, true);
+
+    ApplicationReport appReport =
+        yarnClient.getApplicationReport(getAppId(serviceName));
+    if (appReport.getYarnApplicationState() != RUNNING) {
+      String message =
+          serviceName + " is at " + appReport.getYarnApplicationState()
+              + " state, flex can only be invoked when service is running";
+    if (StringUtils.isEmpty(appReport.getHost())) {
+      throw new YarnException(serviceName + " AM hostname is empty");
+    }
+    ClientAMProtocol proxy =
+        createAMProxy(appReport.getHost(), appReport.getRpcPort());
-  public int actionStop(String appName, boolean waitForAppStopped)
+  public int actionStop(String serviceName, boolean waitForAppStopped)
-    validateClusterName(appName);
-    getAppId(appName);
-    ApplicationId currentAppId = cachedAppIds.get(appName);
+    ServiceApiUtil.validateNameFormat(serviceName, getConfig());
+    ApplicationId currentAppId = getAppId(serviceName);
-      LOG.info("Application {} is already in a terminated state {}", appName,
+      LOG.info("Service {} is already in a terminated state {}", serviceName,
-    LOG.info("Stopping application {}, with appId = {}", appName, currentAppId);
+    if (preRunningStates.contains(report.getYarnApplicationState())) {
+      String msg = serviceName + " is at " + report.getYarnApplicationState()
+          + ", forcefully killed by user!";
+      yarnClient.killApplication(currentAppId, msg);
+      LOG.info(msg);
+      return EXIT_SUCCESS;
+    }
+    if (StringUtils.isEmpty(report.getHost())) {
+      throw new YarnException(serviceName + " AM hostname is empty");
+    }
+    LOG.info("Stopping service {}, with appId = {}", serviceName, currentAppId);
-      ClientAMProtocol proxy = getAMProxy(appName, report);
-      cachedAppIds.remove(appName);
-      cachedAMProxies.remove(appName);
+      ClientAMProtocol proxy =
+          createAMProxy(report.getHost(), report.getRpcPort());
+      cachedAppIds.remove(serviceName);
-        LOG.info("Application " + appName + " is being gracefully stopped...");
+        LOG.info("Service " + serviceName + " is being gracefully stopped...");
-            appName + " is forcefully killed by user!");
-        LOG.info("Forcefully kill the application: " + appName);
+            serviceName + " is forcefully killed by user!");
+        LOG.info("Forcefully kill the service: " + serviceName);
-          LOG.info("Application " + appName + " is stopped.");
+          LOG.info("Service " + serviceName + " is stopped.");
-              + appName);
+              + serviceName);
-          LOG.info("Waiting for application " + appName + " to be stopped.");
+          LOG.info("Waiting for service " + serviceName + " to be stopped.");
-      LOG.info("Failed to stop " + appName
+      LOG.info("Failed to stop " + serviceName
-  public int actionDestroy(String appName) throws Exception {
-    validateClusterName(appName);
-    verifyNoLiveAppInRM(appName, "Destroy");
-    Path appDir = fs.buildClusterDirPath(appName);
+  public int actionDestroy(String serviceName) throws Exception {
+    ServiceApiUtil.validateNameFormat(serviceName, getConfig());
+    verifyNoLiveAppInRM(serviceName, "Destroy");
+    Path appDir = fs.buildClusterDirPath(serviceName);
-    cachedAppIds.remove(appName);
-    cachedAMProxies.remove(appName);
+    cachedAppIds.remove(serviceName);
-        LOG.info("Successfully deleted application dir for " + appName + ": "
+        LOG.info("Successfully deleted service dir for " + serviceName + ": "
-            "Failed to delete application + " + appName + " at:  " + appDir;
+            "Failed to delete service + " + serviceName + " at:  " + appDir;
-    deleteZKNode(appName);
-    String registryPath = ServiceRegistryUtils.registryPathForInstance(appName);
+    deleteZKNode(serviceName);
+    String registryPath = ServiceRegistryUtils.registryPathForInstance(serviceName);
-    LOG.info("Destroyed cluster {}", appName);
+    LOG.info("Destroyed cluster {}", serviceName);
-  private void verifyNoLiveAppInRM(String appname, String action)
+  private void verifyNoLiveAppInRM(String serviceName, String action)
-    if (appname != null) {
-      tags = Collections.singleton(SliderUtils.createNameTag(appname));
+    if (serviceName != null) {
+      tags = Collections.singleton(SliderUtils.createNameTag(serviceName));
-          "Failed to " + action + " application, as " + appname
+          "Failed to " + action + " service, as " + serviceName
-  private ApplicationId submitApp(Application app)
+  private ApplicationId submitApp(Service app)
-    String appName = app.getName();
+    String serviceName = app.getName();
-        addAMLog4jResource(appName, conf, localResources);
+        addAMLog4jResource(serviceName, conf, localResources);
-    addJarResource(appName, localResources);
+    addJarResource(serviceName, localResources);
-    addKeytabResourceIfSecure(fs, localResources, conf, appName);
+    addKeytabResourceIfSecure(fs, localResources, conf, serviceName);
-        buildCommandLine(appName, conf, appRootDir, hasAMLog4j);
+        buildCommandLine(serviceName, conf, appRootDir, hasAMLog4j);
-    submissionContext.setApplicationName(appName);
+    submissionContext.setApplicationName(serviceName);
-        AbstractClientProvider.createApplicationTags(appName, null, null);
+        AbstractClientProvider.createApplicationTags(serviceName, null, null);
-  private String buildCommandLine(String appName, Configuration conf,
+  private String buildCommandLine(String serviceName, Configuration conf,
-    CLI.add(ACTION_CREATE, appName);
+    CLI.add(ACTION_CREATE, serviceName);
-    CLI.add(Arguments.ARG_CLUSTER_URI, new Path(appRootDir, appName + ".json"));
+    CLI.add(Arguments.ARG_CLUSTER_URI, new Path(appRootDir, serviceName + ".json"));
-  protected Path addJarResource(String appName,
+  protected Path addJarResource(String serviceName,
-    Path libPath = fs.buildClusterDirPath(appName);
+    Path libPath = fs.buildClusterDirPath(serviceName);
-  private boolean addAMLog4jResource(String appName, Configuration conf,
+  private boolean addAMLog4jResource(String serviceName, Configuration conf,
-        Path appDirPath = fs.buildClusterDirPath(appName);
+        Path appDirPath = fs.buildClusterDirPath(serviceName);
-  public int actionStart(String appName) throws YarnException, IOException {
-    validateClusterName(appName);
-    Path appDir = checkAppExistOnHdfs(appName);
-    Application application = ServiceApiUtil.loadApplication(fs, appName);
-    ServiceApiUtil.validateAndResolveApplication(application, fs, getConfig());
+  public int actionStart(String serviceName) throws YarnException, IOException {
+    ServiceApiUtil.validateNameFormat(serviceName, getConfig());
+    Path appDir = checkAppExistOnHdfs(serviceName);
+    Service service = ServiceApiUtil.loadService(fs, serviceName);
+    ServiceApiUtil.validateAndResolveService(service, fs, getConfig());
-    verifyNoLiveAppInRM(appName, "thaw");
-    ApplicationId appId = submitApp(application);
-    application.setId(appId.toString());
+    verifyNoLiveAppInRM(serviceName, "thaw");
+    ApplicationId appId = submitApp(service);
+    service.setId(appId.toString());
-    createDirAndPersistApp(appDir, application);
+    createDirAndPersistApp(appDir, service);
-  private Path checkAppNotExistOnHdfs(Application application)
+  private Path checkAppNotExistOnHdfs(Service service)
-    Path appDir = fs.buildClusterDirPath(application.getName());
+    Path appDir = fs.buildClusterDirPath(service.getName());
-        new Path(appDir, application.getName() + ".json"));
+        new Path(appDir, service.getName() + ".json"));
-  private Path checkAppExistOnHdfs(String appName)
+  private Path checkAppExistOnHdfs(String serviceName)
-    Path appDir = fs.buildClusterDirPath(appName);
-    fs.verifyPathExists(new Path(appDir, appName + ".json"));
+    Path appDir = fs.buildClusterDirPath(serviceName);
+    fs.verifyPathExists(new Path(appDir, serviceName + ".json"));
-  private void createDirAndPersistApp(Path appDir, Application application)
+  private void createDirAndPersistApp(Path appDir, Service service)
-    persistAppDef(appDir, application);
+    persistAppDef(appDir, service);
-  private void persistAppDef(Path appDir, Application application)
+  private void persistAppDef(Path appDir, Service service)
-    Path appJson = new Path(appDir, application.getName() + ".json");
-    ServiceApiUtil.jsonSerDeser
-        .save(fs.getFileSystem(), appJson, application, true);
+    Path appJson = new Path(appDir, service.getName() + ".json");
+    jsonSerDeser
+        .save(fs.getFileSystem(), appJson, service, true);
-        "Persisted application " + application.getName() + " at " + appJson);
+        "Persisted service " + service.getName() + " at " + appJson);
-      String appName) throws IOException, BadConfigException {
+      String serviceName) throws IOException, BadConfigException {
-          fileSystem.buildKeytabPath(keytabDir, amKeytabName, appName);
+          fileSystem.buildKeytabPath(keytabDir, amKeytabName, serviceName);
-              + "The application is therefore not guaranteed to remain "
+              + "The service is therefore not guaranteed to remain "
-  public String updateLifetime(String appName, long lifetime)
+  public String updateLifetime(String serviceName, long lifetime)
-    getAppId(appName);
-    ApplicationId currentAppId = cachedAppIds.get(appName);
+    ApplicationId currentAppId = getAppId(serviceName);
-      throw new YarnException("Application not found for " + appName);
+      throw new YarnException("Service not found for " + serviceName);
-    LOG.info("Updating lifetime of an application: appName = " + appName
+    LOG.info("Updating lifetime of an service: serviceName = " + serviceName
-        "Successfully updated lifetime for an application: appName = " + appName
+        "Successfully updated lifetime for an service: serviceName = " + serviceName
-  public Application getStatus(String appName)
-      throws IOException, YarnException {
-    validateClusterName(appName);
-    ApplicationId currentAppId = getAppId(appName);
-    ApplicationReport appReport = yarnClient.getApplicationReport(currentAppId);
-    ClientAMProtocol amProxy = getAMProxy(appName, appReport);
-    Application appSpec;
-    if (amProxy != null) {
-      GetStatusResponseProto response =
-          amProxy.getStatus(GetStatusRequestProto.newBuilder().build());
-      appSpec = ServiceApiUtil.jsonSerDeser.fromJson(response.getStatus());
-    } else {
-      appSpec = new Application();
-      appSpec.setName(appName);
+  public ServiceState convertState(FinalApplicationStatus status) {
+    switch (status) {
+    case UNDEFINED:
+      return ServiceState.ACCEPTED;
+    case FAILED:
+    case KILLED:
+      return ServiceState.FAILED;
+    case ENDED:
+    case SUCCEEDED:
+      return ServiceState.STOPPED;
+    return ServiceState.ACCEPTED;
+  }
+
+  public Service getStatus(String serviceName)
+      throws IOException, YarnException {
+    ServiceApiUtil.validateNameFormat(serviceName, getConfig());
+    ApplicationId currentAppId = getAppId(serviceName);
+    ApplicationReport appReport = yarnClient.getApplicationReport(currentAppId);
+    Service appSpec = new Service();
+    appSpec.setName(serviceName);
+    appSpec.setState(convertState(appReport.getFinalApplicationStatus()));
+
+    if (appReport.getYarnApplicationState() != RUNNING) {
+      LOG.info("Service {} is at {} state", serviceName,
+          appReport.getYarnApplicationState());
+      return appSpec;
+    }
+    if (StringUtils.isEmpty(appReport.getHost())) {
+      LOG.warn(serviceName + " AM hostname is empty");
+      return appSpec;
+    }
+    ClientAMProtocol amProxy =
+        createAMProxy(appReport.getHost(), appReport.getRpcPort());
+    GetStatusResponseProto response =
+        amProxy.getStatus(GetStatusRequestProto.newBuilder().build());
+    appSpec = jsonSerDeser.fromJson(response.getStatus());
+
-  // Get AMProxy with the appReport provided
-  protected ClientAMProtocol getAMProxy(String appName, ApplicationReport report)
-      throws IOException {
-    if (!cachedAMProxies.containsKey(appName) && !StringUtils
-        .isEmpty(report.getHost())) {
-      insertAMProxy(appName, report.getHost(), report.getRpcPort());
-    }
-    return cachedAMProxies.get(appName);
-  }
-
-  // Get AMProxy without appReport provided - it'll getAppReport from RM
-  protected ClientAMProtocol getAMProxy(String appName)
-      throws IOException, YarnException {
-    ApplicationId currentAppId = getAppId(appName);
-
-    if (cachedAMProxies.containsKey(appName)) {
-      return cachedAMProxies.get(appName);
-    } else {
-      ApplicationReport appReport =
-          yarnClient.getApplicationReport(currentAppId);
-      String host = appReport.getHost();
-      int port = appReport.getRpcPort();
-      if (!StringUtils.isEmpty(host)) {
-        return insertAMProxy(appName, host, port);
-      }
-      return null;
-    }
-  }
-
-  private ClientAMProtocol insertAMProxy(String appName, String host, int port)
+  protected ClientAMProtocol createAMProxy(String host, int port)
-    ClientAMProtocol amProxy =
-        ClientAMProxy.createProxy(getConfig(), ClientAMProtocol.class,
+    return ClientAMProxy.createProxy(getConfig(), ClientAMProtocol.class,
-    cachedAMProxies.put(appName, amProxy);
-    return amProxy;
-  private synchronized ApplicationId getAppId(String appName)
+  private synchronized ApplicationId getAppId(String serviceName)
-    if (cachedAppIds.containsKey(appName)) {
-      return cachedAppIds.get(appName);
+    if (cachedAppIds.containsKey(serviceName)) {
+      return cachedAppIds.get(serviceName);
-    Application persistedApp = ServiceApiUtil.loadApplication(fs, appName);
-    if (persistedApp == null) {
-      throw new YarnException("Application " + appName
+    Service persistedService = ServiceApiUtil.loadService(fs, serviceName);
+    if (persistedService == null) {
+      throw new YarnException("Service " + serviceName
-    ApplicationId currentAppId = ApplicationId.fromString(persistedApp.getId());
-    cachedAppIds.put(appName, currentAppId);
+    ApplicationId currentAppId = ApplicationId.fromString(persistedService.getId());
+    cachedAppIds.put(serviceName, currentAppId);

INS26 INS26 INS26 MOV23 INS40 UPD40 INS40 INS40 INS31 INS31 UPD83 INS83 MOV74 INS59 INS74 UPD43 MOV60 MOV44 MOV43 MOV43 MOV43 MOV43 MOV44 MOV43 MOV43 INS44 MOV83 UPD43 MOV43 UPD42 MOV42 MOV44 INS8 INS83 INS43 INS42 MOV44 MOV43 MOV43 INS8 UPD83 UPD42 INS42 INS32 INS43 INS43 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD42 INS25 UPD42 UPD43 UPD42 INS60 INS25 MOV43 UPD42 INS21 INS25 INS25 MOV43 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 MOV41 UPD42 MOV41 UPD43 UPD42 UPD43 UPD42 INS43 INS42 UPD42 UPD42 UPD43 UPD42 INS50 INS41 UPD42 MOV42 UPD42 INS21 MOV60 MOV60 INS60 MOV21 INS21 MOV60 MOV25 INS25 MOV25 INS60 MOV60 MOV21 MOV41 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD43 INS8 UPD43 INS32 INS8 UPD42 MOV43 INS59 UPD27 INS32 INS8 INS32 MOV32 INS32 INS8 MOV32 INS8 INS43 UPD42 MOV42 MOV43 UPD43 UPD42 MOV43 UPD42 UPD42 MOV43 INS42 UPD42 INS42 INS49 INS41 INS49 INS49 INS41 INS49 INS49 INS41 INS40 INS32 MOV43 INS59 INS43 INS59 INS32 UPD27 MOV27 INS8 INS32 INS8 MOV43 MOV59 MOV32 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS53 UPD42 UPD42 UPD42 INS42 INS42 INS32 INS53 UPD42 UPD42 INS42 UPD42 UPD42 INS32 UPD42 INS42 UPD42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS53 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS32 INS60 INS21 INS21 INS41 INS53 UPD45 UPD42 INS42 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS40 UPD42 MOV42 INS42 UPD42 MOV42 INS32 INS42 INS32 INS42 INS42 INS14 UPD42 INS42 INS42 INS32 INS32 INS42 MOV21 MOV41 INS42 INS42 INS32 INS21 MOV41 INS42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 INS14 UPD42 UPD42 INS42 INS42 INS14 UPD42 INS42 UPD42 UPD42 INS42 INS42 INS32 INS42 INS42 MOV43 INS42 INS42 INS14 UPD42 INS32 INS32 UPD42 MOV42 UPD42 UPD42 INS42 INS42 MOV43 INS59 INS32 INS32 INS42 INS14 MOV43 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS43 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 MOV43 UPD42 MOV43 MOV43 UPD45 MOV43 UPD42 UPD42 UPD45 UPD42 UPD45 UPD42 UPD42 MOV42 INS42 INS42 UPD43 MOV43 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 UPD42 MOV42 INS32 INS42 INS42 MOV32 MOV32 INS42 UPD42 UPD42 UPD42 UPD42 INS43 INS27 UPD42 INS32 INS43 INS27 UPD42 INS42 INS42 INS43 INS27 UPD42 MOV42 INS42 INS42 INS42 UPD45 UPD42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS27 MOV42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS32 INS45 INS42 UPD42 INS42 INS42 INS45 UPD42 UPD45 INS32 INS45 INS42 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS45 UPD42 MOV32 INS32 MOV32 UPD45 UPD42 MOV43 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 INS42 INS45 UPD45 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV42 INS42 UPD42 UPD42 MOV42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD45 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD45 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL40 DEL40 DEL42 DEL33 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL44 DEL40 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL59 DEL42 DEL32 DEL38 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL32 DEL38 DEL8 DEL25 DEL33 DEL41 DEL8 DEL42 DEL40 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL42 DEL44 DEL42 DEL43 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42
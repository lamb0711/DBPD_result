HDFS-9223. Code cleanup for DatanodeDescriptor and HeartbeatManager. Contributed by Jing Zhao.

-
-  // Stores status of decommissioning.
-  // If node is not decommissioning, do not use this object for anything.
-  public final DecommissioningStatus decommissioningStatus =
-      new DecommissioningStatus();
-
-  private long curBlockReportId = 0;
-
-  private BitSet curBlockReportRpcsSeen = null;
-
-  public int updateBlockReportContext(BlockReportContext context) {
-    if (curBlockReportId != context.getReportId()) {
-      curBlockReportId = context.getReportId();
-      curBlockReportRpcsSeen = new BitSet(context.getTotalRpcs());
-    }
-    curBlockReportRpcsSeen.set(context.getCurRpc());
-    return curBlockReportRpcsSeen.cardinality();
-  }
-
-  public void clearBlockReportContext() {
-    curBlockReportId = 0;
-    curBlockReportRpcsSeen = null;
-  }
+  private static final int BLOCKS_SCHEDULED_ROLL_INTERVAL = 600*1000; //10min
+  private static final List<DatanodeStorageInfo> EMPTY_STORAGE_INFO_LIST =
+      ImmutableList.of();
-    private final Queue<E> blockq = new LinkedList<E>();
+    private final Queue<E> blockq = new LinkedList<>();
-    boolean contains(E e) {
+    synchronized boolean contains(E e) {
-  private final Map<String, DatanodeStorageInfo> storageMap = 
-      new HashMap<>();
-
+  // Stores status of decommissioning.
+  // If node is not decommissioning, do not use this object for anything.
+  public final DecommissioningStatus decommissioningStatus =
+      new DecommissioningStatus();
+
+  private long curBlockReportId = 0;
+
+  private BitSet curBlockReportRpcsSeen = null;
+
+  private final Map<String, DatanodeStorageInfo> storageMap =
+      new HashMap<>();
+
-  public CachedBlocksList getPendingCached() {
-    return pendingCached;
-  }
-
-  public CachedBlocksList getCached() {
-    return cached;
-  }
-
-  public CachedBlocksList getPendingUncached() {
-    return pendingUncached;
-  }
-
-  public boolean isAlive = false;
-  public boolean needKeyUpdate = false;
-
+  private boolean isAlive = false;
+  private boolean needKeyUpdate = false;
-  private static final int BLOCKS_SCHEDULED_ROLL_INTERVAL = 600*1000; //10min
+  public int updateBlockReportContext(BlockReportContext context) {
+    if (curBlockReportId != context.getReportId()) {
+      curBlockReportId = context.getReportId();
+      curBlockReportRpcsSeen = new BitSet(context.getTotalRpcs());
+    }
+    curBlockReportRpcsSeen.set(context.getCurRpc());
+    return curBlockReportRpcsSeen.cardinality();
+  }
+
+  public void clearBlockReportContext() {
+    curBlockReportId = 0;
+    curBlockReportRpcsSeen = null;
+  }
+
+  public CachedBlocksList getPendingCached() {
+    return pendingCached;
+  }
+
+  public CachedBlocksList getCached() {
+    return cached;
+  }
+
+  public CachedBlocksList getPendingUncached() {
+    return pendingUncached;
+  }
+
+  public boolean isAlive() {
+    return isAlive;
+  }
+
+  public void setAlive(boolean isAlive) {
+    this.isAlive = isAlive;
+  }
+
+  public boolean needKeyUpdate() {
+    return needKeyUpdate;
+  }
+
+  public void setNeedKeyUpdate(boolean needKeyUpdate) {
+    this.needKeyUpdate = needKeyUpdate;
+  }
+
-  static final private List<DatanodeStorageInfo> EMPTY_STORAGE_INFO_LIST =
-      ImmutableList.of();
-
-  /**
-   * Remove block from the list of blocks belonging to the data-node. Remove
-   * data-node from the block.
-   */
-  boolean removeBlock(BlockInfo b) {
-    final DatanodeStorageInfo s = b.findStorageInfo(this);
-    // if block exists on this datanode
-    if (s != null) {
-      return s.removeBlock(b);
-    }
-    return false;
-  }
-  
-  /**
-   * Remove block from the list of blocks belonging to the data-node. Remove
-   * data-node from the block.
-   */
-  boolean removeBlock(String storageID, BlockInfo b) {
-    DatanodeStorageInfo s = getStorageInfo(storageID);
-    return s != null && s.removeBlock(b);
-  }
-
-      this.recoverBlocks.clear();
-      this.replicateBlocks.clear();
-      this.erasurecodeBlocks.clear();
+    this.recoverBlocks.clear();
+    this.replicateBlocks.clear();
+    this.erasurecodeBlocks.clear();
-  Iterator<BlockInfo> getBlockIterator(final String storageID) {
-    return new BlockIterator(getStorageInfo(storageID));
-  }
-
-  /**
-   * The number of block invalidation items that are pending to 
-   * be sent to the datanode
-   */
-  int getNumberOfBlocksToBeInvalidated() {
-    synchronized (invalidateBlocks) {
-      return invalidateBlocks.size();
-    }
-  }
-
-   * @return
-      if (s.getState() == State.NORMAL &&
-          s.getStorageType() == t) {
+      if (s.getState() == State.NORMAL && s.getStorageType() == t) {
-    currApproxBlocksScheduled.add(t, 1);;
+    currApproxBlocksScheduled.add(t, 1);
-      if (isDecommissionInProgress() == false) {
+      if (!isDecommissionInProgress()) {
-      if (isDecommissionInProgress() == false) {
+      if (!isDecommissionInProgress()) {
-      if (isDecommissionInProgress() == false) {
+      if (!isDecommissionInProgress()) {
-      if (isDecommissionInProgress() == false) {
+      if (!isDecommissionInProgress()) {
-      if (isDecommissionInProgress() == false) {
+      if (!isDecommissionInProgress()) {
-   * checks whether atleast first block report has been received
-   * @return
+   * @return whether at least first block report has been received

MOV31 MOV31 MOV55 MOV55 MOV55 MOV31 MOV31 MOV31 MOV23 MOV23 MOV31 MOV31 MOV31 MOV31 INS83 UPD83 UPD83 INS83 UPD42 INS8 INS83 UPD39 INS42 INS83 INS39 INS42 INS83 UPD39 UPD42 INS44 INS8 MOV8 INS83 MOV41 INS39 INS42 INS21 INS39 INS42 INS21 INS51 MOV21 MOV21 MOV21 INS8 MOV8 UPD65 INS42 INS7 INS42 INS7 INS42 INS8 MOV25 MOV41 MOV25 MOV25 MOV41 UPD66 UPD74 INS22 INS42 INS22 INS42 MOV21 INS38 INS38 INS38 INS38 INS38 INS52 INS42 INS52 INS42 MOV32 MOV32 MOV32 MOV32 MOV32 DEL83 DEL42 DEL43 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL52 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL25 DEL9 DEL41 DEL8 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL41 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL51 DEL8 DEL42 DEL51 DEL8 DEL65 DEL20 DEL9 DEL27 DEL9 DEL27 DEL9 DEL27 DEL9 DEL27 DEL9 DEL27 DEL8 DEL65
HDFS-7531. Improve the concurrent access on FsVolumeList (Lei Xu via Colin P. McCabe)

+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicReference;
+import com.google.common.collect.Lists;
-  /**
-   * Read access to this unmodifiable list is not synchronized.
-   * This list is replaced on modification holding "this" lock.
-   */
-  volatile List<FsVolumeImpl> volumes = null;
+  private final AtomicReference<FsVolumeImpl[]> volumes =
+      new AtomicReference<>(new FsVolumeImpl[0]);
-  
+
+  /**
+   * Return an immutable list view of all the volumes.
+   */
+  List<FsVolumeImpl> getVolumes() {
+    return Collections.unmodifiableList(Arrays.asList(volumes.get()));
+  }
+
-   * Get next volume. Synchronized to ensure {@link #curVolume} is updated
-   * by a single thread and next volume is chosen with no concurrent
-   * update to {@link #volumes}.
+   * Get next volume.
+   *
-  synchronized FsVolumeImpl getNextVolume(StorageType storageType,
-      long blockSize) throws IOException {
-    final List<FsVolumeImpl> list = new ArrayList<FsVolumeImpl>(volumes.size());
-    for(FsVolumeImpl v : volumes) {
+  FsVolumeImpl getNextVolume(StorageType storageType, long blockSize)
+      throws IOException {
+    // Get a snapshot of currently available volumes.
+    final FsVolumeImpl[] curVolumes = volumes.get();
+    final List<FsVolumeImpl> list = new ArrayList<>(curVolumes.length);
+    for(FsVolumeImpl v : curVolumes) {
-   * Get next volume. Synchronized to ensure {@link #curVolume} is updated
-   * by a single thread and next volume is chosen with no concurrent
-   * update to {@link #volumes}.
+   * Get next volume.
+   *
-  synchronized FsVolumeImpl getNextTransientVolume(
-      long blockSize) throws IOException {
-    final List<FsVolumeImpl> list = new ArrayList<FsVolumeImpl>(volumes.size());
-    for(FsVolumeImpl v : volumes) {
+  FsVolumeImpl getNextTransientVolume(long blockSize) throws IOException {
+    // Get a snapshot of currently available volumes.
+    final List<FsVolumeImpl> curVolumes = getVolumes();
+    final List<FsVolumeImpl> list = new ArrayList<>(curVolumes.size());
+    for(FsVolumeImpl v : curVolumes) {
-    for (FsVolumeImpl v : volumes) {
+    for (FsVolumeImpl v : volumes.get()) {
-    for (FsVolumeImpl v : volumes) {
+    for (FsVolumeImpl v : volumes.get()) {
-    for (FsVolumeImpl v : volumes) {
+    for (FsVolumeImpl v : volumes.get()) {
-    for (FsVolumeSpi vol : volumes) {
+    for (FsVolumeSpi vol : volumes.get()) {
-    for (final FsVolumeImpl v : volumes) {
+    for (final FsVolumeImpl v : volumes.get()) {
-      final List<FsVolumeImpl> volumeList = new ArrayList<FsVolumeImpl>(volumes);
+      final List<FsVolumeImpl> volumeList = getVolumes();
-          removeVolume(fsv.getBasePath());
+          removeVolume(fsv);
-  synchronized void addVolume(FsVolumeImpl newVolume) {
+  void addVolume(FsVolumeImpl newVolume) {
-    final List<FsVolumeImpl> volumeList = volumes == null ?
-        new ArrayList<FsVolumeImpl>() :
-        new ArrayList<FsVolumeImpl>(volumes);
-    volumeList.add(newVolume);
-    volumes = Collections.unmodifiableList(volumeList);
+    while (true) {
+      final FsVolumeImpl[] curVolumes = volumes.get();
+      final List<FsVolumeImpl> volumeList = Lists.newArrayList(curVolumes);
+      volumeList.add(newVolume);
+      if (volumes.compareAndSet(curVolumes,
+          volumeList.toArray(new FsVolumeImpl[volumeList.size()]))) {
+        break;
+      } else {
+        if (FsDatasetImpl.LOG.isDebugEnabled()) {
+          FsDatasetImpl.LOG.debug(
+              "The volume list has been changed concurrently, " +
+                  "retry to remove volume: " + newVolume);
+        }
+      }
+    }
+
-   * Dynamically remove volume to the list.
+   * Dynamically remove a volume in the list.
+   * @param target the volume instance to be removed.
+   */
+  private void removeVolume(FsVolumeImpl target) {
+    while (true) {
+      final FsVolumeImpl[] curVolumes = volumes.get();
+      final List<FsVolumeImpl> volumeList = Lists.newArrayList(curVolumes);
+      if (volumeList.remove(target)) {
+        if (volumes.compareAndSet(curVolumes,
+            volumeList.toArray(new FsVolumeImpl[volumeList.size()]))) {
+          target.shutdown();
+          FsDatasetImpl.LOG.info("Removed volume: " + target);
+          break;
+        } else {
+          if (FsDatasetImpl.LOG.isDebugEnabled()) {
+            FsDatasetImpl.LOG.debug(
+                "The volume list has been changed concurrently, " +
+                "retry to remove volume: " + target);
+          }
+        }
+      } else {
+        if (FsDatasetImpl.LOG.isDebugEnabled()) {
+          FsDatasetImpl.LOG.debug("Volume " + target +
+              " does not exist or is removed by others.");
+        }
+        break;
+      }
+    }
+  }
+
+  /**
+   * Dynamically remove volume in the list.
-  synchronized void removeVolume(String volume) {
+  void removeVolume(String volume) {
-    final List<FsVolumeImpl> volumeList = new ArrayList<FsVolumeImpl>(volumes);
+    final FsVolumeImpl[] curVolumes = volumes.get();
+    final List<FsVolumeImpl> volumeList = Lists.newArrayList(curVolumes);
-        fsVolume.shutdown();
-        it.remove();
-        volumes = Collections.unmodifiableList(volumeList);
-        FsDatasetImpl.LOG.info("Removed volume: " + volume);
-        break;
+        // Make sure the removed volume is the one in the curVolumes.
+        removeVolume(fsVolume);
-    for (final FsVolumeImpl v : volumes) {
+    for (final FsVolumeImpl v : volumes.get()) {
-    for (FsVolumeImpl v : volumes) {
+    for (FsVolumeImpl v : volumes.get()) {
-    for (FsVolumeImpl volume : volumes) {
+    for (FsVolumeImpl volume : volumes.get()) {

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS31 INS31 INS83 INS83 INS74 INS59 INS29 MOV74 INS42 INS8 MOV29 INS39 INS42 MOV44 INS8 INS29 UPD83 UPD42 INS44 INS8 INS43 INS5 INS42 INS14 MOV65 INS41 INS60 INS60 INS61 MOV21 INS65 INS65 MOV43 INS42 INS61 INS60 INS60 INS42 INS43 INS85 INS74 INS3 UPD66 INS32 UPD66 INS5 INS59 INS83 MOV74 MOV59 UPD42 UPD66 INS83 MOV74 INS59 INS74 UPD42 INS32 INS32 INS32 INS32 INS32 INS9 INS8 INS66 INS42 INS66 INS9 INS8 UPD66 MOV83 INS5 INS59 INS83 INS74 INS59 INS32 INS32 INS32 INS42 INS43 INS5 INS34 INS42 INS42 INS32 MOV43 INS85 INS42 INS32 INS42 INS32 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS60 MOV21 INS25 INS60 MOV60 INS25 INS43 INS85 INS42 INS32 UPD43 MOV43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS85 INS42 INS42 INS32 INS42 INS42 UPD74 INS40 INS42 INS42 INS42 UPD74 INS83 INS5 INS59 INS83 MOV74 INS59 INS32 INS8 INS8 INS83 INS5 INS59 INS32 INS8 INS8 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS32 MOV43 INS85 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS10 INS25 MOV43 INS85 INS42 INS32 INS32 INS42 INS42 INS42 INS25 INS25 INS10 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS3 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS8 INS32 INS8 INS5 INS32 INS40 INS42 INS21 INS42 INS42 INS42 INS32 INS21 INS21 INS10 INS25 INS40 INS42 INS21 UPD42 INS42 MOV43 INS85 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS3 INS32 INS32 INS32 INS8 INS32 INS40 INS42 INS27 INS5 INS32 INS42 INS42 INS40 INS42 INS27 INS40 INS42 INS21 INS40 INS42 INS27 MOV42 INS45 INS45 INS42 INS43 INS85 MOV42 INS42 INS45 INS42 INS32 INS45 INS42 INS45 INS42 INS40 INS42 INS27 INS45 INS45 INS42 DEL29 DEL83 DEL42 DEL33 DEL59 DEL23 DEL66 DEL42 DEL67 DEL65 DEL66 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL83 DEL42 DEL42 DEL32 DEL42 DEL67 DEL65 DEL66 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL43 DEL74 DEL14 DEL42 DEL43 DEL74 DEL42 DEL14 DEL16 DEL42 DEL32 DEL7 DEL21 DEL8 DEL83 DEL42 DEL74 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL40 DEL45 DEL42 DEL27 DEL10 DEL42 DEL42 DEL42
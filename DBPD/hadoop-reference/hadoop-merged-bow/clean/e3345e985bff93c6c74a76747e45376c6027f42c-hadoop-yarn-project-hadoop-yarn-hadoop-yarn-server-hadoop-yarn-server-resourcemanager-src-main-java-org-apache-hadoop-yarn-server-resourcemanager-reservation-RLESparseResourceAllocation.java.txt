Revert "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem."

This reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.

-import java.util.Collections;
+import java.io.IOException;
+import java.io.StringWriter;
+import com.google.gson.stream.JsonWriter;
+
-  @SuppressWarnings("checkstyle:visibilitymodifier")
-  protected NavigableMap<Long, Resource> cumulativeCapacity =
+  private NavigableMap<Long, Resource> cumulativeCapacity =
-  @SuppressWarnings("checkstyle:visibilitymodifier")
-  protected final Lock readLock = readWriteLock.readLock();
+  private final Lock readLock = readWriteLock.readLock();
+   * Returns the JSON string representation of the current resources allocated
+   * over time.
+   *
+   * @return the JSON string representation of the current resources allocated
+   *         over time
+   */
+  public String toMemJSONString() {
+    StringWriter json = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(json);
+    readLock.lock();
+    try {
+      jsonWriter.beginObject();
+      // jsonWriter.name("timestamp").value("resource");
+      for (Map.Entry<Long, Resource> r : cumulativeCapacity.entrySet()) {
+        jsonWriter.name(r.getKey().toString()).value(r.getValue().toString());
+      }
+      jsonWriter.endObject();
+      jsonWriter.close();
+      return json.toString();
+    } catch (IOException e) {
+      // This should not happen
+      return "";
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  /**
-      return Collections.unmodifiableNavigableMap(cumulativeCapacity);
+      return cumulativeCapacity;
-          && (Resources.fitsIn(val, ZERO_RESOURCE)
-              && !Resources.equals(val, ZERO_RESOURCE))) {
+          && (Resources.fitsIn(val, ZERO_RESOURCE) &&
+              !Resources.equals(val, ZERO_RESOURCE))) {
-  /**
-   * Get a {@link RLESparseResourceAllocation} view of the {@link Resource}
-   * allocations between the specified start and end times.
-   *
-   * @param start the time from which the {@link Resource} allocations are
-   *          required
-   * @param end the time upto which the {@link Resource} allocations are
-   *          required
-   * @return the overlapping allocations
-   */
+
+
+
-  }
-  /**
-   * This method shifts all the timestamp of the {@link Resource} entries by the
-   * specified "delta".
-   *
-   * @param delta the time by which to shift the {@link Resource} allocations
-   */
-  public void shift(long delta) {
-    writeLock.lock();
-    try {
-      TreeMap<Long, Resource> newCum = new TreeMap<>();
-      long start;
-      for (Map.Entry<Long, Resource> entry : cumulativeCapacity.entrySet()) {
-        if (delta > 0) {
-          start = (entry.getKey() == Long.MAX_VALUE) ? Long.MAX_VALUE
-              : entry.getKey() + delta;
-        } else {
-          start = (entry.getKey() == Long.MIN_VALUE) ? Long.MIN_VALUE
-              : entry.getKey() + delta;
-        }
-        newCum.put(start, entry.getValue());
-      }
-      cumulativeCapacity = newCum;
-    } finally {
-      writeLock.unlock();
-    }
-   * search. Maximum resource allocation across tick, tick + period, tick + 2 *
-   * period,..., tick + n * period .. is returned.
+   * search. Maximum resource allocation across tick, tick + period,
+   * tick + 2 * period,..., tick + n * period .. is returned.
-    readLock.lock();
-    try {
-      if (!cumulativeCapacity.isEmpty()) {
-        Long lastKey = cumulativeCapacity.lastKey();
-        for (long t = tick; t <= lastKey; t = t + period) {
-          maxCapacity = Resources.componentwiseMax(maxCapacity,
-              cumulativeCapacity.floorEntry(t).getValue());
-        }
+    if (!cumulativeCapacity.isEmpty()) {
+      Long lastKey = cumulativeCapacity.lastKey();
+      for (long t = tick; t <= lastKey; t = t + period) {
+        maxCapacity = Resources.componentwiseMax(maxCapacity,
+            cumulativeCapacity.floorEntry(t).getValue());
-      return maxCapacity;
-    } finally {
-      readLock.unlock();
+    return maxCapacity;
-    Resource minCapacity =
-        Resource.newInstance(Integer.MAX_VALUE, Integer.MAX_VALUE);
+    Resource minCapacity = Resource.newInstance(
+        Integer.MAX_VALUE, Integer.MAX_VALUE);
-        getRangeOverlapping(start, end).getCumulative();
+        this.getRangeOverlapping(start, end).getCumulative();
-          minCapacity =
-              Resources.componentwiseMin(minCapacity, entry.getValue());
+          minCapacity = Resources.componentwiseMin(minCapacity,
+              entry.getValue());

INS26 INS26 MOV31 UPD40 INS40 INS40 UPD83 UPD83 INS43 INS42 MOV8 UPD65 INS42 INS60 INS60 MOV21 INS54 MOV60 UPD66 UPD66 UPD66 UPD66 INS43 INS59 INS43 MOV59 INS8 INS12 MOV8 UPD66 UPD66 INS42 INS42 INS14 UPD42 MOV42 UPD42 MOV21 INS70 MOV21 MOV21 INS41 INS44 INS8 INS43 INS43 INS42 INS32 MOV44 MOV32 INS8 INS32 INS32 INS43 INS42 INS41 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV21 UPD42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS52 INS32 INS32 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 DEL42 DEL45 DEL79 DEL42 DEL45 DEL79 DEL42 DEL65 DEL66 DEL42 DEL42 DEL65 DEL39 DEL42 DEL39 DEL42 DEL44 DEL43 DEL74 DEL42 DEL32 DEL40 DEL27 DEL36 DEL40 DEL42 DEL42 DEL32 DEL42 DEL27 DEL16 DEL7 DEL42 DEL32 DEL40 DEL27 DEL36 DEL40 DEL32 DEL42 DEL27 DEL16 DEL7 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL7 DEL42 DEL42 DEL32 DEL21 DEL43 DEL43 DEL42 DEL43 DEL74 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL34 DEL27 DEL8 DEL8 DEL25 DEL8 DEL70 DEL8 DEL32 DEL21 DEL8 DEL54 DEL42 DEL42 DEL42 DEL32 DEL66 DEL42 DEL65 DEL66 DEL42 DEL65 DEL66 DEL65 DEL42 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL54 DEL8
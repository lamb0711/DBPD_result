HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.

+import com.google.common.base.Preconditions;
+import org.apache.commons.io.Charsets;
-import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.hdfs.protocol.SnapshotAccessControlException;
+import java.util.AbstractMap;
+import java.util.Map;
-  static HdfsFileStatus mkdirs(
-      FSNamesystem fsn, String src, PermissionStatus permissions,
-      boolean createParent) throws IOException {
+
+  static HdfsFileStatus mkdirs(FSNamesystem fsn, String src,
+      PermissionStatus permissions, boolean createParent) throws IOException {
-    src = fsd.resolvePath(pc, src, pathComponents);
-    INodesInPath iip = fsd.getINodesInPath4Write(src);
-    if (fsd.isPermissionEnabled()) {
-      fsd.checkTraverse(pc, iip);
-    }
-
-    if (!isDirMutable(fsd, iip)) {
-      if (fsd.isPermissionEnabled()) {
-        fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);
-      }
-
-      if (!createParent) {
-        fsd.verifyParentDir(iip, src);
-      }
-
-      // validate that we have enough inodes. This is, at best, a
-      // heuristic because the mkdirs() operation might need to
-      // create multiple inodes.
-      fsn.checkFsObjectLimit();
-      iip = mkdirsRecursively(fsd, iip, permissions, false, now());
-      if (iip == null) {
-        throw new IOException("Failed to create directory: " + src);
-      }
-    }
-    return fsd.getAuditFileInfo(iip);
-  }
-
-  static INode unprotectedMkdir(
-      FSDirectory fsd, long inodeId, String src,
-      PermissionStatus permissions, List<AclEntry> aclEntries, long timestamp)
-      throws QuotaExceededException, UnresolvedLinkException, AclException {
-    assert fsd.hasWriteLock();
-    byte[][] components = INode.getPathComponents(src);
-    final INodesInPath iip = fsd.getExistingPathINodes(components);
-    final int pos = iip.length() - 1;
-    final INodesInPath newiip = unprotectedMkdir(fsd, inodeId, iip, pos,
-        components[pos], permissions, aclEntries, timestamp);
-    return newiip.getINode(pos);
-  }
-
-  /**
-   * Create a directory
-   * If ancestor directories do not exist, automatically create them.
-
-   * @param fsd FSDirectory
-   * @param iip the INodesInPath instance containing all the existing INodes
-   *            and null elements for non-existing components in the path
-   * @param permissions the permission of the directory
-   * @param inheritPermission
-   *   if the permission of the directory should inherit from its parent or not.
-   *   u+wx is implicitly added to the automatically created directories,
-   *   and to the given directory if inheritPermission is true
-   * @param now creation time
-   * @return non-null INodesInPath instance if operation succeeds
-   * @throws QuotaExceededException if directory creation violates
-   *                                any quota limit
-   * @throws UnresolvedLinkException if a symlink is encountered in src.
-   * @throws SnapshotAccessControlException if path is in RO snapshot
-   */
-  static INodesInPath mkdirsRecursively(FSDirectory fsd, INodesInPath iip,
-      PermissionStatus permissions, boolean inheritPermission, long now)
-      throws FileAlreadyExistsException, QuotaExceededException,
-             UnresolvedLinkException, SnapshotAccessControlException,
-             AclException {
-    final int lastInodeIndex = iip.length() - 1;
-    final byte[][] components = iip.getPathComponents();
-    final String[] names = new String[components.length];
-    for (int i = 0; i < components.length; i++) {
-      names[i] = DFSUtil.bytes2String(components[i]);
-    }
-
-      if (iip.isSnapshot()) {
-        throw new SnapshotAccessControlException(
-                "Modification on RO snapshot is disallowed");
-      }
-      final int length = iip.length();
-      // find the index of the first null in inodes[]
-      StringBuilder pathbuilder = new StringBuilder();
-      int i = 1;
-      INode curNode;
-      for(; i < length && (curNode = iip.getINode(i)) != null; i++) {
-        pathbuilder.append(Path.SEPARATOR).append(names[i]);
-        if (!curNode.isDirectory()) {
-          throw new FileAlreadyExistsException("Parent path is not a directory: "
-                  + pathbuilder + " " + curNode.getLocalName());
-        }
+      src = fsd.resolvePath(pc, src, pathComponents);
+      INodesInPath iip = fsd.getINodesInPath4Write(src);
+      if (fsd.isPermissionEnabled()) {
+        fsd.checkTraverse(pc, iip);
-      // default to creating parent dirs with the given perms
-      PermissionStatus parentPermissions = permissions;
-
-      // if not inheriting and it's the last inode, there's no use in
-      // computing perms that won't be used
-      if (inheritPermission || (i < lastInodeIndex)) {
-        // if inheriting (ie. creating a file or symlink), use the parent dir,
-        // else the supplied permissions
-        // NOTE: the permissions of the auto-created directories violate posix
-        FsPermission parentFsPerm = inheritPermission ?
-            iip.getINode(i-1).getFsPermission() : permissions.getPermission();
-
-        // ensure that the permissions allow user write+execute
-        if (!parentFsPerm.getUserAction().implies(FsAction.WRITE_EXECUTE)) {
-          parentFsPerm = new FsPermission(
-                  parentFsPerm.getUserAction().or(FsAction.WRITE_EXECUTE),
-                  parentFsPerm.getGroupAction(),
-                  parentFsPerm.getOtherAction()
-          );
-        }
-
-        if (!parentPermissions.getPermission().equals(parentFsPerm)) {
-          parentPermissions = new PermissionStatus(
-                  parentPermissions.getUserName(),
-                  parentPermissions.getGroupName(),
-                  parentFsPerm
-          );
-          // when inheriting, use same perms for entire path
-          if (inheritPermission) permissions = parentPermissions;
-        }
+      final INode lastINode = iip.getLastINode();
+      if (lastINode != null && lastINode.isFile()) {
+        throw new FileAlreadyExistsException("Path is not a directory: " + src);
-      // create directories beginning from the first null index
-      for(; i < length; i++) {
-        pathbuilder.append(Path.SEPARATOR).append(names[i]);
-        iip = unprotectedMkdir(fsd, fsd.allocateNewInodeId(), iip, i,
-            components[i], (i < lastInodeIndex) ? parentPermissions :
-                permissions, null, now);
-        if (iip.getINode(i) == null) {
-          return null;
+      INodesInPath existing = lastINode != null ? iip : iip.getExistingINodes();
+      if (lastINode == null) {
+        if (fsd.isPermissionEnabled()) {
+          fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);
-        // Directory creation also count towards FilesCreated
-        // to match count of FilesDeleted metric.
-        NameNode.getNameNodeMetrics().incrFilesCreated();
-        final String cur = pathbuilder.toString();
-        fsd.getEditLog().logMkDir(cur, iip.getINode(i));
-        if(NameNode.stateChangeLog.isDebugEnabled()) {
-          NameNode.stateChangeLog.debug(
-                  "mkdirs: created directory " + cur);
+        if (!createParent) {
+          fsd.verifyParentDir(iip, src);
+        }
+
+        // validate that we have enough inodes. This is, at best, a
+        // heuristic because the mkdirs() operation might need to
+        // create multiple inodes.
+        fsn.checkFsObjectLimit();
+
+        List<String> nonExisting = iip.getPath(existing.length(),
+            iip.length() - existing.length());
+        int length = nonExisting.size();
+        if (length > 1) {
+          List<String> ancestors = nonExisting.subList(0, length - 1);
+          // Ensure that the user can traversal the path by adding implicit
+          // u+wx permission to all ancestor directories
+          existing = createChildrenDirectories(fsd, existing, ancestors,
+              addImplicitUwx(permissions, permissions));
+          if (existing == null) {
+            throw new IOException("Failed to create directory: " + src);
+          }
+        }
+
+        if ((existing = createChildrenDirectories(fsd, existing,
+            nonExisting.subList(length - 1, length), permissions)) == null) {
+          throw new IOException("Failed to create directory: " + src);
+      return fsd.getAuditFileInfo(existing);
-    return iip;
-   * Check whether the path specifies a directory
-   * @throws SnapshotAccessControlException if path is in RO snapshot
+   * For a given absolute path, create all ancestors as directories along the
+   * path. All ancestors inherit their parent's permission plus an implicit
+   * u+wx permission. This is used by create() and addSymlink() for
+   * implicitly creating all directories along the path.
+   *
+   * For example, path="/foo/bar/spam", "/foo" is an existing directory,
+   * "/foo/bar" is not existing yet, the function will create directory bar.
+   *
+   * @return a tuple which contains both the new INodesInPath (with all the
+   * existing and newly created directories) and the last component in the
+   * relative path. Or return null if there are errors.
-  private static boolean isDirMutable(FSDirectory fsd, INodesInPath iip)
-      throws SnapshotAccessControlException {
-    fsd.readLock();
-    try {
-      INode node = iip.getLastINode();
-      return node != null && node.isDirectory();
-    } finally {
-      fsd.readUnlock();
+  static Map.Entry<INodesInPath, String> createAncestorDirectories(
+      FSDirectory fsd, INodesInPath iip, PermissionStatus permission)
+      throws IOException {
+    final String last = new String(iip.getLastLocalName(), Charsets.UTF_8);
+    INodesInPath existing = iip.getExistingINodes();
+    List<String> children = iip.getPath(existing.length(),
+        iip.length() - existing.length());
+    int size = children.size();
+    if (size > 1) { // otherwise all ancestors have been created
+      List<String> directories = children.subList(0, size - 1);
+      INode parentINode = existing.getLastINode();
+      // Ensure that the user can traversal the path by adding implicit
+      // u+wx permission to all ancestor directories
+      existing = createChildrenDirectories(fsd, existing, directories,
+          addImplicitUwx(parentINode.getPermissionStatus(), permission));
+      if (existing == null) {
+        return null;
+      }
+    return new AbstractMap.SimpleImmutableEntry<>(existing, last);
-  /** create a directory at index pos.
-   * The parent path to the directory is at [0, pos-1].
-   * All ancestors exist. Newly created one stored at index pos.
+  /**
+   * Create the directory {@code parent} / {@code children} and all ancestors
+   * along the path.
+   *
+   * @param fsd FSDirectory
+   * @param existing The INodesInPath instance containing all the existing
+   *                 ancestral INodes
+   * @param children The relative path from the parent towards children,
+   *                 starting with "/"
+   * @param perm the permission of the directory. Note that all ancestors
+   *             created along the path has implicit {@code u+wx} permissions.
+   *
+   * @return {@link INodesInPath} which contains all inodes to the
+   * target directory, After the execution parentPath points to the path of
+   * the returned INodesInPath. The function return null if the operation has
+   * failed.
-  private static INodesInPath unprotectedMkdir(
-      FSDirectory fsd, long inodeId, INodesInPath inodesInPath, int pos,
-      byte[] name, PermissionStatus permission, List<AclEntry> aclEntries,
-      long timestamp)
-      throws QuotaExceededException, AclException {
+  private static INodesInPath createChildrenDirectories(FSDirectory fsd,
+      INodesInPath existing, List<String> children, PermissionStatus perm)
+      throws IOException {
+
+    for (String component : children) {
+      existing = createSingleDirectory(fsd, existing, component, perm);
+      if (existing == null) {
+        return null;
+      }
+    }
+    return existing;
+  }
+
+  static void mkdirForEditLog(FSDirectory fsd, long inodeId, String src,
+      PermissionStatus permissions, List<AclEntry> aclEntries, long timestamp)
+      throws QuotaExceededException, UnresolvedLinkException, AclException,
+      FileAlreadyExistsException {
+    assert fsd.hasWriteLock();
+    INodesInPath iip = fsd.getINodesInPath(src, false);
+    final byte[] localName = iip.getLastLocalName();
+    final INodesInPath existing = iip.getParentINodesInPath();
+    Preconditions.checkState(existing.getLastINode() != null);
+    unprotectedMkdir(fsd, inodeId, existing, localName, permissions, aclEntries,
+        timestamp);
+  }
+
+  private static INodesInPath createSingleDirectory(FSDirectory fsd,
+      INodesInPath existing, String localName, PermissionStatus perm)
+      throws IOException {
+    assert fsd.hasWriteLock();
+    existing = unprotectedMkdir(fsd, fsd.allocateNewInodeId(), existing,
+        localName.getBytes(Charsets.UTF_8), perm, null, now());
+    if (existing == null) {
+      return null;
+    }
+
+    final INode newNode = existing.getLastINode();
+    // Directory creation also count towards FilesCreated
+    // to match count of FilesDeleted metric.
+    NameNode.getNameNodeMetrics().incrFilesCreated();
+
+    String cur = existing.getPath();
+    fsd.getEditLog().logMkDir(cur, newNode);
+    if (NameNode.stateChangeLog.isDebugEnabled()) {
+      NameNode.stateChangeLog.debug("mkdirs: created directory " + cur);
+    }
+    return existing;
+  }
+
+  private static PermissionStatus addImplicitUwx(PermissionStatus parentPerm,
+      PermissionStatus perm) {
+    FsPermission p = parentPerm.getPermission();
+    FsPermission ancestorPerm = new FsPermission(
+        p.getUserAction().or(FsAction.WRITE_EXECUTE),
+        p.getGroupAction(),
+        p.getOtherAction());
+    return new PermissionStatus(perm.getUserName(), perm.getGroupName(),
+        ancestorPerm);
+  }
+
+  /**
+   * create a directory at path specified by parent
+   */
+  private static INodesInPath unprotectedMkdir(FSDirectory fsd, long inodeId,
+      INodesInPath parent, byte[] name, PermissionStatus permission,
+      List<AclEntry> aclEntries, long timestamp)
+      throws QuotaExceededException, AclException, FileAlreadyExistsException {
+    assert fsd.hasWriteLock();
+    assert parent.getLastINode() != null;
+    if (!parent.getLastINode().isDirectory()) {
+      throw new FileAlreadyExistsException("Parent path is not a directory: " +
+          parent.getPath() + " " + DFSUtil.bytes2String(name));
+    }
-    if (fsd.addChild(inodesInPath, pos, dir, true)) {
-      if (aclEntries != null) {
-        AclStorage.updateINodeAcl(dir, aclEntries, Snapshot.CURRENT_STATE_ID);
-      }
-      return INodesInPath.replace(inodesInPath, pos, dir);
-    } else {
-      return inodesInPath;
+
+    INodesInPath iip = fsd.addLastINode(parent, dir, true);
+    if (iip != null && aclEntries != null) {
+      AclStorage.updateINodeAcl(dir, aclEntries, Snapshot.CURRENT_STATE_ID);
+    return iip;
+

MOV26 MOV26 INS26 INS26 INS40 UPD40 UPD40 INS40 INS31 INS31 INS31 INS31 INS29 INS74 INS42 INS44 MOV44 INS43 MOV29 INS83 MOV83 INS43 INS42 MOV44 MOV44 INS44 INS44 UPD43 MOV43 INS8 INS83 INS39 INS42 MOV44 MOV44 MOV44 MOV44 MOV44 MOV44 MOV43 MOV43 MOV43 MOV43 INS8 INS83 INS83 MOV43 INS42 MOV44 INS44 INS44 INS44 INS43 INS8 MOV83 MOV83 INS43 INS42 MOV44 INS44 MOV8 INS43 MOV21 INS54 INS65 INS65 INS43 MOV43 INS43 INS43 INS42 UPD42 INS42 INS60 INS60 INS25 INS41 INS65 INS42 INS43 INS42 INS74 INS42 MOV43 INS42 UPD42 MOV6 INS70 INS41 INS6 INS60 INS60 MOV60 INS21 INS21 INS43 INS42 INS43 INS42 MOV43 INS42 INS42 INS6 MOV21 MOV25 MOV60 MOV21 INS60 MOV21 MOV25 INS41 INS42 UPD43 UPD42 INS43 INS42 INS60 MOV60 INS41 UPD42 INS42 INS6 INS25 INS60 MOV25 MOV41 INS8 MOV8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS40 INS42 INS42 INS83 INS43 INS59 INS43 INS74 MOV39 INS59 INS27 INS8 INS14 UPD66 INS65 INS66 INS65 UPD66 INS66 UPD42 UPD66 UPD66 UPD42 UPD66 INS66 UPD42 UPD66 UPD66 INS65 UPD66 INS66 INS65 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS42 INS43 MOV43 INS44 INS42 INS8 INS42 INS32 UPD43 MOV43 INS59 INS83 INS5 INS59 INS83 MOV43 INS32 INS32 INS42 INS42 INS32 MOV43 INS43 INS59 INS42 UPD42 UPD42 MOV42 MOV43 INS59 MOV43 INS59 INS14 UPD66 INS27 INS38 MOV8 INS43 INS59 INS27 MOV21 MOV60 MOV25 INS60 INS25 INS60 MOV25 MOV41 INS21 INS42 INS42 INS14 INS42 UPD42 INS43 INS43 UPD42 INS42 INS32 INS42 INS34 INS60 INS60 INS21 INS25 INS74 INS42 INS42 INS66 INS66 INS66 UPD42 MOV42 UPD42 MOV42 MOV43 INS42 MOV21 MOV25 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS32 INS39 INS85 INS42 INS32 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS27 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 UPD42 INS42 INS42 INS32 MOV32 UPD42 UPD42 INS42 INS42 INS32 INS42 INS14 INS43 INS32 INS32 INS42 INS32 INS33 INS32 INS53 INS42 INS42 INS32 INS27 MOV27 INS83 MOV43 INS59 INS27 INS8 INS43 INS59 INS27 INS8 INS32 MOV43 INS32 INS40 UPD42 UPD42 INS42 INS42 UPD42 UPD42 INS32 MOV27 INS42 INS42 INS74 MOV59 MOV43 INS59 INS7 INS27 INS8 INS43 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS9 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 INS32 INS33 UPD42 INS32 INS42 MOV32 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS32 INS32 INS32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 INS14 INS42 INS42 INS42 INS42 INS9 INS42 INS33 INS42 INS42 MOV32 INS27 INS32 INS53 INS42 INS42 INS16 INS42 INS33 MOV25 MOV25 MOV21 INS60 INS60 INS25 INS25 UPD42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS32 INS43 INS43 UPD42 INS32 UPD42 MOV42 INS32 INS42 INS32 INS42 INS33 INS41 INS40 INS42 INS32 INS42 INS33 INS41 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS40 UPD42 MOV42 INS32 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS43 INS27 INS42 INS42 INS42 INS33 INS42 INS42 INS14 INS27 INS42 INS32 INS74 INS59 INS39 INS59 INS27 MOV8 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS27 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS33 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS33 INS42 INS42 INS42 INS45 INS32 INS45 INS32 MOV43 INS27 INS42 INS33 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS32 INS42 INS34 INS60 INS36 INS33 INS53 INS42 MOV34 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS27 INS42 INS42 INS74 INS59 INS7 INS14 INS42 INS42 INS42 INS42 MOV32 INS32 INS43 INS43 INS42 INS32 UPD42 UPD42 INS42 INS32 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS27 UPD42 UPD42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS34 INS42 MOV42 INS42 INS42 INS42 INS27 INS42 INS42 INS34 DEL9 DEL32 DEL38 DEL42 DEL39 DEL85 DEL85 DEL5 DEL42 DEL83 DEL34 DEL27 DEL83 DEL60 DEL83 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL41 DEL66 DEL65 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL39 DEL42 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL32 DEL42 DEL42 DEL32 DEL42 DEL43 DEL45 DEL14 DEL53 DEL42 DEL42 DEL34 DEL27 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL16 DEL42 DEL42 DEL42 DEL2 DEL42 DEL42 DEL27 DEL36 DEL42 DEL42 DEL16 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL59 DEL32 DEL21 DEL42 DEL33 DEL27 DEL32 DEL27 DEL41 DEL8 DEL32 DEL21 DEL8 DEL54 DEL42 DEL39 DEL42 DEL44 DEL43 DEL42 DEL43 DEL42 DEL43 DEL83 DEL39 DEL42 DEL59 DEL60 DEL83 DEL39 DEL85 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL85 DEL5 DEL42 DEL85 DEL5 DEL40 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL83 DEL39 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL27 DEL42 DEL37 DEL42 DEL40 DEL32 DEL42 DEL42 DEL2 DEL32 DEL21 DEL42 DEL42 DEL32 DEL38 DEL45 DEL42 DEL45 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL27 DEL36 DEL27 DEL42 DEL32 DEL40 DEL32 DEL38 DEL42 DEL32 DEL40 DEL32 DEL32 DEL32 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL7 DEL21 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL40 DEL32 DEL42 DEL42 DEL2 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL8 DEL54 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL39 DEL42 DEL43 DEL31 DEL66 DEL66 DEL39 DEL42 DEL44 DEL42 DEL32 DEL41 DEL9 DEL32 DEL42 DEL41 DEL8 DEL25
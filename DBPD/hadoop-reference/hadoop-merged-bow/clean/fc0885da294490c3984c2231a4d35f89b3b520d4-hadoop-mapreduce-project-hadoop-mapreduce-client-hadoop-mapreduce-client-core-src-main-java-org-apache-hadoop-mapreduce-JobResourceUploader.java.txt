MAPREDUCE-6846. Fragments specified for libjar paths are not handled correctly
(Contributed by Chris Trezzo via Daniel Templeton)

+import java.util.LinkedList;
-    FileSystem.mkdirs(jtFs, submitJobDir, mapredSysPerms);
+    mkdirs(jtFs, submitJobDir, mapredSysPerms);
-  private void uploadFiles(Configuration conf, Collection<String> files,
+  @VisibleForTesting
+  void uploadFiles(Configuration conf, Collection<String> files,
-      FileSystem.mkdirs(jtFs, filesDir, mapredSysPerms);
+      mkdirs(jtFs, filesDir, mapredSysPerms);
-          throw new IllegalArgumentException(e);
+          throw new IllegalArgumentException("Error parsing files argument."
+              + " Argument must be a valid URI: " + tmpFile, e);
-          throw new IOException("Failed to create uri for " + tmpFile, ue);
+          throw new IOException(
+              "Failed to create a URI (URISyntaxException) for the remote path "
+                  + newPath + ". This was based on the files parameter: "
+                  + tmpFile,
+              ue);
-  private void uploadLibJars(Configuration conf, Collection<String> libjars,
+  // Suppress warning for use of DistributedCache (it is everywhere).
+  @SuppressWarnings("deprecation")
+  @VisibleForTesting
+  void uploadLibJars(Configuration conf, Collection<String> libjars,
-      FileSystem.mkdirs(jtFs, libjarsDir, mapredSysPerms);
+      mkdirs(jtFs, libjarsDir, mapredSysPerms);
+      Collection<URI> libjarURIs = new LinkedList<>();
+      boolean foundFragment = false;
-        Path tmp = new Path(tmpjars);
+        URI tmpURI = null;
+        try {
+          tmpURI = new URI(tmpjars);
+        } catch (URISyntaxException e) {
+          throw new IllegalArgumentException("Error parsing libjars argument."
+              + " Argument must be a valid URI: " + tmpjars, e);
+        }
+        Path tmp = new Path(tmpURI);
-
-        // Add each file to the classpath
-        DistributedCache.addFileToClassPath(
-            new Path(newPath.toUri().getPath()), conf, jtFs, !useWildcard);
+        try {
+          URI pathURI = getPathURI(newPath, tmpURI.getFragment());
+          if (!foundFragment) {
+            foundFragment = pathURI.getFragment() != null;
+          }
+          DistributedCache.addFileToClassPath(new Path(pathURI.getPath()), conf,
+              jtFs, false);
+          libjarURIs.add(pathURI);
+        } catch (URISyntaxException ue) {
+          // should not throw a uri exception
+          throw new IOException(
+              "Failed to create a URI (URISyntaxException) for the remote path "
+                  + newPath + ". This was based on the libjar parameter: "
+                  + tmpjars,
+              ue);
+        }
-      if (useWildcard) {
-        // Add the whole directory to the cache
+      if (useWildcard && !foundFragment) {
+        // Add the whole directory to the cache using a wild card
-
+      } else {
+        for (URI uri : libjarURIs) {
+          DistributedCache.addCacheFile(uri, conf);
+        }
-  private void uploadArchives(Configuration conf, Collection<String> archives,
+  @VisibleForTesting
+  void uploadArchives(Configuration conf, Collection<String> archives,
-      FileSystem.mkdirs(jtFs, archivesDir, mapredSysPerms);
+      mkdirs(jtFs, archivesDir, mapredSysPerms);
-          throw new IllegalArgumentException(e);
+          throw new IllegalArgumentException("Error parsing archives argument."
+              + " Argument must be a valid URI: " + tmpArchives, e);
-          throw new IOException("Failed to create uri for " + tmpArchives, ue);
+          throw new IOException(
+              "Failed to create a URI (URISyntaxException) for the remote path"
+                  + newPath + ". This was based on the archive parameter: "
+                  + tmpArchives,
+              ue);
-  private void uploadJobJar(Job job, String jobJar, Path submitJobDir,
+  @VisibleForTesting
+  void uploadJobJar(Job job, String jobJar, Path submitJobDir,
-      throw new IllegalArgumentException(e);
+      throw new IllegalArgumentException(
+          "Error parsing argument." + " Argument must be a valid URI: " + s, e);
+  /**
+   * Create a new directory in the passed filesystem. This wrapper method exists
+   * so that it can be overridden/stubbed during testing.
+   */
+  @VisibleForTesting
+  boolean mkdirs(FileSystem fs, Path dir, FsPermission permission)
+      throws IOException {
+    return FileSystem.mkdirs(fs, dir, permission);
+  }
+
-  private Path copyRemoteFiles(Path parentDir, Path originalPath,
+  @VisibleForTesting
+  Path copyRemoteFiles(Path parentDir, Path originalPath,
+    jtFs.makeQualified(newPath);
-  private void copyJar(Path originalJarPath, Path submitJarFile,
+  @VisibleForTesting
+  void copyJar(Path originalJarPath, Path submitJarFile,
-        pathURI = new URI(pathURI.toString() + "#" + destPath.getName());
+        // no fragment, just return existing pathURI from destPath

INS26 INS40 INS31 INS78 INS79 INS78 INS78 INS78 INS29 INS78 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS78 INS78 INS42 INS42 INS45 INS42 INS42 INS42 INS65 INS42 INS43 INS42 MOV43 INS42 INS43 INS42 INS42 INS41 INS42 INS21 INS42 INS66 INS66 INS42 INS42 INS32 INS32 INS60 INS60 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS59 INS39 INS59 INS27 INS8 INS43 INS43 INS42 INS14 INS42 INS9 INS60 MOV54 INS54 INS42 INS38 INS70 INS54 INS42 INS42 INS74 INS43 INS59 INS8 INS8 INS12 INS42 INS44 INS42 INS8 MOV8 INS12 INS27 INS43 INS42 INS42 INS33 INS21 INS60 INS25 MOV21 INS21 MOV44 INS8 MOV43 INS42 INS21 INS44 INS8 INS44 INS45 INS45 INS42 INS42 INS7 INS43 UPD42 INS43 INS59 INS38 INS8 INS32 INS53 INS32 INS43 INS42 INS53 INS43 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS21 INS9 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS27 INS43 INS42 INS27 INS42 INS42 INS32 INS7 MOV43 INS27 INS42 INS43 INS27 INS42 INS43 INS45 INS45 INS42 UPD45 INS42 INS45 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS27 UPD42 MOV42 INS45 INS42 INS45 INS42 INS42 INS45 INS45 INS42 INS42 UPD45 INS42 INS45 INS32 INS33 INS42 INS42 DEL42 DEL83 DEL42 DEL83 DEL42 DEL42 DEL32 DEL42 DEL38 DEL42 DEL83 DEL42 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL14 DEL7 DEL21
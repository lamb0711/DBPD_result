HDFS-12275. Ozone: Corona: Support for random validation of writes. Contributed by Nandakumar.

-
+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.ozone.OzoneConfiguration;
+import org.apache.hadoop.ozone.client.io.OzoneInputStream;
-import org.apache.hadoop.ozone.OzoneConfiguration;
+import java.util.Arrays;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.function.Supplier;
+  private static final String VALIDATE_WRITE = "validateWrites";
+  private boolean validateWrites;
+
-  private Corona(Configuration conf) throws IOException {
+  private Long totalWritesValidated;
+  private Long writeValidationSuccessCount;
+  private Long writeValidationFailureCount;
+
+  private BlockingQueue<KeyValue> validationQueue;
+
+  @VisibleForTesting
+  Corona(Configuration conf) throws IOException {
-      for(int i = 0; i < Integer.parseInt(numOfVolumes); i++) {
+      for (int i = 0; i < Integer.parseInt(numOfVolumes); i++) {
-      Thread progressbar = getProgressBarThread();
-      LOG.info("Starting progress bar Thread.");
-      progressbar.start();
-      processor.shutdown();
-      processor.awaitTermination(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      completed = true;
-      progressbar.join();
-      return 0;
+    Thread validator = null;
+    if(validateWrites) {
+      totalWritesValidated = 0L;
+      writeValidationSuccessCount = 0L;
+      writeValidationFailureCount = 0L;
+
+      validationQueue =
+          new ArrayBlockingQueue<>(Integer.parseInt(numOfThreads));
+      validator = new Thread(new Validator());
+      validator.start();
+      LOG.info("Data validation is enabled.");
+    }
+    Thread progressbar = getProgressBarThread();
+    LOG.info("Starting progress bar Thread.");
+    progressbar.start();
+    processor.shutdown();
+    processor.awaitTermination(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+    completed = true;
+    progressbar.join();
+    if(validateWrites) {
+      validator.join();
+    }
+    return 0;
+    OptionBuilder.withDescription("do random validation of " +
+        "data written into ozone, only subset of data is validated.");
+    Option optValidateWrite = OptionBuilder.create(VALIDATE_WRITE);
+
+    options.addOption(optValidateWrite);
+    validateWrites = cmdLine.hasOption(VALIDATE_WRITE);
+
+    System.out.println("-validateWrites                 "
+        + "do random validation of data written into ozone, " +
+        "only subset of data is validated.");
+
+              if(validateWrites) {
+                boolean validate = validationQueue.offer(
+                    new KeyValue(volume, bucket, key, value));
+                if(validate) {
+                  LOG.trace("Key {}, is queued for validation.", key);
+                }
+              }
-    long maxValue = Integer.parseInt(numOfVolumes) *
-        Integer.parseInt(numOfBuckets) *
-        Integer.parseInt(numOfKeys);
+    Supplier<Long> currentValue;
+    long maxValue;
+
+    if(mode.equals("online")) {
+      throw new UnsupportedOperationException("Not yet implemented.");
+    } else {
+      currentValue = () -> numberOfKeysAdded.get();
+      maxValue = Long.parseLong(numOfVolumes) *
+          Long.parseLong(numOfBuckets) *
+          Long.parseLong(numOfKeys);
+    }
-        new ProgressBar(System.out, maxValue));
+        new ProgressBar(System.out, currentValue, maxValue));
+    private Supplier<Long> currentValue;
-    ProgressBar(PrintStream stream, long maxValue) {
+    ProgressBar(PrintStream stream, Supplier<Long> currentValue,
+                long maxValue) {
+      this.currentValue = currentValue;
-        long keys;
-        while((keys = numberOfKeysAdded.get()) < maxValue) {
-          print(keys);
+        long value;
+        while((value = currentValue.get()) < maxValue) {
+          print(value);
-     * @param currentValue
+     * @param value
-    private void print(long currentValue) {
+    private void print(long value) {
-      double percent = 100.0 * currentValue / maxValue;
+      double percent = 100.0 * value / maxValue;
-      sb.append(currentValue + "/" + maxValue);
+      sb.append(value + "/" + maxValue);
+    if(validateWrites) {
+      out.println("Total number of writes validated: " +
+          totalWritesValidated);
+      out.println("Writes validated: " +
+          (100.0 * totalWritesValidated / numberOfKeysAdded.get())
+          + " %");
+      out.println("Successful validation: " +
+          writeValidationSuccessCount);
+      out.println("Unsuccessful validation: " +
+          writeValidationFailureCount);
+    }
+   * Returns the number of volumes created.
+   * @return volume count.
+   */
+  @VisibleForTesting
+  int getNumberOfVolumesCreated() {
+    return numberOfVolumesCreated.get();
+  }
+
+  /**
+   * Returns the number of buckets created.
+   * @return bucket count.
+   */
+  @VisibleForTesting
+  int getNumberOfBucketsCreated() {
+    return  numberOfBucketsCreated.get();
+  }
+
+  /**
+   * Returns the number of keys added.
+   * @return keys count.
+   */
+  @VisibleForTesting
+  long getNumberOfKeysAdded() {
+    return  numberOfKeysAdded.get();
+  }
+
+  /**
+   * Returns true if random validation of write is enabled.
+   * @return validateWrites
+   */
+  @VisibleForTesting
+  boolean getValidateWrites() {
+    return validateWrites;
+  }
+
+  /**
+   * Returns the number of keys validated.
+   * @return validated key count.
+   */
+  @VisibleForTesting
+  long getTotalKeysValidated() {
+    return totalWritesValidated;
+  }
+
+  /**
+   * Returns the number of successful validation.
+   * @return successful validation count.
+   */
+  @VisibleForTesting
+  long getSuccessfulValidationCount() {
+    return writeValidationSuccessCount;
+  }
+
+  /**
+   * Returns the number of unsuccessful validation.
+   * @return unsuccessful validation count.
+   */
+  @VisibleForTesting
+  long getUnsuccessfulValidationCount() {
+    return writeValidationFailureCount;
+  }
+
+  /**
+   * Validates the write done in ozone cluster.
+   */
+  private class Validator implements Runnable {
+
+    @Override
+    public void run() {
+      while(!completed) {
+        try {
+          KeyValue kv = validationQueue.poll(5, TimeUnit.SECONDS);
+          if(kv != null) {
+            OzoneInputStream is = ozoneClient.
+                getKey(kv.volume, kv.bucket, kv.key);
+            byte[] value = new byte[kv.value.length];
+            int length = is.read(value);
+            totalWritesValidated++;
+            if (length == kv.value.length && Arrays.equals(value, kv.value)) {
+              writeValidationSuccessCount++;
+            } else {
+              writeValidationFailureCount++;
+              LOG.warn("Data validation error for key {}/{}/{}",
+                  kv.volume, kv.bucket, kv.key);
+              LOG.warn("Expected: {}, Actual: {}",
+                  DFSUtil.bytes2String(kv.value),
+                  DFSUtil.bytes2String(value));
+            }
+          }
+        } catch (IOException | InterruptedException ex) {
+          LOG.error("Exception while validating write: " + ex.getMessage());
+        }
+      }
+    }
+  }
+
+
+
+  /**
+   * Wrapper to hold ozone key-value pair.
+   */
+  private static class KeyValue {
+
+    /**
+     * Volume name associated with the key-value.
+     */
+    private String volume;
+
+    /**
+     * Bucket name associated with the key-value.
+     */
+    private String bucket;
+    /**
+     * Key name associated with the key-value.
+     */
+    private String key;
+    /**
+     * Value associated with the key-value.
+     */
+    private byte[] value;
+
+    /**
+     * Constructs a new ozone key-value pair.
+     *
+     * @param key   key part
+     * @param value value part
+     */
+    KeyValue(
+        String volume, String bucket, String key, byte[] value) {
+      this.volume = volume;
+      this.bucket = bucket;
+      this.key = key;
+      this.value = value;
+    }
+  }
+
+  /**

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS55 INS83 INS83 INS83 INS43 INS59 INS83 INS39 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS74 INS59 INS78 MOV21 MOV21 MOV21 MOV60 MOV21 MOV60 MOV21 MOV60 INS23 INS29 INS78 INS39 INS42 INS8 INS29 INS78 INS39 INS42 INS8 INS29 INS78 INS39 INS42 INS8 INS29 INS78 INS39 INS42 INS8 INS29 INS78 INS39 INS42 INS8 INS29 INS78 INS39 INS42 INS8 INS29 INS78 INS39 INS42 INS8 INS29 INS83 INS42 INS43 INS31 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS23 INS31 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS60 INS25 MOV60 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS25 MOV41 INS21 INS60 INS21 INS21 INS21 INS60 INS60 INS25 INS83 INS74 INS59 INS44 INS25 INS65 INS65 INS42 INS41 INS65 INS65 INS42 INS41 INS65 INS65 INS42 INS41 INS65 INS65 INS42 INS41 INS65 INS65 INS42 INS41 INS65 INS65 INS42 INS41 INS65 INS65 INS42 INS41 INS65 INS42 INS78 INS83 INS39 INS42 INS8 INS65 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS5 INS59 INS29 INS42 INS44 INS44 INS44 INS44 INS8 INS42 INS42 INS43 INS59 INS42 INS8 INS42 INS8 INS32 INS43 INS59 INS32 INS7 INS32 INS74 INS59 MOV39 INS59 INS32 INS8 INS8 INS43 INS43 INS42 INS74 INS42 INS21 UPD42 INS42 INS8 INS66 INS66 INS32 INS66 INS66 INS32 INS66 INS66 INS32 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS61 INS66 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS39 INS85 INS42 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS5 INS42 INS21 INS21 INS21 INS21 INS42 INS42 INS33 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS40 INS42 INS27 INS43 INS43 INS42 MOV42 INS42 INS42 INS45 INS53 INS21 INS21 INS42 INS42 INS43 INS43 INS7 UPD42 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS8 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS39 INS85 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS32 INS32 INS32 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS45 INS42 INS42 INS14 INS7 INS7 INS42 INS42 INS22 INS42 INS32 INS32 INS32 INS32 INS42 INS54 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS43 INS45 INS42 INS86 INS42 INS27 INS42 INS52 INS42 INS27 UPD42 INS42 INS42 INS27 INS42 INS42 UPD27 MOV27 INS42 INS42 INS27 INS42 INS42 INS27 INS8 INS12 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS74 INS32 INS43 INS14 INS42 INS32 MOV32 MOV32 MOV32 UPD42 INS36 INS42 UPD42 INS45 INS42 INS45 INS45 INS45 INS42 INS45 INS42 INS60 INS25 INS44 INS8 INS43 INS42 INS42 INS42 INS42 INS43 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS7 INS27 INS43 INS59 INS27 INS8 INS84 INS42 INS21 INS42 INS42 INS42 INS32 UPD42 INS27 MOV32 INS42 INS42 INS32 INS42 INS33 INS60 INS60 INS60 INS21 INS25 INS43 INS43 INS32 INS42 INS42 INS34 INS42 INS42 INS42 INS34 INS40 INS43 INS59 INS5 INS59 INS39 INS59 INS37 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS27 INS25 INS42 INS42 INS32 INS39 INS85 INS42 INS3 INS42 INS32 INS42 INS27 INS32 INS21 INS21 INS21 INS21 INS45 INS32 INS42 INS8 INS42 INS42 INS40 INS40 INS40 INS5 INS40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS37 INS37 INS32 INS32 INS42 INS42 INS60 INS25 INS39 INS85 INS42 INS42 INS42 INS42 INS45 INS40 INS40 INS40 INS42 INS42 INS45 INS32 INS32 INS39 INS59 INS42 INS8 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS21 INS42 INS42 INS14 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 DEL83 DEL27 DEL59 DEL60 DEL42 DEL7 DEL42
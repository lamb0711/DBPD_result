HDFS-13958. Miscellaneous Improvements for FsVolumeSpi. Contributed by BELUGA BEHR.

+import java.util.Collections;
-import java.util.LinkedList;
+import java.util.Objects;
- * 
+ *
- * 
+ *
- * 
- * Note the synchronization is coarse grained - it is at each method. 
+ *
+ * Note the synchronization is coarse grained - it is at each method.
-  
+
-  
+
-  
+
-  
+
-      if (theBlock.getNumBytes() < 0) {
-        theBlock.setNumBytes(0);
+      if (theBlock.getNumBytes() < 0L) {
+        theBlock.setNumBytes(0L);
-    
+
-    
+
-    
+
-            "Finalizing a block that has already been finalized" + 
+            "Finalizing a block that has already been finalized" +
-      // We had allocated the expected length when block was created; 
+      // We had allocated the expected length when block was created;
-      if (extraLen > 0) {
+      if (extraLen > 0L) {
-      theBlock.setNumBytes(finalSize);  
+      theBlock.setNumBytes(finalSize);
-      return new SimulatedInputStream(nullCrcFileData);  
+      return new SimulatedInputStream(nullCrcFileData);
-    synchronized public ReplicaOutputStreams createStreams(boolean isCreate, 
+    synchronized public ReplicaOutputStreams createStreams(boolean isCreate,
-  
+
-    private long used;    // in bytes
+    // in bytes
+    private long used;
-    
+
-    
+
-    
+
-    
+
-      used = 0;   
+      used = 0L;
-  
+
-    
+
-    
+
-    
+
-      long used = 0;
+      long used = 0L;
-    
+
-    
+
-      return false;    
+      return false;
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
-  
+
-    public LinkedList<ScanInfo> compileReport(String bpid,
-        LinkedList<ScanInfo> report, ReportCompiler reportCompiler)
+    public void compileReport(String bpid,
+        Collection<ScanInfo> report, ReportCompiler reportCompiler)
-      return null;
-  
-  
+
-    return new LinkedList<Long>();
+    return Collections.emptyList();
-    long total = 0;
+    long total = 0L;
-    long total = 0;
+    long total = 0L;
-    long total = 0;
+    long total = 0L;
-  
+
-
-    long total = 0;
+    long total = 0L;
-
-    return 0;
+    return 0L;
-    return 0;
+    return 0L;
-    return 0l;
+    return 0L;
-    return 0l;
+    return 0L;
-    return 0l;
+    return 0L;
-    return 0l;
+    return 0L;
-    return 0l;
+    return 0L;
-  @Override 
+  @Override
-    return r == null? "null": r.toString();
+    return Objects.toString(r);
-   * @param b           The block to check.
-   * @param minLength   The minimum length that the block must have.  May be 0.
-   * @param state       If this is null, it is ignored.  If it is non-null, we
-   *                        will check that the replica has this state.
+   * @param b The block to check.
+   * @param minLength The minimum length that the block must have. May be 0.
+   * @param state If this is null, it is ignored. If it is non-null, we will
+   *          check that the replica has this state.
-   * @throws ReplicaNotFoundException          If the replica is not found
+   * @throws ReplicaNotFoundException If the replica is not found
-   * @throws UnexpectedReplicaStateException   If the replica is not in the 
-   *                                             expected state.
+   * @throws UnexpectedReplicaStateException If the replica is not in the
+   *           expected state.
-    
+
-  
+
-      throw new IOException("No such Block " + b );  
+      throw new IOException("No such Block " + b);
-    
-  
+
-      throw new IOException("No such Block " + b );  
+      throw new IOException("No such Block " + b);
-      throw new IOException("Block " + b + 
+      throw new IOException("Block " + b +
-                                              ReplicaOutputStreams stream, 
-                                              int checksumSize)
-                                              throws IOException {
+      ReplicaOutputStreams stream, int checksumSize) throws IOException {
-  /** 
-   * Simulated input and output streams
-   *
+  /**
+   * Simulated input and output streams.
-    
+
-     * An input stream of size l with repeated bytes
+     * An input stream of size l with repeated bytes.
-    
+
-    
+
-    
-    @Override
-    public int read(byte[] b) throws IOException { 
+    @Override
+    public int read(byte[] b) throws IOException {
-  
+
-   *
-    
+
-    
+
-     * 
+     *
-    
+
-    
+
-    
+
-    public void write(byte[] b,
-              int off,
-              int len) throws IOException  {
+    public void write(byte[] b, int off, int len) throws IOException {
-  
+
-
-  
-    // This wraping can be removed in java 6 as it is more flexible in 
+    // This wraping can be removed in java 6 as it is more flexible in
- 
+
-  
+
-      throw new IOException("No such Block " + b );  
+      throw new IOException("No such Block " + b);
-    return new ReplicaRecoveryInfo(binfo.getBlockId(), binfo.getBytesOnDisk(), 
-        binfo.getGenerationStamp(), 
-        binfo.isFinalized()?ReplicaState.FINALIZED : ReplicaState.RBW);
+    return new ReplicaRecoveryInfo(binfo.getBlockId(), binfo.getBytesOnDisk(),
+        binfo.getGenerationStamp(),
+        binfo.isFinalized() ? ReplicaState.FINALIZED : ReplicaState.RBW);
-  
+
-  
+
-  
+
-  
+
-  
+

MOV26 INS26 INS40 UPD40 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 UPD66 INS39 UPD74 INS32 UPD34 UPD34 UPD34 UPD34 UPD34 UPD34 UPD34 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD43 INS42 INS42 UPD34 UPD34 UPD34 UPD34 UPD42 MOV42 MOV42 INS42 UPD66 UPD34 UPD34 UPD34 UPD34 UPD42 UPD34 DEL42 DEL43 DEL42 DEL43 DEL74 DEL33 DEL41 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL42 DEL33 DEL27 DEL45 DEL32 DEL16
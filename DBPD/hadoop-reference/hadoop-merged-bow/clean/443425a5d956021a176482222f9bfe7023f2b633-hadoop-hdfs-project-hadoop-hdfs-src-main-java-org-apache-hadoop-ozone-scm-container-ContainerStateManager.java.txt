HDFS-12522. Ozone: Remove the Priority Queues used in the Container State Manager. Contributed by Anu Engineer.

-/**
+/*
-import com.google.common.annotations.VisibleForTesting;
-import org.apache.commons.lang3.builder.EqualsBuilder;
-import org.apache.commons.lang3.builder.HashCodeBuilder;
-import org.apache.hadoop.ozone.OzoneConfigKeys;
+import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.LifeCycleEvent;
+import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.LifeCycleState;
+import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.ReplicationFactor;
+import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.ReplicationType;
+import org.apache.hadoop.ozone.scm.container.ContainerStates.ContainerID;
+import org.apache.hadoop.ozone.scm.container.ContainerStates.ContainerState;
+import org.apache.hadoop.ozone.scm.container.ContainerStates.ContainerStateMap;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Queue;
-import java.util.Set;
-import java.util.PriorityQueue;
-import java.util.Arrays;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.NavigableSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
-import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.LifeCycleState;
-import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.ReplicationType;
-import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.LifeCycleEvent;
-import org.apache.hadoop.ozone.protocol.proto.OzoneProtos.ReplicationFactor;
-
-import static org.apache.hadoop.ozone.scm.exceptions
-    .SCMException.ResultCodes.FAILED_TO_CHANGE_CONTAINER_STATE;
+import static org.apache.hadoop.ozone.scm.exceptions.SCMException.ResultCodes
+    .FAILED_TO_CHANGE_CONTAINER_STATE;
- * another call to the SCM, this time specifing the containerName and the
+ * another call to the SCM, this time specifying the containerName and the
-  private final long cacheSize;
-  private final long blockSize;
-
-  // A map that maintains the ContainerKey to Containers of that type ordered
-  // by last access time.
-  private final ReadWriteLock lock;
-  private final Queue<ContainerInfo> containerCloseQueue;
-  private Map<ContainerKey, PriorityQueue<ContainerInfo>> containers;
+  private final ConcurrentHashMap<ContainerState, ContainerID> lastUsedMap;
+  private final ContainerStateMap containers;
+  private final AtomicLong containerCount;
+  @SuppressWarnings("unchecked")
-      Mapping containerMapping, final long cacheSize) throws IOException {
-    this.cacheSize = cacheSize;
+      Mapping containerMapping) {
-    this.blockSize = OzoneConsts.MB * configuration.getLong(
-        OzoneConfigKeys.OZONE_SCM_BLOCK_SIZE_IN_MB,
-        OzoneConfigKeys.OZONE_SCM_BLOCK_SIZE_DEFAULT);
-
-    lock = new ReentrantReadWriteLock();
-    containers = new HashMap<>();
+    lastUsedMap = new ConcurrentHashMap<>();
+    containerCount = new AtomicLong(0);
+    containers = new ContainerStateMap();
-    containerCloseQueue = new ConcurrentLinkedQueue<>();
-  /**
-   * Creates containers maps of following types.
-   * <p>
-   * OZONE  of type {Ratis, StandAlone, Chained} for each of these {ALLOCATED,
-   * CREATING, OPEN, CLOSED, DELETING, DELETED}  container states
-   * <p>
-   * CBLOCK of type {Ratis, StandAlone, Chained} for each of these {ALLOCATED,
-   * CREATING, OPEN, CLOSED, DELETING, DELETED}  container states
-   * <p>
-   * Commented out for now: HDFS of type {Ratis, StandAlone, Chained} for each
-   * of these {ALLOCATED, CREATING, OPEN, CLOSED, DELETING, DELETED}  container
-   * states
-   */
-  private void initializeContainerMaps(String owner) {
-    // Called only from Ctor path, hence no lock is held.
-    Preconditions.checkNotNull(containers);
-    for (ReplicationType type : ReplicationType.values()) {
-      for (ReplicationFactor factor : ReplicationFactor.values()) {
-        for (LifeCycleState state : LifeCycleState.values()) {
-          ContainerKey key = new ContainerKey(owner, type, factor, state);
-          PriorityQueue<ContainerInfo> queue = new PriorityQueue<>();
-          containers.put(key, queue);
-        }
-      }
-    }
-  }
-
-  /**
-   * Load containers from the container store into the containerMaps.
-   *
-   * @param containerMapping -- Mapping object containing container store.
-   */
+
+    List<ContainerInfo> containerList;
-      List<String> ownerList = new ArrayList<>();
-      List<ContainerInfo> containerList =
-          containerMapping.listContainer(null, null, Integer.MAX_VALUE);
-      for (ContainerInfo container : containerList) {
-        String owner = container.getOwner();
-        if (ownerList.isEmpty() || !ownerList.contains(owner)) {
-          ownerList.add(owner);
-          initializeContainerMaps(owner);
-        }
-        ContainerKey key =
-            new ContainerKey(owner, container.getPipeline().getType(),
-                container.getPipeline().getFactor(), container.getState());
-        containers.get(key).add(container);
+      containerList = containerMapping.listContainer(null,
+          null, Integer.MAX_VALUE);
+
+      // if there are no container to load, let us return.
+      if (containerList == null || containerList.size() == 0) {
+        LOG.info("No containers to load for this cluster.");
+        return;
-        LOG.info("Could not list the containers", e);
+        LOG.error("Could not list the containers", e);
+      return;
+    }
+
+    try {
+      long maxID = 0;
+      for (ContainerInfo container : containerList) {
+        containers.addContainer(container);
+
+        if (maxID < container.getContainerID()) {
+          maxID = container.getContainerID();
+        }
+
+        containerCount.set(maxID);
+      }
+    } catch (SCMException ex) {
+      LOG.error("Unable to create a container information. ", ex);
+      // Fix me, what is the proper shutdown procedure for SCM ??
+      // System.exit(1) // Should we exit here?
-  List<ContainerInfo> getAllContainers() {
+  public List<ContainerInfo> getAllContainers() {
-    containers.forEach((key, value) -> list.addAll(value));
+
+    //No Locking needed since the return value is an immutable map.
+    containers.getContainerMap().forEach((key, value) -> list.add(value));
-   * @throws IOException
+   * @throws IOException  on Failure.
+        .setContainerID(containerCount.incrementAndGet())
-    lock.writeLock().lock();
-    try {
-      ContainerKey key = new ContainerKey(owner, type, replicationFactor,
-          containerInfo.getState());
-      PriorityQueue<ContainerInfo> queue = containers.get(key);
-      if (queue == null) {
-        initializeContainerMaps(owner);
-        queue = containers.get(key);
-      }
-      queue.add(containerInfo);
-      LOG.trace("New container allocated: {}", containerInfo);
-    } finally {
-      lock.writeLock().unlock();
-    }
+    containers.addContainer(containerInfo);
+    LOG.trace("New container allocated: {}", containerInfo);
-   * @throws SCMException
+   * @throws SCMException  on Failure.
-              "reason: invalid state transition from state: %s upon event: %s.",
+              "reason: invalid state transition from state: %s upon " +
+              "event: %s.",
-    Pipeline pipeline = info.getPipeline();
-
-    ContainerKey oldKey = new ContainerKey(info.getOwner(), pipeline.getType(),
-        pipeline.getFactor(), info.getState());
-
-    ContainerKey newKey = new ContainerKey(info.getOwner(), pipeline.getType(),
-        pipeline.getFactor(), newState);
-    lock.writeLock().lock();
-    try {
-
-      PriorityQueue<ContainerInfo> currentQueue = containers.get(oldKey);
-      // This should never happen, since we have initialized the map and
-      // queues to all possible states. No harm in asserting that info.
-      Preconditions.checkNotNull(currentQueue);
-
-      // TODO : Should we read this container info from the database if this
-      // is missing in the queue?. Right now we just add it into the queue.
-      // We also need a background thread that will remove unused containers
-      // from memory after 24 hours.  This is really a low priority work item
-      // since typical clusters will have less than 10's of millions of open
-      // containers at a given time, which we can easily keep in memory.
-
-      if (currentQueue.contains(info)) {
-        currentQueue.remove(info);
-      }
-
-      PriorityQueue<ContainerInfo> nextQueue = containers.get(newKey);
-      Preconditions.checkNotNull(nextQueue);
-
-      ContainerInfo containerInfo = new ContainerInfo.Builder()
-          .setContainerName(info.getContainerName())
-          .setState(newState)
-          .setPipeline(info.getPipeline())
-          .setAllocatedBytes(info.getAllocatedBytes())
-          .setUsedBytes(info.getUsedBytes())
-          .setNumberOfKeys(info.getNumberOfKeys())
-          .setStateEnterTime(Time.monotonicNow())
-          .setOwner(info.getOwner())
-          .build();
-      Preconditions.checkNotNull(containerInfo);
-      nextQueue.add(containerInfo);
-
-      return containerInfo;
-    } finally {
-      lock.writeLock().unlock();
-    }
+    containers.updateState(info, info.getState(), newState);
+    return containers.getContainerInfo(info);
+   * Update the container State.
+   * @param info - Container Info
+   * @return  ContainerInfo
+   * @throws SCMException - on Error.
+   */
+  public ContainerInfo updateContainerInfo(ContainerInfo info)
+      throws SCMException {
+    containers.updateContainerInfo(info);
+    return containers.getContainerInfo(info);
+  }
+
+
+  /**
-   * @param owner - Owner of the container {OZONE, CBLOCK}
+   * @param owner - Owner of the container - A specific nameservice.
-   * @return ContainerInfo
+   * @return ContainerInfo, null if there is no match found.
-    ContainerKey key = new ContainerKey(owner, type, factor, state);
-    lock.writeLock().lock();
-    try {
-      PriorityQueue<ContainerInfo> queue = containers.get(key);
-      if (queue == null) {
-        initializeContainerMaps(owner);
-        queue = containers.get(key);
-      }
-      if (queue.size() == 0) {
-        // We don't have any Containers of this type.
-        return null;
-      }
-      Iterator<ContainerInfo> iter = queue.iterator();
-      // Two assumptions here.
-      // 1. The Iteration on the heap is in ordered by the last used time.
-      // 2. We remove and add the node back to push the node to the end of
-      // the queue.
-      while (iter.hasNext()) {
-        ContainerInfo info = iter.next();
-        if (info.getAllocatedBytes() + size <= this.containerSize) {
-          queue.remove(info);
-          info.allocate(size);
-          info.updateLastUsedTime();
-          queue.add(info);
+    // Find containers that match the query spec, if no match return null.
+    NavigableSet<ContainerID> matchingSet =
+        containers.getMatchingContainerIDs(state, owner, factor, type);
+    if (matchingSet == null || matchingSet.size() == 0) {
+      return null;
+    }
-          return info;
-        }
+    // Get the last used container and find container above the last used
+    // container ID.
+    ContainerState key = new ContainerState(owner, type, factor);
+    ContainerID lastID = lastUsedMap.get(key);
+    if(lastID == null) {
+      lastID = matchingSet.first();
+    }
+
+    // There is a small issue here. The first time, we will skip the first
+    // container. But in most cases it will not matter.
+    NavigableSet<ContainerID> resultSet = matchingSet.tailSet(lastID, false);
+    if (resultSet.size() == 0) {
+      resultSet = matchingSet;
+    }
+
+    ContainerInfo selectedContainer =
+        findContainerWithSpace(size, resultSet, owner);
+    if (selectedContainer == null) {
+
+      // If we did not find any space in the tailSet, we need to look for
+      // space in the headset, we need to pass true to deal with the
+      // situation that we have a lone container that has space. That is we
+      // ignored the last used container under the assumption we can find
+      // other containers with space, but if have a single container that is
+      // not true. Hence we need to include the last used container as the
+      // last element in the sorted set.
+
+      resultSet = matchingSet.headSet(lastID, true);
+      selectedContainer = findContainerWithSpace(size, resultSet, owner);
+    }
+    // Update the allocated Bytes on this container.
+    if(selectedContainer != null) {
+      selectedContainer.updateAllocatedBytes(size);
+    }
+    return selectedContainer;
+
+  }
+
+  private ContainerInfo findContainerWithSpace(long size,
+      NavigableSet<ContainerID> searchSet, String owner) {
+    // Get the container with space to meet our request.
+    for (ContainerID id : searchSet) {
+      ContainerInfo containerInfo = containers.getContainerInfo(id.getId());
+      if ((containerInfo.getAllocatedBytes() <= this.containerSize) &&
+          (containerInfo.getAllocatedBytes() <=  size)) {
+        containerInfo.updateLastUsedTime();
+
+        ContainerState key = new ContainerState(owner,
+            containerInfo.getPipeline().getType(),
+            containerInfo.getPipeline().getFactor());
+        lastUsedMap.put(key, containerInfo.containerID());
+        return containerInfo;
-
-    } finally {
-      lock.writeLock().unlock();
-  @VisibleForTesting
-  public List<ContainerInfo> getMatchingContainers(String owner,
-      ReplicationType type, ReplicationFactor factor, LifeCycleState state) {
-    ContainerKey key = new ContainerKey(owner, type, factor, state);
-    lock.readLock().lock();
-    try {
-      if (containers.get(key) == null) {
-        return null;
-      } else {
-        return Arrays.asList((ContainerInfo[]) containers.get(key)
-            .toArray(new ContainerInfo[0]));
-      }
-    } catch (Exception e) {
-      LOG.error("Could not get matching containers", e);
-    } finally {
-      lock.readLock().unlock();
-    }
-    return null;
+  /**
+   * Returns a set of ContainerIDs that match the Container.
+   *
+   * @param owner  Owner of the Containers.
+   * @param type - Replication Type of the containers
+   * @param factor - Replication factor of the containers.
+   * @param state - Current State, like Open, Close etc.
+   * @return Set of containers that match the specific query parameters.
+   */
+  public NavigableSet<ContainerID> getMatchingContainerIDs(
+      String owner, ReplicationType type, ReplicationFactor factor,
+      LifeCycleState state) {
+    return containers.getMatchingContainerIDs(state, owner,
+        factor, type);
-    //TODO: update container metadata db with actual allocated bytes values.
-  /**
-   * Class that acts as the container Key.
-   */
-  private static class ContainerKey {
-    private final LifeCycleState state;
-    private final ReplicationType type;
-    private final String owner;
-    private final ReplicationFactor replicationFactor;
-
-    /**
-     * Constructs a Container Key.
-     *
-     * @param owner - Container Owners
-     * @param type - Replication Type.
-     * @param factor - Replication Factors
-     * @param state - LifeCycle State
-     */
-    ContainerKey(String owner, ReplicationType type,
-        ReplicationFactor factor, LifeCycleState state) {
-      this.state = state;
-      this.type = type;
-      this.owner = owner;
-      this.replicationFactor = factor;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (this == o) {
-        return true;
-      }
-
-      if (o == null || getClass() != o.getClass()) {
-        return false;
-      }
-
-      ContainerKey that = (ContainerKey) o;
-
-      return new EqualsBuilder()
-          .append(state, that.state)
-          .append(type, that.type)
-          .append(owner, that.owner)
-          .append(replicationFactor, that.replicationFactor)
-          .isEquals();
-    }
-
-    @Override
-    public int hashCode() {
-      return new HashCodeBuilder(137, 757)
-          .append(state)
-          .append(type)
-          .append(owner)
-          .append(replicationFactor)
-          .toHashCode();
-    }
-
-    @Override
-    public String toString() {
-      return "ContainerKey{" +
-          "state=" + state +
-          ", type=" + type +
-          ", owner=" + owner +
-          ", replicationFactor=" + replicationFactor +
-          '}';
-    }
-  }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 INS23 INS31 INS31 INS31 INS31 MOV83 MOV83 INS74 MOV59 INS43 MOV59 INS83 INS43 INS59 INS79 MOV21 UPD42 MOV44 INS83 MOV29 UPD83 MOV83 MOV43 UPD42 MOV42 INS44 INS43 INS8 MOV29 INS83 MOV43 INS42 MOV44 MOV44 MOV44 MOV44 MOV44 INS8 UPD83 MOV83 MOV43 INS42 INS44 INS44 MOV44 INS8 MOV29 MOV83 INS74 INS42 MOV44 MOV44 MOV44 MOV44 MOV8 UPD66 INS43 INS43 INS43 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS45 MOV60 INS54 INS54 MOV21 MOV21 INS21 INS41 INS65 INS65 INS43 INS42 UPD42 MOV42 MOV21 INS41 INS60 INS25 MOV60 MOV60 MOV25 MOV60 INS25 MOV60 MOV25 INS25 INS41 INS39 INS42 INS74 INS42 INS70 MOV41 INS65 INS43 INS43 INS42 INS42 UPD42 MOV42 INS8 MOV12 INS8 INS12 INS66 INS66 INS32 INS32 UPD66 UPD42 UPD66 INS66 INS42 INS66 UPD42 MOV42 INS32 UPD66 UPD66 INS74 INS59 INS27 MOV8 UPD43 INS43 UPD74 INS27 INS8 UPD27 INS27 INS8 INS42 UPD43 MOV43 UPD43 MOV43 INS44 INS42 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV21 INS25 INS60 INS70 INS44 INS8 INS32 INS32 UPD42 UPD42 INS42 UPD42 MOV42 MOV42 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS43 INS42 INS32 INS27 INS27 UPD42 UPD42 MOV42 UPD42 UPD42 UPD43 UPD43 UPD42 INS32 INS34 INS21 UPD42 UPD42 MOV42 INS33 INS21 INS42 INS33 MOV21 UPD42 UPD42 INS43 INS42 INS60 INS25 INS42 UPD42 MOV42 MOV42 MOV42 UPD42 MOV42 UPD42 INS74 INS43 INS34 INS43 INS7 INS27 INS8 INS41 INS39 INS59 MOV44 INS42 INS8 INS43 INS42 MOV21 MOV42 INS42 MOV32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS33 INS32 INS34 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS9 UPD42 MOV42 UPD42 MOV42 INS7 UPD42 INS42 UPD42 INS42 INS7 INS7 UPD42 MOV42 MOV43 MOV59 INS27 INS8 INS43 UPD42 MOV42 UPD42 MOV42 INS42 MOV32 INS27 INS27 INS21 INS41 INS42 INS34 INS21 INS25 INS21 UPD42 MOV42 UPD42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS42 INS32 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS32 INS36 INS36 INS21 INS60 INS21 MOV41 UPD42 MOV42 INS42 INS33 INS32 INS34 INS32 INS32 INS27 INS8 INS32 UPD42 UPD42 INS45 UPD42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS9 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS27 INS27 INS32 INS43 INS59 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS45 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS32 MOV22 INS32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS14 INS42 INS42 INS42 INS32 UPD42 INS42 INS42 INS7 UPD45 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS42 INS32 INS32 INS42 INS42 INS42 INS32 UPD42 MOV42 INS32 UPD42 MOV42 MOV32 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL43 DEL23 DEL42 DEL43 DEL43 DEL74 DEL42 DEL59 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL83 DEL39 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL42 DEL42 DEL40 DEL40 DEL32 DEL27 DEL7 DEL21 DEL43 DEL43 DEL74 DEL43 DEL74 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL8 DEL70 DEL8 DEL70 DEL8 DEL70 DEL39 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL38 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL54 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL40 DEL43 DEL14 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL27 DEL32 DEL42 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL42 DEL43 DEL34 DEL34 DEL14 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL83 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL34 DEL27 DEL25 DEL32 DEL8 DEL61 DEL8 DEL8 DEL54 DEL8 DEL31 DEL42 DEL78 DEL74 DEL42 DEL43 DEL60 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL33 DEL27 DEL33 DEL41 DEL8 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL85 DEL5 DEL34 DEL3 DEL32 DEL11 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL32 DEL21 DEL8 DEL12 DEL32 DEL21 DEL8 DEL54 DEL33 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL78 DEL39 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL27 DEL9 DEL41 DEL8 DEL25 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL14 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL45 DEL45 DEL27 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL13 DEL27 DEL41 DEL8 DEL31 DEL55
HDFS-6097. Zero-copy reads are incorrectly disabled on file offsets above 2GB (cmccabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1577350 13f79535-47bb-0310-9956-ffa450edef68

-    // Java ByteBuffers can't be longer than 2 GB, because they use
-    // 4-byte signed integers to represent capacity, etc.
-    // So we can't mmap the parts of the block higher than the 2 GB offset.
-    // FIXME: we could work around this with multiple memory maps.
-    // See HDFS-5101.
-    long blockEnd32 = Math.min(Integer.MAX_VALUE, blockEnd);
-    long curPos = pos;
-    long blockLeft = blockEnd32 - curPos + 1;
-    if (blockLeft <= 0) {
-      if (DFSClient.LOG.isDebugEnabled()) {
-        DFSClient.LOG.debug("unable to perform a zero-copy read from offset " +
-          curPos + " of " + src + "; blockLeft = " + blockLeft +
-          "; blockEnd32 = " + blockEnd32 + ", blockEnd = " + blockEnd +
-          "; maxLength = " + maxLength);
+    // Copy 'pos' and 'blockEnd' to local variables to make it easier for the
+    // JVM to optimize this function.
+    final long curPos = pos;
+    final long curEnd = blockEnd;
+    final long blockStartInFile = currentLocatedBlock.getStartOffset();
+    final long blockPos = curPos - blockStartInFile;
+
+    // Shorten this read if the end of the block is nearby.
+    long length63;
+    if ((curPos + maxLength) <= (curEnd + 1)) {
+      length63 = maxLength;
+    } else {
+      length63 = 1 + curEnd - curPos;
+      if (length63 <= 0) {
+        if (DFSClient.LOG.isDebugEnabled()) {
+          DFSClient.LOG.debug("Unable to perform a zero-copy read from offset " +
+            curPos + " of " + src + "; " + length63 + " bytes left in block.  " +
+            "blockPos=" + blockPos + "; curPos=" + curPos +
+            "; curEnd=" + curEnd);
+        }
+        return null;
-      return null;
+      if (DFSClient.LOG.isDebugEnabled()) {
+        DFSClient.LOG.debug("Reducing read length from " + maxLength +
+            " to " + length63 + " to avoid going more than one byte " +
+            "past the end of the block.  blockPos=" + blockPos +
+            "; curPos=" + curPos + "; curEnd=" + curEnd);
+      }
-    int length = Math.min((int)blockLeft, maxLength);
-    long blockStartInFile = currentLocatedBlock.getStartOffset();
-    long blockPos = curPos - blockStartInFile;
-    long limit = blockPos + length;
-    ClientMmap clientMmap = blockReader.getClientMmap(opts);
+    // Make sure that don't go beyond 31-bit offsets in the MappedByteBuffer.
+    int length;
+    if (blockPos + length63 <= Integer.MAX_VALUE) {
+      length = (int)length63;
+    } else {
+      long length31 = Integer.MAX_VALUE - blockPos;
+      if (length31 <= 0) {
+        // Java ByteBuffers can't be longer than 2 GB, because they use
+        // 4-byte signed integers to represent capacity, etc.
+        // So we can't mmap the parts of the block higher than the 2 GB offset.
+        // FIXME: we could work around this with multiple memory maps.
+        // See HDFS-5101.
+        if (DFSClient.LOG.isDebugEnabled()) {
+          DFSClient.LOG.debug("Unable to perform a zero-copy read from offset " +
+            curPos + " of " + src + "; 31-bit MappedByteBuffer limit " +
+            "exceeded.  blockPos=" + blockPos + ", curEnd=" + curEnd);
+        }
+        return null;
+      }
+      length = (int)length31;
+      if (DFSClient.LOG.isDebugEnabled()) {
+        DFSClient.LOG.debug("Reducing read length from " + maxLength +
+            " to " + length + " to avoid 31-bit limit.  " +
+            "blockPos=" + blockPos + "; curPos=" + curPos +
+            "; curEnd=" + curEnd);
+      }
+    }
+    final ClientMmap clientMmap = blockReader.getClientMmap(opts);
-      seek(pos + length);
+      seek(curPos + length);
-      buffer.limit((int)limit);
+      buffer.limit((int)(blockPos + length));
-        DFSClient.LOG.debug("readZeroCopy read " + maxLength + " bytes from " +
-            "offset " + curPos + " via the zero-copy read path.  " +
-            "blockEnd = " + blockEnd);
+        DFSClient.LOG.debug("readZeroCopy read " + length + 
+            " bytes from offset " + curPos + " via the zero-copy read " +
+            "path.  blockEnd = " + blockEnd);

MOV60 INS60 INS25 INS60 INS25 INS83 INS83 INS83 INS83 MOV39 INS59 INS27 INS8 INS8 MOV39 INS59 INS27 INS8 INS8 INS83 UPD42 INS42 UPD42 MOV42 INS36 INS36 INS21 INS21 MOV25 INS25 MOV42 INS27 INS40 INS21 MOV60 INS25 INS21 INS25 INS27 INS27 INS7 INS7 INS32 INS8 INS42 INS42 INS7 INS27 INS8 INS7 MOV32 INS8 INS32 MOV42 INS42 INS42 MOV34 INS42 INS42 INS42 INS27 UPD42 INS40 INS42 INS21 INS42 INS11 UPD42 INS27 INS42 INS34 INS25 INS41 INS42 INS11 INS21 INS40 INS42 INS27 INS42 INS32 MOV39 UPD42 MOV42 INS40 INS42 INS32 INS8 INS33 INS39 INS42 INS32 UPD42 INS36 INS34 INS42 INS40 INS42 INS27 INS40 INS42 INS21 INS40 INS42 INS27 MOV27 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS42 INS32 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS42 UPD42 UPD45 UPD45 UPD45 INS40 INS42 INS27 UPD45 UPD45 UPD42 INS45 UPD45 UPD42 UPD45 UPD42 UPD45 UPD42 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL27 DEL27 DEL59 DEL60 DEL42 DEL42 DEL11 DEL42 DEL32 DEL59 DEL60 DEL42 DEL45
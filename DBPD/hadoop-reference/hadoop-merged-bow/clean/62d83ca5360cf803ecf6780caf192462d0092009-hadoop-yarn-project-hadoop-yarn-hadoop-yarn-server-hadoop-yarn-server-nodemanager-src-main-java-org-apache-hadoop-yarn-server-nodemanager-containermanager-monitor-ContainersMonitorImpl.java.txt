YARN-8461. Support strict memory control on individual container with elastic control memory mechanism. Contributed by Haibo Chen.

+import org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources.MemoryResourceHandler;
+import java.util.Optional;
-      if (elasticMemoryEnforcement || strictMemoryEnforcement) {
-        // We enforce the overall memory usage instead of individual containers
-        return;
-      }
-      boolean isMemoryOverLimit = false;
-      long vmemLimit = ptInfo.getVmemLimit();
-      long pmemLimit = ptInfo.getPmemLimit();
-      // as processes begin with an age 1, we want to see if there
-      // are processes more than 1 iteration old.
-      long curMemUsageOfAgedProcesses = pTree.getVirtualMemorySize(1);
-      long curRssMemUsageOfAgedProcesses = pTree.getRssMemorySize(1);
+      Optional<Boolean> isMemoryOverLimit = Optional.empty();
-      if (isVmemCheckEnabled()
-              && isProcessTreeOverLimit(containerId.toString(),
-              currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {
-        // The current usage (age=0) is always higher than the aged usage. We
-        // do not show the aged size in the message, base the delta on the
-        // current usage
-        long delta = currentVmemUsage - vmemLimit;
-        // Container (the root process) is still alive and overflowing
-        // memory.
-        // Dump the process-tree and then clean it up.
-        msg = formatErrorMessage("virtual",
-                formatUsageString(currentVmemUsage, vmemLimit,
-                  currentPmemUsage, pmemLimit),
-                pId, containerId, pTree, delta);
-        isMemoryOverLimit = true;
-        containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_VMEM;
-      } else if (isPmemCheckEnabled()
-              && isProcessTreeOverLimit(containerId.toString(),
-              currentPmemUsage, curRssMemUsageOfAgedProcesses,
-              pmemLimit)) {
-        // The current usage (age=0) is always higher than the aged usage. We
-        // do not show the aged size in the message, base the delta on the
-        // current usage
-        long delta = currentPmemUsage - pmemLimit;
-        // Container (the root process) is still alive and overflowing
-        // memory.
-        // Dump the process-tree and then clean it up.
-        msg = formatErrorMessage("physical",
-                formatUsageString(currentVmemUsage, vmemLimit,
-                  currentPmemUsage, pmemLimit),
-                pId, containerId, pTree, delta);
-        isMemoryOverLimit = true;
-        containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_PMEM;
+
+      if (strictMemoryEnforcement && elasticMemoryEnforcement) {
+        // Both elastic memory control and strict memory control are enabled
+        // through cgroups. A container will be frozen by the elastic memory
+        // control mechanism if it exceeds its request, so we check for this
+        // here and kill it. Otherwise, the container will not be killed if
+        // the node never exceeds its limit and the procfs-based
+        // memory accounting is different from the cgroup-based accounting.
+
+        MemoryResourceHandler handler =
+            ResourceHandlerModule.getMemoryResourceHandler();
+        if (handler != null) {
+          isMemoryOverLimit = handler.isUnderOOM(containerId);
+          containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_PMEM;
+          msg = containerId + " is under oom because it exceeded its" +
+              " physical memory limit";
+        }
+      } else if (strictMemoryEnforcement || elasticMemoryEnforcement) {
+        // if cgroup-based memory control is enabled
+        isMemoryOverLimit = Optional.of(false);
-      if (isMemoryOverLimit) {
+      if (!isMemoryOverLimit.isPresent()) {
+        long vmemLimit = ptInfo.getVmemLimit();
+        long pmemLimit = ptInfo.getPmemLimit();
+        // as processes begin with an age 1, we want to see if there
+        // are processes more than 1 iteration old.
+        long curMemUsageOfAgedProcesses = pTree.getVirtualMemorySize(1);
+        long curRssMemUsageOfAgedProcesses = pTree.getRssMemorySize(1);
+        if (isVmemCheckEnabled()
+            && isProcessTreeOverLimit(containerId.toString(),
+            currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {
+          // The current usage (age=0) is always higher than the aged usage. We
+          // do not show the aged size in the message, base the delta on the
+          // current usage
+          long delta = currentVmemUsage - vmemLimit;
+          // Container (the root process) is still alive and overflowing
+          // memory.
+          // Dump the process-tree and then clean it up.
+          msg = formatErrorMessage("virtual",
+              formatUsageString(currentVmemUsage, vmemLimit,
+                  currentPmemUsage, pmemLimit),
+              pId, containerId, pTree, delta);
+          isMemoryOverLimit = Optional.of(true);
+          containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_VMEM;
+        } else if (isPmemCheckEnabled()
+            && isProcessTreeOverLimit(containerId.toString(),
+            currentPmemUsage, curRssMemUsageOfAgedProcesses,
+            pmemLimit)) {
+          // The current usage (age=0) is always higher than the aged usage. We
+          // do not show the aged size in the message, base the delta on the
+          // current usage
+          long delta = currentPmemUsage - pmemLimit;
+          // Container (the root process) is still alive and overflowing
+          // memory.
+          // Dump the process-tree and then clean it up.
+          msg = formatErrorMessage("physical",
+              formatUsageString(currentVmemUsage, vmemLimit,
+                  currentPmemUsage, pmemLimit),
+              pId, containerId, pTree, delta);
+          isMemoryOverLimit = Optional.of(true);
+          containerExitStatus = ContainerExitStatus.KILLED_EXCEEDED_PMEM;
+        }
+      }
+
+      if (isMemoryOverLimit.isPresent() && isMemoryOverLimit.get()) {

INS26 INS26 INS40 INS40 INS60 INS25 INS25 INS74 INS59 INS27 INS8 INS25 INS38 INS8 INS27 INS43 INS43 INS42 INS32 INS42 INS42 INS60 INS25 MOV27 MOV8 INS32 MOV60 MOV60 MOV60 MOV60 MOV25 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 UPD42 UPD42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS21 INS7 INS42 INS42 INS7 INS7 INS7 INS42 INS32 INS42 INS32 INS42 INS40 INS42 INS27 INS42 INS42 INS9 INS32 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS9 INS32 INS42 INS42 INS9 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL41 DEL9 DEL9 DEL42
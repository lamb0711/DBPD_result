HDFS-12273. Federation UI. Contributed by Inigo Goiri.

(cherry picked from commit adbb2e00c7b85524fd43bd68895d49814c16680a)

+import java.util.concurrent.CancellationException;
+import java.util.concurrent.TimeUnit;
+   * @param <T> The type of the remote location.
-  @SuppressWarnings("unchecked")
+    return invokeConcurrent(locations, method, requireResponse, standby, -1);
+  }
+
+  /**
+   * Invokes multiple concurrent proxy calls to different clients. Returns an
+   * array of results.
+   *
+   * Re-throws exceptions generated by the remote RPC call as either
+   * RemoteException or IOException.
+   *
+   * @param locations List of remote locations to call concurrently.
+   * @param remoteMethod The remote method and parameters to invoke.
+   * @param requireResponse If true an exception will be thrown if all calls do
+   *          not complete. If false exceptions are ignored and all data results
+   *          successfully received are returned.
+   * @param standby If the requests should go to the standby namenodes too.
+   * @param timeoutMs Timeout for each individual call.
+   * @return Result of invoking the method per subcluster: nsId -> result.
+   * @throws IOException If requiredResponse=true and any of the calls throw an
+   *           exception.
+   */
+  @SuppressWarnings("unchecked")
+  public <T extends RemoteLocationContext> Map<T, Object> invokeConcurrent(
+      final Collection<T> locations, final RemoteMethod method,
+      boolean requireResponse, boolean standby, long timeOutMs)
+          throws IOException {
-      List<Future<Object>> futures = executorService.invokeAll(callables);
+      List<Future<Object>> futures = null;
+      if (timeOutMs > 0) {
+        futures = executorService.invokeAll(
+            callables, timeOutMs, TimeUnit.MILLISECONDS);
+      } else {
+        futures = executorService.invokeAll(callables);
+      }
+        } catch (CancellationException ce) {
+          T loc = orderedLocations.get(i);
+          String msg =
+              "Invocation to \"" + loc + "\" for \"" + method + "\" timed out";
+          LOG.error(msg);
+          IOException ioe = new IOException(msg);
+          exceptions.put(location, ioe);

INS26 INS26 INS40 INS40 INS31 INS29 INS83 INS73 INS74 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS44 MOV65 INS65 INS65 INS65 INS65 INS65 MOV65 MOV65 INS42 INS43 INS43 INS43 INS43 INS83 INS74 INS42 INS83 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS39 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS25 INS34 INS27 INS8 INS8 INS33 INS42 INS34 INS21 INS21 INS7 INS7 INS12 INS42 INS32 INS42 MOV32 INS44 INS8 INS42 INS42 INS42 INS42 INS40 INS43 INS42 INS60 INS60 INS21 INS60 INS21 INS42 INS43 INS59 INS43 INS59 INS32 INS43 INS59 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS43 INS42 INS42
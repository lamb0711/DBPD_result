HDFS-8674. Improve performance of postponed block scans. Contributed by Daryn Sharp.

+import java.util.LinkedHashSet;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.apache.hadoop.hdfs.util.LightWeightHashSet;
-  private final AtomicLong postponedMisreplicatedBlocksCount = new AtomicLong(0L);
-    return postponedMisreplicatedBlocksCount.get();
+    return postponedMisreplicatedBlocks.size();
-  private final LightWeightHashSet<Block> postponedMisreplicatedBlocks =
-      new LightWeightHashSet<>();
+  private final Set<Block> postponedMisreplicatedBlocks =
+      new LinkedHashSet<Block>();
+  private final int blocksPerPostpondedRescan;
+  private final ArrayList<Block> rescannedMisreplicatedBlocks;
-
+    blocksPerPostpondedRescan = (int)Math.min(Integer.MAX_VALUE,
+        datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan());
+    rescannedMisreplicatedBlocks =
+        new ArrayList<Block>(blocksPerPostpondedRescan);
-    if (postponedMisreplicatedBlocks.add(blk)) {
-      postponedMisreplicatedBlocksCount.incrementAndGet();
-    }
+    postponedMisreplicatedBlocks.add(blk);
-    long startTimeRescanPostponedMisReplicatedBlocks = Time.monotonicNow();
-    long startPostponedMisReplicatedBlocksCount =
-        getPostponedMisreplicatedBlocksCount();
+    long startTime = Time.monotonicNow();
+    long startSize = postponedMisreplicatedBlocks.size();
-      // blocksPerRescan is the configured number of blocks per rescan.
-      // Randomly select blocksPerRescan consecutive blocks from the HashSet
-      // when the number of blocks remaining is larger than blocksPerRescan.
-      // The reason we don't always pick the first blocksPerRescan blocks is to
-      // handle the case if for some reason some datanodes remain in
-      // content stale state for a long time and only impact the first
-      // blocksPerRescan blocks.
-      int i = 0;
-      long startIndex = 0;
-      long blocksPerRescan =
-          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();
-      long base = getPostponedMisreplicatedBlocksCount() - blocksPerRescan;
-      if (base > 0) {
-        startIndex = ThreadLocalRandom.current().nextLong() % (base+1);
-        if (startIndex < 0) {
-          startIndex += (base+1);
-        }
-      }
-      for (int tmp = 0; tmp < startIndex; tmp++) {
-        it.next();
-      }
-
-      for (;it.hasNext(); i++) {
+      for (int i=0; i < blocksPerPostpondedRescan && it.hasNext(); i++) {
-        if (i >= blocksPerRescan) {
-          break;
-        }
+        it.remove();
-          it.remove();
-          postponedMisreplicatedBlocksCount.decrementAndGet();
-        if (res != MisReplicationResult.POSTPONE) {
-          it.remove();
-          postponedMisreplicatedBlocksCount.decrementAndGet();
+        if (res == MisReplicationResult.POSTPONE) {
+          rescannedMisreplicatedBlocks.add(b);
-      long endPostponedMisReplicatedBlocksCount =
-          getPostponedMisreplicatedBlocksCount();
+      postponedMisreplicatedBlocks.addAll(rescannedMisreplicatedBlocks);
+      rescannedMisreplicatedBlocks.clear();
+      long endSize = postponedMisreplicatedBlocks.size();
-          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +
-          " msecs. " + endPostponedMisReplicatedBlocksCount +
-          " blocks are left. " + (startPostponedMisReplicatedBlocksCount -
-          endPostponedMisReplicatedBlocksCount) + " blocks are removed.");
+          (Time.monotonicNow() - startTime) + " msecs. " +
+          endSize + " blocks are left. " +
+          (startSize - endSize) + " blocks were removed.");
-    if (postponedMisreplicatedBlocks.remove(block)) {
-      postponedMisreplicatedBlocksCount.decrementAndGet();
-    }
+    postponedMisreplicatedBlocks.remove(block);
-    postponedMisreplicatedBlocksCount.set(0);

MOV26 UPD40 INS23 INS23 INS74 INS83 INS83 INS39 INS59 INS83 INS83 INS74 INS59 MOV60 INS43 INS43 INS42 INS43 INS43 INS42 INS21 INS21 MOV21 MOV21 INS42 INS42 UPD74 MOV74 INS42 INS42 INS7 INS7 MOV32 MOV32 UPD42 UPD42 UPD43 INS42 INS11 INS42 INS14 UPD42 UPD42 INS21 INS21 UPD42 INS39 INS32 INS74 INS42 UPD42 INS42 INS58 INS27 INS32 INS32 INS42 INS42 INS40 MOV32 INS43 INS43 INS39 MOV59 INS27 MOV32 MOV21 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD27 UPD42 INS42 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL34 DEL14 DEL59 DEL23 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL8 DEL25 DEL39 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL42 DEL32 DEL42 DEL27 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL34 DEL27 DEL36 DEL27 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL42 DEL34 DEL27 DEL36 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL27 DEL10 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL34 DEL32 DEL21
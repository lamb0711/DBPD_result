HDFS-4686. Update quota computation for rename and INodeReference.  Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1471647 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.INodeReference.WithCount;
-        if (INodeReference.tryRemoveReference(d) <= 0) {
-          d.computeQuotaUsage(counts, false);
-          d.destroyAndCollectBlocks(collectedBlocks, removedINodes);
-        } else {
-          refNodes.add(d.asReference());
+        d.computeQuotaUsage(counts, false);
+        d.destroyAndCollectBlocks(collectedBlocks, removedINodes);
+        if (d.isReference()) {
+          INodeReference.WithCount wc = 
+              (INodeReference.WithCount) d.asReference().getReferredINode();
+          if (wc.getReferenceCount() > 0) {
+            refNodes.add(d.asReference());
+          }
-            if (INodeReference.tryRemoveReference(inode) <= 0) {
-              inode.computeQuotaUsage(counts, false);
-              inode.destroyAndCollectBlocks(collectedBlocks, removedINodes);
-            } else {
-              // if the node is a reference node, we should continue the 
-              // snapshot deletion process
-              try {
-                // use null as prior here because we are handling a reference
-                // node stored in the created list of a snapshot diff. This 
-                // snapshot diff must be associated with the latest snapshot of
-                // the dst tree before the rename operation. In this scenario,
-                // the prior snapshot should be the one created in the src tree,
-                // and it can be identified by the cleanSubtree since we call
-                // recordModification before the rename.
-                counts.add(inode.cleanSubtree(posterior.snapshot, null,
-                    collectedBlocks, removedINodes));
-              } catch (QuotaExceededException e) {
-                String error = "should not have QuotaExceededException while deleting snapshot";
-                LOG.error(error, e);
+            inode.computeQuotaUsage(counts, false);
+            inode.destroyAndCollectBlocks(collectedBlocks, removedINodes);
+
+            boolean handleRef = false;
+            if (inode.isReference()) {
+              INodeReference.WithCount wc = (INodeReference.WithCount) inode
+                  .asReference().getReferredINode();
+              if (wc.getReferenceCount() > 0) {
+                handleRef = true;
+              }
+            }
+
+            if (handleRef) {
+              final Snapshot postSnapshot = posterior.snapshot;
+              if (inode instanceof INodeReference.DstReference) {
+                // we are handling a reference node and its subtree stored in
+                // the created list of a snapshot diff, which must be associated
+                // with the latest snapshot of the dst tree before the rename 
+                // operation.
+                destroyDstSnapshot(inode, postSnapshot, null, collectedBlocks,
+                    removedINodes);
+              } else if (inode instanceof INodeReference.WithName) {
+                // the inode should be renamed again. We only need to delete
+                // postSnapshot in its subtree.
+                try {
+                  inode.cleanSubtree(postSnapshot, null, collectedBlocks,
+                      removedINodes);
+                } catch (QuotaExceededException e) {
+                  LOG.error("Error: should not throw QuotaExceededException", e);
+                }
+    
+    /**
+     * For a reference node, delete its first snapshot associated with the dst
+     * tree of a rename operation, i.e., the snapshot diff is associated with
+     * the latest snapshot of the dst tree before the rename operation. The
+     * difference between this process and a regular snapshot deletion
+     * process is that we need to delete everything created after the rename,
+     * i.e., we should destroy the whole created list of the referred node.
+     */
+    private Quota.Counts destroyDstSnapshot(INode inode, final Snapshot snapshot, 
+        Snapshot prior, final BlocksMapUpdateInfo collectedBlocks,
+        final List<INode> removedINodes) {
+      Quota.Counts counts = Quota.Counts.newInstance();
+      try {
+        if (inode.isReference()) {
+          INodeReference referenceNode = inode.asReference(); 
+          INodeReference.WithCount wc = 
+              (WithCount) referenceNode.getReferredINode();
+          INode referred = wc.getReferredINode();
+          Quota.Counts subCounts = destroyDstSnapshot(referred, snapshot,
+              prior, collectedBlocks, removedINodes);
+          if (inode instanceof INodeReference.WithName) {
+            INodeReference ref = wc.getParentReference();
+            if (ref != null) {
+              ref.addSpaceConsumed(-subCounts.get(Quota.NAMESPACE),
+                  -subCounts.get(Quota.DISKSPACE), true, Snapshot.INVALID_ID);
+            }
+          } else if (inode instanceof INodeReference.DstReference) {
+            wc.addSpaceConsumedToRenameSrc(-counts.get(Quota.NAMESPACE),
+                -counts.get(Quota.DISKSPACE), true, snapshot.getId());
+          }
+        } else if (inode.isFile()) { // file and not reference
+          counts.add(inode.cleanSubtree(snapshot, null, collectedBlocks,
+              removedINodes));
+        } else if (inode.isDirectory()) { // directory and not reference
+          if (inode.asDirectory() instanceof INodeDirectoryWithSnapshot) {
+            INodeDirectoryWithSnapshot dirNode = 
+                (INodeDirectoryWithSnapshot) inode.asDirectory();
+            DirectoryDiffList diffList = dirNode.getDiffs();
+            prior = diffList.updatePrior(snapshot, prior);
+            counts.add(diffList.deleteSnapshotDiff(snapshot, prior, dirNode, 
+                collectedBlocks, removedINodes));
+            if (prior != null) {
+              DirectoryDiff priorDiff = diffList.getDiff(prior);
+              if (priorDiff != null) {
+                // destroy everything in the created list!
+                counts.add(priorDiff.diff.destroyCreatedList(dirNode,
+                    collectedBlocks, removedINodes));
+                for (INode dNode : priorDiff.getChildrenDiff().getList(
+                    ListType.DELETED)) {
+                  counts.add(cleanDeletedINode(dNode, snapshot, prior,
+                      collectedBlocks, removedINodes));
+                }
+              }
+            }
+          }
+          Snapshot s = snapshot != null && prior != null ? prior : snapshot;
+          for (INode child : inode.asDirectory().getChildrenList(s)) {
+            counts.add(destroyDstSnapshot(child, s, prior, collectedBlocks,
+                removedINodes));
+          }
+        }
+      } catch (QuotaExceededException e) {
+        String error = "should not have QuotaExceededException while deleting snapshot";
+        LOG.error(error, e);
+      }
+      return counts;
+    }
-        try {
-          // Use null as prior snapshot. We are handling a reference node stored
-          // in the delete list of this snapshot diff. We need to destroy this 
-          // snapshot diff because it is the very first one in history.
-          // If the ref node is a WithName instance acting as the src node of
-          // the rename operation, there will not be any snapshot before the
-          // snapshot to be deleted. If the ref node presents the dst node of a 
-          // rename operation, we can identify the corresponding prior snapshot 
-          // when we come into the subtree of the ref node.
-          counts.add(ref.cleanSubtree(this.snapshot, null, collectedBlocks,
-              removedINodes));
-        } catch (QuotaExceededException e) {
-          String error = 
-              "should not have QuotaExceededException while deleting snapshot " 
-              + this.snapshot;
-          LOG.error(error, e);
+        if (ref instanceof INodeReference.DstReference) {
+          // if ref is a DstReference instance, we should delete all the files
+          // created after the rename
+          destroyDstSnapshot(ref, snapshot, null, collectedBlocks,
+              removedINodes);
+        } else if (ref instanceof INodeReference.WithName) {
+          // ref should have been renamed again. We only need to delete
+          // the snapshot in its subtree.
+          try {
+            ref.cleanSubtree(snapshot, null, collectedBlocks, removedINodes);
+          } catch (QuotaExceededException e) {
+            LOG.error("Error: should not throw QuotaExceededException", e);
+          }
-          counts.get(Quota.DISKSPACE), false);
+          counts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);
-  private Quota.Counts cleanDeletedINode(INode inode, Snapshot post,
+  private static Quota.Counts cleanDeletedINode(INode inode, Snapshot post,
-      final List<INode> removedINodes) {
+      final List<INode> removedINodes) throws QuotaExceededException {
-      if (topNode instanceof FileWithSnapshot) {
-        FileWithSnapshot fs = (FileWithSnapshot) topNode;
+      if (topNode.isFile() && topNode.asFile() instanceof FileWithSnapshot) {
+        FileWithSnapshot fs = (FileWithSnapshot) topNode.asFile();
+  public final Quota.Counts computeQuotaUsage(Quota.Counts counts,
+      boolean useCache, int lastSnapshotId) {
+    if ((useCache && isQuotaSet()) || lastSnapshotId == Snapshot.INVALID_ID) {
+      return super.computeQuotaUsage(counts, useCache, lastSnapshotId);
+    }
+    
+    final int diffNum = 0;
+    Snapshot lastSnapshot = null;
+    Snapshot lastInDiff = diffs.getLastSnapshot();
+    // if lastSnapshotId > lastInDiff.getId(), the snapshot diff associated with
+    // lastSnapshotId must have been deleted. We should call 
+    // getChildrenList(null) to get the children list for the continuous 
+    // computation. In the meanwhile, there must be some snapshot diff whose
+    // snapshot id is no less than lastSnapshotId. Otherwise the WithName node
+    // itself should have been deleted.
+    if (lastInDiff != null && lastInDiff.getId() >= lastSnapshotId) {
+      lastSnapshot = diffs.searchSnapshotById(lastSnapshotId);
+    }
+    
+    ReadOnlyList<INode> childrenList = getChildrenList(lastSnapshot);
+    for (INode child : childrenList) {
+      child.computeQuotaUsage(counts, useCache, lastSnapshotId);
+    }
+    
+    counts.add(Quota.NAMESPACE, diffNum + 1);
+    return counts;
+  }
+  
+  @Override
-
-        deleted.computeQuotaUsage(counts, false);
+        deleted.computeQuotaUsage(counts, false, Snapshot.INVALID_ID);

INS26 INS40 INS31 INS31 INS83 INS43 INS78 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS42 INS42 INS40 INS43 INS42 INS39 INS42 INS39 INS42 INS25 INS60 INS60 INS60 INS25 INS60 INS70 INS21 INS41 INS65 INS40 INS43 INS42 INS83 INS43 INS42 INS43 INS42 INS83 INS43 INS42 INS83 INS74 INS42 INS60 INS54 INS41 INS40 INS27 INS8 INS83 INS39 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS74 INS59 INS44 INS42 INS8 INS32 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS59 INS8 MOV12 INS42 INS8 INS36 INS27 INS41 INS42 INS34 INS42 INS42 INS33 INS42 INS42 INS32 INS27 INS27 INS21 INS43 INS43 INS42 INS32 INS43 INS42 INS21 INS42 INS42 INS40 INS27 MOV21 MOV21 INS42 INS42 INS40 INS42 INS32 INS25 INS25 INS27 INS27 INS42 INS40 INS48 INS42 INS42 INS42 INS33 INS32 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS32 INS8 INS40 INS42 INS32 INS8 INS25 INS62 INS8 INS25 INS40 INS32 MOV62 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS60 INS25 INS42 INS42 INS60 INS60 INS60 INS60 INS25 INS32 INS8 INS25 INS42 INS43 INS21 INS62 INS8 INS42 INS42 INS32 MOV43 INS42 INS42 INS42 INS42 INS43 INS59 INS27 MOV8 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS62 INS8 INS25 INS42 INS42 INS21 INS32 INS8 INS40 INS32 INS42 INS43 MOV54 INS42 INS42 INS40 INS40 INS42 INS11 INS32 MOV34 INS42 INS42 INS32 INS40 INS42 INS11 INS42 INS42 INS32 INS40 INS42 INS32 INS42 INS43 INS60 INS25 INS62 INS8 INS32 INS42 INS42 INS25 INS60 INS70 INS42 INS42 INS42 INS33 INS42 INS42 INS40 MOV43 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS43 INS59 INS27 INS8 INS42 INS43 INS21 INS42 INS42 INS32 INS62 INS8 INS43 INS59 INS44 INS32 INS8 INS44 INS8 INS42 INS42 INS40 INS32 INS42 MOV21 MOV21 INS60 INS25 INS25 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS40 INS32 INS42 INS42 INS42 INS33 INS42 INS42 INS32 INS43 INS60 INS60 INS21 INS21 INS25 INS42 INS42 INS16 INS43 INS42 INS32 INS42 INS42 INS21 INS32 INS43 INS42 MOV21 MOV42 INS42 INS39 INS59 INS32 INS8 INS42 INS8 INS42 INS42 INS32 INS42 INS42 INS38 INS38 INS9 INS32 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS7 INS32 INS27 INS8 INS27 INS42 INS42 INS42 INS42 INS42 INS32 MOV42 MOV42 INS42 MOV33 MOV42 MOV42 UPD42 MOV42 INS42 INS9 INS42 INS42 INS60 INS25 INS60 INS25 INS42 INS42 INS38 INS38 INS9 INS40 INS32 INS32 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS27 INS27 INS42 INS42 INS32 INS45 INS43 INS59 INS27 MOV8 INS83 INS43 INS59 INS62 INS8 INS25 INS32 INS32 INS42 INS42 INS40 INS42 INS42 INS40 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS33 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS11 INS32 MOV34 INS21 INS42 INS42 INS40 INS42 INS43 INS21 INS62 MOV8 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS70 INS43 INS32 INS42 INS42 INS7 INS40 INS32 INS42 INS43 INS42 INS42 INS42 INS32 INS44 INS32 INS8 INS40 INS32 UPD42 MOV42 INS42 INS9 INS42 INS42 INS42 INS33 INS42 INS42 INS40 INS12 INS42 INS42 INS32 INS43 INS42 INS32 INS42 INS40 INS21 UPD42 MOV42 UPD42 MOV42 MOV44 INS8 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS21 INS42 INS42 INS32 MOV42 MOV42 INS42 MOV33 MOV42 MOV42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 DEL42 DEL32 DEL27 DEL8 DEL42 DEL42 DEL40 DEL32 DEL32 DEL32 DEL27 DEL25 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL32 DEL42 DEL43 DEL42 DEL45 DEL52 DEL42 DEL22 DEL27 DEL59 DEL60 DEL8 DEL8 DEL42 DEL42
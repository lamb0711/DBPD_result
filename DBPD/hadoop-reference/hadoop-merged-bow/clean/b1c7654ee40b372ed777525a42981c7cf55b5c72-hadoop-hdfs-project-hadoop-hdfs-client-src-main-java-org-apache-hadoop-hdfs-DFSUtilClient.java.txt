HDFS-12594. snapshotDiff fails if the report exceeds the RPC response limit. Contributed by Shashikant Banerjee

+import java.util.Arrays;
+  /**
+   * Converts a byte array to array of arrays of bytes
+   * on byte separator.
+   */
+  public static byte[][] bytes2byteArray(byte[] bytes) {
+    return bytes2byteArray(bytes, bytes.length, (byte)Path.SEPARATOR_CHAR);
+  }
+  /**
+   * Splits first len bytes in bytes to array of arrays of bytes
+   * on byte separator.
+   * @param bytes the byte array to split
+   * @param len the number of bytes to split
+   * @param separator the delimiting byte
+   */
+  public static byte[][] bytes2byteArray(byte[] bytes, int len,
+      byte separator) {
+    Preconditions.checkPositionIndex(len, bytes.length);
+    if (len == 0) {
+      return new byte[][]{null};
+    }
+    // Count the splits. Omit multiple separators and the last one by
+    // peeking at prior byte.
+    int splits = 0;
+    for (int i = 1; i < len; i++) {
+      if (bytes[i-1] == separator && bytes[i] != separator) {
+        splits++;
+      }
+    }
+    if (splits == 0 && bytes[0] == separator) {
+      return new byte[][]{null};
+    }
+    splits++;
+    byte[][] result = new byte[splits][];
+    int nextIndex = 0;
+    // Build the splits.
+    for (int i = 0; i < splits; i++) {
+      int startIndex = nextIndex;
+      // find next separator in the bytes.
+      while (nextIndex < len && bytes[nextIndex] != separator) {
+        nextIndex++;
+      }
+      result[i] = (nextIndex > 0)
+          ? Arrays.copyOfRange(bytes, startIndex, nextIndex)
+          : DFSUtilClient.EMPTY_BYTES; // reuse empty bytes for root.
+      do { // skip over separators.
+        nextIndex++;
+      } while (nextIndex < len && bytes[nextIndex] == separator);
+    }
+    return result;
+  }
-    if (pathComponents.length == 0) {
+    if (pathComponents.length == 0 ||  (pathComponents.length == 1
+        && (pathComponents[0] == null || pathComponents[0].length == 0))) {
-    } else if (pathComponents.length == 1
-        && (pathComponents[0] == null || pathComponents[0].length == 0)) {
-      return new byte[]{(byte) Path.SEPARATOR_CHAR};

INS26 INS40 INS31 INS31 INS29 INS83 INS83 INS5 INS42 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS44 INS8 INS65 INS39 INS85 INS85 INS5 INS42 INS41 INS65 INS65 INS65 INS65 INS39 INS85 INS85 MOV5 INS42 INS39 INS42 INS39 INS42 INS21 INS25 INS60 INS24 INS25 INS21 INS60 INS60 INS24 INS41 MOV25 INS66 INS66 INS39 INS85 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS32 INS27 INS8 INS39 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS37 INS5 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS27 MOV8 INS42 INS42 INS40 MOV11 INS42 INS42 INS42 INS40 INS42 INS34 INS41 INS42 INS34 INS39 INS59 INS42 INS42 INS42 INS25 INS27 INS27 INS41 INS42 INS39 INS85 INS85 INS42 INS3 INS42 INS34 INS39 INS59 INS42 INS42 INS42 INS60 INS61 INS21 INS19 MOV27 INS36 INS3 INS42 INS34 INS27 INS8 INS42 INS34 INS2 INS42 INS3 INS5 INS42 INS42 INS34 INS39 INS59 INS27 INS8 INS7 INS8 INS27 MOV27 INS5 INS4 INS27 INS27 INS21 INS42 INS34 INS5 INS4 INS39 INS85 INS85 INS42 INS42 INS27 INS27 INS21 INS2 INS16 INS21 INS27 INS27 INS39 INS85 INS85 INS33 INS2 INS42 INS2 INS42 INS37 INS39 INS85 INS85 INS33 INS42 INS42 INS2 INS42 INS37 INS42 INS42 INS36 INS32 INS40 INS37 INS42 INS42 INS2 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS34 DEL4 DEL3 DEL41 DEL8 DEL25
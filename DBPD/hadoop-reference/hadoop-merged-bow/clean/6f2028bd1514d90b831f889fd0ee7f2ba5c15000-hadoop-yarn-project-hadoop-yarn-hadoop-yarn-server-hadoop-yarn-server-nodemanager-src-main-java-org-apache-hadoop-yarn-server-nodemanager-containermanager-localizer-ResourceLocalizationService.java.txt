YARN-90. NodeManager should identify failed disks becoming good again. Contributed by Varun Vasudev

+import org.apache.hadoop.fs.FileAlreadyExistsException;
+import org.apache.hadoop.fs.UnsupportedFileSystemException;
+  
+  FileContext lfs;
-      FileContext lfs = getLocalFileContext(conf);
-      lfs.setUMask(new FsPermission((short)FsPermission.DEFAULT_UMASK));
+      lfs = getLocalFileContext(conf);
+      lfs.setUMask(new FsPermission((short) FsPermission.DEFAULT_UMASK));
-      if (!stateStore.canRecover() || stateStore.isNewlyCreated()) {
-        cleanUpLocalDir(lfs,delService);
+      if (!stateStore.canRecover()|| stateStore.isNewlyCreated()) {
+        cleanUpLocalDirs(lfs, delService);
+        initializeLocalDirs(lfs);
+        initializeLogDirs(lfs);
-
-      List<String> localDirs = dirsHandler.getLocalDirs();
-      for (String localDir : localDirs) {
-        // $local/usercache
-        Path userDir = new Path(localDir, ContainerLocalizer.USERCACHE);
-        lfs.mkdir(userDir, null, true);
-        // $local/filecache
-        Path fileDir = new Path(localDir, ContainerLocalizer.FILECACHE);
-        lfs.mkdir(fileDir, null, true);
-        // $local/nmPrivate
-        Path sysDir = new Path(localDir, NM_PRIVATE_DIR);
-        lfs.mkdir(sysDir, NM_PRIVATE_PERM, true);
-      }
-
-      List<String> logDirs = dirsHandler.getLogDirs();
-      for (String logDir : logDirs) {
-        lfs.mkdir(new Path(logDir), null, true);
-      }
-    } catch (IOException e) {
-      throw new YarnRuntimeException("Failed to initialize LocalizationService", e);
+    } catch (Exception e) {
+      throw new YarnRuntimeException(
+        "Failed to initialize LocalizationService", e);
-    for (String localDir : dirsHandler.getLocalDirs()) {
+    
+    // Try deleting from good local dirs and full local dirs because a dir might
+    // have gone bad while the app was running(disk full). In addition
+    // a dir might have become good while the app was running.
+    // Check if the container dir exists and if it does, try to delete it
+    for (String localDir : dirsHandler.getLocalDirsForCleanup()) {
-      delService.delete(userName, containerDir, new Path[] {});
+      submitDirForDeletion(userName, containerDir);
-      
+
-      delService.delete(null, containerSysDir,  new Path[] {});
+      submitDirForDeletion(null, containerSysDir);
+  
+  private void submitDirForDeletion(String userName, Path dir) {
+    try {
+      lfs.getFileStatus(dir);
+      delService.delete(userName, dir, new Path[] {});
+    } catch (UnsupportedFileSystemException ue) {
+      LOG.warn("Local dir " + dir + " is an unsupported filesystem", ue);
+    } catch (IOException ie) {
+      // ignore
+      return;
+    }
+  }
-    for (String localDir : dirsHandler.getLocalDirs()) {
+    userName = application.getUser();
+    appIDStr = application.toString();
+
+    for (String localDir : dirsHandler.getLocalDirsForCleanup()) {
-      delService.delete(userName, appDir, new Path[] {});
+      submitDirForDeletion(userName, appDir);
-      delService.delete(null, appSysDir, new Path[] {});
+      submitDirForDeletion(null, appSysDir);
-      ContainerLocalizer.USERCACHE, user, ContainerLocalizer.APPCACHE, appId,
-      ContainerLocalizer.FILECACHE));
+        ContainerLocalizer.USERCACHE, user, ContainerLocalizer.APPCACHE, appId,
+        ContainerLocalizer.FILECACHE));
-     * @return
+     * @return the next resource to be localized
-        List<String> localDirs = dirsHandler.getLocalDirs();
-        List<String> logDirs = dirsHandler.getLogDirs();
+        List<String> localDirs = getInitializedLocalDirs();
+        List<String> logDirs = getInitializedLogDirs();
-              + dirsHandler.getDisksHealthReport());
+              + dirsHandler.getDisksHealthReport(false));
-  private void cleanUpLocalDir(FileContext lfs, DeletionService del) {
-    long currentTimeStamp = System.currentTimeMillis();
-    for (String localDir : dirsHandler.getLocalDirs()) {
-      renameLocalDir(lfs, localDir, ContainerLocalizer.USERCACHE,
-          currentTimeStamp);
-      renameLocalDir(lfs, localDir, ContainerLocalizer.FILECACHE,
-          currentTimeStamp);
-      renameLocalDir(lfs, localDir, ResourceLocalizationService.NM_PRIVATE_DIR,
-          currentTimeStamp);
+  private void initializeLocalDirs(FileContext lfs) {
+    List<String> localDirs = dirsHandler.getLocalDirs();
+    for (String localDir : localDirs) {
+      initializeLocalDir(lfs, localDir);
+    }
+  }
+
+  private void initializeLocalDir(FileContext lfs, String localDir) {
+
+    Map<Path, FsPermission> pathPermissionMap = getLocalDirsPathPermissionsMap(localDir);
+    for (Map.Entry<Path, FsPermission> entry : pathPermissionMap.entrySet()) {
+      FileStatus status;
-        deleteLocalDir(lfs, del, localDir);
-      } catch (IOException e) {
-        // Do nothing, just give the warning
-        LOG.warn("Failed to delete localDir: " + localDir);
+        status = lfs.getFileStatus(entry.getKey());
+      catch(FileNotFoundException fs) {
+        status = null;
+      }
+      catch(IOException ie) {
+        String msg = "Could not get file status for local dir " + entry.getKey();
+        LOG.warn(msg, ie);
+        throw new YarnRuntimeException(msg, ie);
+      }
+      if(status == null) {
+        try {
+          lfs.mkdir(entry.getKey(), entry.getValue(), true);
+          status = lfs.getFileStatus(entry.getKey());
+        } catch (IOException e) {
+          String msg = "Could not initialize local dir " + entry.getKey();
+          LOG.warn(msg, e);
+          throw new YarnRuntimeException(msg, e);
+        }
+      }
+      FsPermission perms = status.getPermission();
+      if(!perms.equals(entry.getValue())) {
+        try {
+          lfs.setPermission(entry.getKey(), entry.getValue());
+        }
+        catch(IOException ie) {
+          String msg = "Could not set permissions for local dir " + entry.getKey();
+          LOG.warn(msg, ie);
+          throw new YarnRuntimeException(msg, ie);
+        }
+      }
+    }
+  }
+
+  private void initializeLogDirs(FileContext lfs) {
+    List<String> logDirs = dirsHandler.getLogDirs();
+    for (String logDir : logDirs) {
+      initializeLogDir(lfs, logDir);
+    }
+  }
+
+  private void initializeLogDir(FileContext lfs, String logDir) {
+    try {
+      lfs.mkdir(new Path(logDir), null, true);
+    } catch (FileAlreadyExistsException fe) {
+      // do nothing
+    } catch (IOException e) {
+      String msg = "Could not initialize log dir " + logDir;
+      LOG.warn(msg, e);
+      throw new YarnRuntimeException(msg, e);
+    }
+  }
+
+  private void cleanUpLocalDirs(FileContext lfs, DeletionService del) {
+    for (String localDir : dirsHandler.getLocalDirs()) {
+      cleanUpLocalDir(lfs, del, localDir);
+    }
+  }
+
+  private void cleanUpLocalDir(FileContext lfs, DeletionService del,
+      String localDir) {
+    long currentTimeStamp = System.currentTimeMillis();
+    renameLocalDir(lfs, localDir, ContainerLocalizer.USERCACHE,
+      currentTimeStamp);
+    renameLocalDir(lfs, localDir, ContainerLocalizer.FILECACHE,
+      currentTimeStamp);
+    renameLocalDir(lfs, localDir, ResourceLocalizationService.NM_PRIVATE_DIR,
+      currentTimeStamp);
+    try {
+      deleteLocalDir(lfs, del, localDir);
+    } catch (IOException e) {
+      // Do nothing, just give the warning
+      LOG.warn("Failed to delete localDir: " + localDir);
+  
+  /**
+   * Synchronized method to get a list of initialized local dirs. Method will
+   * check each local dir to ensure it has been setup correctly and will attempt
+   * to fix any issues it finds.
+   * 
+   * @return list of initialized local dirs
+   */
+  synchronized private List<String> getInitializedLocalDirs() {
+    List<String> dirs = dirsHandler.getLocalDirs();
+    List<String> checkFailedDirs = new ArrayList<String>();
+    for (String dir : dirs) {
+      try {
+        checkLocalDir(dir);
+      } catch (YarnRuntimeException e) {
+        checkFailedDirs.add(dir);
+      }
+    }
+    for (String dir : checkFailedDirs) {
+      LOG.info("Attempting to initialize " + dir);
+      initializeLocalDir(lfs, dir);
+      try {
+        checkLocalDir(dir);
+      } catch (YarnRuntimeException e) {
+        String msg =
+            "Failed to setup local dir " + dir + ", which was marked as good.";
+        LOG.warn(msg, e);
+        throw new YarnRuntimeException(msg, e);
+      }
+    }
+    return dirs;
+  }
+  private boolean checkLocalDir(String localDir) {
+
+    Map<Path, FsPermission> pathPermissionMap = getLocalDirsPathPermissionsMap(localDir);
+
+    for (Map.Entry<Path, FsPermission> entry : pathPermissionMap.entrySet()) {
+      FileStatus status;
+      try {
+        status = lfs.getFileStatus(entry.getKey());
+      } catch (Exception e) {
+        String msg =
+            "Could not carry out resource dir checks for " + localDir
+                + ", which was marked as good";
+        LOG.warn(msg, e);
+        throw new YarnRuntimeException(msg, e);
+      }
+
+      if (!status.getPermission().equals(entry.getValue())) {
+        String msg =
+            "Permissions incorrectly set for dir " + entry.getKey()
+                + ", should be " + entry.getValue() + ", actual value = "
+                + status.getPermission();
+        LOG.warn(msg);
+        throw new YarnRuntimeException(msg);
+      }
+    }
+    return true;
+  }
+
+  private Map<Path, FsPermission> getLocalDirsPathPermissionsMap(String localDir) {
+    Map<Path, FsPermission> localDirPathFsPermissionsMap = new HashMap<Path, FsPermission>();
+
+    FsPermission defaultPermission =
+        FsPermission.getDirDefault().applyUMask(lfs.getUMask());
+    FsPermission nmPrivatePermission =
+        NM_PRIVATE_PERM.applyUMask(lfs.getUMask());
+
+    Path userDir = new Path(localDir, ContainerLocalizer.USERCACHE);
+    Path fileDir = new Path(localDir, ContainerLocalizer.FILECACHE);
+    Path sysDir = new Path(localDir, NM_PRIVATE_DIR);
+
+    localDirPathFsPermissionsMap.put(userDir, defaultPermission);
+    localDirPathFsPermissionsMap.put(fileDir, defaultPermission);
+    localDirPathFsPermissionsMap.put(sysDir, nmPrivatePermission);
+    return localDirPathFsPermissionsMap;
+  }
+  
+  /**
+   * Synchronized method to get a list of initialized log dirs. Method will
+   * check each local dir to ensure it has been setup correctly and will attempt
+   * to fix any issues it finds.
+   * 
+   * @return list of initialized log dirs
+   */
+  synchronized private List<String> getInitializedLogDirs() {
+    List<String> dirs = dirsHandler.getLogDirs();
+    initializeLogDirs(lfs);
+    return dirs;
+  }

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV43 INS59 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 MOV44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 MOV44 MOV8 INS29 INS83 INS83 INS74 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS74 INS42 MOV44 INS8 INS29 INS83 INS83 INS74 INS42 INS8 INS42 INS43 INS42 INS43 INS42 INS54 INS21 INS21 INS43 INS42 MOV60 INS70 INS43 INS42 INS43 INS42 INS60 INS70 INS43 INS42 MOV60 INS70 INS43 INS42 INS54 INS43 INS42 INS43 INS42 INS70 MOV60 INS65 INS65 INS43 INS43 INS60 INS60 INS70 INS70 INS41 INS43 INS42 INS60 INS70 INS41 INS43 INS43 INS43 INS60 INS60 INS60 MOV60 MOV60 MOV60 INS21 INS21 INS21 INS41 INS65 INS65 INS43 INS43 INS60 INS21 INS41 INS42 INS42 INS8 INS12 INS12 INS7 INS7 INS32 INS42 INS44 INS42 INS8 INS42 INS42 INS74 INS59 INS44 INS32 INS8 INS42 INS44 INS42 INS8 INS42 MOV8 INS12 INS12 INS42 INS42 INS44 MOV32 INS8 INS66 INS66 INS66 INS66 INS42 INS42 INS74 INS59 INS74 INS59 INS44 INS42 INS8 INS44 INS42 INS8 INS42 INS42 INS74 INS59 INS44 INS32 INS8 INS9 INS42 INS42 INS42 INS74 INS59 INS43 INS59 INS43 INS59 INS32 INS32 INS32 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS74 INS59 INS32 INS42 INS21 INS25 INS44 UPD42 INS21 INS21 MOV21 INS44 INS8 INS44 INS8 INS42 INS32 INS42 INS32 INS42 INS42 INS66 INS43 INS42 INS21 INS43 INS43 INS43 INS42 INS32 INS74 INS42 INS42 INS42 INS60 INS54 INS25 INS60 INS25 INS43 INS42 INS21 INS44 INS8 INS44 INS8 INS43 INS42 INS21 INS43 INS43 INS42 MOV32 INS43 INS43 INS42 INS14 INS43 INS42 INS54 INS43 INS42 INS21 INS21 INS54 INS43 INS43 INS43 INS42 INS32 INS74 INS42 INS42 INS42 INS60 INS54 INS25 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS42 INS7 MOV27 INS8 INS43 INS42 INS32 INS32 INS43 INS42 INS21 INS43 INS42 INS41 INS42 INS42 INS42 INS42 INS60 INS60 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS59 INS8 INS12 INS12 INS27 INS8 INS43 INS59 INS38 INS8 INS42 INS32 INS43 INS42 INS43 INS42 INS60 INS21 INS53 INS42 INS32 INS42 INS42 INS42 INS42 INS74 INS42 INS8 INS12 INS42 INS32 INS32 INS8 INS12 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS59 INS8 INS12 INS38 INS8 INS42 INS42 INS42 INS74 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 MOV32 MOV21 MOV21 MOV21 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 INS42 INS32 INS42 UPD42 UPD42 INS74 INS59 INS74 INS59 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS44 INS8 INS42 INS33 INS54 INS42 INS42 INS32 INS32 INS54 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS43 INS43 INS21 INS44 INS8 INS42 INS42 INS27 INS42 INS42 INS42 INS21 INS44 INS8 INS40 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS32 INS60 INS21 INS53 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS32 INS7 INS43 INS42 INS21 INS43 INS42 INS60 INS21 INS53 INS8 INS12 INS42 INS42 INS42 INS42 INS32 INS8 INS12 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS21 INS45 INS42 INS32 INS43 INS42 INS60 INS21 INS53 INS7 INS43 INS42 INS60 INS21 INS53 INS32 INS42 INS32 INS43 INS59 INS32 INS14 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS7 INS42 INS43 INS59 INS32 INS14 INS21 INS21 MOV44 INS8 INS42 INS42 INS21 INS44 INS8 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS32 INS42 INS33 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS7 INS60 INS21 INS53 INS32 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS32 INS32 INS9 INS42 INS32 INS43 INS59 INS32 INS14 INS42 INS42 INS32 INS32 INS42 INS43 INS59 INS32 INS14 INS45 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 DEL42 DEL59 DEL60 DEL42 DEL33 DEL9 DEL42 DEL33 DEL9 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL70 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL70 DEL42 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL42 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL42 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL70 DEL8
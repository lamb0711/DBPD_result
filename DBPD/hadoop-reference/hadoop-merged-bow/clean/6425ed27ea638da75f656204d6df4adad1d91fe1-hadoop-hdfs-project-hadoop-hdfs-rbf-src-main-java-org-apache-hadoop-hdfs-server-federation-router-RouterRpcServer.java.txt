HDFS-13790. RBF: Move ClientProtocol APIs to its own module. Contributed by Chao Sun.

-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.TreeMap;
-import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.hdfs.DFSConfigKeys;
-import org.apache.hadoop.hdfs.protocol.OpenFilesIterator;
-import org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.ClientNamenodeProtocol;
+import org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.ClientNamenodeProtocol;
-  /** Identifier for the super user. */
-  private final String superUser;
-  /** Identifier for the super group. */
-  private final String superGroup;
-
-  /** Erasure coding calls. */
-  private final ErasureCoding erasureCoding;
-
+  /** ClientProtocol calls. */
+  private final RouterClientProtocol clientProto;
-    // User and group for reporting
-    this.superUser = System.getProperty("user.name");
-    this.superGroup = this.conf.get(
-        DFSConfigKeys.DFS_PERMISSIONS_SUPERUSERGROUP_KEY,
-        DFSConfigKeys.DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT);
-
-    this.erasureCoding = new ErasureCoding(this);
+    this.clientProto = new RouterClientProtocol(conf, this);
+   * Get the active namenode resolver
+   */
+  public ActiveNamenodeResolver getNamenodeResolver() {
+    return namenodeResolver;
+  }
+
+  /**
-  protected void checkOperation(OperationCategory op, boolean supported)
+  void checkOperation(OperationCategory op, boolean supported)
-  protected void checkOperation(OperationCategory op)
+  void checkOperation(OperationCategory op)
+  /**
+   * Get the name of the method that is calling this function.
+   *
+   * @return Name of the method calling this function.
+   */
+  static String getMethodName() {
+    final StackTraceElement[] stack = Thread.currentThread().getStackTrace();
+    String methodName = stack[3].getMethodName();
+    return methodName;
+  }
+
-    checkOperation(OperationCategory.WRITE, false);
-    return null;
-  }
-
-  /**
-   * The the delegation token from each name service.
-   * @param renewer
-   * @return Name service -> Token.
-   * @throws IOException
-   */
-  public Map<FederationNamespaceInfo, Token<DelegationTokenIdentifier>>
-      getDelegationTokens(Text renewer) throws IOException {
-    checkOperation(OperationCategory.WRITE, false);
-    return null;
+    return clientProto.getDelegationToken(renewer);
-    checkOperation(OperationCategory.WRITE, false);
-    return 0;
+    return clientProto.renewDelegationToken(token);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.cancelDelegationToken(token);
-    checkOperation(OperationCategory.READ);
-
-    List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod remoteMethod = new RemoteMethod("getBlockLocations",
-        new Class<?>[] {String.class, long.class, long.class},
-        new RemoteParam(), offset, length);
-    return (LocatedBlocks) rpcClient.invokeSequential(locations, remoteMethod,
-        LocatedBlocks.class, null);
+    return clientProto.getBlockLocations(src, offset, length);
-    checkOperation(OperationCategory.READ);
-
-    RemoteMethod method = new RemoteMethod("getServerDefaults");
-    String ns = subclusterResolver.getDefaultNamespace();
-    return (FsServerDefaults) rpcClient.invokeSingle(ns, method);
+    return clientProto.getServerDefaults();
-    checkOperation(OperationCategory.WRITE);
-
-    if (createParent && isPathAll(src)) {
-      int index = src.lastIndexOf(Path.SEPARATOR);
-      String parent = src.substring(0, index);
-      LOG.debug("Creating {} requires creating parent {}", src, parent);
-      FsPermission parentPermissions = getParentPermission(masked);
-      boolean success = mkdirs(parent, parentPermissions, createParent);
-      if (!success) {
-        // This shouldn't happen as mkdirs returns true or exception
-        LOG.error("Couldn't create parents for {}", src);
-      }
-    }
-
-    RemoteLocation createLocation = getCreateLocation(src);
-    RemoteMethod method = new RemoteMethod("create",
-        new Class<?>[] {String.class, FsPermission.class, String.class,
-                        EnumSetWritable.class, boolean.class, short.class,
-                        long.class, CryptoProtocolVersion[].class,
-                        String.class},
-        createLocation.getDest(), masked, clientName, flag, createParent,
+    return clientProto.create(src, masked, clientName, flag, createParent,
-    return (HdfsFileStatus) rpcClient.invokeSingle(createLocation, method);
-  }
-
-  /**
-   * Get the permissions for the parent of a child with given permissions.
-   * Add implicit u+wx permission for parent. This is based on
-   * @{FSDirMkdirOp#addImplicitUwx}.
-   * @param mask The permission mask of the child.
-   * @return The permission mask of the parent.
-   */
-  private static FsPermission getParentPermission(final FsPermission mask) {
-    FsPermission ret = new FsPermission(
-        mask.getUserAction().or(FsAction.WRITE_EXECUTE),
-        mask.getGroupAction(),
-        mask.getOtherAction());
-    return ret;
-  protected RemoteLocation getCreateLocation(final String src)
+  RemoteLocation getCreateLocation(final String src)
-  // Medium
-    checkOperation(OperationCategory.WRITE);
-
-    List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("append",
-        new Class<?>[] {String.class, String.class, EnumSetWritable.class},
-        new RemoteParam(), clientName, flag);
-    return rpcClient.invokeSequential(
-        locations, method, LastBlockWithStatus.class, null);
+    return clientProto.append(src, clientName, flag);
-  // Low
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("recoverLease",
-        new Class<?>[] {String.class, String.class}, new RemoteParam(),
-        clientName);
-    Object result = rpcClient.invokeSequential(
-        locations, method, Boolean.class, Boolean.TRUE);
-    return (boolean) result;
+    return clientProto.recoverLease(src, clientName);
-    checkOperation(OperationCategory.WRITE);
-
-    List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("setReplication",
-        new Class<?>[] {String.class, short.class}, new RemoteParam(),
-        replication);
-    Object result = rpcClient.invokeSequential(
-        locations, method, Boolean.class, Boolean.TRUE);
-    return (boolean) result;
+    return clientProto.setReplication(src, replication);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.WRITE);
-
-    List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("setStoragePolicy",
-        new Class<?>[] {String.class, String.class},
-        new RemoteParam(), policyName);
-    rpcClient.invokeSequential(locations, method, null, null);
+    clientProto.setStoragePolicy(src, policyName);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.READ);
-
-    RemoteMethod method = new RemoteMethod("getStoragePolicies");
-    String ns = subclusterResolver.getDefaultNamespace();
-    return (BlockStoragePolicy[]) rpcClient.invokeSingle(ns, method);
+    return clientProto.getStoragePolicies();
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("setPermission",
-        new Class<?>[] {String.class, FsPermission.class},
-        new RemoteParam(), permissions);
-    if (isPathAll(src)) {
-      rpcClient.invokeConcurrent(locations, method);
-    } else {
-      rpcClient.invokeSequential(locations, method);
-    }
+    clientProto.setPermission(src, permissions);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("setOwner",
-        new Class<?>[] {String.class, String.class, String.class},
-        new RemoteParam(), username, groupname);
-    if (isPathAll(src)) {
-      rpcClient.invokeConcurrent(locations, method);
-    } else {
-      rpcClient.invokeSequential(locations, method);
-    }
+    clientProto.setOwner(src, username, groupname);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("addBlock",
-        new Class<?>[] {String.class, String.class, ExtendedBlock.class,
-                        DatanodeInfo[].class, long.class, String[].class,
-                        EnumSet.class},
-        new RemoteParam(), clientName, previous, excludedNodes, fileId,
-        favoredNodes, addBlockFlags);
-    // TODO verify the excludedNodes and favoredNodes are acceptable to this NN
-    return (LocatedBlock) rpcClient.invokeSequential(
-        locations, method, LocatedBlock.class, null);
+    return clientProto.addBlock(src, clientName, previous, excludedNodes,
+        fileId, favoredNodes, addBlockFlags);
-    checkOperation(OperationCategory.READ);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("getAdditionalDatanode",
-        new Class<?>[] {String.class, long.class, ExtendedBlock.class,
-                        DatanodeInfo[].class, String[].class,
-                        DatanodeInfo[].class, int.class, String.class},
-        new RemoteParam(), fileId, blk, existings, existingStorageIDs, excludes,
-        numAdditionalNodes, clientName);
-    return (LocatedBlock) rpcClient.invokeSequential(
-        locations, method, LocatedBlock.class, null);
+    return clientProto.getAdditionalDatanode(src, fileId, blk, existings,
+        existingStorageIDs, excludes, numAdditionalNodes, clientName);
-    checkOperation(OperationCategory.WRITE);
-
-    RemoteMethod method = new RemoteMethod("abandonBlock",
-        new Class<?>[] {ExtendedBlock.class, long.class, String.class,
-                        String.class},
-        b, fileId, new RemoteParam(), holder);
-    rpcClient.invokeSingle(b, method);
+    clientProto.abandonBlock(b, fileId, src, holder);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("complete",
-        new Class<?>[] {String.class, String.class, ExtendedBlock.class,
-                        long.class},
-        new RemoteParam(), clientName, last, fileId);
-    // Complete can return true/false, so don't expect a result
-    return ((Boolean) rpcClient.invokeSequential(
-        locations, method, Boolean.class, null)).booleanValue();
+    return clientProto.complete(src, clientName, last, fileId);
-    checkOperation(OperationCategory.WRITE);
-
-    RemoteMethod method = new RemoteMethod("updateBlockForPipeline",
-        new Class<?>[] {ExtendedBlock.class, String.class},
-        block, clientName);
-    return (LocatedBlock) rpcClient.invokeSingle(block, method);
+    return clientProto.updateBlockForPipeline(block, clientName);
-    checkOperation(OperationCategory.WRITE);
-
-    RemoteMethod method = new RemoteMethod("updatePipeline",
-        new Class<?>[] {String.class, ExtendedBlock.class, ExtendedBlock.class,
-                        DatanodeID[].class, String[].class},
-        clientName, oldBlock, newBlock, newNodes, newStorageIDs);
-    rpcClient.invokeSingle(oldBlock, method);
+    clientProto.updatePipeline(clientName, oldBlock, newBlock, newNodes,
+        newStorageIDs);
-    checkOperation(OperationCategory.READ);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("getPreferredBlockSize",
-        new Class<?>[] {String.class}, new RemoteParam());
-    return ((Long) rpcClient.invokeSequential(
-        locations, method, Long.class, null)).longValue();
-  }
-
-  /**
-   * Determines combinations of eligible src/dst locations for a rename. A
-   * rename cannot change the namespace. Renames are only allowed if there is an
-   * eligible dst location in the same namespace as the source.
-   *
-   * @param srcLocations List of all potential source destinations where the
-   *          path may be located. On return this list is trimmed to include
-   *          only the paths that have corresponding destinations in the same
-   *          namespace.
-   * @param dst The destination path
-   * @return A map of all eligible source namespaces and their corresponding
-   *         replacement value.
-   * @throws IOException If the dst paths could not be determined.
-   */
-  private RemoteParam getRenameDestinations(
-      final List<RemoteLocation> srcLocations, final String dst)
-          throws IOException {
-
-    final List<RemoteLocation> dstLocations = getLocationsForPath(dst, true);
-    final Map<RemoteLocation, String> dstMap = new HashMap<>();
-
-    Iterator<RemoteLocation> iterator = srcLocations.iterator();
-    while (iterator.hasNext()) {
-      RemoteLocation srcLocation = iterator.next();
-      RemoteLocation eligibleDst =
-          getFirstMatchingLocation(srcLocation, dstLocations);
-      if (eligibleDst != null) {
-        // Use this dst for this source location
-        dstMap.put(srcLocation, eligibleDst.getDest());
-      } else {
-        // This src destination is not valid, remove from the source list
-        iterator.remove();
-      }
-    }
-    return new RemoteParam(dstMap);
-  }
-
-  /**
-   * Get first matching location.
-   *
-   * @param location Location we are looking for.
-   * @param locations List of locations.
-   * @return The first matchin location in the list.
-   */
-  private RemoteLocation getFirstMatchingLocation(RemoteLocation location,
-      List<RemoteLocation> locations) {
-    for (RemoteLocation loc : locations) {
-      if (loc.getNameserviceId().equals(location.getNameserviceId())) {
-        // Return first matching location
-        return loc;
-      }
-    }
-    return null;
+    return clientProto.getPreferredBlockSize(src);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> srcLocations =
-        getLocationsForPath(src, true, false);
-    // srcLocations may be trimmed by getRenameDestinations()
-    final List<RemoteLocation> locs = new LinkedList<>(srcLocations);
-    RemoteParam dstParam = getRenameDestinations(locs, dst);
-    if (locs.isEmpty()) {
-      throw new IOException(
-          "Rename of " + src + " to " + dst + " is not allowed," +
-          " no eligible destination in the same namespace was found.");
-    }
-    RemoteMethod method = new RemoteMethod("rename",
-        new Class<?>[] {String.class, String.class},
-        new RemoteParam(), dstParam);
-    return ((Boolean) rpcClient.invokeSequential(
-        locs, method, Boolean.class, Boolean.TRUE)).booleanValue();
+    return clientProto.rename(src, dst);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> srcLocations =
-        getLocationsForPath(src, true, false);
-    // srcLocations may be trimmed by getRenameDestinations()
-    final List<RemoteLocation> locs = new LinkedList<>(srcLocations);
-    RemoteParam dstParam = getRenameDestinations(locs, dst);
-    if (locs.isEmpty()) {
-      throw new IOException(
-          "Rename of " + src + " to " + dst + " is not allowed," +
-          " no eligible destination in the same namespace was found.");
-    }
-    RemoteMethod method = new RemoteMethod("rename2",
-        new Class<?>[] {String.class, String.class, options.getClass()},
-        new RemoteParam(), dstParam, options);
-    rpcClient.invokeSequential(locs, method, null, null);
+    clientProto.rename2(src, dst, options);
-    checkOperation(OperationCategory.WRITE);
-
-    // See if the src and target files are all in the same namespace
-    LocatedBlocks targetBlocks = getBlockLocations(trg, 0, 1);
-    if (targetBlocks == null) {
-      throw new IOException("Cannot locate blocks for target file - " + trg);
-    }
-    LocatedBlock lastLocatedBlock = targetBlocks.getLastLocatedBlock();
-    String targetBlockPoolId = lastLocatedBlock.getBlock().getBlockPoolId();
-    for (String source : src) {
-      LocatedBlocks sourceBlocks = getBlockLocations(source, 0, 1);
-      if (sourceBlocks == null) {
-        throw new IOException(
-            "Cannot located blocks for source file " + source);
-      }
-      String sourceBlockPoolId =
-          sourceBlocks.getLastLocatedBlock().getBlock().getBlockPoolId();
-      if (!sourceBlockPoolId.equals(targetBlockPoolId)) {
-        throw new IOException("Cannot concatenate source file " + source
-            + " because it is located in a different namespace"
-            + " with block pool id " + sourceBlockPoolId
-            + " from the target file with block pool id "
-            + targetBlockPoolId);
-      }
-    }
-
-    // Find locations in the matching namespace.
-    final RemoteLocation targetDestination =
-        getLocationForPath(trg, true, targetBlockPoolId);
-    String[] sourceDestinations = new String[src.length];
-    for (int i = 0; i < src.length; i++) {
-      String sourceFile = src[i];
-      RemoteLocation location =
-          getLocationForPath(sourceFile, true, targetBlockPoolId);
-      sourceDestinations[i] = location.getDest();
-    }
-    // Invoke
-    RemoteMethod method = new RemoteMethod("concat",
-        new Class<?>[] {String.class, String[].class},
-        targetDestination.getDest(), sourceDestinations);
-    rpcClient.invokeSingle(targetDestination, method);
+    clientProto.concat(trg, src);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("truncate",
-        new Class<?>[] {String.class, long.class, String.class},
-        new RemoteParam(), newLength, clientName);
-    return ((Boolean) rpcClient.invokeSequential(locations, method,
-        Boolean.class, Boolean.TRUE)).booleanValue();
+    return clientProto.truncate(src, newLength, clientName);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations =
-        getLocationsForPath(src, true, false);
-    RemoteMethod method = new RemoteMethod("delete",
-        new Class<?>[] {String.class, boolean.class}, new RemoteParam(),
-        recursive);
-    if (isPathAll(src)) {
-      return rpcClient.invokeAll(locations, method);
-    } else {
-      return rpcClient.invokeSequential(locations, method,
-          Boolean.class, Boolean.TRUE).booleanValue();
-    }
+    return clientProto.delete(src, recursive);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("mkdirs",
-        new Class<?>[] {String.class, FsPermission.class, boolean.class},
-        new RemoteParam(), masked, createParent);
-
-    // Create in all locations
-    if (isPathAll(src)) {
-      return rpcClient.invokeAll(locations, method);
-    }
-
-    if (locations.size() > 1) {
-      // Check if this directory already exists
-      try {
-        HdfsFileStatus fileStatus = getFileInfo(src);
-        if (fileStatus != null) {
-          // When existing, the NN doesn't return an exception; return true
-          return true;
-        }
-      } catch (IOException ioe) {
-        // Can't query if this file exists or not.
-        LOG.error("Error requesting file info for path {} while proxing mkdirs",
-            src, ioe);
-      }
-    }
-
-    RemoteLocation firstLocation = locations.get(0);
-    return ((Boolean) rpcClient.invokeSingle(firstLocation, method))
-        .booleanValue();
+    return clientProto.mkdirs(src, masked, createParent);
-    checkOperation(OperationCategory.WRITE);
-
-    RemoteMethod method = new RemoteMethod("renewLease",
-        new Class<?>[] {String.class}, clientName);
-    Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    rpcClient.invokeConcurrent(nss, method, false, false);
+    clientProto.renewLease(clientName);
-    checkOperation(OperationCategory.READ);
-
-    // Locate the dir and fetch the listing
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("getListing",
-        new Class<?>[] {String.class, startAfter.getClass(), boolean.class},
-        new RemoteParam(), startAfter, needLocation);
-    Map<RemoteLocation, DirectoryListing> listings =
-        rpcClient.invokeConcurrent(
-            locations, method, false, false, DirectoryListing.class);
-
-    Map<String, HdfsFileStatus> nnListing = new TreeMap<>();
-    int totalRemainingEntries = 0;
-    int remainingEntries = 0;
-    boolean namenodeListingExists = false;
-    if (listings != null) {
-      // Check the subcluster listing with the smallest name
-      String lastName = null;
-      for (Entry<RemoteLocation, DirectoryListing> entry :
-          listings.entrySet()) {
-        RemoteLocation location = entry.getKey();
-        DirectoryListing listing = entry.getValue();
-        if (listing == null) {
-          LOG.debug("Cannot get listing from {}", location);
-        } else {
-          totalRemainingEntries += listing.getRemainingEntries();
-          HdfsFileStatus[] partialListing = listing.getPartialListing();
-          int length = partialListing.length;
-          if (length > 0) {
-            HdfsFileStatus lastLocalEntry = partialListing[length-1];
-            String lastLocalName = lastLocalEntry.getLocalName();
-            if (lastName == null || lastName.compareTo(lastLocalName) > 0) {
-              lastName = lastLocalName;
-            }
-          }
-        }
-      }
-
-      // Add existing entries
-      for (Object value : listings.values()) {
-        DirectoryListing listing = (DirectoryListing) value;
-        if (listing != null) {
-          namenodeListingExists = true;
-          for (HdfsFileStatus file : listing.getPartialListing()) {
-            String filename = file.getLocalName();
-            if (totalRemainingEntries > 0 && filename.compareTo(lastName) > 0) {
-              // Discarding entries further than the lastName
-              remainingEntries++;
-            } else {
-              nnListing.put(filename, file);
-            }
-          }
-          remainingEntries += listing.getRemainingEntries();
-        }
-      }
-    }
-
-    // Add mount points at this level in the tree
-    final List<String> children = subclusterResolver.getMountPoints(src);
-    if (children != null) {
-      // Get the dates for each mount point
-      Map<String, Long> dates = getMountPointDates(src);
-
-      // Create virtual folder with the mount name
-      for (String child : children) {
-        long date = 0;
-        if (dates != null && dates.containsKey(child)) {
-          date = dates.get(child);
-        }
-        // TODO add number of children
-        HdfsFileStatus dirStatus = getMountPointStatus(child, 0, date);
-
-        // This may overwrite existing listing entries with the mount point
-        // TODO don't add if already there?
-        nnListing.put(child, dirStatus);
-      }
-    }
-
-    if (!namenodeListingExists && nnListing.size() == 0) {
-      // NN returns a null object if the directory cannot be found and has no
-      // listing. If we didn't retrieve any NN listing data, and there are no
-      // mount points here, return null.
-      return null;
-    }
-
-    // Generate combined listing
-    HdfsFileStatus[] combinedData = new HdfsFileStatus[nnListing.size()];
-    combinedData = nnListing.values().toArray(combinedData);
-    return new DirectoryListing(combinedData, remainingEntries);
+    return clientProto.getListing(src, startAfter, needLocation);
-    checkOperation(OperationCategory.READ);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("getFileInfo",
-        new Class<?>[] {String.class}, new RemoteParam());
-
-    HdfsFileStatus ret = null;
-    // If it's a directory, we check in all locations
-    if (isPathAll(src)) {
-      ret = getFileInfoAll(locations, method);
-    } else {
-      // Check for file information sequentially
-      ret = (HdfsFileStatus) rpcClient.invokeSequential(
-          locations, method, HdfsFileStatus.class, null);
-    }
-
-    // If there is no real path, check mount points
-    if (ret == null) {
-      List<String> children = subclusterResolver.getMountPoints(src);
-      if (children != null && !children.isEmpty()) {
-        Map<String, Long> dates = getMountPointDates(src);
-        long date = 0;
-        if (dates != null && dates.containsKey(src)) {
-          date = dates.get(src);
-        }
-        ret = getMountPointStatus(src, children.size(), date);
-      }
-    }
-
-    return ret;
-  }
-
-  /**
-   * Get the file info from all the locations.
-   *
-   * @param locations Locations to check.
-   * @param method The file information method to run.
-   * @return The first file info if it's a file, the directory if it's
-   *         everywhere.
-   * @throws IOException If all the locations throw an exception.
-   */
-  private HdfsFileStatus getFileInfoAll(final List<RemoteLocation> locations,
-      final RemoteMethod method) throws IOException {
-
-    // Get the file info from everybody
-    Map<RemoteLocation, HdfsFileStatus> results =
-        rpcClient.invokeConcurrent(locations, method, HdfsFileStatus.class);
-
-    // We return the first file
-    HdfsFileStatus dirStatus = null;
-    for (RemoteLocation loc : locations) {
-      HdfsFileStatus fileStatus = results.get(loc);
-      if (fileStatus != null) {
-        if (!fileStatus.isDirectory()) {
-          return fileStatus;
-        } else if (dirStatus == null) {
-          dirStatus = fileStatus;
-        }
-      }
-    }
-    return dirStatus;
+    return clientProto.getFileInfo(src);
-    checkOperation(OperationCategory.READ);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("isFileClosed",
-        new Class<?>[] {String.class}, new RemoteParam());
-    return ((Boolean) rpcClient.invokeSequential(
-        locations, method, Boolean.class, Boolean.TRUE)).booleanValue();
+    return clientProto.isFileClosed(src);
-    checkOperation(OperationCategory.READ);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("getFileLinkInfo",
-        new Class<?>[] {String.class}, new RemoteParam());
-    return (HdfsFileStatus) rpcClient.invokeSequential(
-        locations, method, HdfsFileStatus.class, null);
+    return clientProto.getFileLinkInfo(src);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.READ);
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("getLocatedFileInfo",
-        new Class<?>[] {String.class, boolean.class}, new RemoteParam(),
-        Boolean.valueOf(needBlockToken));
-    return (HdfsLocatedFileStatus) rpcClient.invokeSequential(
-        locations, method, HdfsFileStatus.class, null);
+    return clientProto.getLocatedFileInfo(src, needBlockToken);
-    checkOperation(OperationCategory.UNCHECKED);
-
-    RemoteMethod method = new RemoteMethod("getStats");
-    Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    Map<FederationNamespaceInfo, long[]> results =
-        rpcClient.invokeConcurrent(nss, method, true, false, long[].class);
-    long[] combinedData = new long[STATS_ARRAY_LENGTH];
-    for (long[] data : results.values()) {
-      for (int i = 0; i < combinedData.length && i < data.length; i++) {
-        if (data[i] >= 0) {
-          combinedData[i] += data[i];
-        }
-      }
-    }
-    return combinedData;
+    return clientProto.getStats();
-    checkOperation(OperationCategory.UNCHECKED);
-    return getDatanodeReport(type, true, 0);
+    return clientProto.getDatanodeReport(type);
-    checkOperation(OperationCategory.UNCHECKED);
-
-    Map<String, DatanodeStorageReport[]> dnSubcluster =
-        getDatanodeStorageReportMap(type);
-
-    // Avoid repeating machines in multiple subclusters
-    Map<String, DatanodeStorageReport> datanodesMap = new LinkedHashMap<>();
-    for (DatanodeStorageReport[] dns : dnSubcluster.values()) {
-      for (DatanodeStorageReport dn : dns) {
-        DatanodeInfo dnInfo = dn.getDatanodeInfo();
-        String nodeId = dnInfo.getXferAddr();
-        if (!datanodesMap.containsKey(nodeId)) {
-          datanodesMap.put(nodeId, dn);
-        }
-        // TODO merge somehow, right now it just takes the first one
-      }
-    }
-
-    Collection<DatanodeStorageReport> datanodes = datanodesMap.values();
-    DatanodeStorageReport[] combinedData =
-        new DatanodeStorageReport[datanodes.size()];
-    combinedData = datanodes.toArray(combinedData);
-    return combinedData;
+    return clientProto.getDatanodeStorageReport(type);
-    checkOperation(OperationCategory.WRITE);
-
-    // Set safe mode in all the name spaces
-    RemoteMethod method = new RemoteMethod("setSafeMode",
-        new Class<?>[] {SafeModeAction.class, boolean.class},
-        action, isChecked);
-    Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    Map<FederationNamespaceInfo, Boolean> results =
-        rpcClient.invokeConcurrent(
-            nss, method, true, !isChecked, Boolean.class);
-
-    // We only report true if all the name space are in safe mode
-    int numSafemode = 0;
-    for (boolean safemode : results.values()) {
-      if (safemode) {
-        numSafemode++;
-      }
-    }
-    return numSafemode == results.size();
+    return clientProto.setSafeMode(action, isChecked);
-    checkOperation(OperationCategory.UNCHECKED);
-
-    RemoteMethod method = new RemoteMethod("restoreFailedStorage",
-        new Class<?>[] {String.class}, arg);
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    Map<FederationNamespaceInfo, Boolean> ret =
-        rpcClient.invokeConcurrent(nss, method, true, false, Boolean.class);
-
-    boolean success = true;
-    for (boolean s : ret.values()) {
-      if (!s) {
-        success = false;
-        break;
-      }
-    }
-    return success;
+    return clientProto.restoreFailedStorage(arg);
-    checkOperation(OperationCategory.UNCHECKED);
-
-    RemoteMethod method = new RemoteMethod("saveNamespace",
-        new Class<?>[] {Long.class, Long.class}, timeWindow, txGap);
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    Map<FederationNamespaceInfo, Boolean> ret =
-        rpcClient.invokeConcurrent(nss, method, true, false, boolean.class);
-
-    boolean success = true;
-    for (boolean s : ret.values()) {
-      if (!s) {
-        success = false;
-        break;
-      }
-    }
-    return success;
+    return clientProto.saveNamespace(timeWindow, txGap);
-    checkOperation(OperationCategory.WRITE);
-
-    RemoteMethod method = new RemoteMethod("rollEdits", new Class<?>[] {});
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    Map<FederationNamespaceInfo, Long> ret =
-        rpcClient.invokeConcurrent(nss, method, true, false, long.class);
-
-    // Return the maximum txid
-    long txid = 0;
-    for (long t : ret.values()) {
-      if (t > txid) {
-        txid = t;
-      }
-    }
-    return txid;
+    return clientProto.rollEdits();
-    checkOperation(OperationCategory.UNCHECKED);
-
-    RemoteMethod method = new RemoteMethod("refreshNodes", new Class<?>[] {});
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    rpcClient.invokeConcurrent(nss, method, true, true);
+    clientProto.refreshNodes();
-    checkOperation(OperationCategory.UNCHECKED);
-
-    RemoteMethod method = new RemoteMethod("finalizeUpgrade",
-        new Class<?>[] {});
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    rpcClient.invokeConcurrent(nss, method, true, false);
+    clientProto.finalizeUpgrade();
-    String methodName = getMethodName();
-    throw new UnsupportedOperationException(
-        "Operation \"" + methodName + "\" is not supported");
+    return clientProto.upgradeStatus();
-    checkOperation(OperationCategory.READ);
-
-    RemoteMethod method = new RemoteMethod("rollingUpgrade",
-        new Class<?>[] {RollingUpgradeAction.class}, action);
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    Map<FederationNamespaceInfo, RollingUpgradeInfo> ret =
-        rpcClient.invokeConcurrent(
-            nss, method, true, false, RollingUpgradeInfo.class);
-
-    // Return the first rolling upgrade info
-    RollingUpgradeInfo info = null;
-    for (RollingUpgradeInfo infoNs : ret.values()) {
-      if (info == null && infoNs != null) {
-        info = infoNs;
-      }
-    }
-    return info;
+    return clientProto.rollingUpgrade(action);
-    checkOperation(OperationCategory.UNCHECKED);
-
-    RemoteMethod method = new RemoteMethod("metaSave",
-        new Class<?>[] {String.class}, filename);
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    rpcClient.invokeConcurrent(nss, method, true, false);
+    clientProto.metaSave(filename);
-    checkOperation(OperationCategory.READ);
-
-    final List<RemoteLocation> locations = getLocationsForPath(path, false);
-    RemoteMethod method = new RemoteMethod("listCorruptFileBlocks",
-        new Class<?>[] {String.class, String.class},
-        new RemoteParam(), cookie);
-    return (CorruptFileBlocks) rpcClient.invokeSequential(
-        locations, method, CorruptFileBlocks.class, null);
+    return clientProto.listCorruptFileBlocks(path, cookie);
-    checkOperation(OperationCategory.UNCHECKED);
-
-    RemoteMethod method = new RemoteMethod("setBalancerBandwidth",
-        new Class<?>[] {Long.class}, bandwidth);
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    rpcClient.invokeConcurrent(nss, method, true, false);
+    clientProto.setBalancerBandwidth(bandwidth);
-    checkOperation(OperationCategory.READ);
-
-    // Get the summaries from regular files
-    Collection<ContentSummary> summaries = new LinkedList<>();
-    FileNotFoundException notFoundException = null;
-    try {
-      final List<RemoteLocation> locations = getLocationsForPath(path, false);
-      RemoteMethod method = new RemoteMethod("getContentSummary",
-          new Class<?>[] {String.class}, new RemoteParam());
-      Map<RemoteLocation, ContentSummary> results =
-          rpcClient.invokeConcurrent(
-              locations, method, false, false, ContentSummary.class);
-      summaries.addAll(results.values());
-    } catch (FileNotFoundException e) {
-      notFoundException = e;
-    }
-
-    // Add mount points at this level in the tree
-    final List<String> children = subclusterResolver.getMountPoints(path);
-    if (children != null) {
-      for (String child : children) {
-        Path childPath = new Path(path, child);
-        try {
-          ContentSummary mountSummary = getContentSummary(childPath.toString());
-          if (mountSummary != null) {
-            summaries.add(mountSummary);
-          }
-        } catch (Exception e) {
-          LOG.error("Cannot get content summary for mount {}: {}",
-              childPath, e.getMessage());
-        }
-      }
-    }
-
-    // Throw original exception if no original nor mount points
-    if (summaries.isEmpty() && notFoundException != null) {
-      throw notFoundException;
-    }
-
-    return aggregateContentSummary(summaries);
-  }
-
-  /**
-   * Aggregate content summaries for each subcluster.
-   *
-   * @param summaries Collection of individual summaries.
-   * @return Aggregated content summary.
-   */
-  private ContentSummary aggregateContentSummary(
-      Collection<ContentSummary> summaries) {
-    if (summaries.size() == 1) {
-      return summaries.iterator().next();
-    }
-
-    long length = 0;
-    long fileCount = 0;
-    long directoryCount = 0;
-    long quota = 0;
-    long spaceConsumed = 0;
-    long spaceQuota = 0;
-
-    for (ContentSummary summary : summaries) {
-      length += summary.getLength();
-      fileCount += summary.getFileCount();
-      directoryCount += summary.getDirectoryCount();
-      quota += summary.getQuota();
-      spaceConsumed += summary.getSpaceConsumed();
-      spaceQuota += summary.getSpaceQuota();
-    }
-
-    ContentSummary ret = new ContentSummary.Builder()
-        .length(length)
-        .fileCount(fileCount)
-        .directoryCount(directoryCount)
-        .quota(quota)
-        .spaceConsumed(spaceConsumed)
-        .spaceQuota(spaceQuota)
-        .build();
-    return ret;
+    return clientProto.getContentSummary(path);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("fsync",
-        new Class<?>[] {String.class, long.class, String.class, long.class },
-        new RemoteParam(), fileId, clientName, lastBlockLength);
-    rpcClient.invokeSequential(locations, method);
+    clientProto.fsync(src, fileId, clientName, lastBlockLength);
-    checkOperation(OperationCategory.WRITE);
-
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("setTimes",
-        new Class<?>[] {String.class, long.class, long.class},
-        new RemoteParam(), mtime, atime);
-    rpcClient.invokeSequential(locations, method);
+    clientProto.setTimes(src, mtime, atime);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO Verify that the link location is in the same NS as the targets
-    final List<RemoteLocation> targetLocations =
-        getLocationsForPath(target, true);
-    final List<RemoteLocation> linkLocations =
-        getLocationsForPath(link, true);
-    RemoteLocation linkLocation = linkLocations.get(0);
-    RemoteMethod method = new RemoteMethod("createSymlink",
-        new Class<?>[] {String.class, String.class, FsPermission.class,
-                        boolean.class},
-        new RemoteParam(), linkLocation.getDest(), dirPerms, createParent);
-    rpcClient.invokeSequential(targetLocations, method);
+    clientProto.createSymlink(target, link, dirPerms, createParent);
-    checkOperation(OperationCategory.READ);
-
-    final List<RemoteLocation> locations = getLocationsForPath(path, true);
-    RemoteMethod method = new RemoteMethod("getLinkTarget",
-        new Class<?>[] {String.class}, new RemoteParam());
-    return (String) rpcClient.invokeSequential(
-        locations, method, String.class, null);
+    return clientProto.getLinkTarget(path);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.allowSnapshot(snapshotRoot);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.disallowSnapshot(snapshot);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.renameSnapshot(snapshotRoot, snapshotOldName, snapshotNewName);
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.getSnapshottableDirListing();
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.getSnapshotDiffReport(
+        snapshotRoot, earlierSnapshotName, laterSnapshotName);
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.getSnapshotDiffReportListing(snapshotRoot,
+        earlierSnapshotName, laterSnapshotName, startPath, index);
-    checkOperation(OperationCategory.WRITE, false);
-    return 0;
+    return clientProto.addCacheDirective(path, flags);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.modifyCacheDirective(directive, flags);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.removeCacheDirective(id);
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.listCacheDirectives(prevId, filter);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.addCachePool(info);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.modifyCachePool(info);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.removeCachePool(cachePoolName);
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.listCachePools(prevKey);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("modifyAclEntries",
-        new Class<?>[] {String.class, List.class},
-        new RemoteParam(), aclSpec);
-    rpcClient.invokeSequential(locations, method, null, null);
+    clientProto.modifyAclEntries(src, aclSpec);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("removeAclEntries",
-        new Class<?>[] {String.class, List.class},
-        new RemoteParam(), aclSpec);
-    rpcClient.invokeSequential(locations, method, null, null);
+    clientProto.removeAclEntries(src, aclSpec);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("removeDefaultAcl",
-        new Class<?>[] {String.class}, new RemoteParam());
-    rpcClient.invokeSequential(locations, method);
+    clientProto.removeDefaultAcl(src);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("removeAcl",
-        new Class<?>[] {String.class}, new RemoteParam());
-    rpcClient.invokeSequential(locations, method);
+    clientProto.removeAcl(src);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod(
-        "setAcl", new Class<?>[] {String.class, List.class},
-        new RemoteParam(), aclSpec);
-    rpcClient.invokeSequential(locations, method);
+    clientProto.setAcl(src, aclSpec);
-    checkOperation(OperationCategory.READ);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("getAclStatus",
-        new Class<?>[] {String.class}, new RemoteParam());
-    return (AclStatus) rpcClient.invokeSequential(
-        locations, method, AclStatus.class, null);
+    return clientProto.getAclStatus(src);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("createEncryptionZone",
-        new Class<?>[] {String.class, String.class},
-        new RemoteParam(), keyName);
-    rpcClient.invokeSequential(locations, method);
+    clientProto.createEncryptionZone(src, keyName);
-    checkOperation(OperationCategory.READ);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("getEZForPath",
-        new Class<?>[] {String.class}, new RemoteParam());
-    return (EncryptionZone) rpcClient.invokeSequential(
-        locations, method, EncryptionZone.class, null);
+    return clientProto.getEZForPath(src);
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.listEncryptionZones(prevId);
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.reencryptEncryptionZone(zone, action);
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.listReencryptionStatus(prevId);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("setXAttr",
-        new Class<?>[] {String.class, XAttr.class, EnumSet.class},
-        new RemoteParam(), xAttr, flag);
-    rpcClient.invokeSequential(locations, method);
+    clientProto.setXAttr(src, xAttr, flag);
-  @SuppressWarnings("unchecked")
-    checkOperation(OperationCategory.READ);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("getXAttrs",
-        new Class<?>[] {String.class, List.class}, new RemoteParam(), xAttrs);
-    return (List<XAttr>) rpcClient.invokeSequential(
-        locations, method, List.class, null);
+    return clientProto.getXAttrs(src, xAttrs);
-  @SuppressWarnings("unchecked")
-    checkOperation(OperationCategory.READ);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, false);
-    RemoteMethod method = new RemoteMethod("listXAttrs",
-        new Class<?>[] {String.class}, new RemoteParam());
-    return (List<XAttr>) rpcClient.invokeSequential(
-        locations, method, List.class, null);
+    return clientProto.listXAttrs(src);
-    checkOperation(OperationCategory.WRITE);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(src, true);
-    RemoteMethod method = new RemoteMethod("removeXAttr",
-        new Class<?>[] {String.class, XAttr.class}, new RemoteParam(), xAttr);
-    rpcClient.invokeSequential(locations, method);
+    clientProto.removeXAttr(src, xAttr);
-    checkOperation(OperationCategory.READ);
-
-    // TODO handle virtual directories
-    final List<RemoteLocation> locations = getLocationsForPath(path, true);
-    RemoteMethod method = new RemoteMethod("checkAccess",
-        new Class<?>[] {String.class, FsAction.class},
-        new RemoteParam(), mode);
-    rpcClient.invokeSequential(locations, method);
+    clientProto.checkAccess(path, mode);
-    checkOperation(OperationCategory.READ);
-
-    RemoteMethod method = new RemoteMethod(
-        "getCurrentEditLogTxid", new Class<?>[] {});
-    final Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();
-    Map<FederationNamespaceInfo, Long> ret =
-        rpcClient.invokeConcurrent(nss, method, true, false, long.class);
-
-    // Return the maximum txid
-    long txid = 0;
-    for (long t : ret.values()) {
-      if (t > txid) {
-        txid = t;
-      }
-    }
-    return txid;
+    return clientProto.getCurrentEditLogTxid();
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.getEditsFromTxid(txid);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.getDataEncryptionKey();
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.WRITE);
-    return null;
+    return clientProto.createSnapshot(snapshotRoot, snapshotName);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.deleteSnapshot(snapshotRoot, snapshotName);
-    this.quotaCall.setQuota(path, namespaceQuota, storagespaceQuota, type);
+    clientProto.setQuota(path, namespaceQuota, storagespaceQuota, type);
-    return this.quotaCall.getQuotaUsage(path);
+    return clientProto.getQuotaUsage(path);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.WRITE);
-
-    // Block pool id -> blocks
-    Map<String, List<LocatedBlock>> blockLocations = new HashMap<>();
-    for (LocatedBlock block : blocks) {
-      String bpId = block.getBlock().getBlockPoolId();
-      List<LocatedBlock> bpBlocks = blockLocations.get(bpId);
-      if (bpBlocks == null) {
-        bpBlocks = new LinkedList<>();
-        blockLocations.put(bpId, bpBlocks);
-      }
-      bpBlocks.add(block);
-    }
-
-    // Invoke each block pool
-    for (Entry<String, List<LocatedBlock>> entry : blockLocations.entrySet()) {
-      String bpId = entry.getKey();
-      List<LocatedBlock> bpBlocks = entry.getValue();
-
-      LocatedBlock[] bpBlocksArray =
-          bpBlocks.toArray(new LocatedBlock[bpBlocks.size()]);
-      RemoteMethod method = new RemoteMethod("reportBadBlocks",
-          new Class<?>[] {LocatedBlock[].class},
-          new Object[] {bpBlocksArray});
-      rpcClient.invokeSingleBlockPool(bpId, method);
-    }
+    clientProto.reportBadBlocks(blocks);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.WRITE, false);
+    clientProto.unsetStoragePolicy(src);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.getStoragePolicy(path);
-    return erasureCoding.getErasureCodingPolicies();
+    return clientProto.getErasureCodingPolicies();
-    return erasureCoding.getErasureCodingCodecs();
+    return clientProto.getErasureCodingCodecs();
-    return erasureCoding.addErasureCodingPolicies(policies);
+    return clientProto.addErasureCodingPolicies(policies);
-    erasureCoding.removeErasureCodingPolicy(ecPolicyName);
+    clientProto.removeErasureCodingPolicy(ecPolicyName);
-    erasureCoding.disableErasureCodingPolicy(ecPolicyName);
+    clientProto.disableErasureCodingPolicy(ecPolicyName);
-    erasureCoding.enableErasureCodingPolicy(ecPolicyName);
+    clientProto.enableErasureCodingPolicy(ecPolicyName);
-    return erasureCoding.getErasureCodingPolicy(src);
+    return clientProto.getErasureCodingPolicy(src);
-    erasureCoding.setErasureCodingPolicy(src, ecPolicyName);
+    clientProto.setErasureCodingPolicy(src, ecPolicyName);
-    erasureCoding.unsetErasureCodingPolicy(src);
+    clientProto.unsetErasureCodingPolicy(src);
-  @Override
+  @Override // ClientProtocol
-    return erasureCoding.getECBlockGroupStats();
+    return clientProto.getECBlockGroupStats();
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.getReplicatedBlockStats();
-  @Override
+  @Override // ClientProtocol
-    return listOpenFiles(prevId, EnumSet.of(OpenFilesType.ALL_OPEN_FILES),
-        OpenFilesIterator.FILTER_PATH_DEFAULT);
+    return clientProto.listOpenFiles(prevId);
-  @Override
+  @Override // ClientProtocol
-    checkOperation(OperationCategory.READ, false);
-    return null;
+    return clientProto.listOpenFiles(prevId, openFilesTypes, path);
+  }
+
+  @Override // ClientProtocol
+  public void satisfyStoragePolicy(String path) throws IOException {
+    clientProto.satisfyStoragePolicy(path);
+  @Override // NamenodeProtocol
+  public Long getNextSPSPath() throws IOException {
+    return nnProto.getNextSPSPath();
+  }
+
-  private RemoteLocation getLocationForPath(
+  protected RemoteLocation getLocationForPath(
-   * Check if a path should be in all subclusters.
-   *
-   * @param path Path to check.
-   * @return If a path should be in all subclusters.
-   */
-  private boolean isPathAll(final String path) {
-    if (subclusterResolver instanceof MountTableResolver) {
-      try {
-        MountTableResolver mountTable = (MountTableResolver)subclusterResolver;
-        MountTable entry = mountTable.getMountPoint(path);
-        if (entry != null) {
-          return entry.isAll();
-        }
-      } catch (IOException e) {
-        LOG.error("Cannot get mount point", e);
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Get the modification dates for mount points.
-   *
-   * @param path Name of the path to start checking dates from.
-   * @return Map with the modification dates for all sub-entries.
-   */
-  private Map<String, Long> getMountPointDates(String path) {
-    Map<String, Long> ret = new TreeMap<>();
-    if (subclusterResolver instanceof MountTableResolver) {
-      try {
-        final List<String> children = subclusterResolver.getMountPoints(path);
-        for (String child : children) {
-          Long modTime = getModifiedTime(ret, path, child);
-          ret.put(child, modTime);
-        }
-      } catch (IOException e) {
-        LOG.error("Cannot get mount point", e);
-      }
-    }
-    return ret;
-  }
-
-  /**
-   * Get modified time for child. If the child is present in mount table it
-   * will return the modified time. If the child is not present but subdirs of
-   * this child are present then it will return latest modified subdir's time
-   * as modified time of the requested child.
-   * @param ret contains children and modified times.
-   * @param mountTable.
-   * @param path Name of the path to start checking dates from.
-   * @param child child of the requested path.
-   * @return modified time.
-   */
-  private long getModifiedTime(Map<String, Long> ret, String path,
-      String child) {
-    MountTableResolver mountTable = (MountTableResolver)subclusterResolver;
-    String srcPath;
-    if (path.equals(Path.SEPARATOR)) {
-      srcPath = Path.SEPARATOR + child;
-    } else {
-      srcPath = path + Path.SEPARATOR + child;
-    }
-    Long modTime = 0L;
-    try {
-      // Get mount table entry for the srcPath
-      MountTable entry = mountTable.getMountPoint(srcPath);
-      // if srcPath is not in mount table but its subdirs are in mount
-      // table we will display latest modified subdir date/time.
-      if (entry == null) {
-        List<MountTable> entries = mountTable.getMounts(srcPath);
-        for (MountTable eachEntry : entries) {
-          // Get the latest date
-          if (ret.get(child) == null ||
-              ret.get(child) < eachEntry.getDateModified()) {
-            modTime = eachEntry.getDateModified();
-          }
-        }
-      } else {
-        modTime = entry.getDateModified();
-      }
-    } catch (IOException e) {
-      LOG.error("Cannot get mount point", e);
-    }
-    return modTime;
-  }
-
-  /**
-   * Create a new file status for a mount point.
-   *
-   * @param name Name of the mount point.
-   * @param childrenNum Number of children.
-   * @param date Map with the dates.
-   * @return New HDFS file status representing a mount point.
-   */
-  private HdfsFileStatus getMountPointStatus(
-      String name, int childrenNum, long date) {
-    long modTime = date;
-    long accessTime = date;
-    FsPermission permission = FsPermission.getDirDefault();
-    String owner = this.superUser;
-    String group = this.superGroup;
-    try {
-      // TODO support users, it should be the user for the pointed folder
-      UserGroupInformation ugi = getRemoteUser();
-      owner = ugi.getUserName();
-      group = ugi.getPrimaryGroupName();
-    } catch (IOException e) {
-      LOG.error("Cannot get the remote user: {}", e.getMessage());
-    }
-    long inodeId = 0;
-    return new HdfsFileStatus.Builder()
-      .isdir(true)
-      .mtime(modTime)
-      .atime(accessTime)
-      .perm(permission)
-      .owner(owner)
-      .group(group)
-      .symlink(new byte[0])
-      .path(DFSUtil.string2Bytes(name))
-      .fileId(inodeId)
-      .children(childrenNum)
-      .build();
-  }
-
-  /**
-   * Get the name of the method that is calling this function.
-   *
-   * @return Name of the method calling this function.
-   */
-  private static String getMethodName() {
-    final StackTraceElement[] stack = Thread.currentThread().getStackTrace();
-    String methodName = stack[3].getMethodName();
-    return methodName;
-  }
-
-  /**
-
-  @Override
-  public void satisfyStoragePolicy(String path) throws IOException {
-    checkOperation(OperationCategory.WRITE, false);
-  }
-
-  @Override
-  public Long getNextSPSPath() throws IOException {
-    checkOperation(OperationCategory.READ, false);
-    // not supported
-    return null;
-  }

MOV26 MOV23 MOV31 MOV31 MOV31 MOV31 UPD43 MOV21 INS43 UPD42 MOV78 MOV44 MOV78 MOV44 MOV43 MOV78 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV43 MOV78 MOV44 MOV43 MOV78 MOV78 MOV43 INS8 MOV78 MOV44 MOV43 MOV78 MOV43 MOV78 MOV44 MOV43 INS8 MOV78 MOV44 MOV43 MOV78 MOV43 MOV44 MOV43 MOV78 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV43 MOV78 MOV43 MOV78 MOV78 MOV43 MOV78 MOV44 MOV43 MOV78 MOV43 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV44 MOV43 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV43 MOV78 MOV43 MOV44 MOV43 MOV78 MOV44 MOV44 MOV43 INS8 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV44 MOV43 MOV78 MOV78 MOV43 MOV78 MOV44 MOV43 MOV78 MOV43 MOV43 UPD83 UPD42 UPD42 UPD42 MOV42 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS21 INS21 INS41 INS41 INS21 INS41 INS21 INS41 INS21 INS41 MOV41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS21 INS21 INS21 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS41 INS21 INS41 INS41 INS41 INS41 MOV21 INS41 INS41 INS41 INS41 UPD66 UPD66 INS42 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 INS42 UPD42 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 UPD42 MOV42 INS42 MOV42 INS42 UPD42 MOV42 INS42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 INS42 MOV42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 UPD42 MOV42 INS42 MOV42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 MOV42 INS42 UPD42 UPD43 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL42 DEL45 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL40 DEL40 DEL32 DEL7 DEL21 DEL42 DEL65 DEL66 DEL65 DEL42 DEL65 DEL42 DEL43 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL43 DEL42 DEL44 DEL42 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL83 DEL83 DEL83 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL40 DEL9 DEL32 DEL21 DEL34 DEL41 DEL40 DEL9 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL27 DEL39 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL38 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL39 DEL57 DEL39 DEL57 DEL39 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL41 DEL66 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL41 DEL8 DEL31 DEL83 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL41 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL40 DEL32 DEL59 DEL60 DEL39 DEL42 DEL11 DEL41 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL40 DEL32 DEL59 DEL60 DEL39 DEL42 DEL11 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL33 DEL33 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL11 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL39 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL41 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL39 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL41 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL42 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL36 DEL42 DEL32 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL32 DEL11 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL4 DEL3 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL36 DEL42 DEL32 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL41 DEL8 DEL25 DEL8 DEL70 DEL33 DEL41 DEL8 DEL31 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL9 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL40 DEL32 DEL11 DEL36 DEL42 DEL32 DEL41 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL9 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL32 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL33 DEL33 DEL32 DEL21 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL34 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL34 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL45 DEL45 DEL42 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL70 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL9 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL40 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL9 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL85 DEL5 DEL57 DEL4 DEL3 DEL42 DEL42 DEL32 DEL42 DEL14 DEL59 DEL60 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL40 DEL32 DEL11 DEL36 DEL42 DEL32 DEL41 DEL42 DEL42 DEL43 DEL57 DEL40 DEL32 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL8 DEL25 DEL8 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL9 DEL9 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL32 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL42 DEL43 DEL57 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL27 DEL2 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL70 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL9 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL37 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL25 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL25 DEL42 DEL38 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL33 DEL41 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL41 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL41 DEL8 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL42 DEL41 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL8 DEL31 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL43 DEL57 DEL40 DEL32 DEL11 DEL36 DEL42 DEL32 DEL42 DEL43 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL39 DEL85 DEL5 DEL74 DEL42 DEL42 DEL42 DEL9 DEL9 DEL39 DEL85 DEL5 DEL57 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL3 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL34 DEL27 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL7 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL70 DEL42 DEL41 DEL42 DEL40 DEL32 DEL21 DEL9 DEL34 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL85 DEL5 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL70 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL41 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL42 DEL38 DEL42 DEL43 DEL57 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL37 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL27 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL9 DEL42 DEL43 DEL57 DEL32 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL38 DEL42 DEL9 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL42 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL39 DEL57 DEL32 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL38 DEL42 DEL9 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL4 DEL3 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL9 DEL39 DEL57 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL4 DEL3 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL9 DEL9 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL4 DEL3 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL9 DEL9 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL42 DEL43 DEL57 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL9 DEL9 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL9 DEL9 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL42 DEL43 DEL57 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL12 DEL54 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL70 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL27 DEL42 DEL53 DEL8 DEL25 DEL42 DEL42 DEL32 DEL41 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL70 DEL42 DEL43 DEL42 DEL40 DEL43 DEL14 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL41 DEL8 DEL31 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL42 DEL43 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL39 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL39 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL32 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL40 DEL9 DEL40 DEL9 DEL40 DEL9 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL40 DEL9 DEL32 DEL21 DEL34 DEL41 DEL40 DEL9 DEL40 DEL9 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL40 DEL9 DEL40 DEL9 DEL40 DEL9 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL33 DEL33 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL33 DEL33 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL40 DEL9 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL45 DEL79 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL42 DEL45 DEL79 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL57 DEL33 DEL32 DEL11 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL40 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL42 DEL43 DEL14 DEL42 DEL14 DEL59 DEL60 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL4 DEL3 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL9 DEL9 DEL39 DEL57 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL42 DEL43 DEL40 DEL32 DEL21 DEL33 DEL41 DEL42 DEL43 DEL40 DEL9 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL57 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL40 DEL9 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL42 DEL43 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL42 DEL43 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL42 DEL43 DEL42 DEL44 DEL40 DEL9 DEL42 DEL43 DEL40 DEL9 DEL32 DEL21 DEL33 DEL41 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL42 DEL40 DEL42 DEL27 DEL7 DEL21 DEL8 DEL42 DEL42 DEL40 DEL42 DEL27 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL54 DEL39 DEL42 DEL34 DEL59 DEL60 DEL40 DEL43 DEL14 DEL42 DEL9 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL39 DEL85 DEL5 DEL34 DEL3 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL31
HDFS-12681. Make HdfsLocatedFileStatus a subtype of LocatedFileStatus

+import java.io.ObjectInputValidation;
+import java.io.Serializable;
+import java.util.Set;
+import org.apache.hadoop.fs.FileStatus.AttrFlags;
+import org.apache.hadoop.io.Writable;
-/** Interface that represents the over the wire information for a file.
+/**
+ * HDFS metadata for an entity in the filesystem.
-public class HdfsFileStatus extends FileStatus {
+public interface HdfsFileStatus
+    extends Writable, Comparable<Object>, Serializable, ObjectInputValidation {
-  private static final long serialVersionUID = 0x126eb82a;
+  byte[] EMPTY_NAME = new byte[0];
-  // local name of the inode that's encoded in java UTF8
-  private byte[] uPath;
-  private byte[] uSymlink; // symlink target encoded in java UTF8/null
-  private final long fileId;
-  private final FileEncryptionInfo feInfo;
-  private final ErasureCodingPolicy ecPolicy;
-
-  // Used by dir, not including dot and dotdot. Always zero for a regular file.
-  private final int childrenNum;
-  private final byte storagePolicy;
-
-  public static final byte[] EMPTY_NAME = new byte[0];
-
-  /**
-   * Set of features potentially active on an instance.
-   */
-  public enum Flags {
+  /** Set of features potentially active on an instance. */
+  enum Flags {
-  private final EnumSet<Flags> flags;
-
-  /**
-   * Constructor.
-   * @param length the number of bytes the file has
-   * @param isdir if the path is a directory
-   * @param replication the replication factor
-   * @param blocksize the block size
-   * @param mtime modification time
-   * @param atime access time
-   * @param permission permission
-   * @param owner the owner of the path
-   * @param group the group of the path
-   * @param symlink symlink target encoded in java UTF8 or null
-   * @param path the local name in java UTF8 encoding the same as that in-memory
-   * @param fileId the file id
-   * @param childrenNum the number of children. Used by directory.
-   * @param feInfo the file's encryption info
-   * @param storagePolicy ID which specifies storage policy
-   * @param ecPolicy the erasure coding policy
-   */
-  protected HdfsFileStatus(long length, boolean isdir, int replication,
-                         long blocksize, long mtime, long atime,
-                         FsPermission permission, EnumSet<Flags> flags,
-                         String owner, String group,
-                         byte[] symlink, byte[] path, long fileId,
-                         int childrenNum, FileEncryptionInfo feInfo,
-                         byte storagePolicy, ErasureCodingPolicy ecPolicy) {
-    super(length, isdir, replication, blocksize, mtime,
-        atime, convert(isdir, symlink != null, permission, flags),
-        owner, group, null, null,
-        flags.contains(Flags.HAS_ACL), flags.contains(Flags.HAS_CRYPT),
-        flags.contains(Flags.HAS_EC));
-    this.flags = flags;
-    this.uSymlink = symlink;
-    this.uPath = path;
-    this.fileId = fileId;
-    this.childrenNum = childrenNum;
-    this.feInfo = feInfo;
-    this.storagePolicy = storagePolicy;
-    this.ecPolicy = ecPolicy;
-  }
-
-  /**
-   * Set redundant flags for compatibility with existing applications.
-   */
-  protected static FsPermission convert(boolean isdir, boolean symlink,
-      FsPermission p, EnumSet<Flags> f) {
-    if (p instanceof FsPermissionExtension) {
-      // verify flags are set consistently
-      assert p.getAclBit() == f.contains(HdfsFileStatus.Flags.HAS_ACL);
-      assert p.getEncryptedBit() == f.contains(HdfsFileStatus.Flags.HAS_CRYPT);
-      assert p.getErasureCodedBit() == f.contains(HdfsFileStatus.Flags.HAS_EC);
-      return p;
-    }
-    if (null == p) {
-      if (isdir) {
-        p = FsPermission.getDirDefault();
-      } else if (symlink) {
-        p = FsPermission.getDefault();
-      } else {
-        p = FsPermission.getFileDefault();
-      }
-    }
-    return new FsPermissionExtension(p, f.contains(Flags.HAS_ACL),
-        f.contains(Flags.HAS_CRYPT), f.contains(Flags.HAS_EC));
-  }
-
-  @Override
-  public boolean isSymlink() {
-    return uSymlink != null;
-  }
-
-  @Override
-  public boolean hasAcl() {
-    return flags.contains(Flags.HAS_ACL);
-  }
-
-  @Override
-  public boolean isEncrypted() {
-    return flags.contains(Flags.HAS_CRYPT);
-  }
-
-  @Override
-  public boolean isErasureCoded() {
-    return flags.contains(Flags.HAS_EC);
-  }
-
-  /**
-   * Check if the local name is empty.
-   * @return true if the name is empty
-   */
-  public final boolean isEmptyLocalName() {
-    return uPath.length == 0;
-  }
-
-  /**
-   * Get the string representation of the local name.
-   * @return the local name in string
-   */
-  public final String getLocalName() {
-    return DFSUtilClient.bytes2String(uPath);
-  }
-
-  /**
-   * Get the Java UTF8 representation of the local name.
-   * @return the local name in java UTF8
-   */
-  public final byte[] getLocalNameInBytes() {
-    return uPath;
-  }
-
-  /**
-   * Get the string representation of the full path name.
-   * @param parent the parent path
-   * @return the full path in string
-   */
-  public final String getFullName(final String parent) {
-    if (isEmptyLocalName()) {
-      return parent;
-    }
-
-    StringBuilder fullName = new StringBuilder(parent);
-    if (!parent.endsWith(Path.SEPARATOR)) {
-      fullName.append(Path.SEPARATOR);
-    }
-    fullName.append(getLocalName());
-    return fullName.toString();
-  }
-
-  /**
-   * Get the full path.
-   * @param parent the parent path
-   * @return the full path
-   */
-  public final Path getFullPath(final Path parent) {
-    if (isEmptyLocalName()) {
-      return parent;
-    }
-
-    return new Path(parent, getLocalName());
-  }
-
-  @Override
-  public Path getSymlink() throws IOException {
-    if (isSymlink()) {
-      return new Path(DFSUtilClient.bytes2String(uSymlink));
-    }
-    throw new IOException("Path " + getPath() + " is not a symbolic link");
-  }
-
-  @Override
-  public void setSymlink(Path sym) {
-    uSymlink = DFSUtilClient.string2Bytes(sym.toString());
-  }
-
-  /**
-   * Opaque referant for the symlink, to be resolved at the client.
-   */
-  public final byte[] getSymlinkInBytes() {
-    return uSymlink;
-  }
-
-  public final long getFileId() {
-    return fileId;
-  }
-
-  public final FileEncryptionInfo getFileEncryptionInfo() {
-    return feInfo;
-  }
-
-  /**
-   * Get the erasure coding policy if it's set.
-   * @return the erasure coding policy
-   */
-  public ErasureCodingPolicy getErasureCodingPolicy() {
-    return ecPolicy;
-  }
-
-  public final int getChildrenNum() {
-    return childrenNum;
-  }
-
-  /** @return the storage policy id */
-  public final byte getStoragePolicy() {
-    return storagePolicy;
-  }
-
-  /**
-   * Check if directory is Snapshot enabled or not.
-   *
-   * @return true if directory is snapshot enabled
-   */
-  public boolean isSnapshotEnabled() {
-    return flags.contains(Flags.SNAPSHOT_ENABLED);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    // satisfy findbugs
-    return super.equals(o);
-  }
-
-  @Override
-  public int hashCode() {
-    // satisfy findbugs
-    return super.hashCode();
-  }
-
-  /**
-   * Resolve the short name of the Path given the URI, parent provided. This
-   * FileStatus reference will not contain a valid Path until it is resolved
-   * by this method.
-   * @param defaultUri FileSystem to fully qualify HDFS path.
-   * @param parent Parent path of this element.
-   * @return Reference to this instance.
-   */
-  public final FileStatus makeQualified(URI defaultUri, Path parent) {
-    // fully-qualify path
-    setPath(getFullPath(parent).makeQualified(defaultUri, null));
-    return this; // API compatibility
-
-  }
-  public static class Builder {
+  class Builder {
+    private LocatedBlocks locations        = null;
+     * Set the block locations for this entity (default = null).
+     * @param locations HDFS locations
+     *       (see {@link HdfsLocatedFileStatus#makeQualifiedLocated(URI, Path)})
+     * @return This Builder instance
+     */
+    public Builder locations(LocatedBlocks locations) {
+      this.locations = locations;
+      return this;
+    }
+
+    /**
-      return new HdfsFileStatus(length, isdir, replication, blocksize,
-          mtime, atime, permission, flags, owner, group, symlink, path, fileId,
-          childrenNum, feInfo, storagePolicy, ecPolicy);
+      if (null == locations && !isdir && null == symlink) {
+        return new HdfsNamedFileStatus(length, isdir, replication, blocksize,
+            mtime, atime, permission, flags, owner, group, symlink, path,
+            fileId, childrenNum, feInfo, storagePolicy, ecPolicy);
+      }
+      return new HdfsLocatedFileStatus(length, isdir, replication, blocksize,
+          mtime, atime, permission, flags, owner, group, symlink, path,
+          fileId, childrenNum, feInfo, storagePolicy, ecPolicy, locations);
+
+  }
+
+  ///////////////////
+  // HDFS-specific //
+  ///////////////////
+
+  /**
+   * Inode ID for this entity, if a file.
+   * @return inode ID.
+   */
+  long getFileId();
+
+  /**
+   * Get metadata for encryption, if present.
+   * @return the {@link FileEncryptionInfo} for this stream, or null if not
+   *         encrypted.
+   */
+  FileEncryptionInfo getFileEncryptionInfo();
+
+  /**
+   * Check if the local name is empty.
+   * @return true if the name is empty
+   */
+  default boolean isEmptyLocalName() {
+    return getLocalNameInBytes().length == 0;
+  }
+
+  /**
+   * Get the string representation of the local name.
+   * @return the local name in string
+   */
+  default String getLocalName() {
+    return DFSUtilClient.bytes2String(getLocalNameInBytes());
+  }
+
+  /**
+   * Get the Java UTF8 representation of the local name.
+   * @return the local name in java UTF8
+   */
+  byte[] getLocalNameInBytes();
+
+  /**
+   * Get the string representation of the full path name.
+   * @param parent the parent path
+   * @return the full path in string
+   */
+  default String getFullName(String parent) {
+    if (isEmptyLocalName()) {
+      return parent;
+    }
+
+    StringBuilder fullName = new StringBuilder(parent);
+    if (!parent.endsWith(Path.SEPARATOR)) {
+      fullName.append(Path.SEPARATOR);
+    }
+    fullName.append(getLocalName());
+    return fullName.toString();
+  }
+
+  /**
+   * Get the full path.
+   * @param parent the parent path
+   * @return the full path
+   */
+  default Path getFullPath(Path parent) {
+    if (isEmptyLocalName()) {
+      return parent;
+    }
+
+    return new Path(parent, getLocalName());
+  }
+
+  /**
+   * Opaque referant for the symlink, to be resolved at the client.
+   */
+  byte[] getSymlinkInBytes();
+
+  /**
+   * @return number of children for this inode.
+   */
+  int getChildrenNum();
+
+  /**
+   * Get the erasure coding policy if it's set.
+   * @return the erasure coding policy
+   */
+  ErasureCodingPolicy getErasureCodingPolicy();
+
+  /** @return the storage policy id */
+  byte getStoragePolicy();
+
+  /**
+   * Resolve the short name of the Path given the URI, parent provided. This
+   * FileStatus reference will not contain a valid Path until it is resolved
+   * by this method.
+   * @param defaultUri FileSystem to fully qualify HDFS path.
+   * @param parent Parent path of this element.
+   * @return Reference to this instance.
+   */
+  default FileStatus makeQualified(URI defaultUri, Path parent) {
+    // fully-qualify path
+    setPath(getFullPath(parent).makeQualified(defaultUri, null));
+    return (FileStatus) this; // API compatibility
+  }
+
+  ////////////////////////////
+  // FileStatus "overrides" //
+  ////////////////////////////
+
+  /**
+   * See {@link FileStatus#getPath()}.
+   */
+  Path getPath();
+  /**
+   * See {@link FileStatus#setPath(Path)}.
+   */
+  void setPath(Path p);
+  /**
+   * See {@link FileStatus#getLen()}.
+   */
+  long getLen();
+  /**
+   * See {@link FileStatus#isFile()}.
+   */
+  boolean isFile();
+  /**
+   * See {@link FileStatus#isDirectory()}.
+   */
+  boolean isDirectory();
+  /**
+   * See {@link FileStatus#isDir()}.
+   */
+  boolean isDir();
+  /**
+   * See {@link FileStatus#isSymlink()}.
+   */
+  boolean isSymlink();
+  /**
+   * See {@link FileStatus#getBlockSize()}.
+   */
+  long getBlockSize();
+  /**
+   * See {@link FileStatus#getReplication()}.
+   */
+  short getReplication();
+  /**
+   * See {@link FileStatus#getModificationTime()}.
+   */
+  long getModificationTime();
+  /**
+   * See {@link FileStatus#getAccessTime()}.
+   */
+  long getAccessTime();
+  /**
+   * See {@link FileStatus#getPermission()}.
+   */
+  FsPermission getPermission();
+  /**
+   * See {@link FileStatus#setPermission(FsPermission)}.
+   */
+  void setPermission(FsPermission permission);
+  /**
+   * See {@link FileStatus#getOwner()}.
+   */
+  String getOwner();
+  /**
+   * See {@link FileStatus#setOwner(String)}.
+   */
+  void setOwner(String owner);
+  /**
+   * See {@link FileStatus#getGroup()}.
+   */
+  String getGroup();
+  /**
+   * See {@link FileStatus#setGroup(String)}.
+   */
+  void setGroup(String group);
+  /**
+   * See {@link FileStatus#hasAcl()}.
+   */
+  boolean hasAcl();
+  /**
+   * See {@link FileStatus#isEncrypted()}.
+   */
+  boolean isEncrypted();
+  /**
+   * See {@link FileStatus#isErasureCoded()}.
+   */
+  boolean isErasureCoded();
+  /**
+   * See {@link FileStatus#isSnapshotEnabled()}.
+   */
+  boolean isSnapshotEnabled();
+  /**
+   * See {@link FileStatus#getSymlink()}.
+   */
+  Path getSymlink() throws IOException;
+  /**
+   * See {@link FileStatus#setSymlink(Path sym)}.
+   */
+  void setSymlink(Path sym);
+  /**
+   * See {@link FileStatus#compareTo(FileStatus)}.
+   */
+  int compareTo(FileStatus stat);
+
+  /**
+   * Set redundant flags for compatibility with existing applications.
+   */
+  static FsPermission convert(boolean isdir, boolean symlink,
+                              FsPermission p, Set<Flags> f) {
+    if (p instanceof FsPermissionExtension) {
+      // verify flags are set consistently
+      assert p.getAclBit() == f.contains(HdfsFileStatus.Flags.HAS_ACL);
+      assert p.getEncryptedBit() == f.contains(HdfsFileStatus.Flags.HAS_CRYPT);
+      assert p.getErasureCodedBit() == f.contains(HdfsFileStatus.Flags.HAS_EC);
+      return p;
+    }
+    if (null == p) {
+      if (isdir) {
+        p = FsPermission.getDirDefault();
+      } else if (symlink) {
+        p = FsPermission.getDefault();
+      } else {
+        p = FsPermission.getFileDefault();
+      }
+    }
+    return new FsPermissionExtension(p, f.contains(Flags.HAS_ACL),
+        f.contains(Flags.HAS_CRYPT), f.contains(Flags.HAS_EC));
+  }
+
+  static Set<AttrFlags> convert(Set<Flags> flags) {
+    if (flags.isEmpty()) {
+      return FileStatus.NONE;
+    }
+    EnumSet<AttrFlags> attr = EnumSet.noneOf(AttrFlags.class);
+    if (flags.contains(Flags.HAS_ACL)) {
+      attr.add(AttrFlags.HAS_ACL);
+    }
+    if (flags.contains(Flags.HAS_EC)) {
+      attr.add(AttrFlags.HAS_EC);
+    }
+    if (flags.contains(Flags.HAS_CRYPT)) {
+      attr.add(AttrFlags.HAS_CRYPT);
+    }
+    if (flags.contains(Flags.SNAPSHOT_ENABLED)) {
+      attr.add(AttrFlags.SNAPSHOT_ENABLED);
+    }
+    return attr;

INS26 INS26 INS26 INS26 INS26 MOV31 MOV31 MOV31 MOV55 INS40 INS40 INS40 INS40 INS40 INS43 INS74 INS43 INS43 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 INS43 MOV43 INS42 INS42 INS42 INS23 INS31 INS29 INS39 INS42 INS29 MOV43 INS42 MOV29 INS83 INS39 INS42 INS8 MOV29 INS83 MOV43 INS42 INS8 UPD83 UPD83 INS29 INS39 INS42 MOV29 INS39 INS42 UPD83 INS29 MOV43 INS42 INS29 INS39 INS42 INS44 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS43 INS42 INS29 INS39 INS42 MOV44 INS29 MOV43 INS42 INS29 INS39 INS42 MOV44 INS29 INS43 INS42 INS29 UPD39 MOV39 UPD42 MOV42 MOV44 INS29 MOV39 MOV42 INS29 INS29 MOV39 UPD42 MOV42 INS29 INS39 INS42 INS29 MOV43 INS42 MOV43 INS29 MOV39 MOV42 MOV44 INS29 INS39 INS42 INS44 UPD83 MOV83 INS74 UPD42 MOV42 MOV44 INS8 UPD66 INS42 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS44 INS8 INS8 INS65 INS65 INS65 INS65 INS41 INS41 INS43 INS43 INS65 INS41 INS65 INS65 INS43 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS65 INS65 INS65 INS65 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS74 INS43 INS43 UPD74 INS25 INS60 INS25 INS25 INS25 INS25 MOV41 UPD66 INS42 INS42 INS33 INS65 INS65 INS65 INS42 INS43 INS42 INS21 MOV41 INS25 INS41 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS27 INS32 INS42 INS42 INS66 INS11 INS66 INS65 UPD66 MOV66 UPD66 MOV66 INS65 UPD66 MOV66 INS42 UPD66 MOV66 INS65 UPD66 MOV66 UPD66 MOV66 INS65 UPD66 MOV66 UPD66 MOV66 INS65 UPD66 MOV66 UPD66 MOV66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS43 MOV43 INS42 INS42 UPD43 INS32 INS8 UPD74 MOV74 INS59 MOV32 INS8 MOV32 INS8 MOV32 INS8 MOV32 INS8 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS42 INS7 INS27 INS8 INS14 INS42 INS22 INS34 INS42 INS42 INS32 MOV43 INS52 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS42 UPD42 INS42 INS42 MOV41 INS43 INS42 INS32 INS21 INS21 INS21 INS21 INS68 INS22 INS42 INS27 INS27 MOV41 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS69 INS40 INS42 INS42 INS42 INS57 INS32 INS32 INS32 INS32 INS42 INS42 INS69 INS69 INS52 INS42 INS27 INS38 INS33 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS43 INS42 INS43 INS43 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS40 INS43 MOV43 INS33 INS42 INS42 UPD43 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL39 DEL85 DEL5 DEL42 DEL59 DEL23 DEL83 DEL39 DEL85 DEL5 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL8 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL23 DEL65 DEL42 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL33 DEL33 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL46 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL33 DEL27 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL40 DEL34 DEL27 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL41 DEL8 DEL83 DEL83 DEL83 DEL83 DEL42 DEL78 DEL83 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL14 DEL41 DEL8 DEL25 DEL43 DEL45 DEL42 DEL32 DEL45 DEL27 DEL14 DEL53 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL31 DEL83 DEL83 DEL42 DEL41 DEL8 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL41 DEL8 DEL31 DEL83 DEL42 DEL41 DEL8 DEL83 DEL83 DEL39 DEL42 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL42 DEL48 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL83 DEL42 DEL78 DEL83 DEL41 DEL8 DEL83 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL83 DEL42 DEL42 DEL48
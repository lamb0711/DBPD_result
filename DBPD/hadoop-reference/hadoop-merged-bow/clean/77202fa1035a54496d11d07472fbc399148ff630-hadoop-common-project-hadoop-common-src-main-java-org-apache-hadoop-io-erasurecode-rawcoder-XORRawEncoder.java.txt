HADOOP-13010. Refactor raw erasure coders. Contributed by Kai Zheng

-import java.nio.ByteBuffer;
-
+import org.apache.hadoop.io.erasurecode.ErasureCoderOptions;
+
+import java.nio.ByteBuffer;
-public class XORRawEncoder extends AbstractRawErasureEncoder {
+public class XORRawEncoder extends RawErasureEncoder {
-  public XORRawEncoder(int numDataUnits, int numParityUnits) {
-    super(numDataUnits, numParityUnits);
+  public XORRawEncoder(ErasureCoderOptions coderOptions) {
+    super(coderOptions);
-  protected void doEncode(ByteBuffer[] inputs, ByteBuffer[] outputs) {
-    ByteBuffer output = outputs[0];
+  protected void doEncode(ByteBufferEncodingState encodingState) {
+    CoderUtil.resetOutputBuffers(encodingState.outputs,
+        encodingState.encodeLength);
+    ByteBuffer output = encodingState.outputs[0];
-    for (iIdx = inputs[0].position(), oIdx = output.position();
-         iIdx < inputs[0].limit(); iIdx++, oIdx++) {
-      output.put(oIdx, inputs[0].get(iIdx));
+    for (iIdx = encodingState.inputs[0].position(), oIdx = output.position();
+         iIdx < encodingState.inputs[0].limit(); iIdx++, oIdx++) {
+      output.put(oIdx, encodingState.inputs[0].get(iIdx));
-    for (int i = 1; i < inputs.length; i++) {
-      for (iIdx = inputs[i].position(), oIdx = output.position();
-           iIdx < inputs[i].limit();
+    for (int i = 1; i < encodingState.inputs.length; i++) {
+      for (iIdx = encodingState.inputs[i].position(), oIdx = output.position();
+           iIdx < encodingState.inputs[i].limit();
-        output.put(oIdx, (byte) (output.get(oIdx) ^ inputs[i].get(iIdx)));
+        output.put(oIdx, (byte) (output.get(oIdx) ^
+            encodingState.inputs[i].get(iIdx)));
-  protected void doEncode(byte[][] inputs, int[] inputOffsets, int dataLen,
-                          byte[][] outputs, int[] outputOffsets) {
-    byte[] output = outputs[0];
-    resetBuffer(output, outputOffsets[0], dataLen);
+  protected void doEncode(ByteArrayEncodingState encodingState) {
+    int dataLen = encodingState.encodeLength;
+    CoderUtil.resetOutputBuffers(encodingState.outputs,
+        encodingState.outputOffsets, dataLen);
+    byte[] output = encodingState.outputs[0];
-    for (iIdx = inputOffsets[0], oIdx = outputOffsets[0];
-         iIdx < inputOffsets[0] + dataLen; iIdx++, oIdx++) {
-      output[oIdx] = inputs[0][iIdx];
+    for (iIdx = encodingState.inputOffsets[0],
+             oIdx = encodingState.outputOffsets[0];
+         iIdx < encodingState.inputOffsets[0] + dataLen; iIdx++, oIdx++) {
+      output[oIdx] = encodingState.inputs[0][iIdx];
-    for (int i = 1; i < inputs.length; i++) {
-      for (iIdx = inputOffsets[i], oIdx = outputOffsets[0];
-           iIdx < inputOffsets[i] + dataLen; iIdx++, oIdx++) {
-        output[oIdx] ^= inputs[i][iIdx];
+    for (int i = 1; i < encodingState.inputs.length; i++) {
+      for (iIdx = encodingState.inputOffsets[i],
+               oIdx = encodingState.outputOffsets[0];
+           iIdx < encodingState.inputOffsets[i] + dataLen; iIdx++, oIdx++) {
+        output[oIdx] ^= encodingState.inputs[i][iIdx];

MOV26 INS26 INS40 UPD43 UPD42 INS44 INS8 INS8 INS43 UPD42 MOV42 INS43 UPD42 INS21 MOV60 MOV60 MOV24 MOV24 INS43 INS42 INS60 INS21 MOV60 MOV60 MOV24 MOV24 INS42 UPD42 UPD42 MOV42 INS32 MOV43 INS42 INS39 INS59 INS32 INS42 INS42 INS40 INS40 UPD40 INS42 INS40 INS42 INS42 INS40 INS40 INS42 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 DEL39 DEL42 DEL44 DEL39 DEL44 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL85 DEL5 DEL42 DEL44 DEL8 DEL39 DEL85 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL85 DEL85 DEL5 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL21 DEL8
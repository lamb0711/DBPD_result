HDFS-4749. Use INodeId to identify the corresponding directory node in FSImage saving/loading.  Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1475902 13f79535-47bb-0310-9956-ffa450edef68

-import java.nio.ByteBuffer;
+import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map.Entry;
-import org.apache.hadoop.hdfs.DFSUtil;
-      String parentPath = FSImageSerialization.readString(in);
-      final INodeDirectory parent = INodeDirectory.valueOf(
-          namesystem.dir.rootDir.getNode(parentPath, false), parentPath);
+      long inodeId = in.readLong();
+      final INodeDirectory parent = this.namesystem.dir.getInode(inodeId)
+          .asDirectory();
-            = INodeDirectorySnapshottable.valueOf(parent, parentPath);
+            = INodeDirectorySnapshottable.valueOf(parent, parent.getLocalName());
-        namesystem.dir.addToInodeMapUnprotected(inode);
+        if (!inode.isReference()) { // reference node does not have its id
+          namesystem.dir.addToInodeMapUnprotected(inode);
+        }
-    static private final byte[] PATH_SEPARATOR = DFSUtil.string2Bytes(Path.SEPARATOR);
-
-        byte[] byteStore = new byte[4*HdfsConstants.MAX_PATH_LENGTH];
-        ByteBuffer strbuf = ByteBuffer.wrap(byteStore);
-        saveImage(strbuf, fsDir.rootDir, out, null, true);
+        saveImage(fsDir.rootDir, out, true);
-        strbuf = null;
-     * The nonSnapshotPath is a path without snapshot in order to enable buffer
-     * reuse. If the snapshot is not null, we need to compute a snapshot path.
-     * E.g., when nonSnapshotPath is "/test/foo/bar/" and the snapshot is s1 of
-     * /test, we actually want to save image for directory /test/foo/bar/ under
-     * snapshot s1 of /test, and the path to save thus should be
-     * "/test/.snapshot/s1/foo/bar/".
-     * 
-     * @param nonSnapshotPath The path without snapshot related information.
-     * @param snapshot The snapshot associated with the inode that the path 
-     *                 actually leads to.
-     * @return The snapshot path.                
-     */
-    private static String computeSnapshotPath(String nonSnapshotPath, 
-        Snapshot snapshot) {
-      String snapshotParentFullPath = snapshot.getRoot().getParent()
-          .getFullPathName();
-      String snapshotName = snapshot.getRoot().getLocalName();
-      String relativePath = nonSnapshotPath.equals(snapshotParentFullPath) ? 
-          Path.SEPARATOR : nonSnapshotPath.substring(
-               snapshotParentFullPath.length());
-      return Snapshot.getSnapshotPath(snapshotParentFullPath,
-          snapshotName + relativePath);
-    }
-    
-    /**
-     * @param currentDirName A ByteBuffer storing the path leading to the 
-     *                       current node. For a snapshot node, the path is
-     *                       (the snapshot path - ".snapshot/snapshot_name")
-    private void saveImage(ByteBuffer currentDirName, INodeDirectory current,
-        DataOutputStream out, Snapshot snapshot, boolean toSaveSubtree)
-        throws IOException {
-      // 1. Print prefix (parent directory name)
-      int prefixLen = currentDirName.position();
-      if (snapshot == null) {
-        if (prefixLen == 0) {  // root
-          out.writeShort(PATH_SEPARATOR.length);
-          out.write(PATH_SEPARATOR);
-        } else {  // non-root directories
-          out.writeShort(prefixLen);
-          out.write(currentDirName.array(), 0, prefixLen);
-        }
-      } else {
-        String nonSnapshotPath = prefixLen == 0 ? Path.SEPARATOR : DFSUtil
-            .bytes2String(currentDirName.array(), 0, prefixLen);
-        String snapshotFullPath = computeSnapshotPath(nonSnapshotPath, 
-            snapshot);
-        byte[] snapshotFullPathBytes = DFSUtil.string2Bytes(snapshotFullPath);
-        out.writeShort(snapshotFullPathBytes.length);
-        out.write(snapshotFullPathBytes);
-      }
+    private void saveImage(INodeDirectory current, DataOutputStream out,
+        boolean toSaveSubtree) throws IOException {
+      // write the inode id of the directory
+      out.writeLong(current.getId());
-      Map<Snapshot, List<INodeDirectory>> snapshotDirMap = null;
+      List<INodeDirectory> snapshotDirs = null;
-        snapshotDirMap = new HashMap<Snapshot, List<INodeDirectory>>();
-        dirNum += ((INodeDirectoryWithSnapshot) current).
-            getSnapshotDirectory(snapshotDirMap);
+        snapshotDirs = new ArrayList<INodeDirectory>();
+        ((INodeDirectoryWithSnapshot) current).getSnapshotDirectory(
+            snapshotDirs);
+        dirNum += snapshotDirs.size();
-        currentDirName.put(PATH_SEPARATOR).put(child.getLocalNameBytes()); 
-        saveImage(currentDirName, child.asDirectory(), out, snapshot, toSave);
-        currentDirName.position(prefixLen);
+        saveImage(child.asDirectory(), out, toSave);
-      if (snapshotDirMap != null) {
-        for (Entry<Snapshot, List<INodeDirectory>> e : snapshotDirMap.entrySet()) {
-          for (INodeDirectory subDir : e.getValue()) {
-            // make sure we only save the subtree under a reference node once
-            boolean toSave = subDir.getParentReference() != null ? 
-                referenceMap.toProcessSubtree(subDir.getId()) : true;
-            currentDirName.put(PATH_SEPARATOR).put(subDir.getLocalNameBytes());
-            saveImage(currentDirName, subDir, out, e.getKey(), toSave);
-            currentDirName.position(prefixLen);
-          }
+      if (snapshotDirs != null) {
+        for (INodeDirectory subDir : snapshotDirs) {
+          // make sure we only save the subtree under a reference node once
+          boolean toSave = subDir.getParentReference() != null ? 
+              referenceMap.toProcessSubtree(subDir.getId()) : true;
+          saveImage(subDir, out, toSave);

MOV26 UPD40 MOV21 INS39 INS8 MOV21 MOV21 MOV21 MOV74 MOV8 UPD42 INS25 UPD42 UPD42 INS21 UPD42 UPD42 UPD42 INS32 UPD42 INS38 MOV8 UPD42 UPD42 MOV32 INS7 INS42 INS22 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 UPD42 INS42 INS32 INS22 INS42 INS32 INS42 INS42 INS74 INS42 INS42 INS52 INS42 UPD42 MOV42 INS42 UPD43 MOV43 MOV43 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL42 DEL42 DEL40 DEL9 DEL32 DEL83 DEL83 DEL83 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL23 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL34 DEL40 DEL27 DEL3 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL42 DEL33 DEL7 DEL21 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL16 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL41 DEL8 DEL31 DEL42 DEL66 DEL66 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL34 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL34 DEL27 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL34 DEL27 DEL40 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL42 DEL32 DEL16 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL7 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL70 DEL8
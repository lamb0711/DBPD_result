Merge trunk r1595301 to branch

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1595303 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.DataOutputStream;
-import org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.CacheDirectiveInfoProto;
-import org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.CachePoolInfoProto;
+import org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.CacheDirectiveInfoProto;
+import org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.CachePoolInfoProto;
-    if (filter.getId() != null) {
-      throw new IOException("Filtering by ID is unsupported.");
-    }
-      throw new IOException("Filtering by replication is unsupported.");
+      throw new InvalidRequestException(
+          "Filtering by replication is unsupported.");
+
+    // Querying for a single ID
+    final Long id = filter.getId();
+    if (id != null) {
+      if (!directivesById.containsKey(id)) {
+        throw new InvalidRequestException("Did not find requested id " + id);
+      }
+      // Since we use a tailMap on directivesById, setting prev to id-1 gets
+      // us the directive with the id (if present)
+      prevId = id - 1;
+    }
+
+
+      // If the requested ID is present, it should be the first item.
+      // Hitting this case means the ID is not present, or we're on the second
+      // item and should break out.
+      if (id != null &&
+          !(info.getId().equals(id))) {
+        break;
+      }
+  /**
+   * Saves the current state of the CacheManager to the DataOutput. Used
+   * to persist CacheManager state in the FSImage.
+   * @param out DataOutput to persist state
+   * @param sdPath path of the storage directory
+   * @throws IOException
+   */
+  public void saveStateCompat(DataOutputStream out, String sdPath)
+      throws IOException {
+    serializerCompat.save(out, sdPath);
+  }
+
+    private void save(DataOutputStream out, String sdPath) throws IOException {
+      out.writeLong(nextDirectiveId);
+      savePools(out, sdPath);
+      saveDirectives(out, sdPath);
+    }
+
+     * Save cache pools to fsimage
+     */
+    private void savePools(DataOutputStream out,
+        String sdPath) throws IOException {
+      StartupProgress prog = NameNode.getStartupProgress();
+      Step step = new Step(StepType.CACHE_POOLS, sdPath);
+      prog.beginStep(Phase.SAVING_CHECKPOINT, step);
+      prog.setTotal(Phase.SAVING_CHECKPOINT, step, cachePools.size());
+      Counter counter = prog.getCounter(Phase.SAVING_CHECKPOINT, step);
+      out.writeInt(cachePools.size());
+      for (CachePool pool: cachePools.values()) {
+        FSImageSerialization.writeCachePoolInfo(out, pool.getInfo(true));
+        counter.increment();
+      }
+      prog.endStep(Phase.SAVING_CHECKPOINT, step);
+    }
+
+    /*
+     * Save cache entries to fsimage
+     */
+    private void saveDirectives(DataOutputStream out, String sdPath)
+        throws IOException {
+      StartupProgress prog = NameNode.getStartupProgress();
+      Step step = new Step(StepType.CACHE_ENTRIES, sdPath);
+      prog.beginStep(Phase.SAVING_CHECKPOINT, step);
+      prog.setTotal(Phase.SAVING_CHECKPOINT, step, directivesById.size());
+      Counter counter = prog.getCounter(Phase.SAVING_CHECKPOINT, step);
+      out.writeInt(directivesById.size());
+      for (CacheDirective directive : directivesById.values()) {
+        FSImageSerialization.writeCacheDirectiveInfo(out, directive.toInfo());
+        counter.increment();
+      }
+      prog.endStep(Phase.SAVING_CHECKPOINT, step);
+    }
+
+    /**

MOV26 MOV26 INS26 INS40 INS31 MOV25 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS31 INS31 INS31 INS60 INS25 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS21 INS83 INS39 INS42 INS44 INS44 MOV43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 MOV43 INS8 MOV27 INS83 INS43 INS59 INS27 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS32 INS43 INS42 INS43 INS42 INS21 INS21 INS21 INS65 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS21 INS21 INS60 INS21 INS70 INS21 INS43 INS42 INS43 INS42 INS60 INS60 INS21 INS21 INS60 INS21 INS70 INS21 INS42 INS42 MOV32 INS42 INS33 MOV25 INS21 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS32 INS43 INS59 INS32 INS44 INS32 INS8 INS32 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS32 INS43 INS59 INS32 INS44 INS32 INS8 INS32 INS38 INS7 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS40 INS42 INS43 UPD45 INS32 INS42 INS27 INS27 INS38 INS10 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS33 INS36 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS27 INS32 INS42 INS42 INS9 INS42 INS42 INS42 INS45 INS42 INS32 INS42 INS42 INS42 INS42 DEL33 DEL27 DEL45
HDDS-461. Container remains in CLOSING state in SCM forever. Contributed by Shashikant Banerjee.

-import org.apache.hadoop.hdds.protocol.DatanodeDetails;
+import org.apache.hadoop.hdds.scm.container.common.helpers.Pipeline;
-    ContainerWithPipeline containerWithPipeline = null;
+    ContainerWithPipeline containerWithPipeline;
-    if (info.getState() == HddsProtos.LifeCycleState.OPEN) {
-      for (DatanodeDetails datanode :
-          containerWithPipeline.getPipeline().getMachines()) {
-        CommandForDatanode closeContainerCommand = new CommandForDatanode<>(
-            datanode.getUuid(),
-            new CloseContainerCommand(containerID.getId(),
-                info.getReplicationType(), info.getPipelineID()));
-        publisher.fireEvent(DATANODE_COMMAND, closeContainerCommand);
-        publisher.fireEvent(CLOSE_CONTAINER_RETRYABLE_REQ, new
-            CloseContainerRetryableReq(containerID));
-      }
-      try {
-        // Finalize event will make sure the state of the container transitions
-        // from OPEN to CLOSING in containerStateManager.
-        containerManager.updateContainerState(containerID.getId(),
-            HddsProtos.LifeCycleEvent.FINALIZE);
-      } catch (IOException ex) {
-        LOG.error("Failed to update the container state to FINALIZE for"
-            + "container : {}" + containerID, ex);
-      }
-    } else if (info.getState() == HddsProtos.LifeCycleState.ALLOCATED) {
-      try {
-        // Create event will make sure the state of the container transitions
-        // from OPEN to CREATING in containerStateManager, this will move
-        // the container out of active allocation path.
+    HddsProtos.LifeCycleState state = info.getState();
+    try {
+      switch (state) {
+      case ALLOCATED:
+        // We cannot close a container in ALLOCATED state, moving the
+        // container to CREATING state, this should eventually
+        // timeout and the container will be moved to DELETING state.
+        LOG.debug("Closing container {} in {} state", containerID, state);
-      } catch (IOException ex) {
-        LOG.error("Failed to update the container state to CREATE for"
-            + "container:{}" + containerID, ex);
+        break;
+      case CREATING:
+        // We cannot close a container in CREATING state, it will eventually
+        // timeout and moved to DELETING state.
+        LOG.debug("Closing container {} in {} state", containerID, state);
+        break;
+      case OPEN:
+        containerManager.updateContainerState(containerID.getId(),
+            HddsProtos.LifeCycleEvent.FINALIZE);
+        fireCloseContainerEvents(containerWithPipeline, info, publisher);
+        break;
+      case CLOSING:
+        fireCloseContainerEvents(containerWithPipeline, info, publisher);
+        break;
+      case CLOSED:
+      case DELETING:
+      case DELETED:
+        LOG.info(
+            "container with id : {} is in {} state and need not be closed.",
+            containerID.getId(), info.getState());
+        break;
+      default:
+        throw new IOException(
+            "Invalid container state for container " + containerID);
-    } else {
-      LOG.info("container with id : {} is in {} state and need not be closed.",
-          containerID.getId(), info.getState());
+    } catch (IOException ex) {
+      LOG.error("Failed to update the container state for" + "container : {}"
+          + containerID, ex);
+  }
+  private void fireCloseContainerEvents(
+      ContainerWithPipeline containerWithPipeline, ContainerInfo info,
+      EventPublisher publisher) {
+    ContainerID containerID = info.containerID();
+    // fire events.
+    CloseContainerCommand closeContainerCommand =
+        new CloseContainerCommand(containerID.getId(),
+            info.getReplicationType(), info.getPipelineID());
+
+    Pipeline pipeline = containerWithPipeline.getPipeline();
+    pipeline.getMachines().stream().map(
+        datanode -> new CommandForDatanode<>(datanode.getUuid(),
+            closeContainerCommand)).forEach((command) -> {
+              publisher.fireEvent(DATANODE_COMMAND, command);
+            });
+    publisher.fireEvent(CLOSE_CONTAINER_RETRYABLE_REQ,
+        new CloseContainerRetryableReq(containerID));
+    LOG.trace("Issuing {} on Pipeline {} for container", closeContainerCommand,
+        pipeline, containerID);

MOV26 UPD40 INS31 INS83 INS39 INS42 INS44 INS44 INS44 MOV8 INS60 INS54 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS21 INS21 INS43 INS59 INS8 MOV12 INS42 INS42 INS42 INS43 INS59 UPD43 INS43 INS59 INS32 INS32 INS40 INS42 MOV32 INS50 INS42 INS42 INS32 UPD42 MOV14 INS42 INS42 MOV32 INS32 INS42 INS86 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS49 INS21 MOV21 INS10 INS49 INS21 INS10 INS49 MOV21 INS21 INS10 INS49 INS21 INS10 INS49 INS49 INS49 MOV21 INS10 INS49 INS53 INS42 INS42 INS32 INS42 INS86 INS59 INS8 INS42 INS32 INS42 MOV32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS14 INS32 INS42 INS59 MOV14 INS42 MOV21 INS42 INS42 INS45 UPD42 MOV42 INS42 UPD42 INS45 INS42 UPD42 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS45 INS42 UPD45 UPD45 UPD42 DEL33 DEL45 DEL45 DEL42 DEL27 DEL40 DEL27 DEL42 DEL43 DEL42 DEL44 DEL32 DEL70 DEL8 DEL42 DEL43 DEL42 DEL44 DEL21 DEL8 DEL12 DEL54 DEL8 DEL32 DEL40 DEL27 DEL8 DEL54 DEL8 DEL8 DEL25 DEL25
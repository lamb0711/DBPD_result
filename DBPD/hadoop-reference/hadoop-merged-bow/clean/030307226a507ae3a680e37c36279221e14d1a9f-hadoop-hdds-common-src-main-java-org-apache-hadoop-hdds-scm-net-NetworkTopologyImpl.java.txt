HDDS-1586. Allow Ozone RPC client to read with topology awareness. Contributed by Sammi Chen.

+import java.util.ArrayList;
-    LOG.debug("Choosing random from \"{}\" available nodes on node \"{}\"," +
-            " scope=\"{}\", excludedScope=\"{}\", excludeNodes=\"{}\".",
-        availableNodes, scopeNode, scopeNode.getNetworkFullPath(),
-        excludedScope, excludedNodes);
+    int nodeIndex;
-      ret = ((InnerNode)scopeNode).getLeaf(leafIndex % availableNodes,
-          excludedScope, mutableExNodes, ancestorGen);
+      nodeIndex = leafIndex % availableNodes;
+      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, excludedScope,
+          mutableExNodes, ancestorGen);
-      final int index = ThreadLocalRandom.current().nextInt(availableNodes);
-      ret = ((InnerNode)scopeNode).getLeaf(index, excludedScope, mutableExNodes,
-          ancestorGen);
+      nodeIndex = ThreadLocalRandom.current().nextInt(availableNodes);
+      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, excludedScope,
+          mutableExNodes, ancestorGen);
-    LOG.debug("chooseRandom return {}", ret);
+    LOG.debug("Choosing node[index={},random={}] from \"{}\" available nodes" +
+            " scope=\"{}\", excludedScope=\"{}\", excludeNodes=\"{}\".",
+        nodeIndex, (leafIndex == -1 ? "true" : "false"), availableNodes,
+        scopeNode.getNetworkFullPath(), excludedScope, excludedNodes);
+    LOG.debug("Chosen node = {}", (ret == null ? "not found" : ret.toString()));
+    if (node1 == null || node2 == null) {
+      LOG.warn("One of the nodes is a null pointer");
+      return Integer.MAX_VALUE;
+    }
-      if (node1 == null || node2 == null ||
-          (node1.getAncestor(maxLevel - 1) != clusterTree) ||
+      if ((node1.getAncestor(maxLevel - 1) != clusterTree) ||
-        LOG.warn("One of the nodes is a null pointer");
+        LOG.warn("One of the nodes is outside of network topology");
-  public void sortByDistanceCost(Node reader, Node[] nodes, int activeLen) {
+  public List<? extends Node> sortByDistanceCost(Node reader,
+      List<? extends Node> nodes, int activeLen) {
+    if (reader == null) {
+      return nodes;
+    }
-      costs[i] = getDistanceCost(reader, nodes[i]);
+      costs[i] = getDistanceCost(reader, nodes.get(i));
-      Node node = nodes[i];
+      Node node = nodes.get(i);
-    int idx = 0;
+
+    List<Node> ret = new ArrayList<>();
-          nodes[idx] = n;
-          idx++;
+          ret.add(n);
-    Preconditions.checkState(idx == activeLen, "Wrong number of nodes sorted!");
+
+    Preconditions.checkState(ret.size() == activeLen,
+        "Wrong number of nodes sorted!");
+    return ret;

INS26 INS40 MOV21 INS74 INS60 INS25 INS43 INS76 INS74 INS25 INS41 INS39 INS59 MOV27 MOV8 INS42 MOV43 INS43 INS76 INS27 INS8 INS74 INS42 INS42 INS21 INS21 UPD42 INS36 UPD42 UPD45 INS36 INS42 MOV43 INS42 INS33 INS41 INS43 INS43 UPD42 INS14 INS7 INS7 UPD45 INS16 INS16 MOV27 INS8 INS42 INS43 INS42 INS42 INS74 INS32 INS42 MOV27 INS42 MOV32 INS27 INS45 INS45 INS27 INS45 INS32 MOV36 INS21 INS41 INS42 INS32 INS43 INS42 INS42 INS42 UPD42 INS42 INS38 INS42 INS33 INS42 INS42 INS32 INS40 INS32 INS42 INS42 INS42 INS42 INS34 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 DEL83 DEL39 DEL42 DEL59 DEL60 DEL42 DEL27 DEL39 DEL85 DEL5 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL39 DEL34 DEL42 DEL42 DEL2 DEL42 DEL7 DEL42 DEL37 DEL21 DEL42
MAPREDUCE-3787. [Gridmix] Optimize job monitoring and STRESS mode for faster job submission. (amarrk)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1292736 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import org.apache.hadoop.mapred.gridmix.Statistics.JobStats;
+import org.apache.hadoop.mapreduce.JobStatus;
- * Component accepting submitted, running jobs and responsible for
- * monitoring jobs for success and failure. Once a job is submitted, it is
- * polled for status until complete. If a job is complete, then the monitor
- * thread returns immediately to the queue. If not, the monitor will sleep
- * for some duration.
+ * Component accepting submitted, running {@link Statistics.JobStats} and 
+ * responsible for monitoring jobs for success and failure. Once a job is 
+ * submitted, it is polled for status until complete. If a job is complete, 
+ * then the monitor thread returns immediately to the queue. If not, the monitor
+ * will sleep for some duration.
+ * 
+ * {@link JobMonitor} can be configured to use multiple threads for polling
+ * the job statuses. Use {@link Gridmix#GRIDMIX_JOBMONITOR_THREADS} to specify
+ * the total number of monitoring threads. 
+ * 
+ * The duration for which a monitoring thread sleeps if the first job in the 
+ * queue is running can also be configured. Use 
+ * {@link Gridmix#GRIDMIX_JOBMONITOR_SLEEPTIME_MILLIS} to specify a custom 
+ * value.
-class JobMonitor implements Gridmix.Component<Job> {
+class JobMonitor implements Gridmix.Component<JobStats> {
-  private final Queue<Job> mJobs;
-  private final MonitorThread mThread;
-  private final BlockingQueue<Job> runningJobs;
+  private final Queue<JobStats> mJobs;
+  private ExecutorService executor;
+  private int numPollingThreads;
+  private final BlockingQueue<JobStats> runningJobs;
-  public JobMonitor(Statistics statistics) {
-    this(5,TimeUnit.SECONDS, statistics);
-  }
-
-  public JobMonitor(int pollDelay, TimeUnit unit, Statistics statistics) {
-    mThread = new MonitorThread();
-    runningJobs = new LinkedBlockingQueue<Job>();
-    mJobs = new LinkedList<Job>();
+  public JobMonitor(int pollDelay, TimeUnit unit, Statistics statistics, 
+                    int numPollingThreads) {
+    executor = Executors.newCachedThreadPool();
+    this.numPollingThreads = numPollingThreads;
+    runningJobs = new LinkedBlockingQueue<JobStats>();
+    mJobs = new LinkedList<JobStats>();
-   * Add a job to the polling queue.
+   * Add a running job's status to the polling queue.
-  public void add(Job job) throws InterruptedException {
-    runningJobs.put(job);
+  public void add(JobStats job) throws InterruptedException {
+    synchronized (runningJobs) {
+      runningJobs.put(job);
+    }
-   * Add a submission failed job , such that it can be communicated
+   * Add a submission failed job's status, such that it can be communicated
-  public void submissionFailed(Job job) {
-    LOG.info("Job submission failed notification for job " + job.getJobID());
-    this.statistics.add(job);
+  public void submissionFailed(JobStats job) {
+    String jobID = job.getJob().getConfiguration().get(Gridmix.ORIGINAL_JOB_ID);
+    LOG.info("Job submission failed notification for job " + jobID);
+    synchronized (statistics) {
+      this.statistics.add(job);
+    }
-  List<Job> getRemainingJobs() {
-    if (mThread.isAlive()) {
-      LOG.warn("Internal error: Polling running monitor for jobs");
-    }
+  List<JobStats> getRemainingJobs() {
-      return new ArrayList<Job>(mJobs);
+      return new ArrayList<JobStats>(mJobs);
-    public MonitorThread() {
-      super("GridmixJobMonitor");
-    }
-
-    /**
-     * Check a job for success or failure.
-     */
-    public void process(Job job) throws IOException, InterruptedException {
-      if (job.isSuccessful()) {
-        onSuccess(job);
-      } else {
-        onFailure(job);
-      }
+    public MonitorThread(int i) {
+      super("GridmixJobMonitor-" + i);
-          synchronized (mJobs) {
-            graceful = JobMonitor.this.graceful;
-            shutdown = JobMonitor.this.shutdown;
-            runningJobs.drainTo(mJobs);
+          synchronized (runningJobs) {
+            synchronized (mJobs) {
+              graceful = JobMonitor.this.graceful;
+              shutdown = JobMonitor.this.shutdown;
+              runningJobs.drainTo(mJobs);
+            }
-              while (!runningJobs.isEmpty()) {
-                synchronized (mJobs) {
-                  runningJobs.drainTo(mJobs);
+              synchronized (runningJobs) {
+                while (!runningJobs.isEmpty()) {
+                  synchronized (mJobs) {
+                    runningJobs.drainTo(mJobs);
+                  }
-            } else if (mJobs.isEmpty()) {
-              break;
+            }
+            
+            synchronized (mJobs) {
+              if (graceful && mJobs.isEmpty()) {
+                break;
+              }
-          while (!mJobs.isEmpty()) {
-            Job job;
-            synchronized (mJobs) {
-              job = mJobs.poll();
-            }
+          JobStats jobStats = null;
+          synchronized (mJobs) {
+            jobStats = mJobs.poll();
+          }
+          while (jobStats != null) {
+            Job job = jobStats.getJob();
+            
-              if (job.isComplete()) {
-                process(job);
-                statistics.add(job);
-                continue;
+              // get the job status
+              long start = System.currentTimeMillis();
+              JobStatus status = job.getStatus(); // cache the job status
+              long end = System.currentTimeMillis();
+              
+              if (LOG.isDebugEnabled()) {
+                LOG.debug("Status polling for job " + job.getJobID() + " took "
+                          + (end-start) + "ms.");
+              }
+              
+              // update the job progress
+              jobStats.updateJobStatus(status);
+              
+              // if the job is complete, let others know
+              if (status.isJobComplete()) {
+                if (status.getState() == JobStatus.State.SUCCEEDED) {
+                  onSuccess(job);
+                } else {
+                  onFailure(job);
+                }
+                synchronized (statistics) {
+                  statistics.add(jobStats);
+                }
+              } else {
+                // add the running job back and break
+                synchronized (mJobs) {
+                  if (!mJobs.offer(jobStats)) {
+                    LOG.error("Lost job " + (null == job.getJobName()
+                         ? "<unknown>" : job.getJobName())); // should never
+                                                             // happen
+                  }
+                }
+                break;
-                continue;
+                synchronized (statistics) {
+                  statistics.add(jobStats);
+                }
+            
+            // get the next job
-              if (!mJobs.offer(job)) {
-                LOG.error("Lost job " + (null == job.getJobName()
-                     ? "<unknown>" : job.getJobName())); // should never
-                                                         // happen
-              }
+              jobStats = mJobs.poll();
-            break;
+          
+          // sleep for a while before checking again
-    mThread.start();
+    for (int i = 0; i < numPollingThreads; ++i) {
+      executor.execute(new MonitorThread(i));
+    }
-    mThread.join(millis);
+    executor.awaitTermination(millis, TimeUnit.MILLISECONDS);
-    mThread.interrupt();
+    executor.shutdown();
-    mThread.interrupt();
+    executor.shutdown();

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 UPD74 INS23 UPD43 UPD74 UPD43 INS83 INS39 INS59 UPD74 INS44 INS8 INS8 UPD74 UPD66 INS65 INS66 UPD66 UPD66 UPD66 UPD66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 UPD42 UPD43 UPD42 UPD42 INS42 UPD43 INS39 INS42 INS21 INS21 UPD43 INS51 UPD43 INS60 INS21 INS51 UPD43 INS44 INS24 INS40 INS42 INS67 INS67 UPD42 UPD42 INS7 INS7 UPD66 UPD42 INS42 MOV8 UPD66 UPD42 INS43 INS59 INS32 INS42 MOV8 UPD42 INS39 INS42 INS58 INS27 INS38 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS22 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS27 INS39 INS59 INS42 INS42 INS42 MOV21 UPD42 UPD42 INS40 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS52 INS42 UPD74 UPD74 INS32 INS42 INS40 INS45 INS42 INS45 INS42 INS42 INS34 INS32 UPD43 UPD43 INS32 INS42 UPD74 INS42 INS42 MOV14 UPD42 UPD42 INS42 INS42 UPD43 INS51 INS60 MOV51 INS42 UPD42 INS42 INS8 INS43 INS59 INS27 MOV51 INS51 INS42 INS42 INS33 INS42 INS33 INS51 INS8 INS42 INS8 INS42 INS8 INS51 INS10 INS25 UPD42 INS32 INS60 INS60 INS60 INS25 MOV21 INS25 INS21 INS42 MOV8 INS27 MOV8 INS42 INS42 INS39 INS59 INS43 INS59 INS39 INS59 INS32 INS8 INS32 MOV8 INS8 INS7 INS42 MOV32 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 MOV21 UPD42 UPD42 UPD42 INS42 INS42 INS51 MOV51 INS10 INS42 INS32 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS42 INS27 INS42 INS8 INS51 INS42 INS42 UPD42 UPD42 INS27 INS32 INS40 INS21 INS42 INS8 INS45 MOV32 INS45 INS36 INS45 UPD42 MOV42 UPD42 MOV42 INS32 INS21 INS27 INS42 INS42 INS42 INS32 INS42 INS42 UPD42 INS42 INS42 INS42 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL34 DEL40 DEL42 DEL17 DEL8 DEL31 DEL42 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL45 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL31 DEL10 DEL42 DEL42 DEL32 DEL25 DEL38 DEL32 DEL32 DEL18 DEL8 DEL25 DEL18 DEL10 DEL42 DEL7 DEL42 DEL42 DEL32 DEL21
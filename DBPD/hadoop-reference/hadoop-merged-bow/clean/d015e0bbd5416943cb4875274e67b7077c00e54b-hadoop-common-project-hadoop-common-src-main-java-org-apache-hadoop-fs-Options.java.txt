HDFS-7878. API - expose a unique file identifier.

+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.BiFunction;
+
+
+  /**
+   * Options for creating {@link PathHandle} references.
+   */
+  public static class HandleOpt {
+    protected HandleOpt() {
+    }
+
+    /**
+     * Utility function for mapping
+     * {@link FileSystem#getPathHandle(FileStatus, HandleOpt[])} to a
+     * fixed set of handle options.
+     * @param fs Target filesystem
+     * @param opt Options to bind in partially evaluated function
+     * @return Function reference with options fixed
+     */
+    public static Function<FileStatus, PathHandle> resolve(
+        FileSystem fs, HandleOpt... opt) {
+      return resolve(fs::getPathHandle, opt);
+    }
+
+    /**
+     * Utility function for partial evaluation of {@link FileStatus}
+     * instances to a fixed set of handle options.
+     * @param fsr Function reference
+     * @param opt Options to associate with {@link FileStatus} instances to
+     *            produce {@link PathHandle} instances.
+     * @return Function reference with options fixed
+     */
+    public static Function<FileStatus, PathHandle> resolve(
+        BiFunction<FileStatus, HandleOpt[], PathHandle> fsr,
+        HandleOpt... opt) {
+      return (stat) -> fsr.apply(stat, opt);
+    }
+
+    /**
+     * Handle is valid iff the referent is neither moved nor changed.
+     * Equivalent to changed(false), moved(false).
+     * @return Options requiring that the content and location of the entity
+     * be unchanged between calls.
+     */
+    public static HandleOpt[] exact() {
+      return new HandleOpt[] {changed(false), moved(false) };
+    }
+
+    /**
+     * Handle is valid iff the content of the referent is the same.
+     * Equivalent to changed(false), moved(true).
+     * @return Options requiring that the content of the entity is unchanged,
+     * but it may be at a different location.
+     */
+    public static HandleOpt[] content() {
+      return new HandleOpt[] {changed(false), moved(true)  };
+    }
+
+    /**
+     * Handle is valid iff the referent is unmoved in the namespace.
+     * Equivalent to changed(true), moved(false).
+     * @return Options requiring that the referent exist in the same location,
+     * but its content may have changed.
+     */
+    public static HandleOpt[] path() {
+      return new HandleOpt[] {changed(true),  moved(false) };
+    }
+
+    /**
+     * Handle is valid iff the referent exists in the namespace.
+     * Equivalent to changed(true), moved(true).
+     * @return Options requiring that the implementation resolve a reference
+     * to this entity regardless of changes to content or location.
+     */
+    public static HandleOpt[] reference() {
+      return new HandleOpt[] {changed(true),  moved(true)  };
+    }
+
+    /**
+     * @param allow If true, resolve references to this entity even if it has
+     *             been modified.
+     * @return Handle option encoding parameter.
+     */
+    public static Data changed(boolean allow) {
+      return new Data(allow);
+    }
+
+    /**
+     * @param allow If true, resolve references to this entity anywhere in
+     *              the namespace.
+     * @return Handle option encoding parameter.
+     */
+    public static Location moved(boolean allow) {
+      return new Location(allow);
+    }
+
+    /**
+     * Utility method to extract a HandleOpt from the set provided.
+     * @param c Target class
+     * @param opt List of options
+     * @param <T> Type constraint for exact match
+     * @throws IllegalArgumentException If more than one matching type is found.
+     * @return An option assignable from the specified type or null if either
+     * opt is null or a suitable match is not found.
+     */
+    public static <T extends HandleOpt> Optional<T> getOpt(
+        Class<T> c, HandleOpt... opt) {
+      if (null == opt) {
+        return Optional.empty();
+      }
+      T ret = null;
+      for (HandleOpt o : opt) {
+        if (c.isAssignableFrom(o.getClass())) {
+          if (ret != null) {
+            throw new IllegalArgumentException("Duplicate option "
+                + c.getSimpleName());
+          }
+
+          @SuppressWarnings("unchecked")
+          T tmp = (T) o;
+          ret = tmp;
+        }
+      }
+      return Optional.ofNullable(ret);
+    }
+
+    /**
+     * Option storing standard constraints on data.
+     */
+    public static class Data extends HandleOpt {
+      private final boolean allowChanged;
+      Data(boolean allowChanged) {
+        this.allowChanged = allowChanged;
+      }
+
+      /**
+       * Tracks whether any changes to file content are permitted.
+       * @return True if content changes are allowed, false otherwise.
+       */
+      public boolean allowChange() {
+        return allowChanged;
+      }
+      @Override
+      public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("data(allowChange=")
+          .append(allowChanged).append(")");
+        return sb.toString();
+      }
+    }
+
+    /**
+     * Option storing standard constraints on location.
+     */
+    public static class Location extends HandleOpt {
+      private final boolean allowChanged;
+      Location(boolean allowChanged) {
+        this.allowChanged = allowChanged;
+      }
+
+      /**
+       * Tracks whether any changes to file location are permitted.
+       * @return True if relocation in the namespace is allowed, false
+       * otherwise.
+       */
+      public boolean allowChange() {
+        return allowChanged;
+      }
+      @Override
+      public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("loc(allowChange=")
+            .append(allowChanged).append(")");
+        return sb.toString();
+      }
+    }
+
+  }
+

INS26 INS26 INS26 INS40 INS40 INS40 INS55 INS29 INS83 INS83 INS42 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS55 INS65 INS83 INS42 INS8 INS29 INS83 INS83 INS74 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS74 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS8 INS29 INS83 INS83 INS5 INS42 INS8 INS29 INS83 INS83 INS5 INS42 INS8 INS29 INS83 INS83 INS5 INS42 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS73 INS74 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS29 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS66 INS65 INS66 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS43 INS42 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS74 INS42 INS43 INS42 INS41 INS65 INS65 INS43 INS85 INS41 INS65 INS65 INS43 INS85 INS41 INS65 INS65 INS43 INS85 INS41 INS65 INS65 INS43 INS85 INS41 INS65 INS65 INS42 INS39 INS42 INS41 INS65 INS65 INS42 INS39 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS43 INS43 INS74 INS42 INS43 INS42 INS25 INS60 INS70 INS41 INS65 INS42 INS83 INS83 INS39 INS59 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS65 INS42 INS83 INS83 INS39 INS59 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS42 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS32 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS42 INS42 INS42 INS43 INS43 INS5 INS43 INS42 INS86 INS66 INS66 INS66 INS66 INS42 INS3 INS66 INS66 INS66 INS66 INS42 INS3 INS66 INS66 INS66 INS66 INS42 INS3 INS66 INS66 INS66 INS66 INS42 INS3 INS42 INS66 INS66 INS66 INS14 INS42 INS66 INS66 INS66 INS14 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS42 INS43 INS43 INS42 INS27 INS8 INS43 INS59 INS44 INS42 INS8 INS32 INS66 INS42 INS39 INS42 INS21 INS65 INS65 INS41 INS42 INS42 INS60 INS21 INS41 INS66 INS42 INS39 INS42 INS21 INS65 INS65 INS41 INS42 INS42 INS60 INS21 INS41 INS68 INS42 INS90 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS59 INS32 INS5 INS4 INS5 INS4 INS5 INS4 INS5 INS4 INS43 INS42 INS43 INS42 INS42 INS42 INS33 INS42 INS41 INS42 INS42 INS33 INS43 INS42 INS25 INS42 INS42 INS42 INS7 INS66 INS66 INS42 INS43 INS59 INS32 INS32 INS7 INS66 INS66 INS66 INS42 INS43 INS59 INS32 INS32 INS42 INS42 INS69 INS69 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS32 INS32 INS43 INS85 INS32 INS32 INS43 INS85 INS32 INS32 INS43 INS85 INS32 INS32 INS42 INS42 INS32 INS42 INS32 INS8 INS22 INS42 INS42 INS42 INS14 INS32 INS42 INS45 INS42 INS42 INS22 INS42 INS42 INS42 INS14 INS32 INS42 INS45 INS42 INS42 INS43 INS5 INS42 INS42 INS9 INS42 INS9 INS42 INS42 INS9 INS42 INS9 INS42 INS42 INS9 INS42 INS9 INS42 INS42 INS9 INS42 INS9 INS42 INS42 INS42 INS42 INS32 INS25 INS60 INS21 INS52 INS42 INS43 INS32 INS42 INS42 INS52 INS42 INS43 INS32 INS42 INS42 INS42 INS43 INS85 INS42 INS42 INS27 INS8 INS79 INS43 INS59 INS7 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS33 INS53 INS42 INS45 INS42 INS42 INS11 INS42 INS42 INS14 INS43 INS42 INS43 INS27 INS42 INS42 INS45 INS32 INS42 INS42
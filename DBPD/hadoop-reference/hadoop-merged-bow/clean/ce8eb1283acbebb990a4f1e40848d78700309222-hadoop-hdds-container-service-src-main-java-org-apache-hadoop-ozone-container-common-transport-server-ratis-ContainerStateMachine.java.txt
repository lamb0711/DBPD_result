Revert "HDDS-1610. applyTransaction failure should not be lost on restart. Contributed by Shashikant Banerjee."

This reverts commit 62445021d5d57b0d49adcb1bd4365c13532328fc as it has unintended changes in DirectoryWithSnapshotFeature class..

-import org.apache.ratis.protocol.StateMachineException;
-import java.util.concurrent.atomic.AtomicBoolean;
-  private final AtomicBoolean isStateMachineHealthy;
-    isStateMachineHealthy = new AtomicBoolean(true);
-    if (!isStateMachineHealthy.get()) {
-      String msg =
-          "Failed to take snapshot " + " for " + gid + " as the stateMachine"
-              + " is unhealthy. The last applied index is at " + ti;
-      StateMachineException sme = new StateMachineException(msg);
-      LOG.error(msg);
-      throw sme;
-    }
-        LOG.error("{}: Failed to write snapshot at:{} file {}", gid, ti,
+        LOG.info("{}: Failed to write snapshot at:{} file {}", gid, ti,
-      LOG.info("{}: Finished taking a snapshot at:{} file:{} time:{}", gid, ti,
-          snapshotFile, (Time.monotonicNow() - startTime));
+      LOG.info("{}: Finished taking a snapshot at:{} file:{} time:{}",
+          gid, ti, snapshotFile, (Time.monotonicNow() - startTime));
-  private ContainerCommandResponseProto runCommand(
+  private ContainerCommandResponseProto runCommandGetResponse(
+  private Message runCommand(ContainerCommandRequestProto requestProto,
+      DispatcherContext context) {
+    return runCommandGetResponse(requestProto, context)::toByteString;
+  }
+
-            runCommand(requestProto, context), chunkExecutor);
+            runCommandGetResponse(requestProto, context), chunkExecutor);
-      return CompletableFuture
-          .completedFuture(runCommand(requestProto, null)::toByteString);
+      return CompletableFuture.completedFuture(runCommand(requestProto, null));
-      CompletableFuture<Message> applyTransactionFuture =
-          new CompletableFuture<>();
-      CompletableFuture<ContainerCommandResponseProto> future =
-          CompletableFuture.supplyAsync(
-              () -> runCommand(requestProto, builder.build()),
+      CompletableFuture<Message> future = CompletableFuture
+          .supplyAsync(() -> runCommand(requestProto, builder.build()),
-      future.thenApply(r -> {
+
+      future.thenAccept(m -> {
-        if (r.getResult() != ContainerProtos.Result.SUCCESS) {
-          StorageContainerException sce =
-              new StorageContainerException(r.getMessage(), r.getResult());
-          LOG.error(
-              "gid {} : ApplyTransaction failed. cmd {} logIndex {} msg : "
-                  + "{} Container Result: {}", gid, r.getCmdType(), index,
-              r.getMessage(), r.getResult());
-          metrics.incNumApplyTransactionsFails();
-          // Since the applyTransaction now is completed exceptionally,
-          // before any further snapshot is taken , the exception will be
-          // caught in stateMachineUpdater in Ratis and ratis server will
-          // shutdown.
-          applyTransactionFuture.completeExceptionally(sce);
-          isStateMachineHealthy.compareAndSet(true, false);
-          ratisServer.handleApplyTransactionFailure(gid, trx.getServerRole());
-        } else {
-          LOG.debug(
-              "gid {} : ApplyTransaction completed. cmd {} logIndex {} msg : "
-                  + "{} Container Result: {}", gid, r.getCmdType(), index,
-              r.getMessage(), r.getResult());
-          applyTransactionFuture.complete(r::toByteString);
-          if (cmdType == Type.WriteChunk || cmdType == Type.PutSmallFile) {
-            metrics.incNumBytesCommittedCount(
-                requestProto.getWriteChunk().getChunkData().getLen());
-          }
-          // add the entry to the applyTransactionCompletionMap only if the
-          // stateMachine is healthy i.e, there has been no applyTransaction
-          // failures before.
-          if (isStateMachineHealthy.get()) {
-            final Long previous = applyTransactionCompletionMap
+
+        final Long previous =
+            applyTransactionCompletionMap
-            Preconditions.checkState(previous == null);
-            updateLastApplied();
-          }
+        Preconditions.checkState(previous == null);
+        if (cmdType == Type.WriteChunk || cmdType == Type.PutSmallFile) {
+          metrics.incNumBytesCommittedCount(
+              requestProto.getWriteChunk().getChunkData().getLen());
-        return applyTransactionFuture;
+        updateLastApplied();
-      return applyTransactionFuture;
+      return future;

INS31 UPD42 INS83 INS43 INS42 INS44 INS44 INS8 UPD42 MOV42 INS43 INS42 INS43 INS42 INS41 INS42 INS42 INS90 INS32 INS42 INS42 INS42 INS42 MOV74 UPD42 MOV32 UPD42 UPD42 MOV8 UPD42 UPD42 MOV25 MOV25 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL43 DEL42 DEL59 DEL23 DEL42 DEL42 DEL43 DEL9 DEL14 DEL7 DEL21 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL45 DEL45 DEL27 DEL42 DEL45 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL25 DEL42 DEL90 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL9 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL90 DEL32 DEL21 DEL42 DEL42 DEL32 DEL25 DEL8 DEL25 DEL42 DEL41 DEL8
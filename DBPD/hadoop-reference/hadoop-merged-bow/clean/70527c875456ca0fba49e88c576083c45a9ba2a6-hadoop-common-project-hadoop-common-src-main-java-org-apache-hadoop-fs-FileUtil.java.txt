merge trunk into HDFS-4949 branch

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1513658 13f79535-47bb-0310-9956-ffa450edef68

-  
+
+  /**
+   * Returns the target of the given symlink. Returns the empty string if
+   * the given path does not refer to a symlink or there is an error
+   * accessing the symlink.
+   * @param f File representing the symbolic link.
+   * @return The target of the symbolic link, empty string on error or if not
+   *         a symlink.
+   */
+  public static String readLink(File f) {
+    /* NB: Use readSymbolicLink in java.nio.file.Path once available. Could
+     * use getCanonicalPath in File to get the target of the symlink but that
+     * does not indicate if the given path refers to a symlink.
+     */
+    try {
+      return Shell.execCommand(
+          Shell.getReadlinkCommand(f.toString())).trim();
+    } catch (IOException x) {
+      return "";
+    }
+  }
+
+   *
-   * @return value returned by the command
+   * @return 0 on success
-    File targetFile = new File(target);
-    File linkFile = new File(linkname);
+    File targetFile = new File(
+        Path.getPathWithoutSchemeAndAuthority(new Path(target)).toString());
+    File linkFile = new File(
+        Path.getPathWithoutSchemeAndAuthority(new Path(linkname)).toString());
-        LOG.info("FileUtil#symlink: On Java6, copying file instead "
-            + linkname + " -> " + target);
-        org.apache.commons.io.FileUtils.copyFile(targetFile, linkFile);
+        LOG.warn("FileUtil#symlink: On Windows+Java6, copying file instead " +
+            "of creating a symlink. Copying " + target + " -> " + linkname);
+
+        if (!linkFile.getParentFile().exists()) {
+          LOG.warn("Parent directory " + linkFile.getParent() +
+              " does not exist.");
+          return 1;
+        } else {
+          org.apache.commons.io.FileUtils.copyFile(targetFile, linkFile);
+        }
-    String[] cmd = Shell.getSymlinkCommand(targetFile.getPath(),
-        linkFile.getPath());
-    ShellCommandExecutor shExec = new ShellCommandExecutor(cmd);
+    String[] cmd = Shell.getSymlinkCommand(
+        targetFile.toString(),
+        linkFile.toString());
+
+    ShellCommandExecutor shExec;
+      if (Shell.WINDOWS &&
+          linkFile.getParentFile() != null &&
+          !new Path(target).isAbsolute()) {
+        // Relative links on Windows must be resolvable at the time of
+        // creation. To ensure this we run the shell command in the directory
+        // of the link.
+        //
+        shExec = new ShellCommandExecutor(cmd, linkFile.getParentFile());
+      } else {
+        shExec = new ShellCommandExecutor(cmd);
+      }
-  
+

INS31 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS65 INS65 INS65 INS42 INS43 INS42 INS54 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS8 INS12 UPD66 MOV43 MOV43 INS8 INS41 INS44 INS8 INS14 INS14 INS25 MOV21 INS32 INS43 INS42 INS41 MOV43 INS32 MOV43 INS32 INS8 INS27 INS8 INS8 INS32 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS21 INS25 UPD42 UPD42 INS27 INS38 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS14 INS32 INS38 INS8 MOV8 INS40 INS27 INS32 INS7 INS7 INS42 INS42 INS32 INS43 MOV42 INS43 MOV42 INS42 INS42 INS27 INS32 INS21 INS41 INS32 INS33 INS14 INS42 INS42 INS14 INS42 MOV14 INS42 INS42 INS42 INS42 INS27 INS42 INS45 INS42 INS32 INS42 INS32 INS34 INS42 INS42 INS43 INS42 INS43 INS42 INS32 INS45 INS45 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS42 INS42 DEL14 DEL14 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8
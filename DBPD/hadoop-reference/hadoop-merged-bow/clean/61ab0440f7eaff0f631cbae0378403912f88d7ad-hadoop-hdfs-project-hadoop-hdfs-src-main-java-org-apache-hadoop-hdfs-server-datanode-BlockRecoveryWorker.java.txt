HDFS-9173. Erasure Coding: Lease recovery for striped file. Contributed by Walter Su and Jing Zhao.

Change-Id: I51703a61c9d8454f883028f3f6acb5729fde1b15

+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
+import org.apache.hadoop.hdfs.protocol.ErasureCodingPolicy;
+import org.apache.hadoop.hdfs.server.common.HdfsServerConstants;
+import org.apache.hadoop.hdfs.server.protocol.BlockRecoveryCommand.RecoveringStripedBlock;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.hadoop.hdfs.server.common.HdfsServerConstants.BLOCK_GROUP_INDEX_MASK;
+import static org.apache.hadoop.hdfs.util.StripedBlockUtil.getInternalBlockLength;
+    public ReplicaRecoveryInfo getReplicaRecoveryInfo(){
+      return rInfo;
+    }
+
-        StringBuilder b = new StringBuilder();
-        for(DatanodeID id : failedList) {
-          b.append("\n  " + id);
-        }
-        throw new IOException("Cannot recover " + block + ", the following "
-            + failedList.size() + " data-nodes failed {" + b + "\n}");
+        throw new IOException("Cannot recover " + block
+            + ", the following datanodes failed: " + failedList);
+  /**
+   * blk_0  blk_1  blk_2  blk_3  blk_4  blk_5  blk_6  blk_7  blk_8
+   *  64k    64k    64k    64k    64k    64k    64k    64k    64k   <-- stripe_0
+   *  64k    64k    64k    64k    64k    64k    64k    64k    64k
+   *  64k    64k    64k    64k    64k    64k    64k    61k    <-- startStripeIdx
+   *  64k    64k    64k    64k    64k    64k    64k
+   *  64k    64k    64k    64k    64k    64k    59k
+   *  64k    64k    64k    64k    64k    64k
+   *  64k    64k    64k    64k    64k    64k                <-- last full stripe
+   *  64k    64k    13k    64k    55k     3k              <-- target last stripe
+   *  64k    64k           64k     1k
+   *  64k    64k           58k
+   *  64k    64k
+   *  64k    19k
+   *  64k                                               <-- total visible stripe
+   *
+   *  Due to different speed of streamers, the internal blocks in a block group
+   *  could have different lengths when the block group isn't ended normally.
+   *  The purpose of this class is to recover the UnderConstruction block group,
+   *  so all internal blocks end at the same stripe.
+   *
+   * The steps:
+   * 1. get all blocks lengths from DataNodes.
+   * 2. calculate safe length, which is at the target last stripe.
+   * 3. decode and feed blk_6~8, make them end at last full stripe. (the last
+   * full stripe means the last decodable stripe.)
+   * 4. encode the target last stripe, with the remaining sequential data. In
+   * this case, the sequential data is 64k+64k+13k. Feed blk_6~8 the parity cells.
+   * Overwrite the parity cell if have to.
+   * 5. truncate the stripes from visible stripe, to target last stripe.
+   * TODO: implement step 3,4
+   */
+  public class RecoveryTaskStriped {
+    private final RecoveringBlock rBlock;
+    private final ExtendedBlock block;
+    private final String bpid;
+    private final DatanodeInfo[] locs;
+    private final long recoveryId;
+
+    private final int[] blockIndices;
+    private final ErasureCodingPolicy ecPolicy;
+
+    RecoveryTaskStriped(RecoveringStripedBlock rBlock) {
+      this.rBlock = rBlock;
+      // TODO: support truncate
+      Preconditions.checkArgument(rBlock.getNewBlock() == null);
+
+      block = rBlock.getBlock();
+      bpid = block.getBlockPoolId();
+      locs = rBlock.getLocations();
+      recoveryId = rBlock.getNewGenerationStamp();
+      blockIndices = rBlock.getBlockIndices();
+      ecPolicy = rBlock.getErasureCodingPolicy();
+    }
+
+    protected void recover() throws IOException {
+      checkLocations(locs.length);
+
+      Map<Long, BlockRecord> syncBlocks = new HashMap<>(locs.length);
+      final int dataBlkNum = ecPolicy.getNumDataUnits();
+      final int totalBlkNum = dataBlkNum + ecPolicy.getNumParityUnits();
+      //check generation stamps
+      for (int i = 0; i < locs.length; i++) {
+        DatanodeID id = locs[i];
+        try {
+          DatanodeID bpReg = new DatanodeID(
+              datanode.getBPOfferService(bpid).bpRegistration);
+          InterDatanodeProtocol proxyDN = bpReg.equals(id) ?
+              datanode : DataNode.createInterDataNodeProtocolProxy(id, conf,
+              dnConf.socketTimeout, dnConf.connectToDnViaHostname);
+          ExtendedBlock internalBlk = new ExtendedBlock(block);
+          final long blockId = block.getBlockId() + blockIndices[i];
+          internalBlk.setBlockId(blockId);
+          ReplicaRecoveryInfo info = callInitReplicaRecovery(proxyDN,
+              new RecoveringBlock(internalBlk, null, recoveryId));
+
+          if (info != null &&
+              info.getGenerationStamp() >= block.getGenerationStamp() &&
+              info.getNumBytes() > 0) {
+            final BlockRecord existing = syncBlocks.get(blockId);
+            if (existing == null ||
+                info.getNumBytes() > existing.rInfo.getNumBytes()) {
+              // if we have >1 replicas for the same internal block, we
+              // simply choose the one with larger length.
+              // TODO: better usage of redundant replicas
+              syncBlocks.put(blockId, new BlockRecord(id, proxyDN, info));
+            }
+          }
+        } catch (RecoveryInProgressException ripE) {
+          InterDatanodeProtocol.LOG.warn(
+              "Recovery for replica " + block + " on data-node " + id
+                  + " is already in progress. Recovery id = "
+                  + rBlock.getNewGenerationStamp() + " is aborted.", ripE);
+          return;
+        } catch (IOException e) {
+          InterDatanodeProtocol.LOG.warn(
+              "Failed to obtain replica info for block (=" + block
+                  + ") from datanode (=" + id + ")", e);
+        }
+      }
+      checkLocations(syncBlocks.size());
+
+      final long safeLength = getSafeLength(syncBlocks);
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Recovering block " + block
+            + ", length=" + block.getNumBytes() + ", safeLength=" + safeLength
+            + ", syncList=" + syncBlocks);
+      }
+
+      // If some internal blocks reach the safe length, convert them to RUR
+      List<BlockRecord> rurList = new ArrayList<>(locs.length);
+      for (BlockRecord r : syncBlocks.values()) {
+        int blockIndex = (int) (r.rInfo.getBlockId() & BLOCK_GROUP_INDEX_MASK);
+        long newSize = getInternalBlockLength(safeLength, ecPolicy.getCellSize(),
+            dataBlkNum, blockIndex);
+        if (r.rInfo.getNumBytes() >= newSize) {
+          rurList.add(r);
+        }
+      }
+      assert rurList.size() >= dataBlkNum : "incorrect safe length";
+
+      // Recovery the striped block by truncating internal blocks to the safe
+      // length. Abort if there is any failure in this step.
+      truncatePartialBlock(rurList, safeLength);
+
+      // notify Namenode the new size and locations
+      final DatanodeID[] newLocs = new DatanodeID[totalBlkNum];
+      final String[] newStorages = new String[totalBlkNum];
+      for (int i = 0; i < totalBlkNum; i++) {
+        newLocs[blockIndices[i]] = DatanodeID.EMPTY_DATANODE_ID;
+        newStorages[blockIndices[i]] = "";
+      }
+      for (BlockRecord r : rurList) {
+        int index = (int) (r.rInfo.getBlockId() &
+            HdfsServerConstants.BLOCK_GROUP_INDEX_MASK);
+        newLocs[index] = r.id;
+        newStorages[index] = r.storageID;
+      }
+      ExtendedBlock newBlock = new ExtendedBlock(bpid, block.getBlockId(),
+          safeLength, recoveryId);
+      DatanodeProtocolClientSideTranslatorPB nn = getActiveNamenodeForBP(bpid);
+      nn.commitBlockSynchronization(block, newBlock.getGenerationStamp(),
+          newBlock.getNumBytes(), true, false, newLocs, newStorages);
+    }
+
+    private void truncatePartialBlock(List<BlockRecord> rurList,
+        long safeLength) throws IOException {
+      int cellSize = ecPolicy.getCellSize();
+      int dataBlkNum = ecPolicy.getNumDataUnits();
+      List<DatanodeID> failedList = new ArrayList<>();
+      for (BlockRecord r : rurList) {
+        int blockIndex = (int) (r.rInfo.getBlockId() & BLOCK_GROUP_INDEX_MASK);
+        long newSize = getInternalBlockLength(safeLength, cellSize, dataBlkNum,
+            blockIndex);
+        try {
+          r.updateReplicaUnderRecovery(bpid, recoveryId, r.rInfo.getBlockId(),
+              newSize);
+        } catch (IOException e) {
+          InterDatanodeProtocol.LOG.warn("Failed to updateBlock (newblock="
+              + ", datanode=" + r.id + ")", e);
+          failedList.add(r.id);
+        }
+      }
+
+      // If any of the data-nodes failed, the recovery fails, because
+      // we never know the actual state of the replica on failed data-nodes.
+      // The recovery should be started over.
+      if (!failedList.isEmpty()) {
+        throw new IOException("Cannot recover " + block
+            + ", the following datanodes failed: " + failedList);
+      }
+    }
+
+    /**
+     * TODO: the current implementation depends on the assumption that the
+     * parity cells are only generated based on the full stripe. This is not
+     * true after we support hflush.
+     */
+    @VisibleForTesting
+    long getSafeLength(Map<Long, BlockRecord> syncBlocks) {
+      final int cellSize = ecPolicy.getCellSize();
+      final int dataBlkNum = ecPolicy.getNumDataUnits();
+      Preconditions.checkArgument(syncBlocks.size() >= dataBlkNum);
+      final int stripeSize = dataBlkNum * cellSize;
+      long[] blockLengths = new long[syncBlocks.size()];
+      int i = 0;
+      for (BlockRecord r : syncBlocks.values()) {
+        ReplicaRecoveryInfo rInfo = r.getReplicaRecoveryInfo();
+        blockLengths[i++] = rInfo.getNumBytes();
+      }
+      Arrays.sort(blockLengths);
+      // full stripe is a stripe has at least dataBlkNum full cells.
+      // lastFullStripeIdx is the index of the last full stripe.
+      int lastFullStripeIdx =
+          (int) (blockLengths[blockLengths.length - dataBlkNum] / cellSize);
+      return lastFullStripeIdx * stripeSize; // return the safeLength
+      // TODO: Include lastFullStripeIdx+1 stripe in safeLength, if there exists
+      // such a stripe (and it must be partial).
+    }
+
+    private void checkLocations(int locationCount)
+        throws IOException {
+      if (locationCount < ecPolicy.getNumDataUnits()) {
+        throw new IOException(block + " has no enough internal blocks" +
+            ", unable to start recovery. Locations=" + Arrays.asList(locs));
+      }
+    }
+  }
+
-            RecoveryTaskContiguous task = new RecoveryTaskContiguous(b);
-            task.recover();
+            if (b.isStriped()) {
+              new RecoveryTaskStriped((RecoveringStripedBlock) b).recover();
+            } else {
+              new RecoveryTaskContiguous(b).recover();
+            }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS55 INS31 INS29 INS83 INS42 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS43 INS42 INS8 INS65 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS5 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS5 INS59 INS83 INS83 INS43 INS59 INS42 INS44 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS78 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS42 INS41 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS42 INS39 INS85 INS42 INS42 INS42 INS43 INS42 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS21 INS60 INS60 INS60 INS24 INS21 INS60 INS25 INS60 INS70 INS6 INS21 INS60 INS60 INS24 INS70 INS60 INS60 INS21 INS74 INS42 INS39 INS42 INS42 INS60 INS60 INS60 INS70 INS25 INS65 INS42 INS74 INS42 INS60 INS60 INS21 INS60 INS60 INS60 INS70 INS21 INS60 INS41 INS39 INS42 INS42 INS25 INS42 INS42 INS42 INS7 INS32 INS7 INS7 INS7 INS7 INS7 INS7 INS32 INS74 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS58 INS27 INS37 INS8 INS32 INS83 INS39 INS59 INS32 INS8 INS74 INS59 INS44 INS32 INS8 INS27 INS45 INS32 INS83 INS5 INS59 INS83 INS5 INS59 INS58 INS27 INS37 INS8 INS44 INS42 INS8 INS43 INS59 INS43 INS59 INS32 INS43 INS43 INS39 INS59 INS39 INS59 INS74 INS59 INS44 INS42 INS8 INS38 INS8 INS66 INS66 INS66 INS43 INS43 INS43 INS83 INS39 INS59 INS83 INS39 INS59 INS32 INS83 INS39 INS59 INS5 INS59 INS39 INS59 INS44 INS32 INS8 INS32 INS39 INS59 INS27 INS27 INS8 INS22 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS40 INS43 INS43 INS43 INS42 INS14 INS42 INS32 INS42 INS27 INS39 INS59 INS42 INS40 INS42 INS60 INS54 INS42 INS32 INS42 INS32 INS42 INS42 INS21 INS43 INS43 INS42 INS14 INS43 INS42 INS42 INS42 INS60 INS60 INS25 INS32 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS3 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS42 INS42 INS21 INS21 INS43 INS42 INS60 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS9 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS43 INS43 INS42 INS14 INS43 INS42 INS60 INS60 INS54 INS32 INS53 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS27 INS42 INS27 INS39 INS85 INS42 INS3 INS42 INS34 INS43 INS42 INS42 INS42 INS60 INS21 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS32 INS53 INS52 INS42 INS32 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS40 INS42 INS42 INS42 INS32 INS42 INS34 MOV43 INS59 INS8 INS12 INS12 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS74 INS40 INS42 INS39 INS59 INS39 INS59 INS27 INS8 INS42 INS42 INS42 INS5 INS42 INS42 INS5 INS42 INS42 INS34 INS7 INS7 INS42 INS39 INS59 INS7 INS7 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS42 INS39 INS59 INS39 INS59 INS8 INS12 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS5 INS32 INS42 INS43 INS59 INS7 INS39 INS36 INS42 INS42 INS14 INS42 INS42 INS43 INS42 INS42 INS42 INS2 INS60 INS60 INS60 INS60 INS21 INS60 INS25 INS44 INS8 INS44 INS8 INS42 INS42 INS27 INS43 INS42 INS11 INS42 INS32 INS32 INS42 INS21 INS43 INS85 INS43 INS85 INS2 INS40 INS2 INS45 INS42 INS11 INS2 INS40 INS2 INS40 INS42 INS42 INS42 INS43 INS42 INS11 INS42 INS32 INS21 INS44 INS8 INS43 INS27 INS42 INS42 INS39 INS85 INS42 INS42 INS42 INS42 INS32 INS2 INS32 INS27 INS43 INS27 UPD45 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS83 INS39 INS59 INS32 INS43 INS59 INS27 INS8 INS43 INS42 INS21 INS41 INS43 INS42 INS21 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS42 INS42 INS39 INS36 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS2 INS42 INS2 INS39 INS36 INS42 INS42 INS42 INS42 INS42 INS39 INS36 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS21 INS21 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS37 INS42 INS42 INS2 INS42 INS42 INS42 INS45 INS45 INS32 INS42 INS42 INS14 INS42 INS42 INS16 INS42 INS42 INS14 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS60 INS25 INS42 INS32 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS22 INS32 INS42 INS32 INS43 INS42 INS32 INS2 INS42 INS42 INS14 INS27 INS27 INS32 INS34 INS83 INS43 INS59 INS27 INS8 INS40 INS42 INS27 INS42 INS40 INS42 INS27 INS42 INS32 INS42 INS32 INS40 INS32 INS42 INS40 INS42 INS40 INS42 INS27 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS33 INS42 INS42 INS33 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS21 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS45 INS42 INS45 INS42 INS45 INS40 INS42 INS40 INS42 INS40 INS42 INS27 INS40 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS32 INS32 INS32 INS42 INS42 INS45 INS45 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS14 INS25 INS43 INS42 INS42 INS42 INS32 INS8 INS8 INS42 INS42 INS42 INS21 MOV21 INS32 INS14 INS42 MOV14 INS43 INS11 UPD42 MOV42 INS43 INS42 INS42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL44 DEL42 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL70 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL42 DEL43 DEL42 DEL59 DEL60
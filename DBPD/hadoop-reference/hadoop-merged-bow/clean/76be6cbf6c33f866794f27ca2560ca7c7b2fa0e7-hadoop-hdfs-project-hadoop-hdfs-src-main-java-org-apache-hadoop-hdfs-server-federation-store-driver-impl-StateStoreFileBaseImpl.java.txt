HDFS-12773. RBF: Improve State Store FS implementation. Contributed by Inigo Goiri.

-import static org.apache.hadoop.hdfs.server.federation.store.StateStoreUtils.getRecordClass;
+import static org.apache.hadoop.util.Time.monotonicNow;
+import static org.apache.hadoop.util.Time.now;
-import java.util.Collection;
-import java.util.LinkedList;
+import java.util.Map.Entry;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.hadoop.hdfs.server.federation.metrics.StateStoreMetrics;
+import org.apache.hadoop.hdfs.server.federation.store.StateStoreUtils;
+import org.apache.hadoop.util.Time;
+import com.google.common.annotations.VisibleForTesting;
+
- * {@link StateStoreDriver} implementation based on a local file.
+ * {@link StateStoreDriver} implementation based on files. In this approach, we
+ * use temporary files for the writes and renaming "atomically" to the final
+ * value. Instead of writing to the final location, it will go to a temporary
+ * one and then rename to the final destination.
+  /** File extension for temporary files. */
+  private static final String TMP_MARK = ".tmp";
+  /** We remove temporary files older than 10 seconds. */
+  private static final long OLD_TMP_RECORD_MS = TimeUnit.SECONDS.toMillis(10);
+  /** File pattern for temporary records: file.XYZ.tmp. */
+  private static final Pattern OLD_TMP_RECORD_PATTERN =
+      Pattern.compile(".+\\.(\\d+)\\.tmp");
+
-  /** Name of the file containing the data. */
-  private static final String DATA_FILE_NAME = "records.data";
-
-   * Lock reading records.
+   * Get the reader of a record for the file system.
-   * @param clazz Class of the record.
-   */
-  protected abstract <T extends BaseRecord> void lockRecordRead(Class<T> clazz);
-
-  /**
-   * Unlock reading records.
-   *
-   * @param clazz Class of the record.
-   */
-  protected abstract <T extends BaseRecord> void unlockRecordRead(
-      Class<T> clazz);
-
-  /**
-   * Lock writing records.
-   *
-   * @param clazz Class of the record.
-   */
-  protected abstract <T extends BaseRecord> void lockRecordWrite(
-      Class<T> clazz);
-
-  /**
-   * Unlock writing records.
-   *
-   * @param clazz Class of the record.
-   */
-  protected abstract <T extends BaseRecord> void unlockRecordWrite(
-      Class<T> clazz);
-
-  /**
-   * Get the reader for the file system.
-   *
-   * @param clazz Class of the record.
+   * @param path Path of the record to read.
+   * @return Reader for the record.
-      Class<T> clazz, String sub);
+      String path);
-   * Get the writer for the file system.
+   * Get the writer of a record for the file system.
-   * @param clazz Class of the record.
+   * @param path Path of the record to write.
+   * @return Writer for the record.
-      Class<T> clazz, String sub);
+      String path);
+   * Rename a file. This should be atomic.
+   *
+   * @param src Source name.
+   * @param dst Destination name.
+   * @return If the rename was successful.
+   */
+  protected abstract boolean rename(String src, String dst);
+
+  /**
+   * Remove a file.
+   *
+   * @param path Path for the file to remove
+   * @return If the file was removed.
+   */
+  protected abstract boolean remove(String path);
+
+  /**
+   * Get the children for a path.
+   *
+   * @param path Path to check.
+   * @return List of children.
+   */
+  protected abstract List<String> getChildren(String path);
+
+  /**
-        String dataFilePath = dataDirPath + "/" + DATA_FILE_NAME;
-        if (!exists(dataFilePath)) {
-          // Create empty file
-          List<T> emtpyList = new ArrayList<>();
-          if(!writeAll(emtpyList, recordClass)) {
-            LOG.error("Cannot create data file {}", dataFilePath);
-            return false;
-          }
-        }
-  /**
-   * Read all lines from a file and deserialize into the desired record type.
-   *
-   * @param reader Open handle for the file.
-   * @param clazz Record class to create.
-   * @param includeDates True if dateModified/dateCreated are serialized.
-   * @return List of records.
-   * @throws IOException
-   */
-  private <T extends BaseRecord> List<T> getAllFile(
-      BufferedReader reader, Class<T> clazz, boolean includeDates)
-          throws IOException {
-
-    List<T> ret = new ArrayList<T>();
-    String line;
-    while ((line = reader.readLine()) != null) {
-      if (!line.startsWith("#") && line.length() > 0) {
-        try {
-          T record = newRecord(line, clazz, includeDates);
-          ret.add(record);
-        } catch (Exception ex) {
-          LOG.error("Cannot parse line in data source file: {}", line, ex);
-        }
-      }
-    }
-    return ret;
-  }
-
-    return get(clazz, (String)null);
+    verifyDriverReady();
+    long start = monotonicNow();
+    StateStoreMetrics metrics = getMetrics();
+    List<T> ret = new ArrayList<>();
+    try {
+      String path = getPathForClass(clazz);
+      List<String> children = getChildren(path);
+      for (String child : children) {
+        String pathRecord = path + "/" + child;
+        if (child.endsWith(TMP_MARK)) {
+          LOG.debug("There is a temporary file {} in {}", child, path);
+          if (isOldTempRecord(child)) {
+            LOG.warn("Removing {} as it's an old temporary record", child);
+            remove(pathRecord);
+          }
+        } else {
+          T record = getRecord(pathRecord, clazz);
+          ret.add(record);
+        }
+      }
+    } catch (Exception e) {
+      if (metrics != null) {
+        metrics.addFailure(monotonicNow() - start);
+      }
+      String msg = "Cannot fetch records for " + clazz.getSimpleName();
+      LOG.error(msg, e);
+      throw new IOException(msg, e);
+    }
+
+    if (metrics != null) {
+      metrics.addRead(monotonicNow() - start);
+    }
+    return new QueryResult<T>(ret, getTime());
-  @Override
-  public <T extends BaseRecord> QueryResult<T> get(Class<T> clazz, String sub)
-      throws IOException {
-    verifyDriverReady();
-    BufferedReader reader = null;
-    lockRecordRead(clazz);
+  /**
+   * Check if a record is temporary and old.
+   *
+   * @param pathRecord Path for the record to check.
+   * @return If the record is temporary and old.
+   */
+  @VisibleForTesting
+  public static boolean isOldTempRecord(final String pathRecord) {
+    if (!pathRecord.endsWith(TMP_MARK)) {
+      return false;
+    }
+    // Extract temporary record creation time
+    Matcher m = OLD_TMP_RECORD_PATTERN.matcher(pathRecord);
+    if (m.find()) {
+      long time = Long.parseLong(m.group(1));
+      return now() - time > OLD_TMP_RECORD_MS;
+    }
+    return false;
+  }
+
+  /**
+   * Read a record from a file.
+   *
+   * @param path Path to the file containing the record.
+   * @param clazz Class of the record.
+   * @return Record read from the file.
+   * @throws IOException If the file cannot be read.
+   */
+  private <T extends BaseRecord> T getRecord(
+      final String path, final Class<T> clazz) throws IOException {
+    BufferedReader reader = getReader(path);
-      reader = getReader(clazz, sub);
-      List<T> data = getAllFile(reader, clazz, true);
-      return new QueryResult<T>(data, getTime());
-    } catch (Exception ex) {
-      LOG.error("Cannot fetch records {}", clazz.getSimpleName());
-      throw new IOException("Cannot read from data store " + ex.getMessage());
+      String line;
+      while ((line = reader.readLine()) != null) {
+        if (!line.startsWith("#") && line.length() > 0) {
+          try {
+            T record = newRecord(line, clazz, false);
+            return record;
+          } catch (Exception ex) {
+            LOG.error("Cannot parse line {} in file {}", line, path, ex);
+          }
+        }
+      }
-        try {
-          reader.close();
-        } catch (IOException e) {
-          LOG.error("Failed closing file", e);
-        }
+        reader.close();
-      unlockRecordRead(clazz);
+    throw new IOException("Cannot read " + path + " for record " +
+        clazz.getSimpleName());
-   * Overwrite the existing data with a new data set.
-   *
-   * @param records List of records to write.
-   * @param writer BufferedWriter stream to write to.
-   * @return If the records were succesfully written.
+   * Get the path for a record class.
+   * @param clazz Class of the record.
+   * @return Path for this record class.
-  private <T extends BaseRecord> boolean writeAllFile(
-      Collection<T> records, BufferedWriter writer) {
-
-    try {
-      for (BaseRecord record : records) {
-        try {
-          String data = serializeString(record);
-          writer.write(data);
-          writer.newLine();
-        } catch (IllegalArgumentException ex) {
-          LOG.error("Cannot write record {} to file", record, ex);
-        }
-      }
-      writer.flush();
-      return true;
-    } catch (IOException e) {
-      LOG.error("Cannot commit records to file", e);
-      return false;
+  private <T extends BaseRecord> String getPathForClass(final Class<T> clazz) {
+    String className = StateStoreUtils.getRecordName(clazz);
+    StringBuilder sb = new StringBuilder();
+    sb.append(getRootDir());
+    if (sb.charAt(sb.length() - 1) != '/') {
+      sb.append("/");
-  }
-
-  /**
-   * Overwrite the existing data with a new data set. Replaces all records in
-   * the data store for this record class. If all records in the data store are
-   * not successfully committed, this function must return false and leave the
-   * data store unchanged.
-   *
-   * @param records List of records to write. All records must be of type
-   *                recordClass.
-   * @param recordClass Class of record to replace.
-   * @return true if all operations were successful, false otherwise.
-   * @throws StateStoreUnavailableException
-   */
-  public <T extends BaseRecord> boolean writeAll(
-      Collection<T> records, Class<T> recordClass)
-          throws StateStoreUnavailableException {
-    verifyDriverReady();
-    lockRecordWrite(recordClass);
-    BufferedWriter writer = null;
-    try {
-      writer = getWriter(recordClass, null);
-      return writeAllFile(records, writer);
-    } catch (Exception e) {
-      LOG.error(
-          "Cannot add records to file for {}", recordClass.getSimpleName(), e);
-      return false;
-    } finally {
-      if (writer != null) {
-        try {
-          writer.close();
-        } catch (IOException e) {
-          LOG.error(
-              "Cannot close writer for {}", recordClass.getSimpleName(), e);
-        }
-      }
-      unlockRecordWrite(recordClass);
-    }
-  }
-
-  /**
-   * Get the data file name.
-   *
-   * @return Data file name.
-   */
-  protected String getDataFileName() {
-    return DATA_FILE_NAME;
+    sb.append(className);
+    return sb.toString();
-
-    @SuppressWarnings("unchecked")
-    Class<T> clazz = (Class<T>) getRecordClass(records.get(0).getClass());
-    QueryResult<T> result;
-    try {
-      result = get(clazz);
-    } catch (IOException e) {
-      return false;
-    }
-    Map<Object, T> writeList = new HashMap<>();
+    long start = monotonicNow();
+    StateStoreMetrics metrics = getMetrics();
-    // Write all of the existing records
-    for (T existingRecord : result.getRecords()) {
-      String key = existingRecord.getPrimaryKey();
-      writeList.put(key, existingRecord);
-    }
+    // Check if any record exists
+    Map<String, T> toWrite = new HashMap<>();
+    for (T record : records) {
+      Class<? extends BaseRecord> recordClass = record.getClass();
+      String path = getPathForClass(recordClass);
+      String primaryKey = getPrimaryKey(record);
+      String recordPath = path + "/" + primaryKey;
-    // Add inserts and updates, overwrite any existing values
-    for (T updatedRecord : records) {
-      try {
-        updatedRecord.validate();
-        String key = updatedRecord.getPrimaryKey();
-        if (writeList.containsKey(key) && allowUpdate) {
-          // Update
-          writeList.put(key, updatedRecord);
+      if (exists(recordPath)) {
+        if (allowUpdate) {
-          updatedRecord.setDateModified(this.getTime());
-        } else if (!writeList.containsKey(key)) {
-          // Insert
-          // Create/Mod timestamps are already initialized
-          writeList.put(key, updatedRecord);
+          record.setDateModified(this.getTime());
+          toWrite.put(recordPath, record);
-              updatedRecord);
+              recordPath);
+          if (metrics != null) {
+            metrics.addFailure(monotonicNow() - start);
+          }
+        } else  {
+          LOG.debug("Not updating {}", record);
-      } catch (IllegalArgumentException ex) {
-        LOG.error("Cannot write invalid record to State Store", ex);
-        return false;
+      } else {
+        toWrite.put(recordPath, record);
-    // Write all
-    boolean status = writeAll(writeList.values(), clazz);
-    return status;
+    // Write the records
+    boolean success = true;
+    for (Entry<String, T> entry : toWrite.entrySet()) {
+      String recordPath = entry.getKey();
+      String recordPathTemp = recordPath + "." + now() + TMP_MARK;
+      BufferedWriter writer = getWriter(recordPathTemp);
+      try {
+        T record = entry.getValue();
+        String line = serializeString(record);
+        writer.write(line);
+      } catch (IOException e) {
+        LOG.error("Cannot write {}", recordPathTemp, e);
+        success = false;
+      } finally {
+        if (writer != null) {
+          try {
+            writer.close();
+          } catch (IOException e) {
+            LOG.error("Cannot close the writer for {}", recordPathTemp);
+          }
+        }
+      }
+      // Commit
+      if (!rename(recordPathTemp, recordPath)) {
+        LOG.error("Failed committing record into {}", recordPath);
+        success = false;
+      }
+    }
+
+    long end = monotonicNow();
+    if (metrics != null) {
+      if (success) {
+        metrics.addWrite(end - start);
+      } else {
+        metrics.addFailure(end - start);
+      }
+    }
+    return success;
+    long start = Time.monotonicNow();
+    StateStoreMetrics metrics = getMetrics();
-      removed = recordsToRemove.size();
-      final List<T> newRecords = new LinkedList<>();
-      for (T record : existingRecords) {
-        if (!recordsToRemove.contains(record)) {
-          newRecords.add(record);
+      boolean success = true;
+      for (T recordToRemove : recordsToRemove) {
+        String path = getPathForClass(clazz);
+        String primaryKey = getPrimaryKey(recordToRemove);
+        String recordToRemovePath = path + "/" + primaryKey;
+        if (remove(recordToRemovePath)) {
+          removed++;
+        } else {
+          LOG.error("Cannot remove record {}", recordToRemovePath);
+          success = false;
-      if (!writeAll(newRecords, clazz)) {
-        throw new IOException(
-            "Cannot remove record " + clazz + " query " + query);
+      if (!success) {
+        LOG.error("Cannot remove records {} query {}", clazz, query);
+        if (metrics != null) {
+          metrics.addFailure(monotonicNow() - start);
+        }
+      if (metrics != null) {
+        metrics.addFailure(monotonicNow() - start);
+      }
+    if (removed > 0 && metrics != null) {
+      metrics.addRemove(monotonicNow() - start);
+    }
-    List<T> emptyList = new ArrayList<>();
-    boolean status = writeAll(emptyList, clazz);
-    return status;
+    long start = Time.monotonicNow();
+    StateStoreMetrics metrics = getMetrics();
+
+    boolean success = true;
+    String path = getPathForClass(clazz);
+    List<String> children = getChildren(path);
+    for (String child : children) {
+      String pathRecord = path + "/" + child;
+      if (!remove(pathRecord)) {
+        success = false;
+      }
+    }
+
+    if (metrics != null) {
+      long time = Time.monotonicNow() - start;
+      if (success) {
+        metrics.addRemove(time);
+      } else {
+        metrics.addFailure(time);
+      }
+    }
+    return success;

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV31 MOV31 INS40 UPD40 UPD40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS43 INS59 MOV73 MOV43 UPD42 MOV73 MOV43 UPD42 MOV44 UPD39 UPD42 MOV44 INS39 INS42 MOV29 UPD83 MOV83 INS83 UPD74 MOV74 UPD42 MOV42 MOV44 MOV78 INS83 MOV73 MOV74 INS42 MOV44 MOV43 INS8 INS78 UPD83 INS83 UPD42 INS8 UPD83 MOV73 MOV43 UPD42 MOV43 MOV29 UPD83 MOV73 UPD42 INS44 UPD66 INS66 INS66 INS66 UPD42 UPD45 UPD65 MOV65 INS42 INS32 INS65 UPD42 MOV42 INS42 INS32 INS65 INS43 INS42 INS65 UPD42 INS65 UPD65 INS65 UPD42 INS43 INS42 INS65 UPD65 INS65 INS43 INS42 UPD65 UPD43 UPD43 UPD42 MOV21 MOV60 INS60 MOV60 INS54 INS25 MOV41 INS42 INS83 INS43 UPD42 INS25 INS60 INS25 MOV41 UPD65 MOV65 INS83 INS43 UPD42 INS83 MOV74 INS42 INS54 INS53 INS65 INS83 MOV74 INS42 INS60 INS60 INS21 INS25 INS21 INS60 INS60 INS70 INS60 INS60 INS25 INS60 INS60 INS25 INS60 INS60 INS60 INS60 INS70 INS25 UPD66 UPD66 INS40 INS42 INS34 INS66 INS42 INS42 INS45 UPD66 UPD42 UPD66 INS66 UPD42 MOV42 UPD66 UPD42 UPD66 INS66 INS66 INS42 UPD66 UPD42 UPD66 INS66 UPD42 MOV42 INS66 INS42 UPD66 INS66 UPD42 MOV42 UPD66 UPD42 UPD66 UPD66 UPD42 UPD42 INS39 INS43 INS59 INS8 INS12 INS27 INS8 UPD66 UPD42 UPD66 UPD66 UPD42 MOV42 INS38 MOV8 INS43 INS59 INS32 INS8 UPD66 UPD42 UPD66 UPD66 UPD42 INS66 UPD42 MOV42 MOV43 INS8 MOV8 INS14 UPD66 INS66 INS43 INS59 INS43 INS59 INS32 INS27 INS8 INS32 INS32 INS39 INS59 INS43 INS59 UPD74 MOV44 INS42 INS8 INS39 INS59 INS32 INS8 UPD39 MOV39 INS59 INS27 INS8 UPD42 INS39 INS59 INS43 INS59 INS27 INS8 INS39 INS59 INS43 INS59 INS39 INS59 INS43 INS59 UPD74 INS44 INS42 INS8 INS27 INS8 UPD42 UPD42 INS32 UPD42 MOV42 INS42 INS32 MOV43 MOV43 UPD42 INS60 INS60 INS70 MOV44 INS8 INS42 INS33 INS21 UPD42 INS32 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS60 INS41 UPD42 INS32 MOV60 INS61 MOV43 INS27 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS32 INS13 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 UPD43 UPD42 MOV60 INS60 INS60 INS60 INS25 INS42 INS9 INS74 INS42 UPD42 MOV42 UPD42 MOV42 MOV60 INS60 INS60 INS54 INS25 INS42 INS32 INS42 INS33 INS25 INS42 INS32 INS42 INS42 INS32 INS60 INS70 INS27 INS27 INS21 INS42 INS32 INS42 INS42 INS32 INS42 INS9 INS42 INS42 INS32 UPD43 UPD42 INS32 INS43 INS42 INS60 INS25 INS42 INS33 MOV60 INS25 INS42 UPD42 MOV42 MOV42 MOV43 INS59 INS74 INS59 INS44 INS42 INS8 INS25 MOV60 MOV21 MOV53 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS39 INS59 INS27 INS42 INS42 MOV27 INS8 MOV8 INS45 INS42 INS45 MOV32 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS27 INS32 INS42 INS42 UPD42 INS74 INS43 INS59 INS43 MOV59 INS43 INS59 INS32 INS8 INS8 INS43 INS43 MOV43 MOV43 MOV43 INS59 MOV43 INS59 INS8 INS12 MOV8 INS38 INS8 INS42 INS42 INS8 INS8 INS42 INS42 INS42 INS39 INS59 MOV44 INS42 INS8 INS25 INS42 INS34 INS42 INS33 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS43 INS59 INS38 INS8 UPD39 INS42 INS8 INS8 INS42 INS32 UPD43 MOV43 UPD43 MOV43 INS42 INS32 INS43 UPD42 MOV42 INS60 INS25 INS27 INS8 MOV43 INS42 INS42 INS27 INS42 INS32 INS27 INS42 INS25 INS42 INS32 INS34 INS42 INS42 INS45 INS43 INS76 INS42 INS32 UPD42 MOV42 INS42 INS32 UPD42 MOV42 INS42 INS32 INS42 INS42 INS27 UPD42 MOV42 UPD42 MOV42 INS25 MOV21 INS42 INS42 UPD42 INS42 INS27 INS42 INS32 INS60 MOV60 MOV21 MOV44 INS8 INS32 MOV21 INS21 INS21 INS21 INS42 INS9 UPD42 INS60 INS60 INS60 MOV25 INS42 INS21 INS25 INS27 INS8 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS21 UPD42 INS27 INS21 INS21 INS42 INS42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 MOV43 INS59 INS32 INS8 MOV8 INS42 INS33 INS21 UPD42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS42 MOV27 INS8 INS42 INS42 INS42 MOV43 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 MOV8 MOV21 INS25 UPD42 UPD42 INS42 INS45 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 MOV21 INS21 INS42 INS42 INS42 INS7 INS32 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS8 INS32 INS27 INS8 INS42 INS33 INS21 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS7 INS32 INS42 INS32 INS32 INS42 INS27 INS42 INS42 INS42 INS21 INS25 INS32 INS45 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS34 UPD42 MOV42 MOV54 INS42 INS8 INS8 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 INS7 UPD45 UPD42 INS42 INS9 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 INS27 INS42 INS42 INS32 UPD42 MOV42 INS42 INS32 UPD42 MOV42 INS42 INS27 UPD42 MOV42 UPD42 MOV42 INS21 INS21 INS42 INS42 INS45 INS42 INS42 INS42 INS33 INS21 INS32 INS42 INS42 INS9 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS32 INS32 INS8 UPD42 MOV42 UPD42 MOV42 INS27 UPD42 MOV42 UPD42 MOV42 INS21 INS25 MOV41 INS21 INS42 INS42 UPD45 UPD42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS45 INS42 INS37 INS7 INS32 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS42 MOV21 MOV21 INS32 INS42 INS60 MOV44 UPD42 UPD42 UPD42 UPD42 INS32 INS27 INS8 INS32 INS42 UPD42 UPD42 INS45 UPD42 INS42 INS9 INS42 INS42 INS27 INS32 INS42 UPD42 UPD42 INS42 MOV43 INS59 INS42 UPD42 MOV42 INS42 INS45 UPD42 MOV42 INS42 INS33 INS21 INS42 INS42 INS45 INS42 INS32 INS42 INS42 UPD42 INS42 INS45 INS42 UPD42 UPD42 INS42 INS32 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS9 UPD45 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 INS27 UPD45 UPD42 MOV42 INS32 INS42 INS42 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL73 DEL39 DEL42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL44 DEL31 DEL42 DEL42 DEL43 DEL73 DEL39 DEL43 DEL42 DEL43 DEL74 DEL42 DEL39 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL83 DEL83 DEL42 DEL42 DEL43 DEL73 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL31 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL43 DEL73 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL66 DEL65 DEL42 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL42 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL74 DEL14 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL9 DEL32 DEL45 DEL45 DEL42 DEL42 DEL32 DEL27 DEL39 DEL42 DEL44 DEL43 DEL42 DEL44 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL61 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL42 DEL43 DEL73 DEL74 DEL42 DEL42 DEL43 DEL43 DEL74 DEL44 DEL42 DEL42 DEL33 DEL11 DEL32 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL73 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL66 DEL65 DEL43 DEL74 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL32 DEL21 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL70 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL39 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL21 DEL33 DEL42 DEL33 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL32 DEL9 DEL41 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL32 DEL21 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL43 DEL74 DEL60 DEL42 DEL32 DEL7 DEL21 DEL8 DEL12 DEL54 DEL42 DEL45 DEL79 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL32 DEL11 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL27 DEL42 DEL32 DEL38 DEL8 DEL42 DEL8 DEL25 DEL25 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL9 DEL41 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL38 DEL42 DEL32 DEL7 DEL21 DEL83 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL8 DEL70 DEL42 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL42 DEL27 DEL14 DEL53 DEL42 DEL43 DEL74 DEL14 DEL42 DEL32
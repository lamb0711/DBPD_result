HDDS-1184. Parallelization of write chunks in datanodes is broken. Contributed by Shashikant Banerjee.

+import org.apache.hadoop.hdds.scm.container.common.helpers.StorageContainerException;
+import org.apache.hadoop.ozone.container.common.helpers.ContainerUtils;
-      ContainerCommandRequestProto requestProto,
-      DispatcherContext context) throws IOException {
+      ContainerCommandRequestProto requestProto, DispatcherContext context) {
-    if(isBlockTokenEnabled) {
-      // ServerInterceptors intercepts incoming request and creates ugi.
-      tokenVerifier.verify(UserGroupInformation.getCurrentUser()
-          .getShortUserName(), requestProto.getEncodedToken());
+    if (isBlockTokenEnabled) {
+      try {
+        // ServerInterceptors intercepts incoming request and creates ugi.
+        tokenVerifier
+            .verify(UserGroupInformation.getCurrentUser().getShortUserName(),
+                requestProto.getEncodedToken());
+      } catch (IOException ioe) {
+        StorageContainerException sce = new StorageContainerException(
+            "Block token verification failed. " + ioe.getMessage(), ioe,
+            ContainerProtos.Result.BLOCK_TOKEN_VERIFICATION_FAILED);
+        return ContainerUtils.logAndReturnError(LOG, sce, requestProto);
+      }
-      DispatcherContext context) throws IOException {
+      DispatcherContext context) {
-    CompletableFuture<Message> writeChunkFuture;
-    try {
-      Message msg = runCommand(requestProto, context);
-      writeChunkFuture = CompletableFuture
-          .supplyAsync(() -> msg, chunkExecutor);
-    }catch(IOException ie) {
-      writeChunkFuture = completeExceptionally(ie);
-    }
+    // ensure the write chunk happens asynchronously in writeChunkExecutor pool
+    // thread.
+    CompletableFuture<Message> writeChunkFuture = CompletableFuture
+        .supplyAsync(() -> runCommand(requestProto, context), chunkExecutor);
-        CompletableFuture<ByteString> future = new CompletableFuture<>();
-        return future.supplyAsync(() -> {
+        final CompletableFuture<ByteString> future = new CompletableFuture<>();
+        CompletableFuture.supplyAsync(() -> {
-            return getCachedStateMachineData(entry.getIndex(), entry.getTerm(),
-                requestProto);
+            future.complete(
+                getCachedStateMachineData(entry.getIndex(), entry.getTerm(),
+                    requestProto));
-            return null;
+          return future;
+        return future;
-      CompletableFuture<Message> future;
-      try {
-        Message msg = runCommand(requestProto, builder.build());
-        future = CompletableFuture.supplyAsync(() -> msg,
-            getCommandExecutor(requestProto));
-      } catch (IOException ie) {
-        future = completeExceptionally(ie);
-      }
+      // Ensure the command gets executed in a separate thread than
+      // stateMachineUpdater thread which is calling applyTransaction here.
+      CompletableFuture<Message> future = CompletableFuture
+          .supplyAsync(() -> runCommand(requestProto, builder.build()),
+              getCommandExecutor(requestProto));

INS26 INS26 INS40 INS40 MOV60 INS8 MOV74 INS54 UPD42 INS32 MOV60 MOV8 INS12 INS42 INS42 INS86 INS42 MOV74 INS44 INS8 MOV32 INS21 UPD42 INS32 MOV43 INS42 INS60 INS41 INS83 MOV32 INS42 INS42 INS42 INS86 MOV32 INS43 INS59 INS32 UPD42 MOV32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS40 INS41 INS42 INS45 INS32 INS42 INS42 INS42 INS21 INS32 INS42 INS42 MOV32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL86 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL12 DEL54 DEL41 DEL33 DEL41 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL86 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL12 DEL54
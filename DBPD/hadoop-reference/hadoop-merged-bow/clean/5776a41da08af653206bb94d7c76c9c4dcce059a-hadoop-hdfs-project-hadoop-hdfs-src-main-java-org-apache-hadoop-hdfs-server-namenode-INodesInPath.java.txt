HDFS-7498. Simplify the logic in INodesInPath. Contributed by Jing Zhao.

+import java.util.Collections;
+import java.util.List;
+import java.util.NoSuchElementException;
+import static org.apache.hadoop.hdfs.server.namenode.snapshot.Snapshot.CURRENT_STATE_ID;
+import static org.apache.hadoop.hdfs.server.namenode.snapshot.Snapshot.ID_INTEGER_COMPARATOR;
+
-    final INodesInPath iip = new INodesInPath(path, depth);
-    iip.setINodes(inodes);
-    return iip;
+    return new INodesInPath(inodes, path);
-      final byte[][] components, final int numOfINodes, 
+      final byte[][] components, final int numOfINodes,
-    final INodesInPath existing = new INodesInPath(components, numOfINodes);
-    int index = numOfINodes - components.length;
-    if (index > 0) {
-      index = 0;
-    }
+    int index = numOfINodes <= components.length ?
+        numOfINodes - components.length : 0;
+    int inodeNum = 0;
+    int capacity = numOfINodes;
+    INode[] inodes = new INode[numOfINodes];
+    boolean isSnapshot = false;
+    int snapshotId = CURRENT_STATE_ID;
+
-        existing.addNode(curNode);
+        inodes[inodeNum++] = curNode;
-        if (!existing.isSnapshot()) {
-          existing.updateLatestSnapshotId(dir.getDirectoryWithSnapshotFeature()
-              .getLastSnapshotId());
+        if (!isSnapshot && shouldUpdateLatestId(
+            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),
+            snapshotId)) {
+          snapshotId = dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();
-        if (!existing.isSnapshot()) {
+        if (!isSnapshot) {
-          int latest = existing.getLatestSnapshotId();
-          if (latest == Snapshot.CURRENT_STATE_ID || // no snapshot in dst tree of rename
-              (dstSnapshotId != Snapshot.CURRENT_STATE_ID && 
-                dstSnapshotId >= latest)) { // the above scenario 
-            int lastSnapshot = Snapshot.CURRENT_STATE_ID;
+          if (snapshotId == CURRENT_STATE_ID || // no snapshot in dst tree of rename
+              (dstSnapshotId != CURRENT_STATE_ID &&
+               dstSnapshotId >= snapshotId)) { // the above scenario
+            int lastSnapshot = CURRENT_STATE_ID;
-            existing.setSnapshotId(lastSnapshot);
+            snapshotId = lastSnapshot;
-        existing.isSnapshot = true;
+        isSnapshot = true;
-          existing.capacity--;
+          capacity--;
-          //snapshot not found
-          curNode = null;
+          curNode = null; // snapshot not found
-          existing.setSnapshotId(s.getId());
-        }
-        if (index >= -1) {
-          existing.snapshotRootIndex = existing.numNonNull;
+          snapshotId = s.getId();
-        curNode = dir.getChild(childName, existing.getPathSnapshotId());
+        curNode = dir.getChild(childName,
+            isSnapshot ? snapshotId : CURRENT_STATE_ID);
-    return existing;
+    if (isSnapshot && capacity < numOfINodes &&
+        !isDotSnapshotDir(components[components.length - 1])) {
+      // for snapshot path shrink the inode array. however, for path ending with
+      // .snapshot, still keep last the null inode in the array
+      INode[] newNodes = new INode[capacity];
+      System.arraycopy(inodes, 0, newNodes, 0, capacity);
+      inodes = newNodes;
+    }
+    return new INodesInPath(inodes, components, isSnapshot, snapshotId);
+  }
+
+  private static boolean shouldUpdateLatestId(int sid, int snapshotId) {
+    return snapshotId == CURRENT_STATE_ID || (sid != CURRENT_STATE_ID &&
+        ID_INTEGER_COMPARATOR.compare(snapshotId, sid) < 0);
+  }
+
+  /**
+   * Replace an inode of the given INodesInPath in the given position. We do a
+   * deep copy of the INode array.
+   * @param pos the position of the replacement
+   * @param inode the new inode
+   * @return a new INodesInPath instance
+   */
+  public static INodesInPath replace(INodesInPath iip, int pos, INode inode) {
+    Preconditions.checkArgument(iip.length() > 0 && pos > 0 // no for root
+        && pos < iip.length());
+    if (iip.getINode(pos) == null) {
+      Preconditions.checkState(iip.getINode(pos - 1) != null);
+    }
+    INode[] inodes = new INode[iip.inodes.length];
+    System.arraycopy(iip.inodes, 0, inodes, 0, inodes.length);
+    inodes[pos] = inode;
+    return new INodesInPath(inodes, iip.path, iip.isSnapshot, iip.snapshotId);
-  private INode[] inodes;
-  /**
-   * Indicate the number of non-null elements in {@link #inodes}
-   */
-  private int numNonNull;
-  /**
-   * The path for a snapshot file/dir contains the .snapshot thus makes the
-   * length of the path components larger the number of inodes. We use
-   * the capacity to control this special case.
-   */
-  private int capacity;
+  private final INode[] inodes;
-  private boolean isSnapshot;
-  /**
-   * index of the {@link Snapshot.Root} node in the inodes array,
-   * -1 for non-snapshot paths.
-   */
-  private int snapshotRootIndex;
+  private final boolean isSnapshot;
-  private int snapshotId = Snapshot.CURRENT_STATE_ID; 
+  private final int snapshotId;
-  private INodesInPath(byte[][] path, int number) {
+  private INodesInPath(INode[] inodes, byte[][] path, boolean isSnapshot,
+      int snapshotId) {
+    Preconditions.checkArgument(inodes != null && path != null);
+    this.inodes = inodes;
-    assert (number >= 0);
-    inodes = new INode[number];
-    capacity = number;
-    numNonNull = 0;
-    isSnapshot = false;
-    snapshotRootIndex = -1;
+    this.isSnapshot = isSnapshot;
+    this.snapshotId = snapshotId;
+  }
+
+  private INodesInPath(INode[] inodes, byte[][] path) {
+    this(inodes, path, false, CURRENT_STATE_ID);
-    return isSnapshot ? snapshotId : Snapshot.CURRENT_STATE_ID;
+    return isSnapshot ? snapshotId : CURRENT_STATE_ID;
-  private void setSnapshotId(int sid) {
-    snapshotId = sid;
-  }
-  
-  private void updateLatestSnapshotId(int sid) {
-    if (snapshotId == Snapshot.CURRENT_STATE_ID
-        || (sid != Snapshot.CURRENT_STATE_ID && Snapshot.ID_INTEGER_COMPARATOR
-            .compare(snapshotId, sid) < 0)) {
-      snapshotId = sid;
-    }
-  }
-
-  /**
-   * @return a new array of inodes excluding the null elements introduced by
-   * snapshot path elements. E.g., after resolving path "/dir/.snapshot",
-   * {@link #inodes} is {/, dir, null}, while the returned array only contains
-   * inodes of "/" and "dir". Note the length of the returned array is always
-   * equal to {@link #capacity}.
-   */
-  INode[] getINodes() {
-    if (capacity == inodes.length) {
-      return inodes;
-    }
-
-    INode[] newNodes = new INode[capacity];
-    System.arraycopy(inodes, 0, newNodes, 0, capacity);
-    return newNodes;
-  }
-  
-    return inodes[i >= 0? i: inodes.length + i];
+    if (inodes == null || inodes.length == 0) {
+      throw new NoSuchElementException("inodes is null or empty");
+    }
+    int index = i >= 0 ? i : inodes.length + i;
+    if (index < inodes.length && index >= 0) {
+      return inodes[index];
+    } else {
+      throw new NoSuchElementException("inodes.length == " + inodes.length);
+    }
-    return inodes[inodes.length - 1];
+    return getINode(-1);
-  /**
-   * @return index of the {@link Snapshot.Root} node in the inodes array,
-   * -1 for non-snapshot paths.
-   */
-  int getSnapshotRootIndex() {
-    return this.snapshotRootIndex;
+  public String getParentPath() {
+    return getPath(path.length - 1);
-  
+
+  public String getPath(int pos) {
+    return DFSUtil.byteArray2PathString(path, 0, pos);
+  }
+
+  public int length() {
+    return inodes.length;
+  }
+
+  public List<INode> getReadOnlyINodes() {
+    return Collections.unmodifiableList(Arrays.asList(inodes));
+  }
+
-  
-  /**
-   * Add an INode at the end of the array
-   */
-  private void addNode(INode node) {
-    inodes[numNonNull++] = node;
-  }
-  private void setINodes(INode inodes[]) {
-    this.inodes = inodes;
-    this.numNonNull = this.inodes.length;
-  }
-  
-  void setINode(int i, INode inode) {
-    inodes[i >= 0? i: inodes.length + i] = inode;
-  }
-  
-  void setLastINode(INode last) {
-    inodes[inodes.length - 1] = last;
-  }
-  
-  /**
-   * @return The number of non-null elements
-   */
-  int getNumNonNull() {
-    return numNonNull;
-  }
-  
-    b.append("\n  numNonNull = ").append(numNonNull)
-     .append("\n  capacity   = ").append(capacity)
-     .append("\n  isSnapshot        = ").append(isSnapshot)
-     .append("\n  snapshotRootIndex = ").append(snapshotRootIndex)
+    b.append("\n  isSnapshot        = ").append(isSnapshot)
-    // check parent up to snapshotRootIndex or numNonNull
-    final int n = snapshotRootIndex >= 0? snapshotRootIndex + 1: numNonNull;  
+    // check parent up to snapshotRootIndex if this is a snapshot path
-      for(i++; i < n && inodes[i] != null; i++) {
+      for(i++; i < inodes.length && inodes[i] != null; i++) {
-    if (i != n) {
-      throw new AssertionError("i = " + i + " != " + n
+    if (i != inodes.length) {
+      throw new AssertionError("i = " + i + " != " + inodes.length

INS26 INS26 INS26 INS26 INS26 MOV31 MOV31 MOV31 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV60 MOV25 INS83 INS83 INS39 UPD42 MOV42 MOV44 MOV44 MOV8 INS83 INS83 MOV43 INS42 INS44 INS44 MOV44 INS83 INS83 INS83 UPD83 MOV83 UPD42 MOV42 INS44 MOV44 INS44 INS44 INS8 UPD42 INS44 MOV29 UPD83 MOV83 MOV43 UPD42 MOV42 MOV44 INS8 MOV29 INS83 MOV43 UPD42 MOV42 INS8 INS83 INS43 INS42 MOV8 INS83 INS43 INS42 INS44 INS83 INS39 INS42 INS8 INS83 INS74 INS42 INS8 INS60 INS60 INS60 INS60 UPD42 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS21 INS21 MOV5 INS42 INS39 INS42 INS39 INS42 INS21 MOV21 MOV21 INS21 INS21 INS5 UPD42 INS5 INS42 INS17 INS25 INS60 INS25 INS41 UPD42 MOV42 INS41 INS42 INS39 INS42 INS41 INS43 MOV43 INS41 MOV14 INS39 INS59 INS39 INS59 INS5 INS39 INS59 INS39 INS59 UPD27 INS14 INS27 UPD66 MOV66 UPD66 MOV66 INS42 UPD66 MOV66 INS42 INS66 UPD66 MOV66 INS42 INS32 MOV5 INS7 INS14 INS32 INS7 INS7 INS43 INS85 INS39 INS85 INS85 INS42 INS42 INS9 INS42 INS27 INS8 INS39 INS59 INS27 INS8 INS8 INS32 INS32 INS32 INS40 INS42 INS32 UPD42 UPD42 INS16 INS42 INS34 INS42 INS42 INS43 INS85 UPD42 INS3 INS42 INS9 INS42 INS42 INS27 INS38 INS60 INS21 MOV43 INS42 INS42 INS42 INS42 MOV27 MOV36 INS42 INS42 INS27 INS32 INS33 INS21 UPD42 INS40 UPD42 INS40 INS2 INS42 MOV43 INS42 INS40 INS40 INS40 INS42 INS42 INS27 INS22 INS42 INS22 INS42 MOV42 INS42 INS27 INS27 INS53 INS42 MOV16 INS27 INS27 INS41 INS53 INS42 MOV38 INS42 INS27 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS32 INS40 INS27 MOV27 INS34 INS42 INS5 INS42 MOV8 UPD42 MOV42 INS27 INS32 MOV5 INS59 INS32 INS7 INS42 INS27 INS27 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS27 INS27 INS52 INS42 MOV52 UPD42 MOV42 INS42 INS33 INS40 INS34 INS14 INS42 INS40 INS42 INS34 INS2 INS14 UPD40 MOV40 MOV34 INS42 INS42 INS42 MOV32 MOV42 INS42 INS40 INS43 INS85 INS25 INS42 INS42 INS42 INS2 INS42 INS3 INS42 INS42 MOV42 INS34 INS42 INS34 MOV42 INS42 INS42 INS27 INS27 INS42 INS32 INS42 INS42 INS27 INS42 INS33 INS42 INS33 INS43 INS45 MOV42 INS42 INS43 INS27 INS42 INS7 INS27 INS8 INS42 INS27 INS5 MOV42 INS42 INS32 INS34 INS42 INS34 INS42 INS42 INS32 INS33 INS42 INS42 INS45 INS40 MOV42 MOV42 INS40 INS40 INS2 INS42 INS38 MOV32 MOV42 MOV21 INS42 INS40 UPD34 MOV34 INS43 INS85 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS37 INS42 UPD42 UPD42 INS7 INS42 INS7 INS16 INS42 INS42 INS34 INS42 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 INS42 INS7 INS42 INS42 INS42 INS42 UPD42 DEL83 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL83 DEL42 DEL42 DEL14 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL25 DEL8 DEL42 DEL42 DEL32 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL40 DEL40 DEL42 DEL42 DEL42 DEL32 DEL40 DEL40 DEL42 DEL42 DEL32 DEL42 DEL34 DEL38 DEL27 DEL40 DEL40 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL34 DEL7 DEL42 DEL40 DEL40 DEL40 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL67 DEL65 DEL66 DEL66 DEL42 DEL67 DEL65 DEL65 DEL42 DEL42 DEL40 DEL42 DEL41 DEL42 DEL66 DEL42 DEL67 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL40 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL40 DEL66 DEL65 DEL29 DEL39 DEL43 DEL42 DEL42 DEL37 DEL2 DEL42 DEL7 DEL21 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL34 DEL27 DEL36 DEL6 DEL42 DEL42 DEL3 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL7 DEL21 DEL8 DEL31 DEL40 DEL83 DEL39 DEL42 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL31 DEL42 DEL42 DEL34 DEL27 DEL42 DEL40 DEL42 DEL27 DEL16 DEL2 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL40 DEL34 DEL27 DEL2 DEL41 DEL8 DEL31 DEL42 DEL27 DEL2 DEL42 DEL7 DEL21 DEL66 DEL40 DEL65 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL22 DEL41 DEL8 DEL31 DEL39 DEL42 DEL85 DEL44 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL22 DEL7 DEL21 DEL8 DEL31 DEL39 DEL42 DEL39 DEL42 DEL44 DEL2 DEL42 DEL7 DEL21 DEL8 DEL31 DEL39 DEL43 DEL42 DEL44 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL83 DEL39 DEL42 DEL42 DEL34 DEL27 DEL42 DEL34 DEL27 DEL42 DEL16 DEL59 DEL60 DEL42 DEL42 DEL42
HDFS-7853. Erasure coding: extend LocatedBlocks to support reading from striped files. Contributed by Jing Zhao.

-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-   *
-   * TODO: we need to update this attribute, along with the return type of
-   * getExpectedStorageLocations and LocatedBlock. For striped blocks, clients
-   * need to understand the index of each striped block in the block group.
-  private List<ReplicaUnderConstruction> replicas;
+  private ReplicaUnderConstruction[] replicas;
-   * 
+   *
-   * @throws IOException if the state of the block 
-   * (the generation stamp and the length) has not been committed by 
-   * the client or it does not have at least a minimal number of replicas 
-   * reported from data-nodes. 
+   * @throws IOException if the state of the block
+   * (the generation stamp and the length) has not been committed by
+   * the client or it does not have at least a minimal number of replicas
+   * reported from data-nodes.
-    this.replicas = new ArrayList<>(numLocations);
+    this.replicas = new ReplicaUnderConstruction[numLocations];
-      replicas.add(new ReplicaUnderConstruction(this, targets[i],
-          ReplicaState.RBW));
+      // when creating a new block we simply sequentially assign block index to
+      // each storage
+      Block blk = new Block(this.getBlockId() + i, this.getGenerationStamp(), 0);
+      replicas[i] = new ReplicaUnderConstruction(blk, targets[i],
+          ReplicaState.RBW);
-      storages[i] = replicas.get(i).getExpectedStorageLocation();
+      storages[i] = replicas[i].getExpectedStorageLocation();
+  /** @return the index array indicating the block index in each storage */
+  public int[] getBlockIndices() {
+    int numLocations = getNumExpectedLocations();
+    int[] indices = new int[numLocations];
+    for (int i = 0; i < numLocations; i++) {
+      indices[i] = BlockIdManager.getBlockIndex(replicas[i]);
+    }
+    return indices;
+  }
+
-    return replicas == null ? 0 : replicas.size();
+    return replicas == null ? 0 : replicas.length;
-    if (replicas == null || replicas.size() == 0) {
+    if (replicas == null || replicas.length == 0) {
-  void addReplicaIfNotPresent(DatanodeStorageInfo storage, Block block,
+  void addReplicaIfNotPresent(DatanodeStorageInfo storage, Block reportedBlock,
-    Iterator<ReplicaUnderConstruction> it = replicas.iterator();
-    while (it.hasNext()) {
-      ReplicaUnderConstruction r = it.next();
-      DatanodeStorageInfo expectedLocation = r.getExpectedStorageLocation();
-      if (expectedLocation == storage) {
-        // Record the gen stamp from the report
-        r.setGenerationStamp(block.getGenerationStamp());
-        return;
-      } else if (expectedLocation != null &&
-          expectedLocation.getDatanodeDescriptor() ==
-              storage.getDatanodeDescriptor()) {
-        // The Datanode reported that the block is on a different storage
-        // than the one chosen by BlockPlacementPolicy. This can occur as
-        // we allow Datanodes to choose the target storage. Update our
-        // state by removing the stale entry and adding a new one.
-        it.remove();
-        break;
+    if (replicas == null) {
+      replicas = new ReplicaUnderConstruction[1];
+      replicas[0] = new ReplicaUnderConstruction(reportedBlock, storage, rState);
+    } else {
+      for (int i = 0; i < replicas.length; i++) {
+        DatanodeStorageInfo expected = replicas[i].getExpectedStorageLocation();
+        if (expected == storage) {
+          replicas[i].setBlockId(reportedBlock.getBlockId());
+          replicas[i].setGenerationStamp(reportedBlock.getGenerationStamp());
+          return;
+        } else if (expected != null && expected.getDatanodeDescriptor() ==
+            storage.getDatanodeDescriptor()) {
+          // The Datanode reported that the block is on a different storage
+          // than the one chosen by BlockPlacementPolicy. This can occur as
+          // we allow Datanodes to choose the target storage. Update our
+          // state by removing the stale entry and adding a new one.
+          replicas[i] = new ReplicaUnderConstruction(reportedBlock, storage,
+              rState);
+          return;
+        }
+      ReplicaUnderConstruction[] newReplicas =
+          new ReplicaUnderConstruction[replicas.length + 1];
+      System.arraycopy(replicas, 0, newReplicas, 0, replicas.length);
+      newReplicas[newReplicas.length - 1] = new ReplicaUnderConstruction(
+          reportedBlock, storage, rState);
+      replicas = newReplicas;
-    replicas.add(new ReplicaUnderConstruction(block, storage, rState));
-      Iterator<ReplicaUnderConstruction> iter = replicas.iterator();
-      if (iter.hasNext()) {
-        iter.next().appendStringTo(sb);
-        while (iter.hasNext()) {
+      int i = 0;
+      for (ReplicaUnderConstruction r : replicas) {
+        r.appendStringTo(sb);
+        if (++i < replicas.length) {
-          iter.next().appendStringTo(sb);

INS23 INS31 MOV29 MOV83 INS5 MOV59 INS29 INS83 INS5 INS42 INS8 MOV43 INS85 INS65 INS39 INS85 INS60 INS60 INS24 INS41 UPD42 INS25 UPD66 UPD66 UPD66 UPD66 INS66 INS39 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS27 INS8 INS8 INS3 INS60 INS42 INS32 INS39 INS85 INS42 INS3 INS39 INS59 INS42 INS42 INS42 INS21 INS40 INS42 INS33 INS21 INS21 INS24 INS60 INS21 INS21 INS21 INS60 INS70 INS5 INS42 INS43 INS59 INS7 INS42 INS5 INS42 INS42 INS34 INS7 INS40 INS7 INS7 INS58 INS27 INS37 INS8 INS5 INS59 INS32 INS7 INS7 INS39 INS59 INS44 INS42 INS8 INS43 INS85 INS42 INS42 INS14 INS2 MOV14 INS39 INS85 INS2 INS32 INS42 INS3 INS2 INS14 INS39 INS59 INS42 INS40 INS42 MOV60 MOV25 INS43 INS85 INS42 INS3 INS42 INS42 MOV42 INS34 UPD42 MOV42 INS34 INS40 INS2 INS14 INS42 INS42 INS42 INS34 INS43 INS42 MOV21 INS25 UPD42 MOV42 INS43 INS27 INS32 INS34 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS2 INS5 INS34 INS42 INS34 MOV43 INS42 INS42 INS42 UPD42 MOV42 INS34 INS42 INS5 INS27 INS42 INS27 MOV43 UPD42 MOV42 MOV42 MOV42 MOV42 INS27 MOV8 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS42 INS42 MOV43 INS85 UPD42 UPD42 INS21 INS43 INS85 INS40 INS34 INS40 INS34 UPD42 MOV42 INS38 INS40 INS52 INS42 INS2 INS32 INS41 INS42 INS42 INS42 INS42 INS2 INS42 INS32 INS2 UPD42 INS7 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS2 INS14 INS42 INS42 MOV43 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL66 DEL42 DEL43 DEL74 DEL23 DEL43 DEL74 DEL42 DEL14 DEL52 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL10 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL61 DEL14 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL61 DEL8 DEL25
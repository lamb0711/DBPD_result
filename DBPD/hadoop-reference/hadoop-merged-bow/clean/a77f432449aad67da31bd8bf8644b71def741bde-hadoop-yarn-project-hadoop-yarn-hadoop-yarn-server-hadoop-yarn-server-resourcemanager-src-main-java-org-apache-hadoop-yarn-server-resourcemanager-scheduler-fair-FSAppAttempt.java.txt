YARN-6171. ConcurrentModificationException on FSAppAttempt.containersToPreempt. (Miklos Szegedi via kasha)

+  private final Object preemptionVariablesLock = new Object();
+
-    if (containersToPreempt.add(container)) {
-      synchronized (preemptedResources) {
+    synchronized (preemptionVariablesLock) {
+      if (containersToPreempt.add(container)) {
-    if (containersToPreempt.remove(container)) {
-      synchronized (preemptedResources) {
+    synchronized (preemptionVariablesLock) {
+      if (containersToPreempt.remove(container)) {
-  Set<RMContainer> getPreemptionContainers() {
-    return containersToPreempt;
-  }
-
-  private Resource getPreemptedResources() {
-    synchronized (preemptedResources) {
-      return preemptedResources;
+  Set<ContainerId> getPreemptionContainerIds() {
+    synchronized (preemptionVariablesLock) {
+      Set<ContainerId> preemptionContainerIds = new HashSet<>();
+      for (RMContainer container : containersToPreempt) {
+        preemptionContainerIds.add(container.getContainerId());
+      }
+      return preemptionContainerIds;
-    if (containersToPreempt.contains(container)) {
-      // The container is already under consideration for preemption
-      return false;
+    synchronized (preemptionVariablesLock) {
+      if (containersToPreempt.contains(container)) {
+        // The container is already under consideration for preemption
+        return false;
+      }
-                  + allowedLocality + ", priority: " + schedulerKey.getPriority()
+                  + allowedLocality + ", priority: "
+                  + schedulerKey.getPriority()
-    /*
-     * getResourcesToPreempt() returns zero, except when there are containers
-     * to preempt. Avoid creating an object in the common case.
-     */
-    return getPreemptedResources().equals(Resources.none())
-        ? getCurrentConsumption()
-        : Resources.subtract(getCurrentConsumption(), getPreemptedResources());
+    // Subtract copies the object, so that we have a snapshot,
+    // in case usage changes, while the caller is using the value
+    synchronized (preemptionVariablesLock) {
+      return containersToPreempt.isEmpty()
+          ? getCurrentConsumption()
+          : Resources.subtract(getCurrentConsumption(), preemptedResources);
+    }

INS23 INS31 INS83 INS83 INS43 INS59 MOV8 MOV8 UPD74 MOV74 UPD42 MOV42 MOV8 INS8 INS42 INS42 INS14 UPD43 INS51 INS51 INS43 UPD42 INS8 UPD42 INS8 UPD42 UPD42 INS42 INS8 INS42 INS8 UPD42 MOV42 INS25 INS25 INS60 INS70 MOV25 MOV41 MOV32 MOV8 MOV32 MOV8 INS74 INS59 INS44 INS42 INS8 UPD42 INS43 INS43 INS42 INS14 INS43 INS42 INS21 INS42 INS42 INS74 INS42 INS32 UPD42 MOV42 UPD42 UPD42 MOV42 INS43 INS42 INS42 INS32 INS42 INS42 INS42 DEL25 DEL8 DEL25 DEL8 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL43 DEL31 DEL32 DEL42 DEL42 DEL32 DEL32 DEL8
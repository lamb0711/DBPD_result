HDFS-10206. Datanodes not sorted properly by distance when the reader isn't a datanode. (Nandakumar via mingma)

+  private static final char PATH_SEPARATOR = '/';
+  private static final String PATH_SEPARATOR_STR = "/";
+  private static final String ROOT = "/";
+
-  /** convert a network tree to a string */
+  /** convert a network tree to a string. */
-    // 0 is local, 1 is same rack, 2 is off rack
-    // Start off by initializing to off rack
-    int weight = 2;
-    if (reader != null) {
-      if (reader.equals(node)) {
-        weight = 0;
-      } else if (isOnSameRack(reader, node)) {
-        weight = 1;
+    // 0 is local, 2 is same rack, and each level on each node increases the
+    //weight by 1
+    //Start off by initializing to Integer.MAX_VALUE
+    int weight = Integer.MAX_VALUE;
+    if (reader != null && node != null) {
+      if(reader.equals(node)) {
+        return 0;
+      }
+      int maxReaderLevel = reader.getLevel();
+      int maxNodeLevel = node.getLevel();
+      int currentLevelToCompare = maxReaderLevel > maxNodeLevel ?
+          maxNodeLevel : maxReaderLevel;
+      Node r = reader;
+      Node n = node;
+      weight = 0;
+      while(r != null && r.getLevel() > currentLevelToCompare) {
+        r = r.getParent();
+        weight++;
+      }
+      while(n != null && n.getLevel() > currentLevelToCompare) {
+        n = n.getParent();
+        weight++;
+      }
+      while(r != null && n != null && !r.equals(n)) {
+        r = r.getParent();
+        n = n.getParent();
+        weight+=2;
+   * Returns an integer weight which specifies how far away <i>node</i> is
+   * from <i>reader</i>. A lower value signifies that a node is closer.
+   * It uses network location to calculate the weight
+   *
+   * @param reader Node where data will be read
+   * @param node Replica of data
+   * @return weight
+   */
+  private static int getWeightUsingNetworkLocation(Node reader, Node node) {
+    //Start off by initializing to Integer.MAX_VALUE
+    int weight = Integer.MAX_VALUE;
+    if(reader != null && node != null) {
+      String readerPath = normalizeNetworkLocationPath(
+          reader.getNetworkLocation());
+      String nodePath = normalizeNetworkLocationPath(
+          node.getNetworkLocation());
+
+      //same rack
+      if(readerPath.equals(nodePath)) {
+        if(reader.getName().equals(node.getName())) {
+          weight = 0;
+        } else {
+          weight = 2;
+        }
+      } else {
+        String[] readerPathToken = readerPath.split(PATH_SEPARATOR_STR);
+        String[] nodePathToken = nodePath.split(PATH_SEPARATOR_STR);
+        int maxLevelToCompare = readerPathToken.length > nodePathToken.length ?
+            nodePathToken.length : readerPathToken.length;
+        int currentLevel = 1;
+        //traverse through the path and calculate the distance
+        while(currentLevel < maxLevelToCompare) {
+          if(!readerPathToken[currentLevel]
+              .equals(nodePathToken[currentLevel])){
+            break;
+          }
+          currentLevel++;
+        }
+        weight = (readerPathToken.length - currentLevel) +
+            (nodePathToken.length - currentLevel);
+      }
+    }
+    return weight;
+  }
+
+  /** Normalize a path by stripping off any trailing {@link #PATH_SEPARATOR}.
+   * @param path path to normalize.
+   * @return the normalised path
+   * If <i>path</i>is null or empty {@link #ROOT} is returned
+   * @throws IllegalArgumentException if the first character of a non empty path
+   * is not {@link #PATH_SEPARATOR}
+   */
+  private static String normalizeNetworkLocationPath(String path) {
+    if (path == null || path.length() == 0) {
+      return ROOT;
+    }
+
+    if (path.charAt(0) != PATH_SEPARATOR) {
+      throw new IllegalArgumentException("Network Location"
+          + "path doesn't start with " +PATH_SEPARATOR+ ": "+path);
+    }
+
+    int len = path.length();
+    if (path.charAt(len-1) == PATH_SEPARATOR) {
+      return path.substring(0, len-1);
+    }
+    return path;
+  }
+
+  /**
+    /*
+     * This method is called if the reader is a datanode,
+     * so nonDataNodeReader flag is set to false.
+     */
+    sortByDistance(reader, nodes, activeLen, false);
+  }
+
+  /**
+   * Sort nodes array by network distance to <i>reader</i>.
+   * <p/> using network location. This is used when the reader
+   * is not a datanode. Sorting the nodes based on network distance
+   * from the reader reduces network traffic and improves
+   * performance.
+   * <p/>
+   *
+   * @param reader    Node where data will be read
+   * @param nodes     Available replicas with the requested data
+   * @param activeLen Number of active nodes at the front of the array
+   */
+  public void sortByDistanceUsingNetworkLocation(Node reader, Node[] nodes,
+      int activeLen) {
+    /*
+     * This method is called if the reader is not a datanode,
+     * so nonDataNodeReader flag is set to true.
+     */
+    sortByDistance(reader, nodes, activeLen, true);
+  }
+
+  /**
+   * Sort nodes array by network distance to <i>reader</i>.
+   * <p/>
+   * As an additional twist, we also randomize the nodes at each network
+   * distance. This helps with load balancing when there is data skew.
+   *
+   * @param reader    Node where data will be read
+   * @param nodes     Available replicas with the requested data
+   * @param activeLen Number of active nodes at the front of the array
+   * @param nonDataNodeReader True if the reader is not a datanode
+   */
+  private void sortByDistance(Node reader, Node[] nodes, int activeLen,
+      boolean nonDataNodeReader) {
-      weights[i] = getWeight(reader, nodes[i]);
+      if(nonDataNodeReader) {
+        weights[i] = getWeightUsingNetworkLocation(reader, nodes[i]);
+      } else {
+        weights[i] = getWeight(reader, nodes[i]);
+      }

INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 MOV29 MOV83 MOV39 MOV42 MOV44 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 MOV8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 MOV29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 UPD83 INS44 INS42 INS13 INS42 INS42 INS45 INS42 INS42 INS45 INS60 INS25 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS25 INS25 INS60 INS25 INS41 INS43 INS42 INS5 INS42 INS39 INS42 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS5 INS42 INS39 INS42 INS21 INS65 INS65 INS65 INS65 INS65 INS39 INS42 UPD66 INS39 INS59 INS27 INS8 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS66 INS65 INS66 INS42 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS65 INS42 INS27 INS8 INS27 INS8 INS39 INS59 INS27 INS8 INS42 INS42 INS43 INS85 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS85 INS32 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS8 INS42 INS40 MOV27 INS27 INS25 INS60 INS60 INS60 INS60 INS60 INS21 INS61 INS61 INS61 INS40 INS27 INS27 INS60 INS60 INS67 INS67 INS67 INS27 INS27 INS41 INS32 INS42 INS53 INS42 INS32 INS32 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS9 INS25 INS42 INS33 MOV32 INS8 INS39 INS59 INS39 INS59 INS39 INS59 INS43 INS59 INS43 INS59 INS7 INS27 INS8 INS27 INS8 INS27 INS8 INS42 INS33 INS42 INS33 INS43 INS59 INS43 INS59 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS33 INS32 INS34 INS42 INS42 INS42 INS34 INS14 INS42 INS42 INS42 INS42 INS27 INS32 INS42 INS8 MOV8 INS41 INS42 INS32 INS42 INS32 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS27 INS27 INS21 INS21 INS27 INS27 INS21 INS21 INS27 INS38 INS21 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS25 INS60 INS60 INS60 INS60 INS61 INS21 INS42 INS42 INS43 INS27 INS42 INS34 INS42 INS42 INS34 INS27 INS21 INS34 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS33 INS32 INS42 INS7 INS37 INS42 INS33 INS32 INS42 INS7 INS37 INS27 INS27 INS32 INS7 INS7 INS7 INS42 INS32 INS42 INS32 MOV32 MOV8 MOV8 INS5 INS59 INS5 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS7 INS42 INS27 INS42 INS45 INS42 INS42 INS34 INS7 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS33 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS32 UPD42 INS32 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS16 INS42 INS34 INS42 INS42 INS25 INS21 INS42 INS27 INS45 INS45 INS2 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS40 INS40 INS38 INS8 INS37 INS36 INS36 INS42 INS42 INS42 INS42 INS2 UPD34 INS40 INS40 INS32 INS10 INS42 INS27 INS27 INS42 INS42 INS2 INS42 INS2 INS40 INS42 INS40 INS42 INS42 INS42 INS42 INS42 DEL34 DEL25 DEL31
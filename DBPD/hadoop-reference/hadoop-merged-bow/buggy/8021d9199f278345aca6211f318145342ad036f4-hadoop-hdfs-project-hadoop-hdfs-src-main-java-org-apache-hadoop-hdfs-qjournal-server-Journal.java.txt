HDFS-3863. Track last "committed" txid in QJM. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1380976 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.util.BestEffortLongFile;
+import com.google.common.collect.Range;
+import com.google.common.collect.Ranges;
+  /**
+   * Lower-bound on the last committed transaction ID. This is not
+   * depended upon for correctness, but acts as a sanity check
+   * during the recovery procedures, and as a visibility mark
+   * for clients reading in-progress logs.
+   */
+  private BestEffortLongFile committedTxnId;
+  
-
+  private static final String COMMITTED_TXID_FILENAME = "committed-txid";
+  
-
+    this.committedTxnId = new BestEffortLongFile(
+        new File(currentDir, COMMITTED_TXID_FILENAME),
+        HdfsConstants.INVALID_TXID);
+    
-    if (files.isEmpty()) {
-      curSegmentTxId = HdfsConstants.INVALID_TXID;
-      return;
-    }
+    curSegmentTxId = HdfsConstants.INVALID_TXID;
-    EditLogFile latestLog = files.get(files.size() - 1);
-    latestLog.validateLog();
-    LOG.info("Latest log is " + latestLog);
-    if (latestLog.getLastTxId() == HdfsConstants.INVALID_TXID) {
-      // the log contains no transactions
-      LOG.warn("Latest log " + latestLog + " has no transactions. " +
-          "moving it aside");
-      latestLog.moveAsideEmptyFile();
-      curSegmentTxId = HdfsConstants.INVALID_TXID;
-    } else {
-      curSegmentTxId = latestLog.getFirstTxId();
+    while (!files.isEmpty()) {
+      EditLogFile latestLog = files.remove(files.size() - 1);
+      latestLog.validateLog();
+      LOG.info("Latest log is " + latestLog);
+      if (latestLog.getLastTxId() == HdfsConstants.INVALID_TXID) {
+        // the log contains no transactions
+        LOG.warn("Latest log " + latestLog + " has no transactions. " +
+            "moving it aside and looking for previous log");
+        latestLog.moveAsideEmptyFile();
+      } else {
+        curSegmentTxId = latestLog.getFirstTxId();
+        break;
+      }
+    
+    IOUtils.closeStream(committedTxnId);
+  
+  synchronized long getCommittedTxnIdForTests() throws IOException {
+    return committedTxnId.get();
+  }
-    checkWriteRequest(reqInfo);
+    checkWriteRequest(reqInfo);
+    
+
+    if (reqInfo.hasCommittedTxId()) {
+      Preconditions.checkArgument(
+          reqInfo.getCommittedTxId() >= committedTxnId.get(),
+          "Client trying to move committed txid backward from " +
+          committedTxnId.get() + " to " + reqInfo.getCommittedTxId());
+      
+      committedTxnId.set(reqInfo.getCommittedTxId());
+    }
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
+    if (committedTxnId.get() != HdfsConstants.INVALID_TXID) {
+      builder.setLastCommittedTxId(committedTxnId.get());
+    }
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
-            ": old segment " + TextFormat.shortDebugString(segment) + " is " +
-            "not the right length");
+            ": old segment " + TextFormat.shortDebugString(currentSegment) +
+            " is not the right length");
+        
+        // Paranoid sanity check: if the new log is shorter than the log we
+        // currently have, we should not end up discarding any transactions
+        // which are already Committed.
+        if (txnRange(currentSegment).contains(committedTxnId.get()) &&
+            !txnRange(segment).contains(committedTxnId.get())) {
+          throw new AssertionError(
+              "Cannot replace segment " +
+              TextFormat.shortDebugString(currentSegment) +
+              " with new segment " +
+              TextFormat.shortDebugString(segment) + 
+              ": would discard already-committed txn " +
+              committedTxnId.get());
+        }
+  private Range<Long> txnRange(SegmentStateProto seg) {
+    Preconditions.checkArgument(seg.hasEndTxId(),
+        "invalid segment: %s", seg);
+    return Ranges.closed(seg.getStartTxId(), seg.getEndTxId());
+  }
+

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS29 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS39 INS42 INS43 INS8 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS83 INS74 INS42 INS44 INS8 INS65 INS42 INS42 INS42 INS42 INS45 INS21 MOV21 INS61 INS21 INS42 INS41 INS25 INS25 INS43 INS43 INS43 INS42 INS21 INS41 INS66 INS66 INS66 INS66 INS7 INS38 INS8 INS32 INS32 INS32 INS8 INS27 INS8 INS42 INS42 INS42 INS32 INS32 INS22 INS14 MOV32 MOV60 MOV21 MOV21 MOV25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS32 INS40 INS21 INS42 INS42 INS32 INS45 INS42 INS42 INS42 INS32 INS32 INS52 INS42 INS43 INS14 INS40 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS10 INS42 INS42 INS27 INS27 INS42 INS42 INS32 INS42 INS42 INS32 INS25 INS42 UPD42 INS32 INS32 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS38 INS53 UPD45 INS32 UPD45 INS32 INS42 INS32 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 MOV32 INS45 INS32 INS42 INS42 INS42 INS42 INS42 DEL42 DEL40 DEL7 DEL21 DEL41 DEL8 DEL25 DEL45
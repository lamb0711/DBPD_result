YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)

-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.StringTokenizer;
-
+import com.google.common.collect.ImmutableSet;
+import org.apache.hadoop.yarn.exceptions.YarnRuntimeException;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.policy.PriorityUtilizationQueueOrderingPolicy;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.policy.QueueOrderingPolicy;
-import com.google.common.collect.ImmutableSet;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.StringTokenizer;
-  
+
+  /**
+   * Ordering policy of queues
+   */
-  
-  public static final String FIFO_ORDERING_POLICY = "fifo";
-  public static final String FAIR_ORDERING_POLICY = "fair";
+  /*
+   * Ordering policy inside a leaf queue to sort apps
+   */
+  public static final String FIFO_APP_ORDERING_POLICY = "fifo";
-  public static final String DEFAULT_ORDERING_POLICY = FIFO_ORDERING_POLICY;
+  public static final String FAIR_APP_ORDERING_POLICY = "fair";
+
+  public static final String DEFAULT_APP_ORDERING_POLICY =
+      FIFO_APP_ORDERING_POLICY;
+
+  static String getQueueOrderingPolicyPrefix(String queue) {
+    String queueName = PREFIX + queue + DOT + ORDERING_POLICY + DOT;
+    return queueName;
+  }
-  
+
+  // TODO (wangda): We need to better distinguish app ordering policy and queue
+  // ordering policy's classname / configuration options, etc. And dedup code
+  // if possible.
-  public <S extends SchedulableEntity> OrderingPolicy<S> getOrderingPolicy(
+  public <S extends SchedulableEntity> OrderingPolicy<S> getAppOrderingPolicy(
-    String policyType = get(getQueuePrefix(queue) + ORDERING_POLICY, 
-      DEFAULT_ORDERING_POLICY);
+    String policyType = get(getQueuePrefix(queue) + ORDERING_POLICY,
+        DEFAULT_APP_ORDERING_POLICY);
-    if (policyType.trim().equals(FIFO_ORDERING_POLICY)) {
+    if (policyType.trim().equals(FIFO_APP_ORDERING_POLICY)) {
-    if (policyType.trim().equals(FAIR_ORDERING_POLICY)) {
+    if (policyType.trim().equals(FAIR_APP_ORDERING_POLICY)) {
+  @Private
+  public Priority getQueuePriority(String queue) {
+    String queuePolicyPrefix = getQueuePrefix(queue);
+    Priority pri = Priority.newInstance(
+        getInt(queuePolicyPrefix + "priority", 0));
+    return pri;
+  }
+
+  @Private
+  public void setQueuePriority(String queue, int priority) {
+    String queuePolicyPrefix = getQueuePrefix(queue);
+    setInt(queuePolicyPrefix + "priority", priority);
+  }
+
+
+  /**
+   * Ordering policy inside a parent queue to sort queues
+   */
+
+  /**
+   * Less relative usage queue can get next resource, this is default
+   */
+  public static final String QUEUE_UTILIZATION_ORDERING_POLICY = "utilization";
+
+  /**
+   * Combination of relative usage and priority
+   */
+  public static final String QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY =
+      "priority-utilization";
+
+  public static final String DEFAULT_QUEUE_ORDERING_POLICY =
+      QUEUE_UTILIZATION_ORDERING_POLICY;
+
+
+  @Private
+  public void setQueueOrderingPolicy(String queue, String policy) {
+    set(getQueuePrefix(queue) + ORDERING_POLICY, policy);
+  }
+
+  @Private
+  public QueueOrderingPolicy getQueueOrderingPolicy(String queue,
+      String parentPolicy) {
+    String defaultPolicy = parentPolicy;
+    if (null == defaultPolicy) {
+      defaultPolicy = DEFAULT_QUEUE_ORDERING_POLICY;
+    }
+
+    String policyType = get(getQueuePrefix(queue) + ORDERING_POLICY,
+        defaultPolicy);
+
+    QueueOrderingPolicy qop;
+    if (policyType.trim().equals(QUEUE_UTILIZATION_ORDERING_POLICY)) {
+      // Doesn't respect priority
+      qop = new PriorityUtilizationQueueOrderingPolicy(false);
+    } else if (policyType.trim().equals(
+        QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY)) {
+      qop = new PriorityUtilizationQueueOrderingPolicy(true);
+    } else {
+      String message =
+          "Unable to construct queue ordering policy=" + policyType + " queue="
+              + queue;
+      throw new YarnRuntimeException(message);
+    }
+
+    return qop;
+  }
+
+  /*
+   * Get global configuration for ordering policies
+   */
+  private String getOrderingPolicyGlobalConfigKey(String orderPolicyName,
+      String configKey) {
+    return PREFIX + ORDERING_POLICY + DOT + orderPolicyName + DOT + configKey;
+  }
+
+  /**
+   * Global configurations of queue-priority-utilization ordering policy
+   */
+  private static final String UNDER_UTILIZED_PREEMPTION_ENABLED =
+      "underutilized-preemption.enabled";
+
+  /**
+   * Do we allow under-utilized queue with higher priority to preempt queue
+   * with lower priority *even if queue with lower priority is not satisfied*.
+   *
+   * For example, two queues, a and b
+   * a.priority = 1, (a.used-capacity - a.reserved-capacity) = 40%
+   * b.priority = 0, b.used-capacity = 30%
+   *
+   * Set this configuration to true to allow queue-a to preempt container from
+   * queue-b.
+   *
+   * (The reason why deduct reserved-capacity from used-capacity for queue with
+   * higher priority is: the reserved-capacity is just scheduler's internal
+   * implementation to allocate large containers, it is not possible for
+   * application to use such reserved-capacity. It is possible that a queue with
+   * large container requests have a large number of containers but cannot
+   * allocate from any of them. But scheduler will make sure a satisfied queue
+   * will not preempt resource from any other queues. A queue is considered to
+   * be satisfied when queue's used-capacity - reserved-capacity â‰¥
+   * guaranteed-capacity.)
+   *
+   * @return allowed or not
+   */
+  public boolean getPUOrderingPolicyUnderUtilizedPreemptionEnabled() {
+    return getBoolean(getOrderingPolicyGlobalConfigKey(
+        QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,
+        UNDER_UTILIZED_PREEMPTION_ENABLED), false);
+  }
+
+  @VisibleForTesting
+  public void setPUOrderingPolicyUnderUtilizedPreemptionEnabled(
+      boolean enabled) {
+    setBoolean(getOrderingPolicyGlobalConfigKey(
+        QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,
+        UNDER_UTILIZED_PREEMPTION_ENABLED), enabled);
+  }
+
+  private static final String UNDER_UTILIZED_PREEMPTION_DELAY =
+      "underutilized-preemption.reserved-container-delay-ms";
+
+  /**
+   * When a reserved container of an underutilized queue is created. Preemption
+   * will kick in after specified delay (in ms).
+   *
+   * The total time to preempt resources for a reserved container from higher
+   * priority queue will be: reserved-container-delay-ms +
+   * {@link CapacitySchedulerConfiguration#PREEMPTION_WAIT_TIME_BEFORE_KILL}.
+   *
+   * This parameter is added to make preemption from lower priority queue which
+   * is underutilized to be more careful. This parameter takes effect when
+   * underutilized-preemption.enabled set to true.
+   *
+   * @return delay
+   */
+  public long getPUOrderingPolicyUnderUtilizedPreemptionDelay() {
+    return getLong(getOrderingPolicyGlobalConfigKey(
+        QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,
+        UNDER_UTILIZED_PREEMPTION_DELAY), 60000L);
+  }
+
+  @VisibleForTesting
+  public void setPUOrderingPolicyUnderUtilizedPreemptionDelay(
+      long timeout) {
+    setLong(getOrderingPolicyGlobalConfigKey(
+        QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,
+        UNDER_UTILIZED_PREEMPTION_DELAY), timeout);
+  }
+
+  private static final String UNDER_UTILIZED_PREEMPTION_MOVE_RESERVATION =
+      "underutilized-preemption.allow-move-reservation";
+
+  /**
+   * When doing preemption from under-satisfied queues for priority queue.
+   * Do we allow move reserved container from one host to another?
+   *
+   * @return allow or not
+   */
+  public boolean getPUOrderingPolicyUnderUtilizedPreemptionMoveReservation() {
+    return getBoolean(getOrderingPolicyGlobalConfigKey(
+        QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,
+        UNDER_UTILIZED_PREEMPTION_MOVE_RESERVATION), false);
+  }
+
+  @VisibleForTesting
+  public void setPUOrderingPolicyUnderUtilizedPreemptionMoveReservation(
+      boolean allowMoveReservation) {
+    setBoolean(getOrderingPolicyGlobalConfigKey(
+        QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,
+        UNDER_UTILIZED_PREEMPTION_MOVE_RESERVATION), allowMoveReservation);
+  }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS31 INS31 INS23 INS23 INS23 INS31 INS31 INS31 INS23 INS31 INS31 INS23 INS31 INS31 INS23 INS31 INS31 INS29 MOV43 MOV43 MOV43 INS83 INS43 INS42 INS44 INS8 UPD42 INS78 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS65 UPD42 UPD42 UPD42 UPD42 INS42 INS43 INS42 INS60 INS41 INS42 INS42 INS43 INS42 INS60 INS60 INS41 INS42 INS43 INS42 INS39 INS42 INS60 INS21 INS65 INS42 INS42 INS45 INS65 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS21 INS42 INS42 INS43 INS42 INS43 INS42 INS60 INS25 INS60 INS60 INS25 INS41 INS42 INS43 INS42 INS43 INS42 INS41 INS65 INS42 INS42 INS45 INS65 INS65 INS41 INS42 INS39 INS42 INS21 INS42 INS42 INS45 INS65 INS65 INS41 INS42 INS39 INS42 INS21 INS42 INS42 INS45 INS65 INS65 INS41 INS42 INS39 INS42 INS21 INS66 INS42 INS43 INS59 INS42 INS32 MOV32 INS42 INS43 INS59 INS43 INS59 INS42 INS42 INS43 INS59 INS32 INS66 INS66 INS42 INS42 INS32 INS42 INS42 INS43 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS32 INS8 INS25 INS42 INS42 INS42 INS27 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS32 INS32 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS32 INS32 INS66 INS66 INS66 INS32 INS32 INS42 INS42 INS27 MOV32 INS42 INS42 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS33 INS42 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS21 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS9 INS42 INS32 INS42 INS67 INS42 INS32 INS34 INS42 INS32 INS42 INS42 INS32 INS9 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS45 INS32 INS42 INS7 INS42 INS27 INS42 INS42 INS42 INS7 INS32 INS42 INS42 INS21 INS60 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS34 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS7 INS43 INS59 INS14 INS42 INS45 INS42 INS42 INS43 INS9 INS42 INS14 INS42 INS42 INS27 INS43 INS42 INS42 INS43 INS9 INS45 INS42 INS45 INS42 INS42 INS42 DEL42 DEL42 DEL32
HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.
Contributed by Steve Loughran and Ryan Blue.

+import com.amazonaws.AbortedException;
+import com.amazonaws.SdkBaseException;
+import com.amazonaws.services.dynamodbv2.model.AmazonDynamoDBException;
+import com.amazonaws.services.dynamodbv2.model.LimitExceededException;
+import com.amazonaws.services.dynamodbv2.model.ProvisionedThroughputExceededException;
+import com.amazonaws.services.dynamodbv2.model.ResourceNotFoundException;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.LocatedFileStatus;
+import org.apache.hadoop.fs.PathFilter;
+import org.apache.hadoop.fs.RemoteIterator;
+import org.apache.hadoop.net.ConnectTimeoutException;
+import org.slf4j.LoggerFactory;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.Optional;
-  /** Reuse the S3AFileSystem log. */
-  private static final Logger LOG = S3AFileSystem.LOG;
+  private static final Logger LOG = LoggerFactory.getLogger(S3AUtils.class);
+  private static final String EOF_MESSAGE_IN_XML_PARSER
+      = "Failed to sanitize XML document destined for handler class";
+   *
+   * @see <a href="http://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html">S3 Error responses</a>
+   * @see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/ErrorBestPractices.html">Amazon S3 Error Best Practices</a>
+   * @see <a href="http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/CommonErrors.html">Dynamo DB Commmon errors</a>
-      AmazonClientException exception) {
+      SdkBaseException exception) {
-      if (containsInterruptedException(exception)) {
-        return (IOException)new InterruptedIOException(message)
-            .initCause(exception);
+      Exception innerCause = containsInterruptedException(exception);
+      if (innerCause != null) {
+        // interrupted IO, or a socket exception underneath that class
+        return translateInterruptedException(exception, innerCause, message);
+      }
+      if (signifiesConnectionBroken(exception)) {
+        // call considered an sign of connectivity failure
+        return (EOFException)new EOFException(message).initCause(exception);
-
+      if (exception instanceof AmazonDynamoDBException) {
+        // special handling for dynamo DB exceptions
+        return translateDynamoDBException(message,
+            (AmazonDynamoDBException)exception);
+      }
+      message = message + ":" + ase.getErrorCode();
+      case 307:
-          ioe = new AWSS3IOException(message, s3Exception);
+          ioe = new AWSRedirectException(message, s3Exception);
-          ioe = new AWSServiceIOException(message, ase);
+          ioe = new AWSRedirectException(message, ase);
+
+      case 400:
+        ioe = new AWSBadRequestException(message, ase);
+        break;
+
+        ioe.initCause(ase);
+        break;
+
+      // this has surfaced as a "no response from server" message.
+      // so rare we haven't replicated it.
+      // Treating as an idempotent proxy error.
+      case 443:
+      case 444:
+        ioe = new AWSNoResponseException(message, ase);
+        break;
+
+      // throttling
+      case 503:
+        ioe = new AWSServiceThrottledException(message, ase);
+        break;
+
+      // internal error
+      case 500:
+        ioe = new AWSStatus500Exception(message, ase);
-   * @return true if down the execution chain the operation was an interrupt
+   * @return the actual exception if the operation was an interrupt
-  static boolean containsInterruptedException(Throwable thrown) {
+  static Exception containsInterruptedException(Throwable thrown) {
-      return false;
+      return null;
-        thrown instanceof InterruptedIOException) {
-      return true;
+        thrown instanceof InterruptedIOException ||
+        thrown instanceof AbortedException) {
+      return (Exception)thrown;
+   * Handles translation of interrupted exception. This includes
+   * preserving the class of the fault for better retry logic
+   * @param exception outer exception
+   * @param innerCause inner cause (which is guaranteed to be some form
+   * of interrupted exception
+   * @param message message for the new exception.
+   * @return an IOE which can be rethrown
+   */
+  private static InterruptedIOException translateInterruptedException(
+      SdkBaseException exception,
+      final Exception innerCause,
+      String message) {
+    InterruptedIOException ioe;
+    if (innerCause instanceof SocketTimeoutException) {
+      ioe = new SocketTimeoutException(message);
+    } else {
+      String name = innerCause.getClass().getName();
+      if (name.endsWith(".ConnectTimeoutException")
+          || name.endsWith("$ConnectTimeoutException")) {
+        // TCP connection http timeout from the shaded or unshaded filenames
+        // com.amazonaws.thirdparty.apache.http.conn.ConnectTimeoutException
+        ioe = new ConnectTimeoutException(message);
+      } else {
+        // any other exception
+        ioe = new InterruptedIOException(message);
+      }
+    }
+    ioe.initCause(exception);
+    return ioe;
+  }
+
+  /**
+   * Is the exception an instance of a throttling exception. That
+   * is an AmazonServiceException with a 503 response, any
+   * exception from DynamoDB for limits exceeded, or an
+   * {@link AWSServiceThrottledException}.
+   * @param ex exception to examine
+   * @return true if it is considered a throttling exception
+   */
+  public static boolean isThrottleException(Exception ex) {
+    return ex instanceof AWSServiceThrottledException
+        || ex instanceof ProvisionedThroughputExceededException
+        || ex instanceof LimitExceededException
+        || (ex instanceof AmazonServiceException
+            && 503  == ((AmazonServiceException)ex).getStatusCode());
+  }
+
+  /**
+   * Cue that an AWS exception is likely to be an EOF Exception based
+   * on the message coming back from an XML/JSON parser. This is likely
+   * to be brittle, so only a hint.
+   * @param ex exception
+   * @return true if this is believed to be a sign the connection was broken.
+   */
+  public static boolean signifiesConnectionBroken(SdkBaseException ex) {
+    return ex.toString().contains(EOF_MESSAGE_IN_XML_PARSER);
+  }
+
+  /**
+   * Translate a DynamoDB exception into an IOException.
+   * @param message preformatted message for the exception
+   * @param ex exception
+   * @return an exception to throw.
+   */
+  public static IOException translateDynamoDBException(String message,
+      AmazonDynamoDBException ex) {
+    if (isThrottleException(ex)) {
+      return new AWSServiceThrottledException(message, ex);
+    }
+    if (ex instanceof ResourceNotFoundException) {
+      return (FileNotFoundException) new FileNotFoundException(message)
+          .initCause(ex);
+    }
+    return new AWSServiceIOException(message, ex);
+  }
+
+  /**
-   * Get a long option >= the minimum allowed value, supporting memory
+   * Get a long option &gt;= the minimum allowed value, supporting memory
-  static long longBytesOption(Configuration conf,
+  public static long longBytesOption(Configuration conf,
+
+  /**
+   * Delete a path quietly: failures are logged at DEBUG.
+   * @param fs filesystem
+   * @param path path
+   * @param recursive recursive?
+   */
+  public static void deleteQuietly(FileSystem fs,
+      Path path,
+      boolean recursive) {
+    try {
+      fs.delete(path, recursive);
+    } catch (IOException e) {
+      LOG.debug("Failed to delete {}", path, e);
+    }
+  }
+
+  /**
+   * Delete a path: failures are logged at WARN.
+   * @param fs filesystem
+   * @param path path
+   * @param recursive recursive?
+   */
+  public static void deleteWithWarning(FileSystem fs,
+      Path path,
+      boolean recursive) {
+    try {
+      fs.delete(path, recursive);
+    } catch (IOException e) {
+      LOG.warn("Failed to delete {}", path, e);
+    }
+  }
+
+
+  /**
+   * An interface for use in lambda-expressions working with
+   * directory tree listings.
+   */
+  @FunctionalInterface
+  public interface CallOnLocatedFileStatus {
+    void call(LocatedFileStatus status) throws IOException;
+  }
+
+  /**
+   * An interface for use in lambda-expressions working with
+   * directory tree listings.
+   */
+  @FunctionalInterface
+  public interface LocatedFileStatusMap<T> {
+    T call(LocatedFileStatus status) throws IOException;
+  }
+
+  /**
+   * Apply an operation to every {@link LocatedFileStatus} in a remote
+   * iterator.
+   * @param iterator iterator from a list
+   * @param eval closure to evaluate
+   * @throws IOException anything in the closure, or iteration logic.
+   */
+  public static void applyLocatedFiles(
+      RemoteIterator<LocatedFileStatus> iterator,
+      CallOnLocatedFileStatus eval) throws IOException {
+    while (iterator.hasNext()) {
+      eval.call(iterator.next());
+    }
+  }
+
+  /**
+   * Map an operation to every {@link LocatedFileStatus} in a remote
+   * iterator, returning a list of the results.
+   * @param iterator iterator from a list
+   * @param eval closure to evaluate
+   * @throws IOException anything in the closure, or iteration logic.
+   */
+  public static <T> List<T> mapLocatedFiles(
+      RemoteIterator<LocatedFileStatus> iterator,
+      LocatedFileStatusMap<T> eval) throws IOException {
+    final List<T> results = new ArrayList<>();
+    applyLocatedFiles(iterator,
+        (s) -> results.add(eval.call(s)));
+    return results;
+  }
+
+  /**
+   * Map an operation to every {@link LocatedFileStatus} in a remote
+   * iterator, returning a list of the all results which were not empty.
+   * @param iterator iterator from a list
+   * @param eval closure to evaluate
+   * @throws IOException anything in the closure, or iteration logic.
+   */
+  public static <T> List<T> flatmapLocatedFiles(
+      RemoteIterator<LocatedFileStatus> iterator,
+      LocatedFileStatusMap<Optional<T>> eval) throws IOException {
+    final List<T> results = new ArrayList<>();
+    applyLocatedFiles(iterator,
+        (s) -> eval.call(s).map(r -> results.add(r)));
+    return results;
+  }
+
+  /**
+   * List located files and filter them as a classic listFiles(path, filter)
+   * would do.
+   * @param fileSystem filesystem
+   * @param path path to list
+   * @param recursive recursive listing?
+   * @param filter filter for the filename
+   * @return the filtered list of entries
+   * @throws IOException IO failure.
+   */
+  public static List<LocatedFileStatus> listAndFilter(FileSystem fileSystem,
+      Path path, boolean recursive, PathFilter filter) throws IOException {
+    return flatmapLocatedFiles(fileSystem.listFiles(path, recursive),
+        status -> maybe(filter.accept(status.getPath()), status));
+  }
+
+  /**
+   * Convert a value into a non-empty Optional instance if
+   * the value of {@code include} is true.
+   * @param include flag to indicate the value is to be included.
+   * @param value value to return
+   * @param <T> type of option.
+   * @return if include is false, Optional.empty. Otherwise, the value.
+   */
+  public static <T> Optional<T> maybe(boolean include, T value) {
+    return include ? Optional.of(value) : Optional.empty();
+  }
+
+
+  /**
+   * Path filter which ignores any file which starts with . or _.
+   */
+  public static final PathFilter HIDDEN_FILE_FILTER = new PathFilter() {
+    @Override
+    public boolean accept(Path path) {
+      String name = path.getName();
+      return !name.startsWith("_") && !name.startsWith(".");
+    }
+
+    @Override
+    public String toString() {
+      return "HIDDEN_FILE_FILTER";
+    }
+  };
+
+  /**
+   * A Path filter which accepts all filenames.
+   */
+  public static final PathFilter ACCEPT_ALL = new PathFilter() {
+    @Override
+    public boolean accept(Path file) {
+      return true;
+    }
+
+    @Override
+    public String toString() {
+      return "ACCEPT_ALL";
+    }
+  };
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS55 INS31 INS31 INS31 INS31 INS31 INS23 INS83 INS83 INS83 MOV43 INS59 INS83 INS83 INS83 INS43 INS59 INS43 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS78 INS83 INS42 INS31 INS29 INS78 INS83 INS42 INS73 INS31 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS73 INS74 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS73 INS74 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS73 INS74 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS83 INS43 INS59 UPD83 INS43 INS42 INS32 INS42 INS42 INS45 INS65 INS65 INS65 UPD43 INS42 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS83 INS43 INS42 INS43 INS42 INS60 INS25 INS21 INS41 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS25 INS25 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS54 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS54 INS65 INS42 INS39 INS42 INS44 INS43 INS65 INS42 INS42 INS43 INS42 INS44 INS43 INS65 INS65 INS65 INS65 INS74 INS42 INS43 INS42 INS42 INS61 INS65 INS65 INS65 INS65 INS42 INS43 INS43 INS74 INS42 INS74 INS42 INS42 INS60 INS21 INS41 INS65 INS65 INS65 INS65 INS42 INS43 INS43 INS74 INS42 INS74 INS42 INS42 INS60 INS21 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS43 INS39 INS42 INS43 INS42 INS41 INS65 INS42 INS42 INS14 INS42 UPD42 INS14 INS42 INS42 INS57 INS66 INS66 INS66 UPD42 UPD66 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS43 INS59 INS62 INS8 INS8 INS32 INS42 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS42 INS27 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS8 INS62 INS8 MOV14 UPD66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS8 INS12 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS8 INS12 INS66 INS66 INS43 INS42 INS42 INS66 INS66 INS42 INS43 INS42 INS42 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS43 INS43 INS42 INS32 INS8 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS43 INS43 INS43 INS83 INS74 INS59 INS32 INS42 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS43 INS43 INS74 INS83 INS74 INS59 INS32 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS32 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS42 INS16 INS66 INS43 INS1 UPD66 INS43 INS1 INS43 INS60 INS25 INS25 INS21 MOV21 MOV10 MOV21 MOV10 MOV10 MOV21 INS62 INS41 INS42 INS42 INS42 INS43 INS21 INS60 INS25 INS42 INS42 INS42 INS42 INS62 INS62 INS62 INS36 INS32 INS42 INS42 INS42 INS42 INS41 INS42 INS43 INS41 UPD42 INS21 INS44 INS8 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS14 INS42 INS42 INS86 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS86 INS42 INS32 INS86 INS66 INS42 INS32 INS32 INS42 INS31 INS31 INS42 INS31 INS31 INS42 INS43 INS59 INS27 INS8 INS32 INS62 INS8 INS7 INS49 INS49 INS21 INS21 INS10 INS49 INS21 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS10 INS33 INS42 INS43 INS11 INS42 INS7 INS43 INS59 INS27 INS8 INS8 INS42 INS43 INS42 INS43 INS42 INS43 INS27 INS42 INS42 INS14 INS42 INS11 INS32 MOV43 INS42 INS21 INS32 INS43 INS42 INS21 INS32 INS42 INS42 INS74 INS59 INS32 INS42 INS42 INS42 INS42 INS74 INS59 INS32 INS42 INS42 INS42 INS42 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS39 INS42 INS44 MOV8 INS78 INS83 INS43 INS42 INS8 INS42 INS42 MOV32 INS42 INS33 INS41 INS42 INS42 INS42 INS43 INS41 INS42 INS27 INS34 INS34 INS7 INS32 INS34 INS34 INS7 INS34 INS7 INS34 INS7 INS42 INS43 INS42 INS42 INS14 INS42 INS42 INS32 INS32 INS32 INS21 INS21 INS42 INS42 INS42 INS62 INS27 INS43 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS32 INS43 INS42 INS32 INS42 INS86 INS42 INS42 INS32 INS42 INS42 INS43 INS42 INS60 INS41 INS42 INS42 INS41 INS42 INS43 INS42 INS42 INS42 INS41 INS32 INS42 INS32 INS42 INS45 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS43 INS42 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS45 INS7 INS7 INS42 INS43 INS34 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS59 INS32 INS42 INS42 INS32 INS42 INS43 INS59 INS27 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS11 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 MOV14 INS42 INS36 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS38 INS38 INS42 INS14 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS42 INS11 INS42 INS42 INS42 INS32 INS32 INS43 INS42 INS42 UPD43 INS43 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS45 INS42 INS42 INS45 INS42 UPD42 INS42 INS42 DEL39 DEL9 DEL40
revert HADOOP-9652

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508248 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.FileNotFoundException;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.fs.permission.FsPermission;
+import org.apache.hadoop.util.Shell;
-
+  
-  public boolean isValidName(String src) {
-    // Different local file systems have different validation rules. Skip
-    // validation here and just let the OS handle it. This is consistent with
-    // RawLocalFileSystem.
+  public boolean supportsSymlinks() {
+  }  
+  
+  @Override
+  public void createSymlink(Path target, Path link, boolean createParent) 
+      throws IOException {
+    final String targetScheme = target.toUri().getScheme();
+    if (targetScheme != null && !"file".equals(targetScheme)) {
+      throw new IOException("Unable to create symlink to non-local file "+
+                            "system: "+target.toString());
+    }
+    if (createParent) {
+      mkdir(link.getParent(), FsPermission.getDirDefault(), true);
+    }
+    // NB: Use createSymbolicLink in java.nio.file.Path once available
+    try {
+      Shell.execCommand(Shell.getSymlinkCommand(
+        Path.getPathWithoutSchemeAndAuthority(target).toString(),
+        Path.getPathWithoutSchemeAndAuthority(link).toString()));
+    } catch (IOException x) {
+      throw new IOException("Unable to create symlink: "+x.getMessage());
+    }
+  }
+
+  /** 
+   * Returns the target of the given symlink. Returns the empty string if  
+   * the given path does not refer to a symlink or there is an error 
+   * acessing the symlink.
+   */
+  private String readLink(Path p) {
+    /* NB: Use readSymbolicLink in java.nio.file.Path once available. Could
+     * use getCanonicalPath in File to get the target of the symlink but that 
+     * does not indicate if the given path refers to a symlink.
+     */
+    try {
+      final String path = p.toUri().getPath();
+      return Shell.execCommand(Shell.READ_LINK_COMMAND, path).trim(); 
+    } catch (IOException x) {
+      return "";
+    }
+  }
+  
+  /**
+   * Return a FileStatus representing the given path. If the path refers 
+   * to a symlink return a FileStatus representing the link rather than
+   * the object the link refers to.
+   */
+  @Override
+  public FileStatus getFileLinkStatus(final Path f) throws IOException {
+    String target = readLink(f);
+    try {
+      FileStatus fs = getFileStatus(f);
+      // If f refers to a regular file or directory      
+      if (target.isEmpty()) {
+        return fs;
+      }
+      // Otherwise f refers to a symlink
+      return new FileStatus(fs.getLen(), 
+          false,
+          fs.getReplication(), 
+          fs.getBlockSize(),
+          fs.getModificationTime(),
+          fs.getAccessTime(),
+          fs.getPermission(),
+          fs.getOwner(),
+          fs.getGroup(),
+          new Path(target),
+          f);
+    } catch (FileNotFoundException e) {
+      /* The exists method in the File class returns false for dangling 
+       * links so we can get a FileNotFoundException for links that exist.
+       * It's also possible that we raced with a delete of the link. Use
+       * the readBasicFileAttributes method in java.nio.file.attributes 
+       * when available.
+       */
+      if (!target.isEmpty()) {
+        return new FileStatus(0, false, 0, 0, 0, 0, FsPermission.getDefault(), 
+            "", "", new Path(target), f);        
+      }
+      // f refers to a file or directory that does not exist
+      throw e;
+    }
+  }
+  
+   @Override
+   public boolean isValidName(String src) {
+     // Different local file systems have different validation rules.  Skip
+     // validation here and just let the OS handle it.  This is consistent with
+     // RawLocalFileSystem.
+     return true;
+   }
+  
+  @Override
+  public Path getLinkTarget(Path f) throws IOException {
+    /* We should never get here. Valid local links are resolved transparently
+     * by the underlying local file system and accessing a dangling link will 
+     * result in an IOException, not an UnresolvedLinkException, so FileContext
+     * should never call this function.
+     */
+    throw new AssertionError();

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS29 INS78 INS83 INS43 INS42 INS44 INS43 INS8 INS78 INS83 INS43 INS42 INS44 INS43 INS8 INS42 INS41 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS60 INS25 INS25 INS54 INS65 INS42 INS43 INS42 INS54 INS65 INS42 INS42 INS83 INS43 INS42 INS42 INS60 INS54 INS42 INS42 INS43 INS42 INS42 INS53 INS9 INS42 INS42 INS83 INS43 INS59 INS27 INS8 INS42 INS8 INS8 INS12 INS66 INS66 INS66 INS42 INS8 INS12 INS66 INS66 INS66 INS42 INS43 INS59 INS8 INS12 INS42 INS14 INS42 INS42 INS32 INS27 INS38 INS53 INS21 INS21 INS44 INS8 INS60 INS41 INS44 INS8 INS42 INS42 INS32 INS60 INS25 INS41 INS44 INS8 INS43 INS32 INS42 INS42 INS33 INS32 INS14 INS32 INS32 INS43 INS42 INS53 INS83 INS43 INS59 INS32 INS43 INS42 INS41 INS42 INS42 INS43 INS59 INS32 INS8 INS14 INS43 INS42 INS25 INS53 INS42 INS42 INS42 INS45 INS42 INS42 INS43 INS27 INS42 INS32 INS32 INS9 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS32 INS32 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS41 INS43 INS32 INS9 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS14 INS42 INS42 INS38 INS8 INS42 INS42 INS45 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS43 INS27 INS32 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS32 INS41 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS34 INS9 INS34 INS34 INS34 INS34 INS32 INS45 INS45 INS14 INS42 INS42 INS42 INS42 INS43 INS42 INS42
HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.jar.Attributes;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+import org.apache.commons.collections.map.CaseInsensitiveMap;
+import org.apache.hadoop.fs.permission.FsAction;
+import org.apache.hadoop.fs.permission.FsPermission;
+import org.apache.hadoop.io.nativeio.NativeIO;
+import org.apache.hadoop.util.StringUtils;
+  /* The error code is defined in winutils to indicate insufficient
+   * privilege to create symbolic links. This value need to keep in
+   * sync with the constant of the same name in:
+   * "src\winutils\common.h"
+   * */
+  public static final int SYMLINK_NO_PRIVILEGE = 2;
+
-   * This class is only used on windows to invoke the cygpath command.
-   */
-  private static class CygPathCommand extends Shell {
-    String[] command;
-    String result;
-    CygPathCommand(String path) throws IOException {
-      command = new String[]{"cygpath", "-u", path};
-      run();
-    }
-    String getResult() throws IOException {
-      return result;
-    }
-    @Override
-    protected String[] getExecString() {
-      return command;
-    }
-    @Override
-    protected void parseExecResult(BufferedReader lines) throws IOException {
-      String line = lines.readLine();
-      if (line == null) {
-        throw new IOException("Can't convert '" + command[2] + 
-                              " to a cygwin path");
-      }
-      result = line;
-    }
-  }
-
-  /**
-    if (Path.WINDOWS) {
-      return new CygPathCommand(filename).getResult();
-    } else {
-      return filename;
-    }    
+    return filename;
-    
+
-   * Supports Unix, Cygwin, WindXP.
+   * Supports Unix, WindXP.
-   * only on a local disk. HDFS does not support this
+   * only on a local disk. HDFS does not support this.
+   * On Windows, when symlink creation fails due to security
+   * setting, we will log a warning. The return code in this
+   * case is 2.
-    String cmd = "ln -s " + target + " " + linkname;
-    Process p = Runtime.getRuntime().exec(cmd, null);
-    int returnVal = -1;
-    try{
-      returnVal = p.waitFor();
-    } catch(InterruptedException e){
-      //do nothing as of yet
+    // Run the input paths through Java's File so that they are converted to the
+    // native OS form
+    File targetFile = new File(target);
+    File linkFile = new File(linkname);
+
+    // If not on Java7+, copy a file instead of creating a symlink since
+    // Java6 has close to no support for symlinks on Windows. Specifically
+    // File#length and File#renameTo do not work as expected.
+    // (see HADOOP-9061 for additional details)
+    // We still create symlinks for directories, since the scenario in this
+    // case is different. The directory content could change in which
+    // case the symlink loses its purpose (for example task attempt log folder
+    // is symlinked under userlogs and userlogs are generated afterwards).
+    if (Shell.WINDOWS && !Shell.isJava7OrAbove() && targetFile.isFile()) {
+      try {
+        LOG.info("FileUtil#symlink: On Java6, copying file instead "
+            + linkname + " -> " + target);
+        org.apache.commons.io.FileUtils.copyFile(targetFile, linkFile);
+      } catch (IOException ex) {
+        LOG.warn("FileUtil#symlink failed to copy the file with error: "
+            + ex.getMessage());
+        // Exit with non-zero exit code
+        return 1;
+      }
+      return 0;
-    return returnVal;
+
+    String[] cmd = Shell.getSymlinkCommand(targetFile.getPath(),
+        linkFile.getPath());
+    ShellCommandExecutor shExec = new ShellCommandExecutor(cmd);
+    try {
+      shExec.execute();
+    } catch (Shell.ExitCodeException ec) {
+      int returnVal = ec.getExitCode();
+      if (Shell.WINDOWS && returnVal == SYMLINK_NO_PRIVILEGE) {
+        LOG.warn("Fail to create symbolic links on Windows. "
+            + "The default security settings in Windows disallow non-elevated "
+            + "administrators and all non-administrators from creating symbolic links. "
+            + "This behavior can be changed in the Local Security Policy management console");
+      } else if (returnVal != 0) {
+        LOG.warn("Command '" + StringUtils.join(" ", cmd) + "' failed "
+            + returnVal + " with: " + ec.getMessage());
+      }
+      return returnVal;
+    } catch (IOException e) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Error while create symlink " + linkname + " to " + target
+            + "." + " Exception: " + StringUtils.stringifyException(e));
+      }
+      throw e;
+    }
+    return shExec.getExitCode();
-   * @throws InterruptedException
-                            throws IOException, InterruptedException {
-    StringBuilder cmdBuf = new StringBuilder();
-    cmdBuf.append("chmod ");
-    if (recursive) {
-      cmdBuf.append("-R ");
-    }
-    cmdBuf.append(perm).append(" ");
-    cmdBuf.append(filename);
-    String[] shellCmd = {"bash", "-c" ,cmdBuf.toString()};
-    ShellCommandExecutor shExec = new ShellCommandExecutor(shellCmd);
+                            throws IOException {
+    String [] cmd = Shell.getSetPermissionCommand(perm, recursive);
+    String[] args = new String[cmd.length + 1];
+    System.arraycopy(cmd, 0, args, 0, cmd.length);
+    args[cmd.length] = new File(filename).getPath();
+    ShellCommandExecutor shExec = new ShellCommandExecutor(args);
-    }catch(Exception e) {
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Error while changing permission : " + filename
-            + " Exception: ", e);
+    }catch(IOException e) {
+      if(LOG.isDebugEnabled()) {
+        LOG.debug("Error while changing permission : " + filename 
+                  +" Exception: " + StringUtils.stringifyException(e));
+
+  /**
+   * Set the ownership on a file / directory. User name and group name
+   * cannot both be null.
+   * @param file the file to change
+   * @param username the new user owner name
+   * @param groupname the new group owner name
+   * @throws IOException
+   */
+  public static void setOwner(File file, String username,
+      String groupname) throws IOException {
+    if (username == null && groupname == null) {
+      throw new IOException("username == null && groupname == null");
+    }
+    String arg = (username == null ? "" : username)
+        + (groupname == null ? "" : ":" + groupname);
+    String [] cmd = Shell.getSetOwnerCommand(arg);
+    execCommand(file, cmd);
+  }
+
+  /**
+   * Set permissions to the required value. Uses the java primitives instead
+   * of forking if group == other.
+   * @param f the file to change
+   * @param permission the new permissions
+   * @throws IOException
+   */
+  public static void setPermission(File f, FsPermission permission
+                                   ) throws IOException {
+    FsAction user = permission.getUserAction();
+    FsAction group = permission.getGroupAction();
+    FsAction other = permission.getOtherAction();
+
+    // use the native/fork if the group/other permissions are different
+    // or if the native is available or on Windows
+    if (group != other || NativeIO.isAvailable() || Shell.WINDOWS) {
+      execSetPermission(f, permission);
+      return;
+    }
+    
+    boolean rv = true;
+    
+    // read perms
+    rv = f.setReadable(group.implies(FsAction.READ), false);
+    checkReturnValue(rv, f, permission);
+    if (group.implies(FsAction.READ) != user.implies(FsAction.READ)) {
+      rv = f.setReadable(user.implies(FsAction.READ), true);
+      checkReturnValue(rv, f, permission);
+    }
+
+    // write perms
+    rv = f.setWritable(group.implies(FsAction.WRITE), false);
+    checkReturnValue(rv, f, permission);
+    if (group.implies(FsAction.WRITE) != user.implies(FsAction.WRITE)) {
+      rv = f.setWritable(user.implies(FsAction.WRITE), true);
+      checkReturnValue(rv, f, permission);
+    }
+
+    // exec perms
+    rv = f.setExecutable(group.implies(FsAction.EXECUTE), false);
+    checkReturnValue(rv, f, permission);
+    if (group.implies(FsAction.EXECUTE) != user.implies(FsAction.EXECUTE)) {
+      rv = f.setExecutable(user.implies(FsAction.EXECUTE), true);
+      checkReturnValue(rv, f, permission);
+    }
+  }
+
+  private static void checkReturnValue(boolean rv, File p, 
+                                       FsPermission permission
+                                       ) throws IOException {
+    if (!rv) {
+      throw new IOException("Failed to set permissions of path: " + p + 
+                            " to " + 
+                            String.format("%04o", permission.toShort()));
+    }
+  }
+  private static void execSetPermission(File f, 
+                                        FsPermission permission
+                                       )  throws IOException {
+    if (NativeIO.isAvailable()) {
+      NativeIO.POSIX.chmod(f.getCanonicalPath(), permission.toShort());
+    } else {
+      execCommand(f, Shell.getSetPermissionCommand(
+                  String.format("%04o", permission.toShort()), false));
+    }
+  }
+  
+  static String execCommand(File f, String... cmd) throws IOException {
+    String[] args = new String[cmd.length + 1];
+    System.arraycopy(cmd, 0, args, 0, cmd.length);
+    args[cmd.length] = f.getCanonicalPath();
+    String output = Shell.execCommand(args);
+    return output;
+  }
+
+  
+  /**
+   * Create a jar file at the given path, containing a manifest with a classpath
+   * that references all specified entries.
+   * 
+   * Some platforms may have an upper limit on command line length.  For example,
+   * the maximum command line length on Windows is 8191 characters, but the
+   * length of the classpath may exceed this.  To work around this limitation,
+   * use this method to create a small intermediate jar with a manifest that
+   * contains the full classpath.  It returns the absolute path to the new jar,
+   * which the caller may set as the classpath for a new process.
+   * 
+   * Environment variable evaluation is not supported within a jar manifest, so
+   * this method expands environment variables before inserting classpath entries
+   * to the manifest.  The method parses environment variables according to
+   * platform-specific syntax (%VAR% on Windows, or $VAR otherwise).  On Windows,
+   * environment variables are case-insensitive.  For example, %VAR% and %var%
+   * evaluate to the same value.
+   * 
+   * Specifying the classpath in a jar manifest does not support wildcards, so
+   * this method expands wildcards internally.  Any classpath entry that ends
+   * with * is translated to all files at that path with extension .jar or .JAR.
+   * 
+   * @param inputClassPath String input classpath to bundle into the jar manifest
+   * @param pwd Path to working directory to save jar
+   * @return String absolute path to new jar
+   * @throws IOException if there is an I/O error while writing the jar file
+   */
+  public static String createJarWithClassPath(String inputClassPath, Path pwd)
+      throws IOException {
+    // Replace environment variables, case-insensitive on Windows
+    @SuppressWarnings("unchecked")
+    Map<String, String> env = Shell.WINDOWS ?
+      new CaseInsensitiveMap(System.getenv()) : System.getenv();
+    String[] classPathEntries = inputClassPath.split(File.pathSeparator);
+    for (int i = 0; i < classPathEntries.length; ++i) {
+      classPathEntries[i] = StringUtils.replaceTokens(classPathEntries[i],
+        StringUtils.ENV_VAR_PATTERN, env);
+    }
+    File workingDir = new File(pwd.toString());
+    if (!workingDir.mkdirs()) {
+      // If mkdirs returns false because the working directory already exists,
+      // then this is acceptable.  If it returns false due to some other I/O
+      // error, then this method will fail later with an IOException while saving
+      // the jar.
+      LOG.debug("mkdirs false for " + workingDir + ", execution will continue");
+    }
+
+    // Append all entries
+    List<String> classPathEntryList = new ArrayList<String>(
+      classPathEntries.length);
+    for (String classPathEntry: classPathEntries) {
+      if (classPathEntry.endsWith("*")) {
+        // Append all jars that match the wildcard
+        Path globPath = new Path(classPathEntry).suffix("{.jar,.JAR}");
+        FileStatus[] wildcardJars = FileContext.getLocalFSFileContext().util()
+          .globStatus(globPath);
+        if (wildcardJars != null) {
+          for (FileStatus wildcardJar: wildcardJars) {
+            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()
+              .toExternalForm());
+          }
+        }
+      } else {
+        // Append just this jar
+        classPathEntryList.add(new File(classPathEntry).toURI().toURL()
+          .toExternalForm());
+      }
+    }
+    String jarClassPath = StringUtils.join(" ", classPathEntryList);
+
+    // Create the manifest
+    Manifest jarManifest = new Manifest();
+    jarManifest.getMainAttributes().putValue(
+        Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
+    jarManifest.getMainAttributes().putValue(
+        Attributes.Name.CLASS_PATH.toString(), jarClassPath);
+
+    // Write the manifest to output JAR file
+    File classPathJar = File.createTempFile("classpath-", ".jar", workingDir);
+    FileOutputStream fos = null;
+    BufferedOutputStream bos = null;
+    JarOutputStream jos = null;
+    try {
+      fos = new FileOutputStream(classPathJar);
+      bos = new BufferedOutputStream(fos);
+      jos = new JarOutputStream(bos, jarManifest);
+    } finally {
+      IOUtils.cleanup(LOG, jos, bos, fos);
+    }
+
+    return classPathJar.getCanonicalPath();
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS39 INS59 MOV8 MOV29 INS83 INS83 INS39 INS42 MOV44 MOV44 MOV43 INS8 MOV29 INS83 INS83 INS39 INS42 MOV44 MOV44 MOV44 MOV43 INS8 INS29 MOV83 MOV83 UPD39 MOV39 UPD42 MOV42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS44 MOV44 MOV43 INS8 INS29 INS43 INS42 INS44 INS44 UPD43 INS42 INS34 INS60 INS60 INS25 INS60 INS60 INS54 INS41 INS60 INS60 INS21 MOV21 MOV60 INS54 MOV41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 MOV43 INS42 MOV43 INS42 INS42 INS25 MOV60 INS60 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS25 MOV60 INS21 INS21 INS25 INS21 INS21 INS25 INS21 INS21 INS25 INS39 INS42 INS43 INS42 INS43 INS42 UPD42 MOV42 INS25 INS43 INS42 INS43 INS42 INS42 INS25 INS42 INS43 INS42 UPD42 INS60 INS21 INS21 INS60 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 UPD42 INS60 INS24 INS60 INS60 INS70 INS60 INS60 INS21 INS21 INS60 INS60 INS60 INS60 INS41 UPD66 UPD66 INS66 INS66 INS66 INS43 INS59 INS43 INS59 INS27 INS8 MOV5 INS59 INS43 INS59 INS8 INS12 INS12 INS32 MOV5 INS59 MOV5 INS59 INS32 MOV43 MOV8 INS12 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS27 INS8 MOV43 INS5 INS59 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 UPD39 INS7 INS32 INS27 INS8 INS7 INS32 INS27 INS8 INS7 INS32 INS27 INS8 INS42 INS42 INS38 INS8 INS42 INS42 INS32 INS8 INS8 INS42 INS5 INS59 INS32 INS7 MOV43 INS59 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS79 INS74 INS5 INS59 INS58 INS27 INS38 INS8 INS43 INS59 INS38 INS74 INS59 INS44 INS42 INS8 INS43 INS59 INS43 INS59 INS32 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS8 INS8 INS32 UPD42 MOV42 UPD42 MOV42 INS14 INS42 UPD42 MOV42 INS14 INS40 INS38 INS32 INS54 INS41 INS42 INS32 INS42 INS42 INS14 INS21 INS44 INS8 INS44 INS8 INS42 INS42 INS42 INS32 INS42 INS3 INS42 INS42 INS42 INS34 INS42 INS34 INS40 INS2 INS32 INS44 INS8 INS27 INS27 INS53 UPD42 INS43 INS85 UPD42 MOV42 INS32 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS27 INS40 INS21 INS41 UPD42 INS9 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 MOV21 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS21 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS21 INS21 INS42 INS53 INS42 INS42 INS21 INS21 INS43 INS85 INS42 INS3 INS42 INS42 INS42 INS34 INS42 INS34 INS40 INS2 INS32 INS42 INS32 INS42 INS45 INS43 INS43 INS43 UPD42 INS16 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 MOV21 INS42 INS42 INS14 INS32 INS43 INS43 INS42 INS14 INS43 INS42 INS25 INS42 INS42 INS32 INS42 INS42 INS14 INS32 INS42 INS32 INS45 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS21 INS21 MOV21 INS42 INS42 INS43 INS42 INS43 INS42 INS32 INS42 INS42 INS8 INS12 INS34 INS42 INS42 INS32 INS32 INS43 INS42 INS32 INS43 INS42 MOV60 MOV25 MOV41 MOV43 INS42 INS25 INS53 INS42 INS42 INS42 INS42 MOV5 INS27 INS42 INS40 INS14 INS42 MOV43 UPD42 MOV43 INS42 INS25 INS42 INS33 INS42 INS33 INS14 INS36 INS36 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS32 INS42 INS42 INS32 INS9 INS42 INS42 INS40 INS42 INS42 INS40 INS32 INS42 INS42 INS32 INS9 INS42 INS42 INS40 INS42 INS42 INS40 INS7 INS32 INS42 INS42 INS32 INS9 INS42 INS42 INS40 INS42 INS42 INS40 INS7 INS32 INS14 INS32 INS32 INS42 INS5 INS27 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS40 INS14 INS32 INS42 INS42 INS42 INS40 INS42 INS34 INS7 INS43 INS32 INS42 INS42 INS42 INS42 INS74 INS40 INS42 INS32 INS8 INS8 INS42 INS42 INS45 INS42 INS43 INS42 INS42 INS40 INS42 UPD42 MOV42 INS42 INS40 MOV42 INS42 INS42 INS45 INS45 INS42 INS7 INS7 INS7 INS42 INS42 INS42 INS42 MOV21 MOV21 INS44 INS8 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS40 INS39 INS27 INS8 INS25 INS32 INS8 INS42 INS40 INS34 INS43 INS42 MOV32 INS8 INS43 INS45 INS16 INS16 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS27 INS40 INS42 INS32 INS32 INS42 INS42 INS32 INS43 INS85 INS40 INS34 UPD43 MOV43 INS32 INS42 INS42 INS2 INS32 INS42 INS42 INS42 UPD42 UPD42 INS27 INS43 INS43 INS42 INS42 INS45 INS60 INS60 INS25 MOV21 INS42 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS42 UPD42 INS42 UPD42 INS32 MOV43 INS42 INS21 INS41 UPD42 INS40 INS27 INS21 INS27 MOV8 INS42 INS42 INS21 INS42 INS21 INS42 INS27 INS45 INS42 INS27 INS45 INS27 UPD42 INS42 INS32 INS9 INS42 INS42 INS32 INS9 INS42 INS42 INS32 INS9 INS42 INS45 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS9 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS40 INS42 INS45 INS42 INS45 INS42 INS42 INS43 INS59 INS5 INS59 INS27 INS8 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS27 INS40 UPD42 INS42 INS42 INS32 INS34 UPD42 UPD42 UPD42 MOV42 INS42 INS32 INS42 INS34 INS21 INS32 INS32 INS42 INS33 INS42 INS33 INS45 UPD42 MOV42 UPD42 MOV42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS45 INS32 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS33 INS70 UPD42 UPD42 INS32 UPD42 MOV42 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS14 INS42 INS45 INS42 INS32 INS42 INS42 INS44 INS42 INS8 INS32 INS42 INS45 INS32 INS45 INS45 INS45 INS45 INS42 INS42 INS27 INS45 INS42 INS45 INS42 INS45 INS45 INS32 INS45 INS42 INS45 INS32 INS43 INS42 INS32 INS42 INS43 INS42 MOV21 INS32 INS42 INS42 INS42 UPD45 MOV45 INS32 INS45 INS42 UPD45 MOV45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS14 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS32 INS42 INS42 MOV32 UPD42 MOV42 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL59 DEL23 DEL59 DEL23 DEL42 DEL8 DEL31 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL55 DEL40 DEL42 DEL43 DEL42 DEL14 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL45 DEL45 DEL42 DEL4 DEL3 DEL7 DEL42 DEL34 DEL2 DEL27 DEL14 DEL53 DEL33 DEL27 DEL43 DEL32 DEL33 DEL32 DEL59 DEL60 DEL8 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL65 DEL42 DEL42 DEL45 DEL42 DEL45 DEL34 DEL38 DEL39 DEL42 DEL43 DEL14 DEL42 DEL42 DEL45 DEL32 DEL42 DEL45 DEL45 DEL32 DEL42 DEL42 DEL45 DEL45 DEL32 DEL4 DEL59 DEL60 DEL45 DEL42 DEL45 DEL27 DEL43 DEL42 DEL44 DEL8 DEL25 DEL8 DEL12
HADOOP-8163. Improve ActiveStandbyElector to provide hooks for fencing old active. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1304675 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
+import org.apache.hadoop.util.StringUtils;
+import com.google.common.base.Preconditions;
+
+    /**
+     * If an old active has failed, rather than exited gracefully, then
+     * the new active may need to take some fencing actions against it
+     * before proceeding with failover.
+     * 
+     * @param oldActiveData the application data provided by the prior active
+     */
+    void fenceOldActive(byte[] oldActiveData);
-  protected static final String LOCKFILENAME = "ActiveStandbyElectorLock";
+  protected static final String LOCK_FILENAME = "ActiveStandbyElectorLock";
+  @VisibleForTesting
+  protected static final String BREADCRUMB_FILENAME = "ActiveBreadCrumb";
+  private final String zkBreadCrumbPath;
-    zkLockFilePath = znodeWorkingDir + "/" + LOCKFILENAME;
+    zkLockFilePath = znodeWorkingDir + "/" + LOCK_FILENAME;
+    zkBreadCrumbPath = znodeWorkingDir + "/" + BREADCRUMB_FILENAME;    
+    
+  
+  /**
+   * @return true if the configured parent znode exists
+   */
+  public synchronized boolean parentZNodeExists()
+      throws IOException, InterruptedException {
+    Preconditions.checkState(zkClient != null);
+    try {
+      return zkClient.exists(znodeWorkingDir, false) != null;
+    } catch (KeeperException e) {
+      throw new IOException("Couldn't determine existence of znode '" +
+          znodeWorkingDir + "'", e);
+    }
+  }
+
+  /**
+   * Utility function to ensure that the configured base znode exists.
+   * This recursively creates the znode as well as all of its parents.
+   */
+  public synchronized void ensureParentZNode()
+      throws IOException, InterruptedException {
+    String pathParts[] = znodeWorkingDir.split("/");
+    Preconditions.checkArgument(pathParts.length >= 1 &&
+        "".equals(pathParts[0]),
+        "Invalid path: %s", znodeWorkingDir);
+    
+    StringBuilder sb = new StringBuilder();
+    for (int i = 1; i < pathParts.length; i++) {
+      sb.append("/").append(pathParts[i]);
+      String prefixPath = sb.toString();
+      LOG.debug("Ensuring existence of " + prefixPath);
+      try {
+        createWithRetries(prefixPath, new byte[]{}, zkAcl, CreateMode.PERSISTENT);
+      } catch (KeeperException e) {
+        if (isNodeExists(e.code())) {
+          // This is OK - just ensuring existence.
+          continue;
+        } else {
+          throw new IOException("Couldn't create " + prefixPath, e);
+        }
+      }
+    }
+  }
+   * 
+   * @param needFence true if the underlying daemon may need to be fenced
+   * if a failover occurs due to dropping out of the election.
-  public synchronized void quitElection() {
+  public synchronized void quitElection(boolean needFence) {
+    if (!needFence && state == State.ACTIVE) {
+      // If active is gracefully going back to standby mode, remove
+      // our permanent znode so no one fences us.
+      tryDeleteOwnBreadCrumbNode();
+    }
-      if (operationNodeDoesNotExist(code)) {
+      if (isNodeDoesNotExist(code)) {
-    if (operationSuccess(code)) {
+    if (isSuccess(code)) {
-    if (operationNodeExists(code)) {
+    if (isNodeExists(code)) {
-        + code.toString();
+        + code.toString() + " for path " + path;
-    if (operationRetry(code)) {
+    if (shouldRetry(code)) {
-        createNode();
+        createLockNodeAsync();
-    if (operationSuccess(code)) {
+    if (isSuccess(code)) {
-    if (operationNodeDoesNotExist(code)) {
+    if (isNodeDoesNotExist(code)) {
-    if (operationRetry(code)) {
+    if (shouldRetry(code)) {
-        monitorNode();
+        monitorLockNodeAsync();
-    monitorNode();
+    monitorLockNodeAsync();
-    createNode();
+    createLockNodeAsync();
-
+  
+      try {
+        Stat oldBreadcrumbStat = fenceOldActive();
+        writeBreadCrumbNode(oldBreadcrumbStat);
+      } catch (Exception e) {
+        LOG.warn("Exception handling the winning of election", e);
+        reJoinElection();
+        return;
+      }
+  /**
+   * Write the "ActiveBreadCrumb" node, indicating that this node may need
+   * to be fenced on failover.
+   * @param oldBreadcrumbStat 
+   */
+  private void writeBreadCrumbNode(Stat oldBreadcrumbStat)
+      throws KeeperException, InterruptedException {
+    LOG.info("Writing znode " + zkBreadCrumbPath +
+        " to indicate that the local node is the most recent active...");
+    if (oldBreadcrumbStat == null) {
+      // No previous active, just create the node
+      createWithRetries(zkBreadCrumbPath, appData, zkAcl,
+        CreateMode.PERSISTENT);
+    } else {
+      // There was a previous active, update the node
+      setDataWithRetries(zkBreadCrumbPath, appData, oldBreadcrumbStat.getVersion());
+    }
+  }
+  
+  /**
+   * Try to delete the "ActiveBreadCrumb" node when gracefully giving up
+   * active status.
+   * If this fails, it will simply warn, since the graceful release behavior
+   * is only an optimization.
+   */
+  private void tryDeleteOwnBreadCrumbNode() {
+    assert state == State.ACTIVE;
+    LOG.info("Deleting bread-crumb of active node...");
+    
+    // Sanity check the data. This shouldn't be strictly necessary,
+    // but better to play it safe.
+    Stat stat = new Stat();
+    byte[] data = null;
+    try {
+      data = zkClient.getData(zkBreadCrumbPath, false, stat);
+
+      if (!Arrays.equals(data, appData)) {
+        throw new IllegalStateException(
+            "We thought we were active, but in fact " +
+            "the active znode had the wrong data: " +
+            StringUtils.byteToHexString(data) + " (stat=" + stat + ")");
+      }
+      
+      deleteWithRetries(zkBreadCrumbPath, stat.getVersion());
+    } catch (Exception e) {
+      LOG.warn("Unable to delete our own bread-crumb of being active at " +
+          zkBreadCrumbPath + ": " + e.getLocalizedMessage() + ". " +
+          "Expecting to be fenced by the next active.");
+    }
+  }
+
+  /**
+   * If there is a breadcrumb node indicating that another node may need
+   * fencing, try to fence that node.
+   * @return the Stat of the breadcrumb node that was read, or null
+   * if no breadcrumb node existed
+   */
+  private Stat fenceOldActive() throws InterruptedException, KeeperException {
+    final Stat stat = new Stat();
+    byte[] data;
+    LOG.info("Checking for any old active which needs to be fenced...");
+    try {
+      data = zkDoWithRetries(new ZKAction<byte[]>() {
+        @Override
+        public byte[] run() throws KeeperException, InterruptedException {
+          return zkClient.getData(zkBreadCrumbPath, false, stat);
+        }
+      });
+    } catch (KeeperException ke) {
+      if (isNodeDoesNotExist(ke.code())) {
+        LOG.info("No old node to fence");
+        return null;
+      }
+      
+      // If we failed to read for any other reason, then likely we lost
+      // our session, or we don't have permissions, etc. In any case,
+      // we probably shouldn't become active, and failing the whole
+      // thing is the best bet.
+      throw ke;
+    }
+
+    LOG.info("Old node exists: " + StringUtils.byteToHexString(data));
+    if (Arrays.equals(data, appData)) {
+      LOG.info("But old node has our own data, so don't need to fence it.");
+    } else {
+      appClient.fenceOldActive(data);
+    }
+    return stat;
+  }
+
-  private void createNode() {
+  private void createLockNodeAsync() {
-  private void monitorNode() {
-    zkClient.exists(zkLockFilePath, true, this, null);
+  private void monitorLockNodeAsync() {
+    zkClient.exists(zkLockFilePath, this, this, null);
-  private boolean operationSuccess(Code code) {
+  private String createWithRetries(final String path, final byte[] data,
+      final List<ACL> acl, final CreateMode mode)
+      throws InterruptedException, KeeperException {
+    return zkDoWithRetries(new ZKAction<String>() {
+      public String run() throws KeeperException, InterruptedException {
+        return zkClient.create(path, data, acl, mode);
+      }
+    });
+  }
+
+  private Stat setDataWithRetries(final String path, final byte[] data,
+      final int version) throws InterruptedException, KeeperException {
+    return zkDoWithRetries(new ZKAction<Stat>() {
+      public Stat run() throws KeeperException, InterruptedException {
+        return zkClient.setData(path, data, version);
+      }
+    });
+  }
+  
+  private void deleteWithRetries(final String path, final int version)
+      throws KeeperException, InterruptedException {
+    zkDoWithRetries(new ZKAction<Void>() {
+      public Void run() throws KeeperException, InterruptedException {
+        zkClient.delete(path, version);
+        return null;
+      }
+    });
+  }
+
+  private static <T> T zkDoWithRetries(ZKAction<T> action)
+      throws KeeperException, InterruptedException {
+    int retry = 0;
+    while (true) {
+      try {
+        return action.run();
+      } catch (KeeperException ke) {
+        if (shouldRetry(ke.code()) && ++retry < NUM_RETRIES) {
+          continue;
+        }
+        throw ke;
+      }
+    }
+  }
+  
+  private interface ZKAction<T> {
+    T run() throws KeeperException, InterruptedException; 
+  }
+
+  private static boolean isSuccess(Code code) {
-  private boolean operationNodeExists(Code code) {
+  private static boolean isNodeExists(Code code) {
-  private boolean operationNodeDoesNotExist(Code code) {
+  private static boolean isNodeDoesNotExist(Code code) {
-  private boolean operationRetry(Code code) {
+  private static boolean shouldRetry(Code code) {

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS31 INS78 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS39 INS42 INS43 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS43 INS43 INS8 INS44 INS29 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS43 INS43 INS8 UPD42 UPD42 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS43 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS8 INS83 INS83 INS73 INS43 INS42 INS44 INS43 INS43 INS8 INS83 INS42 INS73 INS31 INS83 UPD42 INS83 UPD42 INS83 UPD42 INS83 UPD42 INS29 INS39 INS42 INS44 UPD42 INS42 INS42 INS42 INS45 INS42 INS42 INS21 INS65 INS42 INS42 INS21 INS54 INS65 INS42 INS42 INS60 INS21 INS60 INS24 INS65 INS39 INS42 INS25 INS65 INS65 INS43 INS42 INS42 INS42 INS21 INS25 INS65 INS6 INS21 INS60 INS60 INS54 INS65 INS65 INS42 INS42 INS42 INS60 INS60 INS21 INS54 INS21 INS25 INS41 INS42 INS83 INS43 INS42 INS83 INS5 INS42 INS83 INS74 INS42 INS83 INS43 INS42 INS42 INS42 INS41 INS42 INS83 INS43 INS42 INS83 INS5 INS42 INS83 INS39 INS42 INS42 INS42 INS41 INS83 INS43 INS42 INS83 INS39 INS42 INS42 INS42 INS21 INS42 INS42 INS74 INS42 INS42 INS42 INS60 INS61 INS42 INS43 INS42 INS43 INS43 INS65 INS65 INS5 INS42 INS7 INS66 INS32 INS8 INS12 INS66 INS66 INS43 INS59 INS32 INS43 INS59 INS58 INS27 INS37 INS8 INS42 INS66 INS66 INS27 INS8 INS66 INS66 INS42 INS66 INS42 INS32 INS27 INS8 INS8 INS66 INS66 INS66 INS66 INS27 INS32 INS43 INS59 INS5 INS59 INS8 INS12 INS66 INS66 INS66 INS66 INS83 INS43 INS59 INS5 INS59 INS32 INS8 INS12 INS32 INS32 INS8 INS8 INS42 INS42 INS39 INS85 INS43 INS43 INS42 INS32 INS42 INS39 INS85 INS32 INS42 INS32 INS43 INS43 INS39 INS59 INS9 INS8 INS42 INS42 INS42 INS66 INS66 INS66 INS42 INS66 INS39 INS85 INS42 INS27 INS42 INS42 INS27 INS41 INS44 INS8 INS42 INS42 INS85 INS32 INS42 INS42 INS27 INS45 INS42 INS42 INS42 INS14 INS39 INS59 INS42 INS40 INS42 INS21 INS60 INS21 INS54 INS38 INS27 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS54 INS42 INS42 INS27 INS42 INS33 INS21 INS21 INS42 INS40 INS42 INS42 INS45 INS42 INS42 INS14 INS39 INS85 INS42 INS33 INS21 INS25 INS21 INS44 INS8 INS42 INS42 INS14 INS39 INS85 INS42 INS42 INS42 INS45 INS21 INS44 INS8 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS21 INS21 INS52 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS34 INS54 UPD42 INS42 INS45 INS42 INS42 INS33 INS27 INS43 INS42 INS53 INS42 INS42 INS45 INS27 INS32 INS43 INS42 INS34 INS32 INS43 INS59 INS32 INS8 INS12 INS42 INS42 INS40 INS32 INS45 INS42 INS8 INS12 INS45 INS42 INS45 INS32 INS32 INS43 INS7 INS38 INS8 INS32 INS43 INS42 INS21 INS43 INS7 INS43 INS42 INS25 INS53 INS45 INS32 INS32 INS32 INS74 INS1 INS74 INS1 INS74 INS1 INS8 INS12 INS32 INS33 INS42 INS14 INS40 INS34 INS45 INS42 INS2 INS42 INS32 INS42 INS2 INS42 INS42 INS32 INS42 INS42 INS27 INS21 INS44 INS8 INS42 INS60 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS53 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS43 INS31 INS43 INS43 INS31 INS43 INS43 INS31 INS41 INS44 INS8 INS42 INS42 INS42 INS9 INS43 INS27 INS42 INS42 INS34 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS42 INS32 INS43 INS42 INS25 UPD42 INS43 INS59 INS32 INS43 INS42 INS21 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS27 INS42 INS14 INS42 INS32 INS21 INS41 INS42 INS42 INS83 INS43 INS42 INS43 INS43 INS8 INS42 INS42 INS83 INS43 INS42 INS43 INS43 INS8 INS42 INS42 INS83 INS43 INS42 INS43 INS43 INS8 INS32 INS43 INS42 INS25 INS53 INS42 INS45 INS42 INS45 INS42 INS42 INS3 INS42 INS40 INS42 INS32 INS8 INS8 UPD42 UPD42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS43 INS27 INS45 INS42 INS45 INS32 INS45 INS45 INS74 INS1 INS42 INS42 INS32 INS33 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS21 INS41 INS42 INS42 INS42 INS27 INS8 INS42 INS5 INS4 INS42 INS32 INS18 INS53 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS27 INS32 INS45 INS42 INS45 INS42 INS42 INS43 INS5 INS31 INS42 INS42 INS45 INS32 INS32 INS32 INS33 INS32 INS27 INS18 INS39 INS85 INS42 INS42 INS14 INS45 INS45 INS42 INS42 INS42 INS42 INS39 INS85 INS78 INS83 INS5 INS42 INS43 INS43 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS38 INS42 INS43 INS27 INS42 INS42 INS39 INS85 INS42 INS42 INS41 INS42 INS42 INS42 INS42 INS45 INS42 INS32 INS42 INS42 INS42 INS9 INS42 DEL9
YARN-6840. Implement zookeeper based store for scheduler configuration updates. (Jonathan Hung via wangda)

Change-Id: I9debea674fe8c7e4109d4ca136965a1ea4c48bcc

+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.yarn.server.records.Version;
+import org.apache.hadoop.yarn.server.resourcemanager.RMContext;
+import org.apache.hadoop.yarn.server.resourcemanager.recovery.RMStateVersionIncompatibleException;
-public interface YarnConfigurationStore {
+public abstract class YarnConfigurationStore {
+  public static final Log LOG =
+      LogFactory.getLog(YarnConfigurationStore.class);
-  class LogMutation implements Serializable {
+  static class LogMutation implements Serializable {
-    private long id;
-     * Create log mutation prior to logging.
+     * Create log mutation.
-    public LogMutation(Map<String, String> updates, String user) {
-      this(updates, user, 0);
-    }
-
-    /**
-     * Create log mutation for recovery.
-     * @param updates key-value configuration updates
-     * @param user user who requested configuration change
-     * @param id transaction id of configuration change
-     */
-    LogMutation(Map<String, String> updates, String user, long id) {
+    LogMutation(Map<String, String> updates, String user) {
-      this.id = id;
-
-    /**
-     * Get transaction id of this configuration change.
-     * @return transaction id
-     */
-    public long getId() {
-      return id;
-    }
-
-    /**
-     * Set transaction id of this configuration change.
-     * @param id transaction id
-     */
-    public void setId(long id) {
-      this.id = id;
-    }
-   * Initialize the configuration store.
+   * Initialize the configuration store, with schedConf as the initial
+   * scheduler configuration. If a persisted store already exists, use the
+   * scheduler configuration stored there, and ignore schedConf.
-   * @param schedConf Initial key-value configuration to persist
+   * @param schedConf Initial key-value scheduler configuration to persist.
+   * @param rmContext RMContext for this configuration store
-  void initialize(Configuration conf, Configuration schedConf)
-      throws IOException;
+  public abstract void initialize(Configuration conf, Configuration schedConf,
+      RMContext rmContext) throws Exception;
-   * Logs the configuration change to backing store. Generates an id associated
-   * with this mutation, sets it in {@code logMutation}, and returns it.
+   * Logs the configuration change to backing store.
-   * @return id which configuration store associates with this mutation
-  long logMutation(LogMutation logMutation) throws IOException;
+  public abstract void logMutation(LogMutation logMutation) throws Exception;
-   * associated with {@code id} and marks the mutation as persisted (no longer
-   * pending). If isValid is true, merge the mutation with the persisted
+   * last logged by {@code logMutation} and marks the mutation as persisted (no
+   * longer pending). If isValid is true, merge the mutation with the persisted
-   *
-   * If {@code confirmMutation} is called with ids in a different order than
-   * was returned by {@code logMutation}, the result is implementation
-   * dependent.
-   * @param id id of mutation to be confirmed
-   * @param isValid if true, update persisted configuration with mutation
-   *                associated with {@code id}.
-   * @return true on success
-   * @throws IOException if mutation confirmation fails
+   * @param isValid if true, update persisted configuration with pending
+   *                mutation.
+   * @throws Exception if mutation confirmation fails
-  boolean confirmMutation(long id, boolean isValid) throws IOException;
+  public abstract void confirmMutation(boolean isValid) throws Exception;
-  Configuration retrieve();
-
-  /**
-   * Get the list of pending mutations, in the order they were logged.
-   * @return list of mutations
-   */
-  List<LogMutation> getPendingMutations();
+  public abstract Configuration retrieve();
-  List<LogMutation> getConfirmedConfHistory(long fromId);
+  public abstract List<LogMutation> getConfirmedConfHistory(long fromId);
+
+  /**
+   * Get schema version of persisted conf store, for detecting compatibility
+   * issues when changing conf store schema.
+   * @return Schema version currently used by the persisted configuration store.
+   * @throws Exception On version fetch failure
+   */
+  protected abstract Version getConfStoreVersion() throws Exception;
+
+  /**
+   * Persist the hard-coded schema version to the conf store.
+   * @throws Exception On storage failure
+   */
+  protected abstract void storeVersion() throws Exception;
+
+  /**
+   * Get the hard-coded schema version, for comparison against the schema
+   * version currently persisted.
+   * @return Current hard-coded schema version
+   */
+  protected abstract Version getCurrentVersion();
+
+  public void checkVersion() throws Exception {
+    // TODO this was taken from RMStateStore. Should probably refactor
+    Version loadedVersion = getConfStoreVersion();
+    LOG.info("Loaded configuration store version info " + loadedVersion);
+    if (loadedVersion != null && loadedVersion.equals(getCurrentVersion())) {
+      return;
+    }
+    // if there is no version info, treat it as CURRENT_VERSION_INFO;
+    if (loadedVersion == null) {
+      loadedVersion = getCurrentVersion();
+    }
+    if (loadedVersion.isCompatibleTo(getCurrentVersion())) {
+      LOG.info("Storing configuration store version info "
+          + getCurrentVersion());
+      storeVersion();
+    } else {
+      throw new RMStateVersionIncompatibleException(
+          "Expecting configuration store version " + getCurrentVersion()
+              + ", but loading version " + loadedVersion);
+    }
+  }
+

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS83 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS42 INS83 INS83 INS44 UPD43 INS83 INS83 UPD39 UPD43 INS29 INS83 INS83 INS39 INS42 MOV44 INS43 INS83 INS83 INS83 INS83 INS29 INS83 INS83 INS43 INS42 INS43 INS29 INS83 INS83 UPD39 MOV39 UPD42 MOV42 UPD43 MOV43 MOV29 INS83 INS83 INS43 INS42 INS83 INS39 INS42 INS43 INS8 INS42 INS42 INS32 INS65 INS43 INS42 UPD42 UPD42 INS65 INS65 UPD65 MOV65 INS42 INS65 INS65 INS65 INS42 INS42 UPD65 MOV65 MOV65 UPD42 UPD42 MOV42 UPD42 MOV42 INS60 INS21 INS25 INS25 INS25 INS42 INS42 INS57 UPD66 INS66 INS66 UPD66 INS42 INS66 INS42 UPD66 MOV66 MOV65 MOV66 UPD66 MOV66 MOV65 UPD66 MOV66 UPD66 MOV66 MOV66 INS42 UPD66 MOV66 UPD66 MOV66 UPD42 UPD66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS42 UPD66 MOV66 UPD66 UPD42 UPD66 UPD66 INS66 UPD66 INS43 INS59 INS32 INS27 INS8 INS27 INS8 INS32 INS8 INS8 INS43 UPD66 INS42 INS42 INS32 INS42 INS42 INS27 INS27 INS32 INS41 INS42 INS33 INS21 INS42 INS42 INS32 INS21 INS21 INS53 INS42 INS42 INS45 INS42 INS42 INS33 INS42 INS42 INS32 INS7 INS42 INS32 INS32 INS14 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS43 INS27 INS42 INS45 INS32 INS42 INS45 INS32 INS45 INS42 INS42 INS42 DEL42 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL34 DEL17 DEL8 DEL31 DEL42 DEL66 DEL65 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL66 DEL65 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL42 DEL65 DEL65 DEL29 DEL39 DEL42 DEL44 DEL31 DEL43 DEL43 DEL74 DEL42 DEL31
HADOOP-6890. Improve listFiles API introduced by HADOOP-6870. Contributed by Hairong Kuang.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@980953 13f79535-47bb-0310-9956-ffa450edef68

-
-  /**
-   * List the statuses and block locations of the files in the given path 
-   * if the path is a directory.
-   * If the given path is a file, return the file's status and block locations.
-   * if recursive is true, list all file statuses and block locations in
-   * the subtree rooted at the given path.
-   * Files across symbolic links are also returned.
-   * 
-   * @param f is the path
-   * @param recursive if the subdirectories need to be traversed recursively
-   *
-   * @return an iterator that traverses statuses of the files
-   *
-   * @throws AccessControlException If access is denied
-   * @throws FileNotFoundException If <code>f</code> does not exist
-   * @throws UnsupportedFileSystemException If file system for <code>f</code> is
-   *           not supported
-   * @throws IOException If an I/O error occurred
-   * 
-   * Exceptions applicable to file systems accessed over RPC:
-   * @throws RpcClientException If an exception occurred in the RPC client
-   * @throws RpcServerException If an exception occurred in the RPC server
-   * @throws UnexpectedServerException If server implementation throws 
-   *           undeclared exception to RPC server
-   */
-  public Iterator<LocatedFileStatus> listFiles(
-      final Path f, final boolean recursive) throws AccessControlException,
-      FileNotFoundException, UnsupportedFileSystemException, 
-      IOException {
-    return new Iterator<LocatedFileStatus>() {
-      private Stack<Path> dirs = new Stack<Path>();
-      private Stack<Path> symLinks = new Stack<Path>();
-      Iterator<LocatedFileStatus> itor = listLocatedStatus(f);
-      LocatedFileStatus curFile;
-
-      @Override
-      public boolean hasNext() {
-        try {
-          while (curFile == null) {
-            if (itor.hasNext()) {
-              handleFileStat(itor.next());
-            } else if (!dirs.isEmpty()) {
-              Path dirPath = dirs.pop(); 
-              itor = listLocatedStatus(dirPath);
-            } else if (!symLinks.isEmpty()) {
-              Path symLink = symLinks.pop();
-              FileStatus stat = getFileStatus(symLink);
-              if (stat.isFile() || (recursive && stat.isDirectory())) {
-                itor = listLocatedStatus(stat.getPath());
-              }
-            } else {
-              return false;
-            }
-          }
-          return true;
-        } catch (IOException ioe) {
-          throw (RuntimeException)new RuntimeException().initCause(ioe);
-        }
-      }
-
-      private void handleFileStat(LocatedFileStatus stat) throws IOException {
-        if (stat.isFile()) { // file
-          curFile = stat;
-        } else if (stat.isSymlink()) { // symbolic link
-          symLinks.push(stat.getSymlink());
-        } else if (recursive) { // directory
-          dirs.push(stat.getPath());
-        }
-      }
-
-      @Override
-      public LocatedFileStatus next() {
-        if (hasNext()) {
-          LocatedFileStatus result = curFile;
-          curFile = null;
-          return result;
-        } 
-        throw new java.util.NoSuchElementException("No more entry in " + f);
-      }
-
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException("Remove is not supported");
-
-      }
-    };
-  }
-   * a directory. Each returned status contains a file's block locations.
+   * a directory. 
+   * Return the file's status and block locations If the path is a file.
+   * 
+   * If a returned status is a file, it contains the file's block locations.
+   * If any IO exception (for example the input directory gets deleted while
+   * listing is being executed), next() or hasNext() of the returned iterator
+   * may throw a RuntimeException with the io exception as the cause.
+     * List the statuses and block locations of the files in the given path.
+     * 
+     * If the path is a directory, 
+     *   if recursive is false, returns files in the directory;
+     *   if recursive is true, return files in the subtree rooted at the path.
+     *   The subtree is traversed in the depth-first order.
+     * If the path is a file, return the file's status and block locations.
+     * Files across symbolic links are also returned.
+     * 
+     * @param f is the path
+     * @param recursive if the subdirectories need to be traversed recursively
+     *
+     * @return an iterator that traverses statuses of the files
+     * If any IO exception (for example a sub-directory gets deleted while
+     * listing is being executed), next() or hasNext() of the returned iterator
+     * may throw a RuntimeException with the IO exception as the cause.
+     *
+     * @throws AccessControlException If access is denied
+     * @throws FileNotFoundException If <code>f</code> does not exist
+     * @throws UnsupportedFileSystemException If file system for <code>f</code>
+     *         is not supported
+     * @throws IOException If an I/O error occurred
+     * 
+     * Exceptions applicable to file systems accessed over RPC:
+     * @throws RpcClientException If an exception occurred in the RPC client
+     * @throws RpcServerException If an exception occurred in the RPC server
+     * @throws UnexpectedServerException If server implementation throws 
+     *           undeclared exception to RPC server
+     */
+    public Iterator<LocatedFileStatus> listFiles(
+        final Path f, final boolean recursive) throws AccessControlException,
+        FileNotFoundException, UnsupportedFileSystemException, 
+        IOException {
+      return new Iterator<LocatedFileStatus>() {
+        private Stack<Iterator<LocatedFileStatus>> itors = 
+          new Stack<Iterator<LocatedFileStatus>>();
+        Iterator<LocatedFileStatus> curItor = listLocatedStatus(f);
+        LocatedFileStatus curFile;
+       
+        /**
+         *  {@inheritDoc}
+         *  @return {@inheritDog} 
+         *  @throws Runtimeexception if any IOException occurs during traversal;
+         *  the IOException is set as the cause of the RuntimeException
+         */
+        @Override
+        public boolean hasNext() {
+            while (curFile == null) {
+              if (curItor.hasNext()) {
+                handleFileStat(curItor.next());
+              } else if (!itors.empty()) {
+                curItor = itors.pop();
+              } else {
+                return false;
+              }
+            }
+            return true;
+        }
+
+        /**
+         * Process the input stat.
+         * If it is a file, return the file stat.
+         * If it is a directory, tranverse the directory if recursive is true;
+         * ignore it if recursive is false.
+         * If it is a symlink, resolve the symlink first and then process it
+         * depending on if it is a file or directory.
+         * @param stat input status
+         * @throws RuntimeException if any io error occurs; the io exception
+         * is set as the cause of RuntimeException
+         */
+        private void handleFileStat(LocatedFileStatus stat) {
+          try {
+            if (stat.isFile()) { // file
+              curFile = stat;
+            } else if (stat.isSymlink()) { // symbolic link
+              // resolve symbolic link
+              FileStatus symstat = FileContext.this.getFileStatus(
+                  stat.getSymlink());
+              if (symstat.isFile() || (recursive && symstat.isDirectory())) {
+                itors.push(curItor);
+                curItor = listLocatedStatus(stat.getPath());
+              }
+            } else if (recursive) { // directory
+              itors.push(curItor);
+              curItor = listLocatedStatus(stat.getPath());
+            }
+          } catch (IOException ioe) {
+            throw (RuntimeException)new RuntimeException().initCause(ioe);
+          }
+        }
+
+        /**
+         *  {@inheritDoc}
+         *  @return {@inheritDoc} 
+         *  @throws Runtimeexception if any IOException occurs during traversal;
+         *  the IOException is set as the cause of the RuntimeException
+         *  @exception {@inheritDoc}
+         */
+        @Override
+        public LocatedFileStatus next() {
+          if (hasNext()) {
+            LocatedFileStatus result = curFile;
+            curFile = null;
+            return result;
+          } 
+          throw new java.util.NoSuchElementException("No more entry in " + f);
+        }
+
+        @Override
+        public void remove() {
+          throw new UnsupportedOperationException("Remove is not supported");
+
+        }
+      };
+    }
+
+    /**

MOV31 INS66 INS66 UPD66 INS66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS66 INS66 UPD66 UPD66 INS31 INS31 UPD74 INS29 MOV78 MOV83 MOV39 MOV42 INS8 INS29 INS83 INS39 INS42 MOV44 INS8 INS29 MOV43 INS74 UPD42 UPD42 INS65 INS65 INS65 INS61 MOV41 INS65 INS65 INS65 INS54 INS65 INS65 INS65 INS65 UPD43 MOV43 UPD43 MOV43 UPD74 INS65 INS66 INS65 INS66 INS42 INS66 INS66 MOV27 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS8 MOV12 INS65 INS66 INS65 INS66 INS42 INS66 INS66 INS66 UPD42 UPD42 MOV43 INS74 INS25 INS25 UPD43 MOV43 UPD43 MOV43 MOV32 MOV8 INS25 MOV32 MOV8 INS25 UPD42 UPD42 UPD42 MOV38 MOV8 MOV8 MOV32 INS8 MOV25 MOV60 MOV25 UPD42 UPD42 INS21 INS21 UPD42 UPD42 UPD42 MOV32 INS21 INS32 INS7 UPD42 UPD42 INS52 UPD42 UPD42 INS32 UPD42 MOV42 MOV42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 INS42 MOV32 UPD42 DEL83 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL25 DEL25 DEL8 DEL61 DEL8 DEL54 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL21 DEL8 DEL25 DEL25 DEL8 DEL31
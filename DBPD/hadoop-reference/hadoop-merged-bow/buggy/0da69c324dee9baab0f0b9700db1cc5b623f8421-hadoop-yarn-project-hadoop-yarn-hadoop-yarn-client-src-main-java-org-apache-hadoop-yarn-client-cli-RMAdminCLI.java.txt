YARN-4676. Automatic and Asynchronous Decommissioning Nodes Status Tracking. Contributed by Diniel Zhi.
(cherry picked from commit d464483bf7f0b3e3be3ba32cd6c3eee546747ab5)

Conflicts:

	hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java
	hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNode.java
	hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java

-              new UsageInfo("[-g [timeout in seconds] -client|server]",
+              new UsageInfo("[-g|graceful [timeout in seconds] -client|server]",
-              + "[-g [timeout in seconds] -client|server] is optional, if we "
-              + "specify the timeout then ResourceManager will wait for "
+              + "[-g|graceful [timeout in seconds] -client|server] is optional,"
+              + " if we specify the timeout then ResourceManager will wait for "
-    "yarn rmadmin" +
-      " [-refreshQueues]" +
-      " [-refreshNodes [-g [timeout in seconds] -client|server]]" +
-      " [-refreshNodesResources]" +
-      " [-refreshSuperUserGroupsConfiguration]" +
-      " [-refreshUserToGroupsMappings]" +
-      " [-refreshAdminAcls]" +
-      " [-refreshServiceAcl]" +
-      " [-getGroup [username]]" +
-      " [-addToClusterNodeLabels <\"label1(exclusive=true),"
-                  + "label2(exclusive=false),label3\">]" +
-      " [-removeFromClusterNodeLabels <label1,label2,label3>]" +
-      " [-replaceLabelsOnNode <\"node1[:port]=label1,label2 node2[:port]=label1\">]" +
-      " [-directlyAccessNodeLabelStore]" +
-      " [-updateNodeResource [NodeID] [MemSize] [vCores] ([OvercommitTimeout])");
+        "yarn rmadmin" +
+        " [-refreshQueues]" +
+        " [-refreshNodes [-g|graceful [timeout in seconds] -client|server]]" +
+        " [-refreshNodesResources]" +
+        " [-refreshSuperUserGroupsConfiguration]" +
+        " [-refreshUserToGroupsMappings]" +
+        " [-refreshAdminAcls]" +
+        " [-refreshServiceAcl]" +
+        " [-getGroup [username]]" +
+        " [-addToClusterNodeLabels <\"label1(exclusive=true),"
+            + "label2(exclusive=false),label3\">]" +
+        " [-removeFromClusterNodeLabels <label1,label2,label3>]" +
+        " [-replaceLabelsOnNode <\"node1[:port]=label1,label2" +
+        " node2[:port]=label1\">]" +
+        " [-directlyAccessNodeLabelStore]" +
+        " [-updateNodeResource [NodeID] [MemSize] [vCores]" +
+        " ([OvercommitTimeout])");
-  private int refreshNodes() throws IOException, YarnException {
+  private int refreshNodes(boolean graceful) throws IOException, YarnException {
-    RefreshNodesRequest request = RefreshNodesRequest
-        .newInstance(DecommissionType.NORMAL);
+    RefreshNodesRequest request = RefreshNodesRequest.newInstance(
+        graceful? DecommissionType.GRACEFUL : DecommissionType.NORMAL);
-  private int refreshNodes(long timeout, String trackingMode)
+  private int refreshNodes(int timeout, String trackingMode)
-    if (!"client".equals(trackingMode)) {
-      throw new UnsupportedOperationException(
-          "Only client tracking mode is currently supported.");
-    }
+    boolean serverTracking = !"client".equals(trackingMode);
-        .newInstance(DecommissionType.GRACEFUL);
+        .newInstance(DecommissionType.GRACEFUL, timeout);
+    if (serverTracking) {
+      return 0;
+    }
+    // As RM enforces timeout automatically, client usually don't need
+    // to forcefully decommission nodes upon timeout.
+    // Here we let the client waits a small additional seconds so to avoid
+    // unnecessary double decommission.
+    final int gracePeriod = 5;
-    for (waitingTime = 0; waitingTime < timeout || timeout == -1; waitingTime++) {
+    for (waitingTime = 0;
+        timeout == -1 || (timeout >= 0 && waitingTime < timeout + gracePeriod);
+        waitingTime++) {
+  private int refreshNodes() throws IOException, YarnException {
+    return refreshNodes(false);
+  }
+
-    
+
-        if (args.length == 1) {
-          exitCode = refreshNodes();
-        } else if (args.length == 3 || args.length == 4) {
-          // if the graceful timeout specified
-          if ("-g".equals(args[1])) {
-            long timeout = -1;
-            String trackingMode;
-            if (args.length == 4) {
-              timeout = validateTimeout(args[2]);
-              trackingMode = validateTrackingMode(args[3]);
-            } else {
-              trackingMode = validateTrackingMode(args[2]);
-            }
-            exitCode = refreshNodes(timeout, trackingMode);
-          } else {
-            printUsage(cmd, isHAEnabled);
-            return -1;
-          }
-        } else {
-          printUsage(cmd, isHAEnabled);
-          return -1;
-        }
+        exitCode = handleRefreshNodes(args, cmd, isHAEnabled);
-        if (args.length < 4 || args.length > 5) {
-          System.err.println("Number of parameters specified for " +
-              "updateNodeResource is wrong.");
-          printUsage(cmd, isHAEnabled);
-          exitCode = -1;
-        } else {
-          String nodeID = args[i++];
-          String memSize = args[i++];
-          String cores = args[i++];
-          int overCommitTimeout = ResourceOption.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT;
-          if (i == args.length - 1) {
-            overCommitTimeout = Integer.parseInt(args[i]);
-          }
-          exitCode = updateNodeResource(nodeID, Integer.parseInt(memSize),
-              Integer.parseInt(cores), overCommitTimeout);
-        }
+        exitCode = handleUpdateNodeResource(args, cmd, isHAEnabled);
-  private long validateTimeout(String strTimeout) {
-    long timeout;
+  // A helper method to reduce the number of lines of run()
+  private int handleRefreshNodes(String[] args, String cmd, boolean isHAEnabled)
+      throws IOException, YarnException {
+    if (args.length == 1) {
+      return refreshNodes();
+    } else if (args.length == 3 || args.length == 4) {
+      // if the graceful timeout specified
+      if ("-g".equals(args[1]) || "-graceful".equals(args[1])) {
+        int timeout = -1;
+        String trackingMode;
+        if (args.length == 4) {
+          timeout = validateTimeout(args[2]);
+          trackingMode = validateTrackingMode(args[3]);
+        } else {
+          trackingMode = validateTrackingMode(args[2]);
+        }
+        return refreshNodes(timeout, trackingMode);
+      } else {
+        printUsage(cmd, isHAEnabled);
+        return -1;
+      }
+    } else {
+      printUsage(cmd, isHAEnabled);
+      return -1;
+    }
+  }
+
+  private int handleUpdateNodeResource(
+      String[] args, String cmd, boolean isHAEnabled)
+          throws NumberFormatException, IOException, YarnException {
+    int i = 1;
+    if (args.length < 4 || args.length > 5) {
+      System.err.println("Number of parameters specified for " +
+          "updateNodeResource is wrong.");
+      printUsage(cmd, isHAEnabled);
+      return -1;
+    } else {
+      String nodeID = args[i++];
+      String memSize = args[i++];
+      String cores = args[i++];
+      int overCommitTimeout = ResourceOption.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT;
+      if (i == args.length - 1) {
+        overCommitTimeout = Integer.parseInt(args[i]);
+      }
+      return updateNodeResource(nodeID, Integer.parseInt(memSize),
+          Integer.parseInt(cores), overCommitTimeout);
+    }
+  }
+
+  private int validateTimeout(String strTimeout) {
+    int timeout;
-      timeout = Long.parseLong(strTimeout);
+      timeout = Integer.parseInt(strTimeout);

INS31 INS31 INS31 INS44 INS83 INS39 INS42 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 MOV8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 INS43 MOV8 UPD39 INS39 INS42 UPD39 INS60 INS25 INS60 INS42 INS42 INS41 INS5 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS5 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS42 INS60 INS39 INS59 INS42 INS8 INS83 INS39 INS59 INS32 INS43 INS85 INS42 INS43 INS85 INS42 INS39 INS59 UPD39 INS42 MOV38 INS41 INS42 INS34 INS36 INS42 INS9 INS42 INS41 INS42 INS42 INS34 INS41 INS41 UPD45 UPD45 INS45 UPD45 INS45 INS16 INS42 INS34 INS27 MOV32 MOV38 MOV32 INS42 INS40 INS40 INS27 MOV27 INS8 INS27 INS42 INS34 INS27 INS21 MOV32 INS32 INS41 UPD42 UPD42 MOV42 INS42 INS7 INS45 INS42 INS2 UPD39 MOV32 INS42 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS8 INS21 INS7 UPD45 INS42 INS32 UPD45 UPD45 INS42 INS42 INS42 INS42 DEL40 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21
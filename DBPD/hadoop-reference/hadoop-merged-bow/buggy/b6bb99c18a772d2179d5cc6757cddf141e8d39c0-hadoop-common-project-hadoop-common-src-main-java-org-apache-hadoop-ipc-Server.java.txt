HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.

-        // Do not log WrappedRpcServerExceptionSuppressed.
-        if (!(e instanceof WrappedRpcServerExceptionSuppressed)) {
-          // A WrappedRpcServerException is an exception that has been sent
-          // to the client, so the stacktrace is unnecessary; any other
-          // exceptions are unexpected internal server errors and thus the
-          // stacktrace should be logged.
-          LOG.info(Thread.currentThread().getName() +
-              ": readAndProcess from client " + c.getHostAddress() +
-              " threw exception [" + e + "]",
-              (e instanceof WrappedRpcServerException) ? null : e);
-        }
+        // Any exceptions that reach here are fatal unexpected internal errors
+        // that could not be sent to the client.
+        LOG.info(Thread.currentThread().getName() +
+            ": readAndProcess from client " + c +
+            " threw exception [" + e + "]", e);
-      if (count < 0) {
+      // setupResponse will signal the connection should be closed when a
+      // fatal response is sent.
+      if (count < 0 || c.shouldClose()) {
-  private static class WrappedRpcServerException extends RpcServerException {
+  private static class FatalRpcServerException extends RpcServerException {
-    public WrappedRpcServerException(RpcErrorCodeProto errCode, IOException ioe) {
+    public FatalRpcServerException(RpcErrorCodeProto errCode, IOException ioe) {
-    public WrappedRpcServerException(RpcErrorCodeProto errCode, String message) {
+    public FatalRpcServerException(RpcErrorCodeProto errCode, String message) {
+    public RpcStatusProto getRpcStatusProto() {
+      return RpcStatusProto.FATAL;
+    }
+    @Override
-  /**
-   * A WrappedRpcServerException that is suppressed altogether
-   * for the purposes of logging.
-   */
-  @SuppressWarnings("serial")
-  private static class WrappedRpcServerExceptionSuppressed
-      extends WrappedRpcServerException {
-    public WrappedRpcServerExceptionSuppressed(
-        RpcErrorCodeProto errCode, IOException ioe) {
-      super(errCode, ioe);
-    }
-  }
-
-    
+    private boolean shouldClose = false;
+
-    
+
+    boolean setShouldClose() {
+      return shouldClose = true;
+    }
+
+    boolean shouldClose() {
+      return shouldClose;
+    }
+
-    WrappedRpcServerException, IOException, InterruptedException {
+        RpcServerException, IOException, InterruptedException {
-            throw new WrappedRpcServerException(
+            throw new FatalRpcServerException(
-     * @throws WrappedRpcServerException setup failed due to SASL negotiation 
+     * @throws RpcServerException setup failed due to SASL negotiation
-        throws WrappedRpcServerException, IOException, InterruptedException {
+        throws RpcServerException, IOException, InterruptedException {
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-      } catch (WrappedRpcServerException wrse) { // don't re-wrap
-        throw wrse;
+      } catch (RpcServerException rse) { // don't re-wrap
+        throw rse;
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-      saslCall.sendResponse();
+      sendResponse(saslCall);
-      authFailedCall.sendResponse();
+      sendResponse(authFailedCall);
-     * @throws WrappedRpcServerException - an exception that has already been 
-     *         sent back to the client that does not require verbose logging
-     *         by the Listener thread
-    public int readAndProcess()
-        throws WrappedRpcServerException, IOException, InterruptedException {
-      while (true) {
+    public int readAndProcess() throws IOException, InterruptedException {
+      while (!shouldClose()) { // stop if a fatal response has been sent.
+          ByteBuffer requestData = data;
+          data = null; // null out in case processOneRpc throws.
-          processOneRpc(data);
-          data = null;
+          processOneRpc(requestData);
+      return -1;
-        fakeCall.sendResponse();
+        sendResponse(fakeCall);
-        fakeCall.sendResponse();
+        sendResponse(fakeCall);
-        fakeCall.sendResponse();
+        sendResponse(fakeCall);
-      fakeCall.sendResponse();
+      sendResponse(fakeCall);
-     * @throws WrappedRpcServerException - if the header cannot be
+     * @throws RpcServerException - if the header cannot be
-        throws WrappedRpcServerException {
+        throws RpcServerException {
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-            throw new WrappedRpcServerException(
+            throw new FatalRpcServerException(
-     * @throws WrappedRpcServerException - an exception that has already been 
-     *         sent back to the client that does not require verbose logging
-     *         by the Listener thread
-        throws WrappedRpcServerException, IOException, InterruptedException {
+        throws IOException, InterruptedException {
-      while (true) {
+      while (!shouldClose()) { // stop if a fatal response has been sent.
-          processOneRpc(unwrappedData);
-          unwrappedData = null;
+          ByteBuffer requestData = unwrappedData;
+          unwrappedData = null; // null out in case processOneRpc throws.
+          processOneRpc(requestData);
-     * @throws WrappedRpcServerException - an exception that is sent back to the
-     *         client in this method and does not require verbose logging by the
-     *         Listener thread
-        throws IOException, WrappedRpcServerException, InterruptedException {
+        throws IOException, InterruptedException {
+      // exceptions that escape this method are fatal to the connection.
+      // setupResponse will use the rpc status to determine if the connection
+      // should be closed.
-          throw new WrappedRpcServerException(
+          throw new FatalRpcServerException(
-      } catch (WrappedRpcServerException wrse) { // inform client of error
-        Throwable ioe = wrse.getCause();
+      } catch (RpcServerException rse) {
+        // inform client of error, but do not rethrow else non-fatal
+        // exceptions will close connection!
+        if (LOG.isDebugEnabled()) {
+          LOG.debug(Thread.currentThread().getName() +
+              ": processOneRpc from client " + this +
+              " threw exception [" + rse + "]");
+        }
+        // use the wrapped exception if there is one.
+        Throwable t = (rse.getCause() != null) ? rse.getCause() : rse;
-            RpcStatusProto.FATAL, wrse.getRpcErrorCodeProto(), null,
-            ioe.getClass().getName(), ioe.getMessage());
-        call.sendResponse();
-        throw wrse;
+            rse.getRpcStatusProto(), rse.getRpcErrorCodeProto(), null,
+            t.getClass().getName(), t.getMessage());
+        sendResponse(call);
-     * @throws WrappedRpcServerException - header contains invalid values 
+     * @throws RpcServerException - header contains invalid values
-        throws WrappedRpcServerException {
+        throws RpcServerException {
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-     * @throws WrappedRpcServerException - due to fatal rpc layer issues such
-     *   as invalid header or deserialization error. In this case a RPC fatal
-     *   status response will later be sent back to client.
+     * @throws RpcServerException - generally due to fatal rpc layer issues
+     *   such as invalid header or deserialization error.  The call queue
+     *   may also throw a fatal or non-fatal exception on overflow.
+     * @throws IOException - fatal internal error that should/could not
+     *   be sent to client.
-        RpcWritable.Buffer buffer) throws WrappedRpcServerException,
+        RpcWritable.Buffer buffer) throws RpcServerException,
-        throw new WrappedRpcServerException(
-            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);   
+        throw new FatalRpcServerException(
+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER, err);
+      } catch (RpcServerException rse) { // lets tests inject failures.
+        throw rse;
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-     * @throws WrappedRpcServerException - setup failed due to SASL
+     * @throws RpcServerException - setup failed due to SASL
-        RpcWritable.Buffer buffer) throws WrappedRpcServerException,
+        RpcWritable.Buffer buffer) throws RpcServerException,
-          throw new WrappedRpcServerException(
+          throw new FatalRpcServerException(
-          throw new WrappedRpcServerException(
+          throw new FatalRpcServerException(
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-     * @throws WrappedRpcServerException - user is not allowed to proxy
+     * @throws RpcServerException - user is not allowed to proxy
-    private void authorizeConnection() throws WrappedRpcServerException {
+    private void authorizeConnection() throws RpcServerException {
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
-     * @throws WrappedRpcServerException - deserialization failed
+     * @throws RpcServerException - deserialization failed
-        RpcWritable.Buffer buffer) throws WrappedRpcServerException {
+        RpcWritable.Buffer buffer) throws RpcServerException {
-        throw new WrappedRpcServerException(
+        throw new FatalRpcServerException(
+    // ipc reader threads should invoke this directly, whereas handlers
+    // must invoke call.sendResponse to allow lifecycle management of
+    // external, postponed, deferred calls, etc.
+    // fatal responses will cause the reader to close the connection.
+    if (status == RpcStatusProto.FATAL) {
+      call.connection.setShouldClose();
+    }

UPD42 INS31 INS23 INS31 INS31 UPD42 UPD42 INS78 INS83 INS43 INS42 INS8 INS83 INS39 INS59 INS39 INS42 INS8 INS39 INS42 INS8 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 INS25 INS42 INS42 INS41 INS42 INS9 INS41 INS41 UPD42 UPD42 INS41 UPD42 UPD42 INS65 UPD42 UPD42 UPD42 UPD42 INS27 INS8 INS27 INS40 INS7 INS42 UPD42 UPD66 INS38 INS38 UPD42 INS38 UPD42 UPD66 UPD42 UPD66 UPD66 UPD66 INS42 INS66 INS66 INS12 UPD42 UPD42 UPD42 INS42 INS40 INS21 INS8 MOV27 INS32 INS42 INS9 UPD42 UPD42 INS42 INS32 INS34 INS42 INS32 INS44 INS8 INS32 MOV21 MOV21 INS42 INS42 UPD43 UPD42 INS42 MOV21 INS42 MOV21 UPD43 UPD42 INS25 INS43 INS42 INS53 INS40 INS42 UPD43 UPD42 UPD42 INS60 INS42 UPD43 INS60 UPD42 INS32 INS8 UPD43 UPD43 UPD43 UPD43 INS42 INS42 INS42 UPD42 UPD43 INS43 INS59 INS42 UPD42 INS43 INS59 INS42 INS42 INS21 INS42 INS16 INS32 INS42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 UPD43 UPD43 INS42 UPD43 UPD42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 INS32 INS36 INS32 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 UPD42 UPD42 UPD42 UPD43 INS42 INS42 INS27 INS27 UPD42 MOV42 MOV42 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 INS32 INS45 INS52 INS45 INS42 INS45 INS32 INS33 UPD42 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL62 DEL36 DEL33 DEL42 DEL16 DEL42 DEL42 DEL43 DEL62 DEL36 DEL38 DEL8 DEL25 DEL8 DEL66 DEL66 DEL65 DEL29 DEL42 DEL45 DEL79 DEL83 DEL83 DEL42 DEL42 DEL43 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL46 DEL8 DEL31 DEL55 DEL42 DEL42 DEL66 DEL66 DEL66 DEL65 DEL42 DEL43 DEL9 DEL42 DEL42 DEL42 DEL42 DEL42 DEL66 DEL66 DEL66 DEL65 DEL42 DEL43 DEL9 DEL42 DEL66 DEL66 DEL66 DEL65 DEL42 DEL43 DEL42 DEL32 DEL40 DEL42 DEL42 DEL53
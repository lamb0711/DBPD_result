HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.regex.Pattern;
-  static final boolean WINDOWS
+  public static final boolean WINDOWS
+  /**
+   *  Pre-compiled regular expressions to detect path formats.
+   */
+  private static final Pattern hasUriScheme =
+      Pattern.compile("^[a-zA-Z][a-zA-Z0-9+-.]+:");
+  private static final Pattern hasDriveLetterSpecifier =
+      Pattern.compile("^/?[a-zA-Z]:");
+
-  private void checkPathArg( String path ) {
+  private void checkPathArg( String path ) throws IllegalArgumentException {
-  public Path(String pathString) {
+  public Path(String pathString) throws IllegalArgumentException {
-    if (hasWindowsDrive(pathString, false))
-      pathString = "/"+pathString;
+    if (hasWindowsDrive(pathString) && pathString.charAt(0) != '/') {
+      pathString = "/" + pathString;
+    }
-      this.uri = new URI(scheme, authority, normalizePath(path), null, fragment)
+      this.uri = new URI(scheme, authority, normalizePath(scheme, path), null, fragment)
-  private String normalizePath(String path) {
-    // remove double slashes & backslashes
+  /**
+   * Merge 2 paths such that the second path is appended relative to the first.
+   * The returned path has the scheme and authority of the first path.  On
+   * Windows, the drive specification in the second path is discarded.
+   * 
+   * @param path1 Path first path
+   * @param path2 Path second path, to be appended relative to path1
+   * @return Path merged path
+   */
+  public static Path mergePaths(Path path1, Path path2) {
+    String path2Str = path2.toUri().getPath();
+    if(hasWindowsDrive(path2Str)) {
+      path2Str = path2Str.substring(path2Str.indexOf(':')+1);
+    }
+    return new Path(path1 + path2Str);
+  }
+
+  /**
+   * Normalize a path string to use non-duplicated forward slashes as
+   * the path separator and remove any trailing path separators.
+   * @param scheme Supplies the URI scheme. Used to deduce whether we
+   *               should replace backslashes or not.
+   * @param path Supplies the scheme-specific part
+   * @return Normalized path string.
+   */
+  private static String normalizePath(String scheme, String path) {
+    // Remove double forward slashes.
-    if (Path.WINDOWS) {
+
+    // Remove backslashes if this looks like a Windows path. Avoid
+    // the substitution if it looks like a non-local URI.
+    if (WINDOWS &&
+        (hasWindowsDrive(path) ||
+         (scheme == null) ||
+         (scheme.isEmpty()) ||
+         (scheme.equals("file")))) {
-    int minLength = hasWindowsDrive(path, true) ? 4 : 1;
+    int minLength = hasWindowsDrive(path) ? 4 : 1;
-  private boolean hasWindowsDrive(String path, boolean slashed) {
-    if (!WINDOWS) return false;
-    int start = slashed ? 1 : 0;
-    return
-      path.length() >= start+2 &&
-      (slashed ? path.charAt(0) == '/' : true) &&
-      path.charAt(start+1) == ':' &&
-      ((path.charAt(start) >= 'A' && path.charAt(start) <= 'Z') ||
-       (path.charAt(start) >= 'a' && path.charAt(start) <= 'z'));
+  private static boolean hasWindowsDrive(String path) {
+    return (WINDOWS && hasDriveLetterSpecifier.matcher(path).find());
+  /**
+   * Determine whether a given path string represents an absolute path on
+   * Windows. e.g. "C:/a/b" is an absolute path. "C:a/b" is not.
+   *
+   * @param pathString Supplies the path string to evaluate.
+   * @param slashed true if the given path is prefixed with "/".
+   * @return true if the supplied path looks like an absolute path with a Windows
+   * drive-specifier.
+   */
+  public static boolean isWindowsAbsolutePath(final String pathString,
+                                              final boolean slashed) {
+    int start = (slashed ? 1 : 0);
+
+    return
+        hasWindowsDrive(pathString) &&
+        pathString.length() >= (start + 3) &&
+        ((pathString.charAt(start + 2) == SEPARATOR_CHAR) ||
+          (pathString.charAt(start + 2) == '\\'));
+  }
-    int start = hasWindowsDrive(uri.getPath(), true) ? 3 : 0;
+    int start = hasWindowsDrive(uri.getPath()) ? 3 : 0;
-    int start = hasWindowsDrive(path, true) ? 3 : 0;
+    int start = hasWindowsDrive(path) ? 3 : 0;
-      int end = hasWindowsDrive(path, true) ? 3 : 0;
+      int end = hasWindowsDrive(path) ? 3 : 0;
-          hasWindowsDrive(path, true) &&          // has windows drive
+          hasWindowsDrive(path) &&                // has windows drive
-        normalizePath(pathUri.getPath()), null, fragment);
+        normalizePath(scheme, pathUri.getPath()), null, fragment);

INS26 INS40 INS23 INS23 INS31 INS31 INS31 INS83 INS29 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS43 INS43 INS29 INS83 INS83 INS43 INS42 MOV44 INS44 INS8 INS29 INS83 INS44 INS83 INS83 INS39 INS42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS65 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS60 INS25 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS83 INS43 INS42 INS83 INS39 INS42 MOV60 INS41 INS66 INS42 INS42 INS45 INS42 INS42 INS45 INS27 INS8 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS59 INS32 INS8 INS14 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS36 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS27 INS32 INS27 MOV21 INS42 INS42 INS32 INS42 INS42 INS21 INS43 INS27 INS42 INS36 MOV27 INS36 INS27 INS36 MOV42 MOV42 INS32 INS13 INS32 INS42 INS7 INS42 INS42 INS42 INS27 INS42 INS32 MOV16 INS32 MOV27 INS27 INS42 INS42 INS34 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS32 INS36 INS36 INS36 INS32 UPD42 MOV42 INS42 INS42 INS32 INS36 INS36 INS36 UPD42 MOV42 UPD42 MOV42 MOV27 INS42 INS42 INS27 INS32 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 UPD27 MOV27 INS27 INS32 INS42 INS33 INS42 INS42 INS42 INS42 INS45 INS42 INS34 INS42 MOV32 UPD13 MOV13 INS42 INS42 INS42 INS42 INS13 UPD42 UPD42 MOV27 UPD42 INS27 INS42 INS34 DEL9 DEL32 DEL39 DEL42 DEL42 DEL40 DEL9 DEL42 DEL32 DEL13 DEL27 DEL42 DEL32 DEL13 DEL27 DEL42 DEL32 DEL13 DEL42 DEL83 DEL39 DEL42 DEL42 DEL38 DEL9 DEL41 DEL25 DEL42 DEL34 DEL32 DEL13 DEL27 DEL9 DEL16 DEL36 DEL27 DEL32 DEL13 DEL27 DEL27 DEL36 DEL27 DEL27 DEL36 DEL27 DEL36 DEL27 DEL41 DEL8 DEL31 DEL9 DEL9 DEL9 DEL9
HDFS-7146. NFS ID/Group lookup requires SSSD enumeration on the server. Contributed by Yongjun Zhang

+ * 
+ * The maps are incrementally updated as described below:
+ *   1. Initialize the maps as empty. 
+ *   2. Incrementally update the maps
+ *      - When ShellBasedIdMapping is requested for user or group name given 
+ *        an ID, or for ID given a user or group name, do look up in the map
+ *        first, if it doesn't exist, find the corresponding entry with shell
+ *        command, and insert the entry to the maps.
+ *      - When group ID is requested for a given group name, and if the
+ *        group name is numerical, the full group map is loaded. Because we
+ *        don't have a good way to find the entry for a numerical group name,
+ *        loading the full map helps to get in all entries.
+ *   3. Periodically refresh the maps for both user and group, e.g,
+ *      do step 1.
+ *   Note: for testing purpose, step 1 may initial the maps with full mapping
+ *   when using constructor
+ *   {@link ShellBasedIdMapping#ShellBasedIdMapping(Configuration, boolean)}.
+  private StaticMapping staticMapping = null;
+  private boolean constructFullMapAtInit = false;
-  
+
+  /*
+   * Constructor
+   * @param conf the configuration
+   * @param constructFullMapAtInit initialize the maps with full mapping when
+   *        true, otherwise initialize the maps to empty. This parameter is
+   *        intended for testing only, its default is false.
+   */
+  @VisibleForTesting
-      final String defaultStaticIdMappingFile) throws IOException {
+      boolean constructFullMapAtInit) throws IOException {
+    this.constructFullMapAtInit = constructFullMapAtInit;
-    String staticFilePath = conf.get(IdMappingConstant.STATIC_ID_MAPPING_FILE_KEY,
-        defaultStaticIdMappingFile);
+    String staticFilePath = 
+        conf.get(IdMappingConstant.STATIC_ID_MAPPING_FILE_KEY,
+            IdMappingConstant.STATIC_ID_MAPPING_FILE_DEFAULT);
-    
+
+  /*
+   * Constructor
+   * initialize user and group maps to empty
+   * @param conf the configuration
+   */
-    this(conf, IdMappingConstant.STATIC_ID_MAPPING_FILE_DEFAULT);
+    this(conf, false);
-  
+
+  @VisibleForTesting
+  public BiMap<Integer, String> getUidNameMap() {
+    return uidNameMap;
+  }
+
+  @VisibleForTesting
+  public BiMap<Integer, String> getGidNameMap() {
+    return gidNameMap;
+  }
+
+  @VisibleForTesting  
+  synchronized public void clearNameMaps() {
+    uidNameMap.clear();
+    gidNameMap.clear();
+    lastUpdateTime = Time.monotonicNow();
+  }  
+
-   * Get the whole list of users and groups and save them in the maps.
+   * Get the list of users or groups returned by the specified command,
+   * and save them in the corresponding map.
-  public static void updateMapInternal(BiMap<Integer, String> map, String mapName,
-      String command, String regex, Map<Integer, Integer> staticMapping)
-      throws IOException  {
+  public static boolean updateMapInternal(BiMap<Integer, String> map,
+      String mapName, String command, String regex,
+      Map<Integer, Integer> staticMapping) throws IOException  {
+    boolean updated = false;
+        updated = true;
-      LOG.info("Updated " + mapName + " map size: " + map.size());
+      LOG.debug("Updated " + mapName + " map size: " + map.size());
+    return updated;
-  synchronized public void updateMaps() throws IOException {
-    BiMap<Integer, String> uMap = HashBiMap.create();
-    BiMap<Integer, String> gMap = HashBiMap.create();
-
+  private boolean checkSupportedPlatform() {
-      return;
+      return false;
-    
-    StaticMapping staticMapping = new StaticMapping(
+    return true;
+  }
+
+  private static boolean isInteger(final String s) {
+    try { 
+      Integer.parseInt(s); 
+    } catch(NumberFormatException e) { 
+      return false; 
+    }
+    // only got here if we didn't return false
+    return true;
+  }
+
+  private void initStaticMapping() throws IOException {
+    staticMapping = new StaticMapping(
+  }  
+  /*
+   * Reset the maps to empty.
+   * For testing code, a full map may be re-constructed here when the object
+   * was created with constructFullMapAtInit being set to true.
+   */
+  synchronized public void updateMaps() throws IOException {
+    if (!checkSupportedPlatform()) {
+      return;
+    }
+
+    if (constructFullMapAtInit) {
+      loadFullMaps();
+    } else {
+      clearNameMaps();
+    }
+  }
+  
+  synchronized private void loadFullUserMap() throws IOException {
+    if (staticMapping == null) {
+      initStaticMapping();
+    }
+    BiMap<Integer, String> uMap = HashBiMap.create();
-      updateMapInternal(gMap, "group", MAC_GET_ALL_GROUPS_CMD, "\\s+",
-          staticMapping.gidMapping);
+    }
+    uidNameMap = uMap;
+    lastUpdateTime = Time.monotonicNow();
+  }
+
+  synchronized private void loadFullGroupMap() throws IOException {
+    if (staticMapping == null) {
+      initStaticMapping();
+    }
+    BiMap<Integer, String> gMap = HashBiMap.create();
+
+    if (OS.startsWith("Mac")) {
+      updateMapInternal(gMap, "group", MAC_GET_ALL_GROUPS_CMD, "\\s+",
+          staticMapping.gidMapping);
+    } else {
-
-    uidNameMap = uMap;
+
+  synchronized private void loadFullMaps() throws IOException {
+    initStaticMapping();
+    loadFullUserMap();
+    loadFullGroupMap();
+  }
+
+  // search for id with given name, return "<name>:<id>"
+  // return
+  //     getent group <name> | cut -d: -f1,3
+  // OR
+  //     id -u <name> | awk '{print "<name>:"$1 }'
+  //
+  private String getName2IdCmdLinux(final String name, final boolean isGrp) {
+    String cmd;
+    if (isGrp) {
+      cmd = "getent group " + name + " | cut -d: -f1,3";   
+    } else {
+      cmd = "id -u " + name + " | awk '{print \"" + name + ":\"$1 }'";
+    }
+    return cmd;
+  }
+  // search for name with given id, return "<name>:<id>"
+  private String getId2NameCmdLinux(final int id, final boolean isGrp) {
+    String cmd = "getent ";
+    cmd += isGrp? "group " : "passwd ";
+    cmd += String.valueOf(id) + " | cut -d: -f1,3";
+    return cmd;
+  }
+
+  // "dscl . -read /Users/<name> | grep UniqueID" returns "UniqueId: <id>",
+  // "dscl . -read /Groups/<name> | grep PrimaryGroupID" returns "PrimaryGoupID: <id>"
+  // The following method returns a command that uses awk to process the result,
+  // of these commands, and returns "<name> <id>", to simulate one entry returned by 
+  // MAC_GET_ALL_USERS_CMD or MAC_GET_ALL_GROUPS_CMD.
+  // Specificially, this method returns:
+  // id -u <name> | awk '{print "<name>:"$1 }'
+  // OR
+  // dscl . -read /Groups/<name> | grep PrimaryGroupID | awk '($1 == "PrimaryGroupID:") { print "<name> " $2 }'
+  //
+  private String getName2IdCmdMac(final String name, final boolean isGrp) {
+    String cmd;
+    if (isGrp) {
+      cmd = "dscl . -read /Groups/" + name;
+      cmd += " | grep PrimaryGroupID | awk '($1 == \"PrimaryGroupID:\") ";
+      cmd += "{ print \"" + name + "  \" $2 }'";
+    } else {
+      cmd = "id -u " + name + " | awk '{print \"" + name + "  \"$1 }'";
+    }
+    return cmd;
+  }
+
+  // "dscl . -search /Users UniqueID <id>" returns 
+  //    <name> UniqueID = (
+  //      <id>
+  //    )
+  // "dscl . -search /Groups PrimaryGroupID <id>" returns
+  //    <name> PrimaryGroupID = (
+  //      <id>
+  //    )
+  // The following method returns a command that uses sed to process the
+  // the result and returns "<name> <id>" to simulate one entry returned
+  // by MAC_GET_ALL_USERS_CMD or MAC_GET_ALL_GROUPS_CMD.
+  // For certain negative id case like nfsnobody, the <id> is quoted as
+  // "<id>", added one sed section to remove the quote.
+  // Specifically, the method returns:
+  // dscl . -search /Users UniqueID <id> | sed 'N;s/\\n//g;N;s/\\n//g' | sed 's/UniqueID =//g' | sed 's/)//g' | sed 's/\"//g'
+  // OR
+  // dscl . -search /Groups PrimaryGroupID <id> | sed 'N;s/\\n//g;N;s/\\n//g' | sed 's/PrimaryGroupID =//g' | sed 's/)//g' | sed 's/\"//g'
+  //
+  private String getId2NameCmdMac(final int id, final boolean isGrp) {
+    String cmd = "dscl . -search /";
+    cmd += isGrp? "Groups PrimaryGroupID " : "Users UniqueID ";
+    cmd += String.valueOf(id);
+    cmd += " | sed 'N;s/\\n//g;N;s/\\n//g' | sed 's/";
+    cmd += isGrp? "PrimaryGroupID" : "UniqueID";
+    cmd += " = (//g' | sed 's/)//g' | sed 's/\\\"//g'";
+    return cmd;
+  }
+
+  synchronized private void updateMapIncr(final String name,
+      final boolean isGrp) throws IOException {
+    if (!checkSupportedPlatform()) {
+      return;
+    }
+    if (isInteger(name) && isGrp) {
+      loadFullGroupMap();
+      return;
+    }
+
+    boolean updated = false;
+    if (staticMapping == null) {
+      initStaticMapping();
+    }
+
+    if (OS.startsWith("Linux")) {
+      if (isGrp) {
+        updated = updateMapInternal(gidNameMap, "group",
+            getName2IdCmdLinux(name, true), ":",
+            staticMapping.gidMapping);
+      } else {
+        updated = updateMapInternal(uidNameMap, "user",
+            getName2IdCmdLinux(name, false), ":",
+            staticMapping.uidMapping);
+      }
+    } else {
+      // Mac
+      if (isGrp) {        
+        updated = updateMapInternal(gidNameMap, "group",
+            getName2IdCmdMac(name, true), "\\s+",
+            staticMapping.gidMapping);
+      } else {
+        updated = updateMapInternal(uidNameMap, "user",
+            getName2IdCmdMac(name, false), "\\s+",
+            staticMapping.uidMapping);
+      }
+    }
+    if (updated) {
+      lastUpdateTime = Time.monotonicNow();
+    }
+  }
+
+  synchronized private void updateMapIncr(final int id,
+      final boolean isGrp) throws IOException {
+    if (!checkSupportedPlatform()) {
+      return;
+    }
+    
+    boolean updated = false;
+    if (staticMapping == null) {
+      initStaticMapping();
+    }
+
+    if (OS.startsWith("Linux")) {
+      if (isGrp) {
+        updated = updateMapInternal(gidNameMap, "group",
+            getId2NameCmdLinux(id, true), ":",
+            staticMapping.gidMapping);
+      } else {
+        updated = updateMapInternal(uidNameMap, "user",
+            getId2NameCmdLinux(id, false), ":",
+            staticMapping.uidMapping);
+      }
+    } else {
+      // Mac
+      if (isGrp) {
+        updated = updateMapInternal(gidNameMap, "group",
+            getId2NameCmdMac(id, true), "\\s+",
+            staticMapping.gidMapping);
+      } else {
+        updated = updateMapInternal(uidNameMap, "user",
+            getId2NameCmdMac(id, false), "\\s+",
+            staticMapping.uidMapping);
+      }
+    }
+    if (updated) {
+      lastUpdateTime = Time.monotonicNow();
+    }
+  }
+
-      throw new IOException("User just deleted?:" + user);
+      updateMapIncr(user, false);
+      id = uidNameMap.inverse().get(user);
+      if (id == null) {
+        throw new IOException("User just deleted?:" + user);
+      }
-      throw new IOException("No such group:" + group);
-
+      updateMapIncr(group, true);
+      id = gidNameMap.inverse().get(group);
+      if (id == null) {
+        throw new IOException("No such group:" + group);
+      }
-      LOG.warn("Can't find user name for uid " + uid
-          + ". Use default user name " + unknown);
-      uname = unknown;
+      try {
+        updateMapIncr(uid, false);
+      } catch (Exception e) {        
+      }
+      uname = uidNameMap.get(uid);
+      if (uname == null) {     
+        LOG.warn("Can't find user name for uid " + uid
+            + ". Use default user name " + unknown);
+        uname = unknown;
+      }
-      LOG.warn("Can't find group name for gid " + gid
-          + ". Use default group name " + unknown);
-      gname = unknown;
+      try {
+        updateMapIncr(gid, true);
+      } catch (Exception e) {        
+      }
+      gname = gidNameMap.get(gid);
+      if (gname == null) {
+        LOG.warn("Can't find group name for gid " + gid
+            + ". Use default group name " + unknown);
+        gname = unknown;
+      }

INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 MOV43 INS59 INS83 INS39 INS59 INS78 INS44 INS78 INS83 INS74 INS42 INS8 INS78 INS83 INS74 INS42 INS8 INS78 MOV83 MOV83 MOV39 INS42 INS8 UPD39 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 MOV44 INS8 INS83 INS39 INS42 MOV43 INS8 INS83 INS83 INS39 MOV42 INS43 INS8 INS83 INS83 INS39 INS42 INS43 INS8 INS83 INS83 INS39 INS42 INS43 INS8 INS83 INS83 INS39 INS42 INS43 INS8 INS83 INS43 INS42 INS44 INS44 MOV8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS42 INS33 INS42 INS9 INS42 INS39 INS42 INS21 INS42 INS43 INS43 INS43 INS41 INS42 INS43 INS43 INS43 INS41 INS42 INS21 INS21 INS21 INS60 INS41 MOV25 INS41 UPD42 INS54 INS41 INS21 MOV25 INS42 INS25 INS25 INS42 INS25 MOV60 MOV25 MOV21 MOV21 INS42 INS25 MOV60 INS25 MOV21 INS21 INS42 INS21 INS21 INS21 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS25 INS41 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS60 INS21 INS21 INS41 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS60 INS25 INS41 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS60 INS21 INS21 INS21 INS21 INS21 INS41 INS83 INS43 INS42 INS83 INS39 INS42 INS42 INS25 INS25 INS60 INS25 INS25 INS25 INS83 INS39 INS42 INS83 INS39 INS42 INS42 INS25 INS60 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS68 INS7 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS7 UPD66 INS66 INS39 INS59 INS42 INS9 INS8 INS12 INS9 INS7 INS38 INS8 INS42 INS8 INS8 INS27 INS8 INS27 INS8 INS32 INS8 INS8 INS7 INS32 INS32 INS32 INS42 INS43 INS42 INS8 INS8 INS42 INS43 INS59 INS7 INS7 INS42 INS42 INS43 INS59 INS42 INS8 INS8 INS42 INS43 INS59 INS7 INS7 INS7 INS7 INS7 INS42 INS42 INS38 INS8 INS27 INS8 INS39 INS59 INS27 INS8 INS32 INS8 INS8 INS42 INS8 INS38 INS8 INS39 INS59 INS27 INS8 INS32 INS8 INS8 INS42 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS42 INS42 INS69 INS69 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS9 INS21 INS44 INS8 INS42 MOV14 INS32 INS41 INS21 INS21 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS42 INS45 MOV21 MOV21 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 INS21 INS21 INS42 INS42 INS45 INS42 INS16 INS42 INS27 INS42 INS42 INS21 INS21 INS21 INS21 INS42 INS42 INS45 INS42 INS16 INS42 INS32 INS42 INS45 INS42 INS16 INS42 INS45 INS32 INS41 INS32 INS42 INS21 INS41 INS42 INS9 INS42 INS33 INS21 INS42 INS42 INS45 INS25 INS25 INS21 INS32 INS41 INS42 INS9 INS42 INS33 INS21 INS42 INS42 INS45 INS25 INS25 INS21 INS42 INS33 INS21 INS21 MOV25 INS42 INS33 INS21 INS21 MOV25 INS42 INS33 INS54 INS21 MOV25 INS42 INS33 INS54 INS21 MOV25 INS43 INS39 INS52 INS42 INS40 INS42 INS42 INS9 INS32 INS43 INS42 INS41 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS7 INS7 INS42 INS45 INS45 INS32 INS45 INS7 INS7 INS7 INS7 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS32 INS32 INS42 INS8 INS8 INS42 INS8 INS8 INS7 INS42 INS32 INS42 INS8 INS8 INS42 INS8 INS8 INS7 INS32 INS7 INS32 INS7 INS8 INS12 INS7 INS8 INS12 INS7 INS42 INS21 UPD42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS27 INS42 INS42 INS42 INS42 INS27 INS42 INS45 INS42 INS27 INS42 INS27 INS42 INS42 INS21 INS21 INS21 INS21 INS42 INS32 INS42 INS21 INS21 INS21 INS21 INS42 INS32 INS42 INS42 INS9 INS42 INS32 INS42 INS42 INS9 INS42 INS32 INS21 INS44 INS8 INS42 INS32 INS21 INS44 INS8 INS42 INS32 INS7 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS7 INS7 INS7 INS7 INS42 INS42 INS7 INS7 INS7 INS7 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS45 INS32 INS45 INS40 INS42 INS42 INS45 INS32 INS45 INS40 INS42 INS42 INS45 INS32 INS45 INS40 INS42 INS42 INS45 INS32 INS45 INS40 INS42 INS42 INS45 INS32 INS45 INS40 INS42 INS42 INS45 INS32 INS45 INS40 INS42 INS42 INS45 INS32 INS45 INS40 INS42 INS42 INS45 INS32 INS45 INS40 INS42 INS42 INS9 INS42 INS42 INS9 INS42 INS42 INS9 INS42 INS42 INS9 INS42 INS42 INS9 INS42 INS42 INS9 INS42 INS42 INS9 INS42 INS42 INS9 DEL42 DEL40 DEL31
HADOOP-9698. [RPC v9] Client must honor server's SASL negotiate response (daryn)


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.List;
+import javax.security.auth.kerberos.KerberosPrincipal;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.security.token.TokenInfo;
+import org.apache.hadoop.security.token.TokenSelector;
-  private final AuthMethod authMethod;
-  private final SaslClient saslClient;
-  private final boolean fallbackAllowed;
+  private final UserGroupInformation ugi;
+  private final Class<?> protocol;
+  private final InetSocketAddress serverAddr;  
+  private final Configuration conf;
+
+  private SaslClient saslClient;
+  
-   * Create a SaslRpcClient for an authentication method
-   * 
-   * @param method
-   *          the requested authentication method
-   * @param token
-   *          token to use if needed by the authentication method
+   * Create a SaslRpcClient that can be used by a RPC client to negotiate
+   * SASL authentication with a RPC server
+   * @param ugi - connecting user
+   * @param protocol - RPC protocol
+   * @param serverAddr - InetSocketAddress of remote server
+   * @param conf - Configuration
-  public SaslRpcClient(AuthMethod method,
-      Token<? extends TokenIdentifier> token, String serverPrincipal,
-      boolean fallbackAllowed)
-      throws IOException {
-    this.authMethod = method;
-    this.fallbackAllowed = fallbackAllowed;
+  public SaslRpcClient(UserGroupInformation ugi, Class<?> protocol,
+      InetSocketAddress serverAddr, Configuration conf) {
+    this.ugi = ugi;
+    this.protocol = protocol;
+    this.serverAddr = serverAddr;
+    this.conf = conf;
+  }
+  
+  /**
+   * Instantiate a sasl client for the first supported auth type in the
+   * given list.  The auth type must be defined, enabled, and the user
+   * must possess the required credentials, else the next auth is tried.
+   * 
+   * @param authTypes to attempt in the given order
+   * @return SaslAuth of instantiated client
+   * @throws AccessControlException - client doesn't support any of the auths
+   * @throws IOException - misc errors
+   */
+  private SaslAuth selectSaslClient(List<SaslAuth> authTypes)
+      throws SaslException, AccessControlException, IOException {
+    SaslAuth selectedAuthType = null;
+    boolean switchToSimple = false;
+    for (SaslAuth authType : authTypes) {
+      if (!isValidAuthType(authType)) {
+        continue; // don't know what it is, try next
+      }
+      AuthMethod authMethod = AuthMethod.valueOf(authType.getMethod());
+      if (authMethod == AuthMethod.SIMPLE) {
+        switchToSimple = true;
+      } else {
+        saslClient = createSaslClient(authType);
+        if (saslClient == null) { // client lacks credentials, try next
+          continue;
+        }
+      }
+      selectedAuthType = authType;
+      break;
+    }
+    if (saslClient == null && !switchToSimple) {
+      List<String> serverAuthMethods = new ArrayList<String>();
+      for (SaslAuth authType : authTypes) {
+        serverAuthMethods.add(authType.getMethod());
+      }
+      throw new AccessControlException(
+          "Client cannot authenticate via:" + serverAuthMethods);
+    }
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Use " + selectedAuthType.getMethod() +
+          " authentication for protocol " + protocol.getSimpleName());
+    }
+    return selectedAuthType;
+  }
+  
+
+  private boolean isValidAuthType(SaslAuth authType) {
+    AuthMethod authMethod;
+    try {
+      authMethod = AuthMethod.valueOf(authType.getMethod());
+    } catch (IllegalArgumentException iae) { // unknown auth
+      authMethod = null;
+    }
+    // do we know what it is?  is it using our mechanism?
+    return authMethod != null &&
+           authMethod.getMechanismName().equals(authType.getMechanism());
+  }  
+  
+  /**
+   * Try to create a SaslClient for an authentication type.  May return
+   * null if the type isn't supported or the client lacks the required
+   * credentials.
+   * 
+   * @param authType - the requested authentication method
+   * @return SaslClient for the authType or null
+   * @throws SaslException - error instantiating client
+   * @throws IOException - misc errors
+   */
+  private SaslClient createSaslClient(SaslAuth authType)
+      throws SaslException, IOException {
-    String saslProtocol = null;
-    String saslServerName = null;
+    // SASL requires the client and server to use the same proto and serverId
+    // if necessary, auth types below will verify they are valid
+    final String saslProtocol = authType.getProtocol();
+    final String saslServerName = authType.getServerId();
+    final AuthMethod method = AuthMethod.valueOf(authType.getMethod());
-        saslProtocol = "";
-        saslServerName = SaslRpcServer.SASL_DEFAULT_REALM;
+        Token<?> token = getServerToken(authType);
+        if (token == null) {
+          return null; // tokens aren't supported or user doesn't have one
+        }
-        if (serverPrincipal == null || serverPrincipal.isEmpty()) {
-          throw new IOException(
-              "Failed to specify server's Kerberos principal name");
+        if (ugi.getRealAuthenticationMethod().getAuthMethod() !=
+            AuthMethod.KERBEROS) {
+          return null; // client isn't using kerberos
-        KerberosName name = new KerberosName(serverPrincipal);
-        saslProtocol = name.getServiceName();
-        saslServerName = name.getHostName();
-        if (saslServerName == null) {
-          throw new IOException(
-              "Kerberos principal name does NOT have the expected hostname part: "
-                  + serverPrincipal);
+        String serverPrincipal = getServerPrincipal(authType);
+        if (serverPrincipal == null) {
+          return null; // protocol doesn't use kerberos
+        }
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("RPC Server's Kerberos principal name for protocol="
+              + protocol.getCanonicalName() + " is " + serverPrincipal);
-      LOG.debug("Creating SASL " + mechanism + "(" + authMethod + ") "
+      LOG.debug("Creating SASL " + mechanism + "(" + method + ") "
-    saslClient = Sasl.createSaslClient(
+    return Sasl.createSaslClient(
-    if (saslClient == null) {
-      throw new IOException("Unable to find SASL client implementation");
-    }
+  
+  /**
+   * Try to locate the required token for the server.
+   * 
+   * @param authType of the SASL client
+   * @return Token<?> for server, or null if no token available
+   * @throws IOException - token selector cannot be instantiated
+   */
+  private Token<?> getServerToken(SaslAuth authType) throws IOException {
+    TokenInfo tokenInfo = SecurityUtil.getTokenInfo(protocol, conf);
+    LOG.debug("Get token info proto:"+protocol+" info:"+tokenInfo);
+    if (tokenInfo == null) { // protocol has no support for tokens
+      return null;
+    }
+    TokenSelector<?> tokenSelector = null;
+    try {
+      tokenSelector = tokenInfo.value().newInstance();
+    } catch (InstantiationException e) {
+      throw new IOException(e.toString());
+    } catch (IllegalAccessException e) {
+      throw new IOException(e.toString());
+    }
+    return tokenSelector.selectToken(
+        SecurityUtil.buildTokenService(serverAddr), ugi.getTokens());
+  }
+  
+  /**
+   * Get the remote server's principal.  The value will be obtained from
+   * the config and cross-checked against the server's advertised principal.
+   * 
+   * @param authType of the SASL client
+   * @return String of the server's principal
+   * @throws IOException - error determining configured principal
+   */
+
+  // try to get the configured principal for the remote server
+  private String getServerPrincipal(SaslAuth authType) throws IOException {
+    KerberosInfo krbInfo = SecurityUtil.getKerberosInfo(protocol, conf);
+    LOG.debug("Get kerberos info proto:"+protocol+" info:"+krbInfo);
+    if (krbInfo == null) { // protocol has no support for kerberos
+      return null;
+    }
+    String serverKey = krbInfo.serverPrincipal();
+    if (serverKey == null) {
+      throw new IllegalArgumentException(
+          "Can't obtain server Kerberos config key from protocol="
+              + protocol.getCanonicalName());
+    }
+    // construct the expected principal from the config
+    String confPrincipal = SecurityUtil.getServerPrincipal(
+        conf.get(serverKey), serverAddr.getAddress());
+    if (confPrincipal == null || confPrincipal.isEmpty()) {
+      throw new IllegalArgumentException(
+          "Failed to specify server's Kerberos principal name");
+    }
+    // ensure it looks like a host-based service principal
+    KerberosName name = new KerberosName(confPrincipal);
+    if (name.getHostName() == null) {
+      throw new IllegalArgumentException(
+          "Kerberos principal name does NOT have the expected hostname part: "
+              + confPrincipal);
+    }
+    // check that the server advertised principal matches our conf
+    KerberosPrincipal serverPrincipal = new KerberosPrincipal(
+        authType.getProtocol() + "/" + authType.getServerId());
+    if (!serverPrincipal.getName().equals(confPrincipal)) {
+      throw new IllegalArgumentException(
+          "Server has invalid Kerberos principal: " + serverPrincipal);
+    }
+    return confPrincipal;
+  }
+  
-   * @return true if connection is set up, or false if needs to switch 
-   *             to simple Auth.
+   * @return AuthMethod used to negotiate the connection
-  public boolean saslConnect(InputStream inS, OutputStream outS)
+  public AuthMethod saslConnect(InputStream inS, OutputStream outS)
-    // track if SASL ever started, or server switched us to simple
-    boolean inSasl = false;
+    // redefined if/when a SASL negotiation completes
+    AuthMethod authMethod = AuthMethod.SIMPLE;
+    
-          inSasl = true;
-          // TODO: should instantiate sasl client based on advertisement
-          // but just blindly use the pre-instantiated sasl client for now
-          String clientAuthMethod = authMethod.toString();
-          SaslAuth saslAuthType = null;
-          for (SaslAuth authType : saslMessage.getAuthsList()) {
-            if (clientAuthMethod.equals(authType.getMethod())) {
-              saslAuthType = authType;
-              break;
+          // create a compatible SASL client, throws if no supported auths
+          SaslAuth saslAuthType = selectSaslClient(saslMessage.getAuthsList());
+          authMethod = AuthMethod.valueOf(saslAuthType.getMethod());
+          
+          byte[] responseToken = null;
+          if (authMethod == AuthMethod.SIMPLE) { // switching to SIMPLE
+            done = true; // not going to wait for success ack
+          } else {
+            byte[] challengeToken = null;
+            if (saslAuthType.hasChallenge()) {
+              // server provided the first challenge
+              challengeToken = saslAuthType.getChallenge().toByteArray();
+              saslAuthType =
+                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();
+            } else if (saslClient.hasInitialResponse()) {
+              challengeToken = new byte[0];
+            responseToken = (challengeToken != null)
+                ? saslClient.evaluateChallenge(challengeToken)
+                    : new byte[0];
-          if (saslAuthType == null) {
-            saslAuthType = SaslAuth.newBuilder()
-                .setMethod(clientAuthMethod)
-                .setMechanism(saslClient.getMechanismName())
-                .build();
-          }
-          
-          byte[] challengeToken = null;
-          if (saslAuthType != null && saslAuthType.hasChallenge()) {
-            // server provided the first challenge
-            challengeToken = saslAuthType.getChallenge().toByteArray();
-            saslAuthType =
-              SaslAuth.newBuilder(saslAuthType).clearChallenge().build();
-          } else if (saslClient.hasInitialResponse()) {
-            challengeToken = new byte[0];
-          }
-          byte[] responseToken = (challengeToken != null)
-              ? saslClient.evaluateChallenge(challengeToken)
-              : new byte[0];
-          
-          inSasl = true;
+          if (saslClient == null) {
+            // should probably instantiate a client to allow a server to
+            // demand a specific negotiation
+            throw new SaslException("Server sent unsolicited challenge");
+          }
-          if (inSasl && saslEvaluateToken(saslMessage, true) != null) {
-            throw new SaslException("SASL client generated spurious token");
+          // simple server sends immediate success to a SASL client for
+          // switch to simple
+          if (saslClient == null) {
+            authMethod = AuthMethod.SIMPLE;
+          } else {
+            saslEvaluateToken(saslMessage, true);
-    if (!inSasl && !fallbackAllowed) {
-      throw new IOException("Server asks us to fall back to SIMPLE " +
-          "auth, but this client is configured to only allow secure " +
-          "connections.");
-    }
-    return inSasl;
+    return authMethod;
+  /**
+   * Evaluate the server provided challenge.  The server must send a token
+   * if it's not done.  If the server is done, the challenge token is
+   * optional because not all mechanisms send a final token for the client to
+   * update its internal state.  The client must also be done after
+   * evaluating the optional token to ensure a malicious server doesn't
+   * prematurely end the negotiation with a phony success.
+   *  
+   * @param saslResponse - client response to challenge
+   * @param serverIsDone - server negotiation state
+   * @throws SaslException - any problems with negotiation
+   */
-      boolean done) throws SaslException {
+      boolean serverIsDone) throws SaslException {
-    } else if (!done) {
-      throw new SaslException("Challenge contains no token");
+    } else if (!serverIsDone) {
+      // the server may only omit a token when it's done
+      throw new SaslException("Server challenge contains no token");
-    if (done && !saslClient.isComplete()) {
-      throw new SaslException("Client is out of sync with server");
+    if (serverIsDone) {
+      // server tried to report success before our client completed
+      if (!saslClient.isComplete()) {
+        throw new SaslException("Client is out of sync with server");
+      }
+      // a client cannot generate a response to a success message
+      if (saslToken != null) {
+        throw new SaslException("Client generated spurious response");        
+      }
-    saslClient.dispose();
+    if (saslClient != null) {
+      saslClient.dispose();
+      saslClient = null;
+    }
-}
+}

INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS43 INS59 INS74 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 MOV29 MOV83 MOV42 MOV44 MOV44 MOV44 MOV44 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS43 MOV43 INS8 INS29 INS83 INS74 INS42 INS44 MOV43 INS8 INS29 INS83 MOV43 INS42 INS44 MOV43 INS8 INS43 INS29 INS8 INS42 INS42 INS43 INS76 UPD42 INS42 INS42 INS42 INS42 INS65 INS65 INS43 INS42 INS74 INS42 INS43 UPD42 INS43 INS42 MOV21 MOV21 INS21 INS21 INS65 INS65 INS65 INS65 INS65 INS42 INS74 INS42 INS42 INS42 INS42 MOV60 MOV60 INS70 MOV25 INS25 INS41 INS43 INS42 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 MOV60 INS60 INS60 MOV60 MOV60 INS60 INS50 MOV60 MOV25 INS41 INS65 INS65 INS65 INS65 INS43 INS76 INS43 INS42 INS60 INS21 INS25 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS60 INS21 MOV25 INS60 INS25 INS60 INS25 MOV60 INS25 INS60 INS25 INS41 INS42 INS65 INS65 INS65 INS65 UPD42 INS25 INS25 INS42 UPD66 INS66 INS42 INS66 INS42 INS66 UPD42 UPD66 UPD42 UPD66 INS42 INS43 INS76 INS42 INS42 INS7 INS7 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS43 INS43 MOV43 INS39 INS44 INS42 INS8 INS27 INS8 MOV32 INS8 INS42 INS42 MOV43 MOV59 INS8 INS12 INS27 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS42 MOV49 INS8 MOV49 INS8 MOV49 MOV53 INS32 MOV32 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS43 INS59 INS32 INS27 INS8 INS74 INS59 INS8 INS12 INS12 INS32 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS43 INS59 INS32 INS27 INS8 MOV43 INS59 INS27 INS8 MOV43 INS59 INS27 INS8 MOV43 INS27 INS8 INS43 INS59 INS38 INS8 INS42 UPD66 INS43 UPD42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 MOV25 INS42 INS8 INS27 MOV8 INS42 UPD42 UPD42 INS22 INS42 INS22 INS42 INS42 INS42 UPD42 UPD42 INS9 INS43 INS42 INS25 INS60 INS25 MOV21 MOV10 MOV27 INS38 INS60 INS70 MOV53 INS21 MOV21 INS44 INS8 INS27 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 MOV32 INS60 INS25 MOV21 INS10 INS25 INS60 INS25 INS25 MOV10 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS33 INS41 INS43 INS76 INS42 INS33 MOV21 INS44 MOV8 INS44 INS8 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS33 INS41 INS42 INS32 INS42 INS33 INS53 INS42 INS32 INS27 INS32 INS53 MOV32 INS33 INS53 INS42 INS42 INS14 INS32 INS53 INS42 UPD42 INS40 INS38 MOV25 INS25 INS42 INS33 INS21 UPD42 UPD42 INS52 INS42 INS52 INS42 INS42 INS38 INS8 MOV43 INS59 INS27 INS8 INS8 INS42 INS74 INS59 MOV44 INS42 INS8 INS32 INS43 INS42 MOV21 INS42 INS33 INS32 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD74 MOV74 INS59 MOV27 INS8 INS27 INS8 MOV43 INS59 MOV27 INS8 INS32 MOV8 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS33 INS42 INS43 INS42 INS43 INS42 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS33 INS42 INS42 INS14 INS42 INS42 INS32 INS32 INS42 INS33 INS42 INS42 INS14 MOV43 UPD42 INS14 INS43 INS27 INS32 INS42 INS42 INS14 INS42 MOV38 INS27 INS8 INS7 INS32 INS18 INS42 INS32 INS42 INS40 INS21 MOV21 INS25 UPD42 INS42 INS43 INS43 INS42 INS14 INS21 INS43 INS27 INS42 INS42 INS27 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 UPD76 INS42 INS32 UPD42 INS41 INS32 INS40 INS41 INS42 INS32 INS41 INS42 INS42 INS21 UPD42 INS32 INS42 INS42 INS14 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS43 INS45 INS43 INS27 INS42 INS32 INS45 INS32 INS42 INS42 INS43 INS27 INS60 MOV21 INS60 INS25 INS25 INS25 INS42 INS33 INS53 INS42 INS33 INS42 INS42 INS42 INS42 INS32 INS7 INS27 INS8 INS42 INS42 INS74 INS32 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS32 UPD42 INS33 INS42 INS42 INS33 INS32 INS42 INS33 INS42 INS42 INS33 INS32 UPD42 INS32 INS42 INS32 MOV43 INS32 INS42 INS45 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS43 MOV59 MOV5 INS59 MOV27 MOV8 INS8 INS27 INS8 INS27 INS8 INS8 UPD45 INS14 INS42 INS42 INS42 INS9 UPD42 INS32 INS42 INS33 INS18 INS43 INS43 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS32 INS42 INS33 UPD42 INS40 MOV60 MOV25 INS21 INS42 INS33 INS53 INS42 INS33 INS21 INS21 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 MOV45 INS32 INS45 MOV42 UPD42 MOV32 INS42 INS42 INS32 MOV32 INS7 INS14 INS7 MOV32 INS42 INS42 INS42 INS42 INS42 UPD42 INS9 INS42 MOV16 MOV43 INS45 INS42 INS40 DEL39 DEL83 DEL42 DEL42 DEL39 DEL42 DEL33 DEL45 DEL40 DEL45 DEL32 DEL27 DEL8 DEL32 DEL42 DEL43 DEL27 DEL14 DEL53 DEL45 DEL42 DEL8 DEL25 DEL8 DEL50 DEL8 DEL31 DEL66 DEL39 DEL39 DEL9 DEL42 DEL42 DEL42 DEL33 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL33 DEL27 DEL27 DEL42 DEL9 DEL7 DEL21 DEL60 DEL42 DEL33 DEL59 DEL60 DEL10 DEL8 DEL25 DEL8 DEL70 DEL25 DEL42 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL38 DEL42 DEL38 DEL27 DEL45 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL33 DEL27 DEL27 DEL42 DEL38 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL27
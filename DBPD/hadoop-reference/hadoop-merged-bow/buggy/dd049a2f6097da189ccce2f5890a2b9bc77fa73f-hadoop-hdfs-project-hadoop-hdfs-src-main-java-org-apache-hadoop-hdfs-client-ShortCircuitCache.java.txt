HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import org.apache.commons.lang.mutable.MutableBoolean;
+import org.apache.hadoop.hdfs.ShortCircuitShm.Slot;
+import org.apache.hadoop.hdfs.net.DomainPeer;
+import org.apache.hadoop.hdfs.protocol.DatanodeInfo;
+import org.apache.hadoop.hdfs.protocol.datatransfer.Sender;
+import org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.ReleaseShortCircuitAccessResponseProto;
+import org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.Status;
+import org.apache.hadoop.hdfs.protocolPB.PBHelper;
+import org.apache.hadoop.net.unix.DomainSocket;
+  /**
+   * A task which asks the DataNode to release a short-circuit shared memory
+   * slot.  If successful, this will tell the DataNode to stop monitoring
+   * changes to the mlock status of the replica associated with the slot.
+   * It will also allow us (the client) to re-use this slot for another
+   * replica.  If we can't communicate with the DataNode for some reason,
+   * we tear down the shared memory segment to avoid being in an inconsistent
+   * state.
+   */
+  private class SlotReleaser implements Runnable {
+    /**
+     * The slot that we need to release.
+     */
+    private final Slot slot;
+
+    SlotReleaser(Slot slot) {
+      this.slot = slot;
+    }
+
+    @Override
+    public void run() {
+      if (LOG.isTraceEnabled()) {
+        LOG.trace(ShortCircuitCache.this + ": about to release " + slot);
+      }
+      final DfsClientShm shm = (DfsClientShm)slot.getShm();
+      final DomainSocket shmSock = shm.getPeer().getDomainSocket();
+      DomainSocket sock = null;
+      DataOutputStream out = null;
+      final String path = shmSock.getPath();
+      boolean success = false;
+      try {
+        sock = DomainSocket.connect(path);
+        out = new DataOutputStream(
+            new BufferedOutputStream(sock.getOutputStream()));
+        new Sender(out).releaseShortCircuitFds(slot.getSlotId());
+        DataInputStream in = new DataInputStream(sock.getInputStream());
+        ReleaseShortCircuitAccessResponseProto resp =
+            ReleaseShortCircuitAccessResponseProto.parseFrom(
+                PBHelper.vintPrefixed(in));
+        if (resp.getStatus() != Status.SUCCESS) {
+          String error = resp.hasError() ? resp.getError() : "(unknown)";
+          throw new IOException(resp.getStatus().toString() + ": " + error);
+        }
+        if (LOG.isTraceEnabled()) {
+          LOG.trace(ShortCircuitCache.this + ": released " + slot);
+        }
+        success = true;
+      } catch (IOException e) {
+        LOG.error(ShortCircuitCache.this + ": failed to release " +
+            "short-circuit shared memory slot " + slot + " by sending " +
+            "ReleaseShortCircuitAccessRequestProto to " + path +
+            ".  Closing shared memory segment.", e);
+      } finally {
+        if (success) {
+          shmManager.freeSlot(slot);
+        } else {
+          shm.getEndpointShmManager().shutdown(shm);
+        }
+        IOUtils.cleanup(LOG, sock, out);
+      }
+    }
+  }
+
-  private final ScheduledThreadPoolExecutor executor
+  private final ScheduledThreadPoolExecutor cleanerExecutor
+  = new ScheduledThreadPoolExecutor(1, new ThreadFactoryBuilder().
+          setDaemon(true).setNameFormat("ShortCircuitCache_Cleaner").
+          build());
+
+  /**
+   * The executor service that runs the cacheCleaner.
+   */
+  private final ScheduledThreadPoolExecutor releaserExecutor
-          setDaemon(true).setNameFormat("ShortCircuitCache Cleaner").
+          setDaemon(true).setNameFormat("ShortCircuitCache_SlotReleaser").
+   * Manages short-circuit shared memory segments for the client.
+   */
+  private final DfsClientShmManager shmManager;
+
+  /**
-            DFSConfigKeys.DFS_CLIENT_SHORT_CIRCUIT_REPLICA_STALE_THRESHOLD_MS_DEFAULT));
+            DFSConfigKeys.DFS_CLIENT_SHORT_CIRCUIT_REPLICA_STALE_THRESHOLD_MS_DEFAULT),
+        conf.getInt(DFSConfigKeys.DFS_SHORT_CIRCUIT_SHARED_MEMORY_WATCHER_INTERRUPT_CHECK_MS,
+            DFSConfigKeys.DFS_SHORT_CIRCUIT_SHARED_MEMORY_WATCHER_INTERRUPT_CHECK_MS_DEFAULT));
-      long mmapRetryTimeoutMs, long staleThresholdMs) {
+      long mmapRetryTimeoutMs, long staleThresholdMs, int shmInterruptCheckMs) {
+    DfsClientShmManager shmManager = null;
+    if (shmInterruptCheckMs > 0) {
+      try {
+        shmManager = new DfsClientShmManager(shmInterruptCheckMs);
+      } catch (IOException e) {
+        LOG.error("failed to create ShortCircuitShmManager", e);
+      }
+    }
+    this.shmManager = shmManager;
+      // If the replica is stale, but we haven't purged it yet, let's do that.
+      // It would be a shame to evict a non-stale replica so that we could put
+      // a stale one into the cache.
+      if ((!replica.purged) && replica.isStale()) {
+        purge(replica);
+      }
+      boolean shouldTrimEvictionMaps = false;
-          trimEvictionMaps();
+          shouldTrimEvictionMaps = true;
+      if (shouldTrimEvictionMaps) {
+        trimEvictionMaps();
+      }
-        LOG.trace(this + ": trimEvictionMaps is purging " +
+        LOG.trace(this + ": trimEvictionMaps is purging " + replica +
-      builder.append(this).append(": ").append(": removed ").
+      builder.append(this).append(": ").append(": purged ").
-          executor.scheduleAtFixedRate(cacheCleaner, rateMs, rateMs,
+          cleanerExecutor.scheduleAtFixedRate(cacheCleaner, rateMs, rateMs,
-  ClientMmap getOrCreateClientMmap(ShortCircuitReplica replica) {
+  ClientMmap getOrCreateClientMmap(ShortCircuitReplica replica,
+      boolean anchored) {
-        if (replica.mmapData instanceof ClientMmap) {
+        if (replica.mmapData instanceof MappedByteBuffer) {
-          ClientMmap clientMmap = (ClientMmap)replica.mmapData;
-          clientMmap.ref();
-          return clientMmap;
+          MappedByteBuffer mmap = (MappedByteBuffer)replica.mmapData;
+          return new ClientMmap(replica, mmap, anchored);
-        ClientMmap clientMmap = new ClientMmap(replica, map);
-        replica.mmapData = clientMmap;
+        replica.mmapData = map;
-        return clientMmap;
+        return new ClientMmap(replica, map, anchored);
+
+  /**
+   * Allocate a new shared memory slot.
+   *
+   * @param datanode       The datanode to allocate a shm slot with.
+   * @param peer           A peer connected to the datanode.
+   * @param usedPeer       Will be set to true if we use up the provided peer.
+   * @param blockId        The block id and block pool id of the block we're 
+   *                         allocating this slot for.
+   * @param clientName     The name of the DFSClient allocating the shared
+   *                         memory.
+   * @return               Null if short-circuit shared memory is disabled;
+   *                         a short-circuit memory slot otherwise.
+   * @throws IOException   An exception if there was an error talking to 
+   *                         the datanode.
+   */
+  public Slot allocShmSlot(DatanodeInfo datanode,
+        DomainPeer peer, MutableBoolean usedPeer,
+        ExtendedBlockId blockId, String clientName) throws IOException {
+    if (shmManager != null) {
+      return shmManager.allocSlot(datanode, peer, usedPeer,
+          blockId, clientName);
+    } else {
+      return null;
+    }
+  }
+
+  /**
+   * Free a slot immediately.
+   *
+   * ONLY use this if the DataNode is not yet aware of the slot.
+   * 
+   * @param slot           The slot to free.
+   */
+  public void freeSlot(Slot slot) {
+    Preconditions.checkState(shmManager != null);
+    slot.makeInvalid();
+    shmManager.freeSlot(slot);
+  }
+  
+  /**
+   * Schedule a shared memory slot to be released.
+   *
+   * @param slot           The slot to release.
+   */
+  public void scheduleSlotReleaser(Slot slot) {
+    Preconditions.checkState(shmManager != null);
+    releaserExecutor.execute(new SlotReleaser(slot));
+  }
+
+  @VisibleForTesting
+  public DfsClientShmManager getDfsClientShmManager() {
+    return shmManager;
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS83 INS42 INS55 INS23 INS23 INS31 INS31 INS31 INS31 INS29 INS83 INS42 INS43 INS23 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS44 INS44 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS65 INS42 INS29 INS83 INS83 INS43 INS59 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 UPD42 INS65 INS42 INS42 INS14 INS65 INS42 INS42 INS39 INS42 INS60 INS25 INS21 INS39 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS65 INS65 INS43 INS42 INS21 INS21 INS21 INS65 INS65 INS43 INS42 INS21 INS21 INS42 INS42 INS41 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS42 INS42 INS43 INS42 INS21 INS42 INS25 INS60 INS60 INS60 INS60 INS60 INS60 INS54 INS66 INS43 INS34 INS32 INS66 INS43 INS59 INS27 INS8 INS7 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS8 INS66 INS66 INS42 INS66 INS42 INS32 INS32 INS32 INS66 INS42 INS66 INS42 INS32 INS32 INS42 INS66 INS42 INS7 INS32 INS8 INS83 INS43 INS59 INS83 INS43 INS59 INS43 INS59 INS43 INS59 INS83 INS43 INS59 INS39 INS59 INS8 INS12 INS8 INS42 INS32 INS42 INS32 INS42 INS42 INS33 INS42 INS34 INS54 INS22 INS42 INS25 INS60 INS25 INS42 INS33 INS41 INS41 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS14 INS22 INS42 INS42 INS42 INS21 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS9 INS21 INS21 INS21 INS60 INS60 INS25 INS25 INS21 INS44 INS8 INS25 INS21 UPD45 INS32 INS42 INS45 INS42 INS42 INS40 INS40 INS8 INS12 INS52 INS42 INS27 INS8 INS39 INS59 INS42 INS8 INS32 INS33 INS42 INS33 INS42 INS33 INS43 INS42 INS52 INS42 INS32 INS43 INS32 INS32 INS42 INS42 INS42 INS7 INS7 INS32 INS43 INS59 INS43 INS59 INS27 INS8 INS32 INS8 INS7 INS43 INS42 INS21 INS42 INS8 INS8 INS32 INS14 INS42 INS9 INS21 INS44 INS8 INS36 INS32 INS21 INS42 INS9 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS14 INS14 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS32 INS40 INS60 INS53 INS42 INS42 INS21 INS42 INS9 INS42 INS32 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS43 INS7 INS43 INS42 INS21 INS38 INS42 INS42 INS32 UPD42 INS14 INS52 INS45 INS42 INS42 INS42 INS42 INS43 INS14 INS43 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS32 INS42 INS42 INS43 INS59 INS14 INS32 INS42 INS42 INS27 INS42 INS32 INS32 INS42 INS42 INS14 INS42 INS32 INS40 INS42 INS42 UPD45 UPD43 INS41 UPD42 MOV43 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS16 INS43 INS27 INS42 INS42 INS27 INS52 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS42 INS42 INS42 INS45 INS42 INS21 INS42 UPD42 UPD43 INS14 INS42 INS42 INS42 INS32 INS32 INS45 INS42 INS32 INS45 INS42 INS52 INS45 INS42 INS42 INS42 INS42 INS42 INS7 UPD42 UPD42 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS9 UPD43 INS42 INS42 UPD42 DEL83 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42
YARN-2962. ZKRMStateStore: Limit the number of znodes under a znode (Contributed by Varun Sexena via Daniel Templeton)

+import org.apache.zookeeper.KeeperException;
+import java.util.Map;
+import java.util.Set;
+ * |     |----- HIERARCHIES
+ * |     |        |----- 1
+ * |     |        |      |----- (#ApplicationId barring last character)
+ * |     |        |      |       |----- (#Last character of ApplicationId)
+ * |     |        |      |       |       |----- (#ApplicationAttemptIds)
+ * |     |        |      ....
+ * |     |        |
+ * |     |        |----- 2
+ * |     |        |      |----- (#ApplicationId barring last 2 characters)
+ * |     |        |      |       |----- (#Last 2 characters of ApplicationId)
+ * |     |        |      |       |       |----- (#ApplicationAttemptIds)
+ * |     |        |      ....
+ * |     |        |
+ * |     |        |----- 3
+ * |     |        |      |----- (#ApplicationId barring last 3 characters)
+ * |     |        |      |       |----- (#Last 3 characters of ApplicationId)
+ * |     |        |      |       |       |----- (#ApplicationAttemptIds)
+ * |     |        |      ....
+ * |     |        |
+ * |     |        |----- 4
+ * |     |        |      |----- (#ApplicationId barring last 4 characters)
+ * |     |        |      |       |----- (#Last 4 characters of ApplicationId)
+ * |     |        |      |       |       |----- (#ApplicationAttemptIds)
+ * |     |        |      ....
+ * |     |        |
+
-  protected static final Version CURRENT_VERSION_INFO =
-      Version.newInstance(1, 3);
+  protected static final Version CURRENT_VERSION_INFO = Version
+      .newInstance(2, 0);
+  @VisibleForTesting
+  public static final String RM_APP_ROOT_HIERARCHIES = "HIERARCHIES";
+  private Map<Integer, String> rmAppRootHierarchies;
+  private int appIdNodeSplitIndex = 0;
+  /*
+   * Indicates different app attempt state store operations.
+   */
+  private enum AppAttemptOp {
+    STORE,
+    UPDATE,
+    REMOVE
+  };
+
+  /**
+   * Encapsulates full app node path and corresponding split index.
+   */
+  private final static class AppNodeSplitInfo {
+    private final String path;
+    private final int splitIndex;
+    AppNodeSplitInfo(String path, int splitIndex) {
+      this.path = path;
+      this.splitIndex = splitIndex;
+    }
+  }
+
-    fencingNodePath = getNodePath(zkRootNodePath, FENCING_LOCK);
+    String hierarchiesPath = getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES);
+    rmAppRootHierarchies = new HashMap<>(5);
+    rmAppRootHierarchies.put(0, rmAppRoot);
+    for (int splitIndex = 1; splitIndex <= 4; splitIndex++) {
+      rmAppRootHierarchies.put(splitIndex,
+          getNodePath(hierarchiesPath, Integer.toString(splitIndex)));
+    }
+
+    fencingNodePath = getNodePath(zkRootNodePath, FENCING_LOCK);
+    appIdNodeSplitIndex =
+        conf.getInt(YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX,
+            YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);
+    if (appIdNodeSplitIndex < 1 || appIdNodeSplitIndex > 4) {
+      LOG.info("Invalid value " + appIdNodeSplitIndex + " for config " +
+          YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + " specified. " +
+              "Resetting it to " +
+                  YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);
+      appIdNodeSplitIndex = YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX;
+    }
+
+    create(getNodePath(rmAppRoot, RM_APP_ROOT_HIERARCHIES));
+    for (int splitIndex = 1; splitIndex <= 4; splitIndex++) {
+      create(rmAppRootHierarchies.get(splitIndex));
+    }
+  private void loadRMAppStateFromAppNode(RMState rmState, String appNodePath,
+      String appIdStr) throws Exception {
+    byte[] appData = getData(appNodePath);
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Loading application from znode: " + appNodePath);
+    }
+    ApplicationId appId = ApplicationId.fromString(appIdStr);
+    ApplicationStateDataPBImpl appState = new ApplicationStateDataPBImpl(
+        ApplicationStateDataProto.parseFrom(appData));
+    if (!appId.equals(
+        appState.getApplicationSubmissionContext().getApplicationId())) {
+      throw new YarnRuntimeException("The node name is different from the " +
+             "application id");
+    }
+    rmState.appState.put(appId, appState);
+    loadApplicationAttemptState(appState, appNodePath);
+  }
+
-    List<String> childNodes = getChildren(rmAppRoot);
-
-    for (String childNodeName : childNodes) {
-      String childNodePath = getNodePath(rmAppRoot, childNodeName);
-      byte[] childData = getData(childNodePath);
-
-      if (childNodeName.startsWith(ApplicationId.appIdStrPrefix)) {
-        // application
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Loading application from znode: " + childNodeName);
+    for (int splitIndex = 0; splitIndex <= 4; splitIndex++) {
+      String appRoot = rmAppRootHierarchies.get(splitIndex);
+      if (appRoot == null) {
+        continue;
+      }
+      List<String> childNodes = getChildren(appRoot);
+      boolean appNodeFound = false;
+      for (String childNodeName : childNodes) {
+        if (childNodeName.startsWith(ApplicationId.appIdStrPrefix)) {
+          appNodeFound = true;
+          if (splitIndex == 0) {
+            loadRMAppStateFromAppNode(rmState,
+                getNodePath(appRoot, childNodeName), childNodeName);
+          } else {
+            // If AppId Node is partitioned.
+            String parentNodePath = getNodePath(appRoot, childNodeName);
+            List<String> leafNodes = getChildren(parentNodePath);
+            for (String leafNodeName : leafNodes) {
+              String appIdStr = childNodeName + leafNodeName;
+              loadRMAppStateFromAppNode(rmState,
+                  getNodePath(parentNodePath, leafNodeName), appIdStr);
+            }
+          }
+        } else {
+          LOG.info("Unknown child node with name: " + childNodeName);
-
-        ApplicationId appId = ApplicationId.fromString(childNodeName);
-        ApplicationStateDataPBImpl appState =
-            new ApplicationStateDataPBImpl(
-                ApplicationStateDataProto.parseFrom(childData));
-
-        if (!appId.equals(
-            appState.getApplicationSubmissionContext().getApplicationId())) {
-          throw new YarnRuntimeException("The child node name is different "
-              + "from the application id");
-        }
-
-        rmState.appState.put(appId, appState);
-        loadApplicationAttemptState(appState, appId);
-      } else {
-        LOG.info("Unknown child node with name: " + childNodeName);
+      }
+      if (splitIndex != appIdNodeSplitIndex && !appNodeFound) {
+        // If no loaded app exists for a particular split index and the split
+        // index for which apps are being loaded is not the one configured, then
+        // we do not need to keep track of this hierarchy for storing/updating/
+        // removing app/app attempt znodes.
+        rmAppRootHierarchies.remove(splitIndex);
-      ApplicationId appId)
-      throws Exception {
-    String appPath = getNodePath(rmAppRoot, appId.toString());
+      String appPath) throws Exception {
-
+  /**
+   * Get parent app node path based on full path and split index supplied.
+   * @param appIdPath App id path for which parent needs to be returned.
+   * @param splitIndex split index.
+   * @return parent app node path.
+   */
+  private String getSplitAppNodeParent(String appIdPath, int splitIndex) {
+    // Calculated as string upto index (appIdPath Length - split index - 1). We
+    // deduct 1 to exclude path separator.
+    return appIdPath.substring(0, appIdPath.length() - splitIndex - 1);
+  }
+
+  /**
+   * Checks if parent app node has no leaf nodes and if it does not have,
+   * removes it. Called while removing application.
+   * @param appIdPath path of app id to be removed.
+   * @param splitIndex split index.
+   * @throws Exception if any problem occurs while performing ZK operation.
+   */
+  private void checkRemoveParentAppNode(String appIdPath, int splitIndex)
+      throws Exception {
+    if (splitIndex != 0) {
+      String parentAppNode = getSplitAppNodeParent(appIdPath, splitIndex);
+      List<String> children = null;
+      try {
+        children = getChildren(parentAppNode);
+      } catch (KeeperException.NoNodeException ke) {
+        // It should be fine to swallow this exception as the parent app node we
+        // intend to delete is already deleted.
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Unable to remove app parent node " + parentAppNode +
+              " as it does not exist.");
+        }
+        return;
+      }
+      // No apps stored under parent path.
+      if (children != null && children.isEmpty()) {
+        try {
+          safeDelete(parentAppNode);
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("No leaf app node exists. Removing parent node " +
+                parentAppNode);
+          }
+        } catch (KeeperException.NotEmptyException ke) {
+          // It should be fine to swallow this exception as the parent app node
+          // has to be deleted only if it has no children. And this node has.
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Unable to remove app parent node " + parentAppNode +
+                " as it has children.");
+          }
+        }
+      }
+    }
+  }
+
-    String nodeCreatePath = getNodePath(rmAppRoot, appId.toString());
+    String nodeCreatePath = getLeafAppIdNodePath(appId.toString(), true);
-    String nodeUpdatePath = getNodePath(rmAppRoot, appId.toString());
+    String nodeUpdatePath = getLeafAppIdNodePath(appId.toString(), false);
+    boolean pathExists = true;
+    // Look for paths based on other split indices if path as per split index
+    // does not exist.
+    if (!exists(nodeUpdatePath)) {
+      AppNodeSplitInfo alternatePathInfo = getAlternatePath(appId.toString());
+      if (alternatePathInfo != null) {
+        nodeUpdatePath = alternatePathInfo.path;
+      } else {
+        // No alternate path exists. Create path as per configured split index.
+        pathExists = false;
+        if (appIdNodeSplitIndex != 0) {
+          String rootNode =
+              getSplitAppNodeParent(nodeUpdatePath, appIdNodeSplitIndex);
+          if (!exists(rootNode)) {
+            safeCreate(rootNode, null, zkAcl, CreateMode.PERSISTENT);
+          }
+        }
+      }
+    }
-    if (exists(nodeUpdatePath)) {
+    if (pathExists) {
-      safeCreate(nodeUpdatePath, appStateData, zkAcl,
-          CreateMode.PERSISTENT);
+      safeCreate(nodeUpdatePath, appStateData, zkAcl, CreateMode.PERSISTENT);
-        LOG.debug(appId + " znode didn't exist. Created a new znode to"
-            + " update the application state.");
+        LOG.debug("Path " + nodeUpdatePath + " for " + appId + " didn't " +
+            "exist. Creating a new znode to update the application state.");
+  /*
+   * Handles store, update and remove application attempt state store
+   * operations.
+   */
+  private void handleApplicationAttemptStateOp(
+      ApplicationAttemptId appAttemptId,
+      ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)
+      throws Exception {
+    String appId = appAttemptId.getApplicationId().toString();
+    String appDirPath = getLeafAppIdNodePath(appId, false);
+    // Look for paths based on other split indices.
+    if (!exists(appDirPath)) {
+      AppNodeSplitInfo alternatePathInfo = getAlternatePath(appId);
+      if (alternatePathInfo == null) {
+        if (operation == AppAttemptOp.REMOVE) {
+          // Unexpected. Assume that app attempt has been deleted.
+          return;
+        } else { // Store or Update operation
+          throw new YarnRuntimeException("Unexpected Exception. App node for " +
+              "app " + appId + " not found");
+        }
+      } else {
+        appDirPath = alternatePathInfo.path;
+      }
+    }
+    String path = getNodePath(appDirPath, appAttemptId.toString());
+    byte[] attemptStateData = (attemptStateDataPB == null) ? null :
+        attemptStateDataPB.getProto().toByteArray();
+    if (LOG.isDebugEnabled()) {
+      LOG.debug(operation + " info for attempt: " + appAttemptId + " at: "
+          + path);
+    }
+    switch (operation) {
+    case UPDATE:
+      if (exists(path)) {
+        safeSetData(path, attemptStateData, -1);
+      } else {
+        safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT);
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Path " + path + " for " + appAttemptId + " didn't exist." +
+              " Created a new znode to update the application attempt state.");
+        }
+      }
+      break;
+    case STORE:
+      safeCreate(path, attemptStateData, zkAcl, CreateMode.PERSISTENT);
+      break;
+    case REMOVE:
+      safeDelete(path);
+      break;
+    default:
+      break;
+    }
+  }
+
-    String appDirPath = getNodePath(rmAppRoot,
-        appAttemptId.getApplicationId().toString());
-    String nodeCreatePath = getNodePath(appDirPath, appAttemptId.toString());
-
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Storing info for attempt: " + appAttemptId + " at: "
-          + nodeCreatePath);
-    }
-
-    byte[] attemptStateData = attemptStateDataPB.getProto().toByteArray();
-    safeCreate(nodeCreatePath, attemptStateData, zkAcl, CreateMode.PERSISTENT);
+    handleApplicationAttemptStateOp(appAttemptId, attemptStateDataPB,
+        AppAttemptOp.STORE);
-    String appIdStr = appAttemptId.getApplicationId().toString();
-    String appAttemptIdStr = appAttemptId.toString();
-    String appDirPath = getNodePath(rmAppRoot, appIdStr);
-    String nodeUpdatePath = getNodePath(appDirPath, appAttemptIdStr);
-
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Storing final state info for attempt: " + appAttemptIdStr
-          + " at: " + nodeUpdatePath);
-    }
-
-    byte[] attemptStateData = attemptStateDataPB.getProto().toByteArray();
-
-    if (exists(nodeUpdatePath)) {
-      safeSetData(nodeUpdatePath, attemptStateData, -1);
-    } else {
-      safeCreate(nodeUpdatePath, attemptStateData, zkAcl,
-          CreateMode.PERSISTENT);
-      if (LOG.isDebugEnabled()) {
-        LOG.debug(appAttemptId + " znode didn't exist. Created a new znode to"
-            + " update the application attempt state.");
-      }
-    }
+    handleApplicationAttemptStateOp(appAttemptId, attemptStateDataPB,
+        AppAttemptOp.UPDATE);
-    String appId = appAttemptId.getApplicationId().toString();
-    String appIdRemovePath = getNodePath(rmAppRoot, appId);
-    String attemptIdRemovePath =
-        getNodePath(appIdRemovePath, appAttemptId.toString());
-
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Removing info for attempt: " + appAttemptId + " at: "
-          + attemptIdRemovePath);
-    }
-
-    safeDelete(attemptIdRemovePath);
+    handleApplicationAttemptStateOp(appAttemptId, null, AppAttemptOp.REMOVE);
-    String appId = appState.getApplicationSubmissionContext().getApplicationId()
-        .toString();
-    String appIdRemovePath = getNodePath(rmAppRoot, appId);
+    removeApp(appState.getApplicationSubmissionContext().
+        getApplicationId().toString(), true, appState.attempts.keySet());
+  }
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Removing info for app: " + appId + " at: " + appIdRemovePath
-          + " and its attempts.");
+  private void removeApp(String removeAppId) throws Exception {
+    removeApp(removeAppId, false, null);
+  }
+
+  /**
+   * Remove application node and its attempt nodes.
+   *
+   * @param removeAppId Application Id to be removed.
+   * @param safeRemove Flag indicating if application and attempt nodes have to
+   *     be removed safely under a fencing or not.
+   * @param attempts list of attempts to be removed associated with this app.
+   *     Ignored if safeRemove flag is false as we recursively delete all the
+   *     child nodes directly.
+   * @throws Exception if any exception occurs during ZK operation.
+   */
+  private void removeApp(String removeAppId, boolean safeRemove,
+      Set<ApplicationAttemptId> attempts) throws Exception {
+    String appIdRemovePath = getLeafAppIdNodePath(removeAppId, false);
+    int splitIndex = appIdNodeSplitIndex;
+    // Look for paths based on other split indices if path as per configured
+    // split index does not exist.
+    if (!exists(appIdRemovePath)) {
+      AppNodeSplitInfo alternatePathInfo = getAlternatePath(removeAppId);
+      if (alternatePathInfo != null) {
+        appIdRemovePath = alternatePathInfo.path;
+        splitIndex = alternatePathInfo.splitIndex;
+      } else {
+        // Alternate path not found so return.
+        return;
+      }
-
-    for (ApplicationAttemptId attemptId : appState.attempts.keySet()) {
-      String attemptRemovePath =
-          getNodePath(appIdRemovePath, attemptId.toString());
-      safeDelete(attemptRemovePath);
+    if (safeRemove) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Removing info for app: " + removeAppId + " at: " +
+            appIdRemovePath + " and its attempts.");
+      }
+      if (attempts != null) {
+        for (ApplicationAttemptId attemptId : attempts) {
+          String attemptRemovePath =
+              getNodePath(appIdRemovePath, attemptId.toString());
+          safeDelete(attemptRemovePath);
+        }
+      }
+      safeDelete(appIdRemovePath);
+    } else {
+      curatorFramework.delete().deletingChildrenIfNeeded().
+          forPath(appIdRemovePath);
-
-    safeDelete(appIdRemovePath);
+    // Check if we should remove the parent app node as well.
+    checkRemoveParentAppNode(appIdRemovePath, splitIndex);
-    String appIdRemovePath = getNodePath(rmAppRoot, removeAppId.toString());
-    delete(appIdRemovePath);
+    removeApp(removeAppId.toString());
+  /**
+   * Get alternate path for app id if path according to configured split index
+   * does not exist. We look for path based on all possible split indices.
+   * @param appId
+   * @return a {@link AppNodeSplitInfo} object containing the path and split
+   *    index if it exists, null otherwise.
+   * @throws Exception if any problem occurs while performing ZK operation.
+   */
+  private AppNodeSplitInfo getAlternatePath(String appId) throws Exception {
+    for (Map.Entry<Integer, String> entry : rmAppRootHierarchies.entrySet()) {
+      // Look for other paths
+      int splitIndex = entry.getKey();
+      if (splitIndex != appIdNodeSplitIndex) {
+        String alternatePath =
+            getLeafAppIdNodePath(appId, entry.getValue(), splitIndex, false);
+        if (exists(alternatePath)) {
+          return new AppNodeSplitInfo(alternatePath, splitIndex);
+        }
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns leaf app node path based on app id and passed split index. If the
+   * passed flag createParentIfNotExists is true, also creates the parent app
+   * node if it does not exist.
+   * @param appId application id.
+   * @param rootNode app root node based on split index.
+   * @param appIdNodeSplitIdx split index.
+   * @param createParentIfNotExists flag which determines if parent app node
+   *     needs to be created(as per split) if it does not exist.
+   * @return leaf app node path.
+   * @throws Exception if any problem occurs while performing ZK operation.
+   */
+  private String getLeafAppIdNodePath(String appId, String rootNode,
+      int appIdNodeSplitIdx, boolean createParentIfNotExists) throws Exception {
+    if (appIdNodeSplitIdx == 0) {
+      return getNodePath(rootNode, appId);
+    }
+    String nodeName = appId;
+    int splitIdx = nodeName.length() - appIdNodeSplitIdx;
+    String rootNodePath =
+        getNodePath(rootNode, nodeName.substring(0, splitIdx));
+    if (createParentIfNotExists && !exists(rootNodePath)) {
+      try {
+        safeCreate(rootNodePath, null, zkAcl, CreateMode.PERSISTENT);
+      } catch (KeeperException.NodeExistsException e) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Unable to create app parent node " + rootNodePath +
+              " as it already exists.");
+        }
+      }
+    }
+    return getNodePath(rootNodePath, nodeName.substring(splitIdx));
+  }
+
+  /**
+   * Returns leaf app node path based on app id and configured split index. If
+   * the passed flag createParentIfNotExists is true, also creates the parent
+   * app node if it does not exist.
+   * @param appId application id.
+   * @param createParentIfNotExists flag which determines if parent app node
+   *     needs to be created(as per split) if it does not exist.
+   * @return leaf app node path.
+   * @throws Exception if any problem occurs while performing ZK operation.
+   */
+  private String getLeafAppIdNodePath(String appId,
+      boolean createParentIfNotExists) throws Exception {
+    return getLeafAppIdNodePath(appId, rmAppRootHierarchies.get(
+        appIdNodeSplitIndex), appIdNodeSplitIndex, createParentIfNotExists);
+  }
+
-  private List<String> getChildren(final String path) throws Exception {
+  @VisibleForTesting
+  List<String> getChildren(final String path) throws Exception {
-  private boolean exists(final String path) throws Exception {
+  @VisibleForTesting
+  boolean exists(final String path) throws Exception {
+  /**
+   * Deletes the path. Checks for existence of path as well.
+   * @param path Path to be deleted.
+   * @throws Exception if any problem occurs while performing deletion.
+   */

INS26 INS26 INS26 MOV31 MOV31 INS40 INS40 INS40 INS23 INS23 INS23 INS71 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS78 INS83 INS83 INS83 INS43 INS59 INS83 INS74 INS59 INS83 INS39 INS59 INS83 INS42 INS72 INS72 INS72 INS29 INS83 INS83 INS83 INS42 INS23 INS23 INS31 MOV21 INS83 INS39 INS42 MOV44 INS44 INS44 MOV43 INS8 UPD83 UPD42 INS44 INS43 INS8 INS29 UPD83 MOV83 INS43 INS42 INS44 INS44 INS8 INS29 UPD83 MOV83 MOV39 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 MOV44 MOV44 INS44 MOV43 INS8 MOV78 MOV83 MOV83 MOV39 INS42 MOV44 MOV44 MOV43 INS8 MOV78 INS83 INS83 INS39 INS42 MOV44 INS44 MOV43 INS8 MOV78 INS83 INS83 INS39 MOV42 INS44 INS43 INS8 MOV78 INS83 INS83 INS39 INS42 MOV44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 MOV43 MOV8 INS29 UPD83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS78 INS78 INS29 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS45 INS43 INS43 INS43 INS42 INS42 INS34 INS42 INS42 INS42 INS65 INS83 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS42 INS44 INS44 INS8 INS60 INS21 INS21 INS24 INS21 INS25 INS21 INS24 MOV43 INS42 MOV43 INS42 MOV60 MOV25 MOV60 MOV60 MOV25 MOV21 MOV21 INS43 INS42 INS42 INS24 MOV43 UPD42 INS65 INS65 INS65 INS65 INS42 MOV43 INS42 INS39 INS42 INS41 INS65 INS65 INS65 INS65 MOV43 INS42 INS39 INS42 INS42 INS25 INS60 MOV60 INS60 INS25 INS43 INS42 MOV60 MOV60 INS25 MOV60 MOV60 INS25 INS50 INS21 INS43 INS42 INS21 INS43 INS42 INS42 INS21 INS42 INS21 MOV43 INS42 INS42 INS21 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS74 INS42 INS60 INS25 INS25 INS21 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS70 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS25 INS60 INS60 INS60 INS25 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS42 INS41 INS42 INS42 INS65 INS65 INS65 UPD34 UPD34 INS42 INS42 INS42 INS66 INS42 INS42 INS42 INS43 INS42 INS39 INS42 INS21 INS21 INS43 INS59 INS7 INS32 INS58 INS27 INS37 INS8 INS7 INS27 INS8 INS32 INS58 INS27 INS37 INS8 MOV5 MOV32 MOV43 INS42 INS58 INS27 INS37 INS8 UPD42 MOV42 INS66 INS42 INS66 INS42 INS66 INS66 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS27 INS8 MOV43 INS59 INS43 INS39 INS59 INS38 INS8 INS42 INS42 INS43 INS38 INS8 MOV32 MOV8 INS42 INS49 INS25 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS10 INS32 INS42 INS32 INS42 INS32 INS32 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS43 INS43 INS43 INS39 INS59 INS38 INS8 INS42 INS8 INS8 INS32 MOV32 INS66 INS66 INS42 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS44 INS32 INS8 INS33 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS27 INS8 INS43 INS59 INS39 INS59 INS43 INS59 INS27 INS8 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS7 INS7 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS34 INS42 INS39 INS59 INS42 INS34 INS42 INS21 INS42 INS32 INS27 INS27 INS21 INS21 INS42 INS32 INS39 INS59 INS42 INS34 INS42 INS21 UPD42 UPD42 INS39 INS59 INS42 INS34 INS42 MOV60 INS25 MOV60 INS60 INS70 INS25 INS42 INS42 INS34 INS27 INS42 INS34 MOV60 INS60 INS54 INS25 INS42 INS32 INS42 UPD42 INS42 INS9 INS32 MOV60 INS25 INS42 INS32 MOV60 INS25 UPD42 INS16 INS42 MOV32 MOV8 MOV8 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS42 INS33 INS40 INS42 MOV32 INS9 MOV32 INS42 INS42 INS9 INS33 INS42 INS42 INS42 INS42 INS42 INS32 INS60 INS25 INS25 INS25 MOV21 MOV21 INS42 INS42 INS42 UPD42 INS42 INS74 INS42 INS42 INS42 INS60 INS25 INS42 INS34 INS41 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS38 INS54 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS42 INS74 INS34 INS42 INS34 INS32 INS42 INS42 INS40 INS40 INS42 INS34 INS42 INS34 INS32 INS7 INS42 INS42 INS42 INS42 INS34 INS32 UPD42 UPD42 MOV43 INS42 INS34 MOV43 INS27 INS8 INS39 INS59 MOV44 INS42 INS8 INS27 INS8 INS32 INS42 INS34 MOV43 INS74 INS59 INS8 INS12 INS27 INS8 INS42 MOV32 INS9 UPD42 INS9 INS42 INS42 INS43 INS27 INS8 INS8 MOV32 UPD42 UPD42 INS9 INS42 INS42 UPD43 INS27 INS8 INS8 INS36 INS33 MOV32 UPD42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 UPD42 UPD42 INS9 INS42 INS42 INS43 INS59 INS27 INS8 INS8 INS32 MOV8 INS27 MOV8 INS43 INS43 INS43 INS39 INS59 INS27 INS8 INS32 INS32 INS42 INS42 INS42 INS32 INS32 INS8 INS12 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS43 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS40 INS42 INS32 UPD42 UPD42 INS42 INS33 INS18 INS42 INS9 INS25 INS27 INS38 INS21 INS42 INS42 UPD42 INS43 INS43 INS42 INS33 INS21 INS44 INS8 INS27 INS32 INS54 INS42 INS42 UPD42 INS42 INS33 INS21 INS21 INS25 UPD42 UPD42 INS42 INS33 INS25 INS21 INS27 MOV32 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS41 UPD42 MOV42 UPD42 MOV42 INS42 INS33 INS32 INS42 UPD42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS42 INS32 INS45 INS42 INS45 INS40 INS45 INS45 INS40 INS42 INS42 INS42 UPD42 UPD45 UPD45 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV32 INS8 MOV8 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 MOV42 INS7 INS43 INS42 INS25 INS41 INS42 INS33 INS42 INS42 INS8 INS12 UPD42 INS7 INS7 INS27 INS8 UPD42 UPD42 INS27 INS8 INS8 INS7 INS42 INS33 INS42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 INS7 INS7 INS42 INS32 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS32 INS43 INS42 INS25 INS42 INS42 INS42 INS21 INS25 INS42 INS42 INS42 INS42 INS32 INS40 MOV32 INS8 INS21 INS25 INS44 INS8 INS42 INS40 INS42 INS9 INS42 INS34 MOV60 INS25 INS42 INS40 INS41 INS53 INS42 INS40 INS42 INS40 INS42 INS40 INS42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS41 INS42 INS42 INS33 INS42 INS40 INS40 INS32 INS8 INS7 INS27 MOV8 INS8 INS42 INS42 INS21 INS32 MOV32 INS8 INS43 INS42 INS25 MOV43 INS38 INS8 INS45 INS42 INS45 UPD45 UPD45 INS14 UPD45 UPD42 UPD42 INS45 INS42 INS42 INS32 INS42 INS9 INS14 INS42 INS42 INS21 INS42 INS9 INS42 INS34 MOV60 INS60 INS70 INS32 INS42 INS42 INS21 INS40 MOV32 INS8 UPD42 INS32 INS21 INS43 INS27 INS45 INS42 INS45 UPD45 UPD45 INS42 INS42 INS43 INS42 INS42 INS32 MOV43 INS74 INS59 INS44 INS42 INS8 INS42 INS42 INS27 INS32 INS21 UPD42 UPD42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS27 INS42 INS45 INS42 INS42 INS42 INS27 UPD42 UPD42 INS32 INS42 UPD42 INS43 INS43 INS42 INS32 MOV43 INS42 INS60 MOV21 INS45 INS42 INS45 UPD42 MOV42 UPD42 MOV42 INS27 INS32 INS42 INS42 INS33 INS42 INS40 INS45 INS45 INS45 INS42 INS45 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS42 MOV43 INS59 INS45 INS42 INS42 INS42 INS27 INS42 INS27 INS42 UPD42 INS32 INS42 INS45 INS42 INS45 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 DEL39 DEL85 DEL5 DEL42 DEL42 DEL32 DEL32 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL40 DEL25 DEL8 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL8 DEL70 DEL8 DEL31 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL25 DEL42 DEL42 DEL32 DEL59 DEL60 DEL25 DEL25 DEL8 DEL31 DEL31 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL83 DEL39 DEL42 DEL83 DEL83
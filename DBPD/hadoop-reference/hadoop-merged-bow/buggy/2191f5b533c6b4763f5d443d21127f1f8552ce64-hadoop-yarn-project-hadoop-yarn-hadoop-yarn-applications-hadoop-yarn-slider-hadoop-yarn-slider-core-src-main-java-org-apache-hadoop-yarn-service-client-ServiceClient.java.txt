YARN-7050. Post cleanup after YARN-6903, removal of org.apache.slider package. Contributed by Jian He

+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.classification.InterfaceStability;
+import org.apache.hadoop.yarn.api.records.ApplicationTimeout;
+import org.apache.hadoop.yarn.service.api.records.Application;
+import org.apache.hadoop.yarn.service.api.records.Component;
+import org.apache.hadoop.yarn.service.client.params.AbstractClusterBuildingActionArgs;
-import org.apache.hadoop.yarn.service.conf.SliderKeys;
-import org.apache.hadoop.yarn.service.conf.SliderXmlConfKeys;
+import org.apache.hadoop.yarn.service.conf.YarnServiceConstants;
+import org.apache.hadoop.yarn.service.utils.ServiceApiUtil;
+import org.apache.hadoop.yarn.service.utils.ServiceRegistryUtils;
+import org.apache.hadoop.yarn.service.utils.SliderFileSystem;
+import org.apache.hadoop.yarn.service.utils.SliderUtils;
-import org.apache.slider.api.resource.Application;
-import org.apache.slider.api.resource.Component;
-import org.apache.slider.common.params.AbstractClusterBuildingActionArgs;
-import org.apache.slider.common.tools.SliderFileSystem;
-import org.apache.slider.common.tools.SliderUtils;
-import org.apache.slider.core.exceptions.BadClusterStateException;
-import org.apache.slider.core.exceptions.BadConfigException;
-import org.apache.slider.core.exceptions.SliderException;
-import org.apache.slider.core.exceptions.UsageException;
-import org.apache.slider.core.launch.ClasspathConstructor;
-import org.apache.slider.core.launch.JavaCommandLineBuilder;
-import org.apache.slider.core.registry.SliderRegistryUtils;
-import org.apache.slider.core.zk.ZKIntegration;
-import org.apache.slider.core.zk.ZookeeperUtils;
-import org.apache.hadoop.yarn.service.utils.ServiceApiUtil;
+import org.apache.hadoop.yarn.service.exceptions.BadClusterStateException;
+import org.apache.hadoop.yarn.service.exceptions.BadConfigException;
+import org.apache.hadoop.yarn.service.exceptions.SliderException;
+import org.apache.hadoop.yarn.service.exceptions.UsageException;
+import org.apache.hadoop.yarn.service.containerlaunch.ClasspathConstructor;
+import org.apache.hadoop.yarn.service.containerlaunch.JavaCommandLineBuilder;
+import org.apache.hadoop.yarn.service.utils.ZookeeperUtils;
-import static org.apache.slider.common.Constants.HADOOP_JAAS_DEBUG;
-import static org.apache.slider.common.tools.SliderUtils.*;
+import static org.apache.hadoop.yarn.service.conf.YarnServiceConf.YARN_QUEUE;
+import static org.apache.hadoop.yarn.service.utils.SliderUtils.*;
+@InterfaceAudience.Public
+@InterfaceStability.Unstable
-    implements SliderExitCodes, SliderKeys {
+    implements SliderExitCodes, YarnServiceConstants {
+  private Map<String, ClientAMProtocol> cachedAMProxies = new ConcurrentHashMap<>();
+
-    ClientAMProtocol proxy = connectToAM(appName);
+    ClientAMProtocol proxy = getAMProxy(appName);
+    if (proxy == null) {
+      String message = appName + " is not running";
+      LOG.error(message);
+      throw new YarnException(message);
+    }
-  public int actionStop(String appName) throws YarnException, IOException {
+  public int actionStop(String appName, boolean waitForAppStopped)
+      throws YarnException, IOException {
-    getAppIdFromPersistedApp(appName);
+    getAppId(appName);
-      // try to stop the app gracefully.
-      ClientAMProtocol proxy = connectToAM(appName);
-      StopRequestProto request = StopRequestProto.newBuilder().build();
-      proxy.stop(request);
-      LOG.info("Application " + appName + " is being gracefully stopped...");
+      ClientAMProtocol proxy = getAMProxy(appName, report);
+      cachedAppIds.remove(appName);
+      cachedAMProxies.remove(appName);
+      if (proxy != null) {
+        // try to stop the app gracefully.
+        StopRequestProto request = StopRequestProto.newBuilder().build();
+        proxy.stop(request);
+        LOG.info("Application " + appName + " is being gracefully stopped...");
+      } else {
+        yarnClient.killApplication(currentAppId,
+            appName + " is forcefully killed by user!");
+        LOG.info("Forcefully kill the application: " + appName);
+        return EXIT_SUCCESS;
+      }
+      if (!waitForAppStopped) {
+        return EXIT_SUCCESS;
+      }
-        Thread.sleep(1000);
+        Thread.sleep(2000);
+    cachedAMProxies.remove(appName);
-    String registryPath = SliderRegistryUtils.registryPathForInstance(appName);
+    String registryPath = ServiceRegistryUtils.registryPathForInstance(appName);
-    String zkPath = ZKIntegration.mkClusterPath(user, clusterName);
+    String zkPath = ServiceRegistryUtils.mkClusterPath(user, clusterName);
-              .sessionTimeoutMs(10000).retryPolicy(new RetryNTimes(10, 2000))
+              .sessionTimeoutMs(10000).retryPolicy(new RetryNTimes(5, 2000))
-    types.add(SliderKeys.APP_TYPE);
+    types.add(YarnServiceConstants.APP_TYPE);
-    submissionContext.setMaxAppAttempts(conf.getInt(KEY_AM_RESTART_LIMIT, 2));
+    submissionContext.setMaxAppAttempts(conf.getInt(
+        YarnServiceConf.AM_RESTART_MAX, 2));
-    boolean hasSliderAMLog4j =
+    boolean hasAMLog4j =
-        buildCommandLine(appName, conf, appRootDir, hasSliderAMLog4j);
+        buildCommandLine(appName, conf, appRootDir, hasAMLog4j);
-        .getLong(KEY_AM_RESOURCE_MEM, DEFAULT_KEY_AM_RESOURCE_MEM,
+        .getLong(YarnServiceConf.AM_RESOURCE_MEM, YarnServiceConf.DEFAULT_KEY_AM_RESOURCE_MEM,
-      queue = conf.get(KEY_YARN_QUEUE, "default");
+      queue = conf.get(YARN_QUEUE, "default");
-    submissionContext.setApplicationType(SliderKeys.APP_TYPE);
+    submissionContext.setApplicationType(YarnServiceConstants.APP_TYPE);
-      CLI.sysprop(SYSPROP_LOG4J_CONFIGURATION, LOG4J_SERVER_PROP_FILENAME);
+      CLI.sysprop(SYSPROP_LOG4J_CONFIGURATION, YARN_SERVICE_LOG4J_FILENAME);
-        buildClasspath(SliderKeys.SUBMITTED_CONF_DIR, "lib", fs, getConfig()
+        buildClasspath(YarnServiceConstants.SUBMITTED_CONF_DIR, "lib", fs, getConfig()
-    String jaas = System.getenv(HADOOP_JAAS_DEBUG);
+    String jaas = System.getenv("HADOOP_JAAS_DEBUG");
-      env.put(HADOOP_JAAS_DEBUG, jaas);
+      env.put("HADOOP_JAAS_DEBUG", jaas);
-        .addProviderJar(localResources, ServiceMaster.class, SLIDER_JAR, fs,
+        .addProviderJar(localResources, ServiceMaster.class, SERVICE_CORE_JAR, fs,
-      LOG.info("Loading lib tar from " + fs.getFileSystem().getScheme() + ": "
+      LOG.info("Loading lib tar from " + fs.getFileSystem().getScheme() + ":/"
-    boolean hasSliderAMLog4j = false;
+    boolean hasAMLog4j = false;
-          new File(hadoopConfDir, SliderKeys.LOG4J_SERVER_PROP_FILENAME);
+          new File(hadoopConfDir, YarnServiceConstants.YARN_SERVICE_LOG4J_FILENAME);
-            new Path(appDirPath, SliderKeys.SUBMITTED_CONF_DIR);
+            new Path(appDirPath, YarnServiceConstants.SUBMITTED_CONF_DIR);
-            new Path(remoteConfPath, SliderKeys.LOG4J_SERVER_PROP_FILENAME);
+            new Path(remoteConfPath, YarnServiceConstants.YARN_SERVICE_LOG4J_FILENAME);
-        hasSliderAMLog4j = true;
+        hasAMLog4j = true;
+      } else {
+        LOG.warn("AM log4j property file doesn't exist: " + localFile);
-    return hasSliderAMLog4j;
+    return hasAMLog4j;
-        conf.get(SliderXmlConfKeys.KEY_AM_KEYTAB_LOCAL_PATH);
+        conf.get(YarnServiceConf.KEY_AM_KEYTAB_LOCAL_PATH);
-          conf.get(SliderXmlConfKeys.KEY_AM_LOGIN_KEYTAB_NAME);
-      String keytabDir = conf.get(SliderXmlConfKeys.KEY_HDFS_KEYTAB_DIR);
+          conf.get(YarnServiceConf.KEY_AM_LOGIN_KEYTAB_NAME);
+      String keytabDir = conf.get(YarnServiceConf.KEY_HDFS_KEYTAB_DIR);
-            .put(SliderKeys.KEYTAB_DIR + "/" + amKeytabName, keytabRes);
+            .put(YarnServiceConstants.KEYTAB_DIR + "/" + amKeytabName, keytabRes);
-        if (conf.getBoolean(KEY_AM_LOGIN_KEYTAB_REQUIRED, false)) {
+        if (conf.getBoolean(YarnServiceConf.KEY_AM_LOGIN_KEYTAB_REQUIRED, false)) {
-    getAppIdFromPersistedApp(appName);
+    getAppId(appName);
-    ClientAMProtocol proxy = connectToAM(appName);
-    GetStatusResponseProto response =
-        proxy.getStatus(GetStatusRequestProto.newBuilder().build());
-    return ServiceApiUtil.jsonSerDeser.fromJson(response.getStatus());
-
+    validateClusterName(appName);
+    ApplicationId currentAppId = getAppId(appName);
+    ApplicationReport appReport = yarnClient.getApplicationReport(currentAppId);
+    ClientAMProtocol amProxy = getAMProxy(appName, appReport);
+    Application appSpec;
+    if (amProxy != null) {
+      GetStatusResponseProto response =
+          amProxy.getStatus(GetStatusRequestProto.newBuilder().build());
+      appSpec = ServiceApiUtil.jsonSerDeser.fromJson(response.getStatus());
+    } else {
+      appSpec = new Application();
+      appSpec.setName(appName);
+    }
+    ApplicationTimeout lifetime =
+        appReport.getApplicationTimeouts().get(ApplicationTimeoutType.LIFETIME);
+    if (lifetime != null) {
+      appSpec.setLifetime(lifetime.getRemainingTime());
+    }
+    return appSpec;
-          SliderKeys.SLIDER_DEPENDENCY_TAR_GZ_FILE_NAME + "_",
-          SliderKeys.SLIDER_DEPENDENCY_TAR_GZ_FILE_EXT);
+          YarnServiceConstants.DEPENDENCY_TAR_GZ_FILE_NAME + "_",
+          YarnServiceConstants.DEPENDENCY_TAR_GZ_FILE_EXT);
-      LOG.info("Uploading dependency for AM (version {}) from {} to {}",
-          VersionInfo.getBuildVersion(), tempLibTarGzipFile.toURI(),
-          dependencyLibTarGzip.toUri());
+      LOG.info("Version Info: " + VersionInfo.getBuildVersion());
-          new FsPermission(SliderKeys.SLIDER_DEPENDENCY_DIR_PERMISSIONS));
+          new FsPermission(YarnServiceConstants.DEPENDENCY_DIR_PERMISSIONS));
-  protected ClientAMProtocol connectToAM(String appName)
-      throws IOException, YarnException {
-    ApplicationId currentAppId = getAppIdFromPersistedApp(appName);
-    // Wait until app becomes running.
-    long startTime = System.currentTimeMillis();
-    int pollCount = 0;
-    ApplicationReport appReport = null;
-    while (true) {
-      appReport = yarnClient.getApplicationReport(currentAppId);
-      YarnApplicationState state = appReport.getYarnApplicationState();
-      if (state == RUNNING) {
-        break;
-      }
-      if (terminatedStates.contains(state)) {
-        throw new YarnException(
-            "Failed to getStatus " + currentAppId + ": " + appReport
-                .getDiagnostics());
-      }
-      long elapsedMillis = System.currentTimeMillis() - startTime;
-      // if over 5 min, quit
-      if (elapsedMillis >= 300000) {
-        throw new YarnException(
-            "Timed out while waiting for application " + currentAppId
-                + " to be running");
-      }
-
-      if (++pollCount % 10 == 0) {
-        LOG.info(
-            "Waiting for application {} to be running, current state is {}",
-            currentAppId, state);
-      }
-      try {
-        Thread.sleep(3000);
-      } catch (InterruptedException ie) {
-        String msg =
-            "Interrupted while waiting for application " + currentAppId
-                + " to be running.";
-        throw new YarnException(msg, ie);
-      }
+  // Get AMProxy with the appReport provided
+  protected ClientAMProtocol getAMProxy(String appName, ApplicationReport report)
+      throws IOException {
+    if (!cachedAMProxies.containsKey(appName) && !StringUtils
+        .isEmpty(report.getHost())) {
+      insertAMProxy(appName, report.getHost(), report.getRpcPort());
-
-    // Make the connection
-    InetSocketAddress address = NetUtils
-        .createSocketAddrForHost(appReport.getHost(), appReport.getRpcPort());
-    return ClientAMProxy.createProxy(getConfig(), ClientAMProtocol.class,
-        UserGroupInformation.getCurrentUser(), rpc, address);
+    return cachedAMProxies.get(appName);
-  private synchronized ApplicationId getAppIdFromPersistedApp(String appName)
+  // Get AMProxy without appReport provided - it'll getAppReport from RM
+  protected ClientAMProtocol getAMProxy(String appName)
+      throws IOException, YarnException {
+    ApplicationId currentAppId = getAppId(appName);
+
+    if (cachedAMProxies.containsKey(appName)) {
+      return cachedAMProxies.get(appName);
+    } else {
+      ApplicationReport appReport =
+          yarnClient.getApplicationReport(currentAppId);
+      String host = appReport.getHost();
+      int port = appReport.getRpcPort();
+      if (!StringUtils.isEmpty(host)) {
+        return insertAMProxy(appName, host, port);
+      }
+      return null;
+    }
+  }
+
+  private ClientAMProtocol insertAMProxy(String appName, String host, int port)
+      throws IOException {
+    InetSocketAddress address =
+        NetUtils.createSocketAddrForHost(host, port);
+    ClientAMProtocol amProxy =
+        ClientAMProxy.createProxy(getConfig(), ClientAMProtocol.class,
+        UserGroupInformation.getCurrentUser(), rpc, address);
+    cachedAMProxies.put(appName, amProxy);
+    return amProxy;
+  }
+
+  private synchronized ApplicationId getAppId(String appName)

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 UPD40 INS40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 INS78 INS78 INS43 INS23 INS31 INS31 INS31 INS31 INS40 INS40 INS42 INS83 INS74 INS59 INS44 MOV83 MOV43 MOV42 MOV44 MOV43 MOV43 INS8 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS43 MOV43 INS8 INS83 MOV43 INS42 MOV44 INS44 INS44 MOV43 INS8 UPD42 INS43 INS43 INS43 INS42 INS14 INS25 INS39 INS42 INS21 INS21 MOV60 INS60 MOV60 MOV60 INS25 MOV60 MOV25 INS41 INS42 INS43 INS42 INS43 INS42 UPD42 MOV42 INS25 INS41 INS42 INS43 INS42 UPD42 MOV42 INS60 INS25 INS43 INS42 INS39 INS42 MOV60 INS60 INS21 MOV41 INS42 UPD42 MOV42 INS42 INS74 INS27 INS8 INS32 MOV43 MOV43 UPD42 MOV43 INS32 MOV43 INS59 MOV43 INS43 INS27 MOV8 INS8 UPD43 UPD27 INS42 INS42 INS42 INS27 INS8 INS32 INS42 INS43 INS59 INS32 INS8 INS8 UPD42 MOV42 INS43 INS59 INS32 INS42 INS43 INS42 INS33 INS60 INS21 INS53 UPD42 INS21 INS21 INS25 INS25 INS42 INS42 INS42 UPD40 UPD42 UPD40 UPD42 UPD42 UPD42 INS42 INS42 INS42 MOV32 UPD42 INS42 UPD42 INS42 INS33 INS21 MOV21 INS21 UPD42 UPD42 INS32 UPD42 INS33 INS21 INS38 INS38 INS21 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS41 INS60 INS60 INS60 INS25 INS41 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 UPD42 INS43 INS59 INS32 INS14 INS32 INS32 INS27 INS8 INS8 INS38 INS8 UPD42 UPD42 INS40 UPD42 UPD40 INS45 MOV43 INS8 UPD40 MOV43 UPD42 UPD42 UPD42 INS42 INS7 INS32 INS32 INS42 INS40 INS32 INS32 INS32 INS32 INS42 UPD42 MOV42 INS32 INS43 INS59 MOV43 INS59 INS39 INS59 INS38 INS8 INS33 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 MOV60 MOV21 MOV21 INS21 INS21 INS41 INS42 INS41 INS40 INS40 UPD42 INS45 INS21 INS42 MOV32 UPD42 INS14 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS32 INS42 MOV32 INS42 MOV32 INS32 INS41 INS42 INS45 INS42 UPD42 INS42 INS32 INS32 INS42 INS42 UPD42 UPD45 MOV43 UPD40 MOV43 MOV43 INS32 UPD40 UPD40 UPD42 INS43 INS42 INS42 UPD40 INS45 MOV32 UPD40 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS27 UPD34 UPD42 INS42 INS42 INS27 INS40 INS42 UPD40 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 UPD34 MOV43 UPD40 MOV43 UPD40 INS45 INS42 UPD40 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL39 DEL39 DEL34 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL41 DEL32 DEL42 DEL10 DEL31 DEL45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL33 DEL59 DEL60 DEL9 DEL42 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL39 DEL42 DEL32 DEL42 DEL27 DEL59 DEL60 DEL42 DEL34 DEL27 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL38 DEL34 DEL27 DEL34 DEL27 DEL45 DEL32 DEL21 DEL8 DEL25 DEL34 DEL32 DEL21 DEL8 DEL43 DEL42 DEL44 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL31
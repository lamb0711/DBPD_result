HDFS-2767. ConfiguredFailoverProxyProvider should support NameNodeProtocol. Contributed by Uma Maheswara Rao G.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1232284 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.protocol.NamenodeProtocol;
+import org.apache.hadoop.hdfs.server.protocol.NamenodeProtocols;
+import com.google.common.base.Preconditions;
+
-public class ConfiguredFailoverProxyProvider implements FailoverProxyProvider,
-    Configurable {
+public class ConfiguredFailoverProxyProvider<T> implements
+    FailoverProxyProvider<T>, Configurable {
-  private List<AddressRpcProxyPair> proxies = new ArrayList<AddressRpcProxyPair>();
+  private List<AddressRpcProxyPair<T>> proxies = new ArrayList<AddressRpcProxyPair<T>>();
+  private final Class<T> xface;
+  public ConfiguredFailoverProxyProvider(Class<T> xface) {
+    Preconditions.checkArgument(
+        xface.isAssignableFrom(NamenodeProtocols.class),
+        "Interface class %s is not a valid NameNode protocol!");
+    this.xface = xface;
+  }
+    
-  public Class<?> getInterface() {
-    return ClientProtocol.class;
+  public Class<T> getInterface() {
+    return xface;
+  @SuppressWarnings("unchecked")
-  public synchronized Object getProxy() {
+  public synchronized T getProxy() {
-        // TODO(HA): This will create a NN proxy with an underlying retry
-        // proxy. We don't want this.
-        current.namenode = DFSUtil.createNamenode(current.address, conf, ugi);
+        if (NamenodeProtocol.class.equals(xface)) {
+          current.namenode = DFSUtil.createNNProxyWithNamenodeProtocol(
+              current.address, conf, ugi);
+        } else if (ClientProtocol.class.equals(xface)) {
+          // TODO(HA): This will create a NN proxy with an underlying retry
+          // proxy. We don't want this.
+          current.namenode = DFSUtil.createNamenode(current.address, conf, ugi);
+        } else {
+          throw new IllegalStateException(
+              "Upsupported protocol found when creating the proxy conection to NameNode. "
+                  + ((xface != null) ? xface.getClass().getName() : xface)
+                  + " is not supported by " + this.getClass().getName());
+        }
-    return current.namenode;
+    return (T)current.namenode;
-  public synchronized void performFailover(Object currentProxy) {
+  public synchronized void performFailover(T currentProxy) {
-        proxies.add(new AddressRpcProxyPair(address));
+        proxies.add(new AddressRpcProxyPair<T>(address));
-  private static class AddressRpcProxyPair {
+  private static class AddressRpcProxyPair<T> {
-    public ClientProtocol namenode;
+    public T namenode;
-    for (AddressRpcProxyPair proxy : proxies) {
+    for (AddressRpcProxyPair<T> proxy : proxies) {

INS26 INS26 INS26 INS40 INS40 INS40 INS73 INS74 INS23 INS31 INS42 MOV43 INS43 INS74 INS83 INS83 UPD74 MOV74 INS59 INS83 INS42 INS44 INS8 INS74 INS79 UPD43 INS73 INS42 MOV43 UPD74 MOV74 INS43 INS42 INS74 INS42 INS21 INS21 INS43 INS43 INS42 INS45 UPD42 UPD43 INS42 UPD43 INS43 INS74 INS42 INS43 INS43 INS32 INS7 INS42 INS42 INS42 INS11 UPD42 UPD42 INS42 MOV43 UPD74 MOV74 INS42 INS42 INS42 INS42 INS32 INS45 INS22 INS42 INS43 INS40 INS74 INS43 INS42 INS42 INS57 INS52 INS42 INS8 INS42 MOV43 INS43 INS42 INS43 INS25 UPD42 MOV42 INS42 INS32 INS8 INS25 INS57 INS42 INS42 INS21 INS32 MOV8 INS8 INS43 INS7 MOV57 INS42 INS42 INS53 INS74 INS42 INS40 INS32 INS14 MOV43 INS43 INS42 INS42 INS40 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS45 INS36 INS45 INS32 INS16 INS32 INS42 INS36 INS32 INS42 INS52 INS42 INS27 INS32 INS42 INS42 INS33 INS42 INS42 DEL76 DEL40
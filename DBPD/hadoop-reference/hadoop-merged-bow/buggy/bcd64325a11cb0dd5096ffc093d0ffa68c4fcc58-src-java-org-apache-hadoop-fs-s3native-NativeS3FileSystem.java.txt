Merged src/core, src/test/core, src/contrib/eclipse-plugin, and
src/contrib/ec2 from trunk 776174:784663


git-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@784965 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.EnumSet;
+import org.apache.hadoop.fs.CreateFlag;
+ *
+ * A note about directories. S3 of course has no "native" support for them.
+ * The idiom we choose then is: for any directory created by this class,
+ * we use an empty object "#{dirpath}_$folder$" as a marker.
+ * Further, to interoperate with other S3 tools, we also accept the following:
+ *  - an object "#{dirpath}/' denoting a directory marker
+ *  - if there exists any objects with the prefix "#{dirpath}/", then the
+ *    directory is said to exist
+ *  - if both a file with the name of a directory and a marker for that
+ *    directory exists, then the *file masks the directory*, and the directory
+ *    is never returned.
-  private static final long MAX_S3_FILE_SIZE = 5 * 1024 * 1024 * 1024L;
+    @Override
+    @Override
+    @Override
+    @Override
+      LOG.info("Opening key '" + key + "' for reading at position '" + pos + "'");
+    @Override
+    @Override
+      LOG.info("OutputStream for key '" + key + "' writing to tempfile '" + this.backupFile + "'");
+      LOG.info("OutputStream for key '" + key + "' closed. Now beginning upload");
-
+      LOG.info("OutputStream for key '" + key + "' upload complete");
-    
-    
+    methodNameToPolicyMap.put("rename", methodPolicy);
+    if (path.toUri().getScheme() != null && "".equals(path.toUri().getPath())) {
+      // allow uris without trailing slash after bucket to refer to root,
+      // like s3n://mybucket
+      return "";
+    }
-    return path.toUri().getPath().substring(1); // remove initial slash
+    String ret = path.toUri().getPath().substring(1); // remove initial slash
+    if (ret.endsWith("/") && (ret.indexOf("/") != ret.length() - 1)) {
+      ret = ret.substring(0, ret.length() -1);
+  }
+    return ret;
+  @Override
-      boolean overwrite, int bufferSize, short replication, long blockSize,
+      EnumSet<CreateFlag> flag, int bufferSize, short replication, long blockSize,
-    if (exists(f) && !overwrite) {
-      throw new IOException("File already exists:"+f);
+    if(exists(f)) {
+      if(flag.contains(CreateFlag.APPEND)){
+        return append(f, bufferSize, progress);
+      } else if(!flag.contains(CreateFlag.OVERWRITE)) {
+        throw new IOException("File already exists: "+f);
+      }
+    } else {
+      if (flag.contains(CreateFlag.APPEND) && !flag.contains(CreateFlag.CREATE))
+        throw new IOException("File already exists: " + f.toString());
+    
+    LOG.debug("Creating new file '" + f + "' in S3");
-  public boolean delete(Path f, boolean recursive) throws IOException {
+  public boolean delete(Path f, boolean recurse) throws IOException {
+      LOG.debug("Delete called for '" + f + "' but file does not exist, so returning false");
-      FileStatus[] contents = listStatus(f);
-      if (!recursive && contents.length > 0) {
-        throw new IOException("Directory " + f.toString() + " is not empty.");
+      if (!recurse && listStatus(f).length > 0) {
+        throw new IOException("Can not delete " + f + " at is a not empty directory and recurse option is false");
-      for (FileStatus p : contents) {
-        if (!delete(p.getPath(), recursive)) {
-          return false;
+
+      createParent(f);
+
+      LOG.debug("Deleting directory '" + f  + "'");
+      String priorLastKey = null;
+      do {
+        PartialListing listing = store.list(key, S3_MAX_LISTING_LENGTH, priorLastKey, true);
+        for (FileMetadata file : listing.getFiles()) {
+          store.delete(file.getKey());
+        priorLastKey = listing.getPriorLastKey();
+      } while (priorLastKey != null);
+
+      try {
+        store.delete(key + FOLDER_SUFFIX);
+      } catch (FileNotFoundException e) {
+        //this is fine, we don't require a marker
-      store.delete(key + FOLDER_SUFFIX);
+      LOG.debug("Deleting file '" + f + "'");
+      createParent(f);
-    
+    LOG.debug("getFileStatus retrieving metadata for key '" + key + "'");
+      LOG.debug("getFileStatus returning 'file' for key '" + key + "'");
+      LOG.debug("getFileStatus returning 'directory' for key '" + key + "' as '"
+          + key + FOLDER_SUFFIX + "' exists");
+    LOG.debug("getFileStatus listing key '" + key + "'");
+      LOG.debug("getFileStatus returning 'directory' for key '" + key + "' as it has contents");
-    throw new FileNotFoundException(absolutePath +
-        ": No such file or directory.");
-    
+    LOG.debug("getFileStatus could not find key '" + key + "'");
+    throw new FileNotFoundException("No such file or directory '" + absolutePath + "'");
-      PartialListing listing = store.list(key, S3_MAX_LISTING_LENGTH, 
-          priorLastKey);
+      PartialListing listing = store.list(key, S3_MAX_LISTING_LENGTH, priorLastKey, false);
-        if (relativePath.endsWith(FOLDER_SUFFIX)) {
-          status.add(newDirectory(new Path(absolutePath,
-              relativePath.substring(0,
-                  relativePath.indexOf(FOLDER_SUFFIX)))));
-        } else {
+
+        if (fileMetadata.getKey().equals(key + "/")) {
+          // this is just the directory we have been asked to list
+        }
+        else if (relativePath.endsWith(FOLDER_SUFFIX)) {
+          status.add(newDirectory(new Path(
+              absolutePath,
+              relativePath.substring(0, relativePath.indexOf(FOLDER_SUFFIX)))));
+        }
+        else {
-    return status.toArray(new FileStatus[0]);
+    return status.toArray(new FileStatus[status.size()]);
-    return new FileStatus(meta.getLength(), false, 1, MAX_S3_FILE_SIZE,
+    return new FileStatus(meta.getLength(), false, 1, getDefaultBlockSize(),
-    return new FileStatus(0, true, 1, MAX_S3_FILE_SIZE, 0,
-        path.makeQualified(this));
+    return new FileStatus(0, true, 1, 0, 0, path.makeQualified(this));
-            "Can't make directory for path %s since it is a file.", f));
+            "Can't make directory for path '%s' since it is a file.", f));
+      LOG.debug("Making dir '" + f + "' in S3");
-    if (!exists(f)) {
-      throw new FileNotFoundException(f.toString());
+    FileStatus fs = getFileStatus(f); // will throw if the file doesn't exist
+    if (fs.isDir()) {
+      throw new IOException("'" + f + "' is a directory");
+    LOG.info("Opening '" + f + "' for reading");
-      Path parent = path.getParent();
-      if (parent != null) {
-          String key = pathToKey(makeAbsolute(parent));
-          if (key.length() > 0) {
-              store.storeEmptyFile(key + FOLDER_SUFFIX);
-          }
+    Path parent = path.getParent();
+    if (parent != null) {
+      String key = pathToKey(makeAbsolute(parent));
+      if (key.length() > 0) {
+          store.storeEmptyFile(key + FOLDER_SUFFIX);
+    }
-  private boolean existsAndIsFile(Path f) throws IOException {
-    Path absolutePath = makeAbsolute(f);
-    String key = pathToKey(absolutePath);
-    
-    if (key.length() == 0) {
-        return false;
-    }
-    
-    FileMetadata meta = store.retrieveMetadata(key);
-    if (meta != null) {
-        // S3 object with given key exists, so this is a file
-        return true;
-    }
-    
-    if (store.retrieveMetadata(key + FOLDER_SUFFIX) != null) {
-        // Signifies empty directory
-        return false;
-    }
-    
-    PartialListing listing = store.list(key, 1, null);
-    if (listing.getFiles().length > 0 ||
-        listing.getCommonPrefixes().length > 0) {
-        // Non-empty directory
-        return false;
-    }
-    
-    throw new FileNotFoundException(absolutePath +
-        ": No such file or directory");
-}
-
-
+    final String debugPreamble = "Renaming '" + src + "' to '" + dst + "' - ";
+
-      boolean dstIsFile = existsAndIsFile(dst);
+      boolean dstIsFile = !getFileStatus(dst).isDir();
-        // Attempting to overwrite a file using rename()
+        LOG.debug(debugPreamble + "returning false as dst is an already existing file");
-        // Move to within the existent directory
+        LOG.debug(debugPreamble + "using dst as output directory");
-      // dst doesn't exist, so we can proceed
+      LOG.debug(debugPreamble + "using dst as output destination");
-          return false; // parent dst is a file
+          LOG.debug(debugPreamble + "returning false as dst parent exists and is a file");
+          return false;
-        return false; // parent dst does not exist
+        LOG.debug(debugPreamble + "returning false as dst parent does not exist");
+        return false;
+    boolean srcIsFile;
-      boolean srcIsFile = existsAndIsFile(src);
-      if (srcIsFile) {
-        store.rename(srcKey, dstKey);
-      } else {
-        // Move the folder object
-        store.delete(srcKey + FOLDER_SUFFIX);
-        store.storeEmptyFile(dstKey + FOLDER_SUFFIX);
-
-        // Move everything inside the folder
-        String priorLastKey = null;
-        do {
-          PartialListing listing = store.listAll(srcKey, S3_MAX_LISTING_LENGTH,
-              priorLastKey);
-          for (FileMetadata file : listing.getFiles()) {
-            store.rename(file.getKey(), dstKey
-                + file.getKey().substring(srcKey.length()));
-          }
-          priorLastKey = listing.getPriorLastKey();
-        } while (priorLastKey != null);
-      }
-
-      createParent(src);
-      return true;
-
+      srcIsFile = !getFileStatus(src).isDir();
-      // Source file does not exist;
+      LOG.debug(debugPreamble + "returning false as src does not exist");
-  }
+    if (srcIsFile) {
+      LOG.debug(debugPreamble + "src is file, so doing copy then delete in S3");
+      store.copy(srcKey, dstKey);
+      store.delete(srcKey);
+    } else {
+      LOG.debug(debugPreamble + "src is directory, so copying contents");
+      store.storeEmptyFile(dstKey + FOLDER_SUFFIX);
+      List<String> keysToDelete = new ArrayList<String>();
+      String priorLastKey = null;
+      do {
+        PartialListing listing = store.list(srcKey, S3_MAX_LISTING_LENGTH, priorLastKey, true);
+        for (FileMetadata file : listing.getFiles()) {
+          keysToDelete.add(file.getKey());
+          store.copy(file.getKey(), dstKey + file.getKey().substring(srcKey.length()));
+        }
+        priorLastKey = listing.getPriorLastKey();
+      } while (priorLastKey != null);
+
+      LOG.debug(debugPreamble + "all files in src copied, now removing src files");
+      for (String key: keysToDelete) {
+        store.delete(key);
+      }
+
+      try {
+        store.delete(srcKey + FOLDER_SUFFIX);
+      } catch (FileNotFoundException e) {
+        //this is fine, we don't require a marker
+      }
+      LOG.debug(debugPreamble + "done");
+    }
+
+    return true;
+  }
+  
+  @Override
+  public long getDefaultBlockSize() {
+    return getConf().getLong("fs.s3n.block.size", 64 * 1024 * 1024);
+  }
-

INS26 INS26 INS40 INS40 INS31 INS31 INS31 INS83 INS83 MOV43 INS42 MOV44 INS8 INS78 MOV78 MOV83 MOV39 MOV42 MOV44 MOV44 MOV43 INS8 INS78 INS83 INS39 INS42 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS78 INS78 INS78 INS78 INS78 INS78 INS21 INS25 MOV25 INS60 INS25 INS41 INS42 INS74 INS42 INS25 INS21 UPD42 MOV60 MOV54 MOV60 MOV60 INS25 MOV41 INS21 INS21 INS21 INS60 INS21 INS60 MOV60 INS54 MOV25 MOV41 INS42 INS41 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS21 INS21 INS21 INS32 INS27 INS8 INS43 INS59 INS27 INS8 INS42 INS43 INS43 MOV32 INS8 INS8 INS32 MOV32 INS8 INS8 INS32 INS8 INS32 MOV8 INS32 MOV43 INS59 INS32 INS32 INS83 INS43 INS59 INS8 MOV12 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS45 INS42 INS27 INS32 MOV41 INS42 INS42 MOV32 INS32 INS36 INS21 INS42 INS42 INS25 MOV25 INS42 INS42 INS27 MOV25 INS21 INS21 MOV60 INS19 INS54 INS21 INS21 INS21 INS42 INS42 INS27 INS21 INS21 MOV41 INS42 INS42 INS27 INS21 INS42 INS42 INS27 INS32 INS34 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS27 INS42 INS42 INS27 MOV21 INS21 INS21 INS21 INS60 INS21 INS70 INS54 INS21 INS32 INS42 INS45 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS33 INS45 INS42 INS32 INS45 INS42 INS42 INS45 INS27 INS7 INS32 INS8 INS25 INS53 INS45 INS42 INS45 INS21 INS32 INS32 UPD43 INS8 INS27 INS8 INS12 INS32 INS32 INS32 INS45 INS42 INS45 INS32 INS32 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS45 UPD45 MOV43 INS32 INS42 INS21 INS42 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS21 INS7 INS21 INS32 INS32 INS32 INS74 INS59 INS32 INS44 INS42 MOV8 INS8 INS12 INS32 UPD42 MOV42 INS34 INS34 INS34 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS22 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS32 INS42 INS32 INS42 INS32 INS27 INS42 INS32 INS42 INS42 INS40 INS41 INS38 INS8 INS32 MOV14 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS27 UPD42 UPD42 INS33 INS60 INS70 INS21 UPD42 MOV42 MOV33 MOV21 INS44 INS8 UPD42 MOV42 UPD42 MOV42 MOV27 INS42 INS42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS25 INS42 INS42 INS32 MOV43 INS27 INS38 INS21 INS21 INS32 INS42 INS38 INS32 INS42 INS42 INS27 UPD42 INS42 INS42 INS42 INS42 INS42 INS27 INS43 INS43 INS42 INS14 INS42 INS42 INS27 INS43 INS42 MOV21 INS44 INS8 INS42 INS42 INS27 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS34 INS42 INS42 INS34 INS27 INS32 INS32 INS53 INS42 INS42 INS40 INS32 INS42 INS42 INS27 UPD42 INS22 INS45 INS42 INS45 MOV43 INS59 INS44 INS32 INS8 INS7 INS43 INS42 INS45 UPD42 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS42 INS45 INS45 INS42 INS45 INS9 INS32 INS8 MOV25 INS42 INS42 INS27 INS45 INS42 INS45 INS32 INS32 INS32 INS42 INS42 INS27 INS32 INS42 INS42 INS27 INS42 INS45 INS42 INS45 INS42 INS42 INS74 INS42 INS45 INS42 INS43 INS42 INS42 INS45 INS42 INS42 INS32 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS14 INS42 INS42 INS40 UPD45 MOV32 INS45 INS42 INS45 MOV32 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS42 INS32 INS42 INS32 INS42 INS27 INS45 INS42 INS45 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS45 INS21 INS32 INS42 INS42 INS45 INS43 INS43 INS21 INS42 INS42 INS42 INS43 INS27 UPD45 INS42 UPD45 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS9 MOV42 INS32 INS42 INS42 INS42 INS42 INS42 INS45 UPD45 UPD42 MOV42 MOV42 INS42 INS45 INS42 INS45 INS21 INS32 UPD42 MOV42 MOV42 INS42 INS42 UPD42 INS9 INS32 INS42 INS45 INS42 MOV42 UPD42 MOV42 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS32 UPD42 INS42 UPD42 MOV42 INS42 INS42 INS27 INS42 INS45 INS42 INS42 INS42 INS45 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL34 DEL34 DEL34 DEL27 DEL59 DEL23 DEL83 DEL83 DEL42 DEL8 DEL31 DEL39 DEL42 DEL42 DEL42 DEL53 DEL8 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL44 DEL42 DEL42 DEL32 DEL32 DEL38 DEL9 DEL41 DEL8 DEL25 DEL8 DEL70 DEL8 DEL25 DEL8 DEL31 DEL8 DEL34 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL34 DEL27 DEL9 DEL41 DEL8 DEL25 DEL43 DEL42 DEL32 DEL59 DEL60 DEL27 DEL9 DEL41 DEL8 DEL25 DEL32 DEL33 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL34 DEL33 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL22 DEL34 DEL27 DEL42 DEL32 DEL42 DEL22 DEL34 DEL27 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL31 DEL32 DEL42 DEL42 DEL32 DEL32 DEL8 DEL54
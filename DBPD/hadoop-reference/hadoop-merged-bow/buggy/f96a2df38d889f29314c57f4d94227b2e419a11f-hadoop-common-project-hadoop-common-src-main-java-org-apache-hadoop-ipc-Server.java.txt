HADOOP-16266. Add more fine-grained processing time metrics to the RPC layer. Contributed by Christopher Gregorian.

+import static org.apache.hadoop.ipc.ProcessingDetails.Timing;
+import java.util.concurrent.TimeUnit;
-  void logSlowRpcCalls(String methodName, int processingTime) {
+  void logSlowRpcCalls(String methodName, Call call, long processingTime) {
-      if(LOG.isWarnEnabled()) {
-        String client = CurCall.get().toString();
-        LOG.warn(
-            "Slow RPC : " + methodName + " took " + processingTime +
-                " milliseconds to process from client " + client);
-      }
+      LOG.warn("Slow RPC : {} took {} {} to process from client {}",
+          methodName, processingTime, RpcMetrics.TIMEUNIT, call);
-  void updateMetrics(String name, int queueTime, int processingTime,
-                     boolean deferredCall) {
+  void updateMetrics(Call call, long startTime, boolean connDropped) {
+    // delta = handler + processing + response
+    long deltaNanos = Time.monotonicNowNanos() - startTime;
+    long timestampNanos = call.timestampNanos;
+
+    ProcessingDetails details = call.getProcessingDetails();
+    // queue time is the delta between when the call first arrived and when it
+    // began being serviced, minus the time it took to be put into the queue
+    details.set(Timing.QUEUE,
+        startTime - timestampNanos - details.get(Timing.ENQUEUE));
+    deltaNanos -= details.get(Timing.PROCESSING);
+    deltaNanos -= details.get(Timing.RESPONSE);
+    details.set(Timing.HANDLER, deltaNanos);
+
+    long queueTime = details.get(Timing.QUEUE, RpcMetrics.TIMEUNIT);
-    if (!deferredCall) {
-      rpcMetrics.addRpcProcessingTime(processingTime);
-      rpcDetailedMetrics.addProcessingTime(name, processingTime);
-      callQueue.addResponseTime(name, getPriorityLevel(), queueTime,
-          processingTime);
-      if (isLogSlowRPC()) {
-        logSlowRpcCalls(name, processingTime);
-      }
+
+    if (call.isResponseDeferred() || connDropped) {
+      // call was skipped; don't include it in processing metrics
+      return;
+    }
+
+    long processingTime =
+        details.get(Timing.PROCESSING, RpcMetrics.TIMEUNIT);
+    long waitTime =
+        details.get(Timing.LOCKWAIT, RpcMetrics.TIMEUNIT);
+    rpcMetrics.addRpcLockWaitTime(waitTime);
+    rpcMetrics.addRpcProcessingTime(processingTime);
+    // don't include lock wait for detailed metrics.
+    processingTime -= waitTime;
+    String name = call.getDetailedMetricsName();
+    rpcDetailedMetrics.addProcessingTime(name, processingTime);
+    callQueue.addResponseTime(name, call, details);
+    if (isLogSlowRPC()) {
+      logSlowRpcCalls(name, call, processingTime);
+    private final ProcessingDetails processingDetails =
+        new ProcessingDetails(TimeUnit.NANOSECONDS);
+    // the method name to use in metrics
+    private volatile String detailedMetricsName = "";
-    long timestamp;              // time received when response is null
+    long timestampNanos;         // time received when response is null
-      this.timestamp = Time.now();
+      this.timestampNanos = Time.monotonicNowNanos();
+    /**
+     * Indicates whether the call has been processed. Always true unless
+     * overridden.
+     *
+     * @return true
+     */
+    boolean isOpen() {
+      return true;
+    }
+
+    String getDetailedMetricsName() {
+      return detailedMetricsName;
+    }
+
+    void setDetailedMetricsName(String name) {
+      detailedMetricsName = name;
+    }
+
+    public ProcessingDetails getProcessingDetails() {
+      return processingDetails;
+    }
+
+    @Override
+    boolean isOpen() {
+      return connection.channel.isOpen();
+    }
+
+
+      long startNanos = Time.monotonicNowNanos();
-            rpcKind, connection.protocolName, rpcRequest, timestamp);
+            rpcKind, connection.protocolName, rpcRequest, timestampNanos);
+        long deltaNanos = Time.monotonicNowNanos() - startNanos;
+        ProcessingDetails details = getProcessingDetails();
+
+        details.set(Timing.PROCESSING, deltaNanos, TimeUnit.NANOSECONDS);
+        deltaNanos -= details.get(Timing.LOCKWAIT, TimeUnit.NANOSECONDS);
+        deltaNanos -= details.get(Timing.LOCKSHARED, TimeUnit.NANOSECONDS);
+        deltaNanos -= details.get(Timing.LOCKEXCLUSIVE, TimeUnit.NANOSECONDS);
+        details.set(Timing.LOCKFREE, deltaNanos, TimeUnit.NANOSECONDS);
+        startNanos = Time.monotonicNowNanos();
+
+
+        deltaNanos = Time.monotonicNowNanos() - startNanos;
+        details.set(Timing.RESPONSE, deltaNanos, TimeUnit.NANOSECONDS);
+  private final static long PURGE_INTERVAL_NANOS = TimeUnit.NANOSECONDS.convert(
+      15, TimeUnit.MINUTES);
+
-    
-    final static int PURGE_INTERVAL = 900000; // 15mins
-      long lastPurgeTime = 0;   // last check for old calls.
+      long lastPurgeTimeNanos = 0;   // last check for old calls.
-          writeSelector.select(PURGE_INTERVAL);
+          writeSelector.select(PURGE_INTERVAL_NANOS);
-          long now = Time.now();
-          if (now < lastPurgeTime + PURGE_INTERVAL) {
+          long nowNanos = Time.monotonicNowNanos();
+          if (nowNanos < lastPurgeTimeNanos + PURGE_INTERVAL_NANOS) {
-          lastPurgeTime = now;
+          lastPurgeTimeNanos = nowNanos;
-            doPurge(call, now);
+            doPurge(call, nowNanos);
-          if (now > call.timestamp + PURGE_INTERVAL) {
+          if (now > call.timestampNanos + PURGE_INTERVAL_NANOS) {
-              call.timestamp = Time.now();
+              call.timestampNanos = Time.monotonicNowNanos();
+      long deltaNanos = Time.monotonicNowNanos() - call.timestampNanos;
+      call.getProcessingDetails().set(Timing.ENQUEUE, deltaNanos,
+          TimeUnit.NANOSECONDS);
+        Call call = null;
+        long startTimeNanos = 0;
+        // True iff the connection for this call has been dropped.
+        // Set to true by default and update to false later if the connection
+        // can be succesfully read.
+        boolean connDropped = true;
+
-          final Call call = callQueue.take(); // pop the queue; maybe blocked here
+          call = callQueue.take(); // pop the queue; maybe blocked here
+          startTimeNanos = Time.monotonicNowNanos();
+          connDropped = !call.isOpen();
+          if (call != null) {
+            updateMetrics(call, startTimeNanos, connDropped);
+            ProcessingDetails.LOG.debug(
+                "Served: [{}]{} name={} user={} details={}",
+                call, (call.isResponseDeferred() ? ", deferred" : ""),
+                call.getDetailedMetricsName(), call.getRemoteUser(),
+                call.getProcessingDetails());
+          }

INS26 INS26 INS40 INS40 INS23 INS44 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS39 INS59 INS43 INS42 UPD39 MOV25 INS43 INS42 UPD39 UPD42 UPD42 INS60 INS60 INS60 INS21 INS21 INS21 INS21 INS60 INS25 INS60 INS60 INS21 MOV21 INS21 INS60 MOV21 MOV21 MOV25 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS29 INS39 INS42 INS8 INS43 INS42 INS8 INS39 INS42 MOV44 INS8 INS83 INS43 INS42 INS8 INS78 INS39 INS42 INS8 INS42 INS32 INS42 MOV27 INS42 INS39 INS59 INS39 INS59 INS43 INS59 INS32 INS7 INS7 INS32 INS39 INS59 INS27 INS8 INS39 INS59 INS39 INS59 INS32 INS7 MOV43 INS59 INS42 INS42 INS14 INS42 INS42 INS45 UPD42 INS65 INS65 INS41 INS42 INS41 INS21 INS42 INS41 INS42 INS41 INS60 INS40 INS42 INS34 INS40 MOV21 INS42 INS27 INS42 INS40 INS42 INS42 INS32 INS42 INS42 INS40 INS27 INS42 INS32 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS32 INS32 INS42 INS41 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 INS43 INS40 INS66 INS66 INS66 INS9 INS42 INS7 INS42 INS32 INS39 INS59 INS60 INS21 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS40 INS40 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS32 INS60 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 UPD42 INS39 INS59 INS32 INS60 INS60 INS60 INS45 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 UPD42 UPD42 INS42 INS42 INS39 INS59 INS43 INS59 INS32 INS7 INS7 INS7 INS32 INS7 INS7 INS32 INS42 INS27 INS32 INS42 INS40 INS42 INS40 MOV43 INS59 INS39 INS59 INS39 INS59 INS8 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS40 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS40 INS42 INS40 INS42 INS32 INS42 INS27 INS42 INS42 INS40 INS42 INS40 INS32 INS40 INS42 INS42 INS42 INS33 INS42 INS34 INS42 INS9 INS21 INS21 INS21 MOV21 MOV21 INS25 UPD42 INS32 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS40 INS40 INS42 INS42 INS40 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS7 INS7 INS7 INS27 INS8 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 MOV32 INS42 INS32 INS42 INS38 INS42 INS33 INS21 INS21 UPD42 UPD42 UPD42 UPD40 UPD42 INS42 INS42 INS32 INS32 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS45 INS42 INS36 INS32 INS32 INS32 INS16 INS42 INS42 INS42 INS42 INS42 INS42 UPD40 INS32 INS45 INS45 UPD42 INS42 INS42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL8 DEL25 DEL39 DEL42 DEL32 DEL42 DEL42 DEL38 DEL8 DEL25 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL42 DEL59 DEL60 DEL8
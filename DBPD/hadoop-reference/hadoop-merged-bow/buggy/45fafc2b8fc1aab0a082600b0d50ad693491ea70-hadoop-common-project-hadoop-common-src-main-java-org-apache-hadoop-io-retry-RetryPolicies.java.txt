HDFS-3504. Support configurable retry policy in DFSClient for RPC connections and RPC calls, and add MultipleLinearRandomRetry, a new retry policy.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1349124 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
-import java.util.Random;
+import java.util.Random;
-import com.google.common.annotations.VisibleForTesting;
-
-  private static final Random RAND = new Random();
+  private static ThreadLocal<Random> RANDOM = new ThreadLocal<Random>() {
+    @Override
+    protected Random initialValue() {
+      return new Random();
+    }
+  };
+  /**
+   * Retry up to maxRetries.
+   * The actual sleep time of the n-th retry is f(n, sleepTime),
+   * where f is a function provided by the subclass implementation.
+   *
+   * The object of the subclasses should be immutable;
+   * otherwise, the subclass must override hashCode(), equals(..) and toString().
+   */
-    int maxRetries;
-    long sleepTime;
-    TimeUnit timeUnit;
+    final int maxRetries;
+    final long sleepTime;
+    final TimeUnit timeUnit;
-    public RetryLimited(int maxRetries, long sleepTime, TimeUnit timeUnit) {
+    private String myString;
+
+    RetryLimited(int maxRetries, long sleepTime, TimeUnit timeUnit) {
+      if (maxRetries < 0) {
+        throw new IllegalArgumentException("maxRetries = " + maxRetries+" < 0");
+      }
+      if (sleepTime < 0) {
+        throw new IllegalArgumentException("sleepTime = " + sleepTime + " < 0");
+      }
+
+    @Override
+    
+    @Override
+    public int hashCode() {
+      return toString().hashCode();
+    }
+    
+    @Override
+    public boolean equals(final Object that) {
+      if (this == that) {
+        return true;
+      } else if (that == null || this.getClass() != that.getClass()) {
+        return false;
+      }
+      return this.toString().equals(that.toString());
+    }
+
+    @Override
+    public String toString() {
+      if (myString == null) {
+        myString = getClass().getSimpleName() + "(maxRetries=" + maxRetries
+            + ", sleepTime=" + sleepTime + " " + timeUnit + ")";
+      }
+      return myString;
+    }
+  /**
+   * Given pairs of number of retries and sleep time (n0, t0), (n1, t1), ...,
+   * the first n0 retries sleep t0 milliseconds on average,
+   * the following n1 retries sleep t1 milliseconds on average, and so on.
+   * 
+   * For all the sleep, the actual sleep time is randomly uniform distributed
+   * in the close interval [0.5t, 1.5t], where t is the sleep time specified.
+   *
+   * The objects of this class are immutable.
+   */
+  public static class MultipleLinearRandomRetry implements RetryPolicy {
+    /** Pairs of numRetries and sleepSeconds */
+    public static class Pair {
+      final int numRetries;
+      final int sleepMillis;
+      
+      public Pair(final int numRetries, final int sleepMillis) {
+        if (numRetries < 0) {
+          throw new IllegalArgumentException("numRetries = " + numRetries+" < 0");
+        }
+        if (sleepMillis < 0) {
+          throw new IllegalArgumentException("sleepMillis = " + sleepMillis + " < 0");
+        }
+
+        this.numRetries = numRetries;
+        this.sleepMillis = sleepMillis;
+      }
+      
+      @Override
+      public String toString() {
+        return numRetries + "x" + sleepMillis + "ms";
+      }
+    }
+
+    private final List<Pair> pairs;
+    private String myString;
+
+    public MultipleLinearRandomRetry(List<Pair> pairs) {
+      if (pairs == null || pairs.isEmpty()) {
+        throw new IllegalArgumentException("pairs must be neither null nor empty.");
+      }
+      this.pairs = Collections.unmodifiableList(pairs);
+    }
+
+    @Override
+    public RetryAction shouldRetry(Exception e, int curRetry, int failovers,
+        boolean isMethodIdempotent) throws Exception {
+      final Pair p = searchPair(curRetry);
+      if (p == null) {
+        //no more retries.
+        return RetryAction.FAIL;
+      }
+
+      //calculate sleep time and return.
+      final double ratio = RANDOM.get().nextDouble() + 0.5;//0.5 <= ratio <=1.5
+      final long sleepTime = Math.round(p.sleepMillis * ratio);
+      return new RetryAction(RetryAction.RetryDecision.RETRY, sleepTime);
+    }
+
+    /**
+     * Given the current number of retry, search the corresponding pair.
+     * @return the corresponding pair,
+     *   or null if the current number of retry > maximum number of retry. 
+     */
+    private Pair searchPair(int curRetry) {
+      int i = 0;
+      for(; i < pairs.size() && curRetry > pairs.get(i).numRetries; i++) {
+        curRetry -= pairs.get(i).numRetries;
+      }
+      return i == pairs.size()? null: pairs.get(i);
+    }
+    
+    @Override
+    public int hashCode() {
+      return toString().hashCode();
+    }
+    
+    @Override
+    public boolean equals(final Object that) {
+      if (this == that) {
+        return true;
+      } else if (that == null || this.getClass() != that.getClass()) {
+        return false;
+      }
+      return this.toString().equals(that.toString());
+    }
+
+    @Override
+    public String toString() {
+      if (myString == null) {
+        myString = getClass().getSimpleName() + pairs;
+      }
+      return myString;
+    }
+
+    /**
+     * Parse the given string as a MultipleLinearRandomRetry object.
+     * The format of the string is "t_1, n_1, t_2, n_2, ...",
+     * where t_i and n_i are the i-th pair of sleep time and number of retires.
+     * Note that the white spaces in the string are ignored.
+     *
+     * @return the parsed object, or null if the parsing fails.
+     */
+    public static MultipleLinearRandomRetry parseCommaSeparatedString(String s) {
+      final String[] elements = s.split(",");
+      if (elements.length == 0) {
+        LOG.warn("Illegal value: there is no element in \"" + s + "\".");
+        return null;
+      }
+      if (elements.length % 2 != 0) {
+        LOG.warn("Illegal value: the number of elements in \"" + s + "\" is "
+            + elements.length + " but an even number of elements is expected.");
+        return null;
+      }
+
+      final List<RetryPolicies.MultipleLinearRandomRetry.Pair> pairs
+          = new ArrayList<RetryPolicies.MultipleLinearRandomRetry.Pair>();
+   
+      for(int i = 0; i < elements.length; ) {
+        //parse the i-th sleep-time
+        final int sleep = parsePositiveInt(elements, i++, s);
+        if (sleep == -1) {
+          return null; //parse fails
+        }
+
+        //parse the i-th number-of-retries
+        final int retries = parsePositiveInt(elements, i++, s);
+        if (retries == -1) {
+          return null; //parse fails
+        }
+
+        pairs.add(new RetryPolicies.MultipleLinearRandomRetry.Pair(retries, sleep));
+      }
+      return new RetryPolicies.MultipleLinearRandomRetry(pairs);
+    }
+
+    /**
+     * Parse the i-th element as an integer.
+     * @return -1 if the parsing fails or the parsed value <= 0;
+     *   otherwise, return the parsed value.
+     */
+    private static int parsePositiveInt(final String[] elements,
+        final int i, final String originalString) {
+      final String s = elements[i].trim();
+      final int n;
+      try {
+        n = Integer.parseInt(s);
+      } catch(NumberFormatException nfe) {
+        LOG.warn("Failed to parse \"" + s + "\", which is the index " + i
+            + " element in \"" + originalString + "\"", nfe);
+        return -1;
+      }
+
+      if (n <= 0) {
+        LOG.warn("The value " + n + " <= 0: it is parsed from the string \""
+            + s + "\" which is the index " + i + " element in \""
+            + originalString + "\"");
+        return -1;
+      }
+      return n;
+    }
+  }
+
+
+      if (maxRetries < 0) {
+        throw new IllegalArgumentException("maxRetries = " + maxRetries + " < 0");
+      } else if (maxRetries >= Long.SIZE - 1) {
+        //calculateSleepTime may overflow. 
+        throw new IllegalArgumentException("maxRetries = " + maxRetries
+            + " >= " + (Long.SIZE - 1));
+      }
-  @VisibleForTesting
-  public static long calculateExponentialTime(long time, int retries,
+  private static long calculateExponentialTime(long time, int retries,
-    long baseTime = Math.min(time * ((long)1 << retries), cap);
-    return (long) (baseTime * (RAND.nextFloat() + 0.5));
+    long baseTime = Math.min(time * (1L << retries), cap);
+    return (long) (baseTime * (RANDOM.get().nextDouble() + 0.5));

MOV26 MOV26 INS26 INS26 INS40 UPD40 INS40 INS23 INS55 INS31 MOV83 MOV83 INS74 INS59 INS29 INS23 INS31 INS31 INS31 INS29 INS83 INS83 INS42 INS43 INS55 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV29 INS83 INS83 MOV39 MOV42 MOV44 MOV44 MOV44 MOV8 INS43 INS43 INS42 INS14 INS65 INS83 INS83 INS83 INS83 INS43 INS59 INS78 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS65 INS42 INS29 INS83 INS83 INS42 INS23 INS23 INS31 INS31 INS83 INS83 INS74 INS59 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS8 MOV78 MOV83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS29 INS83 MOV83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS8 INS42 INS42 INS74 INS1 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS25 INS25 INS42 INS42 INS41 INS42 INS83 INS43 INS42 INS25 INS41 INS42 INS42 INS25 INS41 INS66 INS66 INS66 INS66 INS66 INS66 INS65 MOV83 INS39 INS59 INS83 INS39 INS59 INS83 INS42 INS44 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS43 INS43 INS42 INS42 INS42 INS74 INS42 INS25 INS21 INS42 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS42 INS60 INS25 INS60 INS60 INS41 INS65 INS65 INS42 INS39 INS42 INS60 INS24 INS41 UPD42 INS41 INS42 INS83 INS43 INS42 INS25 INS41 INS42 INS42 INS25 INS41 INS65 INS65 INS42 INS43 INS42 INS60 INS25 INS25 INS60 INS24 INS41 INS65 INS65 INS83 INS5 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS60 INS60 INS54 INS25 INS41 MOV46 INS25 INS43 INS43 INS31 INS27 INS8 INS27 INS8 INS32 INS42 INS27 INS8 INS25 INS32 INS27 INS8 INS42 INS66 INS42 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS25 INS25 INS21 INS21 INS42 INS42 INS41 INS42 INS42 INS43 INS43 INS27 INS8 INS7 INS42 INS83 INS43 INS59 INS27 INS8 INS83 INS39 INS59 INS83 INS39 INS59 INS14 INS66 INS66 INS66 INS39 INS59 INS27 INS37 INS8 INS16 INS32 INS42 INS27 INS8 INS25 INS32 INS27 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS83 INS5 INS59 INS27 INS8 INS27 INS8 INS83 INS74 INS59 INS58 INS27 INS8 INS14 INS66 INS66 INS66 INS43 INS85 INS42 INS83 INS43 INS59 INS83 INS39 INS59 INS8 INS12 INS27 INS8 INS42 INS27 INS8 INS25 INS42 INS42 INS78 INS83 MOV43 INS42 INS8 INS42 INS34 INS53 INS42 INS34 INS53 INS32 INS42 INS52 INS42 INS41 INS27 INS8 INS32 INS42 INS32 INS42 INS33 INS21 INS27 INS8 INS27 INS8 INS7 INS7 INS27 INS42 INS42 INS27 INS32 INS53 INS22 INS32 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS27 INS42 INS32 INS43 INS40 INS42 INS42 INS34 INS27 INS27 INS42 INS21 INS27 INS33 INS32 INS32 INS42 INS52 INS42 INS41 INS27 INS8 INS32 INS42 INS32 INS42 INS33 INS21 INS43 INS85 INS42 INS32 INS40 INS34 INS21 INS41 INS27 INS34 INS21 INS41 INS43 INS43 INS42 INS14 INS39 INS59 INS42 INS40 INS60 INS25 INS60 INS25 INS21 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS21 INS44 INS8 INS42 INS34 INS21 INS41 INS42 INS34 INS53 INS27 INS8 INS42 INS41 INS14 INS14 INS42 INS9 INS27 INS27 INS41 INS52 INS42 INS42 INS42 INS7 INS42 INS34 INS53 INS42 INS34 INS53 INS22 INS42 INS22 INS42 INS42 INS45 INS42 INS45 INS42 INS33 INS42 INS42 INS14 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS32 INS34 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS22 INS7 INS42 INS32 INS42 INS42 INS42 INS42 INS9 INS27 INS27 INS41 INS52 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS45 INS32 INS33 INS40 INS34 INS32 INS33 INS42 INS40 INS74 INS42 INS34 INS83 INS39 INS59 INS27 INS8 INS83 INS39 INS59 INS27 INS8 INS32 INS40 INS2 INS42 INS7 INS43 INS42 INS21 INS41 INS32 INS38 INS14 INS42 INS27 INS53 MOV14 INS43 INS27 INS43 INS27 INS42 INS33 INS32 INS32 INS9 INS42 INS27 INS14 INS14 INS52 INS42 INS52 INS42 INS43 INS45 INS32 INS42 INS40 INS42 INS42 INS42 INS32 INS42 INS42 INS22 INS42 INS42 INS42 INS33 INS32 INS32 INS9 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS43 INS43 INS42 INS32 INS42 INS38 INS41 INS42 INS32 INS42 INS38 INS41 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS32 INS38 INS42 INS42 INS27 INS34 INS43 INS27 INS40 INS34 INS14 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS52 INS42 INS42 INS42 INS32 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS43 INS27 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS40 INS45 INS42 INS40 INS42 INS42 INS37 INS42 INS34 INS33 INS42 INS42 INS37 INS42 INS34 INS33 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS34 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS43 INS27 INS34 INS32 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS36 INS32 UPD42 INS42 INS42 INS27 UPD42 MOV42 INS42 INS40 INS34 DEL42 DEL59 DEL23 DEL83 DEL8 DEL39 DEL34 DEL11 DEL31
HADOOP-14556. S3A to support Delegation Tokens.

Contributed by Steve Loughran and Daryn Sharp.

-import com.amazonaws.auth.InstanceProfileCredentialsProvider;
+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.fs.s3a.auth.IAMInstanceCredentialsProvider;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+  /**
+   * Error message when the AWS provider list built up contains a forbidden
+   * entry.
+   */
+  @VisibleForTesting
+  public static final String E_FORBIDDEN_AWS_PROVIDER
+      = "AWS provider class cannot be used";
-        path != null ? (" on " + path) : "",
+        StringUtils.isNotEmpty(path)? (" on " + path) : "",
+   * The standard AWS provider list for AWS connections.
+   */
+  public static final List<Class<?>>
+      STANDARD_AWS_PROVIDERS = Collections.unmodifiableList(
+      Arrays.asList(
+          TemporaryAWSCredentialsProvider.class,
+          SimpleAWSCredentialsProvider.class,
+          EnvironmentVariableCredentialsProvider.class,
+          IAMInstanceCredentialsProvider.class));
+
+  /**
-   * @param binding Binding URI, may contain user:pass login details;
-   * may be null
+   * @param binding Binding URI -may be null
-      URI binding, Configuration conf) throws IOException {
-    AWSCredentialProviderList credentials = new AWSCredentialProviderList();
-
-    Class<?>[] awsClasses = loadAWSProviderClasses(conf,
-        AWS_CREDENTIALS_PROVIDER);
-    if (awsClasses.length == 0) {
-      credentials.add(new SimpleAWSCredentialsProvider(binding, conf));
-      credentials.add(new EnvironmentVariableCredentialsProvider());
-      credentials.add(InstanceProfileCredentialsProvider.getInstance());
-    } else {
-      for (Class<?> aClass : awsClasses) {
-        credentials.add(createAWSCredentialProvider(conf,
-            aClass,
-            binding));
-      }
-    }
+      @Nullable URI binding,
+      Configuration conf) throws IOException {
+    // this will reject any user:secret entries in the URI
+    S3xLoginHelper.rejectSecretsInURIs(binding);
+    AWSCredentialProviderList credentials =
+        buildAWSProviderList(binding,
+            conf,
+            AWS_CREDENTIALS_PROVIDER,
+            STANDARD_AWS_PROVIDERS,
+            new HashSet<>());
-        S3xLoginHelper.toString(binding), credentials);
+        binding, credentials);
-  public static Class<?>[] loadAWSProviderClasses(Configuration conf,
+  public static List<Class<?>> loadAWSProviderClasses(Configuration conf,
-      return conf.getClasses(key, defaultValue);
+      return Arrays.asList(conf.getClasses(key, defaultValue));
+   * Load list of AWS credential provider/credential provider factory classes;
+   * support a forbidden list to prevent loops, mandate full secrets, etc.
+   * @param binding Binding URI -may be null
+   * @param conf configuration
+   * @param key key
+   * @param forbidden a possibly empty set of forbidden classes.
+   * @param defaultValues list of default providers.
+   * @return the list of classes, possibly empty
+   * @throws IOException on a failure to load the list.
+   */
+  public static AWSCredentialProviderList buildAWSProviderList(
+      @Nullable final URI binding,
+      final Configuration conf,
+      final String key,
+      final List<Class<?>> defaultValues,
+      final Set<Class<?>> forbidden) throws IOException {
+
+    // build up the base provider
+    List<Class<?>> awsClasses = loadAWSProviderClasses(conf,
+        key,
+        defaultValues.toArray(new Class[defaultValues.size()]));
+    // and if the list is empty, switch back to the defaults.
+    // this is to address the issue that configuration.getClasses()
+    // doesn't return the default if the config value is just whitespace.
+    if (awsClasses.isEmpty()) {
+      awsClasses = defaultValues;
+    }
+    // iterate through, checking for blacklists and then instantiating
+    // each provider
+    AWSCredentialProviderList providers = new AWSCredentialProviderList();
+    for (Class<?> aClass : awsClasses) {
+
+      if (forbidden.contains(aClass)) {
+        throw new IOException(E_FORBIDDEN_AWS_PROVIDER
+            + " in option " + key + ": " + aClass);
+      }
+      providers.add(createAWSCredentialProvider(conf,
+          aClass, binding));
+    }
+    return providers;
+  }
+
+  /**
+   * <li>a public constructor accepting
+   *    org.apache.hadoop.conf.Configuration</li>
-  public static AWSCredentialsProvider createAWSCredentialProvider(
+  private static AWSCredentialsProvider createAWSCredentialProvider(
-      URI uri) throws IOException {
-    AWSCredentialsProvider credentials;
+      @Nullable URI uri) throws IOException {
+    AWSCredentialsProvider credentials = null;
-          + "accepting Configuration, or a public factory method named "
-          + "getInstance that accepts no arguments, or a public default "
-          + "constructor.", className, AWS_CREDENTIALS_PROVIDER));
+          + "of a supported signature, or a public factory method named "
+          + "getInstance that accepts no arguments.",
+          className, AWS_CREDENTIALS_PROVIDER));
+   * Set a key if the value is non-empty.
+   * @param config config to patch
+   * @param key key to set
+   * @param val value to probe and set
+   * @param origin origin
+   * @return true if the property was set
+   */
+  public static boolean setIfDefined(Configuration config, String key,
+      String val, String origin) {
+    if (StringUtils.isNotEmpty(val)) {
+      config.set(key, val, origin);
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  /**
-  static String getServerSideEncryptionKey(String bucket,
+  public static String getServerSideEncryptionKey(String bucket,
-  static S3AEncryptionMethods getEncryptionAlgorithm(String bucket,
+  public static S3AEncryptionMethods getEncryptionAlgorithm(String bucket,
+      LOG.debug("Using SSE-C with {}", diagnostics);
-    LOG.debug("Using SSE-C with {}", diagnostics);

MOV26 INS26 INS26 INS26 INS26 INS26 INS40 UPD40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS29 INS78 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS74 INS59 MOV29 INS83 INS83 MOV43 MOV42 MOV44 MOV44 MOV43 INS8 INS74 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS43 INS8 UPD83 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS83 INS83 INS65 INS42 INS42 INS42 INS45 INS65 INS43 MOV74 INS42 INS32 INS78 INS21 MOV60 MOV21 MOV41 INS43 MOV74 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS78 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS74 INS42 INS83 INS74 INS42 INS42 INS60 INS25 MOV60 MOV70 INS41 INS78 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS66 INS66 INS66 INS42 INS42 INS42 INS32 UPD66 INS42 INS32 INS43 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS43 INS74 INS43 INS74 INS74 INS59 INS32 MOV8 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS32 INS8 INS8 MOV21 INS42 INS42 INS57 INS57 INS57 INS57 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS45 INS42 INS42 INS42 INS43 INS76 INS42 INS43 INS76 INS43 INS74 INS42 INS32 INS42 INS42 INS21 UPD42 INS25 INS33 UPD42 MOV42 INS42 INS42 INS21 INS41 INS41 INS43 MOV43 MOV43 INS43 UPD42 INS42 INS42 INS14 INS32 INS42 INS42 INS42 INS43 INS76 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS7 INS32 INS8 INS32 INS9 INS9 INS32 INS42 INS42 INS74 INS42 INS42 MOV32 INS42 INS42 INS42 INS3 INS42 INS42 INS42 INS42 INS42 INS53 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS5 INS32 INS14 INS42 INS43 INS85 UPD42 MOV42 UPD42 MOV42 INS43 INS27 UPD45 UPD45 INS42 INS42 INS42 INS45 INS42 INS45 INS42 DEL42 DEL33 DEL27 DEL66 DEL85 DEL5 DEL42 DEL42 DEL14 DEL83 DEL83 DEL40 DEL34 DEL27 DEL42 DEL42 DEL14 DEL32 DEL21 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL31 DEL85 DEL5 DEL45
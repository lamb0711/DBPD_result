HADOOP-15229. Add FileSystem builder-based openFile() API to match createFile();
S3A to implement S3 Select through this API.

The new openFile() API is asynchronous, and implemented across FileSystem and FileContext.

The MapReduce V2 inputs are moved to this API, and you can actually set must/may
options to pass in.

This is more useful for setting things like s3a seek policy than for S3 select,
as the existing input format/record readers can't handle S3 select output where
the stream is shorter than the file length, and splitting plain text is suboptimal.
Future work is needed there.

In the meantime, any/all filesystem connectors are now free to add their own filesystem-specific
configuration parameters which can be set in jobs and used to set filesystem input stream
options (seek policy, retry, encryption secrets, etc).

Contributed by Steve Loughran

+import javax.annotation.Nullable;
+
+
+  public static final String E_NEGATIVE_READAHEAD_VALUE
+      = "Negative readahead value";
+
-   * @param readahead readahead bytes
-   * @param inputPolicy IO policy
-  public S3AInputStream(S3AReadOpContext ctx, S3ObjectAttributes s3Attributes,
-      long contentLength, AmazonS3 client, long readahead,
-      S3AInputPolicy inputPolicy) {
+  public S3AInputStream(S3AReadOpContext ctx,
+      S3ObjectAttributes s3Attributes,
+      long contentLength,
+      AmazonS3 client) {
-    setInputPolicy(inputPolicy);
-    setReadahead(readahead);
+    setInputPolicy(ctx.getInputPolicy());
+    setReadahead(ctx.getReadahead());
-    S3Object object = context.getReadInvoker().once(text, uri,
+    S3Object object = Invoker.once(text, uri,
-    if (readahead == null) {
-      this.readahead = Constants.DEFAULT_READAHEAD_RANGE;
-    } else {
-      Preconditions.checkArgument(readahead >= 0, "Negative readahead value");
-      this.readahead = readahead;
-    }
+    this.readahead = validateReadahead(readahead);
+  /**
+   * from a possibly null Long value, return a valid
+   * readahead.
+   * @param readahead new readahead
+   * @return a natural number.
+   * @throws IllegalArgumentException if the range is invalid.
+   */
+  public static long validateReadahead(@Nullable Long readahead) {
+    if (readahead == null) {
+      return Constants.DEFAULT_READAHEAD_RANGE;
+    } else {
+      Preconditions.checkArgument(readahead >= 0, E_NEGATIVE_READAHEAD_VALUE);
+      return readahead;
+    }
+  }

INS26 INS40 INS23 INS31 INS83 INS83 INS83 INS43 INS59 MOV8 INS29 INS83 INS83 INS39 INS42 INS44 MOV8 INS42 INS42 INS45 INS65 INS65 INS65 INS65 INS78 INS43 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS8 INS32 INS32 INS32 INS41 INS41 INS42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS40 INS42 INS42 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL40 DEL45 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21
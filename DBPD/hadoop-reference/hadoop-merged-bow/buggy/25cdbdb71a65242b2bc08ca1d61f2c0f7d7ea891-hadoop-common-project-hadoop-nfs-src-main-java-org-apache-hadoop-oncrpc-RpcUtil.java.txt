HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68

+import java.nio.ByteBuffer;
+
+import org.jboss.netty.channel.Channels;
+import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
-public class RpcUtil {
+public final class RpcUtil {
-   * The XID in RPC call. It is used for starting with new seed after each reboot.
+   * The XID in RPC call. It is used for starting with new seed after each
+   * reboot.
+  public static void sendRpcResponse(ChannelHandlerContext ctx,
+      RpcResponse response) {
+    Channels.fireMessageReceived(ctx, response);
+  }
+
+  public static final SimpleChannelUpstreamHandler STAGE_RPC_MESSAGE_PARSER = new RpcMessageParserStage();
+  public static final SimpleChannelUpstreamHandler STAGE_RPC_TCP_RESPONSE = new RpcTcpResponseStage();
+  public static final SimpleChannelUpstreamHandler STAGE_RPC_UDP_RESPONSE = new RpcUdpResponseStage();
+
+  /**
+   * An RPC client can separate a RPC message into several frames (i.e.,
+   * fragments) when transferring it across the wire. RpcFrameDecoder
+   * reconstructs a full RPC message from these fragments.
+   *
+   * RpcFrameDecoder is a stateful pipeline stage. It has to be constructed for
+   * each RPC client.
+   */
+
+  /**
+   * RpcMessageParserStage parses the network bytes and encapsulates the RPC
+   * request into a RpcInfo instance.
+   */
+  static final class RpcMessageParserStage extends SimpleChannelUpstreamHandler {
+    private static final Log LOG = LogFactory
+        .getLog(RpcMessageParserStage.class);
+
+    @Override
+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
+        throws Exception {
+      ChannelBuffer buf = (ChannelBuffer) e.getMessage();
+      ByteBuffer b = buf.toByteBuffer().asReadOnlyBuffer();
+      XDR in = new XDR(b, XDR.State.READING);
+
+      RpcInfo info = null;
+      try {
+        RpcCall callHeader = RpcCall.read(in);
+        ChannelBuffer dataBuffer = ChannelBuffers.wrappedBuffer(in.buffer()
+            .slice());
+        info = new RpcInfo(callHeader, dataBuffer, ctx, e.getChannel(),
+            e.getRemoteAddress());
+      } catch (Exception exc) {
+        LOG.info("Malfromed RPC request from " + e.getRemoteAddress());
+      }
+
+      if (info != null) {
+        Channels.fireMessageReceived(ctx, info);
+      }
+    }
+  }
+
+  /**
+   * RpcTcpResponseStage sends an RpcResponse across the wire with the
+   * appropriate fragment header.
+   */
+  private static class RpcTcpResponseStage extends SimpleChannelUpstreamHandler {
+
+    @Override
+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
+        throws Exception {
+      RpcResponse r = (RpcResponse) e.getMessage();
+      byte[] fragmentHeader = XDR.recordMark(r.data().readableBytes(), true);
+      ChannelBuffer header = ChannelBuffers.wrappedBuffer(fragmentHeader);
+      ChannelBuffer d = ChannelBuffers.wrappedBuffer(header, r.data());
+      e.getChannel().write(d);
+    }
+  }
+
+  /**
+   * RpcUdpResponseStage sends an RpcResponse as a UDP packet, which does not
+   * require a fragment header.
+   */
+  private static final class RpcUdpResponseStage extends
+      SimpleChannelUpstreamHandler {
+
+    @Override
+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
+        throws Exception {
+      RpcResponse r = (RpcResponse) e.getMessage();
+      e.getChannel().write(r.data(), r.remoteAddress());
+    }
+  }

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS83 INS31 INS23 INS23 INS23 INS55 INS55 INS55 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS29 INS29 INS83 INS83 INS42 INS43 INS23 INS31 INS29 INS83 INS83 INS42 INS43 INS31 INS29 INS83 INS83 INS83 INS42 INS43 INS31 INS43 INS42 INS43 INS42 INS21 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS65 INS65 INS42 INS83 INS83 INS83 INS43 INS59 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS65 INS42 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS65 INS42 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 UPD66 INS66 INS42 INS42 INS32 INS43 INS43 INS43 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS32 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS54 INS25 INS66 INS66 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS21 INS66 INS66 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS57 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS8 INS12 INS27 INS8 INS42 INS42 INS43 INS59 INS5 INS59 INS43 INS59 INS43 INS59 INS32 INS42 INS42 INS43 INS59 INS32 INS43 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS33 INS60 INS60 INS21 INS44 INS8 INS42 INS33 INS21 INS42 INS42 INS11 INS39 INS85 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS11 INS32 INS42 INS32 INS32 INS42 INS43 INS32 INS32 INS42 INS43 INS42 INS40 INS43 INS59 INS43 INS59 INS7 INS43 INS42 INS21 INS32 INS43 INS32 INS42 INS42 INS32 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS14 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42
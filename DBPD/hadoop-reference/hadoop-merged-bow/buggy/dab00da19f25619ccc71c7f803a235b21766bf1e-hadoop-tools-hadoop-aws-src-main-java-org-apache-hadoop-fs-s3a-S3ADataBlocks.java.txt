HADOOP-14028. S3A BlockOutputStreams doesn't delete temporary files in multipart uploads or handle part upload failures.
Contributed by Steve Loughran.

(cherry picked from commit 29fe5af017b945d8750c074ca39031b5b777eddd)

-import java.io.FileInputStream;
-import java.io.FilterInputStream;
+import static org.apache.hadoop.fs.s3a.S3AUtils.closeAll;
- * uploaded as partitions.
+ * uploaded as to S3 as a single PUT, or as part of a multipart request.
+   * The output information for an upload.
+   * It can be one of a file or an input stream.
+   * When closed, any stream is closed. Any source file is untouched.
+   */
+  static final class BlockUploadData implements Closeable {
+    private final File file;
+    private final InputStream uploadStream;
+
+    /**
+     * File constructor; input stream will be null.
+     * @param file file to upload
+     */
+    BlockUploadData(File file) {
+      Preconditions.checkArgument(file.exists(), "No file: " + file);
+      this.file = file;
+      this.uploadStream = null;
+    }
+
+    /**
+     * Stream constructor, file field will be null.
+     * @param uploadStream stream to upload
+     */
+    BlockUploadData(InputStream uploadStream) {
+      Preconditions.checkNotNull(uploadStream, "rawUploadStream");
+      this.uploadStream = uploadStream;
+      this.file = null;
+    }
+
+    /**
+     * Predicate: does this instance contain a file reference.
+     * @return true if there is a file.
+     */
+    boolean hasFile() {
+      return file != null;
+    }
+
+    /**
+     * Get the file, if there is one.
+     * @return the file for uploading, or null.
+     */
+    File getFile() {
+      return file;
+    }
+
+    /**
+     * Get the raw upload stream, if the object was
+     * created with one.
+     * @return the upload stream or null.
+     */
+    InputStream getUploadStream() {
+      return uploadStream;
+    }
+
+    /**
+     * Close: closes any upload stream provided in the constructor.
+     * @throws IOException inherited exception
+     */
+    @Override
+    public void close() throws IOException {
+      closeAll(LOG, uploadStream);
+    }
+  }
+
+  /**
+     *
+     * @param index index of block
+     * @param statistics stats to work with
-    abstract DataBlock create(int limit) throws IOException;
+    abstract DataBlock create(long index, int limit,
+        S3AInstrumentation.OutputStreamStatistics statistics)
+        throws IOException;
-     * @throws IOException -ideally, it shouldn't.
+     * @throws IOException Inherited exception; implementations should
+     * avoid raising it.
+    protected final long index;
+    protected final S3AInstrumentation.OutputStreamStatistics statistics;
+
+    protected DataBlock(long index,
+        S3AInstrumentation.OutputStreamStatistics statistics) {
+      this.index = index;
+      this.statistics = statistics;
+    }
-    InputStream startUpload() throws IOException {
-      LOG.debug("Start datablock upload");
+    BlockUploadData startUpload() throws IOException {
+      LOG.debug("Start datablock[{}] upload", index);
+    /**
+     * A block has been allocated.
+     */
+    protected void blockAllocated() {
+      if (statistics != null) {
+        statistics.blockAllocated();
+      }
+    }
+
+    /**
+     * A block has been released.
+     */
+    protected void blockReleased() {
+      if (statistics != null) {
+        statistics.blockReleased();
+      }
+    }
-    DataBlock create(int limit) throws IOException {
-      return new ByteArrayBlock(limit);
+    DataBlock create(long index, int limit,
+        S3AInstrumentation.OutputStreamStatistics statistics)
+        throws IOException {
+      return new ByteArrayBlock(0, limit, statistics);
-    ByteArrayBlock(int limit) {
+    ByteArrayBlock(long index,
+        int limit,
+        S3AInstrumentation.OutputStreamStatistics statistics) {
+      super(index, statistics);
+      blockAllocated();
-    InputStream startUpload() throws IOException {
+    BlockUploadData startUpload() throws IOException {
-      return bufferData;
+      return new BlockUploadData(bufferData);
+      blockReleased();
-      return "ByteArrayBlock{" +
-          "state=" + getState() +
+      return "ByteArrayBlock{"
+          +"index=" + index +
+          ", state=" + getState() +
-   * This is actually the most complex of all the block factories,
-   * due to the need to explicitly recycle buffers; in comparison, the
-   * {@link DiskBlock} buffer delegates the work of deleting files to
-   * the {@link DiskBlock.FileDeletingInputStream}. Here the
-   * input stream {@link ByteBufferInputStream} has a similar task, along
-   * with the foundational work of streaming data from a byte array.
-    ByteBufferBlock create(int limit) throws IOException {
-      return new ByteBufferBlock(limit);
+    ByteBufferBlock create(long index, int limit,
+        S3AInstrumentation.OutputStreamStatistics statistics)
+        throws IOException {
+      return new ByteBufferBlock(index, limit, statistics);
-     * it when the output stream is closed.
+     * it when it is closed.
-      private ByteBuffer buffer;
+      private ByteBuffer blockBuffer;
+       * @param index block index
+       * @param statistics statistics to update
-      ByteBufferBlock(int bufferSize) {
+      ByteBufferBlock(long index,
+          int bufferSize,
+          S3AInstrumentation.OutputStreamStatistics statistics) {
+        super(index, statistics);
-        buffer = requestBuffer(bufferSize);
+        blockBuffer = requestBuffer(bufferSize);
+        blockAllocated();
-      ByteBufferInputStream startUpload() throws IOException {
+      BlockUploadData startUpload() throws IOException {
-        buffer.limit(buffer.position());
-        buffer.position(0);
-        return new ByteBufferInputStream(dataSize, buffer);
+        blockBuffer.limit(blockBuffer.position());
+        blockBuffer.position(0);
+        return new BlockUploadData(
+            new ByteBufferInputStream(dataSize, blockBuffer));
-        return buffer != null ? buffer.remaining() : 0;
+        return blockBuffer != null ? blockBuffer.remaining() : 0;
-        return buffer.capacity() - buffer.remaining();
+        return blockBuffer.capacity() - blockBuffer.remaining();
-        buffer.put(b, offset, written);
+        blockBuffer.put(b, offset, written);
+      /**
+       * Closing the block will release the buffer.
+       */
-        buffer = null;
+        if (blockBuffer != null) {
+          blockReleased();
+          releaseBuffer(blockBuffer);
+          blockBuffer = null;
+        }
-            + "state=" + getState() +
+            + "index=" + index +
+            ", state=" + getState() +
-    }
-
-    /**
-     * Provide an input stream from a byte buffer; supporting
-     * {@link #mark(int)}, which is required to enable replay of failed
-     * PUT attempts.
-     * This input stream returns the buffer to the pool afterwards.
-     */
-    class ByteBufferInputStream extends InputStream {
-
-      private final int size;
-      private ByteBuffer byteBuffer;
-
-      ByteBufferInputStream(int size, ByteBuffer byteBuffer) {
-        LOG.debug("Creating ByteBufferInputStream of size {}", size);
-        this.size = size;
-        this.byteBuffer = byteBuffer;
-      }
-
-       * Return the buffer to the pool after the stream is closed.
+       * Provide an input stream from a byte buffer; supporting
+       * {@link #mark(int)}, which is required to enable replay of failed
+       * PUT attempts.
-      @Override
-      public synchronized void close() {
-        if (byteBuffer != null) {
-          LOG.debug("releasing buffer");
-          releaseBuffer(byteBuffer);
+      class ByteBufferInputStream extends InputStream {
+
+        private final int size;
+        private ByteBuffer byteBuffer;
+
+        ByteBufferInputStream(int size,
+            ByteBuffer byteBuffer) {
+          LOG.debug("Creating ByteBufferInputStream of size {}", size);
+          this.size = size;
+          this.byteBuffer = byteBuffer;
+        }
+
+        /**
+         * After the stream is closed, set the local reference to the byte
+         * buffer to null; this guarantees that future attempts to use
+         * stream methods will fail.
+         */
+        @Override
+        public synchronized void close() {
+          LOG.debug("ByteBufferInputStream.close() for {}",
+              ByteBufferBlock.super.toString());
-      }
-      /**
-       * Verify that the stream is open.
-       * @throws IOException if the stream is closed
-       */
-      private void verifyOpen() throws IOException {
-        if (byteBuffer == null) {
-          throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);
-        }
-      }
-
-      public synchronized int read() throws IOException {
-        if (available() > 0) {
-          return byteBuffer.get() & 0xFF;
-        } else {
-          return -1;
-        }
-      }
-
-      @Override
-      public synchronized long skip(long offset) throws IOException {
-        verifyOpen();
-        long newPos = position() + offset;
-        if (newPos < 0) {
-          throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK);
-        }
-        if (newPos > size) {
-          throw new EOFException(FSExceptionMessages.CANNOT_SEEK_PAST_EOF);
-        }
-        byteBuffer.position((int) newPos);
-        return newPos;
-      }
-
-      @Override
-      public synchronized int available() {
-        Preconditions.checkState(byteBuffer != null,
-            FSExceptionMessages.STREAM_IS_CLOSED);
-        return byteBuffer.remaining();
-      }
-
-      /**
-       * Get the current buffer position.
-       * @return the buffer position
-       */
-      public synchronized int position() {
-        return byteBuffer.position();
-      }
-
-      /**
-       * Check if there is data left.
-       * @return true if there is data remaining in the buffer.
-       */
-      public synchronized boolean hasRemaining() {
-        return byteBuffer.hasRemaining();
-      }
-
-      @Override
-      public synchronized void mark(int readlimit) {
-        LOG.debug("mark at {}", position());
-        byteBuffer.mark();
-      }
-
-      @Override
-      public synchronized void reset() throws IOException {
-        LOG.debug("reset");
-        byteBuffer.reset();
-      }
-
-      @Override
-      public boolean markSupported() {
-        return true;
-      }
-
-      /**
-       * Read in data.
-       * @param buffer destination buffer
-       * @param offset offset within the buffer
-       * @param length length of bytes to read
-       * @throws EOFException if the position is negative
-       * @throws IndexOutOfBoundsException if there isn't space for the
-       * amount of data requested.
-       * @throws IllegalArgumentException other arguments are invalid.
-       */
-      @SuppressWarnings("NullableProblems")
-      public synchronized int read(byte[] buffer, int offset, int length)
-          throws IOException {
-        Preconditions.checkArgument(length >= 0, "length is negative");
-        Preconditions.checkArgument(buffer != null, "Null buffer");
-        if (buffer.length - offset < length) {
-          throw new IndexOutOfBoundsException(
-              FSExceptionMessages.TOO_MANY_BYTES_FOR_DEST_BUFFER
-                  + ": request length =" + length
-                  + ", with offset =" + offset
-                  + "; buffer capacity =" + (buffer.length - offset));
-        }
-        verifyOpen();
-        if (!hasRemaining()) {
-          return -1;
+        /**
+         * Verify that the stream is open.
+         * @throws IOException if the stream is closed
+         */
+        private void verifyOpen() throws IOException {
+          if (byteBuffer == null) {
+            throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);
+          }
-        int toRead = Math.min(length, available());
-        byteBuffer.get(buffer, offset, toRead);
-        return toRead;
-      }
-
-      @Override
-      public String toString() {
-        final StringBuilder sb = new StringBuilder(
-            "ByteBufferInputStream{");
-        sb.append("size=").append(size);
-        ByteBuffer buffer = this.byteBuffer;
-        if (buffer != null) {
-          sb.append(", available=").append(buffer.remaining());
+        public synchronized int read() throws IOException {
+          if (available() > 0) {
+            return byteBuffer.get() & 0xFF;
+          } else {
+            return -1;
+          }
-        sb.append('}');
-        return sb.toString();
+
+        @Override
+        public synchronized long skip(long offset) throws IOException {
+          verifyOpen();
+          long newPos = position() + offset;
+          if (newPos < 0) {
+            throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK);
+          }
+          if (newPos > size) {
+            throw new EOFException(FSExceptionMessages.CANNOT_SEEK_PAST_EOF);
+          }
+          byteBuffer.position((int) newPos);
+          return newPos;
+        }
+
+        @Override
+        public synchronized int available() {
+          Preconditions.checkState(byteBuffer != null,
+              FSExceptionMessages.STREAM_IS_CLOSED);
+          return byteBuffer.remaining();
+        }
+
+        /**
+         * Get the current buffer position.
+         * @return the buffer position
+         */
+        public synchronized int position() {
+          return byteBuffer.position();
+        }
+
+        /**
+         * Check if there is data left.
+         * @return true if there is data remaining in the buffer.
+         */
+        public synchronized boolean hasRemaining() {
+          return byteBuffer.hasRemaining();
+        }
+
+        @Override
+        public synchronized void mark(int readlimit) {
+          LOG.debug("mark at {}", position());
+          byteBuffer.mark();
+        }
+
+        @Override
+        public synchronized void reset() throws IOException {
+          LOG.debug("reset");
+          byteBuffer.reset();
+        }
+
+        @Override
+        public boolean markSupported() {
+          return true;
+        }
+
+        /**
+         * Read in data.
+         * @param b destination buffer
+         * @param offset offset within the buffer
+         * @param length length of bytes to read
+         * @throws EOFException if the position is negative
+         * @throws IndexOutOfBoundsException if there isn't space for the
+         * amount of data requested.
+         * @throws IllegalArgumentException other arguments are invalid.
+         */
+        @SuppressWarnings("NullableProblems")
+        public synchronized int read(byte[] b, int offset, int length)
+            throws IOException {
+          Preconditions.checkArgument(length >= 0, "length is negative");
+          Preconditions.checkArgument(b != null, "Null buffer");
+          if (b.length - offset < length) {
+            throw new IndexOutOfBoundsException(
+                FSExceptionMessages.TOO_MANY_BYTES_FOR_DEST_BUFFER
+                    + ": request length =" + length
+                    + ", with offset =" + offset
+                    + "; buffer capacity =" + (b.length - offset));
+          }
+          verifyOpen();
+          if (!hasRemaining()) {
+            return -1;
+          }
+
+          int toRead = Math.min(length, available());
+          byteBuffer.get(b, offset, toRead);
+          return toRead;
+        }
+
+        @Override
+        public String toString() {
+          final StringBuilder sb = new StringBuilder(
+              "ByteBufferInputStream{");
+          sb.append("size=").append(size);
+          ByteBuffer buf = this.byteBuffer;
+          if (buf != null) {
+            sb.append(", available=").append(buf.remaining());
+          }
+          sb.append(", ").append(ByteBufferBlock.super.toString());
+          sb.append('}');
+          return sb.toString();
+        }
-     * Create a temp file and a block which writes to it.
+     * Create a temp file and a {@link DiskBlock} instance to manage it.
+     *
+     * @param index block index
+     * @param statistics statistics to update
-    DataBlock create(int limit) throws IOException {
+    DataBlock create(long index,
+        int limit,
+        S3AInstrumentation.OutputStreamStatistics statistics)
+        throws IOException {
-          .createTmpFileForWrite("s3ablock", limit, getOwner().getConf());
-      return new DiskBlock(destFile, limit);
+          .createTmpFileForWrite(String.format("s3ablock-%04d-", index),
+              limit, getOwner().getConf());
+      return new DiskBlock(destFile, limit, index, statistics);
-   * This will stop at the limit; the caller is expected to create a new block
+   * This will stop at the limit; the caller is expected to create a new block.
-    private InputStream uploadStream;
+    private final AtomicBoolean closed = new AtomicBoolean(false);
-    DiskBlock(File bufferFile, int limit)
+    DiskBlock(File bufferFile,
+        int limit,
+        long index,
+        S3AInstrumentation.OutputStreamStatistics statistics)
+      super(index, statistics);
+      blockAllocated();
-    InputStream startUpload() throws IOException {
+    BlockUploadData startUpload() throws IOException {
-      uploadStream = new FileInputStream(bufferFile);
-      return new FileDeletingInputStream(uploadStream);
+      return new BlockUploadData(bufferFile);
+    @SuppressWarnings("UnnecessaryDefault")
-          LOG.debug("Deleting buffer file as upload did not start");
-          boolean deleted = bufferFile.delete();
-          if (!deleted && bufferFile.exists()) {
-            LOG.warn("Failed to delete buffer file {}", bufferFile);
-          }
+          LOG.debug("Block[{}]: Deleting buffer file as upload did not start",
+              index);
+          closeBlock();
-        LOG.debug("Buffer file {} exists —close upload stream", bufferFile);
+        LOG.debug("Block[{}]: Buffer file {} exists —close upload stream",
+            index, bufferFile);
-        // no-op
+        closeBlock();
-          + "destFile=" + bufferFile +
+          + "index=" + index
+          + ", destFile=" + bufferFile +
-     * An input stream which deletes the buffer file when closed.
+     * Close the block.
+     * This will delete the block's buffer file if the block has
+     * not previously been closed.
-    private final class FileDeletingInputStream extends FilterInputStream {
-      private final AtomicBoolean closed = new AtomicBoolean(false);
-
-      FileDeletingInputStream(InputStream source) {
-        super(source);
-      }
-
-      /**
-       * Delete the input file when closed.
-       * @throws IOException IO problem
-       */
-      @Override
-      public void close() throws IOException {
-        try {
-          super.close();
-        } finally {
-          if (!closed.getAndSet(true)) {
-            if (!bufferFile.delete()) {
-              LOG.warn("delete({}) returned false",
-                  bufferFile.getAbsoluteFile());
-            }
-          }
+    void closeBlock() {
+      LOG.debug("block[{}]: closeBlock()", index);
+      if (!closed.getAndSet(true)) {
+        blockReleased();
+        if (!bufferFile.delete() && bufferFile.exists()) {
+          LOG.warn("delete({}) returned false",
+              bufferFile.getAbsoluteFile());
+      } else {
+        LOG.debug("block[{}]: skipping re-entrant closeBlock()", index);

MOV26 UPD40 INS55 INS29 INS83 INS83 INS42 INS43 INS23 MOV23 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS23 INS31 INS31 INS31 MOV23 MOV31 UPD66 INS65 INS42 INS83 INS83 INS43 INS59 INS83 INS29 INS42 INS44 INS8 INS29 INS42 MOV44 INS8 INS29 INS39 INS42 INS8 INS29 INS43 INS42 INS8 INS29 MOV43 INS42 INS8 INS29 MOV78 INS83 INS39 INS42 MOV43 INS8 INS44 INS44 INS83 INS83 INS39 INS59 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS8 INS43 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS44 INS44 INS44 INS44 UPD43 INS78 MOV78 INS44 INS44 MOV55 INS44 INS44 INS44 INS44 UPD43 INS79 UPD42 MOV8 INS66 INS66 INS66 INS42 INS42 INS65 INS65 INS43 INS42 INS21 INS21 INS21 INS65 INS65 UPD42 INS21 INS21 INS21 INS65 INS65 INS41 INS65 INS65 INS42 INS41 INS65 INS65 INS41 INS65 INS65 INS21 INS65 INS65 INS39 INS42 INS43 INS42 INS42 INS40 INS42 INS39 INS42 INS43 INS42 INS21 INS21 INS42 INS65 INS25 INS65 INS25 INS39 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS46 INS21 UPD42 INS42 INS21 INS39 INS42 INS43 INS42 INS44 INS44 UPD43 MOV78 INS29 MOV78 INS8 INS65 INS65 INS39 INS42 INS43 INS42 UPD66 INS39 INS42 INS43 INS42 INS46 INS21 UPD42 INS41 INS42 INS45 INS65 INS21 INS66 INS42 INS66 INS42 INS32 INS7 INS7 INS66 INS42 INS66 INS32 INS7 INS7 INS66 INS66 INS27 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS32 INS42 INS66 INS42 INS66 INS40 UPD66 INS66 INS40 INS7 INS7 INS66 INS27 INS8 INS66 INS27 INS8 INS40 INS40 INS42 INS42 INS32 INS14 INS32 INS40 UPD66 UPD42 INS65 INS65 INS39 INS42 INS43 INS42 INS46 INS21 UPD42 INS65 INS25 INS8 UPD66 MOV65 INS66 INS42 INS66 INS42 INS66 INS40 INS40 INS42 INS42 INS32 INS14 INS21 INS66 UPD66 MOV66 UPD66 MOV66 INS32 INS8 INS42 INS42 INS32 INS27 INS22 INS42 INS22 INS33 INS42 INS42 INS42 INS45 INS22 INS42 INS22 INS33 INS42 INS33 INS42 INS42 INS42 INS22 INS42 INS22 INS42 UPD45 INS42 INS42 INS33 INS21 INS42 INS33 INS21 INS34 INS42 INS42 INS43 INS42 INS42 INS42 INS45 MOV32 INS42 INS42 INS42 INS66 INS42 INS66 INS40 INS42 INS42 INS32 INS14 INS66 INS27 INS8 INS21 MOV21 UPD42 INS21 INS42 INS42 INS42 UPD43 MOV43 MOV42 INS32 INS42 INS42 INS45 INS42 INS21 INS21 INS42 INS42 INS45 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS32 INS42 UPD45 UPD42 INS42 UPD42 UPD42 INS43 MOV14 UPD42 INS42 INS33 INS21 INS21 MOV21 INS42 INS45 UPD66 INS66 INS66 INS32 UPD42 INS32 INS32 UPD42 MOV21 UPD45 INS42 INS42 INS42 INS45 MOV32 INS32 MOV27 INS32 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 INS32 UPD45 MOV42 MOV42 UPD45 MOV45 INS48 UPD42 UPD42 UPD42 INS32 INS42 INS48 INS42 INS42 UPD45 MOV45 INS42 UPD45 INS42 MOV38 INS42 INS42 INS45 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 UPD40 INS42 INS42 INS45 INS42 INS42 UPD45 INS42 UPD42 UPD42 UPD40 DEL40 DEL26 DEL42 DEL66 DEL66 DEL66 DEL66 DEL40 DEL65 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL8 DEL66 DEL42 DEL33 DEL27 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL14 DEL41 DEL42 DEL45 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL65 DEL42 DEL65 DEL83 DEL42 DEL42 DEL48 DEL21 DEL8 DEL54 DEL8 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL46 DEL8 DEL31 DEL55
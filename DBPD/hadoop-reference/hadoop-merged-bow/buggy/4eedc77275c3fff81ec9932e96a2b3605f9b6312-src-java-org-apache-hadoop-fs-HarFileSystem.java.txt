HADOOP-6467. Improve the performance on HarFileSystem.listStatus(..).  Contributed by mahadev


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@915168 13f79535-47bb-0310-9956-ffa450edef68

-    // need to look up the file in the underlying fs
-    // look up the index 
-    
-    // make sure this is a prt of this har filesystem
-    Path p = makeQualified(file.getPath());
-    Path harPath = getPathInHar(p);
-    String line = fileStatusInIndex(harPath);
-    if (line == null)  {
-      throw new FileNotFoundException("File " + file.getPath() + " not found");
-    }
-    HarStatus harStatus = new HarStatus(line);
-    if (harStatus.isDir()) {
-      return new BlockLocation[0];
-    }
-    FileStatus fsFile = fs.getFileStatus(new Path(archivePath,
-        harStatus.getPartName()));
-    BlockLocation[] rawBlocks = fs.getFileBlockLocations(fsFile, 
-        harStatus.getStartIndex() + start, len);
-    return fakeBlockLocations(rawBlocks, harStatus.getStartIndex());
+    // just fake block locations
+    // its fast and simpler
+    // doing various block location manipulation
+    // with part files adds a lot of overhead because 
+    // of the look ups of filestatus in index files
+    return new BlockLocation[]{ new BlockLocation() };
+  /**
+   * Get filestatuses of all the children of a given directory. This just reads
+   * through index file and reads line by line to get all statuses for children
+   * of a directory. Its a brute force way of getting all such filestatuses
+   * 
+   * @param parent
+   *          the parent path directory
+   * @param statuses
+   *          the list to add the children filestatuses to
+   * @param children
+   *          the string list of children for this parent
+   * @param archiveIndexStat
+   *          the archive index filestatus
+   */
+  private void fileStatusesInIndex(HarStatus parent, List<FileStatus> statuses,
+      List<String> children, FileStatus archiveIndexStat) throws IOException {
+    // read the index file
+    FSDataInputStream aIn = null;
+    try {
+      aIn = fs.open(archiveIndex);
+      LineReader aLin;
+      long read = 0;
+      aLin = new LineReader(aIn, getConf());
+      String parentString = parent.getName();
+      Path harPath = new Path(parentString);
+      int harlen = harPath.depth();
+      Text line = new Text();
+      while (read < archiveIndexStat.getLen()) {
+        int tmp = aLin.readLine(line);
+        read += tmp;
+        String lineFeed = line.toString();
+        String child = lineFeed.substring(0, lineFeed.indexOf(" "));
+        if ((child.startsWith(parentString))) {
+          Path thisPath = new Path(child);
+          if (thisPath.depth() == harlen + 1) {
+            // bingo!
+            HarStatus hstatus = new HarStatus(lineFeed);
+            FileStatus childStatus = new FileStatus(hstatus.isDir() ? 0
+                : hstatus.getLength(), hstatus.isDir(), (int) archiveIndexStat
+                .getReplication(), archiveIndexStat.getBlockSize(),
+                archiveIndexStat.getModificationTime(), archiveIndexStat
+                    .getAccessTime(), new FsPermission(archiveIndexStat
+                    .getPermission()), archiveIndexStat.getOwner(),
+                archiveIndexStat.getGroup(), makeRelative(this.uri.toString(),
+                    new Path(hstatus.name)));
+            statuses.add(childStatus);
+          }
+          line.clear();
+        }
+      }
+    } finally {
+      if (aIn != null) {
+        aIn.close();
+      }
+    }
+  }
+  
-      for (String child: hstatus.children) {
-        FileStatus tmp = getFileStatus(new Path(tmpPath, child));
-        statuses.add(tmp);
-      }
+      fileStatusesInIndex(hstatus, statuses, hstatus.children, archiveStatus);
+    

INS31 INS31 MOV29 MOV78 MOV83 MOV5 MOV42 MOV44 MOV44 MOV44 MOV43 MOV8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS43 MOV8 INS65 INS65 INS65 INS65 INS65 MOV43 INS42 INS74 INS42 INS74 INS42 MOV43 INS42 INS42 INS60 INS54 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS43 INS43 INS43 INS43 INS43 INS59 INS8 INS8 INS21 INS4 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS60 INS60 INS21 MOV60 INS60 MOV60 INS60 INS61 INS25 MOV32 INS14 INS7 INS43 INS59 INS39 INS59 INS7 MOV43 MOV43 INS59 INS39 INS43 INS59 INS27 INS8 INS27 INS8 INS42 UPD42 UPD42 INS40 UPD42 INS43 INS42 INS32 INS42 INS42 INS42 INS34 INS42 INS14 UPD42 INS32 INS42 INS14 UPD42 INS42 INS42 INS14 INS42 INS32 MOV60 INS21 INS60 INS60 INS25 INS42 INS33 INS21 INS42 INS42 INS42 INS42 INS43 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV43 INS42 UPD42 UPD42 INS43 INS42 INS42 INS39 INS7 INS43 INS59 MOV43 INS59 INS36 INS8 INS32 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS60 INS25 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS42 INS42 INS42 MOV43 INS59 INS27 INS8 INS32 INS42 INS42 INS45 INS42 INS14 MOV32 INS27 MOV60 INS60 INS21 UPD42 MOV42 UPD42 MOV42 UPD43 MOV43 INS42 UPD42 UPD42 INS42 INS34 INS43 INS59 INS32 UPD42 UPD42 INS42 INS42 INS14 INS42 INS42 INS42 INS43 UPD42 MOV43 INS16 INS32 INS11 INS32 INS32 MOV32 INS14 INS32 INS32 INS32 INS42 INS32 INS34 INS32 UPD42 MOV42 INS42 INS39 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 INS43 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 MOV14 UPD42 MOV42 MOV42 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS22 INS42 INS40 INS52 INS42 DEL34 DEL31 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL33 DEL27 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL32 DEL25 DEL42 DEL42 DEL14 DEL32 DEL59 DEL60 DEL43 DEL85 DEL5 DEL42 DEL32 DEL42 DEL27 DEL32 DEL59 DEL60 DEL42 DEL32 DEL32 DEL41 DEL42 DEL44 DEL40 DEL42 DEL42 DEL32 DEL59 DEL60 DEL21 DEL8 DEL70
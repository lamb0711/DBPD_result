Merged src/core, src/test/core, src/contrib/eclipse-plugin, and
src/contrib/ec2 from trunk 776174:784663


git-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@784965 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+  private static final Log LOG = LogFactory.getLog(Progress.class);
-  private float progressPerPhase;
+  // Each phase can have different progress weightage. For example, in
+  // Map Task, map phase accounts for 66.7% and sort phase for 33.3%.
+  // User needs to give weightages as parameters to all phases(when adding
+  // phases) in a Progress object, if he wants to give weightage to any of the
+  // phases. So when nodes are added without specifying weightage, it means 
+  // fixed weightage for all phases.
+  private boolean fixedWeightageForAllPhases = false;
+  private float progressPerPhase = 0.0f;
+  private ArrayList<Float> progressWeightagesForPhases = new ArrayList<Float>();
+  
-  /** Adds a node to the tree. */
+  /** Adds a node to the tree. Gives equal weightage to all phases */
+    Progress phase = addNewPhase();
+    // set equal weightage for all phases
+    progressPerPhase = 1.0f / (float)phases.size();
+    fixedWeightageForAllPhases = true;
+    return phase;
+  }
+  
+  /** Adds a new phase. Caller needs to set progress weightage */
+  private synchronized Progress addNewPhase() {
-    progressPerPhase = 1.0f / (float)phases.size();
+  /** Adds a named node with a specified progress weightage to the tree. */
+  public Progress addPhase(String status, float weightage) {
+    Progress phase = addPhase(weightage);
+    phase.setStatus(status);
+
+    return phase;
+  }
+
+  /** Adds a node with a specified progress weightage to the tree. */
+  public synchronized Progress addPhase(float weightage) {
+    Progress phase = new Progress();
+    progressWeightagesForPhases.add(weightage);
+    phases.add(phase);
+    phase.setParent(this);
+
+    // Ensure that the sum of weightages does not cross 1.0
+    float sum = 0;
+    for (int i = 0; i < phases.size(); i++) {
+      sum += progressWeightagesForPhases.get(i);
+    }
+    if (sum > 1.0) {
+      LOG.warn("Sum of weightages can not be more than 1.0; But sum = " + sum);
+    }
+
+    return phase;
+  }
+
+  /** Adds n nodes to the tree. Gives equal weightage to all phases */
+  public synchronized void addPhases(int n) {
+    for (int i = 0; i < n; i++) {
+      addNewPhase();
+    }
+    // set equal weightage for all phases
+    progressPerPhase = 1.0f / (float)phases.size();
+    fixedWeightageForAllPhases = true;
+  }
+
+  /**
+   * returns progress weightage of the given phase
+   * @param phaseNum the phase number of the phase(child node) for which we need
+   *                 progress weightage
+   * @return returns the progress weightage of the specified phase
+   */
+  float getProgressWeightage(int phaseNum) {
+    if (fixedWeightageForAllPhases) {
+      return progressPerPhase; // all phases are of equal weightage
+    }
+    return progressWeightagesForPhases.get(phaseNum);
+  }
+
-  // this method probably does not need to be synchronized as getINternal() is synchronized 
-  // and the node's parent never changes. Still, it doesn't hurt. 
+  // this method probably does not need to be synchronized as getInternal() is
+  // synchronized and the node's parent never changes. Still, it doesn't hurt. 
+  /**
+   * Returns progress in this node. get() would give overall progress of the
+   * root node(not just given current node).
+   */
+  public synchronized float getProgress() {
+    return getInternal();
+  }
+  
-      float subProgress =
-        currentPhase < phaseCount ? phase().getInternal() : 0.0f;
-      return progressPerPhase*(currentPhase + subProgress);
+      float subProgress = 0.0f;
+      float progressFromCurrentPhase = 0.0f;
+      if (currentPhase < phaseCount) {
+        subProgress = phase().getInternal();
+        progressFromCurrentPhase =
+          getProgressWeightage(currentPhase) * subProgress;
+      }
+      
+      float progressFromCompletedPhases = 0.0f;
+      if (fixedWeightageForAllPhases) { // same progress weightage for each phase
+        progressFromCompletedPhases = progressPerPhase * currentPhase;
+      }
+      else {
+        for (int i = 0; i < currentPhase; i++) {
+          // progress weightages of phases could be different. Add them
+          progressFromCompletedPhases += getProgressWeightage(i);
+        }
+      }
+      return  progressFromCompletedPhases + progressFromCurrentPhase;

INS26 INS26 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS39 INS59 INS83 INS74 INS59 INS29 INS83 INS83 MOV43 INS42 INS8 UPD83 INS43 UPD42 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS8 INS42 INS42 INS32 INS42 INS9 INS34 INS43 INS43 INS42 INS14 INS65 INS60 MOV21 INS21 MOV41 INS42 INS41 INS65 INS42 INS43 INS42 INS39 INS42 INS60 INS21 INS41 INS65 INS42 INS39 INS42 INS60 INS21 INS21 INS21 INS60 INS24 INS25 INS41 INS65 INS39 INS42 INS24 INS21 INS21 INS65 INS65 INS65 INS39 INS42 INS25 INS41 INS65 INS41 INS42 INS42 INS57 INS42 INS42 INS74 INS66 INS43 INS59 INS7 UPD66 INS42 INS66 INS42 INS43 INS59 INS32 INS42 INS66 INS43 INS59 INS32 INS32 INS32 INS39 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS42 INS66 INS58 INS27 INS37 INS8 INS7 INS7 INS66 INS42 INS66 INS66 INS66 INS42 INS8 INS32 INS66 INS66 INS32 INS43 INS43 INS43 INS42 INS42 INS32 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS34 INS39 INS59 INS42 INS32 INS42 INS21 INS42 INS34 INS21 INS39 INS59 INS42 INS42 INS42 INS21 INS42 INS27 INS42 INS9 INS41 INS42 INS42 INS42 INS42 INS60 INS25 INS60 INS25 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS34 INS42 INS42 INS7 INS32 INS42 INS34 INS32 INS34 INS11 INS42 INS39 INS59 MOV27 INS8 INS39 INS59 INS42 INS8 INS8 INS27 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS39 INS32 INS34 INS42 INS34 INS21 INS21 INS42 INS34 INS21 INS24 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS7 INS7 INS7 INS58 INS27 INS37 INS8 INS42 MOV32 INS42 INS27 INS42 INS27 INS39 INS59 INS42 INS42 INS42 INS21 INS32 MOV42 INS42 INS42 INS42 INS34 INS7 INS42 INS42 INS42 INS32 INS42 INS42 DEL34 DEL16 DEL42 DEL42 DEL27 DEL36 DEL27 DEL41
HADOOP-8220. ZKFailoverController doesn't handle failure to become active correctly. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3042@1307596 13f79535-47bb-0310-9956-ffa450edef68

-     * This method is called when the app becomes the active leader
+     * This method is called when the app becomes the active leader.
+     * If the service fails to become active, it should throw
+     * ServiceFailedException. This will cause the elector to
+     * sleep for a short period, then re-join the election.
+     * 
+     * Callback implementations are expected to manage their own
+     * timeouts (e.g. when making an RPC to a remote node).
-    void becomeActive();
+    void becomeActive() throws ServiceFailedException;
+  private static final int SLEEP_AFTER_FAILURE_TO_BECOME_ACTIVE = 1000;
-      becomeActive();
-      monitorActiveStatus();
+      if (becomeActive()) {
+        monitorActiveStatus();
+      } else {
+        reJoinElectionAfterFailureToBecomeActive();
+      }
-        becomeActive();
+        if (!becomeActive()) {
+          reJoinElectionAfterFailureToBecomeActive();
+        }
+   * We failed to become active. Re-join the election, but
+   * sleep for a few seconds after terminating our existing
+   * session, so that other nodes have a chance to become active.
+   * The failure to become active is already logged inside
+   * becomeActive().
+   */
+  private void reJoinElectionAfterFailureToBecomeActive() {
+    reJoinElection(SLEEP_AFTER_FAILURE_TO_BECOME_ACTIVE);
+  }
+
+  /**
-        reJoinElection();
+        reJoinElection(0);
-  private void reJoinElection() {
+  private void reJoinElection(int sleepTime) {
+      sleepFor(sleepTime);
+      
-  
+
+  /**
+   * Sleep for the given number of milliseconds.
+   * This is non-static, and separated out, so that unit tests
+   * can override the behavior not to sleep.
+   */
+  @VisibleForTesting
+  protected void sleepFor(int sleepMs) {
+    if (sleepMs > 0) {
+      try {
+        Thread.sleep(sleepMs);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
-        try {
-          Thread.sleep(5000);
-        } catch(InterruptedException e1) {
-          LOG.warn(e1);
-        }
+        sleepFor(5000);
-  private void becomeActive() {
+  private boolean becomeActive() {
-    if (state != State.ACTIVE) {
-      try {
-        Stat oldBreadcrumbStat = fenceOldActive();
-        writeBreadCrumbNode(oldBreadcrumbStat);
-      } catch (Exception e) {
-        LOG.warn("Exception handling the winning of election", e);
-        reJoinElection();
-        return;
-      }
+    if (state == State.ACTIVE) {
+      // already active
+      return true;
+    }
+    try {
+      Stat oldBreadcrumbStat = fenceOldActive();
+      writeBreadCrumbNode(oldBreadcrumbStat);
+      
-      state = State.ACTIVE;
+      state = State.ACTIVE;
+      return true;
+    } catch (Exception e) {
+      LOG.warn("Exception handling the winning of election", e);
+      // Caller will handle quitting and rejoining the election.
+      return false;

INS23 INS31 INS31 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS39 INS42 INS8 INS44 INS29 INS78 INS83 INS39 INS42 INS44 INS8 UPD39 MOV8 INS43 INS42 INS34 INS65 INS21 INS39 INS42 INS65 INS42 INS39 INS42 INS25 MOV6 INS25 INS42 INS8 INS66 INS66 INS66 INS66 INS66 INS32 INS66 INS66 INS66 INS27 INS8 INS27 INS8 UPD66 INS66 INS66 INS66 INS66 INS66 INS25 INS41 INS42 INS42 INS21 INS42 INS34 INS54 INS42 INS40 INS41 MOV21 MOV21 MOV21 INS41 MOV32 MOV8 INS8 INS8 INS32 INS8 INS12 INS9 INS9 INS21 INS25 INS42 INS42 INS21 MOV44 INS8 INS8 INS9 INS32 INS38 MOV8 INS34 INS32 UPD42 INS21 MOV21 MOV21 INS42 MOV32 INS42 INS42 INS42 INS32 INS32 INS32 INS42 UPD42 INS42 INS42 INS42 DEL21 DEL41 DEL42 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL42 DEL32 DEL21 DEL42 DEL40 DEL27 DEL25 DEL8
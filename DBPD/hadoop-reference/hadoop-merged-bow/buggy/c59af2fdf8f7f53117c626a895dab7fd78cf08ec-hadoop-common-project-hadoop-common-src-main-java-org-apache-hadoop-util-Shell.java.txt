HADOOP-10775. Shell operations to fail with meaningful errors on windows if winutils.exe not found. (stevel)

+import java.io.FileNotFoundException;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import com.google.common.annotations.VisibleForTesting;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
-/** 
- * A base class for running a Unix command.
- * 
- * <code>Shell</code> can be used to run unix commands like <code>du</code> or
+/**
+ * A base class for running a Shell command.
+ *
+ * <code>Shell</code> can be used to run shell commands like <code>du</code> or
-@InterfaceAudience.LimitedPrivate({"HDFS", "MapReduce"})
-@InterfaceStability.Unstable
-abstract public class Shell {
-  
-  public static final Log LOG = LogFactory.getLog(Shell.class);
-  
-  private static boolean IS_JAVA7_OR_ABOVE =
-      System.getProperty("java.version").substring(0, 3).compareTo("1.7") >= 0;
+@InterfaceAudience.Public
+@InterfaceStability.Evolving
+public abstract class Shell {
+  public static final Logger LOG = LoggerFactory.getLogger(Shell.class);
+  /**
+   * Text to include when there are windows-specific problems.
+   * {@value}
+   */
+  private static final String WINDOWS_PROBLEMS =
+      "https://wiki.apache.org/hadoop/WindowsProblems";
+
+  /**
+   * Name of the windows utils binary: {@value}.
+   */
+  static final String WINUTILS_EXE = "winutils.exe";
+
+  /**
+   * System property for the Hadoop home directory: {@value}.
+   */
+  public static final String SYSPROP_HADOOP_HOME_DIR = "hadoop.home.dir";
+
+  /**
+   * Environment variable for Hadoop's home dir: {@value}.
+   */
+  public static final String ENV_HADOOP_HOME = "HADOOP_HOME";
+
+  /**
+   * query to see if system is Java 7 or later.
+   * Now that Hadoop requires Java 7 or later, this always returns true.
+   * @deprecated This call isn't needed any more: please remove uses of it.
+   * @return true, always.
+   */
+  @Deprecated
-    return IS_JAVA7_OR_ABOVE;
+    return true;
-  public static final int WINDOWS_MAX_SHELL_LENGHT = 8191;
+  public static final int WINDOWS_MAX_SHELL_LENGTH = 8191;
-   * Checks if a given command (String[]) fits in the Windows maximum command line length
-   * Note that the input is expected to already include space delimiters, no extra count
-   * will be added for delimiters.
+   * mis-spelling of {@link #WINDOWS_MAX_SHELL_LENGTH}.
+   * @deprecated use the correctly spelled constant.
+   */
+  @Deprecated
+  public static final int WINDOWS_MAX_SHELL_LENGHT = WINDOWS_MAX_SHELL_LENGTH;
+
+  /**
+   * Checks if a given command (String[]) fits in the Windows maximum command
+   * line length Note that the input is expected to already include space
+   * delimiters, no extra count will be added for delimiters.
-    if (len > WINDOWS_MAX_SHELL_LENGHT) {
+    if (len > WINDOWS_MAX_SHELL_LENGTH) {
-          "The command line has a length of %d exceeds maximum allowed length of %d. " +
-          "Command starts with: %s",
-          len, WINDOWS_MAX_SHELL_LENGHT,
-          StringUtils.join("", commands).substring(0, 100)));
+        "The command line has a length of %d exceeds maximum allowed length" +
+            " of %d. Command starts with: %s",
+        len, WINDOWS_MAX_SHELL_LENGTH,
+        StringUtils.join("", commands).substring(0, 100)));
-  /** a Unix command to get the current user's name */
-  public final static String USER_NAME_COMMAND = "whoami";
+  /** a Unix command to get the current user's name: {@value}. */
+  public static final String USER_NAME_COMMAND = "whoami";
-  /** Windows CreateProcess synchronization object */
+  /** Windows <code>CreateProcess</code> synchronization object. */
+  /**
+   * Get the type of the operating system, as determined from parsing
+   * the <code>os.name</code> property.
+   */
-  static private OSType getOSType() {
+  private static OSType getOSType() {
-  /** a Unix command to get the current user's groups list */
+  /** a Unix command to get the current user's groups list. */
-   * a Unix command to get a given user's groups list.
+   * A command to get a given user's groups list.
-    //'groups username' command return is non-consistent across different unixes
-    return (WINDOWS)? new String[] { WINUTILS, "groups", "-F", "\"" + user + "\""}
-                    : new String [] {"bash", "-c", "id -gn " + user
-                                     + "&& id -Gn " + user};
+    //'groups username' command return is inconsistent across different unixes
+    return WINDOWS ?
+      new String[]
+          { getWinutilsPath(), "groups", "-F", "\"" + user + "\"" }
+      : new String [] {"bash", "-c", "id -gn " + user + "&& id -Gn " + user};
-  /** a Unix command to get a given netgroup's user list */
+  /** A command to get a given netgroup's user list. */
-    return (WINDOWS)? new String [] {"cmd", "/c", "getent netgroup " + netgroup}
+    return WINDOWS ? new String [] {"cmd", "/c", "getent netgroup " + netgroup}
-    return (WINDOWS) ? new String[] { WINUTILS, "ls", "-F" }
+    return (WINDOWS) ? new String[] { getWinutilsPath(), "ls", "-F" }
-  /** Return a command to set permission */
+  /** Return a command to set permission. */
-      return (WINDOWS) ? new String[] { WINUTILS, "chmod", "-R", perm }
-                         : new String[] { "chmod", "-R", perm };
+      return (WINDOWS) ?
+          new String[] { getWinutilsPath(), "chmod", "-R", perm }
+          : new String[] { "chmod", "-R", perm };
-      return (WINDOWS) ? new String[] { WINUTILS, "chmod", perm }
-                       : new String[] { "chmod", perm };
+      return (WINDOWS) ?
+          new String[] { getWinutilsPath(), "chmod", perm }
+          : new String[] { "chmod", perm };
-  public static String[] getSetPermissionCommand(String perm, boolean recursive,
-                                                 String file) {
+  public static String[] getSetPermissionCommand(String perm,
+      boolean recursive, String file) {
-  /** Return a command to set owner */
+  /** Return a command to set owner. */
-    return (WINDOWS) ? new String[] { WINUTILS, "chown", "\"" + owner + "\"" }
-                     : new String[] { "chown", owner };
-  }
-  
-  /** Return a command to create symbolic links */
-  public static String[] getSymlinkCommand(String target, String link) {
-    return WINDOWS ? new String[] { WINUTILS, "symlink", link, target }
-                   : new String[] { "ln", "-s", target, link };
+    return (WINDOWS) ?
+        new String[] { getWinutilsPath(), "chown", "\"" + owner + "\"" }
+        : new String[] { "chown", owner };
-  /** Return a command to read the target of the a symbolic link*/
+  /** Return a command to create symbolic links. */
+  public static String[] getSymlinkCommand(String target, String link) {
+    return WINDOWS ?
+       new String[] { getWinutilsPath(), "symlink", link, target }
+       : new String[] { "ln", "-s", target, link };
+  }
+
+  /** Return a command to read the target of the a symbolic link. */
-    return WINDOWS ? new String[] { WINUTILS, "readlink", link }
+    return WINDOWS ?
+        new String[] { getWinutilsPath(), "readlink", link }
-  /** Return a command for determining if process with specified pid is alive. */
+  /**
+   * Return a command for determining if process with specified pid is alive.
+   * @param pid process ID
+   * @return a <code>kill -0</code> command or equivalent
+   */
-  /** Return a command to send a signal to a given pid */
+  /** Return a command to send a signal to a given pid. */
-        return new String[] { Shell.WINUTILS, "task", "isAlive", pid };
+        return new String[] {Shell.getWinutilsPath(), "task", "isAlive", pid };
-        return new String[] { Shell.WINUTILS, "task", "kill", pid };
+        return new String[] {Shell.getWinutilsPath(), "task", "kill", pid };
+  /** Regular expression for environment variables: {@value}. */
-  /** Return a regular expression string that match environment variables */
+
+  /** Return a regular expression string that match environment variables. */
-  
+
-   * given parent directory.  The file extension is inferred by platform: ".cmd"
-   * on Windows, or ".sh" otherwise.
+   * given parent directory.  The file extension is inferred by platform:
+   * <code>".cmd"</code> on Windows, or <code>".sh"</code> otherwise.
-   * Returns a script file name with the given basename.  The file extension is
-   * inferred by platform: ".cmd" on Windows, or ".sh" otherwise.
-   * 
+   * Returns a script file name with the given basename.
+   *
+   * The file extension is inferred by platform:
+   * <code>".cmd"</code> on Windows, or <code>".sh"</code> otherwise.
+   *
-   * 
+   *
-    return WINDOWS ? new String[] { "cmd", "/c", absolutePath } :
-      new String[] { "/bin/bash", absolutePath };
+    return WINDOWS ?
+      new String[] { "cmd", "/c", absolutePath }
+      : new String[] { "/bin/bash", absolutePath };
-  /** a Unix command to set permission */
+  /** a Unix command to set permission: {@value}. */
-  /** a Unix command to set owner */
+  /** a Unix command to set owner: {@value}. */
-  /** a Unix command to set the change user's groups list */
+  /** a Unix command to set the change user's groups list: {@value}. */
-  /** a Unix command to create a link */
+  /** a Unix command to create a link: {@value}. */
-  /** a Unix command to get a link target */
+  /** a Unix command to get a link target: {@value}. */
-  /**Time after which the executing script would be timedout*/
+  /**Time after which the executing script would be timedout. */
-  private AtomicBoolean timedOut;
+  private final AtomicBoolean timedOut = new AtomicBoolean(false);
-
-  /** Centralized logic to discover and validate the sanity of the Hadoop 
-   *  home directory. Returns either NULL or a directory that exists and 
-   *  was specified via either -Dhadoop.home.dir or the HADOOP_HOME ENV 
-   *  variable.  This does a lot of work so it should only be called 
+  /**
+   *  Centralized logic to discover and validate the sanity of the Hadoop
+   *  home directory.
+   *
+   *  This does a lot of work so it should only be called
-   **/
-  private static String checkHadoopHome() {
+   *
+   * @return A directory that exists and via was specified on the command line
+   * via <code>-Dhadoop.home.dir</code> or the <code>HADOOP_HOME</code>
+   * environment variable.
+   * @throws FileNotFoundException if the properties are absent or the specified
+   * path is not a reference to a valid directory.
+   */
+  private static File checkHadoopHome() throws FileNotFoundException {
-    String home = System.getProperty("hadoop.home.dir");
+    String home = System.getProperty(SYSPROP_HADOOP_HOME_DIR);
-      home = System.getenv("HADOOP_HOME");
+      home = System.getenv(ENV_HADOOP_HOME);
+    }
+    return checkHadoopHomeInner(home);
+  }
+
+  /*
+  A set of exception strings used to construct error messages;
+  these are referred to in tests
+  */
+  static final String E_DOES_NOT_EXIST = "does not exist";
+  static final String E_IS_RELATIVE = "is not an absolute path.";
+  static final String E_NOT_DIRECTORY = "is not a directory.";
+  static final String E_NO_EXECUTABLE = "Could not locate Hadoop executable";
+  static final String E_NOT_EXECUTABLE_FILE = "Not an executable file";
+  static final String E_HADOOP_PROPS_UNSET = ENV_HADOOP_HOME + " and "
+      + SYSPROP_HADOOP_HOME_DIR + " are unset.";
+  static final String E_HADOOP_PROPS_EMPTY = ENV_HADOOP_HOME + " or "
+      + SYSPROP_HADOOP_HOME_DIR + " set to an empty string";
+  static final String E_NOT_A_WINDOWS_SYSTEM = "Not a Windows system";
+
+  /**
+   *  Validate the accessibility of the Hadoop home directory.
+   *
+   * @return A directory that is expected to be the hadoop home directory
+   * @throws FileNotFoundException if the specified
+   * path is not a reference to a valid directory.
+   */
+  @VisibleForTesting
+  static File checkHadoopHomeInner(String home) throws FileNotFoundException {
+    // couldn't find either setting for hadoop's home directory
+    if (home == null) {
+      throw new FileNotFoundException(E_HADOOP_PROPS_UNSET);
+    }
+    // strip off leading and trailing double quotes
+    while (home.startsWith("\"")) {
+      home = home.substring(1);
+    }
+    while (home.endsWith("\"")) {
+      home = home.substring(0, home.length() - 1);
+    // after stripping any quotes, check for home dir being non-empty
+    if (home.isEmpty()) {
+      throw new FileNotFoundException(E_HADOOP_PROPS_EMPTY);
+    }
+
+    // check that the hadoop home dir value
+    // is an absolute reference to a directory
+    File homedir = new File(home);
+    if (!homedir.isAbsolute()) {
+      throw new FileNotFoundException("Hadoop home directory " + homedir
+          + " " + E_IS_RELATIVE);
+    }
+    if (!homedir.exists()) {
+      throw new FileNotFoundException("Hadoop home directory " + homedir
+          + " " + E_DOES_NOT_EXIST);
+    }
+    if (!homedir.isDirectory()) {
+      throw new FileNotFoundException("Hadoop home directory " + homedir
+          + " "+ E_NOT_DIRECTORY);
+    }
+    return homedir;
+  }
+
+  /**
+   * The Hadoop home directory.
+   */
+  private static final File HADOOP_HOME_FILE;
+
+  /**
+   * Rethrowable cause for the failure to determine the hadoop
+   * home directory
+   */
+  private static final IOException HADOOP_HOME_DIR_FAILURE_CAUSE;
+
+  static {
+    File home;
+    IOException ex;
-       // couldn't find either setting for hadoop's home directory
-       if (home == null) {
-         throw new IOException("HADOOP_HOME or hadoop.home.dir are not set.");
-       }
-
-       if (home.startsWith("\"") && home.endsWith("\"")) {
-         home = home.substring(1, home.length()-1);
-       }
-
-       // check that the home setting is actually a directory that exists
-       File homedir = new File(home);
-       if (!homedir.isAbsolute() || !homedir.exists() || !homedir.isDirectory()) {
-         throw new IOException("Hadoop home directory " + homedir
-           + " does not exist, is not a directory, or is not an absolute path.");
-       }
-
-       home = homedir.getCanonicalPath();
-
+      home = checkHadoopHome();
+      ex = null;
+      ex = ioe;
-    
-    return home;
+    HADOOP_HOME_FILE = home;
+    HADOOP_HOME_DIR_FAILURE_CAUSE = ex;
-  private static String HADOOP_HOME_DIR = checkHadoopHome();
-  // Public getter, throws an exception if HADOOP_HOME failed validation
-  // checks and is being referenced downstream.
-  public static final String getHadoopHome() throws IOException {
-    if (HADOOP_HOME_DIR == null) {
-      throw new IOException("Misconfigured HADOOP_HOME cannot be referenced.");
+  /**
+   * Optionally extend an error message with some OS-specific text.
+   * @param message core error message
+   * @return error message, possibly with some extra text
+   */
+  private static String addOsText(String message) {
+    return WINDOWS ? (message + " -see " + WINDOWS_PROBLEMS) : message;
+  }
+
+  /**
+   * Create a {@code FileNotFoundException} with the inner nested cause set
+   * to the given exception. Compensates for the fact that FNFE doesn't
+   * have an initializer that takes an exception.
+   * @param text error text
+   * @param ex inner exception
+   * @return a new exception to throw.
+   */
+  private static FileNotFoundException fileNotFoundException(String text,
+      Exception ex) {
+    return (FileNotFoundException) new FileNotFoundException(text)
+        .initCause(ex);
+  }
+
+  /**
+   * Get the Hadoop home directory. Raises an exception if not found
+   * @return the home dir
+   * @throws IOException if the home directory cannot be located.
+   */
+  public static String getHadoopHome() throws IOException {
+    return getHadoopHomeDir().getCanonicalPath();
+  }
+
+  /**
+   * Get the Hadoop home directory. If it is invalid,
+   * throw an exception.
+   * @return a path referring to hadoop home.
+   * @throws FileNotFoundException if the directory doesn't exist.
+   */
+  private static File getHadoopHomeDir() throws FileNotFoundException {
+    if (HADOOP_HOME_DIR_FAILURE_CAUSE != null) {
+      throw fileNotFoundException(
+          addOsText(HADOOP_HOME_DIR_FAILURE_CAUSE.toString()),
+          HADOOP_HOME_DIR_FAILURE_CAUSE);
-
-    return HADOOP_HOME_DIR;
+    return HADOOP_HOME_FILE;
-  /** fully qualify the path to a binary that should be in a known hadoop 
+  /**
+   *  Fully qualify the path to a binary that should be in a known hadoop
-   * */
-  public static final String getQualifiedBinPath(String executable) 
-  throws IOException {
+   *
+   * @param executable executable
+   * @return executable file reference
+   * @throws FileNotFoundException if the path does not exist
+   */
+  public static File getQualifiedBin(String executable)
+      throws FileNotFoundException {
-    String fullExeName = HADOOP_HOME_DIR + File.separator + "bin" 
-      + File.separator + executable;
-
-    File exeFile = new File(fullExeName);
-    if (!exeFile.exists()) {
-      throw new IOException("Could not locate executable " + fullExeName
-        + " in the Hadoop binaries.");
-    }
-
-    return exeFile.getCanonicalPath();
+    return getQualifiedBinInner(getHadoopHomeDir(), executable);
-  /** a Windows utility to emulate Unix commands */
-  public static final String WINUTILS = getWinUtilsPath();
-
-  public static final String getWinUtilsPath() {
-    String winUtilsPath = null;
-
-    try {
-      if (WINDOWS) {
-        winUtilsPath = getQualifiedBinPath("winutils.exe");
-      }
-    } catch (IOException ioe) {
-       LOG.error("Failed to locate the winutils binary in the hadoop binary path",
-         ioe);
+  /**
+   * Inner logic of {@link #getQualifiedBin(String)}, accessible
+   * for tests.
+   * @param hadoopHomeDir home directory (assumed to be valid)
+   * @param executable executable
+   * @return path to the binary
+   * @throws FileNotFoundException if the executable was not found/valid
+   */
+  static File getQualifiedBinInner(File hadoopHomeDir, String executable)
+      throws FileNotFoundException {
+    String binDirText = "Hadoop bin directory ";
+    File bin = new File(hadoopHomeDir, "bin");
+    if (!bin.exists()) {
+      throw new FileNotFoundException(addOsText(binDirText + E_DOES_NOT_EXIST
+          + ": " + bin));
+    }
+    if (!bin.isDirectory()) {
+      throw new FileNotFoundException(addOsText(binDirText + E_NOT_DIRECTORY
+          + ": " + bin));
-    return winUtilsPath;
+    File exeFile = new File(bin, executable);
+    if (!exeFile.exists()) {
+      throw new FileNotFoundException(
+          addOsText(E_NO_EXECUTABLE + ": " + exeFile));
+    }
+    if (!exeFile.isFile()) {
+      throw new FileNotFoundException(
+          addOsText(E_NOT_EXECUTABLE_FILE + ": " + exeFile));
+    }
+    try {
+      return exeFile.getCanonicalFile();
+    } catch (IOException e) {
+      // this isn't going to happen, because of all the upfront checks.
+      // so if it does, it gets converted to a FNFE and rethrown
+      throw fileNotFoundException(e.toString(), e);
+    }
+  }
+
+  /**
+   *  Fully qualify the path to a binary that should be in a known hadoop
+   *  bin location. This is primarily useful for disambiguating call-outs
+   *  to executable sub-components of Hadoop to avoid clashes with other
+   *  executables that may be in the path.  Caveat:  this call doesn't
+   *  just format the path to the bin directory.  It also checks for file
+   *  existence of the composed path. The output of this call should be
+   *  cached by callers.
+   *
+   * @param executable executable
+   * @return executable file reference
+   * @throws FileNotFoundException if the path does not exist
+   * @throws IOException on path canonicalization failures
+   */
+  public static String getQualifiedBinPath(String executable)
+      throws IOException {
+    return getQualifiedBin(executable).getCanonicalPath();
+  }
+
+  /**
+   * Location of winutils as a string; null if not found.
+   * <p>
+   * <i>Important: caller must check for this value being null</i>.
+   * The lack of such checks has led to many support issues being raised.
+   * <p>
+   * @deprecated use one of the exception-raising getter methods,
+   * specifically {@link #getWinutilsPath()} or {@link #getWinutilsFile()}
+   */
+  @Deprecated
+  public static final String WINUTILS;
+
+  /** Canonical path to winutils, private to Shell. */
+  private static final String WINUTILS_PATH;
+
+  /** file reference to winutils. */
+  private static final File WINUTILS_FILE;
+
+  /** the exception raised on a failure to init the WINUTILS fields. */
+  private static final IOException WINUTILS_FAILURE;
+
+  /*
+   * Static WINUTILS_* field initializer.
+   * On non-Windows systems sets the paths to null, and
+   * adds a specific exception to the failure cause, so
+   * that on any attempt to resolve the paths will raise
+   * a meaningful exception.
+   */
+  static {
+    IOException ioe = null;
+    String path = null;
+    File file = null;
+    // invariant: either there's a valid file and path,
+    // or there is a cached IO exception.
+    if (WINDOWS) {
+      try {
+        file = getQualifiedBin(WINUTILS_EXE);
+        path = file.getCanonicalPath();
+        ioe = null;
+      } catch (IOException e) {
+        LOG.warn("Did not find {}: {}", WINUTILS_EXE, e);
+        // stack trace comes at debug level
+        LOG.debug("Failed to find " + WINUTILS_EXE, e);
+        file = null;
+        path = null;
+        ioe = e;
+      }
+    } else {
+      // on a non-windows system, the invariant is kept
+      // by adding an explicit exception.
+      ioe = new FileNotFoundException(E_NOT_A_WINDOWS_SYSTEM);
+    }
+    WINUTILS_PATH = path;
+    WINUTILS_FILE = file;
+
+    WINUTILS = path;
+    WINUTILS_FAILURE = ioe;
+  }
+
+  /**
+   * Predicate to indicate whether or not the path to winutils is known.
+   *
+   * If true, then {@link #WINUTILS} is non-null, and both
+   * {@link #getWinutilsPath()} and {@link #getWinutilsFile()}
+   * will successfully return this value. Always false on non-windows systems.
+   * @return true if there is a valid path to the binary
+   */
+  public static boolean hasWinutilsPath() {
+    return WINUTILS_PATH != null;
+  }
+
+  /**
+   * Locate the winutils binary, or fail with a meaningful
+   * exception and stack trace as an RTE.
+   * This method is for use in methods which don't explicitly throw
+   * an <code>IOException</code>.
+   * @return the path to {@link #WINUTILS_EXE}
+   * @throws RuntimeException if the path is not resolvable
+   */
+  public static String getWinutilsPath() {
+    if (WINUTILS_FAILURE == null) {
+      return WINUTILS_PATH;
+    } else {
+      throw new RuntimeException(WINUTILS_FAILURE.toString(),
+          WINUTILS_FAILURE);
+    }
+  }
+
+  /**
+   * Get a file reference to winutils.
+   * Always raises an exception if there isn't one
+   * @return the file instance referring to the winutils bin.
+   * @throws FileNotFoundException on any failure to locate that file.
+   */
+  public static File getWinutilsFile() throws FileNotFoundException {
+    if (WINUTILS_FAILURE == null) {
+      return WINUTILS_FILE;
+    } else {
+      // raise a new exception to generate a new stack trace
+      throw fileNotFoundException(WINUTILS_FAILURE.toString(),
+          WINUTILS_FAILURE);
+    }
+  /**
+   * Flag which is true if setsid exists.
+   */
+
+  /**
+   * Look for <code>setsid</code>.
+   * @return true if <code>setsid</code> was present
+   */
-      if (err.getMessage().contains("posix_spawn is not " +
+      if (err.getMessage() != null
+          && err.getMessage().contains("posix_spawn is not " +
-  /** Token separator regex used to parse Shell tool outputs */
+  /** Token separator regex used to parse Shell tool outputs. */
-  private long    interval;   // refresh interval in msec
-  private long    lastTime;   // last time the command was performed
-  final private boolean redirectErrorStream; // merge stdout and stderr
+  private long interval;   // refresh interval in msec
+  private long lastTime;   // last time the command was performed
+  private final boolean redirectErrorStream; // merge stdout and stderr
-  /**If or not script finished executing*/
-  private volatile AtomicBoolean completed;
-  
-  public Shell() {
+  /** Flag to indicate whether or not the script has finished executing. */
+  private final AtomicBoolean completed = new AtomicBoolean(false);
+
+  /**
+   * Create an instance with no minimum interval between runs; stderr is
+   * not merged with stdout.
+   */
+  protected Shell() {
-  
-  public Shell(long interval) {
+
+  /**
+   * Create an instance with a minimum interval between executions; stderr is
+   * not merged with stdout.
+   * @param interval interval in milliseconds between command executions.
+   */
+  protected Shell(long interval) {
-   * @param interval the minimum duration to wait before re-executing the 
-   *        command.
+   * Create a shell instance which can be re-executed when the {@link #run()}
+   * method is invoked with a given elapsed time between calls.
+   *
+   * @param interval the minimum duration in milliseconds to wait before
+   *        re-executing the command. If set to 0, there is no minimum.
+   * @param redirectErrorStream should the error stream be merged with
+   *        the normal output stream?
-  public Shell(long interval, boolean redirectErrorStream) {
+  protected Shell(long interval, boolean redirectErrorStream) {
-    this.lastTime = (interval<0) ? 0 : -interval;
+    this.lastTime = (interval < 0) ? 0 : -interval;
-  
-  /** set the environment for the command 
+
+  /**
+   * Set the environment for the command.
-  /** set the working directory 
-   * @param dir The directory where the command would be executed
+  /**
+   * Set the working directory.
+   * @param dir The directory where the command will be executed
-  /** check to see if a command needs to be executed and execute if needed */
+  /** Check to see if a command needs to be executed and execute if needed. */
-    if (lastTime + interval > Time.monotonicNow())
+    if (lastTime + interval > Time.monotonicNow()) {
+    }
-  /** Run a command */
+  /** Run the command. */
-    timedOut = new AtomicBoolean(false);
-    completed = new AtomicBoolean(false);
-    
+    timedOut.set(false);
+    completed.set(false);
+
-    BufferedReader inReader = 
+    BufferedReader inReader =
-    
+
-  /** return an array containing the command name & its parameters */ 
+  /** return an array containing the command name and its parameters. */
-  
+
-  /** 
-   * Get the environment variable
+  /**
+   * Get an environment variable.
+   * @param env the environment var
+   * @return the value or null if it was unset.
-  
-  /** get the current sub-process executing the given command 
+
+  /** get the current sub-process executing the given command.
-  /** get the exit code 
+  /** get the exit code.
-    
+
-    
+
-  
+
-    
+
-  
+
-   * <code>ShellCommandExecutor</code>should be used in cases where the output 
-   * of the command needs no explicit parsing and where the command, working 
-   * directory and the environment remains unchanged. The output of the command 
+   * <code>ShellCommandExecutor</code>should be used in cases where the output
+   * of the command needs no explicit parsing and where the command, working
+   * directory and the environment remains unchanged. The output of the command
-    
+
-    
-    
+
+
-    
+
-   
-    public ShellCommandExecutor(String[] execString, File dir, 
+
+    public ShellCommandExecutor(String[] execString, File dir,
-     *                command will be killed and the status marked as timedout.
+     *                command will be killed and the status marked as timed-out.
-        
-    /** Execute the shell command. */
+    /**
+     * Execute the shell command.
+     * @throws IOException if the command fails, or if the command is
+     * not well constructed.
+     */
+      for (String s : command) {
+        if (s == null) {
+          throw new IOException("(null) entry in command string: "
+              + StringUtils.join(" ", command));
+        }
+      }
-    
-    /** Get the output of the shell command.*/
+
+    /** Get the output of the shell command. */
-  
+
-  
+
-   * Set if the command has timed out.
+   * Declare that the command has timed out.
-  
+
-  
-  /** 
-   * Static method to execute a shell command. 
-   * Covers most of the simple cases without requiring the user to implement  
+
+  /**
+   * Static method to execute a shell command.
+   * Covers most of the simple cases without requiring the user to implement
-   * @return the output of the executed command.o
+   * @return the output of the executed command.
+   * @throws IOException on any problem.
-  
+
-  /** 
-   * Static method to execute a shell command. 
-   * Covers most of the simple cases without requiring the user to implement  
+  /**
+   * Static method to execute a shell command.
+   * Covers most of the simple cases without requiring the user to implement
+   * @throws IOException on any problem.
-  public static String execCommand(Map<String,String> env, String ... cmd) 
+  public static String execCommand(Map<String,String> env, String ... cmd)
-  
+
-    private Shell shell;
+    private final Shell shell;

MOV26 MOV26 INS26 INS26 INS40 INS40 UPD40 UPD40 INS78 INS83 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS23 INS28 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS23 INS23 INS28 INS31 INS31 INS31 INS40 UPD40 UPD43 INS29 MOV83 MOV83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 MOV43 INS59 INS29 INS78 MOV29 INS78 MOV83 INS83 MOV83 INS39 INS59 INS29 INS83 MOV83 INS83 MOV43 MOV59 INS29 INS83 INS29 INS83 INS43 INS43 INS83 INS83 MOV43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS29 INS78 INS83 INS43 INS42 INS44 INS43 MOV8 MOV25 INS29 INS83 INS43 INS29 INS83 INS83 INS83 INS43 INS59 INS83 INS8 INS29 INS83 INS83 MOV43 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS83 MOV43 MOV42 MOV43 INS8 INS29 INS83 INS83 INS43 INS42 INS43 MOV8 MOV29 MOV83 MOV83 INS43 INS42 INS44 INS43 INS8 INS29 UPD83 MOV83 INS43 UPD42 MOV42 INS44 MOV44 INS43 MOV8 INS29 INS83 INS83 MOV43 INS42 INS44 MOV43 INS8 INS78 INS43 INS29 INS83 INS83 INS83 MOV43 INS59 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS43 INS59 INS83 INS8 INS29 INS83 INS83 INS39 INS42 INS8 INS29 INS83 INS83 INS43 INS42 INS8 INS29 INS83 INS83 INS43 INS42 INS43 INS8 INS29 INS29 INS83 UPD83 INS29 UPD83 INS29 UPD83 UPD83 UPD66 UPD66 UPD42 INS65 INS42 INS42 INS45 INS65 INS42 INS42 INS45 INS65 INS42 INS42 INS45 INS65 INS42 INS45 INS65 INS65 INS65 INS42 UPD42 INS65 UPD65 INS42 INS42 INS42 INS65 INS65 INS65 INS65 INS65 MOV14 INS65 INS65 INS42 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS45 INS65 INS65 INS65 INS42 INS42 MOV43 INS42 INS42 INS61 INS61 INS25 INS25 INS41 INS65 INS42 UPD42 INS65 INS42 INS42 INS60 INS60 INS54 INS21 INS21 INS65 INS65 INS65 MOV43 INS42 INS41 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS41 INS65 INS65 INS65 INS41 INS65 INS65 INS65 INS42 INS42 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS42 MOV43 INS42 INS42 INS60 INS60 INS25 INS25 INS25 INS54 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS42 INS42 INS65 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS60 MOV60 INS60 INS25 INS21 INS21 INS21 INS21 INS65 INS65 INS41 INS65 INS65 INS65 INS42 INS25 INS65 INS65 INS65 INS42 INS42 INS25 INS65 INS65 INS65 MOV14 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS8 INS65 INS65 INS83 UPD42 UPD42 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS9 INS66 INS65 INS66 UPD66 UPD66 UPD66 UPD66 INS66 INS65 INS66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS66 INS66 UPD66 INS66 INS65 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS66 INS42 INS66 INS66 MOV43 MOV27 INS32 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS66 INS66 INS42 INS66 INS66 MOV27 MOV32 INS8 MOV32 MOV8 INS32 INS8 MOV38 INS8 MOV38 MOV38 INS8 INS42 INS66 INS66 INS66 MOV43 INS59 MOV43 INS59 INS8 MOV12 INS7 INS7 INS66 INS42 INS66 INS66 INS16 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS11 INS66 INS66 INS42 INS66 INS32 INS66 INS66 INS66 INS42 INS66 UPD27 UPD42 UPD66 INS42 INS66 INS66 INS42 INS66 INS42 INS32 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS43 INS59 INS43 INS59 INS38 INS8 INS38 INS8 INS43 INS38 INS8 INS8 INS12 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS66 INS66 INS66 UPD66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 MOV43 INS59 INS43 INS43 INS59 INS42 INS8 INS8 INS7 INS7 INS7 INS7 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS66 INS27 INS66 INS66 INS66 INS66 INS66 INS65 INS42 INS66 INS27 INS8 INS8 INS66 INS66 INS66 INS42 INS66 INS27 INS8 INS8 INS66 INS66 INS66 UPD66 UPD66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS65 INS66 UPD66 UPD66 INS42 INS66 INS66 UPD66 UPD66 UPD66 UPD66 INS8 UPD66 INS32 INS32 UPD66 UPD66 INS42 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 INS70 MOV21 UPD66 UPD66 UPD66 UPD66 INS42 INS66 UPD66 UPD66 INS42 INS66 INS67 UPD42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS53 INS53 INS53 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS36 INS42 INS66 INS43 INS32 INS32 INS42 UPD42 INS42 INS32 INS42 INS68 INS42 INS42 INS45 INS42 INS42 INS14 INS32 INS53 INS32 INS53 INS42 INS32 INS53 MOV41 INS44 INS8 INS32 INS42 INS68 INS68 INS42 INS33 INS42 UPD42 INS42 INS42 INS33 MOV54 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS67 INS68 INS68 INS42 INS33 INS67 INS42 INS33 INS41 INS53 INS42 INS33 INS41 INS53 INS68 INS41 INS42 INS42 INS9 INS42 INS42 INS9 UPD66 UPD66 INS42 INS66 INS66 INS44 INS42 INS8 UPD66 INS42 INS5 MOV5 INS42 INS7 INS14 INS14 INS14 INS7 INS7 INS21 INS27 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS69 INS43 INS42 INS45 INS42 INS42 INS14 INS42 INS42 INS14 INS43 INS42 INS42 INS42 INS42 INS14 MOV43 INS42 INS53 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS43 INS42 INS25 INS32 INS43 INS85 INS32 INS32 MOV43 INS32 INS32 INS43 INS42 INS42 INS32 INS43 INS42 INS43 INS27 INS43 INS43 INS27 INS42 MOV32 INS42 INS33 INS7 INS42 INS45 INS42 INS43 INS42 INS42 INS32 INS42 INS43 INS42 INS43 INS32 INS43 INS32 INS42 INS43 INS32 INS43 INS32 UPD42 INS32 INS21 MOV21 INS21 INS42 INS14 INS43 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS8 UPD42 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 UPD34 INS42 INS42 INS45 INS42 INS45 INS42 INS42 UPD45 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS32 INS42 INS7 INS7 MOV43 UPD42 INS21 INS21 INS21 INS21 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS33 INS53 UPD45 UPD45 INS32 INS32 MOV5 INS4 MOV5 INS42 INS42 INS42 INS42 INS45 INS42 INS42 UPD42 MOV42 UPD45 MOV45 UPD42 MOV42 INS42 UPD45 MOV45 UPD42 MOV42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 UPD42 INS42 INS33 INS32 INS7 INS7 INS7 INS42 INS27 MOV32 INS14 INS42 INS42 INS32 MOV45 MOV45 MOV42 INS32 INS42 INS42 INS42 UPD42 INS42 INS42 INS45 INS42 INS42 UPD42 INS27 UPD42 INS42 INS33 INS42 INS33 INS42 INS42 INS32 INS33 INS43 INS27 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS45 INS42 DEL40 DEL45 DEL45 DEL4 DEL79 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL34 DEL34 DEL32 DEL42 DEL45 DEL32 DEL34 DEL27 DEL59 DEL23 DEL42 DEL23 DEL83 DEL42 DEL36 DEL42 DEL42 DEL36 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL4 DEL40 DEL66 DEL45 DEL45 DEL54 DEL42 DEL45 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL45 DEL14 DEL42 DEL40 DEL40 DEL27 DEL59 DEL60 DEL42 DEL45 DEL27 DEL83 DEL83 DEL83 DEL31 DEL31 DEL42 DEL32 DEL45 DEL42 DEL8 DEL25 DEL42 DEL43 DEL45 DEL83 DEL83 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL41 DEL42 DEL7 DEL42 DEL7 DEL8
HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.

+import java.text.SimpleDateFormat;
-import java.util.Calendar;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.TimeZone;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.commons.lang.StringUtils;
+import org.apache.commons.lang.exception.ExceptionUtils;
+import org.apache.hadoop.fs.CreateFlag;
+import org.apache.hadoop.fs.azure.AzureException;
+import org.apache.hadoop.fs.azure.StorageInterface.CloudBlobWrapper;
+import org.apache.hadoop.io.IOUtils;
+
+import org.codehaus.jackson.JsonNode;
+import org.codehaus.jackson.JsonParseException;
+import org.codehaus.jackson.JsonParser;
+import org.codehaus.jackson.map.JsonMappingException;
+import org.codehaus.jackson.map.ObjectMapper;
+
-import com.microsoft.windowsazure.storage.core.Utility;
+import com.microsoft.windowsazure.storage.AccessCondition;
+import com.microsoft.windowsazure.storage.OperationContext;
+import com.microsoft.windowsazure.storage.StorageException;
+import com.microsoft.windowsazure.storage.blob.CloudBlob;
+import com.microsoft.windowsazure.storage.core.*;
+  private static final int USER_WX_PERMISION = 0300;
+
+  /**
+   * A description of a folder rename operation, including the source and
+   * destination keys, and descriptions of the files in the source folder.
+   */
+  public static class FolderRenamePending {
+    private SelfRenewingLease folderLease;
+    private String srcKey;
+    private String dstKey;
+    private FileMetadata[] fileMetadata = null;    // descriptions of source files
+    private ArrayList<String> fileStrings = null;
+    private NativeAzureFileSystem fs;
+    private static final int MAX_RENAME_PENDING_FILE_SIZE = 10000000;
+    private static final int FORMATTING_BUFFER = 10000;
+    private boolean committed;
+    public static final String SUFFIX = "-RenamePending.json";
+
+    // Prepare in-memory information needed to do or redo a folder rename.
+    public FolderRenamePending(String srcKey, String dstKey, SelfRenewingLease lease,
+        NativeAzureFileSystem fs) throws IOException {
+      this.srcKey = srcKey;
+      this.dstKey = dstKey;
+      this.folderLease = lease;
+      this.fs = fs;
+      ArrayList<FileMetadata> fileMetadataList = new ArrayList<FileMetadata>();
+
+      // List all the files in the folder.
+      String priorLastKey = null;
+      do {
+        PartialListing listing = fs.getStoreInterface().listAll(srcKey, AZURE_LIST_ALL,
+          AZURE_UNBOUNDED_DEPTH, priorLastKey);
+        for(FileMetadata file : listing.getFiles()) {
+          fileMetadataList.add(file);
+        }
+        priorLastKey = listing.getPriorLastKey();
+      } while (priorLastKey != null);
+      fileMetadata = fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);
+      this.committed = true;
+    }
+
+    // Prepare in-memory information needed to do or redo folder rename from
+    // a -RenamePending.json file read from storage. This constructor is to use during
+    // redo processing.
+    public FolderRenamePending(Path redoFile, NativeAzureFileSystem fs)
+        throws IllegalArgumentException, IOException {
+
+      this.fs = fs;
+
+      // open redo file
+      Path f = redoFile;
+      FSDataInputStream input = fs.open(f);
+      byte[] bytes = new byte[MAX_RENAME_PENDING_FILE_SIZE];
+      int l = input.read(bytes);
+      if (l < 0) {
+        throw new IOException(
+            "Error reading pending rename file contents -- no data available");
+      }
+      if (l == MAX_RENAME_PENDING_FILE_SIZE) {
+        throw new IOException(
+            "Error reading pending rename file contents -- "
+                + "maximum file size exceeded");
+      }
+      String contents = new String(bytes, 0, l);
+
+      // parse the JSON
+      ObjectMapper objMapper = new ObjectMapper();
+      objMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
+      JsonNode json = null;
+      try {
+        json = objMapper.readValue(contents, JsonNode.class);
+        this.committed = true;
+      } catch (JsonMappingException e) {
+
+        // The -RedoPending.json file is corrupted, so we assume it was
+        // not completely written
+        // and the redo operation did not commit.
+        this.committed = false;
+      } catch (JsonParseException e) {
+        this.committed = false;
+      } catch (IOException e) {
+        this.committed = false;  
+      }
+      
+      if (!this.committed) {
+        LOG.error("Deleting corruped rename pending file "
+            + redoFile + "\n" + contents);
+
+        // delete the -RenamePending.json file
+        fs.delete(redoFile, false);
+        return;
+      }
+
+      // initialize this object's fields
+      ArrayList<String> fileStrList = new ArrayList<String>();
+      JsonNode oldFolderName = json.get("OldFolderName");
+      JsonNode newFolderName = json.get("NewFolderName");
+      if (oldFolderName == null || newFolderName == null) {
+    	  this.committed = false;
+      } else {
+        this.srcKey = oldFolderName.getTextValue();
+        this.dstKey = newFolderName.getTextValue();
+        if (this.srcKey == null || this.dstKey == null) {
+          this.committed = false;    	  
+        } else {
+          JsonNode fileList = json.get("FileList");
+          if (fileList == null) {
+            this.committed = false;	
+          } else {
+            for (int i = 0; i < fileList.size(); i++) {
+              fileStrList.add(fileList.get(i).getTextValue());
+            }
+          }
+        }
+      }
+      this.fileStrings = fileStrList;
+    }
+
+    public FileMetadata[] getFiles() {
+      return fileMetadata;
+    }
+
+    public SelfRenewingLease getFolderLease() {
+      return folderLease;
+    }
+
+    /**
+     * Write to disk the information needed to redo folder rename, in JSON format.
+     * The file name will be wasb://<sourceFolderPrefix>/folderName-RenamePending.json
+     * The file format will be:
+     * {
+     *   FormatVersion: "1.0",
+     *   OperationTime: "<YYYY-MM-DD HH:MM:SS.MMM>",
+     *   OldFolderName: "<key>",
+     *   NewFolderName: "<key>",
+     *   FileList: [ <string> , <string> , ... ]
+     * }
+     *
+     * Here's a sample:
+     * {
+     *  FormatVersion: "1.0",
+     *  OperationUTCTime: "2014-07-01 23:50:35.572",
+     *  OldFolderName: "user/ehans/folderToRename",
+     *  NewFolderName: "user/ehans/renamedFolder",
+     *  FileList: [
+     *    "innerFile",
+     *    "innerFile2"
+     *  ]
+     * }
+     * @throws IOException
+     */
+    public void writeFile(FileSystem fs) throws IOException {
+      Path path = getRenamePendingFilePath();
+      if (LOG.isDebugEnabled()){
+        LOG.debug("Preparing to write atomic rename state to " + path.toString());
+      }
+      OutputStream output = null;
+
+      String contents = makeRenamePendingFileContents();
+
+      // Write file.
+      try {
+        output = fs.create(path);
+        output.write(contents.getBytes());
+      } catch (IOException e) {
+        throw new IOException("Unable to write RenamePending file for folder rename from "
+            + srcKey + " to " + dstKey, e);
+      } finally {
+        IOUtils.cleanup(LOG, output);
+      }
+    }
+
+    /**
+     * Return the contents of the JSON file to represent the operations
+     * to be performed for a folder rename.
+     */
+    public String makeRenamePendingFileContents() {
+      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
+      sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
+      String time = sdf.format(new Date());
+
+      // Make file list string
+      StringBuilder builder = new StringBuilder();
+      builder.append("[\n");
+      for (int i = 0; i != fileMetadata.length; i++) {
+        if (i > 0) {
+          builder.append(",\n");
+        }
+        builder.append("    ");
+        String noPrefix = StringUtils.removeStart(fileMetadata[i].getKey(), srcKey + "/");
+
+        // Quote string file names, escaping any possible " characters or other
+        // necessary characters in the name.
+        builder.append(quote(noPrefix));
+        if (builder.length() >=
+            MAX_RENAME_PENDING_FILE_SIZE - FORMATTING_BUFFER) {
+
+          // Give up now to avoid using too much memory.
+          LOG.error("Internal error: Exceeded maximum rename pending file size of "
+              + MAX_RENAME_PENDING_FILE_SIZE + " bytes.");
+
+          // return some bad JSON with an error message to make it human readable
+          return "exceeded maximum rename pending file size";
+        }
+      }
+      builder.append("\n  ]");
+      String fileList = builder.toString();
+
+      // Make file contents as a string. Again, quote file names, escaping
+      // characters as appropriate.
+      String contents = "{\n"
+          + "  FormatVersion: \"1.0\",\n"
+          + "  OperationUTCTime: \"" + time + "\",\n"
+          + "  OldFolderName: " + quote(srcKey) + ",\n"
+          + "  NewFolderName: " + quote(dstKey) + ",\n"
+          + "  FileList: " + fileList + "\n"
+          + "}\n";
+
+      return contents;
+    }
+    
+    /**
+     * This is an exact copy of org.codehaus.jettison.json.JSONObject.quote 
+     * method.
+     * 
+     * Produce a string in double quotes with backslash sequences in all the
+     * right places. A backslash will be inserted within </, allowing JSON
+     * text to be delivered in HTML. In JSON text, a string cannot contain a
+     * control character or an unescaped quote or backslash.
+     * @param string A String
+     * @return  A String correctly formatted for insertion in a JSON text.
+     */
+    private String quote(String string) {
+        if (string == null || string.length() == 0) {
+            return "\"\"";
+        }
+
+        char c = 0;
+        int  i;
+        int  len = string.length();
+        StringBuilder sb = new StringBuilder(len + 4);
+        String t;
+
+        sb.append('"');
+        for (i = 0; i < len; i += 1) {
+            c = string.charAt(i);
+            switch (c) {
+            case '\\':
+            case '"':
+                sb.append('\\');
+                sb.append(c);
+                break;
+            case '/':
+                sb.append('\\');
+                sb.append(c);
+                break;
+            case '\b':
+                sb.append("\\b");
+                break;
+            case '\t':
+                sb.append("\\t");
+                break;
+            case '\n':
+                sb.append("\\n");
+                break;
+            case '\f':
+                sb.append("\\f");
+                break;
+            case '\r':
+                sb.append("\\r");
+                break;
+            default:
+                if (c < ' ') {
+                    t = "000" + Integer.toHexString(c);
+                    sb.append("\\u" + t.substring(t.length() - 4));
+                } else {
+                    sb.append(c);
+                }
+            }
+        }
+        sb.append('"');
+        return sb.toString();
+    }
+
+    public String getSrcKey() {
+      return srcKey;
+    }
+
+    public String getDstKey() {
+      return dstKey;
+    }
+
+    public FileMetadata getSourceMetadata() throws IOException {
+      return fs.getStoreInterface().retrieveMetadata(srcKey);
+    }
+
+    /**
+     * Execute a folder rename. This is the execution path followed
+     * when everything is working normally. See redo() for the alternate
+     * execution path for the case where we're recovering from a folder rename
+     * failure.
+     * @throws IOException
+     */
+    public void execute() throws IOException {
+
+      for (FileMetadata file : this.getFiles()) {
+
+        // Rename all materialized entries under the folder to point to the
+        // final destination.
+        if (file.getBlobMaterialization() == BlobMaterialization.Explicit) {
+          String srcName = file.getKey();
+          String suffix  = srcName.substring((this.getSrcKey()).length());
+          String dstName = this.getDstKey() + suffix;
+
+          // Rename gets exclusive access (via a lease) for files
+          // designated for atomic rename.
+          // The main use case is for HBase write-ahead log (WAL) and data
+          // folder processing correctness.  See the rename code for details.
+          boolean acquireLease = fs.getStoreInterface().isAtomicRenameKey(srcName);
+          fs.getStoreInterface().rename(srcName, dstName, acquireLease, null);
+        }
+      }
+
+      // Rename the source folder 0-byte root file itself.
+      FileMetadata srcMetadata2 = this.getSourceMetadata();
+      if (srcMetadata2.getBlobMaterialization() ==
+          BlobMaterialization.Explicit) {
+
+        // It already has a lease on it from the "prepare" phase so there's no
+        // need to get one now. Pass in existing lease to allow file delete.
+        fs.getStoreInterface().rename(this.getSrcKey(), this.getDstKey(),
+            false, folderLease);
+      }
+
+      // Update the last-modified time of the parent folders of both source and
+      // destination.
+      fs.updateParentFolderLastModifiedTime(srcKey);
+      fs.updateParentFolderLastModifiedTime(dstKey);
+    }
+
+    /** Clean up after execution of rename.
+     * @throws IOException */
+    public void cleanup() throws IOException {
+
+      if (fs.getStoreInterface().isAtomicRenameKey(srcKey)) {
+
+        // Remove RenamePending file
+        fs.delete(getRenamePendingFilePath(), false);
+
+        // Freeing source folder lease is not necessary since the source
+        // folder file was deleted.
+      }
+    }
+
+    private Path getRenamePendingFilePath() {
+      String fileName = srcKey + SUFFIX;
+      Path fileNamePath = keyToPath(fileName);
+      Path path = fs.makeAbsolute(fileNamePath);
+      return path;
+    }
+
+    /**
+     * Recover from a folder rename failure by redoing the intended work,
+     * as recorded in the -RenamePending.json file.
+     * 
+     * @throws IOException
+     */
+    public void redo() throws IOException {
+
+      if (!committed) {
+
+        // Nothing to do. The -RedoPending.json file should have already been
+        // deleted.
+        return;
+      }
+
+      // Try to get a lease on source folder to block concurrent access to it.
+      // It may fail if the folder is already gone. We don't check if the
+      // source exists explicitly because that could recursively trigger redo
+      // and give an infinite recursion.
+      SelfRenewingLease lease = null;
+      boolean sourceFolderGone = false;
+      try {
+        lease = fs.leaseSourceFolder(srcKey);
+      } catch (AzureException e) {
+
+        // If the source folder was not found then somebody probably
+        // raced with us and finished the rename first, or the
+        // first rename failed right before deleting the rename pending
+        // file.
+        String errorCode = "";
+        try {
+          StorageException se = (StorageException) e.getCause();
+          errorCode = se.getErrorCode();
+        } catch (Exception e2) {
+          ; // do nothing -- could not get errorCode
+        }
+        if (errorCode.equals("BlobNotFound")) {
+          sourceFolderGone = true;
+        } else {
+          throw new IOException(
+              "Unexpected error when trying to lease source folder name during "
+              + "folder rename redo",
+              e);
+        }
+      }
+
+      if (!sourceFolderGone) {
+        // Make sure the target folder exists.
+        Path dst = fullPath(dstKey);
+        if (!fs.exists(dst)) {
+          fs.mkdirs(dst);
+        }
+
+        // For each file inside the folder to be renamed,
+        // make sure it has been renamed.
+        for(String fileName : fileStrings) {
+          finishSingleFileRename(fileName);
+        }
+
+        // Remove the source folder. Don't check explicitly if it exists,
+        // to avoid triggering redo recursively.
+        try {
+          fs.getStoreInterface().delete(srcKey, lease);
+        } catch (Exception e) {
+          LOG.info("Unable to delete source folder during folder rename redo. "
+              + "If the source folder is already gone, this is not an error "
+              + "condition. Continuing with redo.", e);
+        }
+
+        // Update the last-modified time of the parent folders of both source
+        // and destination.
+        fs.updateParentFolderLastModifiedTime(srcKey);
+        fs.updateParentFolderLastModifiedTime(dstKey);
+      }
+
+      // Remove the -RenamePending.json file.
+      fs.delete(getRenamePendingFilePath(), false);
+    }
+
+    // See if the source file is still there, and if it is, rename it.
+    private void finishSingleFileRename(String fileName)
+        throws IOException {
+      Path srcFile = fullPath(srcKey, fileName);
+      Path dstFile = fullPath(dstKey, fileName);
+      boolean srcExists = fs.exists(srcFile);
+      boolean dstExists = fs.exists(dstFile);
+      if (srcExists && !dstExists) {
+
+        // Rename gets exclusive access (via a lease) for HBase write-ahead log
+        // (WAL) file processing correctness.  See the rename code for details.
+        String srcName = fs.pathToKey(srcFile);
+        String dstName = fs.pathToKey(dstFile);
+        fs.getStoreInterface().rename(srcName, dstName, true, null);
+      } else if (srcExists && dstExists) {
+
+        // Get a lease on source to block write access.
+        String srcName = fs.pathToKey(srcFile);
+        SelfRenewingLease lease = fs.acquireLease(srcFile);
+
+        // Delete the file. This will free the lease too.
+        fs.getStoreInterface().delete(srcName, lease);
+      } else if (!srcExists && dstExists) {
+
+        // The rename already finished, so do nothing.
+        ;
+      } else {
+        throw new IOException(
+            "Attempting to complete rename of file " + srcKey + "/" + fileName
+            + " during folder rename redo, and file was not found in source "
+            + "or destination.");
+      }
+    }
+
+    // Return an absolute path for the specific fileName within the folder
+    // specified by folderKey.
+    private Path fullPath(String folderKey, String fileName) {
+      return new Path(new Path(fs.getUri()), "/" + folderKey + "/" + fileName);
+    }
+
+    private Path fullPath(String fileKey) {
+      return new Path(new Path(fs.getUri()), "/" + fileKey);
+    }
+  }
+
+  private static final String TRAILING_PERIOD_PLACEHOLDER = "[[.]]";
+  private static final Pattern TRAILING_PERIOD_PLACEHOLDER_PATTERN =
+      Pattern.compile("\\[\\[\\.\\]\\](?=$|/)");
+  private static final Pattern TRAILING_PERIOD_PATTERN = Pattern.compile("\\.(?=$|/)");
-  static final String AZURE_BLOCK_LOCATION_HOST_PROPERTY_NAME = "fs.azure.block.location.impersonatedhost";
-  private static final String AZURE_BLOCK_LOCATION_HOST_DEFAULT = "localhost";
+  static final String AZURE_BLOCK_LOCATION_HOST_PROPERTY_NAME =
+      "fs.azure.block.location.impersonatedhost";
+  private static final String AZURE_BLOCK_LOCATION_HOST_DEFAULT =
+      "localhost";
+  static final String AZURE_RINGBUFFER_CAPACITY_PROPERTY_NAME =
+      "fs.azure.ring.buffer.capacity";
+  static final String AZURE_OUTPUT_STREAM_BUFFER_SIZE_PROPERTY_NAME =
+      "fs.azure.output.stream.buffer.size";
+    private boolean closed = false;
+    private boolean isPageBlob;
-    public NativeAzureFsInputStream(DataInputStream in, String key) {
+    // File length, valid only for streams over block blobs.
+    private long fileLength;
+
+    public NativeAzureFsInputStream(DataInputStream in, String key, long fileLength) {
+      this.isPageBlob = store.isPageBlobKey(key);
+      this.fileLength = fileLength;
+    }
+
+    /**
+     * Return the size of the remaining available bytes
+     * if the size is less than or equal to {@link Integer#MAX_VALUE},
+     * otherwise, return {@link Integer#MAX_VALUE}.
+     *
+     * This is to match the behavior of DFSInputStream.available(),
+     * which some clients may rely on (HBase write-ahead log reading in
+     * particular).
+     */
+    @Override
+    public synchronized int available() throws IOException {
+      if (isPageBlob) {
+        return in.available();
+      } else {
+        if (closed) {
+          throw new IOException("Stream closed");
+        }
+        final long remaining = this.fileLength - pos;
+        return remaining <= Integer.MAX_VALUE ?
+            (int) remaining : Integer.MAX_VALUE;
+      }
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-    public synchronized void close() throws IOException {
+    public void close() throws IOException {
+      closed = true;
-      in.close();
-      in = store.retrieve(key, pos);
-      this.pos = pos;
+     in.close();
+     in = store.retrieve(key);
+     this.pos = in.skip(pos);
+     if (LOG.isDebugEnabled()) {
+       LOG.debug(String.format("Seek to position %d. Bytes skipped %d", pos,
+         this.pos));
+     }
-  public void initialize(URI uri, Configuration conf) throws IOException {
+  public void initialize(URI uri, Configuration conf)
+      throws IOException, IllegalArgumentException {
-  // Note: The logic for this method is confusing as to whether it strips the
-  // last slash or not (it adds it in the beginning, then strips it at the end).
-  // We should revisit that.
-  private String pathToKey(Path path) {
+  /**
+   * Azure Storage doesn't allow the blob names to end in a period,
+   * so encode this here to work around that limitation.
+   */
+  private static String encodeTrailingPeriod(String toEncode) {
+    Matcher matcher = TRAILING_PERIOD_PATTERN.matcher(toEncode);
+    return matcher.replaceAll(TRAILING_PERIOD_PLACEHOLDER);
+  }
+
+  /**
+   * Reverse the encoding done by encodeTrailingPeriod().
+   */
+  private static String decodeTrailingPeriod(String toDecode) {
+    Matcher matcher = TRAILING_PERIOD_PLACEHOLDER_PATTERN.matcher(toDecode);
+    return matcher.replaceAll(".");
+  }
+
+  /**
+   * Convert the path to a key. By convention, any leading or trailing slash is
+   * removed, except for the special case of a single slash.
+   */
+  @VisibleForTesting
+  public String pathToKey(Path path) {
+    key = removeTrailingSlash(key);
+    key = encodeTrailingPeriod(key);
+  // Remove any trailing slash except for the case of a single slash.
+  private static String removeTrailingSlash(String key) {
+    if (key.length() == 0 || key.length() == 1) {
+      return key;
+    }
+    if (key.charAt(key.length() - 1) == '/') {
+      return key.substring(0, key.length() - 1);
+    } else {
+      return key;
+    }
+  }
+
-    return new Path("/" + key);
+    return new Path("/" + decodeTrailingPeriod(key));
-  private Path makeAbsolute(Path path) {
+  /**
+   * Get the absolute version of the path (fully qualified).
+   * This is public for testing purposes.
+   *
+   * @param path
+   * @return fully qualified path
+   */
+  @VisibleForTesting
+  public Path makeAbsolute(Path path) {
+  NativeFileSystemStore getStoreInterface() {
+    return store;
+  }
+
+    return create(f, permission, overwrite, true,
+        bufferSize, replication, blockSize, progress,
+        (SelfRenewingLease) null);
+  }
+
+  /**
+   * Get a self-renewing lease on the specified file.
+   */
+  public SelfRenewingLease acquireLease(Path path) throws AzureException {
+    String fullKey = pathToKey(makeAbsolute(path));
+    return getStore().acquireLease(fullKey);
+  }
+
+  @Override
+  @SuppressWarnings("deprecation")
+  public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,
+      boolean overwrite, int bufferSize, short replication, long blockSize,
+      Progressable progress) throws IOException {
+
+    Path parent = f.getParent();
+
+    // Get exclusive access to folder if this is a directory designated
+    // for atomic rename. The primary use case of for HBase write-ahead
+    // log file management.
+    SelfRenewingLease lease = null;
+    if (store.isAtomicRenameKey(pathToKey(f))) {
+      try {
+        lease = acquireLease(parent);
+      } catch (AzureException e) {
+
+        String errorCode = "";
+        try {
+          StorageException e2 = (StorageException) e.getCause();
+          errorCode = e2.getErrorCode();
+        } catch (Exception e3) {
+          // do nothing if cast fails
+        }
+        if (errorCode.equals("BlobNotFound")) {
+          throw new FileNotFoundException("Cannot create file " +
+              f.getName() + " because parent folder does not exist.");
+        }
+
+        LOG.warn("Got unexpected exception trying to get lease on "
+          + pathToKey(parent) + ". " + e.getMessage());
+        throw e;
+      }
+    }
+
+    // See if the parent folder exists. If not, throw error.
+    // The exists() check will push any pending rename operation forward,
+    // if there is one, and return false.
+    //
+    // At this point, we have exclusive access to the source folder
+    // via the lease, so we will not conflict with an active folder
+    // rename operation.
+    if (!exists(parent)) {
+      try {
+
+        // This'll let the keep-alive thread exit as soon as it wakes up.
+        lease.free();
+      } catch (Exception e) {
+        LOG.warn("Unable to free lease because: " + e.getMessage());
+      }
+      throw new FileNotFoundException("Cannot create file " +
+          f.getName() + " because parent folder does not exist.");
+    }
+
+    // Create file inside folder.
+    FSDataOutputStream out = null;
+    try {
+      out = create(f, permission, overwrite, false,
+          bufferSize, replication, blockSize, progress, lease);
+    } finally {
+      // Release exclusive access to folder.
+      try {
+        if (lease != null) {
+          lease.free();
+        }
+      } catch (Exception e) {
+        IOUtils.cleanup(LOG, out);
+        String msg = "Unable to free lease on " + parent.toUri();
+        LOG.error(msg);
+        throw new IOException(msg, e);
+      }
+    }
+    return out;
+  }
+
+  @Override
+  @SuppressWarnings("deprecation")
+  public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,
+      EnumSet<CreateFlag> flags, int bufferSize, short replication, long blockSize,
+      Progressable progress) throws IOException {
+
+    // Check if file should be appended or overwritten. Assume that the file
+    // is overwritten on if the CREATE and OVERWRITE create flags are set. Note
+    // that any other combinations of create flags will result in an open new or
+    // open with append.
+    final EnumSet<CreateFlag> createflags =
+        EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE);
+    boolean overwrite = flags.containsAll(createflags);
+
+    // Delegate the create non-recursive call.
+    return this.createNonRecursive(f, permission, overwrite,
+        bufferSize, replication, blockSize, progress);
+  }
+
+  @Override
+  @SuppressWarnings("deprecation")
+  public FSDataOutputStream createNonRecursive(Path f,
+      boolean overwrite, int bufferSize, short replication, long blockSize,
+      Progressable progress) throws IOException {
+    return this.createNonRecursive(f, FsPermission.getFileDefault(),
+        overwrite, bufferSize, replication, blockSize, progress);
+  }
+
+
+  /**
+   * Create an Azure blob and return an output stream to use
+   * to write data to it.
+   *
+   * @param f
+   * @param permission
+   * @param overwrite
+   * @param createParent
+   * @param bufferSize
+   * @param replication
+   * @param blockSize
+   * @param progress
+   * @param parentFolderLease Lease on parent folder (or null if
+   * no lease).
+   * @return
+   * @throws IOException
+   */
+  private FSDataOutputStream create(Path f, FsPermission permission,
+      boolean overwrite, boolean createParent, int bufferSize,
+      short replication, long blockSize, Progressable progress,
+      SelfRenewingLease parentFolderLease)
+          throws IOException {
-      if (parentMetadata != null
-          && parentMetadata.isDir()
-          && parentMetadata.getBlobMaterialization() == BlobMaterialization.Explicit) {
-        store.updateFolderLastModifiedTime(parentKey);
+      if (parentMetadata != null && parentMetadata.isDir() &&
+          parentMetadata.getBlobMaterialization() == BlobMaterialization.Explicit) {
+        store.updateFolderLastModifiedTime(parentKey, parentFolderLease);
-        mkdirs(parentFolder, permission);
+        // Create it using inherited permissions from the first existing directory going up the path
+        Path firstExisting = parentFolder.getParent();
+        FileMetadata metadata = store.retrieveMetadata(pathToKey(firstExisting));
+        while(metadata == null) {
+          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata
+          firstExisting = firstExisting.getParent();
+          metadata = store.retrieveMetadata(pathToKey(firstExisting));
+        }
+        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);
-    // Open the output blob stream based on the encoded key.
-    String keyEncoded = encodeKey(key);
-
-    // First create a blob at the real key, pointing back to the temporary file
-    // This accomplishes a few things:
-    // 1. Makes sure we can create a file there.
-    // 2. Makes it visible to other concurrent threads/processes/nodes what
-    // we're
-    // doing.
-    // 3. Makes it easier to restore/cleanup data in the event of us crashing.
-    store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);
+    OutputStream bufOutStream;
+    if (store.isPageBlobKey(key)) {
+      // Store page blobs directly in-place without renames.
+      bufOutStream = store.storefile(key, permissionStatus);
+    } else {
+      // This is a block blob, so open the output blob stream based on the
+      // encoded key.
+      //
+      String keyEncoded = encodeKey(key);
-    // The key is encoded to point to a common container at the storage server.
-    // This reduces the number of splits on the server side when load balancing.
-    // Ingress to Azure storage can take advantage of earlier splits. We remove
-    // the root path to the key and prefix a random GUID to the tail (or leaf
-    // filename) of the key. Keys are thus broadly and randomly distributed over
-    // a single container to ease load balancing on the storage server. When the
-    // blob is committed it is renamed to its earlier key. Uncommitted blocks
-    // are not cleaned up and we leave it to Azure storage to garbage collect
-    // these
-    // blocks.
-    OutputStream bufOutStream = new NativeAzureFsOutputStream(store.storefile(
-        keyEncoded, permissionStatus), key, keyEncoded);
+      // First create a blob at the real key, pointing back to the temporary file
+      // This accomplishes a few things:
+      // 1. Makes sure we can create a file there.
+      // 2. Makes it visible to other concurrent threads/processes/nodes what
+      // we're
+      // doing.
+      // 3. Makes it easier to restore/cleanup data in the event of us crashing.
+      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);
+
+      // The key is encoded to point to a common container at the storage server.
+      // This reduces the number of splits on the server side when load balancing.
+      // Ingress to Azure storage can take advantage of earlier splits. We remove
+      // the root path to the key and prefix a random GUID to the tail (or leaf
+      // filename) of the key. Keys are thus broadly and randomly distributed over
+      // a single container to ease load balancing on the storage server. When the
+      // blob is committed it is renamed to its earlier key. Uncommitted blocks
+      // are not cleaned up and we leave it to Azure storage to garbage collect
+      // these
+      // blocks.
+      bufOutStream = new NativeAzureFsOutputStream(store.storefile(
+          keyEncoded, permissionStatus), key, keyEncoded);
+    }
+    return delete(f, recursive, false);
+  }
+
+  /**
+   * Delete the specified file or folder. The parameter
+   * skipParentFolderLastModifidedTimeUpdate
+   * is used in the case of atomic folder rename redo. In that case, there is
+   * a lease on the parent folder, so (without reworking the code) modifying
+   * the parent folder update time will fail because of a conflict with the
+   * lease. Since we are going to delete the folder soon anyway so accurate
+   * modified time is not necessary, it's easier to just skip
+   * the modified time update.
+   *
+   * @param f
+   * @param recursive
+   * @param skipParentFolderLastModifidedTimeUpdate If true, don't update the folder last
+   * modified time.
+   * @return true if and only if the file is deleted
+   * @throws IOException
+   */
+  public boolean delete(Path f, boolean recursive,
+      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {
-          store.updateFolderLastModifiedTime(parentKey);
+          if (!skipParentFolderLastModifidedTimeUpdate) {
+            store.updateFolderLastModifiedTime(parentKey, null);
+          }
-      instrumentation.fileDeleted();
+      instrumentation.fileDeleted();
-        store.updateFolderLastModifiedTime(parentKey);
+        if (!skipParentFolderLastModifidedTimeUpdate) {
+          store.updateFolderLastModifiedTime(parentKey, null);
+        }
+        // If a rename operation for the folder was pending, redo it.
+        // Then the file does not exist, so signal that.
+        if (conditionalRedoFolderRename(f)) {
+          throw new FileNotFoundException(
+              absolutePath + ": No such file or directory.");
+        }
+
-    // Note: Should never get to this point since the root always exists.
-    throw new FileNotFoundException(absolutePath
-        + ": No such file or directory.");
+    //
+    throw new FileNotFoundException(
+        absolutePath + ": No such file or directory.");
+  }
+
+  // Return true if there is a rename pending and we redo it, otherwise false.
+  private boolean conditionalRedoFolderRename(Path f) throws IOException {
+
+    // Can't rename /, so return immediately in that case.
+    if (f.getName().equals("")) {
+      return false;
+    }
+
+    // Check if there is a -RenamePending.json file for this folder, and if so,
+    // redo the rename.
+    Path absoluteRenamePendingFile = renamePendingFilePath(f);
+    if (exists(absoluteRenamePendingFile)) {
+      FolderRenamePending pending =
+          new FolderRenamePending(absoluteRenamePendingFile, this);
+      pending.redo();
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  // Return the path name that would be used for rename of folder with path f.
+  private Path renamePendingFilePath(Path f) {
+    Path absPath = makeAbsolute(f);
+    String key = pathToKey(absPath);
+    key += "-RenamePending.json";
+    return keyToPath(key);
+
+      // For any -RenamePending.json files in the listing,
+      // push the rename forward.
+      boolean renamed = conditionalRedoFolderRenames(listing);
+
+      // If any renames were redone, get another listing,
+      // since the current one may have changed due to the redo.
+      if (renamed) {
+        listing = store.list(key, AZURE_LIST_ALL, 1, partialKey);
+      }
+
+  // Redo any folder renames needed if there are rename pending files in the
+  // directory listing. Return true if one or more redo operations were done.
+  private boolean conditionalRedoFolderRenames(PartialListing listing)
+      throws IllegalArgumentException, IOException {
+    boolean renamed = false;
+    for (FileMetadata fileMetadata : listing.getFiles()) {
+      Path subpath = keyToPath(fileMetadata.getKey());
+      if (isRenamePendingFile(subpath)) {
+        FolderRenamePending pending =
+            new FolderRenamePending(subpath, this);
+        pending.redo();
+        renamed = true;
+      }
+    }
+    return renamed;
+  }
+
+  // True if this is a folder rename pending file, else false.
+  private boolean isRenamePendingFile(Path path) {
+    return path.toString().endsWith(FolderRenamePending.SUFFIX);
+  }
+
-    return new FileStatus(meta.getLength(), false, 1, blockSize,
-        meta.getLastModified(), 0, meta.getPermissionStatus().getPermission(),
-        meta.getPermissionStatus().getUserName(), meta.getPermissionStatus()
-            .getGroupName(),
+    return new FileStatus (
+        meta.getLength(),
+        false,
+        1,
+        blockSize,
+        meta.getLastModified(),
+        0,
+        meta.getPermissionStatus().getPermission(),
+        meta.getPermissionStatus().getUserName(),
+        meta.getPermissionStatus().getGroupName(),
-    return new FileStatus(0, true, 1, blockSize, meta == null ? 0
-        : meta.getLastModified(), 0, meta == null ? FsPermission.getDefault()
-        : meta.getPermissionStatus().getPermission(), meta == null ? "" : meta
-        .getPermissionStatus().getUserName(), meta == null ? "" : meta
-        .getPermissionStatus().getGroupName(), path.makeQualified(getUri(),
-        getWorkingDirectory()));
+    return new FileStatus (
+        0,
+        true,
+        1,
+        blockSize,
+        meta == null ? 0 : meta.getLastModified(),
+        0,
+        meta == null ? FsPermission.getDefault() : meta.getPermissionStatus().getPermission(),
+        meta == null ? "" : meta.getPermissionStatus().getUserName(),
+        meta == null ? "" : meta.getPermissionStatus().getGroupName(),
+        path.makeQualified(getUri(), getWorkingDirectory()));
-    NewFile, NewDirectory, ChangeExistingFile, ChangeExistingDirectory,
+    NewFile,
+    NewDirectory,
+    NewDirectoryNoUmask,
+    ChangeExistingFile,
+    ChangeExistingDirectory,
-    return new PermissionStatus(UserGroupInformation.getCurrentUser()
-        .getShortUserName(), getConf().get(AZURE_DEFAULT_GROUP_PROPERTY_NAME,
-        AZURE_DEFAULT_GROUP_DEFAULT), permission);
+    return new PermissionStatus(
+        UserGroupInformation.getCurrentUser().getShortUserName(),
+        getConf().get(AZURE_DEFAULT_GROUP_PROPERTY_NAME,
+            AZURE_DEFAULT_GROUP_DEFAULT),
+        permission);
+      return mkdirs(f, permission, false);
+  }
+
+  public boolean mkdirs(Path f, FsPermission permission, boolean noUmask) throws IOException {
-    PermissionStatus permissionStatus = createPermissionStatus(applyUMask(
-        permission, UMaskApplyMode.NewDirectory));
+    PermissionStatus permissionStatus = null;
+    if(noUmask) {
+      // ensure owner still has wx permissions at the minimum
+      permissionStatus = createPermissionStatus(
+          applyUMask(FsPermission.createImmutable((short) (permission.toShort() | USER_WX_PERMISION)),
+              UMaskApplyMode.NewDirectoryNoUmask));
+    } else {
+      permissionStatus = createPermissionStatus(
+          applyUMask(permission, UMaskApplyMode.NewDirectory));
+    }
+
-    // Stop when you get to the root
-    for (Path current = absolutePath, parent = current.getParent(); parent != null; current = parent, parent = current
-        .getParent()) {
+    for (Path current = absolutePath, parent = current.getParent();
+        parent != null; // Stop when you get to the root
+        current = parent, parent = current.getParent()) {
-        throw new IOException("Cannot create directory " + f + " because "
-            + current + " is an existing file.");
-      } else if (currentMetadata == null
-          || (currentMetadata.isDir() && currentMetadata
-              .getBlobMaterialization() == BlobMaterialization.Implicit)) {
+        throw new IOException("Cannot create directory " + f + " because " +
+            current + " is an existing file.");
+      } else if (currentMetadata == null) {
-    // Take the time after finishing mkdirs as the modified time, and update all
-    // the existing directories' modified time to it uniformly.
-    final Calendar lastModifiedCalendar = Calendar
-        .getInstance(Utility.LOCALE_US);
-    lastModifiedCalendar.setTimeZone(Utility.UTC_ZONE);
-    Date lastModified = lastModifiedCalendar.getTime();
-    for (String key : keysToUpdateAsFolder) {
-      store.updateFolderLastModifiedTime(key, lastModified);
-    }
-
-    
+
-        new NativeAzureFsInputStream(store.retrieve(key), key), bufferSize));
+        new NativeAzureFsInputStream(store.retrieve(key), key, meta.getLength()), bufferSize));
+    FolderRenamePending renamePending = null;
+
-    FileMetadata srcMetadata = store.retrieveMetadata(srcKey);
-    if (srcMetadata == null) {
-      // Source doesn't exist
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Source " + src + " doesn't exist, failing the rename.");
-      }
-      return false;
-    }
-
-
-    // directory rename validations
-    if (srcMetadata.isDir()) {
-
-      // rename dir to self is an error
-      if (srcKey.equals(dstKey)) {
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Renaming directory to itself is disallowed. path=" + src);
-        }
-        return false;
-      }
-
-      // rename dir to (sub-)child of self is an error. see
-      // FileSystemContractBaseTest.testRenameChildDirForbidden
-      if (dstKey.startsWith(srcKey + PATH_DELIMITER)) {
-
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Renaming directory to itself is disallowed. src=" + src
-              + " dest=" + dst);
-        }
-        return false;
-      }
-    }
-
-    // file rename early checks
-    if (!srcMetadata.isDir()) {
-      if (srcKey.equals(dstKey)) {
-        // rename file to self is OK
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Renaming file to itself. This is allowed and is treated as no-op. path="
-              + src);
-        }
-        return true;
-      }
-    }
-
-    // More validations..
-    // If target is dir but target already exists, alter the dst to be a
-    // subfolder.
-    // eg move("/a/file.txt", "/b") where "/b" already exists causes the target
-    // to be "/c/file.txt
+      // It's an existing directory.
-      // Best would be to update dstMetadata, but it is not used further, so set
-      // it to null and skip the additional cost
-      dstMetadata = null;
-      // dstMetadata = store.retrieveMetadata(dstKey);
-
-      // rename dir to self is an error
-      if (srcKey.equals(dstKey)) {
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Renaming directory to itself is disallowed. path=" + src);
-        }
-        return false;
-      }
-
-      // Otherwise, attempting to overwrite a file is error
+      // Attempting to overwrite a file using rename()
-      // Either dir or file and target doesn't exist.. Check that the parent
-      // directory exists.
-      FileMetadata parentOfDestMetadata = store
-          .retrieveMetadata(pathToKey(absoluteDst.getParent()));
+      // Check that the parent directory exists.
+      FileMetadata parentOfDestMetadata =
+          store.retrieveMetadata(pathToKey(absoluteDst.getParent()));
-
-    // Validations complete, do the move.
-    if (!srcMetadata.isDir()) {
+    FileMetadata srcMetadata = store.retrieveMetadata(srcKey);
+    if (srcMetadata == null) {
+      // Source doesn't exist
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Source " + src + " doesn't exist, failing the rename.");
+      }
+      return false;
+    } else if (!srcMetadata.isDir()) {
-      // Move everything inside the folder.
-      String priorLastKey = null;
-      // Calculate the index of the part of the string to be moved. That
-      // is everything on the path up to the folder name.
-      do {
-        // List all blobs rooted at the source folder.
-        PartialListing listing = store.listAll(srcKey, AZURE_LIST_ALL,
-            AZURE_UNBOUNDED_DEPTH, priorLastKey);
+      // Prepare for, execute and clean up after of all files in folder, and
+      // the root file, and update the last modified time of the source and
+      // target parent folders. The operation can be redone if it fails part
+      // way through, by applying the "Rename Pending" file.
-        // Rename all the files in the folder.
-        for (FileMetadata file : listing.getFiles()) {
-          // Rename all materialized entries under the folder to point to the
-          // final destination.
-          if (file.getBlobMaterialization() == BlobMaterialization.Explicit) {
-            String srcName = file.getKey();
-            String suffix = srcName.substring(srcKey.length());
-            String dstName = dstKey + suffix;
-            store.rename(srcName, dstName);
-          }
-        }
-        priorLastKey = listing.getPriorLastKey();
-      } while (priorLastKey != null);
-      // Rename the top level empty blob for the folder.
-      if (srcMetadata.getBlobMaterialization() == BlobMaterialization.Explicit) {
-        store.rename(srcKey, dstKey);
+      // The following code (internally) only does atomic rename preparation
+      // and lease management for page blob folders, limiting the scope of the
+      // operation to HBase log file folders, where atomic rename is required.
+      // In the future, we could generalize it easily to all folders.
+      renamePending = prepareAtomicFolderRename(srcKey, dstKey);
+      renamePending.execute();
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Renamed " + src + " to " + dst + " successfully.");
+      renamePending.cleanup();
+      return true;
-    // Update both source and destination parent folder last modified time.
-    Path srcParent = makeAbsolute(keyToPath(srcKey)).getParent();
-    if (srcParent != null && srcParent.getParent() != null) { // not root
-      String srcParentKey = pathToKey(srcParent);
-
-      // ensure the srcParent is a materialized folder
-      FileMetadata srcParentMetadata = store.retrieveMetadata(srcParentKey);
-      if (srcParentMetadata.isDir()
-          && srcParentMetadata.getBlobMaterialization() == BlobMaterialization.Implicit) {
-        store.storeEmptyFolder(srcParentKey,
-            createPermissionStatus(FsPermission.getDefault()));
-      }
-
-      store.updateFolderLastModifiedTime(srcParentKey);
-    }
-
-    Path destParent = makeAbsolute(keyToPath(dstKey)).getParent();
-    if (destParent != null && destParent.getParent() != null) { // not root
-      String dstParentKey = pathToKey(destParent);
-
-      // ensure the dstParent is a materialized folder
-      FileMetadata dstParentMetadata = store.retrieveMetadata(dstParentKey);
-      if (dstParentMetadata.isDir()
-          && dstParentMetadata.getBlobMaterialization() == BlobMaterialization.Implicit) {
-        store.storeEmptyFolder(dstParentKey,
-            createPermissionStatus(FsPermission.getDefault()));
-      }
-
-      store.updateFolderLastModifiedTime(dstParentKey);
-    }
+    // Update the last-modified time of the parent folders of both source
+    // and destination.
+    updateParentFolderLastModifiedTime(srcKey);
+    updateParentFolderLastModifiedTime(dstKey);
-   * Return an array containing hostnames, offset and size of portions of the
-   * given file. For WASB we'll just lie and give fake hosts to make sure we get
-   * many splits in MR jobs.
+   * Update the last-modified time of the parent folder of the file
+   * identified by key.
+   * @param key
+   * @throws IOException
+   */
+  private void updateParentFolderLastModifiedTime(String key)
+      throws IOException {
+    Path parent = makeAbsolute(keyToPath(key)).getParent();
+    if (parent != null && parent.getParent() != null) { // not root
+      String parentKey = pathToKey(parent);
+
+      // ensure the parent is a materialized folder
+      FileMetadata parentMetadata = store.retrieveMetadata(parentKey);
+      // The metadata could be null if the implicit folder only contains a
+      // single file. In this case, the parent folder no longer exists if the
+      // file is renamed; so we can safely ignore the null pointer case.
+      if (parentMetadata != null) {
+        if (parentMetadata.isDir()
+            && parentMetadata.getBlobMaterialization() == BlobMaterialization.Implicit) {
+          store.storeEmptyFolder(parentKey,
+              createPermissionStatus(FsPermission.getDefault()));
+        }
+
+        store.updateFolderLastModifiedTime(parentKey, null);
+      }
+    }
+  }
+
+  /**
+   * If the source is a page blob folder,
+   * prepare to rename this folder atomically. This means to get exclusive
+   * access to the source folder, and record the actions to be performed for
+   * this rename in a "Rename Pending" file. This code was designed to
+   * meet the needs of HBase, which requires atomic rename of write-ahead log
+   * (WAL) folders for correctness.
+   *
+   * Before calling this method, the caller must ensure that the source is a
+   * folder.
+   *
+   * For non-page-blob directories, prepare the in-memory information needed,
+   * but don't take the lease or write the redo file. This is done to limit the
+   * scope of atomic folder rename to HBase, at least at the time of writing
+   * this code.
+   *
+   * @param srcKey Source folder name.
+   * @param dstKey Destination folder name.
+   * @throws IOException
+   */
+  private FolderRenamePending prepareAtomicFolderRename(
+      String srcKey, String dstKey) throws IOException {
+
+    if (store.isAtomicRenameKey(srcKey)) {
+
+      // Block unwanted concurrent access to source folder.
+      SelfRenewingLease lease = leaseSourceFolder(srcKey);
+
+      // Prepare in-memory information needed to do or redo a folder rename.
+      FolderRenamePending renamePending =
+          new FolderRenamePending(srcKey, dstKey, lease, this);
+
+      // Save it to persistent storage to help recover if the operation fails.
+      renamePending.writeFile(this);
+      return renamePending;
+    } else {
+      FolderRenamePending renamePending =
+          new FolderRenamePending(srcKey, dstKey, null, this);
+      return renamePending;
+    }
+  }
+
+  /**
+   * Get a self-renewing Azure blob lease on the source folder zero-byte file.
+   */
+  private SelfRenewingLease leaseSourceFolder(String srcKey)
+      throws AzureException {
+    return store.acquireLease(srcKey);
+  }
+
+  /**
+   * Return an array containing hostnames, offset and size of
+   * portions of the given file. For WASB we'll just lie and give
+   * fake hosts to make sure we get many splits in MR jobs.
-  public BlockLocation[] getFileBlockLocations(FileStatus file, long start,
-      long len) throws IOException {
+  public BlockLocation[] getFileBlockLocations(FileStatus file,
+      long start, long len) throws IOException {
-    } else if (!metadata.getPermissionStatus().getPermission()
-        .equals(permission)) {
-      store.changePermissionStatus(key, new PermissionStatus(metadata
-          .getPermissionStatus().getUserName(), metadata.getPermissionStatus()
-          .getGroupName(), permission));
+    } else if (!metadata.getPermissionStatus().getPermission().
+        equals(permission)) {
+      store.changePermissionStatus(key, new PermissionStatus(
+          metadata.getPermissionStatus().getUserName(),
+          metadata.getPermissionStatus().getGroupName(),
+          permission));
-        username == null ? metadata.getPermissionStatus().getUserName()
-            : username, groupname == null ? metadata.getPermissionStatus()
-            .getGroupName() : groupname, metadata.getPermissionStatus()
-            .getPermission());
+        username == null ?
+            metadata.getPermissionStatus().getUserName() : username,
+        groupname == null ?
+            metadata.getPermissionStatus().getGroupName() : groupname,
+        metadata.getPermissionStatus().getPermission());
-    
+
-    // Close the store
+    // Close the store to close any resources there - e.g. the bandwidth
+    // updater thread would be stopped at this time.
-    
-   * A handler that defines what to do with blobs whose upload was interrupted.
+   * A handler that defines what to do with blobs whose upload was
+   * interrupted.
-        throws IOException;
+      throws IOException;
-   * Handler implementation for just deleting dangling files and cleaning them
-   * up.
+   * Handler implementation for just deleting dangling files and cleaning
+   * them up.
-   * Handler implementation for just moving dangling files to recovery location
-   * (/lost+found).
+   * Handler implementation for just moving dangling files to recovery
+   * location (/lost+found).
-      String finalDestinationKey = pathToKey(new Path(destination,
-          file.getKey()));
+      String finalDestinationKey =
+          pathToKey(new Path(destination, file.getKey()));

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS83 INS42 INS23 INS55 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS39 INS59 INS29 MOV83 INS83 INS42 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS23 INS23 INS23 INS31 INS31 INS43 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS78 UPD83 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS78 UPD83 INS43 INS42 INS8 MOV78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 MOV78 INS79 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 MOV78 INS79 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS78 INS79 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS29 UPD83 INS44 INS44 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS44 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS72 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS44 MOV60 INS29 INS83 INS39 INS42 MOV44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS42 INS34 INS65 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS5 INS59 INS83 INS74 INS59 INS83 INS43 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS83 INS42 INS44 INS44 INS43 MOV43 INS8 INS83 INS5 INS42 INS8 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS8 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS45 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS44 INS29 INS78 MOV83 MOV83 INS39 INS42 INS43 INS8 MOV78 INS83 MOV39 MOV42 INS43 MOV8 INS42 INS65 INS42 INS43 INS42 INS60 INS41 INS65 INS42 MOV43 INS42 INS60 INS41 INS65 INS42 INS21 INS21 INS42 INS43 INS42 INS25 INS25 INS65 INS65 INS65 INS42 INS42 INS41 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS42 INS41 INS65 INS42 INS43 INS42 INS42 INS60 INS41 INS42 INS45 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS25 INS60 INS54 INS41 INS42 INS45 INS42 INS43 INS42 INS43 INS42 INS74 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS42 INS60 INS60 INS41 INS42 INS42 INS45 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS43 INS42 INS25 INS42 INS43 INS42 INS39 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS43 INS42 INS42 INS25 INS60 INS25 INS42 INS43 INS42 INS60 INS60 INS21 INS41 MOV43 INS42 INS42 INS42 INS60 INS70 INS41 INS43 INS42 INS41 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS41 INS39 INS42 INS25 INS60 INS25 MOV21 MOV21 INS65 INS65 INS65 INS42 INS60 INS25 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS65 INS42 INS43 INS42 INS42 INS41 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS33 INS43 INS43 INS42 INS33 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS42 INS42 INS45 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS21 INS21 INS21 INS21 INS60 MOV60 INS19 INS21 INS21 INS43 INS42 INS43 INS42 INS42 INS21 INS60 INS60 INS60 INS60 INS25 INS25 INS60 INS60 INS21 INS60 INS54 INS25 INS60 INS60 INS60 INS25 INS21 INS43 INS85 INS41 INS42 INS41 INS65 INS65 INS43 INS42 INS42 INS60 INS25 INS60 INS60 INS54 INS65 INS42 INS60 INS21 INS60 INS60 INS21 INS24 INS21 INS60 INS60 INS41 INS65 INS65 INS65 INS42 INS43 INS42 INS25 INS60 INS60 INS60 INS60 INS60 INS21 INS24 INS21 INS41 INS42 INS41 INS42 INS41 INS42 INS42 INS41 INS65 INS65 INS42 INS70 INS60 INS25 INS21 INS21 INS65 INS65 INS42 INS25 INS42 INS60 INS60 INS60 INS41 INS65 INS65 INS42 INS25 INS60 INS60 INS54 INS25 INS21 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS25 INS42 INS43 INS42 INS43 INS42 INS41 INS42 INS43 INS42 INS41 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS9 INS42 INS42 INS39 INS42 INS21 INS21 INS65 INS42 INS42 INS25 INS42 MOV21 INS21 MOV21 INS25 INS66 INS66 INS42 INS43 INS59 INS32 INS66 INS43 INS59 INS32 INS66 INS66 INS7 INS7 INS42 INS27 INS8 INS27 INS8 INS8 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS32 INS66 INS42 MOV43 INS59 INS32 INS42 INS42 INS42 MOV43 INS59 INS43 INS59 INS32 INS8 INS38 INS8 INS43 INS59 INS8 INS8 INS42 INS42 INS42 INS43 INS43 INS42 INS83 INS74 INS59 INS39 INS59 INS32 INS42 INS42 INS32 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS66 INS66 INS42 INS42 INS43 INS32 INS8 INS8 INS42 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS66 INS66 INS66 INS42 MOV21 INS42 INS32 INS8 INS43 INS59 INS32 INS8 INS8 INS42 INS43 INS59 INS43 INS59 INS7 INS32 INS39 INS59 INS44 MOV32 INS8 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS8 INS8 INS43 INS59 MOV27 MOV8 INS25 INS66 INS66 INS42 INS42 INS43 INS59 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS32 INS8 INS8 INS66 INS42 INS32 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS7 INS7 INS74 INS59 INS8 MOV27 INS7 INS7 INS42 INS42 INS7 INS43 INS59 INS43 INS59 INS5 INS59 INS39 INS59 INS27 INS8 INS27 INS8 INS43 INS59 INS43 INS59 INS32 INS43 INS59 INS8 INS12 INS12 INS12 INS38 INS8 INS74 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS7 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS43 INS59 MOV32 INS8 MOV43 INS59 INS43 INS59 INS8 INS12 INS8 INS66 INS66 INS43 INS59 INS32 INS43 INS59 INS43 INS59 INS32 INS58 INS27 INS37 INS8 INS32 INS43 INS59 INS43 INS59 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS39 INS59 INS39 INS59 INS39 INS59 INS43 INS59 INS43 INS59 INS32 INS7 INS27 INS7 INS8 INS32 INS32 INS42 INS42 INS32 INS66 INS66 INS66 INS66 INS42 MOV44 INS32 INS8 INS43 INS59 INS27 INS8 INS32 INS32 INS66 INS42 INS66 INS32 INS8 INS43 INS59 INS43 INS59 MOV43 INS59 INS42 INS66 INS66 INS42 INS38 INS8 INS43 INS59 INS39 INS59 INS8 INS12 INS38 INS8 INS32 INS42 INS43 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS25 INS42 INS42 INS14 INS42 INS14 INS7 INS7 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS8 INS8 INS7 MOV32 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS32 INS42 INS32 INS27 INS27 INS41 INS32 INS13 INS41 INS41 MOV43 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS32 INS54 INS32 INS54 INS53 INS42 INS42 INS33 INS21 INS54 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS32 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 MOV60 MOV21 INS21 INS42 INS42 INS42 INS9 INS32 INS42 INS45 MOV41 INS42 INS42 INS32 INS42 INS42 INS60 INS21 MOV41 MOV41 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS45 INS42 INS42 INS60 INS25 INS42 INS9 MOV43 INS42 INS60 INS25 INS32 INS42 INS40 INS42 INS42 INS42 INS9 INS33 INS21 MOV21 INS42 INS42 INS33 MOV38 MOV8 INS8 UPD42 UPD42 UPD42 INS42 INS42 INS32 INS27 INS27 INS60 INS60 MOV25 INS42 INS42 INS42 INS60 INS60 INS21 INS41 INS60 INS41 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS43 INS43 INS42 INS14 INS60 INS70 MOV21 INS42 INS32 INS22 INS9 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS39 INS85 INS42 INS3 INS42 INS32 INS42 INS34 INS53 INS42 INS42 INS53 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS40 INS9 INS42 INS42 INS33 INS21 INS21 INS44 INS8 INS44 INS8 INS44 INS8 INS22 INS21 INS21 INS41 INS43 INS43 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS27 INS27 INS21 INS21 INS21 INS25 INS22 INS42 INS42 INS42 INS32 INS21 INS42 INS33 INS42 INS42 INS32 INS21 INS21 INS44 INS8 INS21 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS45 INS39 INS59 INS42 INS40 INS42 INS25 INS21 INS60 INS21 INS25 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS27 INS27 INS27 INS41 INS42 INS34 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS13 INS42 INS34 INS42 INS42 INS42 INS34 INS21 INS50 INS42 INS42 INS13 INS42 INS42 INS32 INS42 INS42 INS52 INS42 INS25 INS42 INS42 INS32 INS32 INS40 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS32 INS42 INS41 INS42 INS42 INS33 INS42 INS9 INS21 INS44 INS8 INS42 INS60 INS25 INS70 INS54 INS21 INS21 INS42 INS42 INS32 INS9 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS38 INS60 INS60 INS21 INS27 INS8 INS25 INS43 INS14 INS27 INS43 INS14 INS27 INS22 INS32 INS22 INS42 INS67 INS67 INS41 INS25 INS60 INS41 INS42 INS9 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS32 INS34 INS42 INS42 INS42 INS27 INS32 INS42 INS32 INS43 INS33 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS8 INS12 INS42 INS42 INS8 INS12 INS14 INS7 INS8 INS12 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS39 INS59 INS42 INS8 INS43 INS59 INS32 INS8 INS42 INS42 INS7 INS7 INS21 MOV21 MOV25 MOV21 INS41 INS32 INS42 INS42 INS33 INS32 INS33 INS43 INS59 INS43 INS59 INS27 INS43 INS59 INS43 INS59 INS32 INS42 INS43 INS59 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS74 INS43 INS59 INS44 INS32 INS8 INS42 INS42 INS3 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS5 INS42 INS42 INS42 INS42 INS14 INS14 INS43 INS42 INS34 INS42 INS43 INS7 INS7 INS43 INS42 INS21 INS43 INS42 INS21 INS43 INS42 INS21 INS52 INS42 INS32 INS32 INS42 INS42 INS74 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS33 INS42 INS33 INS7 INS7 INS7 INS27 INS8 INS8 INS52 INS42 INS42 INS32 INS42 INS7 INS32 INS43 INS42 INS53 INS32 INS43 INS45 INS42 INS42 INS45 INS42 INS42 INS14 INS43 INS42 INS34 INS27 INS8 INS32 INS43 INS59 INS32 INS27 INS8 INS42 INS42 INS27 INS42 INS45 INS45 INS32 INS45 INS45 INS32 INS45 INS45 INS42 INS45 INS45 INS42 INS33 INS32 INS34 INS45 INS42 INS42 INS43 INS27 INS7 INS42 INS49 INS49 INS21 INS21 INS10 INS49 INS21 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS25 INS42 INS42 MOV27 INS8 INS52 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS43 INS42 INS60 INS54 INS25 INS43 INS59 INS38 INS8 INS44 INS42 INS8 INS8 INS12 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS42 INS42 INS60 INS60 INS21 INS27 INS8 INS8 INS42 INS43 INS32 INS45 INS42 INS45 INS42 INS42 INS43 INS32 INS45 INS42 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS8 INS83 INS39 INS59 INS16 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 INS34 INS27 INS42 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS21 INS44 INS8 INS43 INS27 INS42 INS32 INS25 INS44 INS8 INS60 INS60 INS61 INS42 INS32 INS42 MOV14 INS25 INS25 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS21 INS42 INS42 INS32 INS42 INS42 INS60 INS21 INS21 INS42 INS32 INS42 MOV32 MOV27 INS32 INS7 MOV8 INS9 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 MOV33 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS52 INS42 INS42 INS14 INS43 INS43 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS5 INS32 INS39 INS85 INS43 INS45 INS43 INS27 INS42 INS42 INS42 INS32 INS22 INS9 INS42 INS7 INS42 INS7 INS42 INS7 INS42 INS42 INS27 INS42 INS42 INS42 INS9 INS43 INS43 INS22 INS9 INS22 INS32 INS22 INS32 INS27 INS27 INS21 INS60 INS25 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS42 MOV43 INS42 INS42 INS34 INS21 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS27 INS21 INS41 INS45 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS32 INS13 INS13 INS32 INS32 INS13 INS32 INS32 INS13 INS32 INS13 INS32 INS13 INS32 INS13 INS32 INS13 INS32 INS27 INS8 INS8 MOV60 INS60 INS60 INS60 INS21 INS32 INS42 INS32 INS32 INS9 INS42 INS42 INS42 INS32 INS9 INS42 INS32 INS42 INS43 INS59 INS8 INS12 INS32 INS8 INS8 INS42 INS42 INS32 INS32 INS21 INS43 INS42 INS21 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS9 INS33 INS43 INS59 INS43 INS59 INS32 INS38 INS42 INS20 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS53 INS42 INS27 INS27 INS11 INS40 INS42 INS42 INS32 INS42 INS42 INS32 INS34 INS7 INS43 INS42 INS60 INS54 INS25 INS21 INS53 INS32 INS43 INS42 INS21 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS43 INS42 INS21 INS60 INS21 INS53 INS43 INS59 MOV43 INS59 INS27 INS8 INS42 INS42 INS42 INS42 INS8 INS38 INS8 INS32 INS8 INS43 INS42 INS52 INS42 INS42 INS7 INS42 INS32 INS43 INS59 INS32 INS7 UPD42 MOV42 INS32 INS42 INS42 INS42 INS32 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS52 INS43 INS42 INS42 INS33 INS52 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS57 INS52 INS42 INS22 INS9 INS22 INS9 INS22 INS9 INS45 INS42 INS45 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS22 INS33 INS22 INS33 INS7 INS43 INS59 INS27 INS8 INS8 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS32 INS42 INS42 INS32 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS13 INS42 INS42 INS42 INS42 INS42 INS13 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS13 INS21 INS21 INS21 INS43 INS59 INS43 INS59 INS39 INS59 INS32 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS60 INS21 INS44 INS8 INS42 INS42 INS45 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS14 INS14 INS22 INS42 INS42 INS40 INS39 INS42 INS42 INS42 INS45 INS42 INS22 INS42 INS42 INS42 INS32 INS42 MOV43 INS59 INS8 INS12 INS32 INS8 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS33 INS21 INS42 INS32 MOV43 INS59 INS32 INS14 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS33 INS21 INS21 INS32 INS9 INS25 INS42 MOV21 INS42 INS42 INS53 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS9 UPD42 MOV42 INS32 INS40 INS42 MOV42 MOV42 UPD42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS9 INS42 INS42 INS32 INS42 INS33 INS21 INS24 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS45 INS2 INS42 INS42 INS45 INS42 INS42 INS27 INS7 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS33 INS43 INS59 INS7 INS43 INS42 INS20 INS7 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS43 INS45 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS45 INS60 INS21 INS44 INS8 INS42 INS42 INS45 INS53 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS7 INS32 UPD42 MOV42 INS38 MOV8 INS14 INS42 INS42 INS42 INS42 INS34 INS42 INS43 INS42 INS52 UPD42 MOV42 UPD42 MOV42 INS11 UPD42 INS42 INS52 INS42 INS42 INS42 INS45 INS7 INS58 INS27 INS37 INS8 INS42 INS42 INS45 INS42 INS45 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS42 INS42 INS9 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS43 INS59 INS7 INS43 INS42 INS14 INS45 INS32 INS45 INS32 INS45 INS32 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS33 INS43 INS27 INS42 INS39 INS36 UPD45 UPD45 INS45 UPD42 UPD42 INS22 INS9 INS39 INS59 INS42 INS32 INS42 INS21 INS45 INS32 INS45 INS32 INS36 INS42 INS52 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS45 INS45 INS45 INS45 INS45 INS42 INS42 INS11 INS42 INS32 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS27 INS52 INS42 INS42 INS34 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS45 INS32 INS45 INS42 INS42 INS33 INS32 INS42 INS42 INS42 INS32 INS32 INS34 INS52 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL36 DEL27 DEL83 DEL42 DEL43 DEL42 DEL40 DEL32 DEL59 DEL60 DEL40 DEL32 DEL21 DEL42 DEL32 DEL59 DEL60 DEL42 DEL8 DEL70 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL8 DEL25 DEL9 DEL41 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL33 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL45 DEL42 DEL27 DEL42 DEL42 DEL27 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL27 DEL59 DEL60 DEL8 DEL25 DEL8 DEL70 DEL8 DEL19 DEL42 DEL42 DEL32 DEL40 DEL27 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60
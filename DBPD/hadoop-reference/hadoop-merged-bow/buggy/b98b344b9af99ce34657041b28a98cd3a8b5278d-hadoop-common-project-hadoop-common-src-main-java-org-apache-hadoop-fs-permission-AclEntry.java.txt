HADOOP-10277. setfacl -x fails to parse ACL spec if trying to remove the mask entry. Contributed by Vinay.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1561769 13f79535-47bb-0310-9956-ffa450edef68

-   * @return Returns list of AclEntries parsed
+   * @return Returns list of {@link AclEntry} parsed
-      AclEntry.Builder builder = new AclEntry.Builder();
-      // Here "::" represent one empty string.
-      // StringUtils.getStringCollection() will ignore this.
-      String[] split = aclStr.split(":");
-      int expectedAclSpecLength = 2;
-      if (includePermission) {
-        expectedAclSpecLength = 3;
-      }
-      if (split.length != expectedAclSpecLength
-          && !(split.length == expectedAclSpecLength + 1 && "default"
-              .equals(split[0]))) {
-        throw new HadoopIllegalArgumentException("Invalid <aclSpec> : "
-            + aclStr);
-      }
-      int index = 0;
-      if (split.length == expectedAclSpecLength + 1) {
-        assert "default".equals(split[0]);
-        // default entry
-        index++;
-        builder.setScope(AclEntryScope.DEFAULT);
-      }
-      String type = split[index++];
-      AclEntryType aclType = null;
-      try {
-        aclType = Enum.valueOf(AclEntryType.class, type.toUpperCase());
-        builder.setType(aclType);
-      } catch (IllegalArgumentException iae) {
-        throw new HadoopIllegalArgumentException(
-            "Invalid type of acl in <aclSpec> :" + aclStr);
-      }
+      AclEntry aclEntry = parseAclEntry(aclStr, includePermission);
+      aclEntries.add(aclEntry);
+    }
+    return aclEntries;
+  }
-      String name = split[index++];
+  /**
+   * Parses a string representation of an ACL into a AclEntry object.<br>
+   * 
+   * @param aclStr
+   *          String representation of an ACL.<br>
+   *          Example: "user:foo:rw-"
+   * @param includePermission
+   *          for setAcl operations this will be true. i.e. Acl should include
+   *          permissions.<br>
+   *          But for removeAcl operation it will be false. i.e. Acl should not
+   *          contain permissions.<br>
+   *          Example: "user:foo,group:bar,mask::"
+   * @return Returns an {@link AclEntry} object
+   */
+  public static AclEntry parseAclEntry(String aclStr,
+      boolean includePermission) {
+    AclEntry.Builder builder = new AclEntry.Builder();
+    // Here "::" represent one empty string.
+    // StringUtils.getStringCollection() will ignore this.
+    String[] split = aclStr.split(":");
+
+    if (split.length == 0) {
+      throw new HadoopIllegalArgumentException("Invalid <aclSpec> : " + aclStr);
+    }
+    int index = 0;
+    if ("default".equals(split[0])) {
+      // default entry
+      index++;
+      builder.setScope(AclEntryScope.DEFAULT);
+    }
+
+    if (split.length <= index) {
+      throw new HadoopIllegalArgumentException("Invalid <aclSpec> : " + aclStr);
+    }
+
+    AclEntryType aclType = null;
+    try {
+      aclType = Enum.valueOf(AclEntryType.class, split[index].toUpperCase());
+      builder.setType(aclType);
+      index++;
+    } catch (IllegalArgumentException iae) {
+      throw new HadoopIllegalArgumentException(
+          "Invalid type of acl in <aclSpec> :" + aclStr);
+    }
+
+    if (split.length > index) {
+      String name = split[index];
-
-      if (expectedAclSpecLength == 3) {
-        String permission = split[index++];
-        FsAction fsAction = FsAction.getFsAction(permission);
-        if (null == fsAction) {
-          throw new HadoopIllegalArgumentException(
-              "Invalid permission in <aclSpec> : " + aclStr);
-        }
-        builder.setPermission(fsAction);
-      }
-      aclEntries.add(builder.build());
+      index++;
-    return aclEntries;
+
+    if (includePermission) {
+      if (split.length < index) {
+        throw new HadoopIllegalArgumentException("Invalid <aclSpec> : "
+            + aclStr);
+      }
+      String permission = split[index];
+      FsAction fsAction = FsAction.getFsAction(permission);
+      if (null == fsAction) {
+        throw new HadoopIllegalArgumentException(
+            "Invalid permission in <aclSpec> : " + aclStr);
+      }
+      builder.setPermission(fsAction);
+      index++;
+    }
+
+    if (split.length > index) {
+      throw new HadoopIllegalArgumentException("Invalid <aclSpec> : " + aclStr);
+    }
+    AclEntry aclEntry = builder.build();
+    return aclEntry;

INS31 MOV29 INS83 INS83 MOV74 INS42 MOV44 INS44 INS8 INS29 INS43 INS42 MOV44 MOV8 INS39 INS42 MOV60 MOV60 INS70 MOV41 INS65 INS65 INS65 INS65 INS42 INS25 INS25 INS25 INS25 INS60 INS41 UPD66 INS65 INS66 INS44 INS42 INS8 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS27 MOV8 MOV32 INS27 INS8 INS27 INS8 INS42 INS27 INS8 INS43 INS59 INS42 INS42 INS43 INS42 INS60 INS21 INS42 MOV40 INS34 MOV40 UPD42 MOV42 INS53 INS21 INS40 INS42 MOV60 MOV25 INS21 INS25 INS21 INS40 INS42 INS53 INS42 INS42 MOV32 INS42 INS43 INS59 INS32 INS14 INS37 MOV43 INS37 INS27 INS8 MOV43 INS37 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS27 INS42 UPD42 MOV42 INS40 INS42 INS53 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS2 INS43 INS27 INS42 INS42 INS42 INS45 INS42 DEL42 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL42 DEL27 DEL34 DEL27 DEL27 DEL45 DEL42 DEL42 DEL34 DEL2 DEL32 DEL27 DEL36 DEL38 DEL27 DEL25 DEL40 DEL42 DEL34 DEL27 DEL27 DEL6 DEL42 DEL42 DEL43 DEL42 DEL37 DEL42 DEL42 DEL37 DEL2 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL37 DEL42 DEL42 DEL32 DEL21 DEL42 DEL70 DEL8
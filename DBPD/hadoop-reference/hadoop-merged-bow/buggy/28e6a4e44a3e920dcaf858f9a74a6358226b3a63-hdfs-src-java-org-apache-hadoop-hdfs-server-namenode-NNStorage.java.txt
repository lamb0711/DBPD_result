HDFS-1073. Redesign the NameNode's storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68

-import static org.apache.hadoop.hdfs.server.common.Util.now;
-
+import java.io.BufferedReader;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.OutputStream;
+import java.util.HashMap;
-import org.apache.hadoop.hdfs.server.common.StorageInfo;
-import org.apache.hadoop.io.MD5Hash;
+import org.apache.hadoop.hdfs.util.AtomicFileOutputStream;
+
+import org.apache.hadoop.io.IOUtils;
+import com.google.common.base.Preconditions;
+import com.google.common.annotations.VisibleForTesting;
+
-  static final String MESSAGE_DIGEST_PROPERTY = "imageMD5Digest";
-
+  static final String DEPRECATED_MESSAGE_DIGEST_PROPERTY = "imageMD5Digest";
+  
-    TIME      ("fstime"),
+    TIME      ("fstime"), // from "old" pre-HDFS-1073 format
+    SEEN_TXID ("seen_txid"),
-    EDITS_NEW ("edits.new");
+    EDITS_NEW ("edits.new"), // from "old" pre-HDFS-1073 format
+    EDITS_INPROGRESS ("edits_inprogress");
-  /**
-   * Interface to be implemented by classes which make use of storage
-   * directories. They are  notified when a StorageDirectory is causing errors,
-   * becoming available or being formatted.
-   *
-   * This allows the implementors of the interface take their own specific
-   * action on the StorageDirectory when this occurs.
-   */
-  interface NNStorageListener {
-    /**
-     * An error has occurred with a StorageDirectory.
-     * @param sd The storage directory causing the error.
-     * @throws IOException
-     */
-    void errorOccurred(StorageDirectory sd) throws IOException;
-
-    /**
-     * A storage directory has been formatted.
-     * @param sd The storage directory being formatted.
-     * @throws IOException
-     */
-    void formatOccurred(StorageDirectory sd) throws IOException;
-
-    /**
-     * A storage directory is now available use.
-     * @param sd The storage directory which has become available.
-     * @throws IOException
-     */
-    void directoryAvailable(StorageDirectory sd) throws IOException;
-  }
-
-  final private List<NNStorageListener> listeners;
-  protected MD5Hash imageDigest = null;
-
+  
-  private long checkpointTime = -1L;  // The age of the image
+
+  /**
+   * TxId of the last transaction that was included in the most
+   * recent fsimage file. This does not include any transactions
+   * that have since been written to the edit log.
+   */
+  protected long mostRecentCheckpointTxId = FSConstants.INVALID_TXID;
-   * Construct the NNStorage.
-   * @param conf Namenode configuration.
+   * Properties from old layout versions that may be needed
+   * during upgrade only.
-  public NNStorage(Configuration conf) {
-    super(NodeType.NAME_NODE);
-
-    storageDirs = new CopyOnWriteArrayList<StorageDirectory>();
-    this.listeners = new CopyOnWriteArrayList<NNStorageListener>();
-  }
+  private HashMap<String, String> deprecatedProperties;
-   * @param storageInfo storage information
-   * @param bpid block pool Id
+   * @param conf Namenode configuration.
+   * @param imageDirs Directories the image can be stored in.
+   * @param editsDirs Directories the editlog can be stored in.
+   * @throws IOException if any directories are inaccessible.
-  public NNStorage(StorageInfo storageInfo, String bpid) {
-    super(NodeType.NAME_NODE, storageInfo);
+  public NNStorage(Configuration conf, 
+                   Collection<URI> imageDirs, Collection<URI> editsDirs) 
+      throws IOException {
+    super(NodeType.NAME_NODE);
-    this.listeners = new CopyOnWriteArrayList<NNStorageListener>();
-    this.blockpoolID = bpid;
+    
+    setStorageDirectories(imageDirs, editsDirs);
-    listeners.clear();
-   * into service. If saveNamespace is set, then this method is being
-   * called from saveNamespace.
-   *
-   * @param saveNamespace Whether method is being called from saveNamespace()
+   * into service.
-        try {
-          
-          if(root.exists() && root.canWrite()) {
-            // when we try to restore we just need to remove all the data
-            // without saving current in-memory state (which could've changed).
-            sd.clearDirectory();
-            
-            LOG.info("restoring dir " + sd.getRoot().getAbsolutePath());
-            for (NNStorageListener listener : listeners) {
-              listener.directoryAvailable(sd);
-            }
-            
-            this.addStorageDir(sd); // restore
-            this.removedStorageDirs.remove(sd);
-          }
-        } catch(IOException e) {
-          LOG.warn("failed to restore " + sd.getRoot().getAbsolutePath(), e);
+        if(root.exists() && root.canWrite()) {
+          LOG.info("restoring dir " + sd.getRoot().getAbsolutePath());
+          this.addStorageDir(sd); // restore
+          this.removedStorageDirs.remove(sd);
-   * Set the storage directories which will be used. NNStorage.close() should
-   * be called before this to ensure any previous storage directories have been
-   * freed.
+   * Set the storage directories which will be used. This should only ever be
+   * called from inside NNStorage. However, it needs to remain package private
+   * for testing, as StorageDirectories need to be reinitialised after using
+   * Mockito.spy() on this class, as Mockito doesn't work well with inner
+   * classes, such as StorageDirectory in this case.
+  @VisibleForTesting
-
+  
-   * Determine the checkpoint time of the specified StorageDirectory
+   * Determine the last transaction ID noted in this storage directory.
+   * This txid is stored in a special seen_txid file since it might not
+   * correspond to the latest image or edit log. For example, an image-only
+   * directory will have this txid incremented when edits logs roll, even
+   * though the edits logs are in a different directory.
-   * @return If file exists and can be read, last checkpoint time. If not, 0L.
+   * @return If file exists and can be read, last recorded txid. If not, 0L.
-  long readCheckpointTime(StorageDirectory sd) throws IOException {
-    File timeFile = getStorageFile(sd, NameNodeFile.TIME);
-    long timeStamp = 0L;
-    if (timeFile.exists() && timeFile.canRead()) {
-      DataInputStream in = new DataInputStream(new FileInputStream(timeFile));
+  static long readTransactionIdFile(StorageDirectory sd) throws IOException {
+    File txidFile = getStorageFile(sd, NameNodeFile.SEEN_TXID);
+    long txid = 0L;
+    if (txidFile.exists() && txidFile.canRead()) {
+      BufferedReader br = new BufferedReader(new FileReader(txidFile));
-        timeStamp = in.readLong();
+        txid = Long.valueOf(br.readLine());
-        in.close();
+        IOUtils.cleanup(LOG, br);
-    return timeStamp;
+    return txid;
-
+  
-  public void writeCheckpointTime(StorageDirectory sd) throws IOException {
-    if (checkpointTime < 0L)
-      return; // do not write negative time
-    File timeFile = getStorageFile(sd, NameNodeFile.TIME);
-    if (timeFile.exists() && ! timeFile.delete()) {
-        LOG.error("Cannot delete chekpoint time file: "
-                  + timeFile.getCanonicalPath());
-    }
-    FileOutputStream fos = new FileOutputStream(timeFile);
-    DataOutputStream out = new DataOutputStream(fos);
+  void writeTransactionIdFile(StorageDirectory sd, long txid) throws IOException {
+    Preconditions.checkArgument(txid >= 0, "bad txid: " + txid);
+    
+    File txIdFile = getStorageFile(sd, NameNodeFile.SEEN_TXID);
+    OutputStream fos = new AtomicFileOutputStream(txIdFile);
-      out.writeLong(checkpointTime);
-      out.flush();
-      fos.getChannel().force(true);
+      fos.write(String.valueOf(txid).getBytes());
+      fos.write('\n');
-      out.close();
+      IOUtils.cleanup(LOG, fos);
-   * Record new checkpoint time in order to
-   * distinguish healthy directories from the removed ones.
-   * If there is an error writing new checkpoint time, the corresponding
-   * storage directory is removed from the list.
+   * Set the transaction ID of the last checkpoint
-  public void incrementCheckpointTime() {
-    setCheckpointTimeInStorage(checkpointTime + 1);
+  void setMostRecentCheckpointTxId(long txid) {
+    this.mostRecentCheckpointTxId = txid;
-   * The age of the namespace state.<p>
-   * Reflects the latest time the image was saved.
-   * Modified with every save or a checkpoint.
-   * Persisted in VERSION file.
-   *
-   * @return the current checkpoint time.
+   * Return the transaction ID of the last checkpoint.
-  public long getCheckpointTime() {
-    return checkpointTime;
+  long getMostRecentCheckpointTxId() {
+    return mostRecentCheckpointTxId;
-   * Set the checkpoint time.
-   *
-   * This method does not persist the checkpoint time to storage immediately.
+   * Write a small file in all available storage directories that
+   * indicates that the namespace has reached some given transaction ID.
-   * @see #setCheckpointTimeInStorage
-   * @param newCpT the new checkpoint time.
+   * This is used when the image is loaded to avoid accidental rollbacks
+   * in the case where an edit log is fully deleted but there is no
+   * checkpoint. See TestNameEditsConfigs.testNameEditsConfigsFailure()
+   * @param txid the txid that has been reached
-  public void setCheckpointTime(long newCpT) {
-    checkpointTime = newCpT;
-  }
-
-  /**
-   * Set the current checkpoint time. Writes the new checkpoint
-   * time to all available storage directories.
-   * @param newCpT The new checkpoint time.
-   */
-  public void setCheckpointTimeInStorage(long newCpT) {
-    checkpointTime = newCpT;
-    // Write new checkpoint time in all storage directories
-    for(Iterator<StorageDirectory> it =
-                          dirIterator(); it.hasNext();) {
-      StorageDirectory sd = it.next();
+  public void writeTransactionIdFileToStorage(long txid) {
+    // Write txid marker in all storage directories
+    for (StorageDirectory sd : storageDirs) {
-        writeCheckpointTime(sd);
+        writeTransactionIdFile(sd, txid);
-        LOG.warn("incrementCheckpointTime failed on "
-                 + sd.getRoot().getPath() + ";type="+sd.getStorageDirType());
-        try {
-          reportErrorsOnDirectory(sd);
-        } catch (IOException ioe) {
-            LOG.error("Failed to report and remove NN storage directory "
-                      + sd.getRoot().getPath(), ioe);
-        }
+        LOG.warn("writeTransactionIdToStorage failed on " + sd,
+            e);
+        reportErrorsOnDirectory(sd);
-  public File[] getFsImageNameCheckpoint() {
+  public File[] getFsImageNameCheckpoint(long txid) {
-      list.add(getStorageFile(it.next(), NameNodeFile.IMAGE_NEW));
+      list.add(getStorageFile(it.next(), NameNodeFile.IMAGE_NEW, txid));
-  public File getFsImageName() {
+  public File getFsImageName(long txid) {
-      File fsImage = getStorageFile(sd, NameNodeFile.IMAGE);
+      File fsImage = getStorageFile(sd, NameNodeFile.IMAGE, txid);
-  /**
-   * @return The name of the first editlog file.
-   */
-  public File getFsEditName() throws IOException {
-    for (Iterator<StorageDirectory> it
-           = dirIterator(NameNodeDirType.EDITS); it.hasNext();) {
-      StorageDirectory sd = it.next();
-      if(sd.getRoot().canRead())
-        return getEditFile(sd);
-    }
-    return null;
-  }
-
-  /**
-   * @return The name of the first time file.
-   */
-  public File getFsTimeName() {
-    StorageDirectory sd = null;
-    // NameNodeFile.TIME shoul be same on all directories
-    for (Iterator<StorageDirectory> it =
-             dirIterator(); it.hasNext();)
-      sd = it.next();
-    return getStorageFile(sd, NameNodeFile.TIME);
-  }
-
-    for (NNStorageListener listener : listeners) {
-      listener.formatOccurred(sd);
-    }
+    writeTransactionIdFile(sd, 0);
-    this.setCheckpointTime(now());
-
-  /**
-   * Move {@code current} to {@code lastcheckpoint.tmp} and
-   * recreate empty {@code current}.
-   * {@code current} is moved only if it is well formatted,
-   * that is contains VERSION file.
-   *
-   * @see org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory#getLastCheckpointTmp()
-   * @see org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory#getPreviousCheckpoint()
-   */
-  protected void moveCurrent(StorageDirectory sd)
-    throws IOException {
-    File curDir = sd.getCurrentDir();
-    File tmpCkptDir = sd.getLastCheckpointTmp();
-    // mv current -> lastcheckpoint.tmp
-    // only if current is formatted - has VERSION file
-    if(sd.getVersionFile().exists()) {
-      assert curDir.exists() : curDir + " directory must exist.";
-      assert !tmpCkptDir.exists() : tmpCkptDir + " directory must not exist.";
-      rename(curDir, tmpCkptDir);
-    }
-    // recreate current
-    if(!curDir.exists() && !curDir.mkdir())
-      throw new IOException("Cannot create directory " + curDir);
-  }
-
-  /**
-   * Move {@code lastcheckpoint.tmp} to {@code previous.checkpoint}
-   *
-   * @see org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory#getPreviousCheckpoint()
-   * @see org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory#getLastCheckpointTmp()
-   */
-  protected void moveLastCheckpoint(StorageDirectory sd)
-    throws IOException {
-    File tmpCkptDir = sd.getLastCheckpointTmp();
-    File prevCkptDir = sd.getPreviousCheckpoint();
-    // remove previous.checkpoint
-    if (prevCkptDir.exists())
-      deleteDir(prevCkptDir);
-    // mv lastcheckpoint.tmp -> previous.checkpoint
-    if(tmpCkptDir.exists())
-      rename(tmpCkptDir, prevCkptDir);
-  }
-
-
-    String sMd5 = props.getProperty(MESSAGE_DIGEST_PROPERTY);
-    if (LayoutVersion.supports(Feature.FSIMAGE_CHECKSUM, layoutVersion)) {
-      if (sMd5 == null) {
-        throw new InconsistentFSStateException(sd.getRoot(),
-            "file " + STORAGE_FILE_VERSION
-            + " does not have MD5 image digest.");
-      }
-      this.imageDigest = new MD5Hash(sMd5);
-    } else if (sMd5 != null) {
-      throw new InconsistentFSStateException(sd.getRoot(),
-          "file " + STORAGE_FILE_VERSION +
-          " has image MD5 digest when version is " + layoutVersion);
-    }
-
-    this.setCheckpointTime(readCheckpointTime(sd));
+    setDeprecatedPropertiesForUpgrade(props);
-   * Write last checkpoint time and version file into the storage directory.
+   * Pull any properties out of the VERSION file that are from older
+   * versions of HDFS and only necessary during upgrade.
+   */
+  private void setDeprecatedPropertiesForUpgrade(Properties props) {
+    deprecatedProperties = new HashMap<String, String>();
+    String md5 = props.getProperty(DEPRECATED_MESSAGE_DIGEST_PROPERTY);
+    if (md5 != null) {
+      deprecatedProperties.put(DEPRECATED_MESSAGE_DIGEST_PROPERTY, md5);
+    }
+  }
+  
+  /**
+   * Return a property that was stored in an earlier version of HDFS.
+   * 
+   * This should only be used during upgrades.
+   */
+  String getDeprecatedProperty(String prop) {
+    assert getLayoutVersion() > FSConstants.LAYOUT_VERSION :
+      "getDeprecatedProperty should only be done when loading " +
+      "storage from past versions during upgrade.";
+    return deprecatedProperties.get(prop);
+  }
+
+  /**
+   * Write version file into the storage directory.
-    if (LayoutVersion.supports(Feature.FSIMAGE_CHECKSUM, layoutVersion)) {
-      // Though the current NN supports this feature, this function
-      // is called with old layoutVersions from the upgrade tests.
-      if (imageDigest == null) {
-        // May be null on the first save after an upgrade.
-        imageDigest = MD5Hash.digest(
-            new FileInputStream(getStorageFile(sd, NameNodeFile.IMAGE)));
-      }
-      props.setProperty(MESSAGE_DIGEST_PROPERTY, imageDigest.toString());
-    }
-
-    writeCheckpointTime(sd);
-
+  
+  static File getStorageFile(StorageDirectory sd, NameNodeFile type, long imageTxId) {
+    return new File(sd.getCurrentDir(),
+                    String.format("%s_%019d", type.getName(), imageTxId));
+  }
+  
-   * @return A File of 'type' in storage directory 'sd'.
+   * Get a storage file for one of the files that doesn't need a txid associated
+   * (e.g version, seen_txid)
+  @VisibleForTesting
+  public static String getCheckpointImageFileName(long txid) {
+    return String.format("%s_%019d",
+                         NameNodeFile.IMAGE_NEW.getName(), txid);
+  }
+
+  @VisibleForTesting
+  public static String getImageFileName(long txid) {
+    return String.format("%s_%019d",
+                         NameNodeFile.IMAGE.getName(), txid);
+  }
+  
+  @VisibleForTesting
+  public static String getInProgressEditsFileName(long startTxId) {
+    return String.format("%s_%019d", NameNodeFile.EDITS_INPROGRESS.getName(),
+                         startTxId);
+  }
+  
+  static File getInProgressEditsFile(StorageDirectory sd, long startTxId) {
+    return new File(sd.getCurrentDir(), getInProgressEditsFileName(startTxId));
+  }
+  
+  static File getFinalizedEditsFile(StorageDirectory sd,
+      long startTxId, long endTxId) {
+    return new File(sd.getCurrentDir(),
+        getFinalizedEditsFileName(startTxId, endTxId));
+  }
+  
+  static File getImageFile(StorageDirectory sd, long txid) {
+    return new File(sd.getCurrentDir(),
+        getImageFileName(txid));
+  }
+  
+  @VisibleForTesting
+  public static String getFinalizedEditsFileName(long startTxId, long endTxId) {
+    return String.format("%s_%019d-%019d", NameNodeFile.EDITS.getName(),
+                         startTxId, endTxId);
+  }
+  
-   * @return A editlog File in storage directory 'sd'.
+   * Return the first readable finalized edits file for the given txid.
-  File getEditFile(StorageDirectory sd) {
-    return getStorageFile(sd, NameNodeFile.EDITS);
+  File findFinalizedEditsFile(long startTxId, long endTxId)
+  throws IOException {
+    File ret = findFile(NameNodeDirType.EDITS,
+        getFinalizedEditsFileName(startTxId, endTxId));
+    if (ret == null) {
+      throw new IOException(
+          "No edits file for txid " + startTxId + "-" + endTxId + " exists!");
+    }
+    return ret;
+  }
+    
+  /**
+   * Return the first readable image file for the given txid, or null
+   * if no such image can be found
+   */
+  File findImageFile(long txid) throws IOException {
+    return findFile(NameNodeDirType.IMAGE,
+        getImageFileName(txid));
-   * @return A temporary editlog File in storage directory 'sd'.
+   * Return the first readable storage file of the given name
+   * across any of the 'current' directories in SDs of the
+   * given type, or null if no such file exists.
-  File getEditNewFile(StorageDirectory sd) {
-    return getStorageFile(sd, NameNodeFile.EDITS_NEW);
+  private File findFile(NameNodeDirType dirType, String name) {
+    for (StorageDirectory sd : dirIterable(dirType)) {
+      File candidate = new File(sd.getCurrentDir(), name);
+      if (sd.getCurrentDir().canRead() &&
+          candidate.exists()) {
+        return candidate;
+      }
+    }
+    return null;
-   * @return A list of all Files of 'type' in available storage directories.
+   * @return A list of the given File in every available storage directory,
+   * regardless of whether it might exist.
-  Collection<File> getFiles(NameNodeFile type, NameNodeDirType dirType) {
+  List<File> getFiles(NameNodeDirType dirType, String fileName) {
-      list.add(getStorageFile(it.next(), type));
+      list.add(new File(it.next().getCurrentDir(), fileName));
-    upgradeManager.setUpgradeState(uState, uVersion);
+    if (upgradeManager != null) {
+      upgradeManager.setUpgradeState(uState, uVersion);
+    }
-   * Set the digest for the latest image stored by NNStorage.
-   * @param digest The digest for the image.
-   */
-  void setImageDigest(MD5Hash digest) {
-    this.imageDigest = digest;
-  }
-
-  /**
-   * Get the digest for the latest image storage by NNStorage.
-   * @return The digest for the latest image.
-   */
-  MD5Hash getImageDigest() {
-    return imageDigest;
-  }
-
-  /**
-   * Register a listener. The listener will be notified of changes to the list
-   * of available storage directories.
-   *
-   * @see NNStorageListener
-   * @param sel A storage listener.
-   */
-  void registerListener(NNStorageListener sel) {
-    listeners.add(sel);
-  }
-
-  /**
-  void reportErrorsOnDirectories(List<StorageDirectory> sds) throws IOException {
+  void reportErrorsOnDirectories(List<StorageDirectory> sds) {
-  void reportErrorsOnDirectory(StorageDirectory sd)
-      throws IOException {
+  void reportErrorsOnDirectory(StorageDirectory sd) {
-    for (NNStorageListener listener : listeners) {
-      listener.errorOccurred(sd);
-    }
-
-    incrementCheckpointTime();
-
+    
+   * Report that an IOE has occurred on some file which may
+   * or may not be within one of the NN image storage directories.
+   */
+  void reportErrorOnFile(File f) {
+    // We use getAbsolutePath here instead of getCanonicalPath since we know
+    // that there is some IO problem on that drive.
+    // getCanonicalPath may need to call stat() or readlink() and it's likely
+    // those calls would fail due to the same underlying IO problem.
+    String absPath = f.getAbsolutePath();
+    for (StorageDirectory sd : storageDirs) {
+      String dirPath = sd.getRoot().getAbsolutePath();
+      if (!dirPath.endsWith("/")) {
+        dirPath += "/";
+      }
+      if (absPath.startsWith(dirPath)) {
+        reportErrorsOnDirectory(sd);
+        return;
+      }
+    }
+    
+  }
+  
+  /**
+
+  /**
+   * Iterate over all current storage directories, inspecting them
+   * with the given inspector.
+   */
+  void inspectStorageDirs(FSImageStorageInspector inspector)
+      throws IOException {
+
+    // Process each of the storage directories to find the pair of
+    // newest image file and edit file
+    for (Iterator<StorageDirectory> it = dirIterator(); it.hasNext();) {
+      StorageDirectory sd = it.next();
+      inspector.inspectDirectory(sd);
+    }
+  }
+
+  /**
+   * Iterate over all of the storage dirs, reading their contents to determine
+   * their layout versions. Returns an FSImageStorageInspector which has
+   * inspected each directory.
+   * 
+   * <b>Note:</b> this can mutate the storage info fields (ctime, version, etc).
+   * @throws IOException if no valid storage dirs are found
+   */
+  FSImageStorageInspector readAndInspectDirs()
+      throws IOException {
+    int minLayoutVersion = Integer.MAX_VALUE; // the newest
+    int maxLayoutVersion = Integer.MIN_VALUE; // the oldest
+    
+    // First determine what range of layout versions we're going to inspect
+    for (Iterator<StorageDirectory> it = dirIterator();
+         it.hasNext();) {
+      StorageDirectory sd = it.next();
+      if (!sd.getVersionFile().exists()) {
+        FSImage.LOG.warn("Storage directory " + sd + " contains no VERSION file. Skipping...");
+        continue;
+      }
+      readProperties(sd); // sets layoutVersion
+      minLayoutVersion = Math.min(minLayoutVersion, getLayoutVersion());
+      maxLayoutVersion = Math.max(maxLayoutVersion, getLayoutVersion());
+    }
+    
+    if (minLayoutVersion > maxLayoutVersion) {
+      throw new IOException("No storage directories contained VERSION information");
+    }
+    assert minLayoutVersion <= maxLayoutVersion;
+    
+    // If we have any storage directories with the new layout version
+    // (ie edits_<txnid>) then use the new inspector, which will ignore
+    // the old format dirs.
+    FSImageStorageInspector inspector;
+    if (LayoutVersion.supports(Feature.TXID_BASED_LAYOUT, minLayoutVersion)) {
+      inspector = new FSImageTransactionalStorageInspector();
+      if (!LayoutVersion.supports(Feature.TXID_BASED_LAYOUT, maxLayoutVersion)) {
+        FSImage.LOG.warn("Ignoring one or more storage directories with old layouts");
+      }
+    } else {
+      inspector = new FSImagePreTransactionalStorageInspector();
+    }
+    
+    inspectStorageDirs(inspector);
+    return inspector;
+  }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 MOV31 MOV31 MOV31 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS72 INS72 INS29 MOV83 MOV39 MOV59 INS29 INS83 INS74 INS59 INS44 INS44 MOV43 MOV8 INS78 INS83 UPD42 UPD42 INS44 UPD42 INS44 UPD42 UPD42 INS8 INS44 INS44 MOV29 UPD83 MOV83 MOV39 UPD42 MOV42 MOV44 INS8 INS29 INS43 INS42 INS44 INS8 INS83 MOV43 INS42 MOV44 MOV44 INS44 INS8 INS78 INS83 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS8 INS78 MOV83 INS83 INS43 UPD42 MOV42 INS44 INS8 UPD83 MOV83 INS43 INS42 MOV44 INS44 INS8 INS83 INS43 INS42 MOV44 INS44 INS44 INS8 INS83 INS43 INS42 MOV44 INS44 INS8 INS78 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS29 MOV43 INS42 INS44 INS44 MOV43 INS8 INS29 MOV43 INS42 INS44 MOV43 INS8 INS29 UPD83 MOV83 MOV43 UPD42 MOV42 INS44 INS44 INS8 UPD74 MOV74 INS42 INS44 INS8 INS39 INS42 INS44 INS8 INS39 UPD42 INS44 MOV43 MOV8 MOV29 INS43 INS42 MOV43 INS8 UPD42 INS42 INS45 INS42 INS45 MOV65 UPD42 INS40 MOV65 INS43 UPD43 MOV43 UPD43 MOV43 INS42 INS65 INS65 INS65 INS74 INS42 INS74 INS42 MOV25 INS51 INS42 INS39 INS42 INS21 INS39 INS42 UPD65 UPD42 INS70 INS39 INS42 INS39 INS42 MOV21 INS43 INS42 MOV21 INS60 INS25 INS65 INS42 INS43 INS42 INS6 INS41 INS39 INS42 INS41 UPD65 INS42 INS42 INS39 UPD42 MOV42 INS41 INS42 UPD42 MOV42 INS39 INS42 INS41 INS42 INS42 INS39 INS42 INS41 INS42 INS39 INS42 INS41 INS42 INS39 INS42 INS39 INS42 INS41 INS42 INS39 INS42 INS41 INS42 INS42 INS39 INS42 INS39 INS42 INS41 INS65 INS39 INS42 INS39 INS42 INS60 INS25 INS41 MOV65 INS39 INS42 INS41 INS65 INS43 INS42 MOV43 INS42 INS70 MOV41 UPD43 INS43 INS42 INS25 UPD65 INS43 INS42 INS60 INS70 UPD65 INS43 INS42 UPD65 INS42 INS60 INS60 INS24 INS25 INS6 INS60 INS25 INS21 INS41 UPD66 UPD66 UPD66 UPD66 INS66 UPD42 MOV42 UPD42 UPD42 INS42 INS66 INS42 INS66 INS42 INS66 INS43 INS43 MOV43 INS43 INS32 UPD66 MOV22 MOV8 UPD66 INS66 UPD66 INS66 UPD66 UPD66 INS66 INS66 INS66 INS66 UPD66 INS43 UPD42 INS32 MOV43 UPD43 UPD66 INS7 UPD66 UPD42 INS66 UPD66 UPD66 INS66 INS66 UPD42 UPD66 MOV44 INS42 INS8 MOV32 UPD66 UPD66 INS42 MOV43 INS59 INS27 INS8 INS66 INS66 INS42 INS27 INS27 INS32 UPD66 INS14 UPD66 INS66 INS32 INS32 INS32 INS14 INS14 INS14 INS32 INS66 MOV43 INS59 INS27 INS8 INS42 UPD66 UPD66 MOV66 INS32 INS66 INS66 INS66 INS42 MOV44 INS32 INS8 UPD66 INS66 UPD42 UPD42 MOV42 INS27 MOV8 INS66 UPD66 MOV42 INS43 INS59 MOV44 INS42 INS8 UPD66 INS66 INS42 MOV8 UPD66 INS66 INS66 INS66 UPD42 UPD66 INS39 INS59 INS39 INS59 MOV58 MOV32 INS8 INS27 INS8 INS27 INS43 INS59 INS32 INS8 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 INS24 INS42 UPD42 UPD42 INS42 INS42 INS27 INS27 UPD42 UPD42 INS22 INS42 INS54 UPD42 INS34 UPD42 UPD42 MOV42 UPD42 INS14 INS42 INS32 INS42 INS33 MOV21 INS32 INS40 UPD45 MOV45 INS45 UPD42 MOV42 UPD42 MOV42 INS42 MOV43 MOV32 INS32 UPD42 MOV42 UPD42 MOV42 INS45 MOV32 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS32 INS42 INS42 INS42 INS45 INS32 INS42 MOV43 INS32 INS32 MOV43 INS32 INS32 MOV43 INS32 INS32 INS42 INS42 INS45 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS33 INS53 INS42 INS40 INS32 UPD42 MOV42 UPD42 MOV42 MOV60 INS25 INS42 INS33 INS42 INS42 INS32 INS60 INS25 INS25 INS21 INS42 INS40 INS42 INS40 MOV60 INS25 INS21 MOV21 INS21 INS42 INS42 INS53 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS40 INS42 INS21 INS25 INS21 INS42 INS42 MOV58 MOV32 MOV8 UPD40 UPD42 UPD42 UPD43 UPD42 MOV42 UPD34 MOV34 INS45 INS42 UPD40 UPD43 UPD42 INS52 INS42 INS8 INS12 MOV43 INS74 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS45 INS32 INS42 INS40 UPD42 UPD40 MOV40 INS42 INS40 INS42 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 MOV42 INS42 INS40 INS32 MOV14 INS42 INS42 INS43 INS27 INS8 INS42 INS42 INS43 INS59 INS38 INS8 INS32 MOV8 INS32 INS38 INS8 INS32 INS7 INS14 INS7 INS38 INS8 INS7 MOV60 MOV60 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 MOV42 UPD42 INS13 UPD42 UPD42 INS42 INS42 MOV21 MOV44 INS8 INS43 INS43 INS43 UPD42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 INS14 INS32 INS32 INS41 INS14 INS42 INS42 MOV32 INS32 INS21 UPD42 MOV42 UPD42 MOV42 INS42 INS41 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 INS21 INS18 INS42 INS42 INS42 INS32 INS42 INS32 MOV43 INS45 INS42 INS14 INS32 INS21 INS42 INS14 UPD43 INS32 INS42 INS32 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS45 INS42 UPD45 UPD42 INS45 INS43 INS32 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 INS43 MOV32 MOV42 INS42 INS42 INS42 INS45 INS7 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS43 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 MOV42 INS32 INS43 UPD42 UPD43 UPD42 UPD42 INS32 UPD42 UPD42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 INS42 INS45 INS40 INS42 INS27 INS42 INS42 INS42 INS40 INS42 INS45 INS42 UPD42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS45 INS42 INS45 UPD42 MOV42 UPD42 MOV42 INS45 INS42 DEL29 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL39 DEL42 DEL31 DEL55 DEL83 DEL83 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL66 DEL34 DEL38 DEL83 DEL23 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL40 DEL42 DEL46 DEL42 DEL74 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL32 DEL21 DEL66 DEL42 DEL66 DEL65 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL27 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL24 DEL51 DEL8 DEL32 DEL83 DEL27 DEL41 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL9 DEL66 DEL66 DEL66 DEL83 DEL42 DEL42 DEL34 DEL27 DEL32 DEL66 DEL66 DEL66 DEL66 DEL65 DEL83 DEL42 DEL67 DEL65 DEL42 DEL42 DEL7 DEL8 DEL8 DEL42 DEL32 DEL42 DEL32 DEL45 DEL32 DEL27 DEL32 DEL21 DEL44 DEL45 DEL32 DEL27 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL12 DEL54 DEL8 DEL24 DEL8 DEL31 DEL42 DEL42 DEL32 DEL66 DEL65 DEL29 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL42 DEL52 DEL42 DEL42 DEL32 DEL32 DEL21 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL40 DEL42 DEL68 DEL65 DEL40 DEL42 DEL68 DEL65 DEL29 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL32 DEL42 DEL45 DEL27 DEL6 DEL32 DEL38 DEL42 DEL45 DEL27 DEL6 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL32 DEL38 DEL27 DEL53 DEL25 DEL8 DEL31 DEL40 DEL42 DEL68 DEL65 DEL40 DEL42 DEL68 DEL65 DEL29 DEL39 DEL42 DEL32 DEL59 DEL60 DEL32 DEL42 DEL32 DEL21 DEL25 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL25 DEL52 DEL42 DEL32 DEL42 DEL66 DEL65 DEL39 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL32 DEL14 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL58 DEL24 DEL8 DEL65 DEL66 DEL66 DEL65 DEL32 DEL74 DEL42 DEL42 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL65 DEL42 DEL66 DEL65 DEL29 DEL39 DEL42 DEL43 DEL42 DEL44 DEL32 DEL21 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL42 DEL32 DEL21 DEL42 DEL40 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL32 DEL32 DEL42 DEL42 DEL32 DEL41 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL40 DEL32 DEL41 DEL42 DEL42 DEL40 DEL32 DEL41 DEL8 DEL52 DEL42 DEL22 DEL42
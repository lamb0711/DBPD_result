HDFS-347: style cleanups. Contributed by Colin Patrick McCabe.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1446830 13f79535-47bb-0310-9956-ffa450edef68

-      String problem = "DomainSocket#anchorNative got error: unknown";
+      String problem;
-   * Status bits
-   * 
-   * Bit 30: 0 = DomainSocket open, 1 = DomainSocket closed
-   * Bits 29 to 0: the reference count.
+   * Tracks the reference count of the file descriptor, and also whether it is
+   * open or closed.
-  private final AtomicInteger status;
+  private static class Status {
+    /**
+     * Bit mask representing a closed domain socket. 
+     */
+    private static final int STATUS_CLOSED_MASK = 1 << 30;
+    
+    /**
+     * Status bits
+     * 
+     * Bit 30: 0 = DomainSocket open, 1 = DomainSocket closed
+     * Bits 29 to 0: the reference count.
+     */
+    private final AtomicInteger bits = new AtomicInteger(0);
+
+    Status() { }
+
+    /**
+     * Increment the reference count of the underlying file descriptor.
+     *
+     * @throws ClosedChannelException      If the file descriptor is closed.
+     */
+    void reference() throws ClosedChannelException {
+      int curBits = bits.incrementAndGet();
+      if ((curBits & STATUS_CLOSED_MASK) != 0) {
+        bits.decrementAndGet();
+        throw new ClosedChannelException();
+      }
+    }
+
+    /**
+     * Decrement the reference count of the underlying file descriptor.
+     *
+     * @param checkClosed        Whether to throw an exception if the file
+     *                           descriptor is closed.
+     *
+     * @throws AsynchronousCloseException  If the file descriptor is closed and
+     *                                     checkClosed is set.
+     */
+    void unreference(boolean checkClosed) throws AsynchronousCloseException {
+      int newCount = bits.decrementAndGet();
+      assert (newCount & ~STATUS_CLOSED_MASK) >= 0;
+      if (checkClosed && ((newCount & STATUS_CLOSED_MASK) != 0)) {
+        throw new AsynchronousCloseException();
+      }
+    }
+
+    /**
+     * Return true if the file descriptor is currently open.
+     * 
+     * @return                 True if the file descriptor is currently open.
+     */
+    boolean isOpen() {
+      return ((bits.get() & STATUS_CLOSED_MASK) == 0);
+    }
+
+    /**
+     * Mark the file descriptor as closed.
+     *
+     * Once the file descriptor is closed, it cannot be reopened.
+     *
+     * @return                         The current reference count.
+     * @throws ClosedChannelException  If someone else closes the file 
+     *                                 descriptor before we do.
+     */
+    int setClosed() throws ClosedChannelException {
+      while (true) {
+        int curBits = bits.get();
+        if ((curBits & STATUS_CLOSED_MASK) != 0) {
+          throw new ClosedChannelException();
+        }
+        if (bits.compareAndSet(curBits, curBits | STATUS_CLOSED_MASK)) {
+          return curBits & (~STATUS_CLOSED_MASK);
+        }
+      }
+    }
+
+    /**
+     * Get the current reference count.
+     *
+     * @return                 The current reference count.
+     */
+    int getReferenceCount() {
+      return bits.get() & (~STATUS_CLOSED_MASK);
+    }
+  }
-   * Bit mask representing a closed domain socket. 
+   * The socket status.
-  private static final int STATUS_CLOSED_MASK = 1 << 30;
+  private final Status status;
-    this.status = new AtomicInteger(0);
+    this.status = new Status();
-    fdRef();
+    status.reference();
-      fdUnref(exc);
+      status.unreference(exc);
-  /**
-   * Increment the reference count of the underlying file descriptor.
-   *
-   * @throws SocketException  If the file descriptor is closed.
-   */
-  private void fdRef() throws ClosedChannelException {
-    int bits = status.incrementAndGet();
-    if ((bits & STATUS_CLOSED_MASK) != 0) {
-      status.decrementAndGet();
-      throw new ClosedChannelException();
-    }
-  }
-
-  /**
-   * Decrement the reference count of the underlying file descriptor.
-   */
-  private void fdUnref(boolean checkClosed) throws AsynchronousCloseException {
-    int newCount = status.decrementAndGet();
-    assert (newCount & ~STATUS_CLOSED_MASK) >= 0;
-    if (checkClosed && ((newCount & STATUS_CLOSED_MASK) != 0)) {
-      throw new AsynchronousCloseException();
-    }
-  }
-
-  /**
-   * Return true if the file descriptor is currently open.
-   * 
-   * @return                 True if the file descriptor is currently open.
-   */
-  public boolean isOpen() {
-    return ((status.get() & STATUS_CLOSED_MASK) == 0);
-  }
+ /**
+  * Return true if the file descriptor is currently open.
+  *
+  * @return                 True if the file descriptor is currently open.
+  */
+ public boolean isOpen() {
+   return status.isOpen();
+ }
-  public static final int SND_BUF_SIZE = 1;
-  public static final int RCV_BUF_SIZE = 2;
-  public static final int SND_TIMEO = 3;
-  public static final int RCV_TIMEO = 4;
+  public static final int SEND_BUFFER_SIZE = 1;
+  public static final int RECEIVE_BUFFER_SIZE = 2;
+  public static final int SEND_TIMEOUT = 3;
+  public static final int RECEIVE_TIMEOUT = 4;
-    fdRef();
+    status.reference();
-      fdUnref(exc);
+      status.unreference(exc);
-    fdRef();
+    status.reference();
-      fdUnref(exc);
+      status.unreference(exc);
-    int bits;
-    while (true) {
-      bits = status.get();
-      if ((bits & STATUS_CLOSED_MASK) != 0) {
-        return; // already closed
-      }
-      if (status.compareAndSet(bits, bits | STATUS_CLOSED_MASK)) {
-        break;
-      }
+    int refCount;
+    try {
+      refCount = status.setClosed();
+    } catch (ClosedChannelException e) {
+      // Someone else already closed the DomainSocket.
+      return;
-    while ((bits & (~STATUS_CLOSED_MASK)) > 0) {
+    while (refCount > 0) {
-      bits = status.get();
+      refCount = status.getReferenceCount();
-    // Close the file descriptor.  After this point, the file descriptor
-    // number will be reused by something else.  Although this DomainSocket
-    // object continues to hold the old file descriptor number (it's a final
-    // field), we never use it again because we look at the closed bit and
-    // realize that this DomainSocket is not usable.
+    // At this point, nobody has a reference to the file descriptor, 
+    // and nobody will be able to get one in the future either.
+    // We now call close(2) on the file descriptor.
+    // After this point, the file descriptor number will be reused by 
+    // something else.  Although this DomainSocket object continues to hold 
+    // the old file descriptor number (it's a final field), we never use it 
+    // again because this DomainSocket is closed.
-  /*
-   * Clean up if the user forgets to close the socket.
-   */
-  protected void finalize() throws IOException {
-    close();
-  }
-
-  private native static void sendFileDescriptors0(int fd, FileDescriptor jfds[],
+  private native static void sendFileDescriptors0(int fd,
+      FileDescriptor descriptors[],
-   * @param jfds              The file descriptors to send.
+   * @param descriptors       The file descriptors to send.
-  public void sendFileDescriptors(FileDescriptor jfds[],
+  public void sendFileDescriptors(FileDescriptor descriptors[],
-    fdRef();
+    status.reference();
-      sendFileDescriptors0(fd, jfds, jbuf, offset, length);
+      sendFileDescriptors0(fd, descriptors, jbuf, offset, length);
-      fdUnref(exc);
+      status.unreference(exc);
-  private static native int receiveFileDescriptors0(int fd, FileDescriptor[] jfds,
+  private static native int receiveFileDescriptors0(int fd,
+      FileDescriptor[] descriptors,
-   * @param jfds              (output parameter) Array of FileDescriptors.
+   * @param descriptors       (output parameter) Array of FileDescriptors.
-  public int receiveFileDescriptors(FileDescriptor[] jfds,
+  public int receiveFileDescriptors(FileDescriptor[] descriptors,
-    fdRef();
+    status.reference();
-      int nBytes = receiveFileDescriptors0(fd, jfds, jbuf, offset, length);
+      int nBytes = receiveFileDescriptors0(fd, descriptors, jbuf, offset, length);
-      fdUnref(exc);
+      status.unreference(exc);
-  public int recvFileInputStreams(FileInputStream[] fis, byte buf[],
+  public int recvFileInputStreams(FileInputStream[] streams, byte buf[],
-    FileDescriptor fds[] = new FileDescriptor[fis.length];
+    FileDescriptor descriptors[] = new FileDescriptor[streams.length];
-    for (int i = 0; i < fis.length; i++) {
-      fis[i] = null;
+    for (int i = 0; i < streams.length; i++) {
+      streams[i] = null;
-    fdRef();
+    status.reference();
-      int ret = receiveFileDescriptors0(fd, fds, buf, offset, length);
-      for (int i = 0, j = 0; i < fds.length; i++) {
-        if (fds[i] != null) {
-          fis[j++] = new FileInputStream(fds[i]);
-          fds[i] = null;
+      int ret = receiveFileDescriptors0(fd, descriptors, buf, offset, length);
+      for (int i = 0, j = 0; i < descriptors.length; i++) {
+        if (descriptors[i] != null) {
+          streams[j++] = new FileInputStream(descriptors[i]);
+          descriptors[i] = null;
-        for (int i = 0; i < fds.length; i++) {
-          if (fds[i] != null) {
+        for (int i = 0; i < descriptors.length; i++) {
+          if (descriptors[i] != null) {
-              closeFileDescriptor0(fds[i]);
+              closeFileDescriptor0(descriptors[i]);
-          } else if (fis[i] != null) {
+          } else if (streams[i] != null) {
-              fis[i].close();
+              streams[i].close();
-              fis[i] = null; }
+              streams[i] = null; }
-      fdUnref(!success);
+      status.unreference(!success);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);

MOV31 MOV31 INS55 INS23 INS31 INS29 INS83 INS83 INS42 MOV23 MOV23 INS31 MOV31 MOV31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 MOV59 MOV29 INS83 INS39 INS42 INS8 UPD83 UPD83 UPD39 UPD42 MOV44 MOV44 UPD83 UPD83 UPD39 UPD42 INS44 INS65 INS59 INS42 INS8 UPD42 UPD42 INS29 MOV39 MOV42 MOV8 INS29 INS39 INS42 INS43 INS8 INS29 INS39 INS42 INS8 INS65 INS42 INS41 UPD42 UPD42 UPD42 UPD42 INS54 UPD42 UPD42 INS5 INS42 UPD42 UPD42 INS66 INS66 INS42 INS14 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS61 INS65 INS65 INS41 INS66 INS32 INS8 INS12 UPD42 UPD66 INS43 INS85 UPD42 UPD66 MOV43 MOV85 MOV58 MOV37 INS43 MOV34 UPD42 UPD66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS9 INS8 INS66 INS66 MOV27 UPD42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 UPD42 MOV21 INS44 MOV8 INS42 UPD42 INS42 INS42 UPD42 INS42 UPD42 UPD40 UPD42 INS42 INS42 UPD42 INS60 INS25 INS25 INS32 UPD43 INS43 INS42 MOV5 UPD40 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 UPD42 INS39 INS59 INS27 INS8 INS32 INS8 INS42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 UPD42 INS42 UPD42 UPD42 INS42 UPD42 INS42 UPD42 UPD40 INS42 UPD42 UPD42 UPD42 INS42 INS32 INS36 INS34 INS53 INS42 INS42 INS42 INS27 INS41 UPD42 UPD42 UPD42 UPD42 UPD42 MOV58 MOV37 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 INS42 INS27 INS14 INS42 INS42 INS27 UPD40 UPD42 INS42 INS42 INS43 INS42 INS36 UPD42 MOV8 INS42 INS38 MOV8 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS8 INS21 INS42 INS7 UPD42 INS42 INS2 INS33 UPD42 INS42 INS42 DEL45 DEL83 DEL83 DEL42 DEL83 DEL31 DEL9 DEL42 DEL42 DEL27 DEL36 DEL34 DEL27 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL10 DEL8 DEL25 DEL8 DEL61 DEL36 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL44 DEL42 DEL42 DEL42 DEL2 DEL33 DEL7 DEL21 DEL8 DEL42
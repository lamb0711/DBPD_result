HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)

+import com.amazonaws.services.s3.model.AmazonS3Exception;
+import static org.apache.hadoop.fs.s3a.S3AUtils.*;
-    instrumentation = new S3AInstrumentation(name);
+    try {
+      instrumentation = new S3AInstrumentation(name);
-    uri = URI.create(name.getScheme() + "://" + name.getAuthority());
-    workingDir = new Path("/user", System.getProperty("user.name"))
-        .makeQualified(this.uri, this.getWorkingDirectory());
+      uri = URI.create(name.getScheme() + "://" + name.getAuthority());
+      workingDir = new Path("/user", System.getProperty("user.name"))
+          .makeQualified(this.uri, this.getWorkingDirectory());
-    bucket = name.getHost();
+      bucket = name.getHost();
-    AWSCredentialsProvider credentials = getAWSCredentialsProvider(name, conf);
+      AWSCredentialsProvider credentials =
+          getAWSCredentialsProvider(name, conf);
-    ClientConfiguration awsConf = new ClientConfiguration();
-    awsConf.setMaxConnections(intOption(conf, MAXIMUM_CONNECTIONS,
-        DEFAULT_MAXIMUM_CONNECTIONS, 1));
-    boolean secureConnections = conf.getBoolean(SECURE_CONNECTIONS,
-        DEFAULT_SECURE_CONNECTIONS);
-    awsConf.setProtocol(secureConnections ?  Protocol.HTTPS : Protocol.HTTP);
-    awsConf.setMaxErrorRetry(intOption(conf, MAX_ERROR_RETRIES,
-        DEFAULT_MAX_ERROR_RETRIES, 0));
-    awsConf.setConnectionTimeout(intOption(conf, ESTABLISH_TIMEOUT,
-        DEFAULT_ESTABLISH_TIMEOUT, 0));
-    awsConf.setSocketTimeout(intOption(conf, SOCKET_TIMEOUT,
-        DEFAULT_SOCKET_TIMEOUT, 0));
-    String signerOverride = conf.getTrimmed(SIGNING_ALGORITHM, "");
-    if (!signerOverride.isEmpty()) {
-      LOG.debug("Signer override = {}", signerOverride);
-      awsConf.setSignerOverride(signerOverride);
+      ClientConfiguration awsConf = new ClientConfiguration();
+      awsConf.setMaxConnections(intOption(conf, MAXIMUM_CONNECTIONS,
+          DEFAULT_MAXIMUM_CONNECTIONS, 1));
+      boolean secureConnections = conf.getBoolean(SECURE_CONNECTIONS,
+          DEFAULT_SECURE_CONNECTIONS);
+      awsConf.setProtocol(secureConnections ?  Protocol.HTTPS : Protocol.HTTP);
+      awsConf.setMaxErrorRetry(intOption(conf, MAX_ERROR_RETRIES,
+          DEFAULT_MAX_ERROR_RETRIES, 0));
+      awsConf.setConnectionTimeout(intOption(conf, ESTABLISH_TIMEOUT,
+          DEFAULT_ESTABLISH_TIMEOUT, 0));
+      awsConf.setSocketTimeout(intOption(conf, SOCKET_TIMEOUT,
+          DEFAULT_SOCKET_TIMEOUT, 0));
+      String signerOverride = conf.getTrimmed(SIGNING_ALGORITHM, "");
+      if (!signerOverride.isEmpty()) {
+        LOG.debug("Signer override = {}", signerOverride);
+        awsConf.setSignerOverride(signerOverride);
+      }
+
+      initProxySupport(conf, awsConf, secureConnections);
+
+      initUserAgent(conf, awsConf);
+
+      initAmazonS3Client(conf, credentials, awsConf);
+
+      maxKeys = intOption(conf, MAX_PAGING_KEYS, DEFAULT_MAX_PAGING_KEYS, 1);
+      partSize = conf.getLong(MULTIPART_SIZE, DEFAULT_MULTIPART_SIZE);
+      if (partSize < 5 * 1024 * 1024) {
+        LOG.error(MULTIPART_SIZE + " must be at least 5 MB");
+        partSize = 5 * 1024 * 1024;
+      }
+
+      multiPartThreshold = conf.getLong(MIN_MULTIPART_THRESHOLD,
+          DEFAULT_MIN_MULTIPART_THRESHOLD);
+      if (multiPartThreshold < 5 * 1024 * 1024) {
+        LOG.error(MIN_MULTIPART_THRESHOLD + " must be at least 5 MB");
+        multiPartThreshold = 5 * 1024 * 1024;
+      }
+      //check but do not store the block size
+      longOption(conf, FS_S3A_BLOCK_SIZE, DEFAULT_BLOCKSIZE, 1);
+      enableMultiObjectsDelete = conf.getBoolean(ENABLE_MULTI_DELETE, true);
+
+      readAhead = longOption(conf, READAHEAD_RANGE, DEFAULT_READAHEAD_RANGE, 0);
+
+      int maxThreads = conf.getInt(MAX_THREADS, DEFAULT_MAX_THREADS);
+      if (maxThreads < 2) {
+        LOG.warn(MAX_THREADS + " must be at least 2: forcing to 2.");
+        maxThreads = 2;
+      }
+      int totalTasks = conf.getInt(MAX_TOTAL_TASKS, DEFAULT_MAX_TOTAL_TASKS);
+      if (totalTasks < 1) {
+        LOG.warn(MAX_TOTAL_TASKS + "must be at least 1: forcing to 1.");
+        totalTasks = 1;
+      }
+      long keepAliveTime = conf.getLong(KEEPALIVE_TIME, DEFAULT_KEEPALIVE_TIME);
+      threadPoolExecutor = new BlockingThreadPoolExecutorService(maxThreads,
+          maxThreads + totalTasks, keepAliveTime, TimeUnit.SECONDS,
+          "s3a-transfer-shared");
+
+      initTransferManager();
+
+      initCannedAcls(conf);
+
+      verifyBucketExists();
+
+      initMultipartUploads(conf);
+
+      serverSideEncryptionAlgorithm =
+          conf.getTrimmed(SERVER_SIDE_ENCRYPTION_ALGORITHM);
+    } catch (AmazonClientException e) {
+      throw translateException("initializing ", new Path(name), e);
-    initProxySupport(conf, awsConf, secureConnections);
+  }
-    initUserAgent(conf, awsConf);
-
-    initAmazonS3Client(conf, credentials, awsConf);
-
-    maxKeys = intOption(conf, MAX_PAGING_KEYS, DEFAULT_MAX_PAGING_KEYS, 1);
-    partSize = conf.getLong(MULTIPART_SIZE, DEFAULT_MULTIPART_SIZE);
-    if (partSize < 5 * 1024 * 1024) {
-      LOG.error(MULTIPART_SIZE + " must be at least 5 MB");
-      partSize = 5 * 1024 * 1024;
+  /**
+   * Verify that the bucket exists. This does not check permissions,
+   * not even read access.
+   * @throws FileNotFoundException the bucket is absent
+   * @throws IOException any other problem talking to S3
+   */
+  protected void verifyBucketExists()
+      throws FileNotFoundException, IOException {
+    try {
+      if (!s3.doesBucketExist(bucket)) {
+        throw new FileNotFoundException("Bucket " + bucket + " does not exist");
+      }
+    } catch (AmazonS3Exception e) {
+      // this is a sign of a serious startup problem so do dump everything
+      LOG.warn(stringify(e), e);
+      throw translateException("doesBucketExist", bucket, e);
+    } catch (AmazonServiceException e) {
+      // this is a sign of a serious startup problem so do dump everything
+      LOG.warn(stringify(e), e);
+      throw translateException("doesBucketExist", bucket, e);
+    } catch (AmazonClientException e) {
+      throw translateException("doesBucketExist", bucket, e);
-
-    multiPartThreshold = conf.getLong(MIN_MULTIPART_THRESHOLD,
-        DEFAULT_MIN_MULTIPART_THRESHOLD);
-    if (multiPartThreshold < 5 * 1024 * 1024) {
-      LOG.error(MIN_MULTIPART_THRESHOLD + " must be at least 5 MB");
-      multiPartThreshold = 5 * 1024 * 1024;
-    }
-    //check but do not store the block size
-    longOption(conf, FS_S3A_BLOCK_SIZE, DEFAULT_BLOCKSIZE, 1);
-    enableMultiObjectsDelete = conf.getBoolean(ENABLE_MULTI_DELETE, true);
-    readAhead = longOption(conf, READAHEAD_RANGE, DEFAULT_READAHEAD_RANGE, 0);
-
-    int maxThreads = conf.getInt(MAX_THREADS, DEFAULT_MAX_THREADS);
-    if (maxThreads < 2) {
-      LOG.warn(MAX_THREADS + " must be at least 2: forcing to 2.");
-      maxThreads = 2;
-    }
-    int totalTasks = conf.getInt(MAX_TOTAL_TASKS, DEFAULT_MAX_TOTAL_TASKS);
-    if (totalTasks < 1) {
-      LOG.warn(MAX_TOTAL_TASKS + "must be at least 1: forcing to 1.");
-      totalTasks = 1;
-    }
-    long keepAliveTime = conf.getLong(KEEPALIVE_TIME, DEFAULT_KEEPALIVE_TIME);
-    threadPoolExecutor = new BlockingThreadPoolExecutorService(maxThreads,
-        maxThreads + totalTasks, keepAliveTime, TimeUnit.SECONDS,
-        "s3a-transfer-shared");
-
-    initTransferManager();
-
-    initCannedAcls(conf);
-
-    if (!s3.doesBucketExist(bucket)) {
-      throw new FileNotFoundException("Bucket " + bucket + " does not exist");
-    }
-
-    initMultipartUploads(conf);
-
-    serverSideEncryptionAlgorithm = conf.get(SERVER_SIDE_ENCRYPTION_ALGORITHM);
-
-  private void initMultipartUploads(Configuration conf) {
+  private void initMultipartUploads(Configuration conf) throws IOException {
-          LOG.debug("Failed to abort multipart uploads against {}," +
+          LOG.debug("Failed to purging multipart uploads against {}," +
-          throw e;
+          throw translateException("purging multipart uploads", bucket, e);
-   * @throws IOException on failure
+   * @throws IOException on IO failure
+    try {
+      return innerRename(src, dst);
+    } catch (AmazonClientException e) {
+      throw translateException("rename(" + src +", " + dst + ")", src, e);
+    }
+  }
+
+  /**
+   * The inner rename operation. See {@link #rename(Path, Path)} for
+   * the description of the operation.
+   * @param src path to be renamed
+   * @param dst new path after rename
+   * @return true if rename is successful
+   * @throws IOException on IO failure.
+   * @throws AmazonClientException on failures inside the AWS SDK
+   */
+  private boolean innerRename(Path src, Path dst) throws IOException,
+      AmazonClientException {
-          boolean clearKeys) {
+          boolean clearKeys) throws AmazonClientException {
-  /** Delete a file.
+  /**
+   * Delete a Path. This operation is at least {@code O(files)}, with
+   * added overheads to enumerate the path. It is also not atomic.
+    try {
+      return innerDelete(f, recursive);
+    } catch (AmazonClientException e) {
+      throw translateException("delete", f, e);
+    }
+  }
+
+  /**
+   * Delete a path. See {@link #delete(Path, boolean)}.
+   *
+   * @param f the path to delete.
+   * @param recursive if path is a directory and set to
+   * true, the directory is deleted else throws an exception. In
+   * case of a file the recursive can be set to either true or false.
+   * @return  true if delete is successful else false.
+   * @throws IOException due to inability to delete a directory or file.
+   * @throws AmazonClientException on failures inside the AWS SDK
+   */
+  private boolean innerDelete(Path f, boolean recursive) throws IOException,
+      AmazonClientException {
-  private void createFakeDirectoryIfNecessary(Path f) throws IOException {
+  private void createFakeDirectoryIfNecessary(Path f)
+      throws IOException, AmazonClientException {
+    try {
+      return innerListStatus(f);
+    } catch (AmazonClientException e) {
+      throw translateException("listStatus", f, e);
+    }
+  }
+
+  /**
+   * List the statuses of the files/directories in the given path if the path is
+   * a directory.
+   *
+   * @param f given path
+   * @return the statuses of the files/directories in the given patch
+   * @throws FileNotFoundException when the path does not exist;
+   * @throws IOException due to an IO problem.
+   * @throws AmazonClientException on failures inside the AWS SDK
+   */
+  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,
+      IOException, AmazonClientException {
-   * Make the given file and all non-existent parents into
-   * directories. Has the semantics of Unix 'mkdir -p'.
+   *
+   * Make the given path and all non-existent parents into
+   * directories. Has the semantics of Unix @{code 'mkdir -p'}.
-   * @param f path to create
+   * @param path path to create
+   * @return true if a directory was created
+   * @throws FileAlreadyExistsException there is a file at the path specified
+   * @throws IOException other IO problems
-  public boolean mkdirs(Path f, FsPermission permission) throws IOException {
+  public boolean mkdirs(Path path, FsPermission permission) throws IOException,
+      FileAlreadyExistsException {
+    try {
+      return innerMkdirs(path, permission);
+    } catch (AmazonClientException e) {
+      throw translateException("innerMkdirs", path, e);
+    }
+  }
+  /**
+   *
+   * Make the given path and all non-existent parents into
+   * directories.
+   * See {@link #mkdirs(Path, FsPermission)}
+   * @param f path to create
+   * @param permission to apply to f
+   * @return true if a directory was created
+   * @throws FileAlreadyExistsException there is a file at the path specified
+   * @throws IOException other IO problems
+   * @throws AmazonClientException on failures inside the AWS SDK
+   */
+  // TODO: If we have created an empty file at /foo/bar and we then call
+  // mkdirs for /foo/bar/baz/roo what happens to the empty file /foo/bar/?
+  private boolean innerMkdirs(Path f, FsPermission permission)
+      throws IOException, FileAlreadyExistsException, AmazonClientException {
-   *         IOException see specific implementation
+   * @throws IOException on other problems.
-          printAmazonServiceException(f.toString(), e);
-          throw e;
+          throw translateException("getFileStatus", f, e);
-        printAmazonClientException(f.toString(), e);
-        throw e;
+        throw translateException("getFileStatus", f, e);
-            printAmazonServiceException(newKey, e);
-            throw e;
+            throw translateException("getFileStatus", newKey, e);
-          printAmazonClientException(newKey, e);
-          throw e;
+          throw translateException("getFileStatus", newKey, e);
-        printAmazonServiceException(key, e);
-        throw e;
+        throw translateException("getFileStatus", key, e);
-      printAmazonClientException(key, e);
-      throw e;
+      throw translateException("getFileStatus", key, e);
+   * @throws IOException IO problem
+   * @throws FileAlreadyExistsException the destination file exists and
+   * overwrite==false
+   * @throws AmazonClientException failure in the AWS SDK
+    try {
+      innerCopyFromLocalFile(delSrc, overwrite, src, dst);
+    } catch (AmazonClientException e) {
+      throw translateException("copyFromLocalFile(" + src + ", " + dst + ")",
+          src, e);
+    }
+  }
+
+  /**
+   * The src file is on the local disk.  Add it to FS at
+   * the given dst name.
+   *
+   * This version doesn't need to create a temporary file to calculate the md5.
+   * Sadly this doesn't seem to be used by the shell cp :(
+   *
+   * delSrc indicates if the source should be removed
+   * @param delSrc whether to delete the src
+   * @param overwrite whether to overwrite an existing file
+   * @param src path
+   * @param dst path
+   * @throws IOException IO problem
+   * @throws FileAlreadyExistsException the destination file exists and
+   * overwrite==false
+   * @throws AmazonClientException failure in the AWS SDK
+   */
+  private void innerCopyFromLocalFile(boolean delSrc, boolean overwrite,
+      Path src, Path dst)
+      throws IOException, FileAlreadyExistsException, AmazonClientException {
+  /**
+   * Close the filesystem. This shuts down all transfers.
+   * @throws IOException IO problem
+   */
-  public void close() throws IOException {
+  public synchronized void close() throws IOException {
-  * Override getCanonicalServiceName because we don't support token in S3A.
-  */
+   * Override getCanonicalServiceName because we don't support token in S3A.
+   */
+  /**
+   * Copy a single object in the bucket via a COPY operation.
+   * @param srcKey source object path
+   * @param dstKey destination object path
+   * @param size object size
+   * @throws AmazonClientException on failures inside the AWS SDK
+   * @throws InterruptedIOException the operation was interrupted
+   * @throws IOException Other IO problems
+   */
-      throws IOException {
+      throws IOException, InterruptedIOException, AmazonClientException {
-    ObjectMetadata srcom = s3.getObjectMetadata(bucket, srcKey);
-    ObjectMetadata dstom = cloneObjectMetadata(srcom);
-    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {
-      dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);
-    }
-    CopyObjectRequest copyObjectRequest =
-        new CopyObjectRequest(bucket, srcKey, bucket, dstKey);
-    copyObjectRequest.setCannedAccessControlList(cannedACL);
-    copyObjectRequest.setNewObjectMetadata(dstom);
-
-    ProgressListener progressListener = new ProgressListener() {
-      public void progressChanged(ProgressEvent progressEvent) {
-        switch (progressEvent.getEventType()) {
-          case TRANSFER_PART_COMPLETED_EVENT:
-            statistics.incrementWriteOps(1);
-            break;
-          default:
-            break;
-        }
-      }
-    };
-
-    Copy copy = transfers.copy(copyObjectRequest);
-    copy.addProgressListener(progressListener);
-      copy.waitForCopyResult();
-      statistics.incrementWriteOps(1);
-      instrumentation.filesCopied(1, size);
-    } catch (InterruptedException e) {
-      throw new InterruptedIOException("Interrupted copying " + srcKey
-          + " to " + dstKey + ", cancelling");
+      ObjectMetadata srcom = s3.getObjectMetadata(bucket, srcKey);
+      ObjectMetadata dstom = cloneObjectMetadata(srcom);
+      if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {
+        dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);
+      }
+      CopyObjectRequest copyObjectRequest =
+          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);
+      copyObjectRequest.setCannedAccessControlList(cannedACL);
+      copyObjectRequest.setNewObjectMetadata(dstom);
+
+      ProgressListener progressListener = new ProgressListener() {
+        public void progressChanged(ProgressEvent progressEvent) {
+          switch (progressEvent.getEventType()) {
+            case TRANSFER_PART_COMPLETED_EVENT:
+              statistics.incrementWriteOps(1);
+              break;
+            default:
+              break;
+          }
+        }
+      };
+
+      Copy copy = transfers.copy(copyObjectRequest);
+      copy.addProgressListener(progressListener);
+      try {
+        copy.waitForCopyResult();
+        statistics.incrementWriteOps(1);
+        instrumentation.filesCopied(1, size);
+      } catch (InterruptedException e) {
+        throw new InterruptedIOException("Interrupted copying " + srcKey
+            + " to " + dstKey + ", cancelling");
+      }
+    } catch (AmazonClientException e) {
+      throw translateException("copyFile("+ srcKey+ ", " + dstKey + ")",
+          srcKey, e);
-  public void finishedWrite(String key) throws IOException {
+  /**
+   * Perform post-write actions.
+   * @param key key written to
+   */
+  public void finishedWrite(String key) {
-  private void deleteUnnecessaryFakeDirectories(Path f) throws IOException {
+  /**
+   * Delete mock parent directories which are no longer needed.
+   * This code swallows IO exceptions encountered
+   * @param f path
+   */
+  private void deleteUnnecessaryFakeDirectories(Path f) {
-      } catch (FileNotFoundException | AmazonServiceException e) {
+      } catch (IOException | AmazonClientException e) {
-  private void printAmazonServiceException(String target,
-      AmazonServiceException ase) {
-    LOG.info("{}: caught an AmazonServiceException {}", target, ase);
-    LOG.info("This means your request made it to Amazon S3," +
-        " but was rejected with an error response for some reason.");
-    LOG.info("Error Message: {}", ase.getMessage());
-    LOG.info("HTTP Status Code: {}", ase.getStatusCode());
-    LOG.info("AWS Error Code: {}", ase.getErrorCode());
-    LOG.info("Error Type: {}", ase.getErrorType());
-    LOG.info("Request ID: {}", ase.getRequestId());
-    LOG.info("Class Name: {}", ase.getClass().getName());
-    LOG.info("Exception", ase);
-  }
-
-  private void printAmazonClientException(String target,
-      AmazonClientException ace) {
-    LOG.info("{}: caught an AmazonClientException {}", target, ace);
-    LOG.info("This means the client encountered " +
-        "a problem while trying to communicate with S3, " +
-        "such as not being able to access the network.", ace);
-  }
-

INS26 INS26 MOV31 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS8 INS29 UPD83 MOV83 MOV39 UPD42 MOV42 MOV43 MOV43 INS8 MOV43 MOV29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 UPD83 UPD42 INS43 INS43 MOV29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 UPD83 UPD42 INS43 INS43 MOV29 INS83 INS5 INS42 INS44 INS43 INS43 INS8 INS29 UPD42 INS43 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS8 UPD83 UPD42 INS43 INS43 MOV29 MOV78 UPD83 UPD42 INS44 INS44 INS43 INS29 UPD83 UPD42 INS43 INS43 INS29 INS83 INS29 INS43 INS43 INS8 INS29 INS29 MOV21 MOV21 INS54 INS65 INS65 INS65 INS54 INS43 INS42 INS43 INS42 INS42 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS42 INS43 INS42 INS39 INS42 INS42 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS42 INS43 INS85 INS43 INS42 INS42 INS42 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS42 INS54 INS65 INS65 INS65 INS65 INS42 INS42 INS65 INS65 INS65 INS65 INS39 INS42 INS39 INS42 UPD43 UPD42 UPD43 UPD42 INS42 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS42 MOV21 INS54 INS65 INS65 INS65 INS65 MOV8 INS12 INS66 INS66 INS42 INS66 INS42 INS66 INS8 INS12 INS12 INS12 UPD66 INS42 INS42 INS8 INS12 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 UPD66 INS65 INS66 INS66 INS42 INS8 INS12 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS8 INS12 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS8 INS12 UPD66 UPD66 UPD66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 MOV12 INS42 INS66 INS42 INS66 INS66 INS42 INS66 UPD42 UPD42 INS8 INS12 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 MOV8 INS12 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS21 INS44 INS8 MOV25 INS44 INS8 INS44 INS8 INS44 INS8 INS41 INS44 INS8 INS68 INS66 INS41 INS44 INS8 INS68 INS41 MOV44 INS8 INS41 MOV44 INS8 INS68 MOV21 INS44 INS8 INS44 INS8 INS32 INS43 INS42 INS53 UPD43 MOV43 UPD42 MOV42 INS21 INS53 MOV43 UPD42 MOV42 MOV21 INS53 INS43 INS42 INS53 INS32 INS43 INS42 INS53 INS42 INS69 INS69 INS32 INS43 INS42 INS53 INS42 INS69 INS69 INS32 INS53 INS32 INS53 INS42 INS69 INS69 INS12 INS12 INS53 INS43 INS42 INS53 INS43 INS42 INS53 INS42 INS42 INS32 UPD42 INS32 INS32 INS32 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS43 INS43 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS32 INS43 INS39 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS43 INS43 MOV44 INS8 INS44 INS8 INS32 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS32 INS42 INS32 UPD42 INS42 INS45 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 UPD42 INS32 INS42 UPD42 MOV42 INS45 INS42 INS42 INS42 UPD45 MOV45 INS42 INS42 UPD42 MOV42 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD45 MOV45 INS42 INS42 INS42 UPD42 MOV42 UPD45 MOV45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD45 MOV45 INS42 UPD42 MOV42 INS42 INS42 INS25 INS43 INS42 MOV53 INS53 UPD42 MOV42 INS45 MOV42 MOV42 INS42 MOV27 INS42 UPD42 MOV42 INS42 INS27 INS42 INS42 UPD84 INS43 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS45 INS42 INS45 MOV27 INS8 INS42 INS32 INS44 INS32 UPD45 INS42 UPD45 INS42 UPD45 INS45 INS42 INS45 INS42 INS45 INS43 UPD43 INS42 INS53 INS42 INS45 INS42 INS42 INS43 INS42 INS53 UPD42 MOV42 INS45 UPD42 MOV42 MOV42 INS42 UPD42 INS32 INS32 INS42 INS32 INS42 INS45 INS42 INS42 INS42 INS45 MOV42 UPD42 MOV42 INS53 UPD42 MOV42 INS45 MOV42 MOV42 UPD45 INS32 UPD42 MOV42 INS45 MOV42 MOV42 DEL45 DEL42 DEL66 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL12 DEL32 DEL21 DEL42 DEL53 DEL32 DEL21 DEL42 DEL53 DEL42 DEL32 DEL32 DEL21 DEL42 DEL53 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL25 DEL8 DEL12 DEL32 DEL21 DEL42 DEL53 DEL45 DEL42 DEL42 DEL32 DEL21 DEL44 DEL44 DEL42 DEL45 DEL45 DEL27 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL45 DEL32 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL32 DEL32 DEL21 DEL42 DEL32 DEL21 DEL8 DEL31
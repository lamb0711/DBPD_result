HADOOP-15229. Add FileSystem builder-based openFile() API to match createFile();
S3A to implement S3 Select through this API.

The new openFile() API is asynchronous, and implemented across FileSystem and FileContext.

The MapReduce V2 inputs are moved to this API, and you can actually set must/may
options to pass in.

This is more useful for setting things like s3a seek policy than for S3 select,
as the existing input format/record readers can't handle S3 select output where
the stream is shorter than the file length, and splitting plain text is suboptimal.
Future work is needed there.

In the meantime, any/all filesystem connectors are now free to add their own filesystem-specific
configuration parameters which can be set in jobs and used to set filesystem input stream
options (seek policy, retry, encryption secrets, etc).

Contributed by Steve Loughran

+import javax.annotation.Nonnull;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import org.apache.hadoop.fs.impl.AbstractFSBuilderImpl;
+import org.apache.hadoop.fs.impl.FutureDataInputStreamBuilderImpl;
+import org.apache.hadoop.util.LambdaUtils;
+ *
+ * This is a carefully evolving class.
+ * New methods may be marked as Unstable or Evolving for their initial release,
+ * as a warning that they are new and may change based on the
+ * experience of use in applications.
+      rejectUnknownMandatoryKeys(Collections.emptySet(),
+          " for " + getPath());
-      throw new IOException("Must specify either create, overwrite or append");
+      throw new PathIOException(getPath().toString(),
+          "Must specify either create, overwrite or append");
-    protected FileSystemDataOutputStreamBuilder getThisBuilder() {
+    public FileSystemDataOutputStreamBuilder getThisBuilder() {
+
+  /**
+   * Open a file for reading through a builder API.
+   * Ultimately calls {@link #open(Path, int)} unless a subclass
+   * executes the open command differently.
+   *
+   * The semantics of this call are therefore the same as that of
+   * {@link #open(Path, int)} with one special point: it is in
+   * {@code FSDataInputStreamBuilder.build()} in which the open operation
+   * takes place -it is there where all preconditions to the operation
+   * are checked.
+   * @param path file path
+   * @return a FSDataInputStreamBuilder object to build the input stream
+   * @throws IOException if some early checks cause IO failures.
+   * @throws UnsupportedOperationException if support is checked early.
+   */
+  @InterfaceStability.Unstable
+  public FutureDataInputStreamBuilder openFile(Path path)
+      throws IOException, UnsupportedOperationException {
+    return new FSDataInputStreamBuilder(this, path).getThisBuilder();
+  }
+
+  /**
+   * Open a file for reading through a builder API.
+   * Ultimately calls {@link #open(PathHandle, int)} unless a subclass
+   * executes the open command differently.
+   *
+   * If PathHandles are unsupported, this may fail in the
+   * {@code FSDataInputStreamBuilder.build()}  command,
+   * rather than in this {@code openFile()} operation.
+   * @param pathHandle path handle.
+   * @return a FSDataInputStreamBuilder object to build the input stream
+   * @throws IOException if some early checks cause IO failures.
+   * @throws UnsupportedOperationException if support is checked early.
+   */
+  @InterfaceStability.Unstable
+  public FutureDataInputStreamBuilder openFile(PathHandle pathHandle)
+      throws IOException, UnsupportedOperationException {
+    return new FSDataInputStreamBuilder(this, pathHandle)
+        .getThisBuilder();
+  }
+
+  /**
+   * Execute the actual open file operation.
+   *
+   * This is invoked from {@code FSDataInputStreamBuilder.build()}
+   * and from {@link DelegateToFileSystem} and is where
+   * the action of opening the file should begin.
+   *
+   * The base implementation performs a blocking
+   * call to {@link #open(Path, int)}in this call;
+   * the actual outcome is in the returned {@code CompletableFuture}.
+   * This avoids having to create some thread pool, while still
+   * setting up the expectation that the {@code get()} call
+   * is needed to evaluate the result.
+   * @param path path to the file
+   * @param mandatoryKeys set of options declared as mandatory.
+   * @param options options set during the build sequence.
+   * @param bufferSize buffer size
+   * @return a future which will evaluate to the opened file.
+   * @throws IOException failure to resolve the link.
+   * @throws IllegalArgumentException unknown mandatory key
+   */
+  protected CompletableFuture<FSDataInputStream> openFileWithOptions(
+      final Path path,
+      final Set<String> mandatoryKeys,
+      final Configuration options,
+      final int bufferSize) throws IOException {
+    AbstractFSBuilderImpl.rejectUnknownMandatoryKeys(mandatoryKeys,
+        Collections.emptySet(),
+        "for " + path);
+    return LambdaUtils.eval(
+        new CompletableFuture<>(), () -> open(path, bufferSize));
+  }
+
+  /**
+   * Execute the actual open file operation.
+   * The base implementation performs a blocking
+   * call to {@link #open(Path, int)}in this call;
+   * the actual outcome is in the returned {@code CompletableFuture}.
+   * This avoids having to create some thread pool, while still
+   * setting up the expectation that the {@code get()} call
+   * is needed to evaluate the result.
+   * @param pathHandle path to the file
+   * @param mandatoryKeys set of options declared as mandatory.
+   * @param options options set during the build sequence.
+   * @param bufferSize buffer size
+   * @return a future which will evaluate to the opened file.
+   * @throws IOException failure to resolve the link.
+   * @throws IllegalArgumentException unknown mandatory key
+   * @throws UnsupportedOperationException PathHandles are not supported.
+   * This may be deferred until the future is evaluated.
+   */
+  protected CompletableFuture<FSDataInputStream> openFileWithOptions(
+      final PathHandle pathHandle,
+      final Set<String> mandatoryKeys,
+      final Configuration options,
+      final int bufferSize) throws IOException {
+    AbstractFSBuilderImpl.rejectUnknownMandatoryKeys(mandatoryKeys,
+        Collections.emptySet(), "");
+    CompletableFuture<FSDataInputStream> result = new CompletableFuture<>();
+    try {
+      result.complete(open(pathHandle, bufferSize));
+    } catch (UnsupportedOperationException tx) {
+      // fail fast here
+      throw tx;
+    } catch (Throwable tx) {
+      // fail lazily here to ensure callers expect all File IO operations to
+      // surface later
+      result.completeExceptionally(tx);
+    }
+    return result;
+  }
+
+  /**
+   * Builder returned for {@code #openFile(Path)}
+   * and {@code #openFile(PathHandle)}.
+   */
+  private static class FSDataInputStreamBuilder
+      extends FutureDataInputStreamBuilderImpl
+      implements FutureDataInputStreamBuilder {
+
+    /**
+     * Path Constructor.
+     * @param fileSystem owner
+     * @param path path to open.
+     */
+    protected FSDataInputStreamBuilder(
+        @Nonnull final FileSystem fileSystem,
+        @Nonnull final Path path) {
+      super(fileSystem, path);
+    }
+
+    /**
+     * Construct from a path handle.
+     * @param fileSystem owner
+     * @param pathHandle path handle of file to open.
+     */
+    protected FSDataInputStreamBuilder(
+        @Nonnull final FileSystem fileSystem,
+        @Nonnull final PathHandle pathHandle) {
+      super(fileSystem, pathHandle);
+    }
+
+    /**
+     * Perform the open operation.
+     * Returns a future which, when get() or a chained completion
+     * operation is invoked, will supply the input stream of the file
+     * referenced by the path/path handle.
+     * @return a future to the input stream.
+     * @throws IOException early failure to open
+     * @throws UnsupportedOperationException if the specific operation
+     * is not supported.
+     * @throws IllegalArgumentException if the parameters are not valid.
+     */
+    @Override
+    public CompletableFuture<FSDataInputStream> build() throws IOException {
+      Optional<Path> optionalPath = getOptionalPath();
+      if(optionalPath.isPresent()) {
+        return getFS().openFileWithOptions(optionalPath.get(),
+            getMandatoryKeys(), getOptions(), getBufferSize());
+      } else {
+        return getFS().openFileWithOptions(getPathHandle(),
+            getMandatoryKeys(), getOptions(), getBufferSize());
+      }
+    }
+
+  }
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS55 INS29 INS78 INS83 INS43 INS42 INS44 MOV43 INS43 INS8 INS29 INS78 INS83 INS43 INS42 INS44 INS43 INS43 INS8 INS29 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS42 INS43 INS43 INS31 INS31 INS31 INS66 INS66 INS66 INS66 UPD83 INS65 INS65 INS65 INS65 INS65 INS40 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS40 INS42 INS43 INS42 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS43 INS83 INS43 INS42 INS83 INS74 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS42 INS21 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS43 INS83 INS43 INS42 INS83 INS74 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS42 INS21 INS60 INS54 INS41 INS65 INS42 INS42 INS29 INS83 INS42 INS44 INS44 INS8 INS29 INS83 INS42 INS44 INS44 INS8 INS29 INS78 INS83 INS74 INS42 INS43 INS8 INS21 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS32 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS74 INS59 INS8 INS12 INS12 INS42 INS66 INS65 INS66 INS65 INS66 INS65 INS65 INS65 INS78 INS83 INS43 INS42 INS78 INS83 INS43 INS42 INS46 INS65 INS65 INS65 INS78 INS83 INS43 INS42 INS78 INS83 INS43 INS42 INS46 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS43 INS42 INS60 INS25 INS32 INS68 INS68 INS66 INS14 INS42 INS68 INS66 INS66 INS14 INS42 INS66 INS42 INS68 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS42 INS42 INS14 INS86 INS68 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS32 INS45 INS43 INS43 INS42 INS14 INS21 INS44 INS8 INS44 INS8 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS74 INS59 INS32 INS8 INS8 INS42 INS32 INS27 INS43 INS32 INS42 INS69 INS69 INS42 INS69 INS69 INS43 INS52 INS42 INS42 INS69 INS69 INS43 INS52 INS42 INS42 INS69 INS69 INS42 INS42 INS45 INS42 INS74 INS32 INS42 INS69 INS69 INS42 INS42 INS42 INS42 INS74 INS32 INS43 INS42 INS53 INS43 INS42 INS21 INS43 INS43 INS42 INS32 INS42 INS42 INS41 INS41 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS43 INS39 INS43 INS39 INS42 INS43 INS39 INS42 INS43 INS39 INS43 INS42 INS42 INS42 INS43 INS39 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS32 INS32 INS32 INS42 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42
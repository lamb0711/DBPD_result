HADOOP-7353. Cleanup FsShell and prevent masking of RTE stack traces. Contributed by Daryn Sharp.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1132764 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.PrintStream;
+import java.util.ArrayList;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
+import java.util.LinkedList;
-import org.apache.hadoop.fs.shell.PathExceptions.PathNotFoundException;
-import org.apache.hadoop.ipc.RPC;
-import org.apache.hadoop.util.StringUtils;
+  private final String usagePrefix =
+    "Usage: hadoop fs [generic options]";
+
+   * Default ctor with no configuration.  Be sure to invoke
+   * {@link #setConf(Configuration)} with a valid configuration prior
+   * to running commands.
+  /**
+   * Construct a FsShell with the given configuration.  Commands can be
+   * executed via {@link #run(String[])}
+   * @param conf the hadoop configuration
+   */
-    fs = null;
-    trash = null;
-    commandFactory = new CommandFactory();
-    if(fs == null)
+    if (fs == null) {
-    
+    }
+    if (commandFactory == null) {
+      commandFactory = new CommandFactory(getConf());
+      commandFactory.addObject(new Help(), "-help");
+      commandFactory.addObject(new Usage(), "-usage");
+      registerCommands(commandFactory);
+    }
+  protected void registerCommands(CommandFactory factory) {
+    // TODO: DFSAdmin subclasses FsShell so need to protect the command
+    // registration.  This class should morph into a base class for
+    // commands, and then this method can be abstract
+    if (this.getClass().equals(FsShell.class)) {
+      factory.registerCommands(FsCommand.class);
+    }
+  }
+  
+   * @return Path to the trash
+   * @throws IOException upon error
-  /**
-   * Return an abbreviated English-language desc of the byte length
-   * @deprecated Consider using {@link org.apache.hadoop.util.StringUtils#byteDesc} instead.
-   */
-  @Deprecated
-  public static String byteDesc(long len) {
-    return StringUtils.byteDesc(len);
-  }
-
-  /**
-   * @deprecated Consider using {@link org.apache.hadoop.util.StringUtils#limitDecimalTo2} instead.
-   */
-  @Deprecated
-  public static synchronized String limitDecimalTo2(double d) {
-    return StringUtils.limitDecimalTo2(d);
-  }
-
-  private void printHelp(String cmd) {
-    String summary = "hadoop fs is the command to execute fs commands. " +
-      "The full syntax is: \n\n" +
-      "hadoop fs [-fs <local | file system URI>] [-conf <configuration file>]\n\t" +
-      "[-D <property=value>]\n\t" +
-      "[-report]";
-
-    String conf ="-conf <configuration file>:  Specify an application configuration file.";
- 
-    String D = "-D <property=value>:  Use value for given property.";
+  // NOTE: Usage/Help are inner classes to allow access to outer methods
+  // that access commandFactory
-    String fs = "-fs [local | <file system URI>]: \tSpecify the file system to use.\n" + 
-      "\t\tIf not specified, the current configuration is used, \n" +
-      "\t\ttaken from the following, in increasing precedence: \n" + 
-      "\t\t\tcore-default.xml inside the hadoop jar file \n" +
-      "\t\t\tcore-site.xml in $HADOOP_CONF_DIR \n" +
-      "\t\t'local' means use the local file system as your DFS. \n" +
-      "\t\t<file system URI> specifies a particular file system to \n" +
-      "\t\tcontact. This argument is optional but if used must appear\n" +
-      "\t\tappear first on the command line.  Exactly one additional\n" +
-      "\t\targument must be specified. \n";
+  /**
+   *  Display help for commands with their short usage and long description
+   */
+   protected class Usage extends FsCommand {
+    public static final String NAME = "usage";
+    public static final String USAGE = "[cmd ...]";
+    public static final String DESCRIPTION =
+      "Displays the usage for given command or all commands if none\n" +
+      "is specified.";
+    
+    @Override
+    protected void processRawArguments(LinkedList<String> args) {
+      if (args.isEmpty()) {
+        printUsage(System.out);
+      } else {
+        for (String arg : args) printUsage(System.out, arg);
+      }
+    }
+  } 
-    String help = "-help [cmd]: \tDisplays help for given command or all commands if none\n" +
-      "\t\tis specified.\n";
+  /**
+   * Displays short usage of commands sans the long description
+   */
+  protected class Help extends FsCommand {
+    public static final String NAME = "help";
+    public static final String USAGE = "[cmd ...]";
+    public static final String DESCRIPTION =
+      "Displays help for given command or all commands if none\n" +
+      "is specified.";
+    
+    @Override
+    protected void processRawArguments(LinkedList<String> args) {
+      if (args.isEmpty()) {
+        printHelp(System.out);
+      } else {
+        for (String arg : args) printHelp(System.out, arg);
+      }
+    }
+  }
-    Command instance = commandFactory.getInstance("-" + cmd);
-    if (instance != null) {
-      printHelp(instance);
-    } else if ("fs".equals(cmd)) {
-      System.out.println(fs);
-    } else if ("conf".equals(cmd)) {
-      System.out.println(conf);
-    } else if ("D".equals(cmd)) {
-      System.out.println(D);
-    } else if ("help".equals(cmd)) {
-      System.out.println(help);
+  /*
+   * The following are helper methods for getInfo().  They are defined
+   * outside of the scope of the Help/Usage class because the run() method
+   * needs to invoke them too. 
+   */
+
+  // print all usages
+  private void printUsage(PrintStream out) {
+    printInfo(out, null, false);
+  }
+  
+  // print one usage
+  private void printUsage(PrintStream out, String cmd) {
+    printInfo(out, cmd, false);
+  }
+
+  // print all helps
+  private void printHelp(PrintStream out) {
+    printInfo(out, null, true);
+  }
+
+  // print one help
+  private void printHelp(PrintStream out, String cmd) {
+    printInfo(out, cmd, true);
+  }
+
+  private void printInfo(PrintStream out, String cmd, boolean showHelp) {
+    if (cmd != null) {
+      // display help or usage for one command
+      Command instance = commandFactory.getInstance("-" + cmd);
+      if (instance == null) {
+        throw new UnknownCommandException(cmd);
+      }
+      if (showHelp) {
+        printInstanceHelp(out, instance);
+      } else {
+        printInstanceUsage(out, instance);
+      }
-      System.out.println(summary);
-      for (String thisCmdName : commandFactory.getNames()) {
-        instance = commandFactory.getInstance(thisCmdName);
+      // display help or usage for all commands 
+      out.println(usagePrefix);
+      
+      // display list of short usages
+      ArrayList<Command> instances = new ArrayList<Command>();
+      for (String name : commandFactory.getNames()) {
+        Command instance = commandFactory.getInstance(name);
+          instances.add(instance);
-      System.out.println("\t[-help [cmd]]\n");
-      
-      System.out.println(fs);
+      // display long descriptions for each command
+      if (showHelp) {
+        for (Command instance : instances) {
+          out.println();
+          printInstanceHelp(out, instance);
+        }
+      }
+      out.println();
+      ToolRunner.printGenericCommandUsage(out);
+    }
+  }
-      for (String thisCmdName : commandFactory.getNames()) {
-        instance = commandFactory.getInstance(thisCmdName);
-        if (!instance.isDeprecated()) {
-          printHelp(instance);
-        }
-      }
-      System.out.println(help);
-    }        
+  private void printInstanceUsage(PrintStream out, Command instance) {
+    out.println(usagePrefix + " " + instance.getUsage());
-  private void printHelp(Command instance) {
+  private void printInstanceHelp(PrintStream out, Command instance) {
-  
-  /**
-   * Displays format of commands.
-   * 
-   */
-  private void printUsage(String cmd) {
-    String prefix = "Usage: java " + FsShell.class.getSimpleName();
-
-    Command instance = commandFactory.getInstance(cmd);
-    if (instance != null) {
-      System.err.println(prefix + " [" + instance.getUsage() + "]");
-    } else if ("-fs".equals(cmd)) {
-      System.err.println("Usage: java FsShell" + 
-                         " [-fs <local | file system URI>]");
-    } else if ("-conf".equals(cmd)) {
-      System.err.println("Usage: java FsShell" + 
-                         " [-conf <configuration file>]");
-    } else if ("-D".equals(cmd)) {
-      System.err.println("Usage: java FsShell" + 
-                         " [-D <[property=value>]");
-    } else {
-      System.err.println("Usage: java FsShell");
-      for (String name : commandFactory.getNames()) {
-        instance = commandFactory.getInstance(name);
-        if (!instance.isDeprecated()) {
-          System.err.println("           [" + instance.getUsage() + "]");
-        }
-      }
-      System.err.println("           [-help [cmd]]");
-      System.err.println();
-      ToolRunner.printGenericCommandUsage(System.err);
-    }
-  }
-    // TODO: This isn't the best place, but this class is being abused with
-    // subclasses which of course override this method.  There really needs
-    // to be a better base class for all commands
-    commandFactory.setConf(getConf());
-    commandFactory.registerCommands(FsCommand.class);
-    
-    if (argv.length < 1) {
-      printUsage(""); 
-      return -1;
-    }
+    // initialize FsShell
+    init();
-    int i = 0;
-    String cmd = argv[i++];
-    // initialize FsShell
-    try {
-      init();
-    } catch (RPC.VersionMismatch v) {
-      LOG.debug("Version mismatch", v);
-      System.err.println("Version Mismatch between client and server" +
-                         "... command aborted.");
-      return exitCode;
-    } catch (IOException e) {
-      LOG.debug("Error", e);
-      System.err.println("Bad connection to FS. Command aborted. Exception: " +
-          e.getLocalizedMessage());
-      return exitCode;
-    }
-
-    try {
-      Command instance = commandFactory.getInstance(cmd);
-      if (instance != null) {
-        exitCode = instance.run(Arrays.copyOfRange(argv, i, argv.length));
-      } else if ("-help".equals(cmd)) {
-        if (i < argv.length) {
-          printHelp(argv[i]);
-        } else {
-          printHelp("");
+    if (argv.length < 1) {
+      printUsage(System.err);
+    } else {
+      String cmd = argv[0];
+      Command instance = null;
+      try {
+        instance = commandFactory.getInstance(cmd);
+        if (instance == null) {
+          throw new UnknownCommandException();
-      } else {
-        System.err.println(cmd + ": Unknown command");
-        printUsage("");
-      }
-    } catch (Exception e) {
-      exitCode = 1;
-      LOG.debug("Error", e);
-      displayError(cmd, e);
-      if (e instanceof IllegalArgumentException) {
-        exitCode = -1;
-        printUsage(cmd);
+        exitCode = instance.run(Arrays.copyOfRange(argv, 1, argv.length));
+      } catch (IllegalArgumentException e) {
+        displayError(cmd, e.getLocalizedMessage());
+        if (instance != null) {
+          printInstanceUsage(System.err, instance);
+        }
+      } catch (Exception e) {
+        // instance.run catches IOE, so something is REALLY wrong if here
+        LOG.debug("Error", e);
+        displayError(cmd, "Fatal internal error");
+        e.printStackTrace(System.err);
-
-  // TODO: this is a quick workaround to accelerate the integration of
-  // redesigned commands.  this will be removed this once all commands are
-  // converted.  this change will avoid having to change the hdfs tests
-  // every time a command is converted to use path-based exceptions
-  private static Pattern[] fnfPatterns = {
-    Pattern.compile("File (.*) does not exist\\."),
-    Pattern.compile("File does not exist: (.*)"),
-    Pattern.compile("`(.*)': specified destination directory doest not exist")
-  };
-  private void displayError(String cmd, Exception e) {
-    String message = e.getLocalizedMessage().split("\n")[0];
-    for (Pattern pattern : fnfPatterns) {
-      Matcher matcher = pattern.matcher(message);
-      if (matcher.matches()) {
-        message = new PathNotFoundException(matcher.group(1)).getMessage();
-        break;
-      }
+  
+  private void displayError(String cmd, String message) {
+    for (String line : message.split("\n")) {
+      System.err.println(cmd.substring(1) + ": " + line);
-    System.err.println(cmd.substring(1) + ": " + message);  
+  /**
+   *  Performs any necessary cleanup
+   * @throws IOException upon error
+   */
+   * @param argv the command and its arguments
+   * @throws Exception upon error
-    FsShell shell = new FsShell();
+    FsShell shell = newShellInstance();
+
+  // TODO: this should be abstract in a base class
+  protected static FsShell newShellInstance() {
+    return new FsShell();
+  }
+  
+  /**
+   * The default ctor signals that the command being executed does not exist,
+   * while other ctor signals that a specific command does not exist.  The
+   * latter is used by commands that process other commands, ex. -usage/-help
+   */
+  @SuppressWarnings("serial")
+  static class UnknownCommandException extends IllegalArgumentException {
+    private final String cmd;    
+    UnknownCommandException() { this(null); }
+    UnknownCommandException(String cmd) { this.cmd = cmd; }
+    
+    @Override
+    public String getMessage() {
+      return ((cmd != null) ? "`"+cmd+"': " : "") + "Unknown command";
+    }
+  }

MOV26 MOV26 MOV31 UPD40 UPD40 UPD40 INS23 INS31 INS31 INS55 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS83 INS83 MOV43 INS59 INS29 MOV83 MOV42 MOV44 INS8 INS83 INS39 INS42 MOV43 INS8 UPD42 INS44 INS8 INS29 INS83 INS42 INS43 INS23 INS23 INS23 MOV31 INS29 INS83 INS42 INS43 INS23 INS23 INS23 INS31 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 MOV44 INS8 UPD42 INS44 MOV44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 MOV8 UPD42 INS44 INS83 MOV39 MOV42 MOV44 MOV44 INS8 INS29 INS83 INS83 MOV43 INS42 INS8 INS29 INS79 INS83 INS42 MOV43 INS23 INS31 INS31 INS31 INS42 INS45 INS65 INS65 INS65 MOV46 MOV21 INS25 INS43 INS42 INS25 INS65 INS65 MOV65 INS42 INS83 INS83 INS83 MOV43 INS59 INS83 INS83 INS83 MOV43 INS59 INS83 INS83 INS83 INS43 INS59 UPD83 INS39 UPD42 INS8 INS65 INS42 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS78 INS83 INS39 INS42 INS44 INS8 INS43 INS42 MOV21 INS43 INS42 INS43 INS42 MOV21 INS43 INS42 MOV21 INS43 INS42 MOV21 INS43 INS42 INS39 INS42 INS25 INS43 INS42 INS43 INS42 INS43 INS42 MOV21 INS25 MOV43 UPD42 INS70 INS65 INS65 INS65 INS65 INS41 INS65 INS42 INS45 INS83 INS83 INS43 INS59 INS42 INS8 INS42 INS44 INS8 INS78 INS83 MOV43 INS42 INS8 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS42 INS66 INS8 INS27 INS8 INS42 MOV32 INS8 INS66 INS42 INS66 UPD66 INS42 INS45 INS42 INS45 INS42 INS42 INS27 UPD42 INS74 INS42 INS25 INS66 INS42 UPD42 MOV42 INS45 INS42 UPD42 MOV42 UPD45 MOV45 INS42 UPD42 MOV42 MOV27 INS42 INS74 INS42 INS25 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS27 INS8 MOV8 INS42 INS42 INS42 MOV27 MOV8 INS8 INS44 INS32 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS43 MOV14 INS66 INS66 INS66 UPD42 MOV42 UPD42 MOV42 INS17 INS43 INS42 INS21 INS42 INS41 INS68 INS68 MOV21 INS42 INS33 MOV21 MOV21 MOV21 INS21 INS32 INS42 MOV21 INS45 INS45 INS43 MOV43 INS32 INS8 INS8 UPD45 UPD45 INS43 MOV43 MOV32 MOV8 INS8 UPD42 UPD42 INS33 INS9 UPD42 UPD42 INS42 INS9 UPD42 UPD42 INS33 INS9 UPD42 UPD42 INS42 INS9 INS42 INS33 MOV60 INS25 INS25 INS60 MOV70 INS25 INS42 MOV60 MOV60 INS54 MOV43 INS42 UPD42 MOV42 MOV42 MOV45 MOV21 INS42 INS32 INS33 INS42 INS7 INS27 INS42 INS69 INS42 INS69 INS32 INS32 INS32 INS52 UPD42 MOV42 INS42 INS42 INS42 INS21 INS70 INS42 UPD42 UPD42 INS70 UPD27 MOV27 INS8 INS42 MOV8 MOV8 INS74 INS59 MOV44 INS42 INS8 UPD42 UPD45 MOV43 MOV43 INS8 INS12 MOV12 INS42 INS22 UPD42 MOV42 INS36 INS45 INS43 INS5 INS42 INS42 INS14 INS45 INS42 INS42 INS14 INS45 INS42 INS42 UPD42 INS32 MOV44 INS42 INS21 MOV44 INS42 INS21 INS53 INS42 INS42 INS43 INS43 INS42 INS14 INS60 INS70 INS42 INS42 INS40 UPD42 INS2 INS42 INS33 MOV21 INS25 MOV21 INS44 INS8 INS52 INS42 INS16 INS42 MOV43 INS85 MOV32 INS43 INS43 INS42 INS40 UPD42 INS32 INS42 UPD42 MOV32 INS14 UPD42 MOV42 INS42 INS74 INS42 MOV43 INS59 INS44 INS42 INS8 INS42 INS34 INS7 INS27 INS8 INS43 INS42 MOV21 MOV25 MOV21 MOV21 UPD42 INS36 INS27 INS45 INS42 INS42 UPD42 MOV42 INS40 UPD42 MOV42 INS42 UPD42 INS43 INS42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS43 INS43 INS42 INS42 MOV32 INS21 INS43 INS42 MOV21 MOV21 INS42 MOV32 INS42 INS33 INS53 INS42 MOV27 INS27 INS45 INS42 INS45 INS42 INS42 INS42 MOV42 MOV42 INS32 INS42 INS32 INS14 UPD42 INS42 MOV32 INS45 UPD42 UPD42 INS40 INS42 INS33 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 INS43 INS34 UPD42 MOV42 UPD42 INS40 INS42 DEL40 DEL26 DEL40 DEL26 DEL8 DEL31 DEL42 DEL33 DEL7 DEL42 DEL33 DEL7 DEL8 DEL66 DEL40 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL32 DEL41 DEL8 DEL45 DEL42 DEL42 DEL42 DEL40 DEL40 DEL40 DEL66 DEL40 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL45 DEL45 DEL45 DEL45 DEL45 DEL27 DEL59 DEL60 DEL42 DEL45 DEL59 DEL60 DEL59 DEL60 DEL42 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL27 DEL59 DEL60 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL45 DEL42 DEL42 DEL32 DEL8 DEL45 DEL42 DEL42 DEL32 DEL8 DEL40 DEL42 DEL42 DEL32 DEL21 DEL40 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL38 DEL8 DEL25 DEL8 DEL70 DEL40 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL25 DEL25 DEL25 DEL8 DEL31 DEL66 DEL65 DEL29 DEL40 DEL45 DEL45 DEL27 DEL40 DEL45 DEL45 DEL27 DEL40 DEL45 DEL42 DEL32 DEL7 DEL21 DEL40 DEL42 DEL45 DEL32 DEL45 DEL27 DEL32 DEL40 DEL45 DEL42 DEL42 DEL32 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL38 DEL8 DEL25 DEL8 DEL70 DEL40 DEL40 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL42 DEL32 DEL40 DEL42 DEL45 DEL45 DEL27 DEL32 DEL21 DEL8 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL25 DEL25 DEL25 DEL25 DEL8 DEL40 DEL45 DEL42 DEL42 DEL32 DEL21 DEL25 DEL45 DEL34 DEL38 DEL41 DEL39 DEL34 DEL42 DEL42 DEL42 DEL37 DEL2 DEL42 DEL42 DEL45 DEL42 DEL32 DEL42 DEL40 DEL45 DEL27 DEL42 DEL40 DEL27 DEL42 DEL42 DEL2 DEL42 DEL45 DEL32 DEL21 DEL8 DEL42 DEL34 DEL7 DEL21 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL42 DEL62 DEL42 DEL34 DEL38 DEL7 DEL21 DEL8 DEL25 DEL8 DEL40 DEL43 DEL42 DEL44 DEL40 DEL42 DEL45 DEL45 DEL27 DEL32 DEL21 DEL42 DEL41 DEL8 DEL12 DEL43 DEL42 DEL44 DEL42 DEL41 DEL8 DEL12 DEL54 DEL42 DEL59 DEL60 DEL8 DEL45 DEL42 DEL42 DEL32 DEL8 DEL40 DEL42 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL54 DEL42 DEL43 DEL83 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL32 DEL4 DEL59 DEL23 DEL83 DEL42 DEL42 DEL32 DEL32 DEL34 DEL2 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL34 DEL32 DEL14 DEL42 DEL32 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL70 DEL8 DEL31
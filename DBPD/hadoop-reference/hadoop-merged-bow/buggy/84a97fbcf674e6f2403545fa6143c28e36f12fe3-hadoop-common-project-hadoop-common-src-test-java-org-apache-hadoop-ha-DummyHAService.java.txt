HADOOP-8218. RPC.closeProxy shouldn't throw error when closing a mock. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1306164 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.Closeable;
-    return Mockito.spy(new HAServiceProtocol() {
-      @Override
-      public void monitorHealth() throws HealthCheckFailedException,
-          AccessControlException, IOException {
-        checkUnreachable();
-        if (!isHealthy) {
-          throw new HealthCheckFailedException("not healthy");
-        }
-      }
-
-      @Override
-      public void transitionToActive() throws ServiceFailedException,
-          AccessControlException, IOException {
-        checkUnreachable();
-        if (failToBecomeActive) {
-          throw new ServiceFailedException("injected failure");
-        }
-
-        state = HAServiceState.ACTIVE;
-      }
-
-      @Override
-      public void transitionToStandby() throws ServiceFailedException,
-          AccessControlException, IOException {
-        checkUnreachable();
-        state = HAServiceState.STANDBY;
-      }
-
-      @Override
-      public HAServiceStatus getServiceStatus() throws IOException {
-        checkUnreachable();
-        HAServiceStatus ret = new HAServiceStatus(state);
-        if (state == HAServiceState.STANDBY) {
-          ret.setReadyToBecomeActive();
-        }
-        return ret;
-      }
-
-      private void checkUnreachable() throws IOException {
-        if (actUnreachable) {
-          throw new IOException("Connection refused (fake)");
-        }
-      }
-    });
+    return Mockito.spy(new MockHAProtocolImpl());
+  
+  private class MockHAProtocolImpl implements
+      HAServiceProtocol, Closeable {
+    @Override
+    public void monitorHealth() throws HealthCheckFailedException,
+        AccessControlException, IOException {
+      checkUnreachable();
+      if (!isHealthy) {
+        throw new HealthCheckFailedException("not healthy");
+      }
+    }
+    
+    @Override
+    public void transitionToActive() throws ServiceFailedException,
+        AccessControlException, IOException {
+      checkUnreachable();
+      if (failToBecomeActive) {
+        throw new ServiceFailedException("injected failure");
+      }
+    
+      state = HAServiceState.ACTIVE;
+    }
+    
+    @Override
+    public void transitionToStandby() throws ServiceFailedException,
+        AccessControlException, IOException {
+      checkUnreachable();
+      state = HAServiceState.STANDBY;
+    }
+    
+    @Override
+    public HAServiceStatus getServiceStatus() throws IOException {
+      checkUnreachable();
+      HAServiceStatus ret = new HAServiceStatus(state);
+      if (state == HAServiceState.STANDBY) {
+        ret.setReadyToBecomeActive();
+      }
+      return ret;
+    }
+    
+    private void checkUnreachable() throws IOException {
+      if (actUnreachable) {
+        throw new IOException("Connection refused (fake)");
+      }
+    }
+    
+    @Override
+    public void close() throws IOException {
+    }
+  }

INS26 INS40 INS55 INS83 INS42 MOV43 INS43 MOV31 MOV31 MOV31 MOV31 MOV31 INS31 INS42 INS78 INS83 INS39 INS42 INS43 INS8 INS42 INS42 INS43 INS42 DEL1
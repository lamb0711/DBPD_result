HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.

-import org.apache.commons.io.output.ByteArrayOutputStream;
+import org.apache.commons.lang.NotImplementedException;
+import com.microsoft.windowsazure.storage.blob.CloudBlob;
+import com.microsoft.windowsazure.storage.blob.PageRange;
+
+import javax.ws.rs.core.UriBuilder;
+import javax.ws.rs.core.UriBuilderException;
-  private final ArrayList<PreExistingContainer> preExistingContainers = new ArrayList<MockStorageInterface.PreExistingContainer>();
+  private final ArrayList<PreExistingContainer> preExistingContainers =
+      new ArrayList<MockStorageInterface.PreExistingContainer>();
+  /**
+   * Utility function used to convert a given URI to a decoded string
+   * representation sent to the backing store. URIs coming as input
+   * to this class will be encoded by the URI class, and we want
+   * the underlying storage to store keys in their original UTF-8 form.
+   */
+  private static String convertUriToDecodedString(URI uri) {
+    try {
+      String result = URIUtil.decode(uri.toString());
+      return result;
+    } catch (URIException e) {
+      throw new AssertionError("Failed to decode URI: " + uri.toString());
+    }
+  }
+
+  private static URI convertKeyToEncodedUri(String key) {
+    try {
+      String encodedKey = URIUtil.encodePath(key);
+      URI uri = new URI(encodedKey);
+      return uri;
+    } catch (URISyntaxException e) {
+      throw new AssertionError("Failed to encode key: " + key);
+    } catch (URIException e) {
+      throw new AssertionError("Failed to encode key: " + key);
+    }
+  }
+
+    @Override
+    public CloudPageBlobWrapper getPageBlobReference(String blobAddressUri)
+        throws URISyntaxException, StorageException {
+      return new MockCloudPageBlobWrapper(new URI(blobAddressUri), null, 0);
+    }
+
-      String fullPrefix = prefix == null ? uri.toString() : new URI(
-          uri.getScheme(), uri.getAuthority(), uri.getPath() + prefix,
-          uri.getQuery(), uri.getFragment()).toString();
-      boolean includeMetadata = listingDetails
-          .contains(BlobListingDetails.METADATA);
+      URI searchUri = null;
+      if (prefix == null) {
+        searchUri = uri;
+      } else {
+        try {
+          searchUri = UriBuilder.fromUri(uri).path(prefix).build();
+        } catch (UriBuilderException e) {
+          throw new AssertionError("Failed to encode path: " + prefix);
+        }
+      }
+
+      String fullPrefix = convertUriToDecodedString(searchUri);
+      boolean includeMetadata = listingDetails.contains(BlobListingDetails.METADATA);
-      for (InMemoryBlockBlobStore.ListBlobEntry current : backingStore
-          .listBlobs(fullPrefix, includeMetadata)) {
+      for (InMemoryBlockBlobStore.ListBlobEntry current : backingStore.listBlobs(
+          fullPrefix, includeMetadata)) {
-          ret.add(new MockCloudBlockBlobWrapper(new URI(current.getKey()),
-              current.getMetadata(), current.getContentLength()));
+          if (current.isPageBlob()) {
+            ret.add(new MockCloudPageBlobWrapper(
+                convertKeyToEncodedUri(current.getKey()),
+                current.getMetadata(),
+                current.getContentLength()));
+          } else {
+          ret.add(new MockCloudBlockBlobWrapper(
+              convertKeyToEncodedUri(current.getKey()),
+              current.getMetadata(),
+              current.getContentLength()));
+          }
-            ret.add(new MockCloudBlobDirectoryWrapper(new URI(directoryName
-                + "/")));
+            ret.add(new MockCloudBlobDirectoryWrapper(new URI(
+                directoryName + "/")));
-      throw new UnsupportedOperationException();
+      throw new NotImplementedException();
-
-  class MockCloudBlockBlobWrapper extends CloudBlockBlobWrapper {
-    private URI uri;
-    private HashMap<String, String> metadata = new HashMap<String, String>();
-    private BlobProperties properties;
+  abstract class MockCloudBlobWrapper implements CloudBlobWrapper {
+    protected final URI uri;
+    protected HashMap<String, String> metadata =
+        new HashMap<String, String>();
+    protected BlobProperties properties;
-    public MockCloudBlockBlobWrapper(URI uri, HashMap<String, String> metadata,
+    protected MockCloudBlobWrapper(URI uri, HashMap<String, String> metadata,
-      this.properties.setLastModified(Calendar.getInstance(
-          TimeZone.getTimeZone("UTC")).getTime());
+      this.properties.setLastModified(
+          Calendar.getInstance(TimeZone.getTimeZone("UTC")).getTime());
-    private void refreshProperties(boolean getMetadata) {
-      if (backingStore.exists(uri.toString())) {
-        byte[] content = backingStore.getContent(uri.toString());
+    protected void refreshProperties(boolean getMetadata) {
+      if (backingStore.exists(convertUriToDecodedString(uri))) {
+        byte[] content = backingStore.getContent(convertUriToDecodedString(uri));
-        properties.setLastModified(Calendar.getInstance(
-            TimeZone.getTimeZone("UTC")).getTime());
+        properties.setLastModified(
+            Calendar.getInstance(TimeZone.getTimeZone("UTC")).getTime());
-          metadata = backingStore.getMetadata(uri.toString());
+          metadata = backingStore.getMetadata(convertUriToDecodedString(uri));
-    public void startCopyFromBlob(CloudBlockBlobWrapper sourceBlob,
+    public void startCopyFromBlob(URI source,
-      backingStore.copy(sourceBlob.getUri().toString(), uri.toString());
-      // it would be best if backingStore.properties.CopyState were tracked
-      // If implemented, update azureNativeFileSystemStore.waitForCopyToComplete
+      backingStore.copy(convertUriToDecodedString(source), convertUriToDecodedString(uri));
+      //TODO: set the backingStore.properties.CopyState and
+      //      update azureNativeFileSystemStore.waitForCopyToComplete
-      return this.properties.getCopyState();
+       return this.properties.getCopyState();
-    public void delete(OperationContext opContext) throws StorageException {
-      backingStore.delete(uri.toString());
+    public void delete(OperationContext opContext, SelfRenewingLease lease)
+        throws StorageException {
+      backingStore.delete(convertUriToDecodedString(uri));
-      return backingStore.exists(uri.toString());
+      return backingStore.exists(convertUriToDecodedString(uri));
-      return new ByteArrayInputStream(backingStore.getContent(uri.toString()));
-    }
-
-    @Override
-    public OutputStream openOutputStream(BlobRequestOptions options,
-        OperationContext opContext) throws StorageException {
-      return backingStore.upload(uri.toString(), metadata);
-    }
-
-    @Override
-    public void upload(InputStream sourceStream, OperationContext opContext)
-        throws StorageException, IOException {
-      ByteArrayOutputStream allContent = new ByteArrayOutputStream();
-      allContent.write(sourceStream);
-      backingStore.setContent(uri.toString(), allContent.toByteArray(),
-          metadata);
-      refreshProperties(false);
-      allContent.close();
+      return new ByteArrayInputStream(
+          backingStore.getContent(convertUriToDecodedString(uri)));
-      backingStore.setContent(uri.toString(),
-          backingStore.getContent(uri.toString()), metadata);
+      backingStore.setMetadata(convertUriToDecodedString(uri), metadata);
-    public void uploadProperties(OperationContext opContext)
+    public void downloadRange(long offset, long length, OutputStream os,
+        BlobRequestOptions options, OperationContext opContext)
-      refreshProperties(false);
+      throw new NotImplementedException();
+    }
+  }
+
+  class MockCloudBlockBlobWrapper extends MockCloudBlobWrapper
+    implements CloudBlockBlobWrapper {
+    public MockCloudBlockBlobWrapper(URI uri, HashMap<String, String> metadata,
+        int length) {
+      super(uri, metadata, length);
+    }
+
+    @Override
+    public OutputStream openOutputStream(BlobRequestOptions options,
+        OperationContext opContext) throws StorageException {
+      return backingStore.uploadBlockBlob(convertUriToDecodedString(uri),
+          metadata);
+    }
+
+    @Override
+    public void setStreamMinimumReadSizeInBytes(int minimumReadSizeBytes) {
+    }
+
+    @Override
+    public void setWriteBlockSizeInBytes(int writeBlockSizeBytes) {
+    }
+
+    @Override
+    public StorageUri getStorageUri() {
+      return null;
+    }
+
+    @Override
+    public void uploadProperties(OperationContext context, SelfRenewingLease lease) {
+    }
+
+    @Override
+    public SelfRenewingLease acquireLease() {
+      return null;
+    }
+
+    @Override
+    public CloudBlob getBlob() {
+      return null;
+    }
+  }
+
+  class MockCloudPageBlobWrapper extends MockCloudBlobWrapper
+    implements CloudPageBlobWrapper {
+    public MockCloudPageBlobWrapper(URI uri, HashMap<String, String> metadata,
+        int length) {
+      super(uri, metadata, length);
+    }
+
+    @Override
+    public void create(long length, BlobRequestOptions options,
+        OperationContext opContext) throws StorageException {
+      throw new NotImplementedException();
+    }
+
+    @Override
+    public void uploadPages(InputStream sourceStream, long offset, long length,
+        BlobRequestOptions options, OperationContext opContext)
+        throws StorageException, IOException {
+      throw new NotImplementedException();
+    }
+
+    @Override
+    public ArrayList<PageRange> downloadPageRanges(BlobRequestOptions options,
+        OperationContext opContext) throws StorageException {
+      throw new NotImplementedException();
-      throw new UnsupportedOperationException();
+        throw new NotImplementedException();
+    @Override
+    public void uploadProperties(OperationContext opContext,
+        SelfRenewingLease lease)
+        throws StorageException {
+    }
+
+    @Override
+    public SelfRenewingLease acquireLease() {
+      return null;
+    }
+
+    @Override
+    public CloudBlob getBlob() {
+      return null;
+    }

INS26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS40 INS31 INS31 INS55 INS55 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS43 INS42 INS44 INS8 INS31 INS83 UPD42 INS43 INS31 INS42 INS43 MOV43 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 INS43 INS43 INS31 INS31 INS31 INS31 MOV31 MOV31 INS31 INS31 INS31 INS31 INS65 INS42 INS43 INS42 INS54 INS42 INS43 INS42 INS54 INS78 INS83 INS43 INS42 INS44 INS43 INS43 INS8 MOV78 INS42 UPD83 INS83 UPD83 UPD83 UPD83 UPD42 UPD83 MOV78 MOV44 MOV43 MOV78 MOV44 INS44 MOV43 MOV78 MOV44 MOV43 MOV78 UPD42 MOV44 MOV43 MOV78 MOV83 MOV39 UPD42 MOV42 INS44 INS44 INS44 INS44 INS44 INS43 MOV8 INS42 INS83 INS42 INS44 INS44 INS44 INS8 MOV78 INS83 MOV43 INS42 MOV44 MOV44 MOV43 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 MOV43 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS42 INS42 INS83 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 MOV78 INS83 INS39 INS42 MOV44 INS44 INS44 INS44 MOV44 MOV43 MOV43 INS8 INS78 INS83 INS74 INS42 INS44 INS44 MOV43 INS8 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS39 INS42 MOV44 INS44 INS43 INS8 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS66 INS66 INS66 INS66 INS42 INS8 INS12 INS42 INS8 INS12 INS12 INS42 INS42 MOV43 INS42 INS42 INS42 INS41 INS60 INS25 INS60 UPD43 UPD42 INS43 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS43 INS42 INS74 INS42 INS39 INS42 INS46 INS41 INS42 INS39 INS42 INS42 INS39 INS42 INS42 INS41 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS41 INS42 INS42 INS41 INS43 INS42 INS74 INS42 INS39 INS42 INS46 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS42 INS53 INS39 INS42 INS39 INS42 INS43 INS42 INS53 INS42 INS43 INS43 INS43 INS42 INS43 INS42 INS53 INS42 INS42 INS53 INS42 INS43 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS41 INS60 INS41 INS44 INS8 INS60 INS60 INS41 INS44 INS8 INS44 INS8 INS14 MOV43 INS59 MOV27 INS8 INS8 INS43 INS59 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS32 INS33 INS42 INS42 INS33 INS33 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS42 INS14 INS14 INS42 INS33 INS33 INS43 INS59 INS42 INS43 INS42 INS53 INS43 INS59 INS43 INS59 INS42 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS14 INS33 INS34 INS42 INS33 INS21 INS54 INS42 INS42 INS32 UPD43 INS42 INS42 INS32 MOV32 INS32 UPD42 UPD43 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS42 MOV32 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS14 INS42 INS14 INS42 MOV43 INS42 INS7 INS8 INS12 INS42 INS42 INS8 UPD42 INS42 INS42 UPD42 UPD42 UPD42 MOV42 MOV42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS43 INS27 INS42 INS42 INS42 INS43 INS42 INS43 INS27 INS43 INS27 INS42 INS42 INS21 INS44 INS8 INS25 INS42 INS42 INS45 MOV32 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS7 INS43 INS42 INS53 INS32 INS8 MOV8 INS42 INS32 INS42 INS14 INS42 INS42 INS21 INS42 INS32 UPD42 MOV42 INS43 INS27 INS32 INS32 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS42 INS14 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 INS43 INS32 INS32 INS32 INS32 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL42 DEL27 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL42 DEL32 DEL16 DEL59 DEL60 DEL14 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL31 DEL83 DEL42 DEL31
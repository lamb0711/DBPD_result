HDFS-11210. Enhance key rolling to guarantee new KeyVersion is returned from generateEncryptedKeys after a key is rolled.

-      "   [" + ListCommand.USAGE + "]\n";
+      "   [" + ListCommand.USAGE + "]\n" +
+      "   [" + InvalidateCacheCommand.USAGE + "]\n";
+   * % hadoop key invalidateCache keyName [-provider providerPath]
+      } else if ("invalidateCache".equals(args[i])) {
+        String keyName = "-help";
+        if (moreTokens) {
+          keyName = args[++i];
+        }
+        setSubCommand(new InvalidateCacheCommand(keyName));
+        if ("-help".equals(keyName)) {
+          return 1;
+        }
+    sbuf.append(banner + "\n");
+    sbuf.append(InvalidateCacheCommand.USAGE + ":\n\n"
+        + InvalidateCacheCommand.DESC + "\n");
+  private class InvalidateCacheCommand extends Command {
+    public static final String USAGE =
+        "invalidateCache <keyname> [-provider <provider>] [-help]";
+    public static final String DESC =
+        "The invalidateCache subcommand invalidates the cached key versions\n"
+            + "of the specified key, on the provider indicated using the"
+            + " -provider argument.\n";
+
+    private String keyName = null;
+
+    InvalidateCacheCommand(String keyName) {
+      this.keyName = keyName;
+    }
+
+    public boolean validate() {
+      boolean rc = true;
+      provider = getKeyProvider();
+      if (provider == null) {
+        getOut().println("Invalid provider.");
+        rc = false;
+      }
+      if (keyName == null) {
+        getOut().println("Please provide a <keyname>.\n" +
+            "See the usage description by using -help.");
+        rc = false;
+      }
+      return rc;
+    }
+
+    public void execute() throws NoSuchAlgorithmException, IOException {
+      try {
+        warnIfTransientProvider();
+        getOut().println("Invalidating cache on KeyProvider: "
+            + provider + "\n  for key name: " + keyName);
+        provider.invalidateCache(keyName);
+        getOut().println("Cached keyversions of " + keyName
+            + " has been successfully invalidated.");
+        printProviderWritten();
+      } catch (IOException e) {
+        getOut().println("Cannot invalidate cache for key: " + keyName +
+            " within KeyProvider: " + provider + ". " + e.toString());
+        throw e;
+      }
+    }
+
+    @Override
+    public String getUsage() {
+      return USAGE + ":\n\n" + DESC;
+    }
+  }
+

INS55 INS83 INS42 INS43 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS21 INS21 INS42 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS43 INS43 INS8 INS78 INS83 INS43 INS42 INS8 INS45 INS40 INS45 INS66 INS32 INS32 INS42 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS33 INS43 INS42 INS21 INS60 INS21 INS25 INS25 INS41 INS42 INS42 INS54 INS42 INS42 INS41 INS42 INS42 INS27 INS42 INS42 INS27 INS45 INS45 INS45 INS42 INS7 INS39 INS59 INS7 INS27 INS8 INS27 INS8 INS42 INS8 INS12 INS27 INS42 INS45 INS40 INS45 INS40 INS45 INS22 INS42 INS42 INS9 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS33 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS44 INS8 INS42 INS45 INS42 INS52 INS42 INS42 INS32 INS7 INS32 INS7 INS32 INS32 INS32 INS32 INS32 INS43 INS42 INS21 INS53 INS32 INS42 INS45 INS42 INS9 INS32 INS42 INS27 INS42 INS9 INS42 INS32 INS42 INS27 INS42 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS32 INS42 INS25 INS42 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS45 INS42 INS45 INS32 INS42 INS27 INS32 INS8 MOV25 INS42 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS2 INS60 INS25 INS21 INS25 INS42 INS42 INS42 INS42 INS43 INS59 INS42 INS8 INS32 INS32 INS8 INS42 INS42 INS45 INS21 INS42 INS14 INS45 INS42 INS42 INS41 INS7 INS43 INS42 INS34 INS42 INS2 INS42 INS42 INS38 INS42
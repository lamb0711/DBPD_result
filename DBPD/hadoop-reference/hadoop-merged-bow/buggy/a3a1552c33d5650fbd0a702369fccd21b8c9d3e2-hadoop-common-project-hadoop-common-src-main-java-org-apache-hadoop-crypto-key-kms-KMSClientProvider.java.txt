Revert "HADOOP-14445. Delegation tokens are not shared between KMS instances. Contributed by Xiao Chen and Rushabh S Shah."

This reverts commit 583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81.

 Conflicts:
	hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSTokenRenewer.java
	hadoop-common-project/hadoop-kms/src/test/java/org/apache/hadoop/crypto/key/kms/server/TestKMS.java

-import org.apache.hadoop.security.token.TokenSelector;
+import org.apache.hadoop.security.token.TokenRenewer;
-import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenSelector;
-import static org.apache.hadoop.fs.CommonConfigurationKeysPublic.KMS_CLIENT_COPY_LEGACY_TOKEN_KEY;
-import static org.apache.hadoop.fs.CommonConfigurationKeysPublic.KMS_CLIENT_COPY_LEGACY_TOKEN_DEFAULT;
-  public static final Logger LOG =
+  private static final Logger LOG =
+  public static final String TOKEN_KIND_STR = KMSDelegationToken.TOKEN_KIND_STR;
+  public static final Text TOKEN_KIND = KMSDelegationToken.TOKEN_KIND;
+
-  /* dtService defines the token service value for the kms token.
-   * The value can be legacy format which is ip:port format or it can be uri.
-   * If it's uri format, then the value is read from
-   * CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH at key
-   * provider creation time, and set to token's Service field.
-   * When a token is renewed / canceled, its Service field will be used to
-   * instantiate a KeyProvider, eliminating the need to read configs
-    * at that time.
-   */
-  private final boolean copyLegacyToken;
+
+  // Allow fallback to default kms server port 9600 for certain tests that do
+  // not specify the port explicitly in the kms provider url.
+  @VisibleForTesting
+  public static volatile boolean fallbackDefaultPortForTesting = false;
+  /**
+   * The KMS implementation of {@link TokenRenewer}.
+   */
+  public static class KMSTokenRenewer extends TokenRenewer {
+    private static final Logger LOG =
+        LoggerFactory.getLogger(KMSTokenRenewer.class);
+
+    @Override
+    public boolean handleKind(Text kind) {
+      return kind.equals(TOKEN_KIND);
+    }
+
+    @Override
+    public boolean isManaged(Token<?> token) throws IOException {
+      return true;
+    }
+
+    @Override
+    public long renew(Token<?> token, Configuration conf) throws IOException {
+      LOG.debug("Renewing delegation token {}", token);
+      KeyProvider keyProvider = KMSUtil.createKeyProvider(conf,
+          KeyProviderFactory.KEY_PROVIDER_PATH);
+      try {
+        if (!(keyProvider instanceof
+            KeyProviderDelegationTokenExtension.DelegationTokenExtension)) {
+          throw new IOException(String
+              .format("keyProvider %s cannot renew token [%s]",
+                  keyProvider == null ? "null" : keyProvider.getClass(),
+                  token));
+        }
+        return ((KeyProviderDelegationTokenExtension.DelegationTokenExtension)
+            keyProvider).renewDelegationToken(token);
+      } finally {
+        if (keyProvider != null) {
+          keyProvider.close();
+        }
+      }
+    }
+
+    @Override
+    public void cancel(Token<?> token, Configuration conf) throws IOException {
+      LOG.debug("Canceling delegation token {}", token);
+      KeyProvider keyProvider = KMSUtil.createKeyProvider(conf,
+          KeyProviderFactory.KEY_PROVIDER_PATH);
+      try {
+        if (!(keyProvider instanceof
+            KeyProviderDelegationTokenExtension.DelegationTokenExtension)) {
+          throw new IOException(String
+              .format("keyProvider %s cannot cancel token [%s]",
+                  keyProvider == null ? "null" : keyProvider.getClass(),
+                  token));
+        }
+        ((KeyProviderDelegationTokenExtension.DelegationTokenExtension)
+            keyProvider).cancelDelegationToken(token);
+      } finally {
+        if (keyProvider != null) {
+          keyProvider.close();
+        }
+      }
+    }
+  }
+
-        return createProvider(conf, origUrl, port, hostsPart, providerUri);
+        return createProvider(conf, origUrl, port, hostsPart);
-    private KeyProvider createProvider(Configuration conf, URL origUrl,
-        int port, String hostsPart, URI providerUri) throws IOException {
+    private KeyProvider createProvider(Configuration conf,
+        URL origUrl, int port, String hostsPart) throws IOException {
-                      origUrl.getPath(), null, null), conf, providerUri);
+                      origUrl.getPath(), null, null), conf);
-  public KMSClientProvider(URI uri, Configuration conf, URI providerUri) throws
-      IOException {
+  public KMSClientProvider(URI uri, Configuration conf) throws IOException {
+    int kmsPort = kmsUrl.getPort();
+    if ((kmsPort == -1) && fallbackDefaultPortForTesting) {
+      kmsPort = 9600;
+    }
+
+    InetSocketAddress addr = new InetSocketAddress(kmsUrl.getHost(), kmsPort);
+    dtService = SecurityUtil.buildTokenService(addr);
+
-    copyLegacyToken = conf.getBoolean(KMS_CLIENT_COPY_LEGACY_TOKEN_KEY,
-        KMS_CLIENT_COPY_LEGACY_TOKEN_DEFAULT);
-
-    dtService = new Text(providerUri.toString());
-              createKMSAuthenticatedURL();
+              new DelegationTokenAuthenticatedURL(configurator);
-          createKMSAuthenticatedURL();
+          new DelegationTokenAuthenticatedURL(configurator);
-                  createKMSAuthenticatedURL();
+                  new DelegationTokenAuthenticatedURL(configurator);
-  @VisibleForTesting
-  DelegationTokenAuthenticatedURL createKMSAuthenticatedURL() {
-    return new DelegationTokenAuthenticatedURL(configurator) {
-      @Override
-      public org.apache.hadoop.security.token.Token<? extends TokenIdentifier>
-          getDelegationToken(URL url, Credentials creds) {
-        return selectKMSDelegationToken(creds);
-      }
-    };
-  }
-
-          createKMSAuthenticatedURL();
+          new DelegationTokenAuthenticatedURL(configurator);
-          if (KMSDelegationToken.TOKEN_KIND.equals(token.getKind())) {
-            // do not set service for legacy kind, for compatibility.
-            token.setService(dtService);
-          }
-          LOG.info("New token created: ({})", token);
+          LOG.debug("New token received: ({})", token);
-          Token<?> legacyToken = createAndAddLegacyToken(credentials, token);
-          tokens = legacyToken == null ?
-              new Token<?>[] {token} :
-              new Token<?>[] {token, legacyToken};
+          tokens = new Token<?>[] { token };
-  /**
-   * If {@link CommonConfigurationKeysPublic#KMS_CLIENT_COPY_LEGACY_TOKEN_KEY}
-   * is true when creating the provider, then copy the passed-in token of
-   * {@link KMSDelegationToken#TOKEN_KIND} and create a new token of
-   * {@link KMSDelegationToken#TOKEN_LEGACY_KIND}, and add it to credentials.
-   *
-   * @return The legacy token, or null if one should not be created.
-   */
-  private Token<?> createAndAddLegacyToken(Credentials credentials,
-      Token<?> token) {
-    if (!copyLegacyToken || !KMSDelegationToken.TOKEN_KIND
-        .equals(token.getKind())) {
-      LOG.debug("Not creating legacy token because copyLegacyToken={}, "
-          + "token={}", copyLegacyToken, token);
-      return null;
-    }
-    // copy a KMS_DELEGATION_TOKEN and create a new kms-dt with the same
-    // underlying token for backwards-compatibility. Old clients/renewers
-    // does not parse the new token and can only work with kms-dt.
-    final Token<?> legacyToken = token.copyToken();
-    legacyToken.setKind(KMSDelegationToken.TOKEN_LEGACY_KIND);
-    final InetSocketAddress addr =
-        new InetSocketAddress(kmsUrl.getHost(), kmsUrl.getPort());
-    final Text fallBackServiceText = SecurityUtil.buildTokenService(addr);
-    legacyToken.setService(fallBackServiceText);
-    LOG.info("Copied token to legacy kind: {}", legacyToken);
-    credentials.addToken(legacyToken.getService(), legacyToken);
-    return legacyToken;
-  }
-
-  @VisibleForTesting
-  public Text getDelegationTokenService() {
-    return dtService;
-  }
-
-  /**
-   * Given a list of tokens, return the token that should be used for KMS
-   * authentication.
-   */
-  @VisibleForTesting
-  Token selectKMSDelegationToken(Credentials creds) {
-    // always look for TOKEN_KIND first
-    final TokenSelector<AbstractDelegationTokenIdentifier> tokenSelector =
-        new AbstractDelegationTokenSelector<AbstractDelegationTokenIdentifier>(
-            KMSDelegationToken.TOKEN_KIND) {
-        };
-    Token token = tokenSelector.selectToken(dtService, creds.getAllTokens());
-    LOG.debug("Searching service {} found token {}", dtService, token);
-    if (token != null) {
-      return token;
-    }
-
-    // fall back to look for token by service, regardless of kind.
-    // this is old behavior, keeping for compatibility reasons (for example,
-    // even if KMS server is new, if the job is submitted with an old kms
-    // client, job runners on new version should be able to find the token).
-    final InetSocketAddress addr =
-        new InetSocketAddress(kmsUrl.getHost(), kmsUrl.getPort());
-    final Text fallBackServiceText = SecurityUtil.buildTokenService(addr);
-    token = creds.getToken(fallBackServiceText);
-    LOG.debug("Selected delegation token {} using service:{}", token,
-        fallBackServiceText);
-    return token;
-  }
-
-  private boolean containsKmsDt(UserGroupInformation ugi) {
-    final Credentials creds = ugi.getCredentials();
+  private boolean containsKmsDt(UserGroupInformation ugi) throws IOException {
+    // Add existing credentials from the UGI, since provider is cached.
+    Credentials creds = ugi.getCredentials();
-      final Token dToken = selectKMSDelegationToken(creds);
+      LOG.debug("Searching for token that matches service: {}", dtService);
+      org.apache.hadoop.security.token.Token<? extends TokenIdentifier>
+          dToken = creds.getToken(dtService);

MOV23 UPD40 INS23 INS23 INS55 UPD83 UPD83 INS83 INS43 INS83 INS83 INS83 MOV43 INS59 MOV78 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS31 MOV21 INS43 INS42 UPD42 INS40 INS42 INS40 INS42 INS9 INS65 UPD42 MOV42 INS83 INS83 INS83 INS43 INS59 INS78 INS83 INS39 INS42 INS44 INS8 INS78 UPD83 MOV83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 MOV78 MOV83 INS39 UPD42 MOV42 MOV44 INS44 INS43 MOV8 INS60 INS25 INS60 INS42 INS66 INS65 INS66 UPD42 MOV42 INS42 INS32 INS42 MOV43 INS42 INS41 INS42 INS74 INS42 UPD42 MOV42 MOV41 INS42 INS74 INS42 INS43 INS42 UPD42 MOV42 INS21 MOV60 INS54 INS43 INS42 UPD42 MOV42 INS21 INS54 INS39 INS59 INS27 INS8 MOV43 INS59 INS42 UPD42 MOV42 UPD42 MOV42 INS57 INS32 MOV43 MOV76 INS9 MOV43 MOV76 UPD42 MOV42 INS32 UPD43 INS8 INS8 UPD42 MOV42 INS32 UPD43 INS8 INS8 INS42 MOV32 INS36 INS42 INS21 INS42 INS14 INS32 INS21 INS60 INS43 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS45 INS42 UPD42 UPD42 INS25 INS41 INS25 INS42 INS42 INS45 INS42 UPD42 UPD42 INS25 INS21 INS25 UPD42 MOV42 UPD42 MOV42 INS27 INS7 MOV43 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 MOV43 MOV43 INS59 INS32 MOV74 MOV59 INS42 UPD42 UPD42 UPD42 INS40 INS38 INS8 INS32 INS27 INS8 UPD42 UPD42 MOV42 UPD42 MOV42 INS40 INS38 INS8 INS32 INS27 INS8 INS42 INS38 INS42 INS34 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS45 INS42 INS36 INS53 INS36 UPD42 MOV42 UPD42 MOV42 INS42 INS33 INS21 INS36 INS53 INS36 UPD42 MOV42 INS42 INS42 INS33 MOV21 INS34 MOV43 INS42 INS43 INS42 INS42 UPD42 UPD42 INS62 INS14 INS11 INS32 INS62 INS14 INS11 MOV42 INS42 INS43 INS43 INS32 INS43 INS42 INS42 INS42 INS42 INS43 INS43 INS32 INS43 INS42 UPD42 UPD42 INS40 INS42 UPD42 MOV42 UPD42 MOV42 INS45 INS16 UPD42 MOV42 INS40 INS40 INS42 UPD42 MOV42 UPD42 MOV42 INS45 INS16 UPD42 MOV42 INS40 UPD42 UPD45 MOV3 INS27 INS45 INS32 INS27 INS45 INS32 MOV43 INS42 INS33 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV33 UPD42 MOV42 UPD42 MOV42 INS42 INS14 INS14 MOV43 INS42 INS43 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL39 DEL33 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL40 DEL1 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL21 DEL27 DEL42 DEL41 DEL8 DEL25 DEL83 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL41 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL44 DEL32 DEL14 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL32 DEL41 DEL8 DEL31 DEL1 DEL14 DEL41 DEL8 DEL31 DEL42 DEL42 DEL32 DEL59 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL76 DEL74 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL16 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL65 DEL66 DEL65 DEL29 DEL74 DEL42 DEL43 DEL42 DEL44 DEL42 DEL38 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL27 DEL42 DEL42 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL83 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL83 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL45 DEL32 DEL21 DEL32 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL42 DEL78 DEL43 DEL42 DEL43 DEL42 DEL44 DEL31 DEL83 DEL83 DEL42 DEL43 DEL60
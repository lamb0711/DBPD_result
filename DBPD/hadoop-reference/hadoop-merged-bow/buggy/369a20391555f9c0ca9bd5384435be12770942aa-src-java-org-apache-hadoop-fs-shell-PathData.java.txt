HADOOP-7236. Refactor the mkdir command to conform to new FsCommand class.  Contributed by Daryn Sharp


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1099612 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.conf.Configuration;
+  protected String string = null;
-   * Creates an object to wrap the given parameters as fields.
-   * @param theFs the FileSystem
-   * @param thePath a Path
-   * @param theStat the FileStatus (may be null if the path doesn't exist)
+   * Creates an object to wrap the given parameters as fields.  The string
+   * used to create the path will be recorded since the Path object does not
+   * return exactly the same string used to initialize it
+   * @param pathString a string for a path
+   * @param conf the configuration file
+   * @throws IOException if anything goes wrong...
-  public PathData(FileSystem theFs, Path thePath, FileStatus theStat) {
-    path = thePath;
-    stat = theStat;
-    fs = theFs;
-    exists = (stat != null);
+  public PathData(String pathString, Configuration conf) throws IOException {
+    this.string = pathString;
+    this.path = new Path(pathString);
+    this.fs = path.getFileSystem(conf);
+    setStat(getStat(fs, path));
+  }
+  
+  /**
+   * Creates an object to wrap the given parameters as fields. 
+   * @param fs the FileSystem
+   * @param path a Path
+   * @param stat the FileStatus (may be null if the path doesn't exist)
+   */
+  public PathData(FileSystem fs, Path path, FileStatus stat) {
+    this.string = path.toString();
+    this.path = path;
+    this.fs = fs;
+    setStat(stat);
+  /**
+   * Creates an object to wrap the given parameters as fields.  The string
+   * used to create the path will be recorded since the Path object does not
+   * return exactly the same string used to initialize it.  If the FileStatus
+   * is not null, then its Path will be used to initialized the path, else
+   * the string of the path will be used.
+   * @param fs the FileSystem
+   * @param pathString a String of the path
+   * @param stat the FileStatus (may be null if the path doesn't exist)
+   */
+  public PathData(FileSystem fs, String pathString, FileStatus stat) {
+    this.string = pathString;
+    this.path = (stat != null) ? stat.getPath() : new Path(pathString);
+    this.fs = fs;
+    setStat(stat);
+  }
+
+  
+  private void setStat(FileStatus theStat) {
+    stat = theStat;
+    exists = (stat != null);
+  }
-    stat = fs.getFileStatus(path);
+    setStat(fs.getFileStatus(path));
-   * Returns the printable version of the path that is just the
-   * filesystem path instead of the full uri
+   * Expand the given path as a glob pattern.  Non-existent paths do not
+   * throw an exception because creation commands like touch and mkdir need
+   * to create them.  The "stat" field will be null if the path does not
+   * exist.
+   * @param pattern the pattern to expand as a glob
+   * @param conf the hadoop configuration
+   * @return list of {@link PathData} objects.  if the pattern is not a glob,
+   * and does not exist, the list will contain a single PathData with a null
+   * stat 
+   * @throws IOException anything else goes wrong...
+   */
+  public static PathData[] expandAsGlob(String pattern, Configuration conf)
+  throws IOException {
+    Path globPath = new Path(pattern);
+    FileSystem fs = globPath.getFileSystem(conf);    
+    FileStatus[] stats = fs.globStatus(globPath);
+    PathData[] items = null;
+    
+    if (stats == null) {
+      // not a glob & file not found, so add the path with a null stat
+      items = new PathData[]{ new PathData(fs, pattern, null) };
+    } else if (
+        // this is very ugly, but needed to avoid breaking hdfs tests...
+        // if a path has no authority, then the FileStatus from globStatus
+        // will add the "-fs" authority into the path, so we need to sub
+        // it back out to satisfy the tests
+        stats.length == 1
+        &&
+        stats[0].getPath().equals(fs.makeQualified(globPath)))
+    {
+      // if the fq path is identical to the pattern passed, use the pattern
+      // to initialize the string value
+      items = new PathData[]{ new PathData(fs, pattern, stats[0]) };
+    } else {
+      // convert stats to PathData
+      items = new PathData[stats.length];
+      int i=0;
+      for (FileStatus stat : stats) {
+        items[i++] = new PathData(fs, stat);
+      }
+    }
+    return items;
+  }
+
+  /**
+   * Returns the printable version of the path that is either the path
+   * as given on the commandline, or the full path
-    return path.toString();
+    return (string != null) ? string : path.toString();

INS26 MOV31 INS40 INS23 INS31 INS31 INS31 INS31 INS83 INS43 INS59 INS29 INS83 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS42 MOV44 INS44 INS44 INS8 INS29 INS83 INS42 INS44 INS44 INS44 INS8 UPD83 INS39 UPD42 INS29 INS83 INS83 INS5 INS42 INS44 INS44 INS43 INS8 INS42 INS42 INS33 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS21 INS21 INS21 INS21 INS65 INS65 INS65 INS65 UPD42 INS43 INS42 INS43 INS42 INS21 INS21 INS21 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS21 INS21 INS65 INS65 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS25 INS41 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS7 INS7 INS7 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS7 INS7 INS7 INS32 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS7 INS7 INS7 INS32 INS32 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS5 INS59 INS5 INS59 INS27 INS8 INS25 INS42 UPD66 UPD66 INS16 INS22 INS42 INS22 INS14 INS22 INS32 INS42 INS32 INS22 MOV32 INS22 INS42 INS22 INS42 INS42 INS42 INS22 INS42 INS22 INS16 INS22 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS33 INS42 INS33 INS21 INS27 INS8 INS8 INS36 INS42 INS32 INS52 INS42 INS52 INS42 MOV43 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS36 INS32 INS14 INS52 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS27 INS32 INS21 INS21 INS60 INS70 INS27 INS42 INS42 INS27 INS42 INS42 INS43 INS42 INS42 INS42 INS3 INS40 INS34 INS32 INS42 INS32 INS7 INS7 INS39 INS59 INS44 INS42 INS8 INS42 INS33 INS42 INS33 INS42 INS5 INS4 INS2 INS42 INS42 INS42 INS42 INS42 INS3 INS42 INS3 INS42 INS34 INS43 INS42 INS21 INS43 INS85 INS14 INS42 INS34 INS5 INS4 INS5 INS40 INS42 INS7 INS42 INS43 INS42 INS42 INS33 INS43 INS85 INS14 INS43 INS85 INS2 INS14 INS42 INS42 INS43 INS42 INS42 INS2 INS42 INS42 INS37 INS43 INS42 INS42 INS42 INS42 INS34 INS42 INS42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL7
HDFS-2737. Automatically trigger log rolls periodically on the active NN. Contributed by Todd Lipcon and Aaron T. Myers.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1234256 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.InetSocketAddress;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hdfs.DFSConfigKeys;
+import org.apache.hadoop.hdfs.HAUtil;
+import org.apache.hadoop.hdfs.protocol.HdfsConstants;
+import org.apache.hadoop.hdfs.protocolPB.NamenodeProtocolPB;
+import org.apache.hadoop.hdfs.protocolPB.NamenodeProtocolTranslatorPB;
+import org.apache.hadoop.hdfs.server.namenode.NameNode;
+import org.apache.hadoop.hdfs.server.protocol.NamenodeProtocol;
+import org.apache.hadoop.ipc.RPC;
+
+import static org.apache.hadoop.hdfs.server.common.Util.now;
+
+
+  private InetSocketAddress activeAddr;
+  private NamenodeProtocol cachedActiveProxy = null;
+
+  /**
+   * The last transaction ID at which an edit log roll was initiated.
+   */
+  private long lastRollTriggerTxId = HdfsConstants.INVALID_TXID;
+  
+  /**
+   * The highest transaction ID loaded by the Standby.
+   */
+  private long lastLoadedTxnId = HdfsConstants.INVALID_TXID;
+
+  /**
+   * The last time we successfully loaded a non-zero number of edits from the
+   * shared directory.
+   */
+  private long lastLoadTimestamp;
+
+  /**
+   * How often the Standby should roll edit logs. Since the Standby only reads
+   * from finalized log segments, the Standby will only be as up-to-date as how
+   * often the logs are rolled.
+   */
+  private long logRollPeriodMs;
+
+  /**
+   * How often the Standby should check if there are new finalized segment(s)
+   * available to be read from.
+   */
+  private long sleepTimeMs;
+    
+
+    Configuration conf = namesystem.getConf();
+    lastLoadTimestamp = now();
+
+    logRollPeriodMs = conf.getInt(DFSConfigKeys.DFS_HA_LOGROLL_PERIOD_KEY,
+        DFSConfigKeys.DFS_HA_LOGROLL_PERIOD_DEFAULT) * 1000;
+    if (logRollPeriodMs >= 0) {
+      this.activeAddr = getActiveNodeAddress();
+      Preconditions.checkArgument(activeAddr.getPort() > 0,
+          "Active NameNode must have an IPC port configured. " +
+          "Got address '%s'", activeAddr);
+      LOG.info("Will roll logs on active node at " + activeAddr + " every " +
+          (logRollPeriodMs / 1000) + " seconds.");
+    } else {
+      LOG.info("Not going to trigger log rolls on active node because " +
+          DFSConfigKeys.DFS_HA_LOGROLL_PERIOD_KEY + " is negative.");
+    }
+    
+    sleepTimeMs = conf.getInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,
+        DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_DEFAULT) * 1000;
+    
+    LOG.debug("logRollPeriodMs=" + logRollPeriodMs +
+        " sleepTime=" + sleepTimeMs);
+  private InetSocketAddress getActiveNodeAddress() {
+    Configuration conf = namesystem.getConf();
+    Configuration activeConf = HAUtil.getConfForOtherNode(conf);
+    return NameNode.getServiceAddress(activeConf, true);
+  }
+  
+  private NamenodeProtocol getActiveNodeProxy() throws IOException {
+    if (cachedActiveProxy == null) {
+      Configuration conf = namesystem.getConf();
+      NamenodeProtocolPB proxy = 
+        RPC.waitForProxy(NamenodeProtocolPB.class,
+            RPC.getProtocolVersion(NamenodeProtocolPB.class), activeAddr, conf);
+      cachedActiveProxy = new NamenodeProtocolTranslatorPB(proxy);
+    }
+    assert cachedActiveProxy != null;
+    return cachedActiveProxy;
+  }
+
-
-  @VisibleForTesting
-  public void setSleepTime(long sleepTime) {
-    tailerThread.setSleepTime(sleepTime);
-  }
-  
-  @VisibleForTesting
-  public void interrupt() {
-    tailerThread.interrupt();
-  }
+
+      if (editsLoaded > 0) {
+        lastLoadTimestamp = now();
+      }
+      lastLoadedTxnId = image.getLastAppliedTxId();
+   * @return true if the configured log roll period has elapsed.
+   */
+  private boolean tooLongSinceLastLoad() {
+    return logRollPeriodMs >= 0 && 
+      (now() - lastLoadTimestamp) > logRollPeriodMs ;
+  }
+
+  /**
+   * Trigger the active node to roll its logs.
+   */
+  private void triggerActiveLogRoll() {
+    LOG.info("Triggering log roll on remote NameNode " + activeAddr);
+    try {
+      getActiveNodeProxy().rollEditLog();
+      lastRollTriggerTxId = lastLoadedTxnId;
+    } catch (IOException ioe) {
+      LOG.warn("Unable to trigger a roll of the active NN", ioe);
+    }
+  }
+
+  /**
-    private long sleepTime = 60 * 1000;
-    private void setSleepTime(long sleepTime) {
-      this.sleepTime = sleepTime;
-    }
-    
+          // There's no point in triggering a log roll if the Standby hasn't
+          // read any more transactions since the last time a roll was
+          // triggered. 
+          if (tooLongSinceLastLoad() &&
+              lastRollTriggerTxId < lastLoadedTxnId) {
+            triggerActiveLogRoll();
+          }
+          /**
+           * Check again in case someone calls {@link EditLogTailer#stop} while
+           * we're triggering an edit log roll, since ipc.Client catches and
+           * ignores {@link InterruptedException} in a few places. This fixes
+           * the bug described in HDFS-2823.
+           */
+          if (!shouldRun) {
+            break;
+          }
-          Thread.sleep(sleepTime);
+          Thread.sleep(sleepTimeMs);

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS43 INS59 INS83 INS43 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS83 INS42 MOV44 MOV8 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS43 INS8 INS29 UPD83 MOV83 INS39 INS42 INS8 INS29 INS83 MOV39 INS42 INS8 INS42 INS42 INS42 INS42 INS33 INS65 INS42 INS40 INS65 INS42 INS40 INS65 INS42 INS65 INS42 INS65 INS42 MOV21 MOV21 MOV21 INS60 INS21 INS21 INS25 INS21 INS42 INS60 INS60 INS41 INS42 INS42 INS25 INS6 INS41 INS65 INS41 INS65 INS21 INS54 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS43 INS59 INS7 INS7 INS27 INS8 INS8 INS7 INS43 INS59 INS43 INS59 INS32 INS27 INS8 INS27 INS42 INS66 INS27 INS66 INS32 INS8 INS12 INS42 INS42 INS32 INS42 INS32 INS42 INS27 INS42 INS34 INS21 INS21 INS21 INS21 INS42 INS27 UPD42 UPD42 INS27 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS9 INS42 INS33 INS60 INS60 INS21 INS42 INS33 INS25 INS21 INS27 INS27 INS42 INS42 INS27 INS21 INS21 INS44 INS8 INS42 INS42 INS42 INS32 INS34 INS7 INS32 INS32 INS32 INS32 INS34 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS7 INS27 INS8 INS7 INS42 INS34 INS36 INS42 INS45 INS42 INS32 INS7 INS43 INS42 MOV21 INS42 INS42 INS40 INS40 INS22 INS32 INS42 INS42 INS27 INS27 INS42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS40 INS40 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS14 INS42 INS34 INS21 INS42 INS32 INS27 INS32 INS42 INS42 INS42 INS42 INS8 INS52 INS42 INS42 INS32 INS34 INS45 INS45 INS45 INS42 INS45 INS36 INS45 INS45 INS40 INS45 INS42 INS42 INS42 INS42 INS57 INS32 INS42 INS42 INS43 INS42 INS7 INS42 INS42 INS32 INS42 INS42 UPD42 INS42 INS45 UPD42 INS25 INS25 MOV21 INS42 INS42 INS27 INS43 INS42 INS42 INS57 INS42 INS42 INS32 INS42 INS27 INS8 INS38 INS8 INS42 INS34 INS42 INS43 INS42 INS32 INS27 INS21 INS42 INS10 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 DEL42 DEL83 DEL42 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL31 DEL42 DEL78 DEL42 DEL8 DEL31 DEL83 DEL39 DEL42 DEL34 DEL34 DEL27 DEL59 DEL23 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL8
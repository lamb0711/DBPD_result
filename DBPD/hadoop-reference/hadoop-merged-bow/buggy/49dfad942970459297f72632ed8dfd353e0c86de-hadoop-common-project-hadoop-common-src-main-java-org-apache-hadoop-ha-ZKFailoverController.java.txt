HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.

+import java.util.ArrayList;
+  protected abstract List<HAServiceTarget> getAllOtherNodes();
-   * 2) Determine the current active node. If it is the local node, no
+   * 2a) Determine the current active node. If it is the local node, no
-   * 3) Ask that node to yield from the election for a number of seconds.
+   * 2b) Get the other nodes
+   * 3a) Ask the other nodes to yield from election for a number of seconds
+   * 3b) Ask the active node to yield from the election for a number of seconds.
-    
-    // Phase 3: ask the old active to yield from the election.
-    LOG.info("Asking " + oldActive + " to cede its active state for " +
-        timeout + "ms");
-    ZKFCProtocol oldZkfc = oldActive.getZKFCProxy(conf, timeout);
-    oldZkfc.cedeActive(timeout);
+
+    // Phase 2b: get the other nodes
+    List<HAServiceTarget> otherNodes = getAllOtherNodes();
+    List<ZKFCProtocol> otherZkfcs = new ArrayList<ZKFCProtocol>(otherNodes.size());
+
+    // Phase 3: ask the other nodes to yield from the election.
+    HAServiceTarget activeNode = null;
+    for (HAServiceTarget remote : otherNodes) {
+      // same location, same node - may not always be == equality
+      if (remote.getAddress().equals(oldActive.getAddress())) {
+        activeNode = remote;
+        continue;
+      }
+      otherZkfcs.add(cedeRemoteActive(remote, timeout));
+    }
+
+    assert
+      activeNode != null : "Active node does not match any known remote node";
+
+    // Phase 3b: ask the old active to yield
+    otherZkfcs.add(cedeRemoteActive(activeNode, timeout));
-    oldZkfc.cedeActive(-1);
-    
+    for (ZKFCProtocol zkfc : otherZkfcs) {
+      zkfc.cedeActive(-1);
+    }
+
+   * Ask the remote zkfc to cede its active status and wait for the specified
+   * timeout before attempting to claim leader status.
+   * @param remote node to ask
+   * @param timeout amount of time to cede
+   * @return the {@link ZKFCProtocol} used to talk to the ndoe
+   * @throws IOException
+   */
+  private ZKFCProtocol cedeRemoteActive(HAServiceTarget remote, int timeout)
+    throws IOException {
+    LOG.info("Asking " + remote + " to cede its active state for "
+               + timeout + "ms");
+    ZKFCProtocol oldZkfc = remote.getZKFCProxy(conf, timeout);
+    oldZkfc.cedeActive(timeout);
+    return oldZkfc;
+  }
+
+  /**
-          throw new IllegalArgumentException("Unhandled state:" + lastHealthState);
+          throw new IllegalArgumentException("Unhandled state:"
+                                               + lastHealthState);

INS26 INS40 INS31 INS31 INS83 INS83 INS74 INS42 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS43 INS43 INS60 INS60 INS60 INS70 INS6 INS21 INS70 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS42 INS21 INS60 MOV21 INS41 INS42 INS42 UPD66 INS66 INS66 UPD66 INS74 INS59 INS74 INS59 INS43 INS59 INS44 INS42 INS8 INS27 INS45 INS32 INS44 INS42 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS42 INS42 INS32 INS43 INS59 INS42 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS33 INS43 INS42 INS25 MOV21 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS32 MOV43 INS42 MOV21 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS74 INS32 INS42 INS32 INS8 UPD42 MOV42 INS42 MOV42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS32 INS42 INS32 INS21 INS18 UPD42 UPD42 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL42 DEL32 DEL59 DEL60
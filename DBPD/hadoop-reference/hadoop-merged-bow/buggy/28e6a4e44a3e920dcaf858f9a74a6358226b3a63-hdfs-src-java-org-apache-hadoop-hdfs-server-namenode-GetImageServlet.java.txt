HDFS-1073. Redesign the NameNode's storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.InetSocketAddress;
+
+import org.apache.hadoop.hdfs.server.common.StorageInfo;
+import org.apache.hadoop.hdfs.server.protocol.RemoteEditLog;
+import org.apache.hadoop.hdfs.util.MD5FileUtils;
+import com.google.common.base.Preconditions;
+
-  @SuppressWarnings("unchecked")
+  private static final String TXID_PARAM = "txid";
+  private static final String START_TXID_PARAM = "startTxId";
+  private static final String END_TXID_PARAM = "endTxId";
+  private static final String STORAGEINFO_PARAM = "storageInfo";
+  
+  private static Set<Long> currentlyDownloadingCheckpoints =
+    Collections.<Long>synchronizedSet(new HashSet<Long>());
+  
-    Map<String,String[]> pmap = request.getParameterMap();
-      final TransferFsImage ff = new TransferFsImage(pmap, request, response);
+      final GetImageParams parsedParams = new GetImageParams(request, response);
-
+      
+      String myStorageInfoString = nnImage.getStorage().toColonSeparatedString();
+      String theirStorageInfoString = parsedParams.getStorageInfoString();
+      if (theirStorageInfoString != null &&
+          !myStorageInfoString.equals(theirStorageInfoString)) {
+        response.sendError(HttpServletResponse.SC_FORBIDDEN,
+            "This namenode has storage info " + myStorageInfoString + 
+            " but the secondary expected " + theirStorageInfoString);
+        LOG.warn("Received an invalid request file transfer request " +
+            "from a secondary with storage info " + theirStorageInfoString);
+        return;
+      }
+      
-          if (ff.getImage()) {
-            response.setHeader(TransferFsImage.CONTENT_LENGTH,
-                               String.valueOf(nnImage.getStorage()
-                                              .getFsImageName().length()));
-            // send fsImage
-            TransferFsImage.getFileServer(response.getOutputStream(),
-                                          nnImage.getStorage().getFsImageName(),
-                getThrottler(conf)); 
-          } else if (ff.getEdit()) {
-            response.setHeader(TransferFsImage.CONTENT_LENGTH,
-                               String.valueOf(nnImage.getStorage()
-                                              .getFsEditName().length()));
-            // send edits
-            TransferFsImage.getFileServer(response.getOutputStream(),
-                                          nnImage.getStorage().getFsEditName(),
-                getThrottler(conf));
-          } else if (ff.putImage()) {
-            // issue a HTTP get request to download the new fsimage 
-            nnImage.validateCheckpointUpload(ff.getToken());
-            nnImage.newImageDigest = ff.getNewChecksum();
-            MD5Hash downloadImageDigest = reloginIfNecessary().doAs(
-                new PrivilegedExceptionAction<MD5Hash>() {
-                @Override
-                public MD5Hash run() throws Exception {
-                  return TransferFsImage.getFileClient(
-                      ff.getInfoServer(), "getimage=1", 
-                      nnImage.getStorage().getFsImageNameCheckpoint(), true);
-                }
-            });
-            if (!nnImage.newImageDigest.equals(downloadImageDigest)) {
-              throw new IOException("The downloaded image is corrupt," +
-                  " expecting a checksum " + nnImage.newImageDigest +
-                  " but received a checksum " + downloadImageDigest);
+          if (parsedParams.isGetImage()) {
+            long txid = parsedParams.getTxId();
+            File imageFile = nnImage.getStorage().getFsImageName(txid);
+            if (imageFile == null) {
+              throw new IOException("Could not find image with txid " + txid);
-           nnImage.checkpointUploadDone();
+            setVerificationHeaders(response, imageFile);
+            // send fsImage
+            TransferFsImage.getFileServer(response.getOutputStream(), imageFile,
+                getThrottler(conf)); 
+          } else if (parsedParams.isGetEdit()) {
+            long startTxId = parsedParams.getStartTxId();
+            long endTxId = parsedParams.getEndTxId();
+            
+            File editFile = nnImage.getStorage()
+                .findFinalizedEditsFile(startTxId, endTxId);
+            setVerificationHeaders(response, editFile);
+            
+            // send edits
+            TransferFsImage.getFileServer(response.getOutputStream(), editFile,
+                getThrottler(conf));
+          } else if (parsedParams.isPutImage()) {
+            final long txid = parsedParams.getTxId();
+
+            if (! currentlyDownloadingCheckpoints.add(txid)) {
+              throw new IOException(
+                  "Another checkpointer is already in the process of uploading a" +
+                  " checkpoint made at transaction ID " + txid);
+            }
+
+            try {
+              if (nnImage.getStorage().findImageFile(txid) != null) {
+                throw new IOException(
+                    "Another checkpointer already uploaded an checkpoint " +
+                    "for txid " + txid);
+              }
+              
+              // issue a HTTP get request to download the new fsimage 
+              MD5Hash downloadImageDigest = reloginIfNecessary().doAs(
+                  new PrivilegedExceptionAction<MD5Hash>() {
+                  @Override
+                  public MD5Hash run() throws Exception {
+                    return TransferFsImage.downloadImageToStorage(
+                        parsedParams.getInfoServer(), txid,
+                        nnImage.getStorage(), true);
+                    }
+              });
+              nnImage.saveDigestAndRenameCheckpointImage(txid, downloadImageDigest);
+              
+              // Now that we have a new checkpoint, we might be able to
+              // remove some old ones.
+              nnImage.purgeOldStorage();
+            } finally {
+              currentlyDownloadingCheckpoints.remove(txid);
+            }
+  
+  /**
+   * Set headers for content length, and, if available, md5.
+   * @throws IOException 
+   */
+  private void setVerificationHeaders(HttpServletResponse response, File file)
+  throws IOException {
+    response.setHeader(TransferFsImage.CONTENT_LENGTH,
+        String.valueOf(file.length()));
+    MD5Hash hash = MD5FileUtils.readStoredMd5ForFile(file);
+    if (hash != null) {
+      response.setHeader(TransferFsImage.MD5_HEADER, hash.toString());
+    }
+  }
+
+  static String getParamStringForImage(long txid,
+      StorageInfo remoteStorageInfo) {
+    return "getimage=1&" + TXID_PARAM + "=" + txid
+      + "&" + STORAGEINFO_PARAM + "=" +
+      remoteStorageInfo.toColonSeparatedString();
+    
+  }
+
+  static String getParamStringForLog(RemoteEditLog log,
+      StorageInfo remoteStorageInfo) {
+    return "getedit=1&" + START_TXID_PARAM + "=" + log.getStartTxId()
+        + "&" + END_TXID_PARAM + "=" + log.getEndTxId()
+        + "&" + STORAGEINFO_PARAM + "=" +
+          remoteStorageInfo.toColonSeparatedString();
+  }
+  
+  static String getParamStringToPutImage(long txid,
+      InetSocketAddress imageListenAddress, NNStorage storage) {
+    
+    return "putimage=1" +
+      "&" + TXID_PARAM + "=" + txid +
+      "&port=" + imageListenAddress.getPort() +
+      "&machine=" + imageListenAddress.getHostName()
+      + "&" + STORAGEINFO_PARAM + "=" +
+      storage.toColonSeparatedString();
+  }
+
+  
+  static class GetImageParams {
+    private boolean isGetImage;
+    private boolean isGetEdit;
+    private boolean isPutImage;
+    private int remoteport;
+    private String machineName;
+    private long startTxId, endTxId, txId;
+    private String storageInfoString;
+
+    /**
+     * @param request the object from which this servlet reads the url contents
+     * @param response the object into which this servlet writes the url contents
+     * @throws IOException if the request is bad
+     */
+    public GetImageParams(HttpServletRequest request,
+                          HttpServletResponse response
+                           ) throws IOException {
+      @SuppressWarnings("unchecked")
+      Map<String, String[]> pmap = request.getParameterMap();
+      isGetImage = isGetEdit = isPutImage = false;
+      remoteport = 0;
+      machineName = null;
+
+      for (Map.Entry<String, String[]> entry : pmap.entrySet()) {
+        String key = entry.getKey();
+        String[] val = entry.getValue();
+        if (key.equals("getimage")) { 
+          isGetImage = true;
+          txId = parseLongParam(request, TXID_PARAM);
+        } else if (key.equals("getedit")) { 
+          isGetEdit = true;
+          startTxId = parseLongParam(request, START_TXID_PARAM);
+          endTxId = parseLongParam(request, END_TXID_PARAM);
+        } else if (key.equals("putimage")) { 
+          isPutImage = true;
+          txId = parseLongParam(request, TXID_PARAM);
+        } else if (key.equals("port")) { 
+          remoteport = new Integer(val[0]).intValue();
+        } else if (key.equals("machine")) { 
+          machineName = val[0];
+        } else if (key.equals(STORAGEINFO_PARAM)) {
+          storageInfoString = val[0];
+        }
+      }
+
+      int numGets = (isGetImage?1:0) + (isGetEdit?1:0);
+      if ((numGets > 1) || (numGets == 0) && !isPutImage) {
+        throw new IOException("Illegal parameters to TransferFsImage");
+      }
+    }
+
+    public String getStorageInfoString() {
+      return storageInfoString;
+    }
+
+    public long getTxId() {
+      Preconditions.checkState(isGetImage || isPutImage);
+      return txId;
+    }
+    
+    public long getStartTxId() {
+      Preconditions.checkState(isGetEdit);
+      return startTxId;
+    }
+    
+    public long getEndTxId() {
+      Preconditions.checkState(isGetEdit);
+      return endTxId;
+    }
+
+    boolean isGetEdit() {
+      return isGetEdit;
+    }
+
+    boolean isGetImage() {
+      return isGetImage;
+    }
+
+    boolean isPutImage() {
+      return isPutImage;
+    }
+    
+    String getInfoServer() throws IOException{
+      if (machineName == null || remoteport == 0) {
+        throw new IOException ("MachineName and port undefined");
+      }
+      return machineName + ":" + remoteport;
+    }
+    
+    private static long parseLongParam(HttpServletRequest request, String param)
+        throws IOException {
+      // Parse the 'txid' parameter which indicates which image is to be
+      // fetched.
+      String paramStr = request.getParameter(param);
+      if (paramStr == null) {
+        throw new IOException("Invalid request has no " + param + " parameter");
+      }
+      
+      return Long.valueOf(paramStr);
+    }
+  }

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS55 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS74 INS59 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS83 INS42 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS43 INS43 INS42 INS32 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS21 INS60 INS25 INS42 INS39 INS42 INS43 INS42 INS41 INS42 INS43 INS42 INS43 INS42 INS41 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS41 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS43 INS59 INS83 INS39 INS59 INS59 INS59 INS83 INS43 INS59 INS29 INS83 INS42 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS39 INS42 INS8 INS39 INS42 INS8 INS39 INS42 INS8 INS43 INS42 INS43 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS42 INS42 INS42 INS43 INS42 INS14 INS66 INS42 INS66 INS42 INS42 INS32 INS43 INS59 INS27 INS8 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 MOV60 INS21 INS21 INS21 INS70 INS60 INS25 INS42 INS41 INS21 INS41 INS21 INS41 INS21 INS41 INS41 INS41 INS41 INS42 INS42 INS25 INS41 INS43 INS42 INS43 INS42 INS42 INS60 INS25 INS41 INS42 INS74 INS60 INS60 INS25 INS42 INS42 INS40 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS42 INS45 INS32 INS27 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS32 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 MOV79 INS7 INS7 INS7 INS44 INS32 INS8 INS39 INS59 INS27 INS8 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS8 INS27 INS42 INS42 INS43 INS59 INS27 INS8 INS32 INS43 INS43 UPD43 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS34 INS42 INS33 INS74 INS42 INS42 INS42 INS60 INS60 INS25 INS42 INS27 INS36 INS27 INS53 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS53 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 MOV32 INS42 INS42 INS32 INS27 INS38 INS21 INS21 INS41 INS42 INS42 INS42 INS42 INS40 INS32 INS42 INS7 INS43 INS43 INS5 INS43 INS59 INS5 INS59 INS32 INS8 INS25 INS36 INS36 INS27 INS36 INS38 INS14 INS42 INS42 INS42 INS33 INS42 INS34 INS14 INS42 INS42 INS42 INS14 UPD43 UPD42 INS42 INS42 INS42 INS33 INS32 INS32 INS32 INS42 INS42 INS42 INS9 INS40 INS42 INS43 INS85 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS42 INS45 INS21 INS21 INS32 INS8 INS25 INS16 INS16 INS42 INS34 INS27 INS42 INS43 INS45 INS43 INS45 INS43 INS27 UPD42 INS42 INS42 INS42 INS42 INS42 INS40 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS45 INS21 INS21 INS21 INS32 INS8 INS25 INS42 INS34 INS34 INS42 INS34 INS34 INS42 INS34 INS42 INS42 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS45 INS42 INS42 INS9 INS42 INS32 INS7 INS7 INS7 INS42 INS42 INS45 INS21 INS21 INS32 INS8 INS25 INS42 INS42 INS42 INS42 INS9 INS42 INS32 INS42 INS32 INS7 INS7 INS42 INS42 INS45 INS21 INS32 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS32 INS7 INS42 INS42 INS45 INS21 INS32 INS8 UPD42 UPD42 INS60 INS60 INS25 INS21 MOV21 INS42 INS42 INS42 INS42 INS32 INS7 INS42 INS42 INS42 INS21 INS39 INS59 INS43 INS59 INS27 INS8 INS32 UPD42 UPD42 INS60 INS60 INS60 INS21 MOV21 INS14 INS42 INS42 INS2 INS7 INS42 INS32 INS42 INS42 MOV32 INS42 INS33 INS53 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS39 INS59 INS39 INS59 INS43 INS59 INS32 UPD42 UPD42 INS60 INS25 INS54 INS43 INS2 INS42 INS34 INS42 INS2 INS42 INS42 UPD42 INS42 INS14 INS42 INS32 INS42 INS32 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS83 INS39 INS59 INS38 INS8 INS8 INS8 INS42 INS42 INS34 INS42 INS34 MOV43 INS27 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS32 INS32 INS53 INS25 MOV60 INS21 MOV21 INS21 INS45 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS14 INS27 INS8 INS32 INS32 INS43 INS27 MOV32 INS33 INS53 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 UPD42 INS42 INS14 INS43 INS27 INS42 INS45 INS45 INS42 UPD42 INS42 MOV32 UPD42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL42 DEL32 DEL32 DEL32 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL32 DEL32 DEL21 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL40 DEL32 DEL7 DEL21 DEL40 DEL32 DEL38 DEL45 DEL45 DEL27 DEL40 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25
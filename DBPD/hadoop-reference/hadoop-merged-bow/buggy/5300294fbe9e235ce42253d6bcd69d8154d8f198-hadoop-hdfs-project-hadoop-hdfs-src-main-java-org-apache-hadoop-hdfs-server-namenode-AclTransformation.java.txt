HDFS-5758. NameNode: complete implementation of inode modifications for ACLs. Contributed by Chris Nauroth.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1559267 13f79535-47bb-0310-9956-ffa450edef68

-  private static final int PIVOT_NOT_FOUND = -1;
-  private static final Comparator<AclEntry> ACL_ENTRY_COMPARATOR =
+  static final Comparator<AclEntry> ACL_ENTRY_COMPARATOR =
-    int pivot = calculatePivotOnDefaultEntries(aclBuilder);
+    ScopedAclEntries scopedEntries = new ScopedAclEntries(aclBuilder);
-      if (Collections.binarySearch(aclBuilder, accessEntryKey,
-          ACL_ENTRY_COMPARATOR) < 0) {
+      if (Collections.binarySearch(scopedEntries.getAccessEntries(),
+          accessEntryKey, ACL_ENTRY_COMPARATOR) < 0) {
-      if (pivot != PIVOT_NOT_FOUND) {
+      if (!scopedEntries.getDefaultEntries().isEmpty()) {
-        if (Collections.binarySearch(aclBuilder, defaultEntryKey,
-            ACL_ENTRY_COMPARATOR) < 0) {
+        if (Collections.binarySearch(scopedEntries.getDefaultEntries(),
+            defaultEntryKey, ACL_ENTRY_COMPARATOR) < 0) {
+        // Caller explicitly removed mask entry, but it's required.
+        // Caller explicitly provided new mask, or we are preserving the existing
+        // mask in an unchanged scope.
-      } else if (maskNeeded.contains(scope)) {
+      } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {
+        // Otherwise, if there are maskable entries present, or the ACL
+        // previously had a mask, then recalculate a mask automatically.
-   * Returns the pivot point in the list between the access entries and the
-   * default entries.  This is the index of the first element in the list that is
-   * a default entry.
-   *
-   * @param aclBuilder ArrayList<AclEntry> containing entries to build
-   * @return int pivot point, or -1 if list contains no default entries
-   */
-  private static int calculatePivotOnDefaultEntries(List<AclEntry> aclBuilder) {
-    for (int i = 0; i < aclBuilder.size(); ++i) {
-      if (aclBuilder.get(i).getScope() == DEFAULT) {
-        return i;
-      }
-    }
-    return PIVOT_NOT_FOUND;
-  }
-
-  /**
-    int pivot = calculatePivotOnDefaultEntries(aclBuilder);
-    if (pivot != PIVOT_NOT_FOUND) {
-      List<AclEntry> accessEntries = aclBuilder.subList(0, pivot);
-      List<AclEntry> defaultEntries = aclBuilder.subList(pivot,
-        aclBuilder.size());
+    ScopedAclEntries scopedEntries = new ScopedAclEntries(aclBuilder);
+    if (!scopedEntries.getDefaultEntries().isEmpty()) {
+      List<AclEntry> accessEntries = scopedEntries.getAccessEntries();
+      List<AclEntry> defaultEntries = scopedEntries.getDefaultEntries();

INS43 INS43 INS38 INS42 UPD42 INS14 INS42 UPD42 INS14 INS32 INS43 INS42 INS38 INS43 INS42 INS32 INS42 MOV74 MOV74 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS27 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 INS42 MOV32 INS32 INS32 INS42 INS42 INS42 UPD42 MOV42 INS42 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL83 DEL39 DEL42 DEL42 DEL32 DEL42 DEL42 DEL27 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL27 DEL42 DEL41 DEL8 DEL25 DEL8 DEL24 DEL42 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL32 DEL42 DEL42 DEL27 DEL42 DEL34 DEL42 DEL42 DEL42 DEL32
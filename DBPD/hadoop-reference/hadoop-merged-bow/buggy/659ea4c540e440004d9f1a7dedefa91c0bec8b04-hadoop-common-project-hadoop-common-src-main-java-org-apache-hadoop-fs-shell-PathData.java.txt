HADOOP-7360. Preserve relative paths that do not contain globs in FsShell.  Contributed by Daryn Sharp and Kihwal Lee 


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190109 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.URI;
+import java.net.URISyntaxException;
+import org.apache.hadoop.fs.ChecksumFileSystem;
+import org.apache.hadoop.fs.LocalFileSystem;
+import org.apache.hadoop.fs.shell.PathExceptions.PathIOException;
+import org.apache.hadoop.fs.shell.PathExceptions.PathIsDirectoryException;
+import org.apache.hadoop.fs.shell.PathExceptions.PathNotFoundException;
-@InterfaceStability.Evolving
+@InterfaceStability.Unstable
-  protected String string = null;
+  protected final URI uri;
+  public final FileSystem fs;
-  public final FileSystem fs;
-    this.string = pathString;
-    this.path = new Path(pathString);
-    this.fs = path.getFileSystem(conf);
-    setStat(getStat(fs, path));
+    this(FileSystem.get(URI.create(pathString), conf), pathString);
-    this.string = localPath.toString();
-    this.path = new Path(this.string);
-    this.fs = FileSystem.getLocal(conf);
-    setStat(getStat(fs, path));
+    this(FileSystem.getLocal(conf), localPath.toString());
-   * Creates an object to wrap the given parameters as fields. 
-   * @param fs the FileSystem
-   * @param path a Path
-   * @param stat the FileStatus (may be null if the path doesn't exist)
-   */
-  public PathData(FileSystem fs, Path path, FileStatus stat) {
-    this.string = path.toString();
-    this.path = path;
-    this.fs = fs;
-    setStat(stat);
-  }
-
-  /**
-   * Convenience ctor that looks up the file status for a path.  If the path
+   * Looks up the file status for a path.  If the path
-   * @param path the pathname to lookup 
+   * @param pathString a string for a path 
-  public PathData(FileSystem fs, Path path) throws IOException {
-    this(fs, path, getStat(fs, path));
+  private PathData(FileSystem fs, String pathString) throws IOException {
+    this(fs, pathString, lookupStat(fs, pathString, true));
-   * return exactly the same string used to initialize it.  If the FileStatus
-   * is not null, then its Path will be used to initialized the path, else
-   * the string of the path will be used.
+   * return exactly the same string used to initialize it.
-  public PathData(FileSystem fs, String pathString, FileStatus stat) {
-    this.string = pathString;
-    this.path = (stat != null) ? stat.getPath() : new Path(pathString);
+  private PathData(FileSystem fs, String pathString, FileStatus stat)
+  throws IOException {
+    this.uri = stringToUri(pathString);
+    this.path = fs.makeQualified(new Path(uri));
-  private static FileStatus getStat(FileSystem fs, Path path)
-  throws IOException {  
+  /**
+   * Get the FileStatus info
+   * @param ignoreFNF if true, stat will be null if the path doesn't exist
+   * @return FileStatus for the given path
+   * @throws IOException if anything goes wrong
+   */
+  private static
+  FileStatus lookupStat(FileSystem fs, String pathString, boolean ignoreFNF)
+  throws IOException {
-      status = fs.getFileStatus(path);
-    } catch (FileNotFoundException e) {} // ignore FNF
+      status = fs.getFileStatus(new Path(pathString));
+    } catch (FileNotFoundException e) {
+      if (!ignoreFNF) throw new PathNotFoundException(pathString);
+    }
+    // TODO: should consider wrapping other exceptions into Path*Exceptions
-  private void setStat(FileStatus theStat) {
-    stat = theStat;
+  private void setStat(FileStatus stat) {
+    this.stat = stat;
-   * Convenience ctor that extracts the path from the given file status
-   * @param fs the FileSystem for the FileStatus
-   * @param stat the FileStatus 
-   */
-  public PathData(FileSystem fs, FileStatus stat) {
-    this(fs, stat.getPath(), stat);
-  }
-  
-  /**
-    setStat(fs.getFileStatus(path));
-    return stat;
+    FileStatus status = null;
+    try {
+      status = lookupStat(fs, toString(), false);
+    } finally {
+      // always set the status.  the caller must get the correct result
+      // if it catches the exception and later interrogates the status
+      setStat(status);
+    }
+    return status;
+  }
+
+  protected enum FileTypeRequirement {
+    SHOULD_NOT_BE_DIRECTORY, SHOULD_BE_DIRECTORY
+  };
+
+  /**
+   * Ensure that the file exists and if it is or is not a directory
+   * @param typeRequirement Set it to the desired requirement.
+   * @throws PathIOException if file doesn't exist or the type does not match
+   * what was specified in typeRequirement.
+   */
+  private void checkIfExists(FileTypeRequirement typeRequirement) 
+  throws PathIOException {
+    if (!exists) {
+      throw new PathNotFoundException(toString());      
+    }
+
+    if ((typeRequirement == FileTypeRequirement.SHOULD_BE_DIRECTORY)
+       && !stat.isDirectory()) {
+      throw new PathIsNotDirectoryException(toString());
+    } else if ((typeRequirement == FileTypeRequirement.SHOULD_NOT_BE_DIRECTORY)
+              && stat.isDirectory()) {
+      throw new PathIsDirectoryException(toString());
+    }
+   * Return the corresponding crc data for a file.  Avoids exposing the fs
+   * contortions to the caller.  
+   * @return PathData of the crc file
+   * @throws IOException is anything goes wrong
+   */
+  public PathData getChecksumFile() throws IOException {
+    checkIfExists(FileTypeRequirement.SHOULD_NOT_BE_DIRECTORY);
+    ChecksumFileSystem srcFs = (ChecksumFileSystem)fs;
+    Path srcPath = srcFs.getChecksumFile(path);
+    return new PathData(srcFs.getRawFileSystem(), srcPath.toString());
+  }
+
+  /**
-    if (!stat.isDirectory()) {
-      throw new PathIsNotDirectoryException(string);
-    }
-
+    checkIfExists(FileTypeRequirement.SHOULD_BE_DIRECTORY);
-      String basename = stats[i].getPath().getName();
-      String parent = string;
-      if (!parent.endsWith(Path.SEPARATOR)) parent += Path.SEPARATOR;
-      items[i] = new PathData(fs, parent + basename, stats[i]);
+      String child = getStringForChildPath(stats[i].getPath());
+      items[i] = new PathData(fs, child, stats[i]);
-    if (!stat.isDirectory()) {
-      throw new PathIsNotDirectoryException(string);
-    }
-    return new PathData(fs, new Path(path, child.path.getName()));
+    checkIfExists(FileTypeRequirement.SHOULD_BE_DIRECTORY);
+    return new PathData(fs, getStringForChildPath(child.path));
+   * Given a child of this directory, use the directory's path and the child's
+   * basename to construct the string to the child.  This preserves relative
+   * paths since Path will fully qualify.
+   * @param child a path contained within this directory
+   * @return String of the path relative to this directory
+   */
+  private String getStringForChildPath(Path childPath) {
+    String basename = childPath.getName();
+    if (Path.CUR_DIR.equals(toString())) {
+      return basename;
+    }
+    // check getPath() so scheme slashes aren't considered part of the path
+    String separator = uri.getPath().endsWith(Path.SEPARATOR)
+        ? "" : Path.SEPARATOR;
+    return uri + separator + basename;
+  }
+  
+  protected enum PathType { HAS_SCHEME, SCHEMELESS_ABSOLUTE, RELATIVE };
+  
+  /**
-    } else if (
-        // this is very ugly, but needed to avoid breaking hdfs tests...
-        // if a path has no authority, then the FileStatus from globStatus
-        // will add the "-fs" authority into the path, so we need to sub
-        // it back out to satisfy the tests
-        stats.length == 1
-        &&
-        stats[0].getPath().equals(fs.makeQualified(globPath)))
-    {
-      // if the fq path is identical to the pattern passed, use the pattern
-      // to initialize the string value
-      items = new PathData[]{ new PathData(fs, pattern, stats[0]) };
+      // figure out what type of glob path was given, will convert globbed
+      // paths to match the type to preserve relativity
+      PathType globType;
+      URI globUri = globPath.toUri();
+      if (globUri.getScheme() != null) {
+        globType = PathType.HAS_SCHEME;
+      } else if (new File(globUri.getPath()).isAbsolute()) {
+        globType = PathType.SCHEMELESS_ABSOLUTE;
+      } else {
+        globType = PathType.RELATIVE;
+      }
+
-        items[i++] = new PathData(fs, stat);
+        URI matchUri = stat.getPath().toUri();
+        String globMatch = null;
+        switch (globType) {
+          case HAS_SCHEME: // use as-is, but remove authority if necessary
+            if (globUri.getAuthority() == null) {
+              matchUri = removeAuthority(matchUri);
+            }
+            globMatch = matchUri.toString();
+            break;
+          case SCHEMELESS_ABSOLUTE: // take just the uri's path
+            globMatch = matchUri.getPath();
+            break;
+          case RELATIVE: // make it relative to the current working dir
+            URI cwdUri = fs.getWorkingDirectory().toUri();
+            globMatch = relativize(cwdUri, matchUri, stat.isDirectory());
+            break;
+        }
+        items[i++] = new PathData(fs, globMatch, stat);
+  private static URI removeAuthority(URI uri) {
+    try {
+      uri = new URI(
+          uri.getScheme(), "",
+          uri.getPath(), uri.getQuery(), uri.getFragment()
+      );
+    } catch (URISyntaxException e) {
+      throw new IllegalArgumentException(e.getLocalizedMessage());
+    }
+    return uri;
+  }
+  
+  private static String relativize(URI cwdUri, URI srcUri, boolean isDir) {
+    String uriPath = srcUri.getPath();
+    String cwdPath = cwdUri.getPath();
+    if (cwdPath.equals(uriPath)) {
+      return Path.CUR_DIR;
+    }
+
+    // find common ancestor
+    int lastSep = findLongestDirPrefix(cwdPath, uriPath, isDir);
+    
+    StringBuilder relPath = new StringBuilder();    
+    // take the remaining path fragment after the ancestor
+    if (lastSep < uriPath.length()) {
+      relPath.append(uriPath.substring(lastSep+1));
+    }
+
+    // if cwd has a path fragment after the ancestor, convert them to ".."
+    if (lastSep < cwdPath.length()) {
+      while (lastSep != -1) {
+        if (relPath.length() != 0) relPath.insert(0, Path.SEPARATOR);
+        relPath.insert(0, "..");
+        lastSep = cwdPath.indexOf(Path.SEPARATOR, lastSep+1);
+      }
+    }
+    return relPath.toString();
+  }
+
+  private static int findLongestDirPrefix(String cwd, String path, boolean isDir) {
+    // add the path separator to dirs to simplify finding the longest match
+    if (!cwd.endsWith(Path.SEPARATOR)) {
+      cwd += Path.SEPARATOR;
+    }
+    if (isDir && !path.endsWith(Path.SEPARATOR)) {
+      path += Path.SEPARATOR;
+    }
+
+    // find longest directory prefix 
+    int len = Math.min(cwd.length(), path.length());
+    int lastSep = -1;
+    for (int i=0; i < len; i++) {
+      if (cwd.charAt(i) != path.charAt(i)) break;
+      if (cwd.charAt(i) == Path.SEPARATOR_CHAR) lastSep = i;
+    }
+    return lastSep;
+  }
+  
-    return (string != null) ? string : path.toString();
+    String scheme = uri.getScheme();
+    // No interpretation of symbols. Just decode % escaped chars.
+    String decodedRemainder = uri.getSchemeSpecificPart();
+
+    if (scheme == null) {
+      return decodedRemainder;
+    } else {
+      StringBuilder buffer = new StringBuilder();
+      buffer.append(scheme);
+      buffer.append(":");
+      buffer.append(decodedRemainder);
+      return buffer.toString();
+    }
+  
+  /**
+   * Get the path to a local file
+   * @return File representing the local path
+   * @throws IllegalArgumentException if this.fs is not the LocalFileSystem
+   */
+  public File toFile() {
+    if (!(fs instanceof LocalFileSystem)) {
+       throw new IllegalArgumentException("Not a local path: " + path);
+    }
+    return ((LocalFileSystem)fs).pathToFile(path);
+  }
+
+  /** Construct a URI from a String with unescaped special characters
+   *  that have non-standard sematics. e.g. /, ?, #. A custom parsing
+   *  is needed to prevent misbihaviors.
+   *  @param pathString The input path in string form
+   *  @return URI
+   */
+  private static URI stringToUri(String pathString) {
+    // We can't use 'new URI(String)' directly. Since it doesn't do quoting
+    // internally, the internal parser may fail or break the string at wrong
+    // places. Use of multi-argument ctors will quote those chars for us,
+    // but we need to do our own parsing and assembly.
+    
+    // parse uri components
+    String scheme = null;
+    String authority = null;
+
+    int start = 0;
+
+    // parse uri scheme, if any
+    int colon = pathString.indexOf(':');
+    int slash = pathString.indexOf('/');
+    if (colon > 0 && (slash == colon +1)) {
+      // has a non zero-length scheme
+      scheme = pathString.substring(0, colon);
+      start = colon + 1;
+    }
+
+    // parse uri authority, if any
+    if (pathString.startsWith("//", start) &&
+        (pathString.length()-start > 2)) {
+      start += 2;
+      int nextSlash = pathString.indexOf('/', start);
+      int authEnd = nextSlash > 0 ? nextSlash : pathString.length();
+      authority = pathString.substring(start, authEnd);
+      start = authEnd;
+    }
+
+    // uri path is the rest of the string. ? or # are not interpreated,
+    // but any occurrence of them will be quoted by the URI ctor.
+    String path = pathString.substring(start, pathString.length());
+
+    // Construct the URI
+    try {
+      return new URI(scheme, authority, path, null, null);
+    } catch (URISyntaxException e) {
+      throw new IllegalArgumentException(e);
+    }
+  }
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV31 MOV31 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS71 INS31 INS31 INS31 INS71 INS31 INS31 INS31 UPD40 INS83 INS43 UPD83 MOV29 INS83 INS42 MOV44 MOV44 MOV44 INS43 MOV8 MOV21 INS29 INS83 INS83 MOV43 INS42 MOV44 INS44 INS44 MOV43 INS8 MOV29 INS83 MOV43 INS42 MOV43 INS8 INS83 INS42 INS72 INS72 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 MOV83 INS43 INS42 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS83 INS42 INS72 INS72 INS72 INS83 INS83 INS43 INS42 MOV44 INS8 INS83 UPD83 MOV43 UPD42 INS44 INS44 INS44 INS39 UPD42 INS44 INS44 MOV29 INS83 MOV43 INS42 INS8 INS43 INS42 INS8 INS29 INS83 UPD83 MOV83 INS43 INS42 INS44 INS8 INS42 UPD42 INS17 INS17 UPD43 UPD42 INS42 MOV65 MOV65 INS65 INS65 INS43 INS42 INS39 INS42 MOV60 INS54 MOV41 MOV43 UPD42 INS60 INS54 INS41 INS42 INS42 INS65 MOV65 UPD65 MOV65 INS43 INS42 INS42 INS25 INS25 INS65 INS65 INS65 INS42 INS42 INS21 INS60 INS60 INS41 INS21 INS21 INS65 INS65 INS65 INS42 MOV43 INS42 INS60 INS25 INS60 INS41 INS42 INS42 INS42 INS25 INS42 UPD43 UPD42 INS54 INS41 INS43 INS42 INS43 INS42 INS39 INS42 INS60 INS60 INS25 INS60 INS60 INS25 INS25 INS41 INS43 INS42 INS43 INS39 INS42 INS25 INS25 INS60 INS60 INS24 INS41 INS60 INS60 INS25 UPD65 UPD65 UPD42 MOV42 INS25 INS41 INS65 INS65 INS65 INS42 INS43 INS42 INS60 INS60 INS60 INS60 INS60 INS25 INS25 INS60 INS54 INS32 INS42 MOV32 MOV32 UPD66 UPD42 UPD66 UPD42 UPD42 UPD66 UPD66 UPD42 UPD66 INS66 INS42 INS66 INS42 INS8 INS12 MOV42 INS43 INS59 INS8 INS8 INS42 INS66 UPD42 UPD66 UPD42 UPD66 INS66 INS42 INS38 INS8 INS27 MOV8 INS25 INS66 INS66 INS66 INS42 INS66 INS32 INS43 INS59 MOV43 INS59 INS14 INS32 INS32 INS66 INS66 INS66 INS42 INS66 INS66 MOV43 INS59 INS32 INS8 INS43 INS59 INS27 MOV27 MOV8 INS8 UPD42 INS8 INS12 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS8 INS39 INS59 INS43 INS59 INS27 INS8 INS27 INS8 INS32 INS42 INS42 INS38 INS8 INS27 INS8 INS39 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS43 INS59 INS43 INS59 INS27 INS8 INS8 UPD66 UPD66 UPD42 UPD66 INS38 INS8 INS32 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS27 INS8 INS43 INS59 INS8 INS12 INS42 INS42 INS32 MOV42 UPD42 UPD42 INS9 INS32 INS21 MOV44 INS8 INS22 UPD42 INS42 INS42 INS33 INS21 INS21 INS42 INS53 INS36 MOV38 INS27 INS8 INS42 INS40 UPD42 MOV42 INS42 INS11 INS42 INS32 MOV43 INS32 INS32 INS42 INS40 UPD42 MOV42 INS40 INS32 INS42 INS32 INS40 INS42 INS32 INS41 INS42 INS42 INS16 INS42 INS42 INS42 INS60 INS60 INS25 MOV21 MOV60 INS70 INS21 INS44 INS8 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS41 INS42 INS32 INS42 INS42 INS14 INS42 INS32 MOV21 INS42 INS32 INS61 UPD42 MOV42 UPD42 MOV42 INS32 INS21 INS42 INS38 INS21 INS42 INS32 INS42 INS38 INS39 INS59 INS42 INS42 INS42 INS25 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS41 INS60 INS21 INS21 INS21 INS41 INS36 INS53 INS36 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS34 INS42 INS32 INS42 INS32 INS27 INS36 MOV21 INS21 INS32 INS36 INS21 INS60 INS60 INS21 INS21 INS42 INS42 INS32 INS41 INS44 INS8 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS14 INS7 INS25 INS52 INS42 INS7 INS32 INS14 INS27 INS36 INS32 INS53 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV40 INS42 INS42 INS42 INS42 INS32 INS45 INS40 INS43 INS59 INS43 INS59 INS27 INS8 INS25 MOV44 INS42 INS8 INS7 UPD43 MOV43 UPD42 MOV42 INS53 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS42 INS42 INS27 INS8 INS42 INS42 INS40 INS7 INS32 INS7 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS34 INS42 INS34 INS27 INS10 INS27 INS21 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS32 INS32 INS32 INS62 INS14 INS11 INS42 INS42 INS13 INS42 INS42 INS13 INS42 INS34 INS27 INS7 INS7 INS42 INS42 INS45 INS42 INS27 INS7 INS39 INS59 INS39 INS59 INS7 INS7 UPD42 MOV42 INS42 INS42 INS32 INS14 INS43 INS42 INS53 INS43 INS42 INS42 INS32 INS38 INS53 INS42 INS32 INS42 INS42 INS43 INS32 INS42 INS40 INS32 INS27 INS42 INS42 INS14 INS42 UPD42 MOV32 INS32 INS42 INS40 INS42 INS42 INS42 INS42 INS32 INS32 INS33 INS21 INS32 INS8 INS8 INS60 INS60 INS50 MOV21 INS42 INS14 UPD42 INS14 INS42 INS42 INS42 INS32 UPD42 MOV42 INS38 INS25 INS21 MOV21 INS42 INS40 INS42 INS42 INS40 INS42 INS40 INS42 INS42 MOV42 INS42 INS32 INS32 INS32 INS40 INS7 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS27 INS43 INS42 INS42 INS27 INS42 INS32 INS42 INS27 INS27 INS34 INS42 INS34 INS42 INS32 INS42 INS16 INS42 INS32 INS42 INS42 UPD42 MOV42 INS42 INS43 INS42 INS42 INS42 INS33 INS33 INS42 INS14 INS42 INS42 INS42 MOV14 INS42 INS14 INS42 INS42 INS32 INS9 INS42 INS42 INS42 INS42 INS40 INS43 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS14 INS42 INS21 INS21 INS43 INS59 INS43 INS59 INS42 INS49 INS25 INS21 INS10 INS49 INS21 INS10 INS49 INS60 INS21 INS10 INS43 INS32 INS45 INS32 INS32 INS32 INS43 INS32 INS42 INS42 INS27 INS34 INS27 INS21 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 UPD42 MOV42 INS42 INS45 INS42 INS42 INS42 INS34 UPD42 MOV42 UPD42 MOV42 INS34 UPD42 MOV42 INS42 INS34 INS32 INS42 INS42 INS42 INS13 INS42 INS27 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS40 INS43 INS32 INS7 INS7 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS27 INS8 INS7 INS42 INS7 INS42 INS43 INS59 MOV7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS34 INS32 INS42 INS42 INS34 INS45 INS42 INS32 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS40 MOV32 INS42 INS32 INS33 INS21 INS42 INS32 INS42 INS32 INS42 INS42 INS32 UPD42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS34 INS40 INS42 INS42 INS40 INS27 INS42 INS42 INS7 INS42 INS42 INS42 MOV42 INS32 UPD42 MOV42 INS42 INS42 INS42 INS32 INS42 INS34 INS42 INS32 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 DEL33 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL29 DEL42 DEL43 DEL42 DEL44 DEL44 DEL31 DEL66 DEL66 DEL42 DEL42 DEL42 DEL42 DEL42 DEL41 DEL8 DEL31 DEL25 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL38 DEL42 DEL40 DEL7 DEL21 DEL25 DEL42 DEL42 DEL27 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL32 DEL14 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL34 DEL2 DEL14 DEL4 DEL3 DEL40 DEL34 DEL27 DEL42 DEL34 DEL2 DEL32 DEL42 DEL32 DEL32 DEL27 DEL21 DEL8 DEL42 DEL8 DEL70 DEL8 DEL25 DEL25 DEL52 DEL42 DEL22 DEL42 DEL7 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL33 DEL27 DEL36 DEL32 DEL16 DEL7 DEL21 DEL32 DEL21 DEL42 DEL32 DEL7 DEL21 DEL8 DEL8 DEL12 DEL54 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL17 DEL8 DEL42 DEL32 DEL32 DEL83 DEL42 DEL42 DEL33 DEL27 DEL36 DEL42 DEL32 DEL16 DEL41 DEL8 DEL31
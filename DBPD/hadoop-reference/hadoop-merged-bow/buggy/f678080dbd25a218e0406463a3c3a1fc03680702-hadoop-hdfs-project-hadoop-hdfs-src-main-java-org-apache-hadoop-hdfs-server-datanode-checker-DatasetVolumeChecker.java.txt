HDFS-11182. Update DataNode to use DatasetVolumeChecker. Contributed by Arpit Agarwal.

-import org.apache.hadoop.hdfs.server.datanode.StorageLocation;
-  public Set<StorageLocation> checkAllVolumes(
+  public Set<FsVolumeSpi> checkAllVolumes(
-
-    if (timer.monotonicNow() - lastAllVolumesCheck < minDiskCheckGapMs) {
+    final long gap = timer.monotonicNow() - lastAllVolumesCheck;
+    if (gap < minDiskCheckGapMs) {
+      LOG.trace(
+          "Skipped checking all volumes, time since last check {} is less " +
+          "than the minimum gap between checks ({} ms).",
+          gap, minDiskCheckGapMs);
+      return Collections.emptySet();
+    }
+
+    final FsDatasetSpi.FsVolumeReferences references =
+        dataset.getFsVolumeReferences();
+
+    if (references.size() == 0) {
+      LOG.warn("checkAllVolumesAsync - no volumes can be referenced");
-    final Set<StorageLocation> healthyVolumes = new HashSet<>();
-    final Set<StorageLocation> failedVolumes = new HashSet<>();
-    final Set<StorageLocation> allVolumes = new HashSet<>();
+    final Set<FsVolumeSpi> healthyVolumes = new HashSet<>();
+    final Set<FsVolumeSpi> failedVolumes = new HashSet<>();
+    final Set<FsVolumeSpi> allVolumes = new HashSet<>();
-    final FsDatasetSpi.FsVolumeReferences references =
-        dataset.getFsVolumeReferences();
-    final CountDownLatch resultsLatch = new CountDownLatch(references.size());
+    final AtomicLong numVolumes = new AtomicLong(references.size());
+    final CountDownLatch latch = new CountDownLatch(1);
-      allVolumes.add(reference.getVolume().getStorageLocation());
+      allVolumes.add(reference.getVolume());
-          reference, healthyVolumes, failedVolumes, resultsLatch, null));
+          reference, healthyVolumes, failedVolumes, numVolumes, new Callback() {
+        @Override
+        public void call(Set<FsVolumeSpi> ignored1,
+                         Set<FsVolumeSpi> ignored2) {
+          latch.countDown();
+        }
+      }));
-    if (!resultsLatch.await(maxAllowedTimeForCheckMs, TimeUnit.MILLISECONDS)) {
+    if (!latch.await(maxAllowedTimeForCheckMs, TimeUnit.MILLISECONDS)) {
-
-    if (timer.monotonicNow() - lastAllVolumesCheck < minDiskCheckGapMs) {
+    final long gap = timer.monotonicNow() - lastAllVolumesCheck;
+    if (gap < minDiskCheckGapMs) {
+      LOG.trace(
+          "Skipped checking all volumes, time since last check {} is less " +
+              "than the minimum gap between checks ({} ms).",
+          gap, minDiskCheckGapMs);
+      return false;
+    }
+
+    final FsDatasetSpi.FsVolumeReferences references =
+        dataset.getFsVolumeReferences();
+
+    if (references.size() == 0) {
+      LOG.warn("checkAllVolumesAsync - no volumes can be referenced");
-    final Set<StorageLocation> healthyVolumes = new HashSet<>();
-    final Set<StorageLocation> failedVolumes = new HashSet<>();
-    final FsDatasetSpi.FsVolumeReferences references =
-        dataset.getFsVolumeReferences();
-    final CountDownLatch latch = new CountDownLatch(references.size());
+    final Set<FsVolumeSpi> healthyVolumes = new HashSet<>();
+    final Set<FsVolumeSpi> failedVolumes = new HashSet<>();
+    final AtomicLong numVolumes = new AtomicLong(references.size());
-          reference, healthyVolumes, failedVolumes, latch, callback));
+          reference, healthyVolumes, failedVolumes, numVolumes, callback));
-    void call(Set<StorageLocation> healthyVolumes,
-              Set<StorageLocation> failedVolumes);
+    void call(Set<FsVolumeSpi> healthyVolumes,
+              Set<FsVolumeSpi> failedVolumes);
+   * @return true if the check was scheduled and the callback will be invoked.
+   *         false otherwise.
-  public void checkVolume(
+  public boolean checkVolume(
-      return;
+      return false;
-        new CountDownLatch(1), callback));
+        new AtomicLong(1), callback));
+    return true;
-    private final Set<StorageLocation> failedVolumes;
-    private final Set<StorageLocation> healthyVolumes;
-    private final CountDownLatch latch;
-    private final AtomicLong numVolumes;
+    private final Set<FsVolumeSpi> failedVolumes;
+    private final Set<FsVolumeSpi> healthyVolumes;
+    private final AtomicLong volumeCounter;
+    /**
+     *
+     * @param reference FsVolumeReference to be released when the check is
+     *                  complete.
+     * @param healthyVolumes set of healthy volumes. If the disk check is
+     *                       successful, add the volume here.
+     * @param failedVolumes set of failed volumes. If the disk check fails,
+     *                      add the volume here.
+     * @param semaphore semaphore used to trigger callback invocation.
+     * @param callback invoked when the semaphore can be successfully acquired.
+     */
-                  Set<StorageLocation> healthyVolumes,
-                  Set<StorageLocation> failedVolumes,
-                  CountDownLatch latch,
+                  Set<FsVolumeSpi> healthyVolumes,
+                  Set<FsVolumeSpi> failedVolumes,
+                  AtomicLong volumeCounter,
-      this.latch = latch;
+      this.volumeCounter = volumeCounter;
-      numVolumes = new AtomicLong(latch.getCount());
-        healthyVolumes.add(reference.getVolume().getStorageLocation());
+        healthyVolumes.add(reference.getVolume());
-        failedVolumes.add(reference.getVolume().getStorageLocation());
+        failedVolumes.add(reference.getVolume());
-        latch.countDown();
-
-        if (numVolumes.decrementAndGet() == 0 &&
-            callback != null) {
+        final long remaining = volumeCounter.decrementAndGet();
+        if (callback != null && remaining == 0) {

MOV31 UPD74 MOV60 MOV60 UPD39 UPD43 INS60 INS25 INS60 INS60 INS25 INS65 INS41 UPD74 MOV74 UPD74 MOV74 INS29 UPD42 UPD42 UPD42 INS83 INS39 INS59 INS8 INS27 MOV8 INS74 UPD74 UPD74 MOV74 INS43 INS83 MOV43 INS59 INS83 INS39 INS59 INS27 INS8 UPD74 UPD74 UPD43 UPD74 MOV74 UPD74 MOV74 INS66 INS66 INS9 UPD43 UPD43 UPD42 INS65 INS65 INS65 INS65 INS65 INS74 INS74 UPD43 UPD42 INS42 MOV27 INS42 MOV21 INS21 INS41 INS32 INS34 INS21 MOV43 INS43 UPD43 UPD43 INS42 UPD42 INS42 INS14 INS42 MOV27 INS42 INS21 INS41 INS32 INS34 INS21 MOV41 UPD43 UPD43 UPD42 UPD42 UPD43 UPD43 UPD42 UPD42 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS43 INS43 INS43 INS43 UPD42 INS32 INS32 INS42 INS42 INS32 INS42 UPD42 UPD42 UPD43 INS43 INS34 MOV32 MOV32 UPD42 INS32 INS9 INS42 INS42 INS32 MOV42 UPD42 UPD42 UPD43 UPD42 UPD42 MOV43 INS42 INS42 INS42 INS42 UPD42 INS60 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS45 UPD42 INS42 UPD42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS45 UPD42 INS9 UPD43 UPD42 MOV32 MOV32 MOV32 MOV32 INS83 INS39 INS59 MOV27 INS45 INS45 INS42 INS14 INS45 INS45 MOV43 UPD42 MOV42 UPD42 INS42 UPD42 INS42 INS42 INS32 INS43 INS1 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS31 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS42 INS74 INS42 INS74 INS42 MOV21 INS43 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL42 DEL33 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL42 DEL42 DEL32 DEL14 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32
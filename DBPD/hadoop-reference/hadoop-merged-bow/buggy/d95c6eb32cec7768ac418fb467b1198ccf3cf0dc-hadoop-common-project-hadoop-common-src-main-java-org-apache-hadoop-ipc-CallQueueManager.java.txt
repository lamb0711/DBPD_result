HADOOP-12916. Allow RPC scheduler/callqueue backoff using response times. Contributed by Xiaoyu Yao.

+import org.apache.hadoop.fs.CommonConfigurationKeys;
+
+  @SuppressWarnings("unchecked")
+  static Class<? extends RpcScheduler> convertSchedulerClass(
+      Class<?> schedulerClass) {
+    return (Class<? extends RpcScheduler>)schedulerClass;
+  }
+
+  private RpcScheduler scheduler;
+
+                          Class<? extends RpcScheduler> schedulerClass,
+    int priorityLevels = parseNumLevels(namespace, conf);
+    this.scheduler = createScheduler(schedulerClass, priorityLevels,
+        namespace, conf);
-      maxQueueSize, namespace, conf);
+        priorityLevels, maxQueueSize, namespace, conf);
-    LOG.info("Using callQueue " + backingClass);
+    LOG.info("Using callQueue: " + backingClass + " scheduler: " +
+        schedulerClass);
+  }
+
+  private static <T extends RpcScheduler> T createScheduler(
+      Class<T> theClass, int priorityLevels, String ns, Configuration conf) {
+    // Used for custom, configurable scheduler
+    try {
+      Constructor<T> ctor = theClass.getDeclaredConstructor(int.class,
+          String.class, Configuration.class);
+      return ctor.newInstance(priorityLevels, ns, conf);
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(theClass.getName()
+          + " could not be constructed.", e.getCause());
+    } catch (Exception e) {
+    }
+
+    try {
+      Constructor<T> ctor = theClass.getDeclaredConstructor(int.class);
+      return ctor.newInstance(priorityLevels);
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(theClass.getName()
+          + " could not be constructed.", e.getCause());
+    } catch (Exception e) {
+    }
+
+    // Last attempt
+    try {
+      Constructor<T> ctor = theClass.getDeclaredConstructor();
+      return ctor.newInstance();
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(theClass.getName()
+          + " could not be constructed.", e.getCause());
+    } catch (Exception e) {
+    }
+
+    // Nothing worked
+    throw new RuntimeException(theClass.getName() +
+        " could not be constructed.");
-      Class<T> theClass, int maxLen, String ns, Configuration conf) {
+      Class<T> theClass, int priorityLevels, int maxLen, String ns,
+      Configuration conf) {
-      Constructor<T> ctor = theClass.getDeclaredConstructor(int.class, String.class,
-        Configuration.class);
-      return ctor.newInstance(maxLen, ns, conf);
+      Constructor<T> ctor = theClass.getDeclaredConstructor(int.class,
+          int.class, String.class, Configuration.class);
+      return ctor.newInstance(priorityLevels, maxLen, ns, conf);
+  // Based on policy to determine back off current call
+  boolean shouldBackOff(Schedulable e) {
+    return scheduler.shouldBackOff(e);
+  }
+
+  void addResponseTime(String name, int priorityLevel, int queueTime,
+      int processingTime) {
+    scheduler.addResponseTime(name, priorityLevel, queueTime, processingTime);
+  }
+
+  // This should be only called once per call and cached in the call object
+  // each getPriorityLevel call will increment the counter for the caller
+  int getPriorityLevel(Schedulable e) {
+    return scheduler.getPriorityLevel(e);
+  }
+
+   * Read the number of levels from the configuration.
+   * This will affect the FairCallQueue's overall capacity.
+   * @throws IllegalArgumentException on invalid queue count
+   */
+  @SuppressWarnings("deprecation")
+  private static int parseNumLevels(String ns, Configuration conf) {
+    // Fair call queue levels (IPC_CALLQUEUE_PRIORITY_LEVELS_KEY)
+    // takes priority over the scheduler level key
+    // (IPC_SCHEDULER_PRIORITY_LEVELS_KEY)
+    int retval = conf.getInt(ns + "." +
+        FairCallQueue.IPC_CALLQUEUE_PRIORITY_LEVELS_KEY, 0);
+    if (retval == 0) { // No FCQ priority level configured
+      retval = conf.getInt(ns + "." +
+          CommonConfigurationKeys.IPC_SCHEDULER_PRIORITY_LEVELS_KEY,
+          CommonConfigurationKeys.IPC_SCHEDULER_PRIORITY_LEVELS_DEFAULT_KEY);
+    } else {
+      LOG.warn(ns + "." + FairCallQueue.IPC_CALLQUEUE_PRIORITY_LEVELS_KEY +
+          " is deprecated. Please use " + ns + "." +
+          CommonConfigurationKeys.IPC_SCHEDULER_PRIORITY_LEVELS_KEY + ".");
+    }
+    if(retval < 1) {
+      throw new IllegalArgumentException("numLevels must be at least 1");
+    }
+    return retval;
+  }
+
+  /**
+      Class<? extends RpcScheduler> schedulerClass,
-    BlockingQueue<E> newQ = createCallQueueInstance(queueClassToUse, maxSize,
-      ns, conf);
+    int priorityLevels = parseNumLevels(ns, conf);
+    RpcScheduler newScheduler = createScheduler(schedulerClass, priorityLevels,
+        ns, conf);
+    BlockingQueue<E> newQ = createCallQueueInstance(queueClassToUse,
+        priorityLevels, maxSize, ns, conf);
+    this.scheduler = newScheduler;
+

INS26 INS40 INS31 INS23 INS31 INS31 INS31 INS31 INS31 INS79 INS83 INS74 INS42 INS44 INS8 INS83 INS43 INS59 INS44 INS83 INS83 INS73 INS43 INS42 INS44 INS44 INS44 INS44 INS8 INS44 INS39 INS42 INS44 INS8 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS39 INS42 INS44 INS8 INS29 INS79 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS44 INS42 INS45 INS43 INS76 INS74 INS42 INS41 INS42 INS42 INS74 INS42 INS60 INS21 INS42 INS43 INS42 INS74 INS42 INS39 INS42 INS43 INS42 INS43 INS42 MOV54 INS54 INS54 INS53 INS39 INS42 INS54 INS43 INS42 INS41 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS21 INS43 INS42 INS41 INS65 INS65 INS42 INS45 INS43 INS42 INS43 INS42 INS60 INS25 INS25 INS41 INS74 INS42 INS60 INS60 INS21 INS42 INS43 INS43 INS76 INS11 INS43 INS76 INS39 INS59 INS7 INS42 INS43 INS43 INS42 INS42 INS8 INS12 INS12 INS12 INS8 INS12 INS12 INS12 INS14 INS8 INS12 INS12 INS12 INS42 INS32 INS42 INS32 INS42 INS32 INS66 INS66 INS42 INS66 INS42 INS42 INS39 INS59 INS27 INS8 INS8 INS27 INS8 INS42 INS43 INS76 INS39 INS59 INS43 INS59 INS7 INS42 INS42 INS74 INS42 INS42 INS43 INS42 INS32 INS22 INS32 INS42 INS42 INS60 INS41 INS44 INS8 INS44 INS8 INS44 INS8 INS60 INS41 INS44 INS8 INS44 INS8 INS44 INS8 INS43 INS27 INS60 INS41 INS44 INS8 INS44 INS8 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS21 INS21 INS42 INS34 INS53 INS42 INS43 INS42 INS32 INS42 INS42 INS32 INS22 INS42 INS43 INS76 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 INS45 INS42 INS74 INS59 INS32 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS74 INS59 INS32 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS42 INS32 INS45 INS74 INS59 INS32 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS42 INS42 INS27 INS34 INS7 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS43 UPD42 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS45 INS40 INS42 INS32 INS42 INS42 INS27 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS57 INS43 INS27 INS32 INS42 INS42 INS42 INS42 INS43 INS27 INS32 INS42 INS42 INS42 INS42 INS57 INS57 INS57 INS57 INS43 INS27 INS32 INS42 INS42 INS27 INS40 INS42 INS45 INS40 INS45 INS42 INS45 INS40 INS45 INS42 INS39 INS42 INS32 INS45 INS42 INS42 INS42 INS32 INS45 INS42 INS42 INS39 INS39 INS43 INS43 INS42 INS32 INS45 INS42 INS42 INS42 INS45 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42
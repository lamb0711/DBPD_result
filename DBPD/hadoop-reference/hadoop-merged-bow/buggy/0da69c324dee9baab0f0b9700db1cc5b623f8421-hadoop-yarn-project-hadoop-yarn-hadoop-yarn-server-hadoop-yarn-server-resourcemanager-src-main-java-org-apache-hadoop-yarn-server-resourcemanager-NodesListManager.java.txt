YARN-4676. Automatic and Asynchronous Decommissioning Nodes Status Tracking. Contributed by Diniel Zhi.
(cherry picked from commit d464483bf7f0b3e3be3ba32cd6c3eee546747ab5)

Conflicts:

	hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java
	hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNode.java
	hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java

+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
-import java.util.Map;
-import java.util.Iterator;
+import org.apache.hadoop.util.StringUtils;
+import org.apache.hadoop.yarn.server.resourcemanager.rmnode.RMNodeDecommissioningEvent;
-
-import com.google.common.annotations.VisibleForTesting;
+import com.google.common.annotations.VisibleForTesting;
+
-    
-    LOG.debug("hostsReader: in=" + conf.get(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH, 
+
+    LOG.debug("hostsReader: in=" +
+        conf.get(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH,
-        conf.get(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH, 
+        conf.get(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH,
-  public void refreshNodes(Configuration yarnConf) throws IOException,
-      YarnException {
-    refreshHostsReader(yarnConf);
-
-    for (NodeId nodeId: rmContext.getRMNodes().keySet()) {
-      if (!isValidNode(nodeId.getHost())) {
-        RMNodeEventType nodeEventType = isUntrackedNode(nodeId.getHost()) ?
-            RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;
-        this.rmContext.getDispatcher().getEventHandler().handle(
-            new RMNodeEvent(nodeId, nodeEventType));
-      }
-    }
-    updateInactiveNodes();
+  public void refreshNodes(Configuration yarnConf)
+      throws IOException, YarnException {
+    refreshNodes(yarnConf, false);
-  private void refreshHostsReader(Configuration yarnConf) throws IOException,
-      YarnException {
+  public void refreshNodes(Configuration yarnConf, boolean graceful)
+      throws IOException, YarnException {
+    refreshHostsReader(yarnConf, graceful, null);
+  }
+
+  private void refreshHostsReader(
+      Configuration yarnConf, boolean graceful, Integer timeout)
+          throws IOException, YarnException {
+    LOG.info("refreshNodes excludesFile " + excludesFile);
+
+    LOG.info("hostsReader include:{" +
+        StringUtils.join(",", hostsReader.getHosts()) +
+        "} exclude:{" +
+        StringUtils.join(",", hostsReader.getExcludedHosts()) + "}");
+
+    handleExcludeNodeList(graceful, timeout);
+  // Handle excluded nodes based on following rules:
+  // Recommission DECOMMISSIONED or DECOMMISSIONING nodes no longer excluded;
+  // Gracefully decommission excluded nodes that are not already
+  // DECOMMISSIONED nor DECOMMISSIONING; Take no action for excluded nodes
+  // that are already DECOMMISSIONED or DECOMMISSIONING.
+  private void handleExcludeNodeList(boolean graceful, Integer timeout) {
+    // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.
+    List<RMNode> nodesToRecom = new ArrayList<RMNode>();
+
+    // Nodes need to be decommissioned (graceful or forceful);
+    List<RMNode> nodesToDecom = new ArrayList<RMNode>();
+
+    Set<String> includes = new HashSet<String>();
+    Map<String, Integer> excludes = new HashMap<String, Integer>();
+    hostsReader.getHostDetails(includes, excludes);
+
+    for (RMNode n : this.rmContext.getRMNodes().values()) {
+      NodeState s = n.getState();
+      // An invalid node (either due to explicit exclude or not include)
+      // should be excluded.
+      boolean isExcluded = !isValidNode(
+          n.getHostName(), includes, excludes.keySet());
+      String nodeStr = "node " + n.getNodeID() + " with state " + s;
+      if (!isExcluded) {
+        // Note that no action is needed for DECOMMISSIONED node.
+        if (s == NodeState.DECOMMISSIONING) {
+          LOG.info("Recommission " + nodeStr);
+          nodesToRecom.add(n);
+        }
+        // Otherwise no-action needed.
+      } else {
+        // exclude is true.
+        if (graceful) {
+          // Use per node timeout if exist otherwise the request timeout.
+          Integer timeoutToUse = (excludes.get(n.getHostName()) != null)?
+              excludes.get(n.getHostName()) : timeout;
+          if (s != NodeState.DECOMMISSIONED &&
+              s != NodeState.DECOMMISSIONING) {
+            LOG.info("Gracefully decommission " + nodeStr);
+            nodesToDecom.add(n);
+          } else if (s == NodeState.DECOMMISSIONING &&
+                     !Objects.equals(n.getDecommissioningTimeout(),
+                         timeoutToUse)) {
+            LOG.info("Update " + nodeStr + " timeout to be " + timeoutToUse);
+            nodesToDecom.add(n);
+          } else {
+            LOG.info("No action for " + nodeStr);
+          }
+        } else {
+          if (s != NodeState.DECOMMISSIONED) {
+            LOG.info("Forcefully decommission " + nodeStr);
+            nodesToDecom.add(n);
+          }
+        }
+      }
+    }
+
+    for (RMNode n : nodesToRecom) {
+      RMNodeEvent e = new RMNodeEvent(
+          n.getNodeID(), RMNodeEventType.RECOMMISSION);
+      this.rmContext.getDispatcher().getEventHandler().handle(e);
+    }
+
+    for (RMNode n : nodesToDecom) {
+      RMNodeEvent e;
+      if (graceful) {
+        Integer timeoutToUse = (excludes.get(n.getHostName()) != null)?
+            excludes.get(n.getHostName()) : timeout;
+        e = new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);
+      } else {
+        RMNodeEventType eventType = isUntrackedNode(n.getHostName())?
+            RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;
+        e = new RMNodeEvent(n.getNodeID(), eventType);
+      }
+      this.rmContext.getDispatcher().getEventHandler().handle(e);
+    }
+
+    updateInactiveNodes();
+  }
+
-    String ip = resolver.resolve(hostName);
+    return isValidNode(hostName, hostsList, excludeList);
+  }
+  private boolean isValidNode(
+      String hostName, Set<String> hostsList, Set<String> excludeList) {
+    String ip = resolver.resolve(hostName);
-   * @param conf
+   * @param yarnConf
+   * @param timeout decommission timeout, null means default timeout.
-  public void refreshNodesGracefully(Configuration conf) throws IOException,
-      YarnException {
-    refreshHostsReader(conf);
-    for (Entry<NodeId, RMNode> entry : rmContext.getRMNodes().entrySet()) {
-      NodeId nodeId = entry.getKey();
-      if (!isValidNode(nodeId.getHost())) {
-        RMNodeEventType nodeEventType = isUntrackedNode(nodeId.getHost()) ?
-            RMNodeEventType.SHUTDOWN : RMNodeEventType.GRACEFUL_DECOMMISSION;
-        this.rmContext.getDispatcher().getEventHandler().handle(
-            new RMNodeEvent(nodeId, nodeEventType));
-      } else {
-        // Recommissioning the nodes
-        if (entry.getValue().getState() == NodeState.DECOMMISSIONING) {
-          this.rmContext.getDispatcher().getEventHandler()
-              .handle(new RMNodeEvent(nodeId, RMNodeEventType.RECOMMISSION));
-        }
-      }
-    }
-    updateInactiveNodes();
+  public void refreshNodesGracefully(Configuration yarnConf, Integer timeout)
+      throws IOException, YarnException {
+    refreshHostsReader(yarnConf, true, timeout);
-}
+}

MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 MOV83 MOV39 UPD42 MOV42 MOV44 INS44 INS43 INS43 INS8 INS44 INS44 INS83 INS39 INS42 INS44 INS44 INS8 INS8 INS83 INS39 INS42 INS44 INS44 INS44 MOV8 MOV29 INS83 INS39 INS42 INS44 INS44 MOV43 MOV43 INS8 UPD42 INS39 INS42 INS42 INS42 MOV21 INS39 INS42 INS43 INS42 INS21 INS21 INS21 INS39 INS42 INS43 INS42 INS60 INS60 INS60 INS60 INS21 INS70 MOV70 INS70 MOV21 MOV60 MOV60 MOV21 INS41 INS43 INS42 INS74 INS42 INS74 INS42 INS65 INS43 INS42 INS43 INS42 MOV21 INS42 INS32 INS32 INS32 INS42 INS74 INS59 INS74 INS59 INS74 INS59 INS74 INS59 INS32 INS44 MOV32 INS8 INS42 MOV8 INS44 INS42 INS8 INS32 INS42 INS43 INS43 INS43 INS43 UPD42 INS42 INS66 INS42 INS42 UPD42 INS9 UPD42 INS42 INS33 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS42 UPD43 MOV43 UPD43 MOV43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS42 UPD42 MOV60 INS60 INS60 INS25 UPD43 UPD42 INS43 INS42 INS60 MOV25 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS9 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS45 UPD42 UPD42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS42 INS74 INS42 INS22 UPD43 INS39 INS59 INS43 INS59 INS38 INS8 INS8 UPD42 MOV43 INS42 MOV43 INS59 INS42 INS8 INS8 INS42 INS42 INS45 INS32 INS42 INS42 INS45 INS32 INS43 INS43 INS43 MOV43 INS43 INS43 INS43 INS43 INS43 INS52 INS42 UPD42 UPD42 INS42 INS38 INS42 INS42 INS27 INS42 INS25 INS25 UPD42 INS14 INS42 INS42 INS60 INS21 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV32 INS45 INS32 INS45 INS42 INS27 INS8 INS42 MOV8 INS8 INS43 INS32 INS40 INS43 INS59 INS7 MOV43 INS59 INS7 INS42 INS32 INS42 INS42 INS42 INS40 INS21 INS21 INS25 INS25 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS16 INS42 INS14 INS42 INS16 INS42 INS14 UPD42 UPD42 INS42 INS42 INS32 INS32 UPD43 INS27 INS8 INS25 INS27 INS8 INS36 INS32 INS42 INS43 INS32 INS42 INS32 INS40 INS40 MOV43 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 UPD42 UPD42 INS27 INS27 INS21 INS21 INS27 INS8 INS8 INS42 INS40 INS21 INS21 INS27 INS42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS36 INS32 INS42 INS42 INS40 INS42 INS40 INS32 INS32 INS27 INS38 INS21 INS21 INS21 INS32 INS32 MOV32 INS33 INS42 UPD42 MOV42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS40 INS32 INS32 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS33 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS27 INS45 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 MOV32 INS42 INS42 INS45 INS42 INS45 INS42 INS45 INS42 UPD42 UPD42 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL32 DEL40 DEL40 DEL16 DEL42 DEL42 DEL14 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL25 DEL8 DEL32 DEL40 DEL27 DEL52 DEL42 DEL22 DEL32 DEL32 DEL42 DEL42 DEL40 DEL14 DEL32 DEL21 DEL8 DEL42 DEL42 DEL14 DEL74 DEL42 DEL44 DEL38 DEL8 DEL25 DEL8 DEL70 DEL8 DEL31
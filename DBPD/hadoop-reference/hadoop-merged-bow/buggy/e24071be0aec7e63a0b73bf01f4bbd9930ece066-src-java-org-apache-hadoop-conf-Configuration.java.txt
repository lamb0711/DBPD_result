HADOOP-6105. Adds support for automatically handling deprecation of configuration keys. Contributed by V.V.Chaitanya Krishna.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@812078 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.atomic.AtomicBoolean;
+  /**
+   * Class to keep the information about the keys which replace the deprecated
+   * ones.
+   * 
+   * This class stores the new keys which replace the deprecated keys and also
+   * gives a provision to have a custom message for each of the deprecated key
+   * that is being replaced. It also provides method to get the appropriate
+   * warning message which can be logged whenever the deprecated key is used.
+   */
+  private static class DeprecatedKeyInfo {
+    private String[] newKeys;
+    private String customMessage;
+    private boolean accessed;
+    DeprecatedKeyInfo(String[] newKeys, String customMessage) {
+      this.newKeys = newKeys;
+      this.customMessage = customMessage;
+      accessed = false;
+    }
+    DeprecatedKeyInfo(String[] newKeys) {
+      this(newKeys, null);
+    }
+
+    /**
+     * Method to provide the warning message. It gives the custom message if
+     * non-null, and default message otherwise.
+     * @param key the associated deprecated key.
+     * @return message that is to be logged when a deprecated key is used.
+     */
+    private final String getWarningMessage(String key) {
+      String warningMessage;
+      if(customMessage == null) {
+        StringBuilder message = new StringBuilder(key);
+        String deprecatedKeySuffix = " is deprecated. Instead, use ";
+        message.append(deprecatedKeySuffix);
+        for (int i = 0; i < newKeys.length; i++) {
+          message.append(newKeys[i]);
+          if(i != newKeys.length-1) {
+            message.append(", ");
+          }
+        }
+        warningMessage = message.toString();
+      }
+      else {
+        warningMessage = customMessage;
+      }
+      accessed = true;
+      return warningMessage;
+    }
+  }
+  
+  /**
+   * Stores the deprecated keys, the new keys which replace the deprecated keys
+   * and custom message(if any provided).
+   */
+  private static Map<String, DeprecatedKeyInfo> deprecatedKeyMap = 
+    new HashMap<String, DeprecatedKeyInfo>();
+  
+  /**
+   * Adds the deprecated key to the deprecation map.
+   * It does not override any existing entries in the deprecation map.
+   * This is to be used only by the developers in order to add deprecation of
+   * keys, and attempts to call this method after loading resources once,
+   * would lead to <tt>UnsupportedOperationException</tt>
+   * @param key
+   * @param newKeys
+   * @param customMessage
+   */
+  public synchronized static void addDeprecation(String key, String[] newKeys,
+      String customMessage) {
+    if (key == null || key.length() == 0 ||
+        newKeys == null || newKeys.length == 0) {
+      throw new IllegalArgumentException();
+    }
+    if (!isDeprecated(key)) {
+      DeprecatedKeyInfo newKeyInfo;
+      if (customMessage == null) {
+        newKeyInfo = new DeprecatedKeyInfo(newKeys);
+      }
+      else {
+        newKeyInfo = new DeprecatedKeyInfo(newKeys, customMessage);
+      }
+      deprecatedKeyMap.put(key, newKeyInfo);
+    }
+  }
+
+  /**
+   * Adds the deprecated key to the deprecation map when no custom message
+   * is provided.
+   * It does not override any existing entries in the deprecation map.
+   * This is to be used only by the developers in order to add deprecation of
+   * keys, and attempts to call this method after loading resources once,
+   * would lead to <tt>UnsupportedOperationException</tt>
+   * 
+   * @param key Key that is to be deprecated
+   * @param newKeys list of keys that take up the values of deprecated key
+   */
+  public synchronized static void addDeprecation(String key, String[] newKeys) {
+    addDeprecation(key, newKeys, null);
+  }
+  
+  /**
+   * checks whether the given <code>key</code> is deprecated.
+   * 
+   * @param key the parameter which is to be checked for deprecation
+   * @return <code>true</code> if the key is deprecated and 
+   *         <code>false</code> otherwise.
+   */
+  private static boolean isDeprecated(String key) {
+    return deprecatedKeyMap.containsKey(key);
+  }
+ 
+  /**
+   * Checks for the presence of the property <code>name</code> in the
+   * deprecation map. Returns the first of the list of new keys if present
+   * in the deprecation map or the <code>name</code> itself.
+   * @param name the property name
+   * @return the first property in the list of properties mapping
+   *         the <code>name</code> or the <code>name</code> itself.
+   */
+  private String handleDeprecation(String name) {
+    if (isDeprecated(name)) {
+      DeprecatedKeyInfo keyInfo = deprecatedKeyMap.get(name);
+      if (!keyInfo.accessed) {
+        LOG.warn(keyInfo.getWarningMessage(name));
+      }
+      for (String newKey : keyInfo.newKeys) {
+        if(newKey != null) {
+          name = newKey;
+          break;
+        }
+      }
+    }
+    return name;
+  }
+  
-   * no such property exists.
+   * no such property exists. If the key is deprecated, it returns the value of
+   * the first key which replaces the deprecated key and is not null
-   * @return the value of the <code>name</code> property, 
+   * @return the value of the <code>name</code> or its replacing property, 
+    name = handleDeprecation(name);
-   * <a href="#VariableExpansion">variable expansion</a>.
+   * <a href="#VariableExpansion">variable expansion</a>.If the key is 
+   * deprecated, it returns the value of the first key which replaces 
+   * the deprecated key and is not null.
-   * @return the value of the <code>name</code> property, 
-   *         or null if no such property exists.
+   * @return the value of the <code>name</code> property or 
+   *         its replacing property and null if no such property exists.
+    name = handleDeprecation(name);
-   * Set the <code>value</code> of the <code>name</code> property.
+   * Set the <code>value</code> of the <code>name</code> property. If 
+   * <code>name</code> is deprecated, it sets the <code>value</code> to the keys
+   * that replace the deprecated key.
-    getOverlay().setProperty(name, value);
-    getProps().setProperty(name, value);
+    if (deprecatedKeyMap.isEmpty()) {
+      getProps();
+    }
+    if (!isDeprecated(name)) {
+      getOverlay().setProperty(name, value);
+      getProps().setProperty(name, value);
+    }
+    else {
+      DeprecatedKeyInfo keyInfo = deprecatedKeyMap.get(name);
+      LOG.warn(keyInfo.getWarningMessage(name));
+      for (String newKey : keyInfo.newKeys) {
+        getOverlay().setProperty(newKey, value);
+        getProps().setProperty(newKey, value);
+      }
+    }
-   * Get the value of the <code>name</code> property. If no such property 
-   * exists, then <code>defaultValue</code> is returned.
+   * Get the value of the <code>name</code>. If the key is deprecated,
+   * it returns the value of the first key which replaces the deprecated key
+   * and is not null.
+   * If no such property exists,
+   * then <code>defaultValue</code> is returned.
+    name = handleDeprecation(name);
+    // process for deprecation.
+    processDeprecation();
+  }
+  
+  /**
+   * Flag to ensure that the classes mentioned in the value of the property
+   * <code>hadoop.conf.extra.classes</code> are loaded only once for
+   * all instances of <code>Configuration</code>
+   */
+  private static AtomicBoolean loadedDeprecation = new AtomicBoolean(false);
+  
+  private static final String extraConfKey = "hadoop.conf.extra.classes";
+
+  /**
+   * adds all the deprecations to the deprecatedKeyMap and updates the values of
+   * the appropriate keys
+   */
+  private void processDeprecation() {
+    populateDeprecationMapping();
+    processDeprecatedKeys();
+  }
+  
+  /**
+   * Loads all the classes in mapred and hdfs that extend Configuration and that
+   * have deprecations to be added into deprecatedKeyMap
+   */
+  private synchronized void populateDeprecationMapping() {
+    if (!loadedDeprecation.get()) {
+      // load classes from mapred and hdfs which extend Configuration and have 
+      // deprecations added in their static blocks
+      String classnames = substituteVars(properties.getProperty(extraConfKey));
+      if (classnames == null) {
+        return;
+      }
+      String[] classes = StringUtils.getStrings(classnames);
+      for (String className : classes) {
+        try {
+          Class.forName(className);
+        } catch (ClassNotFoundException e) {
+          LOG.warn(className + " is not in the classpath");
+        }
+      }
+      // make deprecatedKeyMap unmodifiable in order to prevent changes to 
+      // it in user's code.
+      deprecatedKeyMap = Collections.unmodifiableMap(deprecatedKeyMap);
+      // ensure that deprecation processing is done only once for all 
+      // instances of this object
+      loadedDeprecation.set(true);
+    }
+  /**
+   * Updates the keys that are replacing the deprecated keys and removes the 
+   * deprecated keys from memory.
+   */
+  private void processDeprecatedKeys() {
+    for (Map.Entry<String, DeprecatedKeyInfo> item : 
+      deprecatedKeyMap.entrySet()) {
+      if (!properties.containsKey(item.getKey())) {
+        continue;
+      }
+      String oldKey = item.getKey();
+      deprecatedKeyMap.get(oldKey).accessed = false;
+      setDeprecatedValue(oldKey, properties.getProperty(oldKey),
+          finalParameters.contains(oldKey));
+      properties.remove(oldKey);
+      if (finalParameters.contains(oldKey)) {
+        finalParameters.remove(oldKey);
+      }
+      if (storeResource) {
+        updatingResource.remove(oldKey);
+      }
+    }
+  }
+  
+  /**
+   * Sets the deprecated key's value to the associated mapped keys
+   * @param attr the deprecated key
+   * @param value the value corresponding to the deprecated key
+   * @param finalParameter flag to indicate if <code>attr</code> is
+   *        marked as final
+   */
+  private void setDeprecatedValue(String attr,
+      String value, boolean finalParameter) {
+    DeprecatedKeyInfo keyInfo = deprecatedKeyMap.get(attr);
+    for (String key:keyInfo.newKeys) {
+      // update replacing keys with deprecated key's value in all cases,
+      // except when the replacing key is already set to final
+      // and finalParameter is false
+      if (finalParameters.contains(key) && !finalParameter) {
+        LOG.warn("An attempt to override final parameter: "+key
+            +";  Ignoring.");
+        continue;
+      }
+      properties.setProperty(key, value);
+      if (storeResource) {
+        updatingResource.put(key, updatingResource.get(attr));
+      }
+      if (finalParameter) {
+        finalParameters.add(key);
+      }
+    }
+  }
+  

INS26 INS40 INS55 INS23 INS31 INS31 INS31 INS31 INS31 INS23 INS23 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS31 INS31 INS31 INS29 INS83 INS83 INS74 INS59 INS29 INS83 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS29 MOV83 MOV43 MOV42 MOV44 MOV8 INS8 INS29 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS65 INS83 INS5 INS59 INS83 INS43 INS59 INS83 INS39 INS59 INS42 INS44 INS44 INS8 INS42 INS44 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS65 INS43 INS43 INS43 INS42 INS14 INS65 INS65 INS65 INS65 INS43 INS42 INS5 INS42 INS43 INS42 INS25 INS25 INS65 INS65 INS65 INS43 INS42 INS5 INS42 INS21 INS65 INS65 INS65 INS43 INS42 INS41 MOV65 MOV65 INS65 INS42 INS43 INS42 INS25 INS41 INS65 INS21 INS65 MOV65 MOV65 INS21 INS25 INS25 INS21 INS21 INS65 INS42 INS42 INS14 INS42 INS42 INS45 INS65 INS21 INS21 INS65 INS25 INS65 INS70 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS60 INS70 INS66 INS66 INS66 INS66 INS66 INS66 INS43 INS85 INS42 INS42 INS42 INS42 INS5 INS42 INS43 INS42 INS21 INS21 INS21 INS5 INS42 INS17 INS65 INS65 INS65 INS42 INS43 INS42 INS60 INS25 INS21 INS41 INS66 INS66 INS42 INS42 INS42 INS74 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS27 INS8 INS38 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS85 INS32 INS66 INS42 INS66 INS66 INS66 INS42 INS32 UPD66 INS66 UPD66 UPD66 INS66 INS66 INS42 INS32 INS8 INS42 UPD66 INS66 INS42 INS66 UPD66 INS7 INS66 INS66 INS66 INS66 UPD66 UPD66 INS7 UPD66 INS66 INS66 INS32 INS8 INS38 MOV8 INS8 UPD66 INS66 INS66 INS66 UPD66 INS7 INS32 INS66 INS66 INS66 INS43 INS9 INS66 INS66 INS32 INS32 INS66 INS66 INS38 INS8 INS66 INS66 INS44 INS32 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS59 INS44 INS40 INS8 INS42 INS43 INS85 INS42 INS7 INS7 INS7 INS43 INS85 INS42 INS33 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS59 INS27 INS8 INS8 INS7 INS42 INS43 INS43 INS43 INS42 INS27 INS27 INS53 INS32 INS60 INS25 INS21 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS70 INS42 INS32 INS42 INS32 INS42 INS42 INS21 INS32 INS60 INS21 INS70 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS60 INS25 INS60 INS70 INS21 INS21 INS74 INS42 INS42 INS42 INS25 INS60 INS21 INS21 INS21 INS25 INS25 INS42 INS42 INS32 INS43 INS42 INS25 INS21 INS25 INS25 INS42 INS22 INS42 INS22 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS33 INS60 INS60 INS21 INS24 INS21 INS21 INS42 INS9 INS42 INS42 INS42 INS27 INS27 INS40 INS34 INS14 INS42 INS42 INS43 INS59 INS27 INS8 INS8 INS32 INS43 INS59 INS38 INS8 INS44 INS40 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS59 INS32 INS44 INS40 INS8 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS5 INS59 INS44 INS42 INS8 INS7 INS32 INS43 INS43 INS43 INS38 INS8 INS43 INS59 INS7 INS32 INS32 INS32 INS8 INS42 INS8 INS42 INS42 INS42 INS42 INS27 INS8 INS32 INS42 INS8 INS42 INS8 INS52 INS42 INS52 INS42 INS43 INS59 INS43 INS59 INS32 INS58 INS27 INS37 INS8 INS7 INS7 INS27 INS27 INS42 INS33 INS43 INS42 INS42 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS21 INS43 INS42 INS25 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS42 INS21 INS21 INS42 INS42 INS32 INS42 INS33 INS41 INS43 INS85 INS42 INS32 INS43 INS42 INS54 INS42 INS32 INS42 INS42 INS9 INS40 INS42 INS42 INS32 INS18 INS42 INS42 INS32 INS22 INS9 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS32 INS38 INS21 INS18 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS42 INS39 INS59 INS42 INS40 INS42 INS21 INS25 INS42 INS32 INS42 INS42 INS42 INS33 INS32 INS34 INS42 INS7 INS7 INS42 INS42 INS42 INS32 INS42 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS8 INS12 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS43 INS42 INS42 INS34 INS32 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS32 INS42 INS33 INS21 INS10 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS27 INS21 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS32 INS43 INS42 INS21 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS40 INS34 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS27 INS42 INS45 DEL29 DEL31
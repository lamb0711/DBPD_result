AVRO-6422. Make RPC backend plugable.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@889889 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.logging.*;
+
-public class AvroRpc {
+class AvroRpcEngine implements RpcEngine {
+  private static final Log LOG = LogFactory.getLog(RPC.class);
+
+  // the implementation we tunnel through
+  private static final RpcEngine ENGINE = new WritableRpcEngine();
+
-      this.tunnel = (TunnelProtocol)RPC.getProxy(TunnelProtocol.class, VERSION,
-                                                 addr, ticket, conf, factory);
+      this.tunnel =
+        (TunnelProtocol)ENGINE.getProxy(TunnelProtocol.class, VERSION,
+                                        addr, ticket, conf, factory);
-    public void close() throws IOException {}
-  }
-    
-  /** Construct a client-side proxy object that implements the named protocol,
-   * talking to a server at the named address. */
-  public static Object getProxy(Class<?> protocol,
-                                InetSocketAddress addr,
-                                Configuration conf)
-    throws IOException {
-    UserGroupInformation ugi = null;
-    try {
-      ugi = UserGroupInformation.login(conf);
-    } catch (LoginException le) {
-      throw new RuntimeException("Couldn't login!");
+    public void close() throws IOException {
+      ENGINE.stopProxy(tunnel);
-    return getProxy(protocol, addr, ugi, conf,
-                    NetUtils.getDefaultSocketFactory(conf));
-  public static Object getProxy
-    (final Class<?> protocol, final InetSocketAddress addr,
-     final UserGroupInformation ticket,
-     final Configuration conf, final SocketFactory factory)
+  public Object getProxy(Class protocol, long clientVersion,
+                         InetSocketAddress addr, UserGroupInformation ticket,
+                         Configuration conf, SocketFactory factory)
-
-      (protocol.getClassLoader(), new Class[] { protocol },
-       new InvocationHandler() {
-         public Object invoke(Object proxy, Method method, Object[] args) 
-           throws Throwable {
-           return new ReflectRequestor
-             (protocol,
-              new ClientTransceiver(addr, ticket, conf, factory))
-             .invoke(proxy, method, args);
-         }
-       });
+      (protocol.getClassLoader(),
+       new Class[] { protocol },
+       new Invoker(protocol, addr, ticket, conf, factory));
+  }
+
+  /** Stop this proxy. */
+  public void stopProxy(Object proxy) {
+    try {
+      ((Invoker)Proxy.getInvocationHandler(proxy)).close();
+    } catch (IOException e) {
+      LOG.warn("Error while stopping "+proxy, e);
+    }
+  }
+
+  private static class Invoker implements InvocationHandler, Closeable {
+    private final ClientTransceiver tx;
+    private final ReflectRequestor requestor;
+    public Invoker(Class<?> protocol, InetSocketAddress addr,
+                   UserGroupInformation ticket, Configuration conf,
+                   SocketFactory factory) throws IOException {
+      this.tx = new ClientTransceiver(addr, ticket, conf, factory);
+      this.requestor = new ReflectRequestor(protocol, tx);
+    }
+    @Override public Object invoke(Object proxy, Method method, Object[] args) 
+      throws Throwable {
+      return requestor.invoke(proxy, method, args);
+    }
+    public void close() throws IOException {
+      tx.close();
+    }
-  /** Construct a server for a protocol implementation instance listening on a
-   * port and address. */
-  public static Server getServer(Object impl, String bindAddress, int port,
-                                 Configuration conf) 
-    throws IOException {
-    return RPC.getServer(new TunnelResponder(impl.getClass(), impl),
-                         bindAddress, port, conf);
-
+  public Object[] call(Method method, Object[][] params,
+                       InetSocketAddress[] addrs, UserGroupInformation ticket,
+                       Configuration conf) throws IOException {
+    throw new UnsupportedOperationException();
-  public static RPC.Server getServer(Object impl, String bindAddress, int port,
-                                     int numHandlers, boolean verbose,
-                                     Configuration conf) 
-    throws IOException {
-    return RPC.getServer(new TunnelResponder(impl.getClass(), impl),
-                         bindAddress, port, numHandlers, verbose, conf);
+  public RPC.Server getServer(Class iface, Object impl, String bindAddress,
+                              int port, int numHandlers, boolean verbose,
+                              Configuration conf) throws IOException {
+    return ENGINE.getServer(TunnelProtocol.class,
+                            new TunnelResponder(iface, impl),
+                            bindAddress, port, numHandlers, verbose, conf);

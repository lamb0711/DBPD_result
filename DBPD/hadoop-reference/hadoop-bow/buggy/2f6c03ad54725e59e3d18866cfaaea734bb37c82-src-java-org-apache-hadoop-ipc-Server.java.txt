HADOOP-7146. RPC server leaks file descriptors. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1127811 13f79535-47bb-0310-9956-ffa450edef68

-        Selector readSelector = Selector.open();
-        Reader reader = new Reader("Socket Reader #" + (i + 1) + " for port " + port,
-                                   readSelector);
+        Reader reader = new Reader(
+            "Socket Reader #" + (i + 1) + " for port " + port);
-      private Selector readSelector = null;
+      private final Selector readSelector;
-      Reader(String name, Selector readSelector) {
+      Reader(String name) throws IOException {
-        this.readSelector = readSelector;
+
+        this.readSelector = Selector.open();
+      
-        synchronized (this) {
-          while (running) {
-            SelectionKey key = null;
-            try {
-              readSelector.select();
-              while (adding) {
-                this.wait(1000);
-              }              
+        try {
+          doRunLoop();
+        } finally {
+          try {
+            readSelector.close();
+          } catch (IOException ioe) {
+            LOG.error("Error closing read selector in " + this.getName(), ioe);
+          }
+        }
+      }
-              Iterator<SelectionKey> iter = readSelector.selectedKeys().iterator();
-              while (iter.hasNext()) {
-                key = iter.next();
-                iter.remove();
-                if (key.isValid()) {
-                  if (key.isReadable()) {
-                    doRead(key);
-                  }
+      private synchronized void doRunLoop() {
+        while (running) {
+          SelectionKey key = null;
+          try {
+            readSelector.select();
+            while (adding) {
+              this.wait(1000);
+            }              
+
+            Iterator<SelectionKey> iter = readSelector.selectedKeys().iterator();
+            while (iter.hasNext()) {
+              key = iter.next();
+              iter.remove();
+              if (key.isValid()) {
+                if (key.isReadable()) {
+                  doRead(key);
-                key = null;
-            } catch (InterruptedException e) {
-              if (running) {                      // unexpected -- log it
-                LOG.info(getName() + " caught: " +
-                         StringUtils.stringifyException(e));
-              }
-            } catch (IOException ex) {
-              LOG.error("Error in Reader", ex);
+              key = null;
+          } catch (InterruptedException e) {
+            if (running) {                      // unexpected -- log it
+              LOG.info(getName() + " unexpectedly interrupted", e);
+            }
+          } catch (IOException ex) {
+            LOG.error("Error in Reader", ex);
-    private Selector writeSelector;
+    private final Selector writeSelector;
+      try {
+        doRunLoop();
+      } finally {
+        LOG.info("Stopping " + this.getName());
+        try {
+          writeSelector.close();
+        } catch (IOException ioe) {
+          LOG.error("Couldn't close write selector in " + this.getName(), ioe);
+        }
+      }
+    }
+    
+    private void doRunLoop() {
-          LOG.warn("Exception in Responder " + 
-                   StringUtils.stringifyException(e));
+          LOG.warn("Exception in Responder", e);
-      LOG.info("Stopping " + this.getName());
-            LOG.info(getName() + " caught: " +
-                     StringUtils.stringifyException(e));
+            LOG.info(getName() + " unexpectedly interrupted", e);
-          LOG.info(getName() + " caught: " +
-                   StringUtils.stringifyException(e));
+          LOG.info(getName() + " caught an exception", e);

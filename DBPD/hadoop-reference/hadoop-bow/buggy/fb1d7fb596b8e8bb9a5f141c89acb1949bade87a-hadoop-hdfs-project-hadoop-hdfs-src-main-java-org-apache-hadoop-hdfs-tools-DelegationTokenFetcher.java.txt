HDFS-5570. Deprecate hftp / hsftp and replace them with webhdfs / swebhdfs. Contributed by Haohui Mai.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1584100 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.BufferedReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.net.HttpURLConnection;
-import java.net.InetSocketAddress;
-import java.net.URL;
-import org.apache.hadoop.hdfs.server.namenode.CancelDelegationTokenServlet;
-import org.apache.hadoop.hdfs.server.namenode.GetDelegationTokenServlet;
-import org.apache.hadoop.hdfs.server.namenode.RenewDelegationTokenServlet;
-import org.apache.hadoop.hdfs.web.HftpFileSystem;
-import org.apache.hadoop.hdfs.web.HsftpFileSystem;
-import org.apache.hadoop.hdfs.web.URLConnectionFactory;
-import org.apache.hadoop.io.IOUtils;
-import org.apache.hadoop.net.NetUtils;
+
+import org.apache.hadoop.hdfs.web.SWebHdfsFileSystem;
+import org.apache.hadoop.hdfs.web.WebHdfsFileSystem;
-import org.apache.hadoop.security.SecurityUtil;
-import org.apache.hadoop.security.authentication.client.AuthenticationException;
-import com.google.common.base.Charsets;
+import com.google.common.annotations.VisibleForTesting;
-  private static final Log LOG = 
-    LogFactory.getLog(DelegationTokenFetcher.class);
-  private static final String RENEWER = "renewer";
-  private static final String RENEW = "renew";
-  private static final String PRINT = "print";
+  private static final Log LOG = LogFactory
+      .getLog(DelegationTokenFetcher.class);
+  private static final String PRINT = "print";
+  private static final String RENEW = "renew";
+  private static final String RENEWER = "renewer";
-  private static void printUsage(PrintStream err) {
-    err.println("fetchdt retrieves delegation tokens from the NameNode");
-    err.println();
-    err.println("fetchdt <opts> <token file>");
-    err.println("Options:");
-    err.println("  --webservice <url>  Url to contact NN on");
-    err.println("  --renewer <name>    Name of the delegation token renewer");
-    err.println("  --cancel            Cancel the delegation token");
-    err.println("  --renew             Renew the delegation token.  Delegation " 
-    		+ "token must have been fetched using the --renewer <name> option.");
-    err.println("  --print             Print the delegation token");
-    err.println();
-    GenericOptionsParser.printGenericCommandUsage(err);
-    ExitUtil.terminate(1);    
-  }
-
-  private static Collection<Token<?>> readTokens(Path file, Configuration conf)
-      throws IOException {
-    Credentials creds = Credentials.readTokenStorageFile(file, conf);
-    return creds.getAllTokens();
-  }
-    
-    fetcherOptions.addOption(WEBSERVICE, true,
-        "HTTP url to reach the NameNode at");
-    fetcherOptions.addOption(RENEWER, true,
-        "Name of the delegation token renewer");
-    fetcherOptions.addOption(CANCEL, false, "cancel the token");
-    fetcherOptions.addOption(RENEW, false, "renew the token");
-    fetcherOptions.addOption(PRINT, false, "print the token");
-    fetcherOptions.addOption(HELP_SHORT, HELP, false, "print out help information");
+    fetcherOptions
+      .addOption(WEBSERVICE, true, "HTTP url to reach the NameNode at")
+      .addOption(RENEWER, true, "Name of the delegation token renewer")
+      .addOption(CANCEL, false, "cancel the token")
+      .addOption(RENEW, false, "renew the token")
+      .addOption(PRINT, false, "print the token")
+      .addOption(HELP_SHORT, HELP, false, "print out help information");
+
-        fetcherOptions, args);
+            fetcherOptions, args);
-    
-    // get options
+
-        .getOptionValue(WEBSERVICE) : null;
-    final String renewer = cmd.hasOption(RENEWER) ? 
-        cmd.getOptionValue(RENEWER) : null;
+            .getOptionValue(WEBSERVICE) : null;
+    final String renewer = cmd.hasOption(RENEWER) ? cmd.getOptionValue
+            (RENEWER) : null;
-    if (cancel && renew || cancel && print || renew && print || cancel && renew
-        && print) {
+
+    int commandCount = (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);
+    if (commandCount > 1) {
-    final URLConnectionFactory connectionFactory = URLConnectionFactory.DEFAULT_SYSTEM_CONNECTION_FACTORY;
-    UserGroupInformation.getCurrentUser().doAs(
-        new PrivilegedExceptionAction<Object>() {
-          @Override
-          public Object run() throws Exception {
-
-            if (print) {
-              DelegationTokenIdentifier id = new DelegationTokenSecretManager(
-                  0, 0, 0, 0, null).createIdentifier();
-              for (Token<?> token : readTokens(tokenFile, conf)) {
-                DataInputStream in = new DataInputStream(
-                    new ByteArrayInputStream(token.getIdentifier()));
-                id.readFields(in);
-                System.out.println("Token (" + id + ") for " + 
-                                   token.getService());
-              }
-            } else if (cancel) {
-              for(Token<?> token: readTokens(tokenFile, conf)) {
-                if (token.isManaged()) {
-                  token.cancel(conf);
-                  if (LOG.isDebugEnabled()) {
-                    LOG.debug("Cancelled token for " + token.getService());
-                  }
-                }
-              }
-            } else if (renew) {
-              for (Token<?> token : readTokens(tokenFile, conf)) {
-                if (token.isManaged()) {
-                  long result = token.renew(conf);
-                  if (LOG.isDebugEnabled()) {
-                    LOG.debug("Renewed token for " + token.getService()
-                        + " until: " + new Date(result));
-                  }
-                }
-              }
-            } else {
-              // otherwise we are fetching
-              if (webUrl != null) {
-                Credentials creds = getDTfromRemote(connectionFactory, new URI(
-                    webUrl), renewer, null);
-                creds.writeTokenStorageFile(tokenFile, conf);
-                for (Token<?> token : creds.getAllTokens()) {
-                  if(LOG.isDebugEnabled()) {	
-                    LOG.debug("Fetched token via " + webUrl + " for "
-                        + token.getService() + " into " + tokenFile);
-                  }
-                }
-              } else {
-                FileSystem fs = FileSystem.get(conf);
-                Credentials cred = new Credentials();
-                Token<?> tokens[] = fs.addDelegationTokens(renewer, cred);
-                cred.writeTokenStorageFile(tokenFile, conf);
-                if(LOG.isDebugEnabled()) {
-                  for (Token<?> token : tokens) {
-                    LOG.debug("Fetched token for " + token.getService()
-                        + " into " + tokenFile);
-                  }
-                }
-              }
-            }
-            return null;
-          }
-        });
+    UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction<Object>() {
+      @Override
+      public Object run() throws Exception {
+        if (print) {
+          printTokens(conf, tokenFile);
+        } else if (cancel) {
+          cancelTokens(conf, tokenFile);
+        } else if (renew) {
+          renewTokens(conf, tokenFile);
+        } else {
+          // otherwise we are fetching
+          FileSystem fs = getFileSystem(conf, webUrl);
+          saveDelegationToken(conf, fs, renewer, tokenFile);
+        }
+        return null;
+      }
+    });
-  
-  static public Credentials getDTfromRemote(URLConnectionFactory factory,
-      URI nnUri, String renewer, String proxyUser) throws IOException {
-    StringBuilder buf = new StringBuilder(nnUri.toString())
-        .append(GetDelegationTokenServlet.PATH_SPEC);
-    String separator = "?";
-    if (renewer != null) {
-      buf.append("?").append(GetDelegationTokenServlet.RENEWER).append("=")
-          .append(renewer);
-      separator = "&";
-    }
-    if (proxyUser != null) {
-      buf.append(separator).append("doas=").append(proxyUser);
+
+  private static FileSystem getFileSystem(Configuration conf, String url)
+          throws IOException {
+    if (url == null) {
+      return FileSystem.get(conf);
-    boolean isHttps = nnUri.getScheme().equals("https");
+    // For backward compatibility
+    URI fsUri = URI.create(
+            url.replaceFirst("^http://", WebHdfsFileSystem.SCHEME + "://")
+               .replaceFirst("^https://", SWebHdfsFileSystem.SCHEME + "://"));
-    HttpURLConnection conn = null;
-    DataInputStream dis = null;
-    InetSocketAddress serviceAddr = NetUtils.createSocketAddr(nnUri
-        .getAuthority());
+    return FileSystem.get(fsUri, conf);
+  }
-    try {
-      if(LOG.isDebugEnabled()) {
-        LOG.debug("Retrieving token from: " + buf);
-      }
-
-      conn = run(factory, new URL(buf.toString()));
-      InputStream in = conn.getInputStream();
-      Credentials ts = new Credentials();
-      dis = new DataInputStream(in);
-      ts.readFields(dis);
-      for (Token<?> token : ts.getAllTokens()) {
-        token.setKind(isHttps ? HsftpFileSystem.TOKEN_KIND : HftpFileSystem.TOKEN_KIND);
-        SecurityUtil.setTokenService(token, serviceAddr);
-      }
-      return ts;
-    } catch (Exception e) {
-      throw new IOException("Unable to obtain remote token", e);
-    } finally {
-      IOUtils.cleanup(LOG, dis);
-      if (conn != null) {
-        conn.disconnect();
+  @VisibleForTesting
+  static void cancelTokens(final Configuration conf, final Path tokenFile)
+          throws IOException, InterruptedException {
+    for (Token<?> token : readTokens(tokenFile, conf)) {
+      if (token.isManaged()) {
+        token.cancel(conf);
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Cancelled token for " + token.getService());
+        }
-  /**
-   * Cancel a Delegation Token.
-   * @param nnAddr the NameNode's address
-   * @param tok the token to cancel
-   * @throws IOException
-   * @throws AuthenticationException
-   */
-  static public void cancelDelegationToken(URLConnectionFactory factory,
-      URI nnAddr, Token<DelegationTokenIdentifier> tok) throws IOException,
-      AuthenticationException {
-    StringBuilder buf = new StringBuilder(nnAddr.toString())
-        .append(CancelDelegationTokenServlet.PATH_SPEC).append("?")
-        .append(CancelDelegationTokenServlet.TOKEN).append("=")
-        .append(tok.encodeToUrlString());
-    HttpURLConnection conn = run(factory, new URL(buf.toString()));
-    conn.disconnect();
-  }
-
-  /**
-   * Renew a Delegation Token.
-   * @param nnAddr the NameNode's address
-   * @param tok the token to renew
-   * @return the Date that the token will expire next.
-   * @throws IOException
-   * @throws AuthenticationException
-   */
-  static public long renewDelegationToken(URLConnectionFactory factory,
-      URI nnAddr, Token<DelegationTokenIdentifier> tok) throws IOException,
-      AuthenticationException {
-    StringBuilder buf = new StringBuilder(nnAddr.toString())
-        .append(RenewDelegationTokenServlet.PATH_SPEC).append("?")
-        .append(RenewDelegationTokenServlet.TOKEN).append("=")
-        .append(tok.encodeToUrlString());
-
-    HttpURLConnection connection = null;
-    BufferedReader in = null;
-    try {
-      connection = run(factory, new URL(buf.toString()));
-      in = new BufferedReader(new InputStreamReader(
-          connection.getInputStream(), Charsets.UTF_8));
-      long result = Long.parseLong(in.readLine());
-      return result;
-    } catch (IOException ie) {
-      LOG.info("error in renew over HTTP", ie);
-      IOException e = getExceptionFromResponse(connection);
-
-      if (e != null) {
-        LOG.info("rethrowing exception from HTTP request: "
-            + e.getLocalizedMessage());
-        throw e;
-      }
-      throw ie;
-    } finally {
-      IOUtils.cleanup(LOG, in);
-      if (connection != null) {
-        connection.disconnect();
+  @VisibleForTesting
+  static void renewTokens(final Configuration conf, final Path tokenFile)
+          throws IOException, InterruptedException {
+    for (Token<?> token : readTokens(tokenFile, conf)) {
+      if (token.isManaged()) {
+        long result = token.renew(conf);
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Renewed token for " + token.getService() + " until: " +
+                  new Date(result));
+        }
-  // parse the message and extract the name of the exception and the message
-  static private IOException getExceptionFromResponse(HttpURLConnection con) {
-    IOException e = null;
-    String resp;
-    if(con == null) 
-      return null;    
-    
-    try {
-      resp = con.getResponseMessage();
-    } catch (IOException ie) { return null; }
-    if(resp == null || resp.isEmpty())
-      return null;
+  @VisibleForTesting
+  static void saveDelegationToken(Configuration conf, FileSystem fs,
+                                  final String renewer, final Path tokenFile)
+          throws IOException {
+    Token<?> token = fs.getDelegationToken(renewer);
-    String exceptionClass = "", exceptionMsg = "";
-    String[] rs = resp.split(";");
-    if(rs.length < 2)
-      return null;
-    exceptionClass = rs[0];
-    exceptionMsg = rs[1];
-    LOG.info("Error response from HTTP request=" + resp + 
-        ";ec=" + exceptionClass + ";em="+exceptionMsg);
-    
-    if(exceptionClass == null || exceptionClass.isEmpty())
-      return null;
-    
-    // recreate exception objects
-    try {
-      Class<? extends Exception> ec = 
-         Class.forName(exceptionClass).asSubclass(Exception.class);
-      // we are interested in constructor with String arguments
-      java.lang.reflect.Constructor<? extends Exception> constructor =
-          ec.getConstructor (new Class[] {String.class});
+    Credentials cred = new Credentials();
+    cred.addToken(token.getKind(), token);
+    cred.writeTokenStorageFile(tokenFile, conf);
-      // create an instance
-      e =  (IOException) constructor.newInstance (exceptionMsg);
-
-    } catch (Exception ee)  {
-      LOG.warn("failed to create object of this class", ee);
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Fetched token " + fs.getUri() + " for " + token.getService()
+              + " into " + tokenFile);
-    if(e == null)
-      return null;
-    
-    e.setStackTrace(new StackTraceElement[0]); // local stack is not relevant
-    LOG.info("Exception from HTTP response=" + e.getLocalizedMessage());
-    return e;
-  private static HttpURLConnection run(URLConnectionFactory factory, URL url)
-      throws IOException, AuthenticationException {
-    HttpURLConnection conn = null;
-
-    try {
-      conn = (HttpURLConnection) factory.openConnection(url, true);
-      if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {
-        String msg = conn.getResponseMessage();
-
-        throw new IOException("Error when dealing remote token: " + msg);
-      }
-    } catch (IOException ie) {
-      LOG.info("Error when dealing remote token:", ie);
-      IOException e = getExceptionFromResponse(conn);
-
-      if (e != null) {
-        LOG.info("rethrowing exception from HTTP request: "
-            + e.getLocalizedMessage());
-        throw e;
-      }
-      throw ie;
+  private static void printTokens(final Configuration conf,
+                                  final Path tokenFile)
+          throws IOException {
+    DelegationTokenIdentifier id = new DelegationTokenSecretManager(0, 0, 0,
+            0, null).createIdentifier();
+    for (Token<?> token : readTokens(tokenFile, conf)) {
+      DataInputStream in = new DataInputStream(new ByteArrayInputStream(token
+              .getIdentifier()));
+      id.readFields(in);
+      System.out.println("Token (" + id + ") for " + token.getService());
-    return conn;
+  }
+
+  private static void printUsage(PrintStream err) {
+    err.println("fetchdt retrieves delegation tokens from the NameNode");
+    err.println();
+    err.println("fetchdt <opts> <token file>");
+    err.println("Options:");
+    err.println("  --webservice <url>  Url to contact NN on (starts with " +
+            "http:// or https://)");
+    err.println("  --renewer <name>    Name of the delegation token renewer");
+    err.println("  --cancel            Cancel the delegation token");
+    err.println("  --renew             Renew the delegation token.  " +
+            "Delegation " + "token must have been fetched using the --renewer" +
+            " <name> option.");
+    err.println("  --print             Print the delegation token");
+    err.println();
+    GenericOptionsParser.printGenericCommandUsage(err);
+    ExitUtil.terminate(1);
+  }
+
+  private static Collection<Token<?>> readTokens(Path file, Configuration conf)
+          throws IOException {
+    Credentials creds = Credentials.readTokenStorageFile(file, conf);
+    return creds.getAllTokens();

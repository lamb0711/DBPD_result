HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.

-import java.io.DataInputStream;
-import org.apache.hadoop.ipc.ProtobufRpcEngine.RpcResponseWrapper;
-import org.apache.hadoop.ipc.ProtobufRpcEngine.RpcWrapper;
-import org.apache.hadoop.util.ReflectionUtils;
-import com.google.protobuf.CodedOutputStream;
-import com.google.protobuf.Message.Builder;
+  @SuppressWarnings("serial")
-    private void saslReadAndProcess(DataInputStream dis) throws
+    private void saslReadAndProcess(RpcWritable.Buffer buffer) throws
-          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);
+          getMessage(RpcSaslProto.getDefaultInstance(), buffer);
-          new RpcResponseWrapper(message), null, null);
+          RpcWritable.wrap(message), null, null);
-          processOneRpc(data.array());
+          processOneRpc(data);
-    private void processConnectionContext(DataInputStream dis)
+    private void processConnectionContext(RpcWritable.Buffer buffer)
-      connectionContext = decodeProtobufFromStream(
-          IpcConnectionContextProto.newBuilder(), dis);
+      connectionContext = getMessage(IpcConnectionContextProto.getDefaultInstance(), buffer);
-          processOneRpc(unwrappedData.array());
+          processOneRpc(unwrappedData);
-     */    
-    private void processOneRpc(byte[] buf)
+     */
+    private void processOneRpc(ByteBuffer bb)
-        final DataInputStream dis =
-            new DataInputStream(new ByteArrayInputStream(buf));
+        final RpcWritable.Buffer buffer = RpcWritable.Buffer.wrap(bb);
-            decodeProtobufFromStream(RpcRequestHeaderProto.newBuilder(), dis);
+            getMessage(RpcRequestHeaderProto.getDefaultInstance(), buffer);
-        
+
-          processRpcOutOfBandRequest(header, dis);
+          processRpcOutOfBandRequest(header, buffer);
-          processRpcRequest(header, dis);
+          processRpcRequest(header, buffer);
-        DataInputStream dis) throws WrappedRpcServerException,
+        RpcWritable.Buffer buffer) throws WrappedRpcServerException,
-        rpcRequest = ReflectionUtils.newInstance(rpcRequestClass, conf);
-        rpcRequest.readFields(dis);
+        rpcRequest = buffer.newInstance(rpcRequestClass, conf);
-        DataInputStream dis) throws WrappedRpcServerException, IOException,
-        InterruptedException {
+        RpcWritable.Buffer buffer) throws WrappedRpcServerException,
+            IOException, InterruptedException {
-        processConnectionContext(dis);
+        processConnectionContext(buffer);
-        saslReadAndProcess(dis);
+        saslReadAndProcess(buffer);
-    private <T extends Message> T decodeProtobufFromStream(Builder builder,
-        DataInputStream dis) throws WrappedRpcServerException {
+    <T extends Message> T getMessage(Message message,
+        RpcWritable.Buffer buffer) throws WrappedRpcServerException {
-        builder.mergeDelimitedFrom(dis);
-        return (T)builder.build();
+        return (T)buffer.getValue(message);
-        Class<?> protoClass = builder.getDefaultInstanceForType().getClass();
+        Class<?> protoClass = message.getClass();
-    // adjust capacity on estimated length to reduce resizing copies
-    int estimatedLen = header.getSerializedSize();
-    estimatedLen += CodedOutputStream.computeRawVarint32Size(estimatedLen);
-    // if it's not a wrapped protobuf, just let it grow on its own
-    if (rv instanceof RpcWrapper) {
-      estimatedLen += ((RpcWrapper)rv).getLength();
-    }
-    buf.ensureCapacity(estimatedLen);
-    header.writeDelimitedTo(buf);
-    if (rv != null) { // null for exceptions
-      rv.write(buf);
-    }
-    call.setResponse(ByteBuffer.wrap(buf.toByteArray()));
-    // Discard a large buf and reset it back to smaller size
-    // to free up heap.
-    if (buf.capacity() > maxRespSize) {
-      LOG.warn("Large response size " + buf.size() + " for call "
-          + call.toString());
-      buf.setCapacity(INITIAL_RESP_BUF_SIZE);
+    try {
+      RpcWritable.wrap(header).writeTo(buf);
+      if (rv != null) {
+        RpcWritable.wrap(rv).writeTo(buf);
+      }
+      call.setResponse(ByteBuffer.wrap(buf.toByteArray()));
+    } finally {
+      // Discard a large buf and reset it back to smaller size
+      // to free up heap.
+      if (buf.capacity() > maxRespSize) {
+        LOG.warn("Large response size " + buf.size() + " for call "
+            + call.toString());
+        buf.setCapacity(INITIAL_RESP_BUF_SIZE);
+      }
-      setupResponse(call, saslHeader, new RpcResponseWrapper(saslMessage));
+      setupResponse(call, saslHeader, RpcWritable.wrap(saslMessage));

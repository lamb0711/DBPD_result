HDFS-2904. Client support for getting delegation tokens. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1293486 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.URISyntaxException;
+import org.apache.hadoop.hdfs.protocol.ClientProtocol;
+import org.apache.hadoop.hdfs.protocol.HdfsConstants;
+import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;
+import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenSelector;
+import org.apache.hadoop.hdfs.server.protocol.NamenodeProtocol;
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.security.SecurityUtil;
+import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.security.token.Token;
+import static org.apache.hadoop.hdfs.protocol.HdfsConstants.HA_DT_SERVICE_PREFIX;
-  public static <T> FailoverProxyProvider<T> createFailoverProxyProvider(
-      Configuration conf, Class<FailoverProxyProvider<?>> failoverProxyProviderClass,
-      Class xface, URI nameNodeUri) throws IOException {
+  private static <T> FailoverProxyProvider<T> createFailoverProxyProvider(
+      Configuration conf, Class<FailoverProxyProvider<T>> failoverProxyProviderClass,
+      Class<T> xface, URI nameNodeUri) throws IOException {
-      Constructor<FailoverProxyProvider<?>> ctor = failoverProxyProviderClass
+      Constructor<FailoverProxyProvider<T>> ctor = failoverProxyProviderClass
-  public static <T> Class<FailoverProxyProvider<T>> getFailoverProxyProviderClass(
+  private static <T> Class<FailoverProxyProvider<T>> getFailoverProxyProviderClass(
+  
+  /**
+   * @return true if the given nameNodeUri appears to be a logical URI.
+   * This is the case if there is a failover proxy provider configured
+   * for it in the given configuration.
+   */
+  public static boolean isLogicalUri(
+      Configuration conf, URI nameNodeUri) {
+    String host = nameNodeUri.getHost();
+    String configKey = DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + "."
+        + host;
+    return conf.get(configKey) != null;
+  }
-  /** Creates the namenode proxy with the passed Protocol */
+  /**
+   * Creates the namenode proxy with the passed Protocol.
+   * @param conf the configuration containing the required IPC
+   * properties, client failover configurations, etc.
+   * @param nameNodeUri the URI pointing either to a specific NameNode
+   * or to a logical nameservice.
+   * @param xface the IPC interface which should be created
+   * @return an object containing both the proxy and the associated
+   * delegation token service it corresponds to
+   **/
-  public static Object createFailoverProxy(Configuration conf, URI nameNodeUri,
-      Class xface) throws IOException {
-    Class<FailoverProxyProvider<?>> failoverProxyProviderClass = HAUtil
-        .getFailoverProxyProviderClass(conf, nameNodeUri, xface);
-    if (failoverProxyProviderClass != null) {
-      FailoverProxyProvider<?> failoverProxyProvider = HAUtil
+  public static <T> ProxyAndInfo<T> createProxy(
+      Configuration conf, URI nameNodeUri,
+      Class<T> xface) throws IOException {
+    Class<FailoverProxyProvider<T>> failoverProxyProviderClass =
+        HAUtil.getFailoverProxyProviderClass(conf, nameNodeUri, xface);
+
+    if (failoverProxyProviderClass == null) {
+      // Non-HA case
+      return createNonHAProxy(conf, nameNodeUri, xface);
+    } else {
+      // HA case
+      FailoverProxyProvider<T> failoverProxyProvider = HAUtil
-      return RetryProxy.create(xface, failoverProxyProvider, RetryPolicies
+      T proxy = (T) RetryProxy.create(xface, failoverProxyProvider, RetryPolicies
+      
+      Text dtService = buildTokenServiceForLogicalUri(nameNodeUri);
+      return new ProxyAndInfo<T>(proxy, dtService);
-    return null;
+  @SuppressWarnings("unchecked")
+  private static <T> ProxyAndInfo<T> createNonHAProxy(
+      Configuration conf, URI nameNodeUri, Class<T> xface) throws IOException {
+    InetSocketAddress nnAddr = NameNode.getAddress(nameNodeUri);
+    Text dtService = SecurityUtil.buildTokenService(nnAddr);
+
+    if (xface == ClientProtocol.class) {
+      T proxy = (T)DFSUtil.createNamenode(nnAddr, conf);
+      return new ProxyAndInfo<T>(proxy, dtService);
+    } else if (xface == NamenodeProtocol.class) {
+      T proxy = (T) DFSUtil.createNNProxyWithNamenodeProtocol(
+          nnAddr, conf, UserGroupInformation.getCurrentUser());
+      return new ProxyAndInfo<T>(proxy, dtService);
+    } else {
+      throw new AssertionError("Unsupported proxy type: " + xface);
+    }
+  }
+    
+  /**
+   * Parse the HDFS URI out of the provided token.
+   * @throws IOException if the token is invalid
+   */
+  public static URI getServiceUriFromToken(
+      Token<DelegationTokenIdentifier> token)
+      throws IOException {
+    String tokStr = token.getService().toString();
+
+    if (tokStr.startsWith(HA_DT_SERVICE_PREFIX)) {
+      tokStr = tokStr.replaceFirst(HA_DT_SERVICE_PREFIX, "");
+    }
+    
+    try {
+      return new URI(HdfsConstants.HDFS_URI_SCHEME + "://" +
+          tokStr);
+    } catch (URISyntaxException e) {
+      throw new IOException("Invalid token contents: '" +
+          tokStr + "'");
+    }
+  }
+  
+  /**
+   * Get the service name used in the delegation token for the given logical
+   * HA service.
+   * @param uri the logical URI of the cluster
+   * @return the service name
+   */
+  public static Text buildTokenServiceForLogicalUri(URI uri) {
+    return new Text(HA_DT_SERVICE_PREFIX + uri.getHost());
+  }
+  
+  /**
+   * @return true if this token corresponds to a logical nameservice
+   * rather than a specific namenode.
+   */
+  public static boolean isTokenForLogicalUri(
+      Token<DelegationTokenIdentifier> token) {
+    return token.getService().toString().startsWith(HA_DT_SERVICE_PREFIX);
+  }
+  
+  /**
+   * Locate a delegation token associated with the given HA cluster URI, and if
+   * one is found, clone it to also represent the underlying namenode address.
+   * @param ugi the UGI to modify
+   * @param haUri the logical URI for the cluster
+   * @param singleNNAddr one of the NNs in the cluster to which the token
+   * applies
+   */
+  public static void cloneDelegationTokenForLogicalUri(
+      UserGroupInformation ugi, URI haUri,
+      InetSocketAddress singleNNAddr) {
+    Text haService = buildTokenServiceForLogicalUri(haUri);
+    Token<DelegationTokenIdentifier> haToken =
+        DelegationTokenSelector.selectHdfsDelegationToken(haService, ugi);
+    if (haToken == null) {
+      // no token
+      return;
+    }
+    Token<DelegationTokenIdentifier> specificToken =
+        new Token<DelegationTokenIdentifier>(haToken);
+    specificToken.setService(SecurityUtil.buildTokenService(singleNNAddr));
+    ugi.addToken(specificToken);
+    LOG.debug("Mapped HA service delegation token for logical URI " +
+        haUri + " to namenode " + singleNNAddr);
+  }
+  
+  /**
+   * Wrapper for a client proxy as well as its associated service ID.
+   * This is simply used as a tuple-like return type for
+   * {@link HAUtil#createProxy(Configuration, URI, Class)}.
+   */
+  public static class ProxyAndInfo<PROXYTYPE> {
+    private final PROXYTYPE proxy;
+    private final Text dtService;
+    
+    public ProxyAndInfo(PROXYTYPE proxy, Text dtService) {
+      this.proxy = proxy;
+      this.dtService = dtService;
+    }
+    
+    public PROXYTYPE getProxy() {
+      return proxy;
+    }
+    
+    public Text getDelegationTokenService() {
+      return dtService;
+    }
+  }

HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.

-import org.apache.commons.io.output.ByteArrayOutputStream;
+import org.apache.commons.lang.NotImplementedException;
+import com.microsoft.windowsazure.storage.blob.CloudBlob;
+import com.microsoft.windowsazure.storage.blob.PageRange;
+
+import javax.ws.rs.core.UriBuilder;
+import javax.ws.rs.core.UriBuilderException;
-  private final ArrayList<PreExistingContainer> preExistingContainers = new ArrayList<MockStorageInterface.PreExistingContainer>();
+  private final ArrayList<PreExistingContainer> preExistingContainers =
+      new ArrayList<MockStorageInterface.PreExistingContainer>();
+  /**
+   * Utility function used to convert a given URI to a decoded string
+   * representation sent to the backing store. URIs coming as input
+   * to this class will be encoded by the URI class, and we want
+   * the underlying storage to store keys in their original UTF-8 form.
+   */
+  private static String convertUriToDecodedString(URI uri) {
+    try {
+      String result = URIUtil.decode(uri.toString());
+      return result;
+    } catch (URIException e) {
+      throw new AssertionError("Failed to decode URI: " + uri.toString());
+    }
+  }
+
+  private static URI convertKeyToEncodedUri(String key) {
+    try {
+      String encodedKey = URIUtil.encodePath(key);
+      URI uri = new URI(encodedKey);
+      return uri;
+    } catch (URISyntaxException e) {
+      throw new AssertionError("Failed to encode key: " + key);
+    } catch (URIException e) {
+      throw new AssertionError("Failed to encode key: " + key);
+    }
+  }
+
+    @Override
+    public CloudPageBlobWrapper getPageBlobReference(String blobAddressUri)
+        throws URISyntaxException, StorageException {
+      return new MockCloudPageBlobWrapper(new URI(blobAddressUri), null, 0);
+    }
+
-      String fullPrefix = prefix == null ? uri.toString() : new URI(
-          uri.getScheme(), uri.getAuthority(), uri.getPath() + prefix,
-          uri.getQuery(), uri.getFragment()).toString();
-      boolean includeMetadata = listingDetails
-          .contains(BlobListingDetails.METADATA);
+      URI searchUri = null;
+      if (prefix == null) {
+        searchUri = uri;
+      } else {
+        try {
+          searchUri = UriBuilder.fromUri(uri).path(prefix).build();
+        } catch (UriBuilderException e) {
+          throw new AssertionError("Failed to encode path: " + prefix);
+        }
+      }
+
+      String fullPrefix = convertUriToDecodedString(searchUri);
+      boolean includeMetadata = listingDetails.contains(BlobListingDetails.METADATA);
-      for (InMemoryBlockBlobStore.ListBlobEntry current : backingStore
-          .listBlobs(fullPrefix, includeMetadata)) {
+      for (InMemoryBlockBlobStore.ListBlobEntry current : backingStore.listBlobs(
+          fullPrefix, includeMetadata)) {
-          ret.add(new MockCloudBlockBlobWrapper(new URI(current.getKey()),
-              current.getMetadata(), current.getContentLength()));
+          if (current.isPageBlob()) {
+            ret.add(new MockCloudPageBlobWrapper(
+                convertKeyToEncodedUri(current.getKey()),
+                current.getMetadata(),
+                current.getContentLength()));
+          } else {
+          ret.add(new MockCloudBlockBlobWrapper(
+              convertKeyToEncodedUri(current.getKey()),
+              current.getMetadata(),
+              current.getContentLength()));
+          }
-            ret.add(new MockCloudBlobDirectoryWrapper(new URI(directoryName
-                + "/")));
+            ret.add(new MockCloudBlobDirectoryWrapper(new URI(
+                directoryName + "/")));
-      throw new UnsupportedOperationException();
+      throw new NotImplementedException();
-
-  class MockCloudBlockBlobWrapper extends CloudBlockBlobWrapper {
-    private URI uri;
-    private HashMap<String, String> metadata = new HashMap<String, String>();
-    private BlobProperties properties;
+  abstract class MockCloudBlobWrapper implements CloudBlobWrapper {
+    protected final URI uri;
+    protected HashMap<String, String> metadata =
+        new HashMap<String, String>();
+    protected BlobProperties properties;
-    public MockCloudBlockBlobWrapper(URI uri, HashMap<String, String> metadata,
+    protected MockCloudBlobWrapper(URI uri, HashMap<String, String> metadata,
-      this.properties.setLastModified(Calendar.getInstance(
-          TimeZone.getTimeZone("UTC")).getTime());
+      this.properties.setLastModified(
+          Calendar.getInstance(TimeZone.getTimeZone("UTC")).getTime());
-    private void refreshProperties(boolean getMetadata) {
-      if (backingStore.exists(uri.toString())) {
-        byte[] content = backingStore.getContent(uri.toString());
+    protected void refreshProperties(boolean getMetadata) {
+      if (backingStore.exists(convertUriToDecodedString(uri))) {
+        byte[] content = backingStore.getContent(convertUriToDecodedString(uri));
-        properties.setLastModified(Calendar.getInstance(
-            TimeZone.getTimeZone("UTC")).getTime());
+        properties.setLastModified(
+            Calendar.getInstance(TimeZone.getTimeZone("UTC")).getTime());
-          metadata = backingStore.getMetadata(uri.toString());
+          metadata = backingStore.getMetadata(convertUriToDecodedString(uri));
-    public void startCopyFromBlob(CloudBlockBlobWrapper sourceBlob,
+    public void startCopyFromBlob(URI source,
-      backingStore.copy(sourceBlob.getUri().toString(), uri.toString());
-      // it would be best if backingStore.properties.CopyState were tracked
-      // If implemented, update azureNativeFileSystemStore.waitForCopyToComplete
+      backingStore.copy(convertUriToDecodedString(source), convertUriToDecodedString(uri));
+      //TODO: set the backingStore.properties.CopyState and
+      //      update azureNativeFileSystemStore.waitForCopyToComplete
-      return this.properties.getCopyState();
+       return this.properties.getCopyState();
-    public void delete(OperationContext opContext) throws StorageException {
-      backingStore.delete(uri.toString());
+    public void delete(OperationContext opContext, SelfRenewingLease lease)
+        throws StorageException {
+      backingStore.delete(convertUriToDecodedString(uri));
-      return backingStore.exists(uri.toString());
+      return backingStore.exists(convertUriToDecodedString(uri));
-      return new ByteArrayInputStream(backingStore.getContent(uri.toString()));
-    }
-
-    @Override
-    public OutputStream openOutputStream(BlobRequestOptions options,
-        OperationContext opContext) throws StorageException {
-      return backingStore.upload(uri.toString(), metadata);
-    }
-
-    @Override
-    public void upload(InputStream sourceStream, OperationContext opContext)
-        throws StorageException, IOException {
-      ByteArrayOutputStream allContent = new ByteArrayOutputStream();
-      allContent.write(sourceStream);
-      backingStore.setContent(uri.toString(), allContent.toByteArray(),
-          metadata);
-      refreshProperties(false);
-      allContent.close();
+      return new ByteArrayInputStream(
+          backingStore.getContent(convertUriToDecodedString(uri)));
-      backingStore.setContent(uri.toString(),
-          backingStore.getContent(uri.toString()), metadata);
+      backingStore.setMetadata(convertUriToDecodedString(uri), metadata);
-    public void uploadProperties(OperationContext opContext)
+    public void downloadRange(long offset, long length, OutputStream os,
+        BlobRequestOptions options, OperationContext opContext)
-      refreshProperties(false);
+      throw new NotImplementedException();
+    }
+  }
+
+  class MockCloudBlockBlobWrapper extends MockCloudBlobWrapper
+    implements CloudBlockBlobWrapper {
+    public MockCloudBlockBlobWrapper(URI uri, HashMap<String, String> metadata,
+        int length) {
+      super(uri, metadata, length);
+    }
+
+    @Override
+    public OutputStream openOutputStream(BlobRequestOptions options,
+        OperationContext opContext) throws StorageException {
+      return backingStore.uploadBlockBlob(convertUriToDecodedString(uri),
+          metadata);
+    }
+
+    @Override
+    public void setStreamMinimumReadSizeInBytes(int minimumReadSizeBytes) {
+    }
+
+    @Override
+    public void setWriteBlockSizeInBytes(int writeBlockSizeBytes) {
+    }
+
+    @Override
+    public StorageUri getStorageUri() {
+      return null;
+    }
+
+    @Override
+    public void uploadProperties(OperationContext context, SelfRenewingLease lease) {
+    }
+
+    @Override
+    public SelfRenewingLease acquireLease() {
+      return null;
+    }
+
+    @Override
+    public CloudBlob getBlob() {
+      return null;
+    }
+  }
+
+  class MockCloudPageBlobWrapper extends MockCloudBlobWrapper
+    implements CloudPageBlobWrapper {
+    public MockCloudPageBlobWrapper(URI uri, HashMap<String, String> metadata,
+        int length) {
+      super(uri, metadata, length);
+    }
+
+    @Override
+    public void create(long length, BlobRequestOptions options,
+        OperationContext opContext) throws StorageException {
+      throw new NotImplementedException();
+    }
+
+    @Override
+    public void uploadPages(InputStream sourceStream, long offset, long length,
+        BlobRequestOptions options, OperationContext opContext)
+        throws StorageException, IOException {
+      throw new NotImplementedException();
+    }
+
+    @Override
+    public ArrayList<PageRange> downloadPageRanges(BlobRequestOptions options,
+        OperationContext opContext) throws StorageException {
+      throw new NotImplementedException();
-      throw new UnsupportedOperationException();
+        throw new NotImplementedException();
+    @Override
+    public void uploadProperties(OperationContext opContext,
+        SelfRenewingLease lease)
+        throws StorageException {
+    }
+
+    @Override
+    public SelfRenewingLease acquireLease() {
+      return null;
+    }
+
+    @Override
+    public CloudBlob getBlob() {
+      return null;
+    }

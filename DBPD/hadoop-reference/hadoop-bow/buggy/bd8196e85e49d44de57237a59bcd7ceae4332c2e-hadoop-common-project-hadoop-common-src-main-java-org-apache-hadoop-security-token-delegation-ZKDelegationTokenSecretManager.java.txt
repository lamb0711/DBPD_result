HADOOP-11157. ZKDelegationTokenSecretManager never shuts down listenerThreadPool. Contributed by Arun Suresh.

+import java.util.concurrent.TimeUnit;
+import org.apache.curator.framework.recipes.cache.ChildData;
+import org.apache.hadoop.security.token.Token;
+  public static final String ZK_DTSM_ZK_SHUTDOWN_TIMEOUT = ZK_CONF_PREFIX
+      + "zkShutdownTimeout";
+  public static final int ZK_DTSM_ZK_SHUTDOWN_TIMEOUT_DEFAULT = 10000;
+  private final long shutdownTimeout;
+    shutdownTimeout = conf.getLong(ZK_DTSM_ZK_SHUTDOWN_TIMEOUT,
+        ZK_DTSM_ZK_SHUTDOWN_TIMEOUT_DEFAULT);
-    listenerThreadPool = Executors.newFixedThreadPool(2);
+    listenerThreadPool = Executors.newSingleThreadExecutor();
-        keyCache.start(StartMode.POST_INITIALIZED_EVENT);
+        keyCache.start(StartMode.BUILD_INITIAL_CACHE);
-        tokenCache.start(StartMode.POST_INITIALIZED_EVENT);
+        tokenCache.start(StartMode.BUILD_INITIAL_CACHE);
-              processTokenAddOrUpdate(event.getData().getData());
+              processTokenAddOrUpdate(event.getData());
-              processTokenAddOrUpdate(event.getData().getData());
+              processTokenAddOrUpdate(event.getData());
-              processTokenRemoved(event.getData().getData());
+              processTokenRemoved(event.getData());
-    allKeys.put(key.getKeyId(), key);
+    synchronized (this) {
+      allKeys.put(key.getKeyId(), key);
+    }
-        allKeys.remove(keyId);
+        synchronized (this) {
+          allKeys.remove(keyId);
+        }
-  private void processTokenAddOrUpdate(byte[] data) throws IOException {
-    ByteArrayInputStream bin = new ByteArrayInputStream(data);
+  private void processTokenAddOrUpdate(ChildData data) throws IOException {
+    ByteArrayInputStream bin = new ByteArrayInputStream(data.getData());
-      currentTokens.put(ident, tokenInfo);
+      synchronized (this) {
+        currentTokens.put(ident, tokenInfo);
+        // The cancel task might be waiting
+        notifyAll();
+      }
-  private void processTokenRemoved(byte[] data) throws IOException {
-    ByteArrayInputStream bin = new ByteArrayInputStream(data);
+  private void processTokenRemoved(ChildData data) throws IOException {
+    ByteArrayInputStream bin = new ByteArrayInputStream(data.getData());
-    currentTokens.remove(ident);
+    synchronized (this) {
+      currentTokens.remove(ident);
+      // The cancel task might be waiting
+      notifyAll();
+    }
+    super.stopThreads();
-      if (!isExternalClient && (zkClient != null)) {
-        zkClient.close();
-      }
-      if (delTokSeqCounter != null) {
-        delTokSeqCounter.close();
-      }
-      if (keyIdSeqCounter != null) {
-        keyIdSeqCounter.close();
-      }
-      if (keyCache != null) {
-        keyCache.close();
-      }
-      LOG.error("Could not stop Curator Framework", e);
-      // Ignore
+      LOG.error("Could not stop Delegation Token Cache", e);
-    super.stopThreads();
+    try {
+      if (delTokSeqCounter != null) {
+        delTokSeqCounter.close();
+      }
+    } catch (Exception e) {
+      LOG.error("Could not stop Delegation Token Counter", e);
+    }
+    try {
+      if (keyIdSeqCounter != null) {
+        keyIdSeqCounter.close();
+      }
+    } catch (Exception e) {
+      LOG.error("Could not stop Key Id Counter", e);
+    }
+    try {
+      if (keyCache != null) {
+        keyCache.close();
+      }
+    } catch (Exception e) {
+      LOG.error("Could not stop KeyCache", e);
+    }
+    try {
+      if (!isExternalClient && (zkClient != null)) {
+        zkClient.close();
+      }
+    } catch (Exception e) {
+      LOG.error("Could not stop Curator Framework", e);
+    }
+    if (listenerThreadPool != null) {
+      listenerThreadPool.shutdown();
+      try {
+        // wait for existing tasks to terminate
+        if (!listenerThreadPool.awaitTermination(shutdownTimeout,
+            TimeUnit.MILLISECONDS)) {
+          LOG.error("Forcing Listener threadPool to shutdown !!");
+          listenerThreadPool.shutdownNow();
+        }
+      } catch (InterruptedException ie) {
+        listenerThreadPool.shutdownNow();
+        Thread.currentThread().interrupt();
+      }
+    }
+    } catch (InterruptedException e) {
+      // The ExpirationThread is just finishing.. so dont do anything..
+      LOG.debug("Thread interrupted while performing token counter increment", e);
+      Thread.currentThread().interrupt();
+    } catch (InterruptedException e) {
+      // The ExpirationThread is just finishing.. so dont do anything..
+      LOG.debug("Thread interrupted while performing keyId increment", e);
+      Thread.currentThread().interrupt();
-    allKeys.put(key.getKeyId(), key);
-    allKeys.put(key.getKeyId(), key);
-    currentTokens.put(ident, tokenInfo);
-    currentTokens.put(ident, tokenInfo);
+  @Override
+  public synchronized TokenIdent cancelToken(Token<TokenIdent> token,
+      String canceller) throws IOException {
+    ByteArrayInputStream buf = new ByteArrayInputStream(token.getIdentifier());
+    DataInputStream in = new DataInputStream(buf);
+    TokenIdent id = createIdentifier();
+    id.readFields(in);
+    try {
+      if (!currentTokens.containsKey(id)) {
+        // See if token can be retrieved and placed in currentTokens
+        getTokenInfo(id);
+      }
+      return super.cancelToken(token, canceller);
+    } catch (Exception e) {
+      LOG.error("Exception while checking if token exist !!", e);
+      return id;
+    }
+  }
+
+
+  @VisibleForTesting
+  public ExecutorService getListenerThreadPool() {
+    return listenerThreadPool;
+  }

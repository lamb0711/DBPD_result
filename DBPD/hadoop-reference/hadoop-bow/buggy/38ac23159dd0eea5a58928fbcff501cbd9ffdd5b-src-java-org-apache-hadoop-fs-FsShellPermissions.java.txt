HADOOP-7249. Refactor the chmod/chown/chgrp command to conform to new FsCommand class.  Contributed by Daryn Sharp


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1100356 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.LinkedList;
-import org.apache.hadoop.fs.FsShell.CmdHandler;
-import org.apache.hadoop.fs.permission.FsPermission;
+import org.apache.hadoop.fs.permission.FsPermission;
+import org.apache.hadoop.fs.shell.CommandFactory;
+import org.apache.hadoop.fs.shell.CommandFormat;
+import org.apache.hadoop.fs.shell.FsCommand;
+import org.apache.hadoop.fs.shell.PathData;
-class FsShellPermissions {
+public class FsShellPermissions extends FsCommand {
-  /*========== chmod ==========*/
+  /**
+   * Register the permission related commands with the factory
+   * @param factory the command factory
+   */
+  public static void registerCommands(CommandFactory factory) {
+    factory.addClass(Chmod.class, "-chmod");
+    factory.addClass(Chown.class, "-chown");
+    factory.addClass(Chgrp.class, "-chgrp");
+  }
-  /*
+  @Override
+  protected String getFnfText(Path path) {
+    // TODO: printing the path twice is silly for backwards compatibility
+    return "could not get status for '"+path+"': File does not exist: "+path;   
+  }
+
+  /**
+  public static class Chmod extends FsShellPermissions {
+    public static final String NAME = "chmod";
+    public static final String USAGE = "[-R] <MODE[,MODE]... | OCTALMODE> PATH...";
+    public static final String DESCRIPTION =
+      "Changes permissions of a file.\n" +
+      "\tThis works similar to shell's chmod with a few exceptions.\n\n" +
+      "-R\tmodifies the files recursively. This is the only option\n" +
+      "\tcurrently supported.\n\n" +
+      "MODE\tMode is same as mode used for chmod shell command.\n" +
+      "\tOnly letters recognized are 'rwxXt'. E.g. +t,a+r,g-w,+rwx,o=r\n\n" +
+      "OCTALMODE Mode specifed in 3 or 4 digits. If 4 digits, the first may\n" +
+      "be 1 or 0 to turn the sticky bit on or off, respectively.  Unlike " +
+      "shell command, it is not possible to specify only part of the mode\n" +
+      "\tE.g. 754 is same as u=rwx,g=rx,o=r\n\n" +
+      "\tIf none of 'augo' is specified, 'a' is assumed and unlike\n" +
+      "\tshell command, no umask is applied.";
-  static String CHMOD_USAGE =
-                            "-chmod [-R] <MODE[,MODE]... | OCTALMODE> PATH...";
+    protected ChmodParser pp;
-  private static  ChmodParser pp;
-  
-  private static class ChmodHandler extends CmdHandler {
+    @Override
+    protected void processOptions(LinkedList<String> args) throws IOException {
+      CommandFormat cf = new CommandFormat(null, 2, Integer.MAX_VALUE, "R", null);
+      cf.parse(args);
+      setRecursive(cf.getOpt("R"));
-    ChmodHandler(String modeStr) throws IOException {
-      super("chmod");
+      String modeStr = args.removeFirst();
-      } catch(IllegalArgumentException iea) {
-        patternError(iea.getMessage());
+      } catch (IllegalArgumentException iea) {
+        // TODO: remove "chmod : " so it's not doubled up in output, but it's
+        // here for backwards compatibility...
+        throw new IllegalArgumentException(
+            "chmod : mode '" + modeStr + "' does not match the expected pattern.");      
-
-    private void patternError(String mode) throws IOException {
-     throw new IOException("chmod : mode '" + mode + 
-         "' does not match the expected pattern.");      
-    }
-    public void run(FileStatus file, FileSystem srcFs) throws IOException {
-      int newperms = pp.applyNewPermission(file);
-
-      if (file.getPermission().toShort() != newperms) {
+    protected void processPath(PathData item) throws IOException {
+      short newperms = pp.applyNewPermission(item.stat);
+      if (item.stat.getPermission().toShort() != newperms) {
-          srcFs.setPermission(file.getPath(), 
-                                new FsPermission((short)newperms));
+          item.fs.setPermission(item.path, new FsPermission(newperms));
-          LOG.debug("Error changing permissions of " + file.getPath(), e);
-          System.err.println(getName() + ": changing permissions of '" + 
-                             file.getPath() + "':" + e.getMessage());
+          LOG.debug("Error changing permissions of " + item, e);
+          throw new IOException(
+              "changing permissions of '" + item + "': " + e.getMessage());
-    }
+    }    
-
-  /*========== chown ==========*/
-  static private String allowedChars = "[-_./@a-zA-Z0-9]";
-  ///allows only "allowedChars" above in names for owner and group
-  static private Pattern chownPattern = 
-         Pattern.compile("^\\s*(" + allowedChars + "+)?" +
-                          "([:](" + allowedChars + "*))?\\s*$");
-  static private Pattern chgrpPattern = 
-         Pattern.compile("^\\s*(" + allowedChars + "+)\\s*$");
-  
-  static String CHOWN_USAGE = "-chown [-R] [OWNER][:[GROUP]] PATH...";
-  static String CHGRP_USAGE = "-chgrp [-R] GROUP PATH...";  
+  // used by chown/chgrp
+  static private String allowedChars = "[-_./@a-zA-Z0-9]";  
-  private static class ChownHandler extends CmdHandler {
+  /**
+   * Used to change owner and/or group of files 
+   */
+  public static class Chown extends FsShellPermissions {
+    public static final String NAME = "chown";
+    public static final String USAGE = "[-R] [OWNER][:[GROUP]] PATH...";
+    public static final String DESCRIPTION =
+      "Changes owner and group of a file.\n" +
+      "\tThis is similar to shell's chown with a few exceptions.\n\n" +
+      "\t-R\tmodifies the files recursively. This is the only option\n" +
+      "\tcurrently supported.\n\n" +
+      "\tIf only owner or group is specified then only owner or\n" +
+      "\tgroup is modified.\n\n" +
+      "\tThe owner and group names may only cosists of digits, alphabet,\n"+
+      "\tand any of '-_.@/' i.e. [-_.@/a-zA-Z0-9]. The names are case\n" +
+      "\tsensitive.\n\n" +
+      "\tWARNING: Avoid using '.' to separate user name and group though\n" +
+      "\tLinux allows it. If user names have dots in them and you are\n" +
+      "\tusing local file system, you might see surprising results since\n" +
+      "\tshell command 'chown' is used for local files.";
+
+    ///allows only "allowedChars" above in names for owner and group
+    static private final Pattern chownPattern = Pattern.compile(
+        "^\\s*(" + allowedChars + "+)?([:](" + allowedChars + "*))?\\s*$");
+
-    ChownHandler(String ownerStr) throws IOException {
-      super("chown");
+    @Override
+    protected void processOptions(LinkedList<String> args) throws IOException {
+      CommandFormat cf = new CommandFormat(null, 2, Integer.MAX_VALUE, "R");
+      cf.parse(args);
+      setRecursive(cf.getOpt("R"));
+      parseOwnerGroup(args.removeFirst());
+    }
+    
+    /**
+     * Parse the first argument into an owner and group
+     * @param ownerStr string describing new ownership
+     */
+    protected void parseOwnerGroup(String ownerStr) {
-        throw new IOException("'" + ownerStr + "' does not match " +
-                              "expected pattern for [owner][:group].");
+        throw new IllegalArgumentException(
+            "'" + ownerStr + "' does not match expected pattern for [owner][:group].");
-        throw new IOException("'" + ownerStr + "' does not specify " +
-                              " onwer or group.");
-      }
+        throw new IllegalArgumentException(
+            "'" + ownerStr + "' does not specify owner or group.");
+      }    
-
+    
-    public void run(FileStatus file, FileSystem srcFs) throws IOException {
-      //Should we do case insensitive match?  
-      String newOwner = (owner == null || owner.equals(file.getOwner())) ?
+    protected void processPath(PathData item) throws IOException {
+      //Should we do case insensitive match?
+      String newOwner = (owner == null || owner.equals(item.stat.getOwner())) ?
-      String newGroup = (group == null || group.equals(file.getGroup())) ?
+      String newGroup = (group == null || group.equals(item.stat.getGroup())) ?
-          srcFs.setOwner(file.getPath(), newOwner, newGroup);
+          item.fs.setOwner(item.path, newOwner, newGroup);
-          LOG.debug("Error changing ownership of " + file.getPath(), e);
-          System.err.println(getName() + ": changing ownership of '" + 
-                             file.getPath() + "':" + e.getMessage());
-
+          LOG.debug("Error changing ownership of " + item, e);
+          throw new IOException(
+              "changing ownership of '" + item + "': " + e.getMessage());
-  /*========== chgrp ==========*/    
-  
-  private static class ChgrpHandler extends CmdHandler {
-    protected String group = null;
-    ChgrpHandler(String groupStr) throws IOException {
-      super("chgrp");
+  /**
+   * Used to change group of files 
+   */
+  public static class Chgrp extends Chown {
+    public static final String NAME = "chgrp";
+    public static final String USAGE = "[-R] GROUP PATH...";
+    public static final String DESCRIPTION =
+      "This is equivalent to -chown ... :GROUP ...";
+    static private final Pattern chgrpPattern = 
+      Pattern.compile("^\\s*(" + allowedChars + "+)\\s*$");
+
+    @Override
+    protected void parseOwnerGroup(String groupStr) {
-        throw new IOException("'" + groupStr + "' does not match " +
-        "expected pattern for group");
+        throw new IllegalArgumentException(
+            "'" + groupStr + "' does not match expected pattern for group");
+      owner = null;
-    
-    @Override
-    public void run(FileStatus file, FileSystem srcFs) throws IOException {
-
-      String newGroup = (group.equals(file.getGroup())) ?
-                        null : group;
-
-      if (newGroup != null) {
-        try {
-          srcFs.setOwner(file.getPath(), null, newGroup);
-        } catch (IOException e) {
-          LOG.debug("Error changing ownership of " + file.getPath(), e);
-          System.err.println(getName() + ": changing ownership of '" + 
-                             file.getPath() + "':" + e.getMessage());
-
-        }
-      }
-    }
-    
-
-  static int changePermissions(String cmd, 
-                                String argv[], int startIndex, FsShell shell)
-                                throws IOException {
-    CmdHandler handler = null;
-    boolean recursive = false;
-
-    // handle common arguments, currently only "-R" 
-    for (; startIndex < argv.length && argv[startIndex].equals("-R"); 
-    startIndex++) {
-      recursive = true;
-    }
-
-    if ( startIndex >= argv.length ) {
-      throw new IOException("Not enough arguments for the command");
-    }
-
-    if (cmd.equals("-chmod")) {
-      handler = new ChmodHandler(argv[startIndex++]);
-    } else if (cmd.equals("-chown")) {
-      handler = new ChownHandler(argv[startIndex++]);
-    } else if (cmd.equals("-chgrp")) {
-      handler = new ChgrpHandler(argv[startIndex++]);
-    }
-
-    return shell.runCmdHandler(handler, argv, startIndex, recursive);
-  } 

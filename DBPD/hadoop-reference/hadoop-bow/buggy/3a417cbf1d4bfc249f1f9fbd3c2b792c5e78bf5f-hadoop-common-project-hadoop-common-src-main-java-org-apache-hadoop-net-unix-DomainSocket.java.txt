HDFS-347: style cleanups. Contributed by Colin Patrick McCabe.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1446830 13f79535-47bb-0310-9956-ffa450edef68

-      String problem = "DomainSocket#anchorNative got error: unknown";
+      String problem;
-   * Status bits
-   * 
-   * Bit 30: 0 = DomainSocket open, 1 = DomainSocket closed
-   * Bits 29 to 0: the reference count.
+   * Tracks the reference count of the file descriptor, and also whether it is
+   * open or closed.
-  private final AtomicInteger status;
+  private static class Status {
+    /**
+     * Bit mask representing a closed domain socket. 
+     */
+    private static final int STATUS_CLOSED_MASK = 1 << 30;
+    
+    /**
+     * Status bits
+     * 
+     * Bit 30: 0 = DomainSocket open, 1 = DomainSocket closed
+     * Bits 29 to 0: the reference count.
+     */
+    private final AtomicInteger bits = new AtomicInteger(0);
+
+    Status() { }
+
+    /**
+     * Increment the reference count of the underlying file descriptor.
+     *
+     * @throws ClosedChannelException      If the file descriptor is closed.
+     */
+    void reference() throws ClosedChannelException {
+      int curBits = bits.incrementAndGet();
+      if ((curBits & STATUS_CLOSED_MASK) != 0) {
+        bits.decrementAndGet();
+        throw new ClosedChannelException();
+      }
+    }
+
+    /**
+     * Decrement the reference count of the underlying file descriptor.
+     *
+     * @param checkClosed        Whether to throw an exception if the file
+     *                           descriptor is closed.
+     *
+     * @throws AsynchronousCloseException  If the file descriptor is closed and
+     *                                     checkClosed is set.
+     */
+    void unreference(boolean checkClosed) throws AsynchronousCloseException {
+      int newCount = bits.decrementAndGet();
+      assert (newCount & ~STATUS_CLOSED_MASK) >= 0;
+      if (checkClosed && ((newCount & STATUS_CLOSED_MASK) != 0)) {
+        throw new AsynchronousCloseException();
+      }
+    }
+
+    /**
+     * Return true if the file descriptor is currently open.
+     * 
+     * @return                 True if the file descriptor is currently open.
+     */
+    boolean isOpen() {
+      return ((bits.get() & STATUS_CLOSED_MASK) == 0);
+    }
+
+    /**
+     * Mark the file descriptor as closed.
+     *
+     * Once the file descriptor is closed, it cannot be reopened.
+     *
+     * @return                         The current reference count.
+     * @throws ClosedChannelException  If someone else closes the file 
+     *                                 descriptor before we do.
+     */
+    int setClosed() throws ClosedChannelException {
+      while (true) {
+        int curBits = bits.get();
+        if ((curBits & STATUS_CLOSED_MASK) != 0) {
+          throw new ClosedChannelException();
+        }
+        if (bits.compareAndSet(curBits, curBits | STATUS_CLOSED_MASK)) {
+          return curBits & (~STATUS_CLOSED_MASK);
+        }
+      }
+    }
+
+    /**
+     * Get the current reference count.
+     *
+     * @return                 The current reference count.
+     */
+    int getReferenceCount() {
+      return bits.get() & (~STATUS_CLOSED_MASK);
+    }
+  }
-   * Bit mask representing a closed domain socket. 
+   * The socket status.
-  private static final int STATUS_CLOSED_MASK = 1 << 30;
+  private final Status status;
-    this.status = new AtomicInteger(0);
+    this.status = new Status();
-    fdRef();
+    status.reference();
-      fdUnref(exc);
+      status.unreference(exc);
-  /**
-   * Increment the reference count of the underlying file descriptor.
-   *
-   * @throws SocketException  If the file descriptor is closed.
-   */
-  private void fdRef() throws ClosedChannelException {
-    int bits = status.incrementAndGet();
-    if ((bits & STATUS_CLOSED_MASK) != 0) {
-      status.decrementAndGet();
-      throw new ClosedChannelException();
-    }
-  }
-
-  /**
-   * Decrement the reference count of the underlying file descriptor.
-   */
-  private void fdUnref(boolean checkClosed) throws AsynchronousCloseException {
-    int newCount = status.decrementAndGet();
-    assert (newCount & ~STATUS_CLOSED_MASK) >= 0;
-    if (checkClosed && ((newCount & STATUS_CLOSED_MASK) != 0)) {
-      throw new AsynchronousCloseException();
-    }
-  }
-
-  /**
-   * Return true if the file descriptor is currently open.
-   * 
-   * @return                 True if the file descriptor is currently open.
-   */
-  public boolean isOpen() {
-    return ((status.get() & STATUS_CLOSED_MASK) == 0);
-  }
+ /**
+  * Return true if the file descriptor is currently open.
+  *
+  * @return                 True if the file descriptor is currently open.
+  */
+ public boolean isOpen() {
+   return status.isOpen();
+ }
-  public static final int SND_BUF_SIZE = 1;
-  public static final int RCV_BUF_SIZE = 2;
-  public static final int SND_TIMEO = 3;
-  public static final int RCV_TIMEO = 4;
+  public static final int SEND_BUFFER_SIZE = 1;
+  public static final int RECEIVE_BUFFER_SIZE = 2;
+  public static final int SEND_TIMEOUT = 3;
+  public static final int RECEIVE_TIMEOUT = 4;
-    fdRef();
+    status.reference();
-      fdUnref(exc);
+      status.unreference(exc);
-    fdRef();
+    status.reference();
-      fdUnref(exc);
+      status.unreference(exc);
-    int bits;
-    while (true) {
-      bits = status.get();
-      if ((bits & STATUS_CLOSED_MASK) != 0) {
-        return; // already closed
-      }
-      if (status.compareAndSet(bits, bits | STATUS_CLOSED_MASK)) {
-        break;
-      }
+    int refCount;
+    try {
+      refCount = status.setClosed();
+    } catch (ClosedChannelException e) {
+      // Someone else already closed the DomainSocket.
+      return;
-    while ((bits & (~STATUS_CLOSED_MASK)) > 0) {
+    while (refCount > 0) {
-      bits = status.get();
+      refCount = status.getReferenceCount();
-    // Close the file descriptor.  After this point, the file descriptor
-    // number will be reused by something else.  Although this DomainSocket
-    // object continues to hold the old file descriptor number (it's a final
-    // field), we never use it again because we look at the closed bit and
-    // realize that this DomainSocket is not usable.
+    // At this point, nobody has a reference to the file descriptor, 
+    // and nobody will be able to get one in the future either.
+    // We now call close(2) on the file descriptor.
+    // After this point, the file descriptor number will be reused by 
+    // something else.  Although this DomainSocket object continues to hold 
+    // the old file descriptor number (it's a final field), we never use it 
+    // again because this DomainSocket is closed.
-  /*
-   * Clean up if the user forgets to close the socket.
-   */
-  protected void finalize() throws IOException {
-    close();
-  }
-
-  private native static void sendFileDescriptors0(int fd, FileDescriptor jfds[],
+  private native static void sendFileDescriptors0(int fd,
+      FileDescriptor descriptors[],
-   * @param jfds              The file descriptors to send.
+   * @param descriptors       The file descriptors to send.
-  public void sendFileDescriptors(FileDescriptor jfds[],
+  public void sendFileDescriptors(FileDescriptor descriptors[],
-    fdRef();
+    status.reference();
-      sendFileDescriptors0(fd, jfds, jbuf, offset, length);
+      sendFileDescriptors0(fd, descriptors, jbuf, offset, length);
-      fdUnref(exc);
+      status.unreference(exc);
-  private static native int receiveFileDescriptors0(int fd, FileDescriptor[] jfds,
+  private static native int receiveFileDescriptors0(int fd,
+      FileDescriptor[] descriptors,
-   * @param jfds              (output parameter) Array of FileDescriptors.
+   * @param descriptors       (output parameter) Array of FileDescriptors.
-  public int receiveFileDescriptors(FileDescriptor[] jfds,
+  public int receiveFileDescriptors(FileDescriptor[] descriptors,
-    fdRef();
+    status.reference();
-      int nBytes = receiveFileDescriptors0(fd, jfds, jbuf, offset, length);
+      int nBytes = receiveFileDescriptors0(fd, descriptors, jbuf, offset, length);
-      fdUnref(exc);
+      status.unreference(exc);
-  public int recvFileInputStreams(FileInputStream[] fis, byte buf[],
+  public int recvFileInputStreams(FileInputStream[] streams, byte buf[],
-    FileDescriptor fds[] = new FileDescriptor[fis.length];
+    FileDescriptor descriptors[] = new FileDescriptor[streams.length];
-    for (int i = 0; i < fis.length; i++) {
-      fis[i] = null;
+    for (int i = 0; i < streams.length; i++) {
+      streams[i] = null;
-    fdRef();
+    status.reference();
-      int ret = receiveFileDescriptors0(fd, fds, buf, offset, length);
-      for (int i = 0, j = 0; i < fds.length; i++) {
-        if (fds[i] != null) {
-          fis[j++] = new FileInputStream(fds[i]);
-          fds[i] = null;
+      int ret = receiveFileDescriptors0(fd, descriptors, buf, offset, length);
+      for (int i = 0, j = 0; i < descriptors.length; i++) {
+        if (descriptors[i] != null) {
+          streams[j++] = new FileInputStream(descriptors[i]);
+          descriptors[i] = null;
-        for (int i = 0; i < fds.length; i++) {
-          if (fds[i] != null) {
+        for (int i = 0; i < descriptors.length; i++) {
+          if (descriptors[i] != null) {
-              closeFileDescriptor0(fds[i]);
+              closeFileDescriptor0(descriptors[i]);
-          } else if (fis[i] != null) {
+          } else if (streams[i] != null) {
-              fis[i].close();
+              streams[i].close();
-              fis[i] = null; }
+              streams[i] = null; }
-      fdUnref(!success);
+      status.unreference(!success);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);
-      fdRef();
+      status.reference();
-        fdUnref(exc);
+        status.unreference(exc);

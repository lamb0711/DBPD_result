HDFS-7158. Reduce the memory usage of WebImageViewer. Contributed by Haohui Mai.

+import java.io.EOFException;
+import java.io.FileNotFoundException;
+import java.util.Arrays;
+import com.google.common.collect.ImmutableList;
+import com.google.protobuf.CodedInputStream;
+import com.google.protobuf.InvalidProtocolBufferException;
-  private static String[] stringTable;
-  private static Map<Long, FsImageProto.INodeSection.INode> inodes =
-      Maps.newHashMap();
-  private static Map<Long, long[]> dirmap = Maps.newHashMap();
-  private static List<FsImageProto.INodeReferenceSection.INodeReference>
-      refList = Lists.newArrayList();
+  private final String[] stringTable;
+  // byte representation of inodes, sorted by id
+  private final byte[][] inodes;
+  private final Map<Long, long[]> dirmap;
+  private static final Comparator<byte[]> INODE_BYTES_COMPARATOR = new
+          Comparator<byte[]>() {
+    @Override
+    public int compare(byte[] o1, byte[] o2) {
+      try {
+        final FsImageProto.INodeSection.INode l = FsImageProto.INodeSection
+                .INode.parseFrom(o1);
+        final FsImageProto.INodeSection.INode r = FsImageProto.INodeSection
+                .INode.parseFrom(o2);
+        if (l.getId() < r.getId()) {
+          return -1;
+        } else if (l.getId() > r.getId()) {
+          return 1;
+        } else {
+          return 0;
+        }
+      } catch (InvalidProtocolBufferException e) {
+        throw new RuntimeException(e);
+      }
+    }
+  };
-  private FSImageLoader() {}
+  private FSImageLoader(String[] stringTable, byte[][] inodes,
+                        Map<Long, long[]> dirmap) {
+    this.stringTable = stringTable;
+    this.inodes = inodes;
+    this.dirmap = dirmap;
+  }
+
+      // Map to record INodeReference to the referred id
+      ImmutableList<Long> refIdList = null;
+      String[] stringTable = null;
+      byte[][] inodes = null;
+      Map<Long, long[]> dirmap = null;
+
+        LOG.debug("Loading section " + s.getName() + " length: " + s.getLength
+                ());
-            loadStringTable(is);
+            stringTable = loadStringTable(is);
-            loadINodeSection(is);
+            inodes = loadINodeSection(is);
-            loadINodeReferenceSection(is);
+            refIdList = loadINodeReferenceSection(is);
-            loadINodeDirectorySection(is);
+            dirmap = loadINodeDirectorySection(is, refIdList);
+      return new FSImageLoader(stringTable, inodes, dirmap);
-    return new FSImageLoader();
-  private static void loadINodeDirectorySection(InputStream in)
+  private static Map<Long, long[]> loadINodeDirectorySection
+          (InputStream in, List<Long> refIdList)
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Loading directory section");
-    }
+    LOG.info("Loading inode directory section");
+    Map<Long, long[]> dirs = Maps.newHashMap();
+    long counter = 0;
+      ++counter;
+
-        l[i] = refList.get(refId).getReferredId();
+        l[i] = refIdList.get(refId);
-      dirmap.put(e.getParent(), l);
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Loaded directory (parent " + e.getParent()
-            + ") with " + e.getChildrenCount() + " children and "
-            + e.getRefChildrenCount() + " reference children");
-      }
+      dirs.put(e.getParent(), l);
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Loaded " + dirmap.size() + " directories");
-    }
+    LOG.info("Loaded " + counter + " directories");
+    return dirs;
-  private static void loadINodeReferenceSection(InputStream in)
+  private static ImmutableList<Long> loadINodeReferenceSection(InputStream in)
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Loading inode reference section");
-    }
+    LOG.info("Loading inode references");
+    ImmutableList.Builder<Long> builder = ImmutableList.builder();
+    long counter = 0;
-      refList.add(e);
-      if (LOG.isTraceEnabled()) {
-        LOG.trace("Loaded inode reference named '" + e.getName()
-            + "' referring to id " + e.getReferredId() + "");
-      }
+      ++counter;
+      builder.add(e.getReferredId());
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Loaded " + refList.size() + " inode references");
-    }
+    LOG.info("Loaded " + counter + " inode references");
+    return builder.build();
-  private static void loadINodeSection(InputStream in) throws IOException {
+  private static byte[][] loadINodeSection(InputStream in)
+          throws IOException {
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Found " + s.getNumInodes() + " inodes in inode section");
-    }
+    LOG.info("Loading " + s.getNumInodes() + " inodes.");
+    final byte[][] inodes = new byte[(int) s.getNumInodes()][];
+
-      FsImageProto.INodeSection.INode p = FsImageProto.INodeSection.INode
-          .parseDelimitedFrom(in);
-      inodes.put(p.getId(), p);
-      if (LOG.isTraceEnabled()) {
-        LOG.trace("Loaded inode id " + p.getId() + " type " + p.getType()
-            + " name '" + p.getName().toStringUtf8() + "'");
-      }
+      int size = CodedInputStream.readRawVarint32(in.read(), in);
+      byte[] bytes = new byte[size];
+      IOUtils.readFully(in, bytes, 0, size);
+      inodes[i] = bytes;
+    LOG.debug("Sorting inodes");
+    Arrays.sort(inodes, INODE_BYTES_COMPARATOR);
+    LOG.debug("Finished sorting inodes");
+    return inodes;
-  private static void loadStringTable(InputStream in) throws IOException {
+  private static String[] loadStringTable(InputStream in) throws
+  IOException {
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Found " + s.getNumEntry() + " strings in string section");
-    }
-    stringTable = new String[s.getNumEntry() + 1];
+    LOG.info("Loading " + s.getNumEntry() + " strings");
+    String[] stringTable = new String[s.getNumEntry() + 1];
-      if (LOG.isTraceEnabled()) {
-        LOG.trace("Loaded string " + e.getStr());
-      }
+    return stringTable;
-    FsImageProto.INodeSection.INode inode = inodes.get(getINodeId(path));
+    FsImageProto.INodeSection.INode inode = fromINodeId(lookup(path));
-  private List<Map<String, Object>> getFileStatusList(String path) {
+  private List<Map<String, Object>> getFileStatusList(String path)
+          throws IOException {
-    long id = getINodeId(path);
-    FsImageProto.INodeSection.INode inode = inodes.get(id);
+    long id = lookup(path);
+    FsImageProto.INodeSection.INode inode = fromINodeId(id);
-        list.add(getFileStatus(inodes.get(cid), true));
+        list.add(getFileStatus(fromINodeId(cid), true));
-  private List<AclEntry> getAclEntryList(String path) {
-    long id = getINodeId(path);
-    FsImageProto.INodeSection.INode inode = inodes.get(id);
+  private List<AclEntry> getAclEntryList(String path) throws IOException {
+    long id = lookup(path);
+    FsImageProto.INodeSection.INode inode = fromINodeId(id);
-  private PermissionStatus getPermissionStatus(String path) {
-    long id = getINodeId(path);
-    FsImageProto.INodeSection.INode inode = inodes.get(id);
+  private PermissionStatus getPermissionStatus(String path) throws IOException {
+    long id = lookup(path);
+    FsImageProto.INodeSection.INode inode = fromINodeId(id);
-  private long getINodeId(String strPath) {
-    if (strPath.equals("/")) {
-      return INodeId.ROOT_INODE_ID;
-    }
-
-    String[] nameList = strPath.split("/");
-    Preconditions.checkArgument(nameList.length > 1,
-                                "Illegal path: " + strPath);
+  private long lookup(String path) throws IOException {
+    Preconditions.checkArgument(path.startsWith("/"));
-    for (int i = 1; i < nameList.length; i++) {
-      long[] children = dirmap.get(id);
-      Preconditions.checkNotNull(children, "File: " +
-          strPath + " is not found in the fsimage.");
-      String cName = nameList[i];
-      boolean findChildren = false;
+    for (int offset = 0, next; offset < path.length(); offset = next) {
+      next = path.indexOf('/', offset + 1);
+      if (next == -1) {
+        next = path.length();
+      }
+      if (offset + 1 > next) {
+        break;
+      }
+
+      final String component = path.substring(offset + 1, next);
+
+      if (component.isEmpty()) {
+        continue;
+      }
+
+      final long[] children = dirmap.get(id);
+      if (children == null) {
+        throw new FileNotFoundException(path);
+      }
+
+      boolean found = false;
-        if (cName.equals(inodes.get(cid).getName().toStringUtf8())) {
-          id = cid;
-          findChildren = true;
+        FsImageProto.INodeSection.INode child = fromINodeId(cid);
+        if (component.equals(child.getName().toStringUtf8())) {
+          found = true;
+          id = child.getId();
-      Preconditions.checkArgument(findChildren, "File: " +
-          strPath + " is not found in the fsimage.");
+      if (!found) {
+        throw new FileNotFoundException(path);
+      }
+
+  private FsImageProto.INodeSection.INode fromINodeId(final long id)
+          throws IOException {
+    int l = 0, r = inodes.length;
+    while (l < r) {
+      int mid = l + (r - l) / 2;
+      FsImageProto.INodeSection.INode n = FsImageProto.INodeSection.INode
+              .parseFrom(inodes[mid]);
+      long nid = n.getId();
+      if (id > nid) {
+        l = mid + 1;
+      } else if (id < nid) {
+        r = mid;
+      } else {
+        return n;
+      }
+    }
+    return null;
+  }

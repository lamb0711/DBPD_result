HDFS-7146. NFS ID/Group lookup requires SSSD enumeration on the server. Contributed by Yongjun Zhang

+ * 
+ * The maps are incrementally updated as described below:
+ *   1. Initialize the maps as empty. 
+ *   2. Incrementally update the maps
+ *      - When ShellBasedIdMapping is requested for user or group name given 
+ *        an ID, or for ID given a user or group name, do look up in the map
+ *        first, if it doesn't exist, find the corresponding entry with shell
+ *        command, and insert the entry to the maps.
+ *      - When group ID is requested for a given group name, and if the
+ *        group name is numerical, the full group map is loaded. Because we
+ *        don't have a good way to find the entry for a numerical group name,
+ *        loading the full map helps to get in all entries.
+ *   3. Periodically refresh the maps for both user and group, e.g,
+ *      do step 1.
+ *   Note: for testing purpose, step 1 may initial the maps with full mapping
+ *   when using constructor
+ *   {@link ShellBasedIdMapping#ShellBasedIdMapping(Configuration, boolean)}.
+  private StaticMapping staticMapping = null;
+  private boolean constructFullMapAtInit = false;
-  
+
+  /*
+   * Constructor
+   * @param conf the configuration
+   * @param constructFullMapAtInit initialize the maps with full mapping when
+   *        true, otherwise initialize the maps to empty. This parameter is
+   *        intended for testing only, its default is false.
+   */
+  @VisibleForTesting
-      final String defaultStaticIdMappingFile) throws IOException {
+      boolean constructFullMapAtInit) throws IOException {
+    this.constructFullMapAtInit = constructFullMapAtInit;
-    String staticFilePath = conf.get(IdMappingConstant.STATIC_ID_MAPPING_FILE_KEY,
-        defaultStaticIdMappingFile);
+    String staticFilePath = 
+        conf.get(IdMappingConstant.STATIC_ID_MAPPING_FILE_KEY,
+            IdMappingConstant.STATIC_ID_MAPPING_FILE_DEFAULT);
-    
+
+  /*
+   * Constructor
+   * initialize user and group maps to empty
+   * @param conf the configuration
+   */
-    this(conf, IdMappingConstant.STATIC_ID_MAPPING_FILE_DEFAULT);
+    this(conf, false);
-  
+
+  @VisibleForTesting
+  public BiMap<Integer, String> getUidNameMap() {
+    return uidNameMap;
+  }
+
+  @VisibleForTesting
+  public BiMap<Integer, String> getGidNameMap() {
+    return gidNameMap;
+  }
+
+  @VisibleForTesting  
+  synchronized public void clearNameMaps() {
+    uidNameMap.clear();
+    gidNameMap.clear();
+    lastUpdateTime = Time.monotonicNow();
+  }  
+
-   * Get the whole list of users and groups and save them in the maps.
+   * Get the list of users or groups returned by the specified command,
+   * and save them in the corresponding map.
-  public static void updateMapInternal(BiMap<Integer, String> map, String mapName,
-      String command, String regex, Map<Integer, Integer> staticMapping)
-      throws IOException  {
+  public static boolean updateMapInternal(BiMap<Integer, String> map,
+      String mapName, String command, String regex,
+      Map<Integer, Integer> staticMapping) throws IOException  {
+    boolean updated = false;
+        updated = true;
-      LOG.info("Updated " + mapName + " map size: " + map.size());
+      LOG.debug("Updated " + mapName + " map size: " + map.size());
+    return updated;
-  synchronized public void updateMaps() throws IOException {
-    BiMap<Integer, String> uMap = HashBiMap.create();
-    BiMap<Integer, String> gMap = HashBiMap.create();
-
+  private boolean checkSupportedPlatform() {
-      return;
+      return false;
-    
-    StaticMapping staticMapping = new StaticMapping(
+    return true;
+  }
+
+  private static boolean isInteger(final String s) {
+    try { 
+      Integer.parseInt(s); 
+    } catch(NumberFormatException e) { 
+      return false; 
+    }
+    // only got here if we didn't return false
+    return true;
+  }
+
+  private void initStaticMapping() throws IOException {
+    staticMapping = new StaticMapping(
+  }  
+  /*
+   * Reset the maps to empty.
+   * For testing code, a full map may be re-constructed here when the object
+   * was created with constructFullMapAtInit being set to true.
+   */
+  synchronized public void updateMaps() throws IOException {
+    if (!checkSupportedPlatform()) {
+      return;
+    }
+
+    if (constructFullMapAtInit) {
+      loadFullMaps();
+    } else {
+      clearNameMaps();
+    }
+  }
+  
+  synchronized private void loadFullUserMap() throws IOException {
+    if (staticMapping == null) {
+      initStaticMapping();
+    }
+    BiMap<Integer, String> uMap = HashBiMap.create();
-      updateMapInternal(gMap, "group", MAC_GET_ALL_GROUPS_CMD, "\\s+",
-          staticMapping.gidMapping);
+    }
+    uidNameMap = uMap;
+    lastUpdateTime = Time.monotonicNow();
+  }
+
+  synchronized private void loadFullGroupMap() throws IOException {
+    if (staticMapping == null) {
+      initStaticMapping();
+    }
+    BiMap<Integer, String> gMap = HashBiMap.create();
+
+    if (OS.startsWith("Mac")) {
+      updateMapInternal(gMap, "group", MAC_GET_ALL_GROUPS_CMD, "\\s+",
+          staticMapping.gidMapping);
+    } else {
-
-    uidNameMap = uMap;
+
+  synchronized private void loadFullMaps() throws IOException {
+    initStaticMapping();
+    loadFullUserMap();
+    loadFullGroupMap();
+  }
+
+  // search for id with given name, return "<name>:<id>"
+  // return
+  //     getent group <name> | cut -d: -f1,3
+  // OR
+  //     id -u <name> | awk '{print "<name>:"$1 }'
+  //
+  private String getName2IdCmdLinux(final String name, final boolean isGrp) {
+    String cmd;
+    if (isGrp) {
+      cmd = "getent group " + name + " | cut -d: -f1,3";   
+    } else {
+      cmd = "id -u " + name + " | awk '{print \"" + name + ":\"$1 }'";
+    }
+    return cmd;
+  }
+  // search for name with given id, return "<name>:<id>"
+  private String getId2NameCmdLinux(final int id, final boolean isGrp) {
+    String cmd = "getent ";
+    cmd += isGrp? "group " : "passwd ";
+    cmd += String.valueOf(id) + " | cut -d: -f1,3";
+    return cmd;
+  }
+
+  // "dscl . -read /Users/<name> | grep UniqueID" returns "UniqueId: <id>",
+  // "dscl . -read /Groups/<name> | grep PrimaryGroupID" returns "PrimaryGoupID: <id>"
+  // The following method returns a command that uses awk to process the result,
+  // of these commands, and returns "<name> <id>", to simulate one entry returned by 
+  // MAC_GET_ALL_USERS_CMD or MAC_GET_ALL_GROUPS_CMD.
+  // Specificially, this method returns:
+  // id -u <name> | awk '{print "<name>:"$1 }'
+  // OR
+  // dscl . -read /Groups/<name> | grep PrimaryGroupID | awk '($1 == "PrimaryGroupID:") { print "<name> " $2 }'
+  //
+  private String getName2IdCmdMac(final String name, final boolean isGrp) {
+    String cmd;
+    if (isGrp) {
+      cmd = "dscl . -read /Groups/" + name;
+      cmd += " | grep PrimaryGroupID | awk '($1 == \"PrimaryGroupID:\") ";
+      cmd += "{ print \"" + name + "  \" $2 }'";
+    } else {
+      cmd = "id -u " + name + " | awk '{print \"" + name + "  \"$1 }'";
+    }
+    return cmd;
+  }
+
+  // "dscl . -search /Users UniqueID <id>" returns 
+  //    <name> UniqueID = (
+  //      <id>
+  //    )
+  // "dscl . -search /Groups PrimaryGroupID <id>" returns
+  //    <name> PrimaryGroupID = (
+  //      <id>
+  //    )
+  // The following method returns a command that uses sed to process the
+  // the result and returns "<name> <id>" to simulate one entry returned
+  // by MAC_GET_ALL_USERS_CMD or MAC_GET_ALL_GROUPS_CMD.
+  // For certain negative id case like nfsnobody, the <id> is quoted as
+  // "<id>", added one sed section to remove the quote.
+  // Specifically, the method returns:
+  // dscl . -search /Users UniqueID <id> | sed 'N;s/\\n//g;N;s/\\n//g' | sed 's/UniqueID =//g' | sed 's/)//g' | sed 's/\"//g'
+  // OR
+  // dscl . -search /Groups PrimaryGroupID <id> | sed 'N;s/\\n//g;N;s/\\n//g' | sed 's/PrimaryGroupID =//g' | sed 's/)//g' | sed 's/\"//g'
+  //
+  private String getId2NameCmdMac(final int id, final boolean isGrp) {
+    String cmd = "dscl . -search /";
+    cmd += isGrp? "Groups PrimaryGroupID " : "Users UniqueID ";
+    cmd += String.valueOf(id);
+    cmd += " | sed 'N;s/\\n//g;N;s/\\n//g' | sed 's/";
+    cmd += isGrp? "PrimaryGroupID" : "UniqueID";
+    cmd += " = (//g' | sed 's/)//g' | sed 's/\\\"//g'";
+    return cmd;
+  }
+
+  synchronized private void updateMapIncr(final String name,
+      final boolean isGrp) throws IOException {
+    if (!checkSupportedPlatform()) {
+      return;
+    }
+    if (isInteger(name) && isGrp) {
+      loadFullGroupMap();
+      return;
+    }
+
+    boolean updated = false;
+    if (staticMapping == null) {
+      initStaticMapping();
+    }
+
+    if (OS.startsWith("Linux")) {
+      if (isGrp) {
+        updated = updateMapInternal(gidNameMap, "group",
+            getName2IdCmdLinux(name, true), ":",
+            staticMapping.gidMapping);
+      } else {
+        updated = updateMapInternal(uidNameMap, "user",
+            getName2IdCmdLinux(name, false), ":",
+            staticMapping.uidMapping);
+      }
+    } else {
+      // Mac
+      if (isGrp) {        
+        updated = updateMapInternal(gidNameMap, "group",
+            getName2IdCmdMac(name, true), "\\s+",
+            staticMapping.gidMapping);
+      } else {
+        updated = updateMapInternal(uidNameMap, "user",
+            getName2IdCmdMac(name, false), "\\s+",
+            staticMapping.uidMapping);
+      }
+    }
+    if (updated) {
+      lastUpdateTime = Time.monotonicNow();
+    }
+  }
+
+  synchronized private void updateMapIncr(final int id,
+      final boolean isGrp) throws IOException {
+    if (!checkSupportedPlatform()) {
+      return;
+    }
+    
+    boolean updated = false;
+    if (staticMapping == null) {
+      initStaticMapping();
+    }
+
+    if (OS.startsWith("Linux")) {
+      if (isGrp) {
+        updated = updateMapInternal(gidNameMap, "group",
+            getId2NameCmdLinux(id, true), ":",
+            staticMapping.gidMapping);
+      } else {
+        updated = updateMapInternal(uidNameMap, "user",
+            getId2NameCmdLinux(id, false), ":",
+            staticMapping.uidMapping);
+      }
+    } else {
+      // Mac
+      if (isGrp) {
+        updated = updateMapInternal(gidNameMap, "group",
+            getId2NameCmdMac(id, true), "\\s+",
+            staticMapping.gidMapping);
+      } else {
+        updated = updateMapInternal(uidNameMap, "user",
+            getId2NameCmdMac(id, false), "\\s+",
+            staticMapping.uidMapping);
+      }
+    }
+    if (updated) {
+      lastUpdateTime = Time.monotonicNow();
+    }
+  }
+
-      throw new IOException("User just deleted?:" + user);
+      updateMapIncr(user, false);
+      id = uidNameMap.inverse().get(user);
+      if (id == null) {
+        throw new IOException("User just deleted?:" + user);
+      }
-      throw new IOException("No such group:" + group);
-
+      updateMapIncr(group, true);
+      id = gidNameMap.inverse().get(group);
+      if (id == null) {
+        throw new IOException("No such group:" + group);
+      }
-      LOG.warn("Can't find user name for uid " + uid
-          + ". Use default user name " + unknown);
-      uname = unknown;
+      try {
+        updateMapIncr(uid, false);
+      } catch (Exception e) {        
+      }
+      uname = uidNameMap.get(uid);
+      if (uname == null) {     
+        LOG.warn("Can't find user name for uid " + uid
+            + ". Use default user name " + unknown);
+        uname = unknown;
+      }
-      LOG.warn("Can't find group name for gid " + gid
-          + ". Use default group name " + unknown);
-      gname = unknown;
+      try {
+        updateMapIncr(gid, true);
+      } catch (Exception e) {        
+      }
+      gname = gidNameMap.get(gid);
+      if (gname == null) {
+        LOG.warn("Can't find group name for gid " + gid
+            + ". Use default group name " + unknown);
+        gname = unknown;
+      }

HDFS-3863. Track last "committed" txid in QJM. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1380976 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.util.BestEffortLongFile;
+import com.google.common.collect.Range;
+import com.google.common.collect.Ranges;
+  /**
+   * Lower-bound on the last committed transaction ID. This is not
+   * depended upon for correctness, but acts as a sanity check
+   * during the recovery procedures, and as a visibility mark
+   * for clients reading in-progress logs.
+   */
+  private BestEffortLongFile committedTxnId;
+  
-
+  private static final String COMMITTED_TXID_FILENAME = "committed-txid";
+  
-
+    this.committedTxnId = new BestEffortLongFile(
+        new File(currentDir, COMMITTED_TXID_FILENAME),
+        HdfsConstants.INVALID_TXID);
+    
-    if (files.isEmpty()) {
-      curSegmentTxId = HdfsConstants.INVALID_TXID;
-      return;
-    }
+    curSegmentTxId = HdfsConstants.INVALID_TXID;
-    EditLogFile latestLog = files.get(files.size() - 1);
-    latestLog.validateLog();
-    LOG.info("Latest log is " + latestLog);
-    if (latestLog.getLastTxId() == HdfsConstants.INVALID_TXID) {
-      // the log contains no transactions
-      LOG.warn("Latest log " + latestLog + " has no transactions. " +
-          "moving it aside");
-      latestLog.moveAsideEmptyFile();
-      curSegmentTxId = HdfsConstants.INVALID_TXID;
-    } else {
-      curSegmentTxId = latestLog.getFirstTxId();
+    while (!files.isEmpty()) {
+      EditLogFile latestLog = files.remove(files.size() - 1);
+      latestLog.validateLog();
+      LOG.info("Latest log is " + latestLog);
+      if (latestLog.getLastTxId() == HdfsConstants.INVALID_TXID) {
+        // the log contains no transactions
+        LOG.warn("Latest log " + latestLog + " has no transactions. " +
+            "moving it aside and looking for previous log");
+        latestLog.moveAsideEmptyFile();
+      } else {
+        curSegmentTxId = latestLog.getFirstTxId();
+        break;
+      }
+    
+    IOUtils.closeStream(committedTxnId);
+  
+  synchronized long getCommittedTxnIdForTests() throws IOException {
+    return committedTxnId.get();
+  }
-    checkWriteRequest(reqInfo);
+    checkWriteRequest(reqInfo);
+    
+
+    if (reqInfo.hasCommittedTxId()) {
+      Preconditions.checkArgument(
+          reqInfo.getCommittedTxId() >= committedTxnId.get(),
+          "Client trying to move committed txid backward from " +
+          committedTxnId.get() + " to " + reqInfo.getCommittedTxId());
+      
+      committedTxnId.set(reqInfo.getCommittedTxId());
+    }
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
+    if (committedTxnId.get() != HdfsConstants.INVALID_TXID) {
+      builder.setLastCommittedTxId(committedTxnId.get());
+    }
-    checkRequest(reqInfo);
+    checkRequest(reqInfo);
-            ": old segment " + TextFormat.shortDebugString(segment) + " is " +
-            "not the right length");
+            ": old segment " + TextFormat.shortDebugString(currentSegment) +
+            " is not the right length");
+        
+        // Paranoid sanity check: if the new log is shorter than the log we
+        // currently have, we should not end up discarding any transactions
+        // which are already Committed.
+        if (txnRange(currentSegment).contains(committedTxnId.get()) &&
+            !txnRange(segment).contains(committedTxnId.get())) {
+          throw new AssertionError(
+              "Cannot replace segment " +
+              TextFormat.shortDebugString(currentSegment) +
+              " with new segment " +
+              TextFormat.shortDebugString(segment) + 
+              ": would discard already-committed txn " +
+              committedTxnId.get());
+        }
+  private Range<Long> txnRange(SegmentStateProto seg) {
+    Preconditions.checkArgument(seg.hasEndTxId(),
+        "invalid segment: %s", seg);
+    return Ranges.closed(seg.getStartTxId(), seg.getEndTxId());
+  }
+

YARN-628. Fix the way YarnRemoteException is being unrolled to extract out the underlying exception. Contributed by Siddharth Seth.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483207 13f79535-47bb-0310-9956-ffa450edef68

-import java.lang.reflect.UndeclaredThrowableException;
+import java.lang.reflect.InvocationTargetException;
+  private static <T extends Throwable> T instantiateException(
+      Class<? extends T> cls, RemoteException re) throws RemoteException {
+    try {
+      Constructor<? extends T> cn = cls.getConstructor(String.class);
+      cn.setAccessible(true);
+      T ex = cn.newInstance(re.getMessage());
+      ex.initCause(re);
+      return ex;
+      // RemoteException contains useful information as against the
+      // java.lang.reflect exceptions.
+    } catch (NoSuchMethodException e) {
+      throw re;
+    } catch (IllegalArgumentException e) {
+      throw re;
+    } catch (SecurityException e) {
+      throw re;
+    } catch (InstantiationException e) {
+      throw re;
+    } catch (IllegalAccessException e) {
+      throw re;
+    } catch (InvocationTargetException e) {
+      throw re;
+    }
+  }
+
-   * Utility method that unwraps and throws appropriate exception.
+   * Utility method that unwraps and returns appropriate exceptions.
-   * @param se ServiceException
-   * @throws YarnRemoteException
-   * @throws UndeclaredThrowableException
+   * @param se
+   *          ServiceException
+   * @return An instance of the actual exception, which will be a subclass of
+   *         {@link YarnRemoteException} or {@link IOException}
-  public static YarnRemoteException unwrapAndThrowException(ServiceException se)
-      throws UndeclaredThrowableException {
-    if (se.getCause() instanceof RemoteException) {
-      try {
-        RemoteException re = (RemoteException) se.getCause();
-        Class<?> realClass = Class.forName(re.getClassName());
-        //YarnRemoteException is not rooted as IOException.
-        //Do the explicitly check if it is YarnRemoteException
-        if (YarnRemoteException.class.isAssignableFrom(realClass)) {
-          Constructor<? extends YarnRemoteException> cn =
-              realClass.asSubclass(YarnRemoteException.class).getConstructor(
-                  String.class);
-          cn.setAccessible(true);
-          YarnRemoteException ex = cn.newInstance(re.getMessage());
-          ex.initCause(re);
-          return ex;
-        } else {
-          // TODO Fix in YARN-628.
-          throw new IOException((RemoteException) se.getCause());
-        }
-      } catch (IOException e1) {
-        throw new UndeclaredThrowableException(e1);
-      } catch (Exception ex) {
-        throw new UndeclaredThrowableException(
-            (RemoteException) se.getCause());
-      }
-    } else if (se.getCause() instanceof YarnRemoteException) {
-      return (YarnRemoteException) se.getCause();
-    } else if (se.getCause() instanceof UndeclaredThrowableException) {
-      throw (UndeclaredThrowableException) se.getCause();
+  public static Void unwrapAndThrowException(ServiceException se)
+      throws IOException, YarnRemoteException {
+    Throwable cause = se.getCause();
+    if (cause == null) {
+      // SE generated by the RPC layer itself.
+      throw new IOException(se);
-      throw new UndeclaredThrowableException(se);
+      if (cause instanceof RemoteException) {
+        RemoteException re = (RemoteException) cause;
+        Class<?> realClass = null;
+        try {
+          realClass = Class.forName(re.getClassName());
+        } catch (ClassNotFoundException cnf) {
+          // Assume this to be a new exception type added to YARN. This isn't
+          // absolutely correct since the RPC layer could add an exception as
+          // well.
+          throw instantiateException(YarnRemoteException.class, re);
+        }
+
+        if (YarnRemoteException.class.isAssignableFrom(realClass)) {
+          throw instantiateException(
+              realClass.asSubclass(YarnRemoteException.class), re);
+        } else if (IOException.class.isAssignableFrom(realClass)) {
+          throw instantiateException(realClass.asSubclass(IOException.class),
+              re);
+        } else {
+          throw re;
+        }
+        // RemoteException contains useful information as against the
+        // java.lang.reflect exceptions.
+
+      } else if (cause instanceof IOException) {
+        // RPC Client exception.
+        throw (IOException) cause;
+      } else {
+        // Should not be generated.
+        throw new IOException(se);
+      }

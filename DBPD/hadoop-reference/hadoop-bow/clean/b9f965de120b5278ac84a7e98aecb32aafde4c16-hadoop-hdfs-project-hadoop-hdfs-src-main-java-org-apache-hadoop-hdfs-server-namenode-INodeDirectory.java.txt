HDFS-4103. Support O(1) snapshot creation.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1424782 13f79535-47bb-0310-9956-ffa450edef68

-  @Override
-  public Pair<INodeDirectory, INodeDirectory> createSnapshotCopy() {
-    return new Pair<INodeDirectory, INodeDirectory>(this,
-        new INodeDirectory(this, false));
-  }
-  
-  protected int searchChildrenForExistingINode(byte[] name) {
+  protected int searchChildrenForExistingINode(final INode inode) {
+    final byte[] name = inode.getLocalNameBytes();
-  /** Replace a child that has the same name as newChild by newChild.
+  /**
+   * Remove the specified child from this directory.
-   * @param newChild Child node to be added
+   * @param child the child inode to be removed
+   * @param latest See {@link INode#recordModification(Snapshot)}.
+   * @return the removed child inode.
-  void replaceChild(INode newChild) {
+  public INode removeChild(INode child, Snapshot latest) {
-    final int low = searchChildren(newChild.getLocalNameBytes());
-    if (low>=0) { // an old child exists so replace by the newChild
-      children.get(low).parent = null;
-      children.set(low, newChild);
-    } else {
-      throw new IllegalArgumentException("No child exists to be replaced");
+    if (latest != null) {
+      final INodeDirectoryWithSnapshot dir = replaceSelf4INodeDirectoryWithSnapshot(latest);
+      return dir.removeChild(child, latest);
+
+    final int i = searchChildren(child.getLocalNameBytes());
+    return i >= 0? children.remove(i): null;
+  }
+
+  /**
+   * Replace itself with {@link INodeDirectoryWithQuota} or
+   * {@link INodeDirectoryWithSnapshot} depending on the latest snapshot.
+   */
+  INodeDirectoryWithQuota replaceSelf4Quota(final Snapshot latest,
+      final long nsQuota, final long dsQuota) {
+    Preconditions.checkState(!(this instanceof INodeDirectoryWithQuota),
+        "this is already an INodeDirectoryWithQuota, this=%s", this);
+
+    if (latest == null) {
+      final INodeDirectoryWithQuota q = new INodeDirectoryWithQuota(
+          this, true, nsQuota, dsQuota);
+      replaceSelf(q);
+      return q;
+    } else {
+      final INodeDirectoryWithSnapshot s
+          = INodeDirectoryWithSnapshot.newInstance(this, null);
+      s.setQuota(nsQuota, dsQuota, null);
+      replaceSelf(s);
+      s.save2Snapshot(latest, this);
+      return s;
+    }
+  }
+  /** Replace itself with an {@link INodeDirectorySnapshottable}. */
+  public INodeDirectorySnapshottable replaceSelf4INodeDirectorySnapshottable(
+      Snapshot latest) {
+    final INodeDirectorySnapshottable s = new INodeDirectorySnapshottable(this);
+    replaceSelf(s);
+    s.save2Snapshot(latest, this);
+    return s;
+  }
+
+  /** Replace itself with an {@link INodeDirectoryWithSnapshot}. */
+  public INodeDirectoryWithSnapshot replaceSelf4INodeDirectoryWithSnapshot(
+      Snapshot latest) {
+    Preconditions.checkState(!(this instanceof INodeDirectoryWithSnapshot),
+        "this is already an INodeDirectoryWithSnapshot, this=%s", this);
+
+    final INodeDirectoryWithSnapshot withSnapshot
+        = INodeDirectoryWithSnapshot.newInstance(this, latest);
+    replaceSelf(withSnapshot);
+    return withSnapshot;
+  }
+
+  /** Replace itself with {@link INodeDirectory}. */
+  public INodeDirectory replaceSelf4INodeDirectory() {
+    Preconditions.checkState(getClass() != INodeDirectory.class,
+        "the class is already INodeDirectory, this=%s", this);
+
+    final INodeDirectory newNode = new INodeDirectory(this, true);
+    replaceSelf(newNode);
+    return newNode;
+  }
+
+  /** Replace itself with the given directory. */
+  private final void replaceSelf(INodeDirectory newDir) {
+    final INodeDirectory parent = getParent();
+    Preconditions.checkArgument(parent != null, "parent is null, this=%s", this);
+
+    final int i = parent.searchChildrenForExistingINode(newDir);
+    final INode oldDir = parent.children.set(i, newDir);
+    oldDir.setParent(null);
-    final int i = searchChildrenForExistingINode(newChild.getLocalNameBytes());
+    final int i = searchChildrenForExistingINode(newChild);
-  private INode getChild(byte[] name, Snapshot snapshot) {
+  @Override
+  public Pair<? extends INode, ? extends INode> recordModification(Snapshot latest) {
+    if (latest == null) {
+      return null;
+    }
+    return replaceSelf4INodeDirectoryWithSnapshot(latest)
+        .save2Snapshot(latest, this);
+  }
+
+  /**
+   * Save the child to the latest snapshot.
+   * 
+   * @return a pair of inodes, where the left inode is the original child and
+   *         the right inode is the snapshot copy of the child; see also
+   *         {@link INode#createSnapshotCopy()}.
+   */
+  public Pair<? extends INode, ? extends INode> saveChild2Snapshot(
+      INode child, Snapshot latest) {
+    if (latest == null) {
+      return null;
+    }
+    return replaceSelf4INodeDirectoryWithSnapshot(latest)
+        .saveChild2Snapshot(child, latest);
+  }
+
+  /**
+   * @param name the name of the child
+   * @param snapshot
+   *          if it is not null, get the result from the given snapshot;
+   *          otherwise, get the result from the current directory.
+   * @return the child inode.
+   */
+  public INode getChild(byte[] name, Snapshot snapshot) {
-      INodeDirectory parentDir = (INodeDirectory)curNode;
+      final INodeDirectory parentDir = (INodeDirectory)curNode;
+      final byte[] childName = components[count + 1];
-      if (isDotSnapshotDir(components[count + 1])
+      if (isDotSnapshotDir(childName)
-          return existing;
+          break;
-        curNode = parentDir.getChild(components[count + 1],
-            existing.getPathSnapshot());
+        curNode = parentDir.getChild(childName, existing.getPathSnapshot());
-  int nextChild(byte[] name) {
+  static int nextChild(ReadOnlyList<INode> children, byte[] name) {
-    int nextPos = Collections.binarySearch(children, name) + 1;
+    int nextPos = ReadOnlyList.Util.binarySearch(children, name) + 1;
-  public boolean addChild(final INode node, final boolean setModTime) {
+  public boolean addChild(final INode node, final boolean setModTime,
+      final Snapshot latest) {
+    if (latest != null) {
+      final INodeDirectoryWithSnapshot dir = replaceSelf4INodeDirectoryWithSnapshot(latest);
+      return dir.addChild(node, setModTime, latest);
+    }
+
-    if (setModTime)
-      updateModificationTime(node.getModificationTime());
+    if (setModTime) {
+      updateModificationTime(node.getModificationTime(), latest);
+    }
-      node.setGroup(getGroupName());
+      node.setGroup(getGroupName(), latest);
-    return parent.addChild(newNode, true);
+    return parent.addChild(newNode, true, iip.getLatestSnapshot());
+
-  static class INodesInPath {
+  public static class INodesInPath {
-  public void dumpTreeRecursively(PrintWriter out, StringBuilder prefix) {
-    super.dumpTreeRecursively(out, prefix);
+  public void dumpTreeRecursively(PrintWriter out, StringBuilder prefix,
+      final Snapshot snapshot) {
+    super.dumpTreeRecursively(out, prefix, snapshot);
-    dumpTreeRecursively(out, prefix, children);
+    dumpTreeRecursively(out, prefix,
+        new Iterable<Pair<? extends INode, Snapshot>>() {
+      final Iterator<INode> i = getChildrenList(snapshot).iterator();
+      
+      @Override
+      public Iterator<Pair<? extends INode, Snapshot>> iterator() {
+        return new Iterator<Pair<? extends INode, Snapshot>>() {
+          @Override
+          public boolean hasNext() {
+            return i.hasNext();
+          }
+
+          @Override
+          public Pair<INode, Snapshot> next() {
+            return new Pair<INode, Snapshot>(i.next(), snapshot);
+          }
+
+          @Override
+          public void remove() {
+            throw new UnsupportedOperationException();
+          }
+        };
+      }
+    });
-      StringBuilder prefix, Iterable<? extends INode> subs) {
+      StringBuilder prefix, Iterable<Pair<? extends INode, Snapshot>> subs) {
-      for(final Iterator<? extends INode> i = subs.iterator(); i.hasNext();) {
-        final INode inode = i.next();
+      for(final Iterator<Pair<? extends INode, Snapshot>> i = subs.iterator(); i.hasNext();) {
+        final Pair<? extends INode, Snapshot> pair = i.next();
-        inode.dumpTreeRecursively(out, prefix);
+        pair.left.dumpTreeRecursively(out, prefix, pair.right);

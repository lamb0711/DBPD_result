HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.

-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_HA_NAMENODES_KEY_PREFIX;
-  private final Set<Block> postponedMisreplicatedBlocks = Sets.newHashSet();
+  private final Set<BlockInfo> postponedMisreplicatedBlocks = Sets.newHashSet();
-        conf.get(DFSConfigKeys.NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY) == null
-            ? false : true;
+        conf.get(DFSConfigKeys.NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY) != null;
-    return isBlockTokenEnabled()? blockTokenSecretManager.updateKeys(updateTime)
-        : false;
+    return isBlockTokenEnabled() && blockTokenSecretManager.updateKeys(updateTime);
-      for (Block block : neededReplications) {
+      for (BlockInfo block : neededReplications) {
-    for (Block block : postponedMisreplicatedBlocks) {
+    for (BlockInfo block : postponedMisreplicatedBlocks) {
-  private void dumpBlockMeta(Block block, PrintWriter out) {
-    List<DatanodeDescriptor> containingNodes =
-                                      new ArrayList<DatanodeDescriptor>();
-    List<DatanodeStorageInfo> containingLiveReplicasNodes =
-      new ArrayList<>();
+  private void dumpBlockMeta(BlockInfo block, PrintWriter out) {
+    List<DatanodeDescriptor> containingNodes = new ArrayList<>();
+    List<DatanodeStorageInfo> containingLiveReplicasNodes = new ArrayList<>();
-    // containingLiveReplicasNodes can include READ_ONLY_SHARED replicas which are 
-    // not included in the numReplicas.liveReplicas() count
+    // containingLiveReplicasNodes can include READ_ONLY_SHARED replicas which
+    // are not included in the numReplicas.liveReplicas() count
-    
-    if (block instanceof BlockInfo) {
-      BlockCollection bc = ((BlockInfo) block).getBlockCollection();
-      String fileName = (bc == null) ? "[orphaned]" : bc.getName();
-      out.print(fileName + ": ");
-    }
+
+    BlockCollection bc = block.getBlockCollection();
+    String fileName = (bc == null) ? "[orphaned]" : bc.getName();
+    out.print(fileName + ": ");
+
-    Collection<DatanodeDescriptor> corruptNodes = 
-                                  corruptReplicas.getNodes(block);
+    Collection<DatanodeDescriptor> corruptNodes =
+        corruptReplicas.getNodes(block);
-    long curPos = 0, blkSize = 0;
+    long curPos = 0;
+    long blkSize;
-   * 
-   * @param b
+   * Mark a replica (of a contiguous block) or an internal block (of a striped
+   * block group) as corrupt.
+   * @param b Indicating the reported bad block and the corresponding BlockInfo
+   *          stored in blocksMap.
-   * @throws IOException
-    corruptReplicas.addToCorruptReplicasMap(b.corrupted, node, b.reason,
+    corruptReplicas.addToCorruptReplicasMap(b.stored, node, b.reason,
-      invalidateBlock(b, node);
+      invalidateBlock(b, node, numberOfReplicas);
-   * Invalidates the given block on the given datanode.
-   * @return true if the block was successfully invalidated and no longer
-   * present in the BlocksMap
+   * Invalidates the given block on the given datanode. Note that before this
+   * call we have already checked the current live replicas of the block and
+   * make sure it's safe to invalidate the replica.
+   *
+   * @return true if the replica was successfully invalidated and no longer
+   *         associated with the DataNode.
-  private boolean invalidateBlock(BlockToMarkCorrupt b, DatanodeInfo dn
-      ) throws IOException {
+  private boolean invalidateBlock(BlockToMarkCorrupt b, DatanodeInfo dn,
+      NumberReplicas nr) throws IOException {
-    NumberReplicas nr = countNodes(b.stored);
-      postponeBlock(b.corrupted);
+      postponeBlock(b.stored);
-    } else if (nr.liveReplicas() >= 1) {
-      // If we have at least one copy on a live node, then we can delete it.
+    } else {
+      // we already checked the number of replicas in the caller of this
+      // function and we know there is at least one copy on a live node, so we
+      // can delete it.
-    } else {
-      blockLog.info("BLOCK* invalidateBlocks: {} on {} is the only copy and" +
-          " was not deleted", b, dn);
-      return false;
-
-
-  private void postponeBlock(Block blk) {
+  private void postponeBlock(BlockInfo blk) {
-    BlockCollection bc = null;
+    BlockCollection bc;
-          for (int k = 0; k < targets.length; k++) {
+          for (DatanodeStorageInfo target : targets) {
-            targetList.append(targets[k].getDatanodeDescriptor());
+            targetList.append(target.getDatanodeDescriptor());
-      for (int i = 0; i < nodes.size(); i++) {
-        DatanodeDescriptor node = datanodeManager.getDatanodeDescriptor(nodes.get(i));
+      for (String nodeStr : nodes) {
+        DatanodeDescriptor node = datanodeManager.getDatanodeDescriptor(nodeStr);
-   DatanodeDescriptor chooseSourceDatanode(Block block,
+   DatanodeDescriptor chooseSourceDatanode(BlockInfo block,
-        for (int i = 0; i < timedOutItems.length; i++) {
+        for (BlockInfo timedOutItem : timedOutItems) {
-          BlockInfo bi = getStoredBlock(timedOutItems[i]);
+          BlockInfo bi = getStoredBlock(timedOutItem);
-          NumberReplicas num = countNodes(timedOutItems[i]);
+          NumberReplicas num = countNodes(timedOutItem);
-    DatanodeDescriptor node = null;
+    DatanodeDescriptor node;
-      Iterator<Block> it = postponedMisreplicatedBlocks.iterator();
+      Iterator<BlockInfo> it = postponedMisreplicatedBlocks.iterator();
-    BlockToMarkCorrupt b = null;
+    BlockToMarkCorrupt b;
-      invalidateCorruptReplicas(storedBlock, reportedBlock);
+      invalidateCorruptReplicas(storedBlock, reportedBlock, num);
-  private void invalidateCorruptReplicas(BlockInfo blk, Block reported) {
+  private void invalidateCorruptReplicas(BlockInfo blk, Block reported,
+      NumberReplicas numberReplicas) {
-    DatanodeDescriptor[] nodesCopy = nodes.toArray(new DatanodeDescriptor[0]);
+    DatanodeDescriptor[] nodesCopy = nodes.toArray(
+        new DatanodeDescriptor[nodes.size()]);
-            Reason.ANY), node)) {
+            Reason.ANY), node, numberReplicas)) {
-        return;
-        boolean removed = false;
-        removed |= node.getPendingCached().remove(cblock);
+        boolean removed = node.getPendingCached().remove(cblock);
-    for(DatanodeStorageInfo storage : blocksMap.getStorages(b, State.NORMAL)) {
+    for (DatanodeStorageInfo storage : blocksMap.getStorages(b, State.NORMAL)) {
-    return new NumberReplicas(live, decommissioned, decommissioning, corrupt, excess, stale);
+    return new NumberReplicas(live, decommissioned, decommissioning, corrupt,
+        excess, stale);
-        final BlockInfoUnderConstruction uc =
-            (BlockInfoUnderConstruction)b;
-  public int numCorruptReplicas(Block block) {
-    return corruptReplicas.numCorruptReplicas(block);
-  }
-
-  public void removeBlockFromMap(Block block) {
+  public void removeBlockFromMap(BlockInfo block) {
-  private void removeFromExcessReplicateMap(Block block) {
+  private void removeFromExcessReplicateMap(BlockInfo block) {
-  public Collection<DatanodeDescriptor> getCorruptReplicas(Block block) {
+  public Collection<DatanodeDescriptor> getCorruptReplicas(BlockInfo block) {
- public String getCorruptReason(Block block, DatanodeDescriptor node) {
+ public String getCorruptReason(BlockInfo block, DatanodeDescriptor node) {
-  };
+  }

YARN-2934. Improve handling of container's stderr. (Naganarasimha G R via gera)

+import java.nio.charset.StandardCharsets;
+import org.apache.hadoop.fs.FSDataInputStream;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.yarn.server.nodemanager.WindowsSecureContainerExecutor;
-import org.apache.hadoop.yarn.server.nodemanager.WindowsSecureContainerExecutor;
+    Path containerLogDir;
-      Path containerLogDir =
+      containerLogDir =
+
+    StringBuilder diagnosticInfo =
+        new StringBuilder("Container exited with a non-zero exit code ");
+    diagnosticInfo.append(ret);
+    diagnosticInfo.append(". ");
-                "Container exited with a non-zero exit code " + ret));
+                diagnosticInfo.toString()));
-      LOG.warn("Container exited with a non-zero exit code " + ret);
-      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(
-          containerID,
-          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,
-          "Container exited with a non-zero exit code " + ret));
+      handleContainerExitWithFailure(containerID, ret, containerLogDir,
+          diagnosticInfo);
+  /**
+   * Tries to tail and fetch TAIL_SIZE_IN_BYTES of data from the error log.
+   * ErrorLog filename is not fixed and depends upon app, hence file name
+   * pattern is used.
+   * @param containerID
+   * @param ret
+   * @param containerLogDir
+   * @param diagnosticInfo
+   */
+  @SuppressWarnings("unchecked")
+  private void handleContainerExitWithFailure(ContainerId containerID, int ret,
+      Path containerLogDir, StringBuilder diagnosticInfo) {
+    LOG.warn(diagnosticInfo);
+
+    String errorFileNamePattern =
+        conf.get(YarnConfiguration.NM_CONTAINER_STDERR_PATTERN,
+            YarnConfiguration.DEFAULT_NM_CONTAINER_STDERR_PATTERN);
+    FSDataInputStream errorFileIS = null;
+    try {
+      FileSystem fileSystem = FileSystem.getLocal(conf).getRaw();
+      FileStatus[] errorFileStatuses = fileSystem
+          .globStatus(new Path(containerLogDir, errorFileNamePattern));
+      if (errorFileStatuses != null && errorFileStatuses.length != 0) {
+        long tailSizeInBytes =
+            conf.getLong(YarnConfiguration.NM_CONTAINER_STDERR_BYTES,
+                YarnConfiguration.DEFAULT_NM_CONTAINER_STDERR_BYTES);
+        Path errorFile = errorFileStatuses[0].getPath();
+        long fileSize = errorFileStatuses[0].getLen();
+
+        // if more than one file matches the stderr pattern, take the latest
+        // modified file, and also append the file names in the diagnosticInfo
+        if (errorFileStatuses.length > 1) {
+          String[] errorFileNames = new String[errorFileStatuses.length];
+          long latestModifiedTime = errorFileStatuses[0].getModificationTime();
+          errorFileNames[0] = errorFileStatuses[0].getPath().getName();
+          for (int i = 1; i < errorFileStatuses.length; i++) {
+            errorFileNames[i] = errorFileStatuses[i].getPath().getName();
+            if (errorFileStatuses[i]
+                .getModificationTime() > latestModifiedTime) {
+              latestModifiedTime = errorFileStatuses[i].getModificationTime();
+              errorFile = errorFileStatuses[i].getPath();
+              fileSize = errorFileStatuses[i].getLen();
+            }
+          }
+          diagnosticInfo.append("Error files: ")
+              .append(StringUtils.join(", ", errorFileNames)).append(".\n");
+        }
+
+        long startPosition =
+            (fileSize < tailSizeInBytes) ? 0 : fileSize - tailSizeInBytes;
+        int bufferSize =
+            (int) ((fileSize < tailSizeInBytes) ? fileSize : tailSizeInBytes);
+        byte[] tailBuffer = new byte[bufferSize];
+        errorFileIS = fileSystem.open(errorFile);
+        errorFileIS.readFully(startPosition, tailBuffer);
+
+        diagnosticInfo.append("Last ").append(tailSizeInBytes)
+            .append(" bytes of ").append(errorFile.getName()).append(" :\n")
+            .append(new String(tailBuffer, StandardCharsets.UTF_8));
+      }
+    } catch (IOException e) {
+      LOG.error("Failed to get tail of the container's error log file", e);
+    } finally {
+      IOUtils.cleanup(LOG, errorFileIS);
+    }
+
+    this.dispatcher.getEventHandler()
+        .handle(new ContainerExitEvent(containerID,
+            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,
+            diagnosticInfo.toString()));
+  }
+

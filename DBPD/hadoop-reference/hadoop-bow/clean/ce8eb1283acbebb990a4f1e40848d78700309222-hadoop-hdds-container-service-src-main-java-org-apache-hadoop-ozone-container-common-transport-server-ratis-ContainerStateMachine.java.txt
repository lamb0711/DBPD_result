Revert "HDDS-1610. applyTransaction failure should not be lost on restart. Contributed by Shashikant Banerjee."

This reverts commit 62445021d5d57b0d49adcb1bd4365c13532328fc as it has unintended changes in DirectoryWithSnapshotFeature class..

-import org.apache.ratis.protocol.StateMachineException;
-import java.util.concurrent.atomic.AtomicBoolean;
-  private final AtomicBoolean isStateMachineHealthy;
-    isStateMachineHealthy = new AtomicBoolean(true);
-    if (!isStateMachineHealthy.get()) {
-      String msg =
-          "Failed to take snapshot " + " for " + gid + " as the stateMachine"
-              + " is unhealthy. The last applied index is at " + ti;
-      StateMachineException sme = new StateMachineException(msg);
-      LOG.error(msg);
-      throw sme;
-    }
-        LOG.error("{}: Failed to write snapshot at:{} file {}", gid, ti,
+        LOG.info("{}: Failed to write snapshot at:{} file {}", gid, ti,
-      LOG.info("{}: Finished taking a snapshot at:{} file:{} time:{}", gid, ti,
-          snapshotFile, (Time.monotonicNow() - startTime));
+      LOG.info("{}: Finished taking a snapshot at:{} file:{} time:{}",
+          gid, ti, snapshotFile, (Time.monotonicNow() - startTime));
-  private ContainerCommandResponseProto runCommand(
+  private ContainerCommandResponseProto runCommandGetResponse(
+  private Message runCommand(ContainerCommandRequestProto requestProto,
+      DispatcherContext context) {
+    return runCommandGetResponse(requestProto, context)::toByteString;
+  }
+
-            runCommand(requestProto, context), chunkExecutor);
+            runCommandGetResponse(requestProto, context), chunkExecutor);
-      return CompletableFuture
-          .completedFuture(runCommand(requestProto, null)::toByteString);
+      return CompletableFuture.completedFuture(runCommand(requestProto, null));
-      CompletableFuture<Message> applyTransactionFuture =
-          new CompletableFuture<>();
-      CompletableFuture<ContainerCommandResponseProto> future =
-          CompletableFuture.supplyAsync(
-              () -> runCommand(requestProto, builder.build()),
+      CompletableFuture<Message> future = CompletableFuture
+          .supplyAsync(() -> runCommand(requestProto, builder.build()),
-      future.thenApply(r -> {
+
+      future.thenAccept(m -> {
-        if (r.getResult() != ContainerProtos.Result.SUCCESS) {
-          StorageContainerException sce =
-              new StorageContainerException(r.getMessage(), r.getResult());
-          LOG.error(
-              "gid {} : ApplyTransaction failed. cmd {} logIndex {} msg : "
-                  + "{} Container Result: {}", gid, r.getCmdType(), index,
-              r.getMessage(), r.getResult());
-          metrics.incNumApplyTransactionsFails();
-          // Since the applyTransaction now is completed exceptionally,
-          // before any further snapshot is taken , the exception will be
-          // caught in stateMachineUpdater in Ratis and ratis server will
-          // shutdown.
-          applyTransactionFuture.completeExceptionally(sce);
-          isStateMachineHealthy.compareAndSet(true, false);
-          ratisServer.handleApplyTransactionFailure(gid, trx.getServerRole());
-        } else {
-          LOG.debug(
-              "gid {} : ApplyTransaction completed. cmd {} logIndex {} msg : "
-                  + "{} Container Result: {}", gid, r.getCmdType(), index,
-              r.getMessage(), r.getResult());
-          applyTransactionFuture.complete(r::toByteString);
-          if (cmdType == Type.WriteChunk || cmdType == Type.PutSmallFile) {
-            metrics.incNumBytesCommittedCount(
-                requestProto.getWriteChunk().getChunkData().getLen());
-          }
-          // add the entry to the applyTransactionCompletionMap only if the
-          // stateMachine is healthy i.e, there has been no applyTransaction
-          // failures before.
-          if (isStateMachineHealthy.get()) {
-            final Long previous = applyTransactionCompletionMap
+
+        final Long previous =
+            applyTransactionCompletionMap
-            Preconditions.checkState(previous == null);
-            updateLastApplied();
-          }
+        Preconditions.checkState(previous == null);
+        if (cmdType == Type.WriteChunk || cmdType == Type.PutSmallFile) {
+          metrics.incNumBytesCommittedCount(
+              requestProto.getWriteChunk().getChunkData().getLen());
-        return applyTransactionFuture;
+        updateLastApplied();
-      return applyTransactionFuture;
+      return future;

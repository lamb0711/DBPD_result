HDFS-13818. Extend OIV to detect FSImage corruption. Contributed by Adam Antal.

Signed-off-by: Wei-Chiu Chuang <weichiu@apache.org>

+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.text.StringEscapeUtils;
+import java.util.concurrent.atomic.AtomicInteger;
+  static final String DEFAULT_DELIMITER = "\t";
+  static final String CRLF = StringUtils.CR + StringUtils.LF;
+
+
+    /** Returns the name of inode. */
+    String getName(long id) throws IOException;
+
+    /**
+     * Returns the id of the parent's inode, if mentioned in
+     * INodeDirectorySection, throws IgnoreSnapshotException otherwise.
+     */
+    long getParentId(long id) throws IOException;
-      private String getPath() {
+      String getPath() throws IgnoreSnapshotException {
-          return "/";
+          if (this.inode == INodeId.ROOT_INODE_ID) {
+            return "/";
+          } else {
+            if (LOG.isDebugEnabled()) {
+              LOG.debug("Not root inode with id {} having no parent.", inode);
+            }
+            throw PBImageTextWriter.createIgnoredSnapshotException(inode);
+          }
-          this.name = null;
+      String getName() throws IgnoreSnapshotException {
+        return name;
+      }
+
+      long getId() {
+        return inode;
+      }
+
+    /**
+     * If the Dir entry does not exist (i.e. the inode was not contained in
+     * INodeSection) we still create a Dir entry which throws exceptions
+     * for calls other than getId().
+     * We can make sure this way, the getId and getParentId calls will
+     * always succeed if we have the information.
+     */
+    private static class CorruptedDir extends Dir {
+      CorruptedDir(long inode) {
+        super(inode, null);
+      }
+
+      @Override
+      String getPath() throws IgnoreSnapshotException {
+        throw PBImageTextWriter.createIgnoredSnapshotException(getId());
+      }
+
+      @Override
+      String getName() throws IgnoreSnapshotException {
+        throw PBImageTextWriter.createIgnoredSnapshotException(getId());
+      }
+    }
+
+    private Dir getOrCreateCorrupted(long id) {
+      Dir dir = dirMap.get(id);
+      if (dir == null) {
+        dir = new CorruptedDir(id);
+        dirMap.put(id, dir);
+      }
+      return dir;
+    }
+
-      Dir parent = dirMap.get(parentId);
-      Dir child = dirMap.get(childId);
-      if (child != null) {
-        child.setParent(parent);
-      }
+      Dir parent = getOrCreateCorrupted(parentId);
+      Dir child = getOrCreateCorrupted(childId);
+      child.setParent(parent);
-        return "";
+        return "/";
-        PBImageTextWriter.ignoreSnapshotName(inode);
+        throw PBImageTextWriter.createIgnoredSnapshotException(inode);
+
+    @Override
+    public String getName(long id) throws IgnoreSnapshotException {
+      Dir dir = dirMap.get(id);
+      if (dir != null) {
+        return dir.getName();
+      }
+      throw PBImageTextWriter.createIgnoredSnapshotException(id);
+    }
+
+    @Override
+    public long getParentId(long id) throws IgnoreSnapshotException {
+      Dir parentDir = dirChildMap.get(id);
+      if (parentDir != null) {
+        return parentDir.getId();
+      }
+      throw PBImageTextWriter.createIgnoredSnapshotException(id);
+    }
-    @Override
-    public String getParentPath(long inode) throws IOException {
-      if (inode == INodeId.ROOT_INODE_ID) {
-        return "/";
-      }
+    private long getFromDirChildMap(long inode) throws IOException {
-        PBImageTextWriter.ignoreSnapshotName(inode);
+        throw PBImageTextWriter.createIgnoredSnapshotException(inode);
-      long parent = toLong(bytes);
+      return toLong(bytes);
+    }
+
+    @Override
+    public String getParentPath(long inode) throws IOException {
+      if (inode == INodeId.ROOT_INODE_ID) {
+        return "/";
+      }
+      long parent = getFromDirChildMap(inode);
-        bytes = dirMap.get(toBytes(parent));
+        byte[] bytes = dirMap.get(toBytes(parent));
-          PBImageTextWriter.ignoreSnapshotName(parent);
+          throw PBImageTextWriter.createIgnoredSnapshotException(inode);
-                parentName.isEmpty()? "/" : parentName).toString();
+                parentName.isEmpty() ? "/" : parentName).toString();
+
+    @Override
+    public String getName(long id) throws IOException {
+      byte[] bytes = dirMap.get(toBytes(id));
+      if (bytes != null) {
+        return toString(bytes);
+      }
+      throw PBImageTextWriter.createIgnoredSnapshotException(id);
+    }
+
+    @Override
+    public long getParentId(long id) throws IOException {
+      return getFromDirChildMap(id);
+    }
+  private String delimiter;
-  PBImageTextWriter(PrintStream out, String tempPath) throws IOException {
+  PBImageTextWriter(PrintStream out, String delimiter, String tempPath)
+      throws IOException {
+    this.delimiter = delimiter;
+  void append(StringBuffer buffer, int field) {
+    buffer.append(delimiter);
+    buffer.append(field);
+  }
+
+  void append(StringBuffer buffer, long field) {
+    buffer.append(delimiter);
+    buffer.append(field);
+  }
+
+  void append(StringBuffer buffer, String field) {
+    buffer.append(delimiter);
+
+    String escapedField = StringEscapeUtils.escapeCsv(field);
+    if (escapedField.contains(CRLF)) {
+      escapedField = escapedField.replace(CRLF, "%x0D%x0A");
+    } else if (escapedField.contains(StringUtils.LF)) {
+      escapedField = escapedField.replace(StringUtils.LF, "%x0A");
+    }
+
+    buffer.append(escapedField);
+  }
+
+  /**
+   * Method called at the end of output() phase after all the inodes
+   * with known parentPath has been printed out. Can be used to print
+   * additional data depending on the written inodes.
+   */
+  abstract protected void afterOutput() throws IOException;
+
+  void putDirChildToMetadataMap(long parentId, long childId)
+      throws IOException {
+    metadataMap.putDirChild(parentId, childId);
+  }
+
+  String getNodeName(long id) throws IOException {
+    return metadataMap.getName(id);
+  }
+
+  long getParentId(long id) throws IOException {
+    return metadataMap.getParentId(id);
+  }
+
+    afterOutput();
+   * Checks the inode (saves if directory), and counts them. Can be overridden
+   * if additional steps are taken when iterating through INodeSection.
+   */
+  protected void checkNode(INode p, AtomicInteger numDirs) throws IOException {
+    if (p.hasDirectory()) {
+      metadataMap.putDir(p);
+      numDirs.incrementAndGet();
+    }
+  }
+
+  /**
-  private void loadDirectoriesInINodeSection(InputStream in) throws IOException {
+  private void loadDirectoriesInINodeSection(InputStream in)
+      throws IOException {
-    int numDirs = 0;
+    AtomicInteger numDirs = new AtomicInteger(0);
-      if (p.hasDirectory()) {
-        metadataMap.putDir(p);
-        numDirs++;
-      }
+      checkNode(p, numDirs);
-  private void buildNamespace(InputStream in, List<Long> refIdList)
+  protected void buildNamespace(InputStream in, List<Long> refIdList)
+  void printIfNotEmpty(String line) {
+    if (!line.isEmpty()) {
+      out.println(line);
+    }
+  }
+
-        out.println(getEntry(parentPath, p));
+        printIfNotEmpty(getEntry(parentPath, p));
-  static void ignoreSnapshotName(long inode) throws IOException {
+  private static IgnoreSnapshotException createIgnoredSnapshotException(
+      long inode) {
-    throw new IgnoreSnapshotException();
+    return new IgnoreSnapshotException();

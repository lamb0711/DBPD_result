HDFS-4317. Change INode and its subclasses to support HDFS-4103.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1422748 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.snapshot.INodeFileWithLink;
+import com.google.common.base.Preconditions;
+
+  @Override
+  public Pair<INodeDirectory, INodeDirectory> createSnapshotCopy() {
+    return new Pair<INodeDirectory, INodeDirectory>(this,
+        new INodeDirectory(this, false));
+  }
-  private int searchChildren(INode inode) {
-    return Collections.binarySearch(children, inode.getLocalNameBytes());
+  private int searchChildren(byte[] name) {
+    return Collections.binarySearch(children, name);
+  }
+
+  protected int searchChildrenForExistingINode(byte[] name) {
+    assertChildrenNonNull();
+    final int i = searchChildren(name);
+    if (i < 0) {
+      throw new AssertionError("Child not found: name="
+          + DFSUtil.bytes2String(name));
+    }
+    return i;
+  }
+  
+  protected INode getExistingChild(int i) {
+    return children.get(i);
-    final int i = searchChildren(node);
+    final int i = searchChildren(node.getLocalNameBytes());
-    final int low = searchChildren(newChild);
+    final int low = searchChildren(newChild.getLocalNameBytes());
+  /** Replace a child {@link INodeFile} with an {@link INodeFileWithLink}. */
+  INodeFileWithLink replaceINodeFile(final INodeFile child) {
+    assertChildrenNonNull();
+    Preconditions.checkArgument(!(child instanceof INodeFileWithLink),
+        "Child file is already an INodeFileWithLink, child=" + child);
+
+    final INodeFileWithLink newChild = new INodeFileWithLink(child);
+    final int i = searchChildrenForExistingINode(newChild.getLocalNameBytes());
+    children.set(i, newChild);
+    return newChild;
+  }
+
-    INodesInPath existing = new INodesInPath(numOfINodes);
+    INodesInPath existing = new INodesInPath(components, numOfINodes);
-    final int low = searchChildren(node);
+    final int low = searchChildren(node.getLocalNameBytes());
-      setModificationTime(node.getModificationTime());
+      updateModificationTime(node.getModificationTime());
-    INodeDirectory parent = getParent(pathComponents);
+    final INodesInPath iip =  getExistingPathINodes(pathComponents, 2, false);
+    final INodeDirectory parent = INodeDirectory.valueOf(iip.getINode(0),
+        pathComponents);
-  INodeDirectory getParent(byte[][] pathComponents
-      ) throws FileNotFoundException, PathIsNotDirectoryException,
-      UnresolvedLinkException {
-    if (pathComponents.length < 2)  // add root
-      return null;
-    // Gets the parent INode
-    INodesInPath inodes =  getExistingPathINodes(pathComponents, 2, false);
-    return INodeDirectory.valueOf(inodes.inodes[0], pathComponents);
-  }
-
+   * @param snapshot
+   *          if it is not null, get the result from the given snapshot;
+   *          otherwise, get the result from the current directory.
-    //TODO: use snapshot to select children list
+    private final byte[][] path;
-    INodesInPath(int number) {
+    private INodesInPath(byte[][] path, int number) {
+      this.path = path;
-    INode getINode(int i) {
+    public INode getINode(int i) {
+    /** @return the last inode. */
+    public INode getLastINode() {
+      return inodes[inodes.length - 1];
+    }
+    
+      return toString(true);
+    }
+
+    private String toString(boolean vaildateObject) {
+      if (vaildateObject) {
+        vaildate();
+      }
+
-          .append(":\n  inodes = ");
+          .append(": path = ").append(DFSUtil.byteArray2PathString(path))
+          .append("\n  inodes = ");
+
+    void vaildate() {
+      // check parent up to snapshotRootIndex or numNonNull
+      final int n = snapshotRootIndex >= 0? snapshotRootIndex + 1: numNonNull;  
+      int i = 0;
+      if (inodes[i] != null) {
+        for(i++; i < n && inodes[i] != null; i++) {
+          final INodeDirectory parent_i = inodes[i].getParent();
+          final INodeDirectory parent_i_1 = inodes[i-1].getParent();
+          if (parent_i != inodes[i-1] &&
+              (parent_i_1 == null || !parent_i_1.isSnapshottable()
+                  || parent_i != parent_i_1)) {
+            throw new AssertionError(
+                "inodes[" + i + "].getParent() != inodes[" + (i-1)
+                + "]\n  inodes[" + i + "]=" + inodes[i].toDetailString()
+                + "\n  inodes[" + (i-1) + "]=" + inodes[i-1].toDetailString()
+                + "\n this=" + toString(false));
+          }
+        }
+      }
+      if (i != n) {
+        throw new AssertionError("i = " + i + " != " + n
+            + ", this=" + toString(false));
+      }
+    }

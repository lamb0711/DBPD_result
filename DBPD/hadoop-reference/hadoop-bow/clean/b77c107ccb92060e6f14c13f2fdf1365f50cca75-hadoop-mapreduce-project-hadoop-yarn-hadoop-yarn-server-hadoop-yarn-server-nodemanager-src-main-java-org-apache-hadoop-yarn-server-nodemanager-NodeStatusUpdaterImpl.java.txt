Committing rest of merge from trunk (accidentally only committed the HDFS portion before)


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1214546 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+
+  private boolean tokenKeepAliveEnabled;
+  private long tokenRemovalDelayMs;
+  /** Keeps track of when the next keep alive request should be sent for an app*/
+  private Map<ApplicationId, Long> appTokenKeepAliveMap =
+      new HashMap<ApplicationId, Long>();
+  private Random keepAliveDelayRandom = new Random();
+    this.tokenKeepAliveEnabled =
+        conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,
+            YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)
+            && isSecurityEnabled();
+    this.tokenRemovalDelayMs =
+        conf.getInt(YarnConfiguration.RM_NM_EXPIRY_INTERVAL_MS,
+            YarnConfiguration.DEFAULT_RM_NM_EXPIRY_INTERVAL_MS);
+  protected boolean isSecurityEnabled() {
+    return UserGroupInformation.isSecurityEnabled();
+  }
+
+  private List<ApplicationId> createKeepAliveApplicationList() {
+    if (!tokenKeepAliveEnabled) {
+      return Collections.emptyList();
+    }
+
+    List<ApplicationId> appList = new ArrayList<ApplicationId>();
+    for (Iterator<Entry<ApplicationId, Long>> i =
+        this.appTokenKeepAliveMap.entrySet().iterator(); i.hasNext();) {
+      Entry<ApplicationId, Long> e = i.next();
+      ApplicationId appId = e.getKey();
+      Long nextKeepAlive = e.getValue();
+      if (!this.context.getApplications().containsKey(appId)) {
+        // Remove if the application has finished.
+        i.remove();
+      } else if (System.currentTimeMillis() > nextKeepAlive) {
+        // KeepAlive list for the next hearbeat.
+        appList.add(appId);
+        trackAppForKeepAlive(appId);
+      }
+    }
+    return appList;
+  }
+
+    List<ApplicationId> keepAliveAppIds = createKeepAliveApplicationList();
+    nodeStatus.setKeepAliveApplications(keepAliveAppIds);
+    
+  private void trackAppsForKeepAlive(List<ApplicationId> appIds) {
+    if (tokenKeepAliveEnabled && appIds != null && appIds.size() > 0) {
+      for (ApplicationId appId : appIds) {
+        trackAppForKeepAlive(appId);
+      }
+    }
+  }
+
+  private void trackAppForKeepAlive(ApplicationId appId) {
+    // Next keepAlive request for app between 0.7 & 0.9 of when the token will
+    // likely expire.
+    long nextTime = System.currentTimeMillis()
+    + (long) (0.7 * tokenRemovalDelayMs + (0.2 * tokenRemovalDelayMs
+        * keepAliveDelayRandom.nextInt(100))/100);
+    appTokenKeepAliveMap.put(appId, nextTime);
+  }
+
+      @SuppressWarnings("unchecked")
+            //Only start tracking for keepAlive on FINISH_APP
+            trackAppsForKeepAlive(appsToCleanup);

Revert "HADOOP-15836. Review of AccessControlList. Contributed by BELUGA BEHR."

This reverts commit 00254d7b8c714ae2000d0934d260b23458033529.

-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Set;
-import java.util.TreeSet;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
-import org.apache.commons.lang3.StringUtils;
+import org.apache.hadoop.util.StringUtils;
-  static { // register a ctor
+  static {                                      // register a ctor
-  private final Set<String> users = new TreeSet<>();
+  private Collection<String> users;
-  private final Set<String> groups = new TreeSet<>();
+  private Collection<String> groups;
-   *
+   * 
-   * The user list comes first and is separated by a space followed
+   * The user list comes first and is separated by a space followed 
-   *
+   * 
-
+  
-   * Construct a new ACL from String representation of users and groups.
-   *
+   * Construct a new ACL from String representation of users and groups
+   * 
-   *
+   * 
+    users = new HashSet<String>();
+    groups = new HashSet<String>();
-        return;
+        break;
-    if (userGroupStrings.length >= 1 && userGroupStrings[0] != null) {
-      String[] userList = userGroupStrings[0].split(",");
-      for (String user : userList) {
-        if (StringUtils.isNotBlank(user)) {
-          users.add(user.trim());
-        }
+    if (!allAllowed) {      
+      if (userGroupStrings.length >= 1 && userGroupStrings[0] != null) {
+        users = StringUtils.getTrimmedStringCollection(userGroupStrings[0]);
+      } 
+      
+      if (userGroupStrings.length == 2 && userGroupStrings[1] != null) {
+        groups = StringUtils.getTrimmedStringCollection(userGroupStrings[1]);
+        groupsMapping.cacheGroupsAdd(new LinkedList<String>(groups));
-    if (userGroupStrings.length == 2 && userGroupStrings[1] != null) {
-      String[] groupList = userGroupStrings[1].split(",");
-      for (String group : groupList) {
-        if (StringUtils.isNotBlank(group)) {
-          groups.add(group.trim());
-        }
-      }
-      groupsMapping.cacheGroupsAdd(new ArrayList<>(groups));
-    }
-
+  
-   * Checks whether ACL string contains wildcard.
+   * Checks whether ACL string contains wildcard
-    return WILDCARD_ACL_VALUE.equals(aclString.trim());
+    if (aclString.contains(WILDCARD_ACL_VALUE) && 
+        aclString.trim().equals(WILDCARD_ACL_VALUE)) {
+      return true;
+    }
+    return false;
-
+  
-   *
-   * @param user The user name
+   * 
+   * @param user
+   *          The user name
-   *
-   * @param group The group name
+   * 
+   * @param group
+   *          The group name
-      throw new IllegalArgumentException(
-          "Group " + group + " can not be added");
+      throw new IllegalArgumentException("Group " + group + " can not be added");
-      groupsMapping.cacheGroupsAdd(Collections.singletonList(group));
+      List<String> groupsList = new LinkedList<String>();
+      groupsList.add(group);
+      groupsMapping.cacheGroupsAdd(groupsList);
-   *
-   * @param user The user name
+   * 
+   * @param user
+   *          The user name
-   *
-   * @param group The group name
+   * 
+   * @param group
+   *          The group name
-      throw new IllegalArgumentException(
-          "Group " + group + " can not be removed");
+      throw new IllegalArgumentException("Group " + group
+          + " can not be removed");
-   *
-   * @return an unmodifiable set of user names in alphabetic order.
+   * @return the set of user names. the set must not be modified.
-    return Collections.unmodifiableSet(users);
+    return users;
-
+  
-   *
-   * @return an unmodifiable set of group names in alphabetic order.
+   * @return the set of group names. the set must not be modified.
-    return Collections.unmodifiableSet(groups);
+    return groups;
-    }
-    if (!groups.isEmpty()) {
+    } else if (!groups.isEmpty()) {
-    return String.join(",", users);
+    return getString(users);
-    return String.join(",", groups);
+    return getString(groups);
+  }
+
+  /**
+   * Returns comma-separated concatenated single String of all strings of
+   * the given set
+   *
+   * @param strings set of strings to concatenate
+   */
+  private String getString(Collection<String> strings) {
+    StringBuilder sb = new StringBuilder(INITIAL_CAPACITY);
+    boolean first = true;
+    for(String str: strings) {
+      if (!first) {
+        sb.append(",");
+      } else {
+        first = false;
+      }
+      sb.append(str);
+    }
+    return sb.toString();

HDFS-14268. RBF: Fix the location of the DNs in getDatanodeReport(). Contributed by Inigo Goiri.

+import java.util.Collection;
+
+import org.apache.commons.lang3.builder.EqualsBuilder;
+import org.apache.commons.lang3.builder.HashCodeBuilder;
+
+  @Override
+  public int hashCode() {
+    return new HashCodeBuilder()
+        .append(lowRedundancyBlockGroups)
+        .append(corruptBlockGroups)
+        .append(missingBlockGroups)
+        .append(bytesInFutureBlockGroups)
+        .append(pendingDeletionBlocks)
+        .append(highestPriorityLowRedundancyBlocks)
+        .toHashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    ECBlockGroupStats other = (ECBlockGroupStats)o;
+    return new EqualsBuilder()
+        .append(lowRedundancyBlockGroups, other.lowRedundancyBlockGroups)
+        .append(corruptBlockGroups, other.corruptBlockGroups)
+        .append(missingBlockGroups, other.missingBlockGroups)
+        .append(bytesInFutureBlockGroups, other.bytesInFutureBlockGroups)
+        .append(pendingDeletionBlocks, other.pendingDeletionBlocks)
+        .append(highestPriorityLowRedundancyBlocks,
+            other.highestPriorityLowRedundancyBlocks)
+        .isEquals();
+  }
+
+  /**
+   * Merge the multiple ECBlockGroupStats.
+   * @param stats Collection of stats to merge.
+   * @return A new ECBlockGroupStats merging all the input ones
+   */
+  public static ECBlockGroupStats merge(Collection<ECBlockGroupStats> stats) {
+    long lowRedundancyBlockGroups = 0;
+    long corruptBlockGroups = 0;
+    long missingBlockGroups = 0;
+    long bytesInFutureBlockGroups = 0;
+    long pendingDeletionBlocks = 0;
+    long highestPriorityLowRedundancyBlocks = 0;
+    boolean hasHighestPriorityLowRedundancyBlocks = false;
+
+    for (ECBlockGroupStats stat : stats) {
+      lowRedundancyBlockGroups += stat.getLowRedundancyBlockGroups();
+      corruptBlockGroups += stat.getCorruptBlockGroups();
+      missingBlockGroups += stat.getMissingBlockGroups();
+      bytesInFutureBlockGroups += stat.getBytesInFutureBlockGroups();
+      pendingDeletionBlocks += stat.getPendingDeletionBlocks();
+      if (stat.hasHighestPriorityLowRedundancyBlocks()) {
+        hasHighestPriorityLowRedundancyBlocks = true;
+        highestPriorityLowRedundancyBlocks +=
+            stat.getHighestPriorityLowRedundancyBlocks();
+      }
+    }
+    if (hasHighestPriorityLowRedundancyBlocks) {
+      return new ECBlockGroupStats(lowRedundancyBlockGroups, corruptBlockGroups,
+          missingBlockGroups, bytesInFutureBlockGroups, pendingDeletionBlocks,
+          highestPriorityLowRedundancyBlocks);
+    }
+    return new ECBlockGroupStats(lowRedundancyBlockGroups, corruptBlockGroups,
+        missingBlockGroups, bytesInFutureBlockGroups, pendingDeletionBlocks);
+  }

HDFS-4824. FileInputStreamCache.close leaves dangling reference to FileInputStreamCache.cacheCleaner. Contributed by Colin Patrick McCabe.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483641 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.Closeable;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.util.concurrent.ScheduledFuture;
-  class CacheCleaner implements Runnable {
+  private static class CacheCleaner implements Runnable, Closeable {
+    private WeakReference<FileInputStreamCache> cacheRef;
+    private ScheduledFuture<?> future;
+    
+    CacheCleaner(FileInputStreamCache cache) {
+      this.cacheRef = new WeakReference<FileInputStreamCache>(cache);
+    }
+    
-      synchronized(FileInputStreamCache.this) {
-        if (closed) return;
+      FileInputStreamCache cache = cacheRef.get();
+      if (cache == null) return;
+      synchronized(cache) {
+        if (cache.closed) return;
-        for (Iterator<Entry<Key, Value>> iter = map.entries().iterator();
-              iter.hasNext();
-              iter = map.entries().iterator()) {
+        for (Iterator<Entry<Key, Value>> iter =
+                  cache.map.entries().iterator(); iter.hasNext();
+              iter = cache.map.entries().iterator()) {
-          if (entry.getValue().getTime() + expiryTimeMs >= curTime) {
+          if (entry.getValue().getTime() + cache.expiryTimeMs >= curTime) {
+
+    @Override
+    public void close() throws IOException {
+      if (future != null) {
+        future.cancel(false);
+      }
+    }
+    
+    public void setFuture(ScheduledFuture<?> future) {
+      this.future = future;
+    }
-          cacheCleaner = new CacheCleaner();
-          executor.scheduleAtFixedRate(cacheCleaner, expiryTimeMs, expiryTimeMs, 
-              TimeUnit.MILLISECONDS);
+          cacheCleaner = new CacheCleaner(this);
+          ScheduledFuture<?> future = 
+              executor.scheduleAtFixedRate(cacheCleaner, expiryTimeMs, expiryTimeMs,
+                  TimeUnit.MILLISECONDS);
+          cacheCleaner.setFuture(future);
-    if (cacheCleaner != null) {
-      executor.remove(cacheCleaner);
-    }
+    IOUtils.cleanup(LOG, cacheCleaner);

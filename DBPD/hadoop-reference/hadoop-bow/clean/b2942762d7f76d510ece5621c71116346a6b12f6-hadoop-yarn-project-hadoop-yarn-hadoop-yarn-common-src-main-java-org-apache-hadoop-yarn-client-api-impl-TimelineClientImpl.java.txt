YARN-2709. Made timeline client getDelegationToken API retry if ConnectException happens. Contributed by Li Lu.

-  private TimelineJerseyRetryFilter retryFilter;
+  @Private
+  @VisibleForTesting
+  TimelineClientConnectionRetry connectionRetry;
-  static class TimelineJerseyRetryFilter extends ClientFilter {
+  // Abstract class for an operation that should be retried by timeline client
+  private static abstract class TimelineClientRetryOp {
+    // The operation that should be retried
+    public abstract Object run() throws IOException;
+    // The method to indicate if we should retry given the incoming exception
+    public abstract boolean shouldRetryOn(Exception e);
+  }
+
+  // Class to handle retry
+  // Outside this class, only visible to tests
+  @Private
+  @VisibleForTesting
+  static class TimelineClientConnectionRetry {
-    // Indicates if retries happened last time
+    // Indicates if retries happened last time. Only tests should read it.
+    // In unit tests, retryOn() calls should _not_ be concurrent.
-    public TimelineJerseyRetryFilter(Configuration conf) {
-      super();
+    public TimelineClientConnectionRetry(Configuration conf) {
-    @Override
-    public ClientResponse handle(ClientRequest cr)
-        throws ClientHandlerException {
+    public Object retryOn(TimelineClientRetryOp op)
+        throws RuntimeException, IOException {
+
-          // try pass the request on, if fail, keep retrying
-          return getNext().handle(cr);
-        } catch (ClientHandlerException e) {
+          // try perform the op, if fail, keep retrying
+          return op.run();
+        }  catch (IOException e) {
+          // We may only throw runtime and IO exceptions. After switching to
+          // Java 1.7, we can merge these two catch blocks into one.
+
-          if(e.getCause() instanceof ConnectException) {
-            if (leftRetries > 0) {
-              LOG.info("Connection Timeout (" + cr.getURI() + "), will try "
-                  + leftRetries + " more time(s).");
-            } else {
-              // note that maxRetries may be -1 at the very beginning
-              // maxRetries = -1 means keep trying
-              LOG.info("Connection Timeout (" + cr.getURI()
-                  + "), will keep retrying.");
-            }
-            retried = true;
+          if (op.shouldRetryOn(e)) {
+            logException(e, leftRetries);
+          } else {
+            throw e;
+          }
+        } catch (RuntimeException e) {
+          // break if there's no retries left
+          if (leftRetries == 0) {
+            break;
+          }
+          if (op.shouldRetryOn(e)) {
+            logException(e, leftRetries);
+        retried = true;
-      throw new ClientHandlerException("Failed to connect to timeline server. "
+      throw new RuntimeException("Failed to connect to timeline server. "
+
+    private void logException(Exception e, int leftRetries) {
+      if (leftRetries > 0) {
+        LOG.info("Exception caught by TimelineClientConnectionRetry,"
+              + " will try " + leftRetries + " more time(s).\nMessage: "
+              + e.getMessage());
+      } else {
+        // note that maxRetries may be -1 at the very beginning
+        LOG.info("ConnectionException caught by TimelineClientConnectionRetry,"
+            + " will keep retrying.\nMessage: "
+            + e.getMessage());
+      }
+    }
+  }
+
+  private class TimelineJerseyRetryFilter extends ClientFilter {
+    @Override
+    public ClientResponse handle(final ClientRequest cr)
+        throws ClientHandlerException {
+      // Set up the retry operation
+      TimelineClientRetryOp jerseyRetryOp = new TimelineClientRetryOp() {
+        @Override
+        public Object run() {
+          // Try pass the request, if fail, keep retrying
+          return getNext().handle(cr);
+        }
+
+        @Override
+        public boolean shouldRetryOn(Exception e) {
+          // Only retry on connection exceptions
+          return (e instanceof ClientHandlerException)
+              && (e.getCause() instanceof ConnectException);
+        }
+      };
+      try {
+        return (ClientResponse) connectionRetry.retryOn(jerseyRetryOp);
+      } catch (IOException e) {
+        throw new ClientHandlerException("Jersey retry failed!\nMessage: "
+              + e.getMessage());
+      }
+    }
+      token = new DelegationTokenAuthenticatedURL.Token();
+
+      connectionRetry = new TimelineClientConnectionRetry(conf);
-      token = new DelegationTokenAuthenticatedURL.Token();
-      retryFilter = new TimelineJerseyRetryFilter(conf);
+      TimelineJerseyRetryFilter retryFilter = new TimelineJerseyRetryFilter();
-    boolean isProxyAccess =
-        UserGroupInformation.getCurrentUser().getAuthenticationMethod()
-        == UserGroupInformation.AuthenticationMethod.PROXY;
-    UserGroupInformation callerUGI = isProxyAccess ?
-        UserGroupInformation.getCurrentUser().getRealUser()
-        : UserGroupInformation.getCurrentUser();
-    final String doAsUser = isProxyAccess ?
-        UserGroupInformation.getCurrentUser().getShortUserName() : null;
-    try {
-      return callerUGI.doAs(
-          new PrivilegedExceptionAction<Token<TimelineDelegationTokenIdentifier>>() {
-        @Override
-        public Token<TimelineDelegationTokenIdentifier> run() throws Exception {
-          DelegationTokenAuthenticatedURL authUrl =
-              new DelegationTokenAuthenticatedURL(authenticator, connConfigurator);
-          return (Token) authUrl.getDelegationToken(
-              resURI.toURL(), token, renewer, doAsUser);
+    // Set up the retry operation
+    TimelineClientRetryOp tokenRetryOp = new TimelineClientRetryOp() {
+      @Override
+      public Object run() throws IOException {
+        // Try pass the request, if fail, keep retrying
+        boolean isProxyAccess =
+            UserGroupInformation.getCurrentUser().getAuthenticationMethod()
+            == UserGroupInformation.AuthenticationMethod.PROXY;
+        UserGroupInformation callerUGI = isProxyAccess ?
+            UserGroupInformation.getCurrentUser().getRealUser()
+            : UserGroupInformation.getCurrentUser();
+        final String doAsUser = isProxyAccess ?
+            UserGroupInformation.getCurrentUser().getShortUserName() : null;
+        try {
+          return callerUGI.doAs(
+              new PrivilegedExceptionAction<Token<TimelineDelegationTokenIdentifier>>() {
+            @Override
+            public Token<TimelineDelegationTokenIdentifier> run() throws Exception {
+              DelegationTokenAuthenticatedURL authUrl =
+                  new DelegationTokenAuthenticatedURL(authenticator, connConfigurator);
+              return (Token) authUrl.getDelegationToken(
+                  resURI.toURL(), token, renewer, doAsUser);
+            }
+          });
+        } catch (UndeclaredThrowableException e) {
+          throw new IOException(e.getCause());
+        } catch (InterruptedException e) {
+          throw new IOException(e);
-      });
-    } catch (UndeclaredThrowableException e) {
-      throw new IOException(e.getCause());
-    } catch (InterruptedException e) {
-      throw new IOException(e);
-    }
-  }
+      }
+      @Override
+      public boolean shouldRetryOn(Exception e) {
+        // Only retry on connection exceptions
+        return (e instanceof ConnectException);
+      }
+    };
-  @Private
-  @VisibleForTesting
-  public TimelineJerseyRetryFilter getRetryFilter() {
-    return retryFilter;
+    return (Token<TimelineDelegationTokenIdentifier>)
+        connectionRetry.retryOn(tokenRetryOp);

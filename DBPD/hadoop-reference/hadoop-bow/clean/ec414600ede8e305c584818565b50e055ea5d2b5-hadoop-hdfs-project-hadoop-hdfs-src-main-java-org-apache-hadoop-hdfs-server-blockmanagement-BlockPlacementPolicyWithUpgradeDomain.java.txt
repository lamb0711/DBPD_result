HDFS-9007. Fix HDFS Balancer to honor upgrade domain policy. (Ming Ma via lei)

+import org.apache.hadoop.fs.StorageType;
-  private Map<String, List<DatanodeStorageInfo>> getUpgradeDomainMap(
-      DatanodeStorageInfo[] storageInfos) {
-    Map<String, List<DatanodeStorageInfo>> upgradeDomainMap = new HashMap<>();
-    for(DatanodeStorageInfo storage : storageInfos) {
+  private <T> Map<String, List<T>> getUpgradeDomainMap(
+      Collection<T> storagesOrDataNodes) {
+    Map<String, List<T>> upgradeDomainMap = new HashMap<>();
+    for(T storage : storagesOrDataNodes) {
-          storage.getDatanodeDescriptor());
-      List<DatanodeStorageInfo> storages = upgradeDomainMap.get(upgradeDomain);
+          getDatanodeInfo(storage));
+      List<T> storages = upgradeDomainMap.get(upgradeDomain);
+  private Collection<DatanodeStorageInfo> combine(
+      Collection<DatanodeStorageInfo> moreThanOne,
+      Collection<DatanodeStorageInfo> exactlyOne) {
+    List<DatanodeStorageInfo> all = new ArrayList<>();
+    if (moreThanOne != null) {
+      all.addAll(moreThanOne);
+    }
+    if (exactlyOne != null) {
+      all.addAll(exactlyOne);
+    }
+    return all;
+  }
+
-    List<DatanodeStorageInfo> all = new ArrayList<>();
-    if (moreThanOne != null) {
-      all.addAll(moreThanOne);
-    }
-    if (exactlyOne != null) {
-      all.addAll(exactlyOne);
-    }
-
-    Map<String, List<DatanodeStorageInfo>> upgradeDomains =
-        getUpgradeDomainMap(all.toArray(new DatanodeStorageInfo[all.size()]));
-
-    List<DatanodeStorageInfo> shareUDSet = getShareUDSet(upgradeDomains);
+    Collection<DatanodeStorageInfo> all = combine(moreThanOne, exactlyOne);
+    List<DatanodeStorageInfo> shareUDSet = getShareUDSet(
+        getUpgradeDomainMap(all));
+
+  @Override
+  boolean useDelHint(DatanodeStorageInfo delHint,
+      DatanodeStorageInfo added, List<DatanodeStorageInfo> moreThanOne,
+      Collection<DatanodeStorageInfo> exactlyOne,
+      List<StorageType> excessTypes) {
+    if (!super.useDelHint(delHint, added, moreThanOne, exactlyOne,
+        excessTypes)) {
+      // If BlockPlacementPolicyDefault doesn't allow useDelHint, there is no
+      // point checking with upgrade domain policy.
+      return false;
+    }
+    return isMovableBasedOnUpgradeDomain(combine(moreThanOne, exactlyOne),
+        delHint, added);
+  }
+
+  // Check if moving from source to target will preserve the upgrade domain
+  // policy.
+  private <T> boolean isMovableBasedOnUpgradeDomain(Collection<T> all,
+      T source, T target) {
+    Map<String, List<T>> udMap = getUpgradeDomainMap(all);
+    // shareUDSet includes datanodes that share same upgrade
+    // domain with another datanode.
+    List<T> shareUDSet = getShareUDSet(udMap);
+    // check if removing source reduces the number of upgrade domains
+    if (notReduceNumOfGroups(shareUDSet, source, target)) {
+      return true;
+    } else if (udMap.size() > upgradeDomainFactor) {
+      return true; // existing number of upgrade domain exceeds the limit.
+    } else {
+      return false; // removing source reduces the number of UDs.
+    }
+  }
+
+  @Override
+  public boolean isMovable(Collection<DatanodeInfo> locs,
+      DatanodeInfo source, DatanodeInfo target) {
+    if (super.isMovable(locs, source, target)) {
+      return isMovableBasedOnUpgradeDomain(locs, source, target);
+    } else {
+      return false;
+    }
+  }

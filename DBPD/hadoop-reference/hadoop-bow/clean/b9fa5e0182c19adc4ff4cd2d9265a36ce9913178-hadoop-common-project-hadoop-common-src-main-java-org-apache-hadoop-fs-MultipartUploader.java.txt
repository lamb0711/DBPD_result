HDFS-13934. Multipart uploaders to be created through FileSystem/FileContext.

Contributed by Steve Loughran.

Change-Id: Iebd34140c1a0aa71f44a3f4d0fee85f6bdf123a3

-/**
+/*
+
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import java.util.concurrent.CompletableFuture;
-import static com.google.common.base.Preconditions.checkArgument;
-
- * multiple nodes. Users should:
- * <ol>
- *   <li>Initialize an upload.</li>
- *   <li>Upload parts in any order.</li>
- *   <li>Complete the upload in order to have it materialize in the destination
- *   FS.</li>
- * </ol>
+ * multiple nodes.
-@InterfaceAudience.Private
+@InterfaceAudience.Public
-public abstract class MultipartUploader implements Closeable {
-  public static final Logger LOG =
-      LoggerFactory.getLogger(MultipartUploader.class);
+public interface MultipartUploader extends Closeable {
-  /**
-   * Perform any cleanup.
-   * The upload is not required to support any operations after this.
-   * @throws IOException problems on close.
-   */
-  @Override
-  public void close() throws IOException {
-  }
-  public abstract UploadHandle initialize(Path filePath) throws IOException;
+  CompletableFuture<UploadHandle> startUpload(Path filePath)
+      throws IOException;
-   * @param filePath Target path for upload (same as {@link #initialize(Path)}).
+   * @param uploadId Identifier from {@link #startUpload(Path)}.
+   * @param partNumber Index of the part relative to others.
+   * @param filePath Target path for upload (as {@link #startUpload(Path)}).
-   * @param partNumber Index of the part relative to others.
-   * @param uploadId Identifier from {@link #initialize(Path)}.
-  public abstract PartHandle putPart(Path filePath, InputStream inputStream,
-      int partNumber, UploadHandle uploadId, long lengthInBytes)
+  CompletableFuture<PartHandle> putPart(
+      UploadHandle uploadId,
+      int partNumber,
+      Path filePath,
+      InputStream inputStream,
+      long lengthInBytes)
-   * @param filePath Target path for upload (same as {@link #initialize(Path)}.
+   * @param uploadId Identifier from {@link #startUpload(Path)}.
+   * @param filePath Target path for upload (as {@link #startUpload(Path)}.
-   *          from {@link #putPart(Path, InputStream, int, UploadHandle, long)}.
-   * @param multipartUploadId Identifier from {@link #initialize(Path)}.
+   *          from {@link #putPart(UploadHandle, int, Path, InputStream, long)}.
-  public abstract PathHandle complete(Path filePath,
-      Map<Integer, PartHandle> handles,
-      UploadHandle multipartUploadId)
+  CompletableFuture<PathHandle> complete(
+      UploadHandle uploadId,
+      Path filePath,
+      Map<Integer, PartHandle> handles)
-   * @param filePath Target path for upload (same as {@link #initialize(Path)}.
-   * @param multipartUploadId Identifier from {@link #initialize(Path)}.
+   * @param uploadId Identifier from {@link #startUpload(Path)}.
+   * @param filePath Target path for upload (same as {@link #startUpload(Path)}.
+   * @return a future; the operation will have completed
-  public abstract void abort(Path filePath, UploadHandle multipartUploadId)
+  CompletableFuture<Void> abort(UploadHandle uploadId, Path filePath)
-   * Utility method to validate uploadIDs.
-   * @param uploadId Upload ID
-   * @throws IllegalArgumentException invalid ID
+   * Best effort attempt to aborts multipart uploads under a path.
+   * Not all implementations support this, and those which do may
+   * be vulnerable to eventually consistent listings of current uploads
+   * -some may be missed.
+   * @param path path to abort uploads under.
+   * @return a future to the number of entries aborted;
+   * -1 if aborting is unsupported
+   * @throws IOException IO failure
-  protected void checkUploadId(byte[] uploadId)
-      throws IllegalArgumentException {
-    checkArgument(uploadId != null, "null uploadId");
-    checkArgument(uploadId.length > 0,
-        "Empty UploadId is not valid");
-  }
+  CompletableFuture<Integer> abortUploadsUnderPath(Path path) throws IOException;
-  /**
-   * Utility method to validate partHandles.
-   * @param partHandles handles
-   * @throws IllegalArgumentException if the parts are invalid
-   */
-  protected void checkPartHandles(Map<Integer, PartHandle> partHandles) {
-    checkArgument(!partHandles.isEmpty(),
-        "Empty upload");
-    partHandles.keySet()
-        .stream()
-        .forEach(key ->
-            checkArgument(key > 0,
-                "Invalid part handle index %s", key));
-  }
-
-  /**
-   * Check all the arguments to the
-   * {@link #putPart(Path, InputStream, int, UploadHandle, long)} operation.
-   * @param filePath Target path for upload (same as {@link #initialize(Path)}).
-   * @param inputStream Data for this part. Implementations MUST close this
-   * stream after reading in the data.
-   * @param partNumber Index of the part relative to others.
-   * @param uploadId Identifier from {@link #initialize(Path)}.
-   * @param lengthInBytes Target length to read from the stream.
-   * @throws IllegalArgumentException invalid argument
-   */
-  protected void checkPutArguments(Path filePath,
-      InputStream inputStream,
-      int partNumber,
-      UploadHandle uploadId,
-      long lengthInBytes) throws IllegalArgumentException {
-    checkArgument(filePath != null, "null filePath");
-    checkArgument(inputStream != null, "null inputStream");
-    checkArgument(partNumber > 0, "Invalid part number: %d", partNumber);
-    checkArgument(uploadId != null, "null uploadId");
-    checkArgument(lengthInBytes >= 0, "Invalid part length: %d", lengthInBytes);
-  }

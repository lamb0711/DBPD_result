Remove extra code that code erroneously committed in HDFS-3934 (cmccabe)



git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489083 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.Closeable;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.util.concurrent.ThreadFactoryBuilder;
-
-public class HostFileManager implements Closeable {
+public class HostFileManager {
-  @VisibleForTesting
-  public static boolean dnsResolutionDisabledForTesting = false;
-
-    
-    public Entry(String prefix, int port, String ipAddress) {
-      this.prefix = prefix;
-      this.port = port;
-      this.ipAddress = ipAddress;
-    }
-
-    public String getIdentifier() {
-      return ipAddress.isEmpty() ? prefix : ipAddress;
-    }
-
-    static Entry fromPrefixAndPort(String fileName, String prefix, int port) {
-      String ipAddress = "";
-      try {
-        if (dnsResolutionDisabledForTesting) {
-          throw new UnknownHostException("dns resolution disabled for " +
-              "testing");
-        }
-        // Let's see if we can resolve this prefix to an IP address.
-        // This may fail; one example is with a registered hostname
-        // which is not actually a real DNS name.
-        InetAddress addr = InetAddress.getByName(prefix);
-        ipAddress = addr.getHostAddress();
-      } catch (UnknownHostException e) {
-        if (fileName != null) {
-          LOG.info("When reading " + fileName + ", could not look up " +
-              "IP address for " + prefix + ".  We will assume this is a " +
-              "registration name.", e);
-        }
-      }
-      return new Entry(prefix, port, ipAddress);
-    }
+      String ipAddress = "";
-      return Entry.fromPrefixAndPort(fileName, prefix, port);
+      try {
+        // Let's see if we can resolve this prefix to an IP address.
+        // This may fail; one example is with a registered hostname
+        // which is not actually a real DNS name.
+        InetAddress addr = InetAddress.getByName(prefix);
+        ipAddress = addr.getHostAddress();
+      } catch (UnknownHostException e) {
+        LOG.info("When reading " + fileName + ", could not look up " +
+            "IP address for " + prefix + ".  We will assume this is a " +
+            "registration name.", e);
+      }
+      return new Entry(prefix, port, ipAddress);
+    }
+
+    public String getIdentifier() {
+      return ipAddress.isEmpty() ? prefix : ipAddress;
+    }
+
+    public Entry(String prefix, int port, String ipAddress) {
+      this.prefix = prefix;
+      this.port = port;
+      this.ipAddress = ipAddress;
-  private final ScheduledThreadPoolExecutor executor
-      = new ScheduledThreadPoolExecutor(1, new ThreadFactoryBuilder().
-          setDaemon(true).setNameFormat("HostFileManagerDnsRefresh thread").
-          build());
-
-  private final ScheduledFuture<?> dnsResolverFuture;
-
-  private class DnsResolver implements Runnable {
-    @Override
-    public void run() {
-      EntrySet oldIncludes, oldExcludes;
-      synchronized (HostFileManager.this) {
-        oldIncludes = includes;
-        oldExcludes = excludes;
-      }
-      MutableEntrySet newIncludes = new MutableEntrySet();
-      for (Entry e : oldIncludes) {
-        newIncludes.add(Entry.fromPrefixAndPort(null, e.prefix, e.port));
-      }
-      MutableEntrySet newExcludes = new MutableEntrySet();
-      for (Entry e : oldExcludes) {
-        newExcludes.add(Entry.fromPrefixAndPort(null, e.prefix, e.port));
-      }
-      synchronized (HostFileManager.this) {
-        // Don't replace an entry set that has already been replaced by
-        // refresh().
-        if (includes == oldIncludes) {
-          includes = newIncludes;
-        }
-        if (excludes == oldExcludes) {
-          excludes = newExcludes;
-        }
-      }
-    }
-  }
-  
-  public HostFileManager(int dnsResolutionSeconds) {
-    this.dnsResolverFuture = this.executor.
-        scheduleAtFixedRate(new DnsResolver(),
-            dnsResolutionSeconds, dnsResolutionSeconds,
-            TimeUnit.SECONDS);
+  public HostFileManager() {
-
-  @Override
-  public synchronized void close() throws IOException {
-    dnsResolverFuture.cancel(false);
-  }

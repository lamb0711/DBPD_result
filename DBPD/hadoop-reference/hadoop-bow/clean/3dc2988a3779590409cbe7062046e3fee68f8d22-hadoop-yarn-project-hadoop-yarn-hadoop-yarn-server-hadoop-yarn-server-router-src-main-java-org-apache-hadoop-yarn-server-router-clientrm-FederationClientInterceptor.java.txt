YARN-8699. Add Yarnclient#yarnclusterMetrics API implementation in router. Contributed by Bibin A Chundatt.

+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import java.lang.reflect.Method;
+import java.util.TreeMap;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+  private ThreadPoolExecutor executorService;
+
+    int numThreads = getConf().getInt(
+        YarnConfiguration.ROUTER_USER_CLIENT_THREADS_SIZE,
+        YarnConfiguration.DEFAULT_ROUTER_USER_CLIENT_THREADS_SIZE);
+    ThreadFactory threadFactory = new ThreadFactoryBuilder()
+        .setNameFormat("RPC Router Client-" + userName + "-%d ").build();
+
+    BlockingQueue workQueue = new LinkedBlockingQueue<>();
+    this.executorService = new ThreadPoolExecutor(numThreads, numThreads,
+        0L, TimeUnit.MILLISECONDS, workQueue, threadFactory);
+
-    throw new NotImplementedException("Code is not implemented");
+    Map<SubClusterId, SubClusterInfo> subclusters =
+        federationFacade.getSubClusters(true);
+    ClientMethod remoteMethod = new ClientMethod("getClusterMetrics",
+        new Class[] {GetClusterMetricsRequest.class}, new Object[] {request});
+    ArrayList<SubClusterId> clusterList = new ArrayList<>(subclusters.keySet());
+    Map<SubClusterId, GetClusterMetricsResponse> clusterMetrics =
+        invokeConcurrent(clusterList, remoteMethod,
+            GetClusterMetricsResponse.class);
+    return RouterYarnClientUtils.merge(clusterMetrics.values());
+  }
+
+  <R> Map<SubClusterId, R> invokeConcurrent(ArrayList<SubClusterId> clusterIds,
+      ClientMethod request, Class<R> clazz) throws YarnException, IOException {
+    List<Callable<Object>> callables = new ArrayList<>();
+    List<Future<Object>> futures = new ArrayList<>();
+    Map<SubClusterId, IOException> exceptions = new TreeMap<>();
+    for (SubClusterId subClusterId : clusterIds) {
+      callables.add(new Callable<Object>() {
+        @Override
+        public Object call() throws Exception {
+          ApplicationClientProtocol protocol =
+              getClientRMProxyForSubCluster(subClusterId);
+          Method method = ApplicationClientProtocol.class
+              .getDeclaredMethod(request.getMethodName(), request.getTypes());
+          return method.invoke(protocol, request.getParams());
+        }
+      });
+    }
+    Map<SubClusterId, R> results = new TreeMap<>();
+    try {
+      futures.addAll(executorService.invokeAll(callables));
+      for (int i = 0; i < futures.size(); i++) {
+        SubClusterId subClusterId = clusterIds.get(i);
+        try {
+          Future<Object> future = futures.get(i);
+          Object result = future.get();
+          results.put(subClusterId, clazz.cast(result));
+        } catch (ExecutionException ex) {
+          Throwable cause = ex.getCause();
+          LOG.debug("Cannot execute {} on {}: {}", request.getMethodName(),
+              subClusterId.getId(), cause.getMessage());
+          IOException ioe;
+          if (cause instanceof IOException) {
+            ioe = (IOException) cause;
+          } else if (cause instanceof YarnException) {
+            throw (YarnException) cause;
+          } else {
+            ioe = new IOException(
+                "Unhandled exception while calling " + request.getMethodName()
+                    + ": " + cause.getMessage(), cause);
+          }
+          // Store the exceptions
+          exceptions.put(subClusterId, ioe);
+        }
+      }
+      if (results.isEmpty()) {
+        SubClusterId subClusterId = clusterIds.get(0);
+        IOException ioe = exceptions.get(subClusterId);
+        if (ioe != null) {
+          throw ioe;
+        }
+      }
+    } catch (InterruptedException e) {
+      throw new YarnException(e);
+    }
+    return results;
+
+  @Override
+  public void shutdown() {
+    executorService.shutdown();
+    super.shutdown();
+  }

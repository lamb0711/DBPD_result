HDFS-3170. Add more useful metrics for write latency. Contributed by Matthew Jacobs.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1357970 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.hdfs.server.common.Util;
+    long flushTotalNanos = 0;
+    boolean measuredFlushTime = false;
+        long flushStartNanos = System.nanoTime();
+        long flushEndNanos = System.nanoTime();
-          long start = Util.now();
+          long fsyncStartNanos = flushEndNanos;
-          datanode.metrics.addFsync(Util.now() - start);
+          datanode.metrics.addFsyncNanos(System.nanoTime() - fsyncStartNanos);
+        flushTotalNanos += flushEndNanos - flushStartNanos;
+        measuredFlushTime = true;
+        long flushStartNanos = System.nanoTime();
+        long flushEndNanos = System.nanoTime();
-          long start = Util.now();
+          long fsyncStartNanos = flushEndNanos;
-          datanode.metrics.addFsync(Util.now() - start);
+          datanode.metrics.addFsyncNanos(System.nanoTime() - fsyncStartNanos);
+        flushTotalNanos += flushEndNanos - flushStartNanos;
+        measuredFlushTime = true;
+    if (measuredFlushTime) {
+      datanode.metrics.addFlushNanos(flushTotalNanos);
+    }
+    long flushTotalNanos = 0;
+      long flushStartNanos = System.nanoTime();
+      long flushEndNanos = System.nanoTime();
-        long start = Util.now();
+        long fsyncStartNanos = flushEndNanos;
-        datanode.metrics.addFsync(Util.now() - start);
+        datanode.metrics.addFsyncNanos(System.nanoTime() - fsyncStartNanos);
+      flushTotalNanos += flushEndNanos - flushStartNanos;
+      long flushStartNanos = System.nanoTime();
+      long flushEndNanos = System.nanoTime();
-        long start = Util.now();
+        long fsyncStartNanos = flushEndNanos;
-        datanode.metrics.addFsync(Util.now() - start);
+        datanode.metrics.addFsyncNanos(System.nanoTime() - fsyncStartNanos);
+      flushTotalNanos += flushEndNanos - flushStartNanos;
+    }
+    if (checksumOut != null || out != null) {
+      datanode.metrics.addFlushNanos(flushTotalNanos);
-     * full packet with single read and to accept arbitarary size  
+     * full packet with single read and to accept arbitrary size  
-          
+
-        final Packet p = new Packet(seqno, lastPacketInBlock, offsetInBlock);
+        final Packet p = new Packet(seqno, lastPacketInBlock, offsetInBlock,
+            System.nanoTime());
+        long totalAckTimeNanos = 0;
+            long ackRecvNanoTime = 0;
+                ackRecvNanoTime = System.nanoTime();
+                  if (type == PacketResponderType.HAS_DOWNSTREAM_IN_PIPELINE) {
+                    // The total ack time includes the ack times of downstream nodes.
+                    // The value is 0 if this responder doesn't have a downstream
+                    // DN in the pipeline.
+                    totalAckTimeNanos = ackRecvNanoTime - pkt.ackEnqueueNanoTime;
+                    // Report the elapsed time from ack send to ack receive minus
+                    // the downstream ack time.
+                    long ackTimeNanos = totalAckTimeNanos - ack.getDownstreamAckTimeNanos();
+                    if (ackTimeNanos < 0) {
+                      if (LOG.isDebugEnabled()) {
+                        LOG.debug("Calculated invalid ack time: " + ackTimeNanos + "ns.");
+                      }
+                    } else {
+                      datanode.metrics.addPacketAckRoundTripTimeNanos(ackTimeNanos);
+                    }
+                  }
-            PipelineAck replyAck = new PipelineAck(expected, replies);
+            PipelineAck replyAck = new PipelineAck(expected, replies, totalAckTimeNanos);
+    final long ackEnqueueNanoTime;
-    Packet(long seqno, boolean lastPacketInBlock, long offsetInBlock) {
+    Packet(long seqno, boolean lastPacketInBlock, long offsetInBlock,
+        long ackEnqueueNanoTime) {
+      this.ackEnqueueNanoTime = ackEnqueueNanoTime;
+        + ", ackEnqueueNanoTime=" + ackEnqueueNanoTime

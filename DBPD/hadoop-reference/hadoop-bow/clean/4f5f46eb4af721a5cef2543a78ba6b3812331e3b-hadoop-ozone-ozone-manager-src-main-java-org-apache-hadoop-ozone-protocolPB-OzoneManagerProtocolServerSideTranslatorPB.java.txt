HDDS-1935. Improve the visibility with Ozone Insight tool (#1255)




-
+  private final ProtocolMessageMetrics protocolMessageMetrics;
-      OzoneManager impl, OzoneManagerRatisServer ratisServer,
+      OzoneManager impl,
+      OzoneManagerRatisServer ratisServer,
+      ProtocolMessageMetrics metrics,
+    this.protocolMessageMetrics = metrics;
-   public OMResponse submitRequest(RpcController controller,
+  public OMResponse submitRequest(RpcController controller,
-      if (isRatisEnabled) {
-        // Check if the request is a read only request
-        if (OmUtils.isReadOnly(request)) {
-          return submitReadRequestToOM(request);
-        } else {
-          if (omRatisServer.isLeader()) {
-            try {
-              OMClientRequest omClientRequest =
-                  OzoneManagerRatisUtils.createClientRequest(request);
-              if (omClientRequest != null) {
-                request = omClientRequest.preExecute(ozoneManager);
-              }
-            } catch(IOException ex) {
-              // As some of the preExecute returns error. So handle here.
-              return createErrorResponse(request, ex);
-            }
-            return submitRequestToRatis(request);
-          } else {
-            // throw not leader exception. This is being done, so to avoid
-            // unnecessary execution of preExecute on follower OM's. This
-            // will be helpful in the case like where we we reduce the
-            // chance of allocate blocks on follower OM's. Right now our
-            // leader status is updated every 1 second.
-            throw createNotLeaderException();
-          }
-        }
-      } else {
-        return submitRequestDirectlyToOM(request);
+      if (LOG.isTraceEnabled()) {
+        LOG.trace(
+            "OzoneManagerProtocol {} request is received: <json>{}</json>",
+            request.getCmdType().toString(),
+            request.toString().replaceAll("\n", "\\\\n"));
+      } else if (LOG.isDebugEnabled()) {
+        LOG.debug("OzoneManagerProtocol {} request is received",
+            request.getCmdType().toString());
+      protocolMessageMetrics.increment(request.getCmdType());
+
+      OMResponse omResponse = processRequest(request);
+
+      if (LOG.isTraceEnabled()) {
+        LOG.trace(
+            "OzoneManagerProtocol {} request is processed. Response: "
+                + "<json>{}</json>",
+            request.getCmdType().toString(),
+            omResponse.toString().replaceAll("\n", "\\\\n"));
+      }
+      return omResponse;
+
+  private OMResponse processRequest(OMRequest request) throws
+      ServiceException {
+
+    if (isRatisEnabled) {
+      // Check if the request is a read only request
+      if (OmUtils.isReadOnly(request)) {
+        return submitReadRequestToOM(request);
+      } else {
+        if (omRatisServer.isLeader()) {
+          try {
+            OMClientRequest omClientRequest =
+                OzoneManagerRatisUtils.createClientRequest(request);
+            if (omClientRequest != null) {
+              request = omClientRequest.preExecute(ozoneManager);
+            }
+          } catch (IOException ex) {
+            // As some of the preExecute returns error. So handle here.
+            return createErrorResponse(request, ex);
+          }
+          return submitRequestToRatis(request);
+        } else {
+          // throw not leader exception. This is being done, so to avoid
+          // unnecessary execution of preExecute on follower OM's. This
+          // will be helpful in the case like where we we reduce the
+          // chance of allocate blocks on follower OM's. Right now our
+          // leader status is updated every 1 second.
+          throw createNotLeaderException();
+        }
+      }
+    } else {
+      return submitRequestDirectlyToOM(request);
+    }
+
+  }
+
+   *
+

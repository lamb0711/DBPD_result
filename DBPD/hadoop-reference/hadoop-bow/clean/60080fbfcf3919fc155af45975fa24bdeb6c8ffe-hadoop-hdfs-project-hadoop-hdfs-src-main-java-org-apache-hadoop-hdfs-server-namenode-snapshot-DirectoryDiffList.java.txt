HDFS-13171. Handle Deletion of nodes in SnasphotSkipList.  Contributed by Shashikant Banerjee

+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+  public static final Logger LOG =
+      LoggerFactory.getLogger(DirectoryDiffList.class);
-      return "->" + skipTo;
+      return "->" + skipTo + (diff == null? " (diff==null)": "");
+    void trim() {
+      for (int level = level();
+           level > 0 && getSkipNode(level) == null; level--) {
+        skipDiffList.remove(level);
+      }
+    }
+
+  private SkipListNode[] findPreviousNodes(SkipListNode node, int nodeLevel) {
+    final SkipListNode[] nodePath = new SkipListNode[nodeLevel + 1];
+    SkipListNode cur = head;
+    final int headLevel = head.level();
+    for (int level = headLevel < nodeLevel ? headLevel : nodeLevel;
+         level >= 0; level--) {
+      while (cur.getSkipNode(level) != node) {
+        cur = cur.getSkipNode(level);
+      }
+      nodePath[level] = cur;
+    }
+    for (int level = headLevel + 1; level <= nodeLevel; level++) {
+      nodePath[level] = head;
+    }
+    return nodePath;
+  }
+
-    final SkipListNode[] nodePath = new SkipListNode[nodeLevel + 1];
-    SkipListNode cur = head;
-    for (int level = headLevel < nodeLevel ? headLevel : nodeLevel;
-         level >= 0; level--) {
-      while (cur.getSkipNode(level) != null) {
-        cur = cur.getSkipNode(level);
-      }
-      nodePath[level] = cur;
-    }
+    final SkipListNode[] nodePath = findPreviousNodes(null, nodeLevel);
+      current.setSkipTo(null, level);
-   * @throws UnsupportedOperationException {@inheritDoc}
+   * @return the removed DirectoryDiff
-    throw new UnsupportedOperationException();
+    SkipListNode node = getNode(index);
+    int headLevel = head.level();
+    int nodeLevel = node.level();
+    final SkipListNode[] nodePath = findPreviousNodes(node, nodeLevel);
+    for (int level = 0; level <= nodeLevel; level++) {
+      if (nodePath[level] != head && level > 0) {
+        // if the last snapshot is deleted, for all the skip level nodes
+        // pointing to the last one, the combined children diff at each level
+        // > 0 should be made null and skip pointers will be updated to null.
+        // if the snapshot being deleted is not the last one, we have to merge
+        // the diff of deleted node at each level to the previous skip level
+        // node at that level and the skip pointers will be updated to point to
+        // the skip nodes of the deleted node.
+        if (index == size() - 1) {
+          nodePath[level].setSkipDiff(null, level);
+        } else {
+          /* Ideally at level 0, the deleted diff will be combined with
+           * the previous diff , and deleted inodes will be cleaned up
+           * by passing a deleted processor here while combining the diffs.
+           * Level 0 merge with previous diff will be handled inside the
+           * {@link AbstractINodeDiffList#deleteSnapshotDiff} function.
+           */
+          if (node.getChildrenDiff(level) != null) {
+            nodePath[level].getChildrenDiff(level)
+                .combinePosterior(node.getChildrenDiff(level), null);
+          }
+        }
+      }
+      nodePath[level].setSkipTo(node.getSkipNode(level), level);
+    }
+    if (nodeLevel == headLevel) {
+      head.trim();
+    }
+    return skipNodeList.remove(index).getDiff();
-    b.append("\nhead: ").append(head).append(head.skipDiffList);
+    b.append(" head: ").append(head).append(head.skipDiffList);

Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1196458 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.ThreadFactory;
-import org.apache.avro.ipc.Server;
+import org.apache.hadoop.ipc.Server;
+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;
-import org.apache.hadoop.security.SecurityInfo;
-import org.apache.hadoop.yarn.server.nodemanager.containermanager.localizer.security.LocalizerSecurityInfo;
+import org.apache.hadoop.yarn.server.nodemanager.security.authorize.NMPolicyProvider;
+import org.apache.hadoop.yarn.util.FSDownload;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+  
+  /**
+   * Map of LocalResourceTrackers keyed by username, for private
+   * resources.
+   */
+
+  /**
+   * Map of LocalResourceTrackers keyed by appid, for application
+   * resources.
+   */
-    this.cacheCleanup = new ScheduledThreadPoolExecutor(1);
+    this.cacheCleanup = new ScheduledThreadPoolExecutor(1,
+        new ThreadFactoryBuilder()
+          .setNameFormat("ResourceLocalizationService Cache Cleanup")
+          .build());
-      conf.get(YarnConfiguration.NM_LOCALIZER_ADDRESS, YarnConfiguration.DEFAULT_NM_LOCALIZER_ADDRESS));
+      conf.get(YarnConfiguration.NM_LOCALIZER_ADDRESS, YarnConfiguration.DEFAULT_NM_LOCALIZER_ADDRESS),
+      YarnConfiguration.DEFAULT_NM_LOCALIZER_PORT,
+      YarnConfiguration.NM_LOCALIZER_ADDRESS);
-    LOG.info("Localizer started on port " + server.getPort());
+    String host = getConfig().get(YarnConfiguration.NM_LOCALIZER_ADDRESS)
+        .split(":")[0];
+    getConfig().set(YarnConfiguration.NM_LOCALIZER_ADDRESS, host + ":" 
+        + server.getPort());
+    localizationServerAddress = NetUtils.createSocketAddr(
+        getConfig().get(YarnConfiguration.NM_LOCALIZER_ADDRESS, 
+            YarnConfiguration.DEFAULT_NM_LOCALIZER_ADDRESS));
+    LOG.info("Localizer started on port " + server.getPort());
-    return rpc.getServer(LocalizationProtocol.class, this,
+    Server server = rpc.getServer(LocalizationProtocol.class, this,
-
+    
+    // Enable service authorization?
+    if (conf.getBoolean(
+        CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION, 
+        false)) {
+      server.refreshServiceAcl(conf, new NMPolicyProvider());
+    }
+    
+    return server;
-      server.close();
+      server.stop();
-  @SuppressWarnings("unchecked") // dispatcher not typed
-    String userName;
-    String appIDStr;
-    Container c;
-    Map<LocalResourceVisibility, Collection<LocalResourceRequest>> rsrcs;
-    LocalResourcesTracker tracker;
-      Application app =
-        ((ApplicationLocalizationEvent)event).getApplication();
-      // 0) Create application tracking structs
-      userName = app.getUser();
-      privateRsrc.putIfAbsent(userName,
-          new LocalResourcesTrackerImpl(userName, dispatcher));
-      if (null != appRsrc.putIfAbsent(ConverterUtils.toString(app.getAppId()),
-          new LocalResourcesTrackerImpl(app.getUser(), dispatcher))) {
-        LOG.warn("Initializing application " + app + " already present");
-        assert false; // TODO: FIXME assert doesn't help
-                      // ^ The condition is benign. Tests should fail and it
-                      //   should appear in logs, but it's an internal error
-                      //   that should have no effect on applications
-      }
-      // 1) Signal container init
-      dispatcher.getEventHandler().handle(new ApplicationInitedEvent(
-            app.getAppId()));
+      handleInitApplicationResources(
+          ((ApplicationLocalizationEvent)event).getApplication());
-      ContainerLocalizationRequestEvent rsrcReqs =
-        (ContainerLocalizationRequestEvent) event;
-      c = rsrcReqs.getContainer();
-      LocalizerContext ctxt = new LocalizerContext(
-          c.getUser(), c.getContainerID(), c.getCredentials());
-      rsrcs = rsrcReqs.getRequestedResources();
-      for (Map.Entry<LocalResourceVisibility, Collection<LocalResourceRequest>> e :
-           rsrcs.entrySet()) {
-        tracker = getLocalResourcesTracker(e.getKey(), c.getUser(), 
-            c.getContainerID().getApplicationAttemptId().getApplicationId());
-        for (LocalResourceRequest req : e.getValue()) {
-          tracker.handle(new ResourceRequestEvent(req, e.getKey(), ctxt));
-        }
-      }
+      handleInitContainerResources((ContainerLocalizationRequestEvent) event);
-      ResourceRetentionSet retain =
-        new ResourceRetentionSet(delService, cacheTargetSize);
-      retain.addResources(publicRsrc);
-      LOG.debug("Resource cleanup (public) " + retain);
-      for (LocalResourcesTracker t : privateRsrc.values()) {
-        retain.addResources(t);
-        LOG.debug("Resource cleanup " + t.getUser() + ":" + retain);
-      }
+      handleCacheCleanup(event);
-      ContainerLocalizationCleanupEvent rsrcCleanup =
-        (ContainerLocalizationCleanupEvent) event;
-      c = rsrcCleanup.getContainer();
-      rsrcs = rsrcCleanup.getResources();
-      for (Map.Entry<LocalResourceVisibility, Collection<LocalResourceRequest>> e :
-           rsrcs.entrySet()) {
-        tracker = getLocalResourcesTracker(e.getKey(), c.getUser(), 
-            c.getContainerID().getApplicationAttemptId().getApplicationId());
-        for (LocalResourceRequest req : e.getValue()) {
-          tracker.handle(new ResourceReleaseEvent(req, c.getContainerID()));
-        }
-      }
-
-      // Delete the container directories
-      userName = c.getUser();
-      String containerIDStr = c.toString();
-      appIDStr =
-        ConverterUtils.toString(
-            c.getContainerID().getApplicationAttemptId().getApplicationId());
-      for (Path localDir : localDirs) {
-
-        // Delete the user-owned container-dir
-        Path usersdir = new Path(localDir, ContainerLocalizer.USERCACHE);
-        Path userdir = new Path(usersdir, userName);
-        Path allAppsdir = new Path(userdir, ContainerLocalizer.APPCACHE);
-        Path appDir = new Path(allAppsdir, appIDStr);
-        Path containerDir = new Path(appDir, containerIDStr);
-        delService.delete(userName, containerDir, new Path[] {});
-
-        // Delete the nmPrivate container-dir
-        Path sysDir = new Path(localDir, NM_PRIVATE_DIR);
-        Path appSysDir = new Path(sysDir, appIDStr);
-        Path containerSysDir = new Path(appSysDir, containerIDStr);
-        delService.delete(null, containerSysDir,  new Path[] {});
-      }
-
-      dispatcher.getEventHandler().handle(new ContainerEvent(c.getContainerID(),
-            ContainerEventType.CONTAINER_RESOURCES_CLEANEDUP));
+      handleCleanupContainerResources((ContainerLocalizationCleanupEvent)event);
-
-      Application application =
-          ((ApplicationLocalizationEvent) event).getApplication();
-      LocalResourcesTracker appLocalRsrcsTracker =
-        appRsrc.remove(ConverterUtils.toString(application.getAppId()));
-      if (null == appLocalRsrcsTracker) {
-        LOG.warn("Removing uninitialized application " + application);
-      }
-      // TODO: What to do with appLocalRsrcsTracker?
-
-      // Delete the application directories
-      userName = application.getUser();
-      appIDStr = application.toString();
-      for (Path localDir : localDirs) {
-
-        // Delete the user-owned app-dir
-        Path usersdir = new Path(localDir, ContainerLocalizer.USERCACHE);
-        Path userdir = new Path(usersdir, userName);
-        Path allAppsdir = new Path(userdir, ContainerLocalizer.APPCACHE);
-        Path appDir = new Path(allAppsdir, appIDStr);
-        delService.delete(userName, appDir, new Path[] {});
-
-        // Delete the nmPrivate app-dir
-        Path sysDir = new Path(localDir, NM_PRIVATE_DIR);
-        Path appSysDir = new Path(sysDir, appIDStr);
-        delService.delete(null, appSysDir, new Path[] {});
-      }
-
-      // TODO: decrement reference counts of all resources associated with this
-      // app
-
-      dispatcher.getEventHandler().handle(new ApplicationEvent(
-            application.getAppId(),
-            ApplicationEventType.APPLICATION_RESOURCES_CLEANEDUP));
+      handleDestroyApplicationResources(
+          ((ApplicationLocalizationEvent)event).getApplication());
+    default:
+      throw new YarnException("Unknown localization event: " + event);
+  
+  /**
+   * Handle event received the first time any container is scheduled
+   * by a given application.
+   */
+  @SuppressWarnings("unchecked")
+  private void handleInitApplicationResources(Application app) {
+    // 0) Create application tracking structs
+    String userName = app.getUser();
+    privateRsrc.putIfAbsent(userName,
+        new LocalResourcesTrackerImpl(userName, dispatcher));
+    if (null != appRsrc.putIfAbsent(ConverterUtils.toString(app.getAppId()),
+        new LocalResourcesTrackerImpl(app.getUser(), dispatcher))) {
+      LOG.warn("Initializing application " + app + " already present");
+      assert false; // TODO: FIXME assert doesn't help
+                    // ^ The condition is benign. Tests should fail and it
+                    //   should appear in logs, but it's an internal error
+                    //   that should have no effect on applications
+    }
+    // 1) Signal container init
+    //
+    // This is handled by the ApplicationImpl state machine and allows
+    // containers to proceed with launching.
+    dispatcher.getEventHandler().handle(new ApplicationInitedEvent(
+          app.getAppId()));
+  }
+  
+  /**
+   * For each of the requested resources for a container, determines the
+   * appropriate {@link LocalResourcesTracker} and forwards a 
+   * {@link LocalResourceRequest} to that tracker.
+   */
+  private void handleInitContainerResources(
+      ContainerLocalizationRequestEvent rsrcReqs) {
+    Container c = rsrcReqs.getContainer();
+    LocalizerContext ctxt = new LocalizerContext(
+        c.getUser(), c.getContainerID(), c.getCredentials());
+    Map<LocalResourceVisibility, Collection<LocalResourceRequest>> rsrcs =
+      rsrcReqs.getRequestedResources();
+    for (Map.Entry<LocalResourceVisibility, Collection<LocalResourceRequest>> e :
+         rsrcs.entrySet()) {
+      LocalResourcesTracker tracker = getLocalResourcesTracker(e.getKey(), c.getUser(), 
+          c.getContainerID().getApplicationAttemptId().getApplicationId());
+      for (LocalResourceRequest req : e.getValue()) {
+        tracker.handle(new ResourceRequestEvent(req, e.getKey(), ctxt));
+      }
+    }
+  }
+  
+  private void handleCacheCleanup(LocalizationEvent event) {
+    ResourceRetentionSet retain =
+      new ResourceRetentionSet(delService, cacheTargetSize);
+    retain.addResources(publicRsrc);
+    LOG.debug("Resource cleanup (public) " + retain);
+    for (LocalResourcesTracker t : privateRsrc.values()) {
+      retain.addResources(t);
+      LOG.debug("Resource cleanup " + t.getUser() + ":" + retain);
+    }
+    //TODO Check if appRsrcs should also be added to the retention set.
+  }
+
+
+  @SuppressWarnings("unchecked")
+  private void handleCleanupContainerResources(
+      ContainerLocalizationCleanupEvent rsrcCleanup) {
+    Container c = rsrcCleanup.getContainer();
+    Map<LocalResourceVisibility, Collection<LocalResourceRequest>> rsrcs =
+      rsrcCleanup.getResources();
+    for (Map.Entry<LocalResourceVisibility, Collection<LocalResourceRequest>> e :
+         rsrcs.entrySet()) {
+      LocalResourcesTracker tracker = getLocalResourcesTracker(e.getKey(), c.getUser(), 
+          c.getContainerID().getApplicationAttemptId().getApplicationId());
+      for (LocalResourceRequest req : e.getValue()) {
+        tracker.handle(new ResourceReleaseEvent(req, c.getContainerID()));
+      }
+    }
+
+    // Delete the container directories
+    String userName = c.getUser();
+    String containerIDStr = c.toString();
+    String appIDStr = ConverterUtils.toString(
+        c.getContainerID().getApplicationAttemptId().getApplicationId());
+    for (Path localDir : localDirs) {
+
+      // Delete the user-owned container-dir
+      Path usersdir = new Path(localDir, ContainerLocalizer.USERCACHE);
+      Path userdir = new Path(usersdir, userName);
+      Path allAppsdir = new Path(userdir, ContainerLocalizer.APPCACHE);
+      Path appDir = new Path(allAppsdir, appIDStr);
+      Path containerDir = new Path(appDir, containerIDStr);
+      delService.delete(userName, containerDir, new Path[] {});
+
+      // Delete the nmPrivate container-dir
+      
+      Path sysDir = new Path(localDir, NM_PRIVATE_DIR);
+      Path appSysDir = new Path(sysDir, appIDStr);
+      Path containerSysDir = new Path(appSysDir, containerIDStr);
+      delService.delete(null, containerSysDir,  new Path[] {});
+    }
+
+    dispatcher.getEventHandler().handle(new ContainerEvent(c.getContainerID(),
+          ContainerEventType.CONTAINER_RESOURCES_CLEANEDUP));
+  }
+
+
+  @SuppressWarnings({"unchecked"})
+  private void handleDestroyApplicationResources(Application application) {
+    String userName;
+    String appIDStr;
+    LocalResourcesTracker appLocalRsrcsTracker =
+      appRsrc.remove(ConverterUtils.toString(application.getAppId()));
+    if (null == appLocalRsrcsTracker) {
+      LOG.warn("Removing uninitialized application " + application);
+    }
+    // TODO: What to do with appLocalRsrcsTracker?
+
+    // Delete the application directories
+    userName = application.getUser();
+    appIDStr = application.toString();
+    for (Path localDir : localDirs) {
+
+      // Delete the user-owned app-dir
+      Path usersdir = new Path(localDir, ContainerLocalizer.USERCACHE);
+      Path userdir = new Path(usersdir, userName);
+      Path allAppsdir = new Path(userdir, ContainerLocalizer.APPCACHE);
+      Path appDir = new Path(allAppsdir, appIDStr);
+      delService.delete(userName, appDir, new Path[] {});
+
+      // Delete the nmPrivate app-dir
+      Path sysDir = new Path(localDir, NM_PRIVATE_DIR);
+      Path appSysDir = new Path(sysDir, appIDStr);
+      delService.delete(null, appSysDir, new Path[] {});
+    }
+
+    // TODO: decrement reference counts of all resources associated with this
+    // app
+
+    dispatcher.getEventHandler().handle(new ApplicationEvent(
+          application.getAppId(),
+          ApplicationEventType.APPLICATION_RESOURCES_CLEANEDUP));
+  }
+
+  private static ExecutorService createLocalizerExecutor(Configuration conf) {
+    int nThreads = conf.getInt(
+        YarnConfiguration.NM_LOCALIZER_FETCH_THREAD_COUNT,
+        YarnConfiguration.DEFAULT_NM_LOCALIZER_FETCH_THREAD_COUNT);
+    ThreadFactory tf = new ThreadFactoryBuilder()
+      .setNameFormat("PublicLocalizer #%d")
+      .build();
+    return Executors.newFixedThreadPool(nThreads, tf);
+  }
+
+
-           Executors.newFixedThreadPool(conf.getInt(
-               YarnConfiguration.NM_LOCALIZER_FETCH_THREAD_COUNT, YarnConfiguration.DEFAULT_NM_LOCALIZER_FETCH_THREAD_COUNT)),
+           createLocalizerExecutor(conf),
-
+    
+      super("Public Localizer");
+      super("LocalizerRunner for " + localizerId);
+      Path nmPrivateCTokensPath = null;
-        Path nmPrivateCTokensPath =
+        nmPrivateCTokensPath =
+
-        DataOutputStream tokenOut = null;
-        try {
-          Credentials credentials = context.getCredentials();
-          FileContext lfs = getLocalFileContext(getConfig());
-          tokenOut =
-              lfs.create(nmPrivateCTokensPath, EnumSet.of(CREATE, OVERWRITE));
-          LOG.info("Writing credentials to the nmPrivate file "
-              + nmPrivateCTokensPath.toString() + ". Credentials list: ");
-          if (LOG.isDebugEnabled()) {
-            for (Token<? extends TokenIdentifier> tk : credentials
-                .getAllTokens()) {
-              LOG.debug(tk.getService() + " : " + tk.encodeToUrlString());
-            }
-          }
-          credentials.writeTokenStorageToStream(tokenOut);
-        } finally {
-          if (tokenOut != null) {
-            tokenOut.close();
-          }
-        }
+        writeCredentials(nmPrivateCTokensPath);
+        delService.delete(null, nmPrivateCTokensPath, new Path[] {});
+      }
+    }
+
+    private void writeCredentials(Path nmPrivateCTokensPath)
+        throws IOException {
+      DataOutputStream tokenOut = null;
+      try {
+        Credentials credentials = context.getCredentials();
+        FileContext lfs = getLocalFileContext(getConfig());
+        tokenOut =
+            lfs.create(nmPrivateCTokensPath, EnumSet.of(CREATE, OVERWRITE));
+        LOG.info("Writing credentials to the nmPrivate file "
+            + nmPrivateCTokensPath.toString() + ". Credentials list: ");
+        if (LOG.isDebugEnabled()) {
+          for (Token<? extends TokenIdentifier> tk : credentials
+              .getAllTokens()) {
+            LOG.debug(tk.getService() + " : " + tk.encodeToUrlString());
+          }
+        }
+        credentials.writeTokenStorageToStream(tokenOut);
+      } finally {
+        if (tokenOut != null) {
+          tokenOut.close();
+        }
+      super("CacheCleanup");

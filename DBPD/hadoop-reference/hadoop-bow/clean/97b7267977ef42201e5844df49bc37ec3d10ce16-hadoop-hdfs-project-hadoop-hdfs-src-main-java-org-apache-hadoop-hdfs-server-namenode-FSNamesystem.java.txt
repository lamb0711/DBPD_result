HDFS-5121.  Add RPCs for creating and manipulating cache pools.  (Contributed by Colin Patrick McCabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1519841 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.protocol.CachePoolInfo;
+    checkOperation(OperationCategory.WRITE);
-      List<PathCacheDirective> directives) {
-    return cacheManager.addDirectives(directives);
+      List<PathCacheDirective> directives) throws IOException {
+    CacheEntryWithPayload retryCacheEntry =
+        RetryCache.waitForCompletion(retryCache, null);
+    if (retryCacheEntry != null && retryCacheEntry.isSuccess()) {
+      return (List<Fallible<PathCacheEntry>>) retryCacheEntry.getPayload();
+    }
+    final FSPermissionChecker pc = getPermissionChecker();
+    boolean success = false;
+    List<Fallible<PathCacheEntry>> results = null;
+    checkOperation(OperationCategory.WRITE);
+    writeLock();
+    try {
+      checkOperation(OperationCategory.WRITE);
+      if (isInSafeMode()) {
+        throw new SafeModeException(
+            "Cannot add path cache directive", safeMode);
+      }
+      results = cacheManager.addDirectives(directives, pc);
+      //getEditLog().logAddPathCacheDirectives(results); FIXME: HDFS-5119
+      success = true;
+    } finally {
+      writeUnlock();
+      if (success) {
+        getEditLog().logSync();
+      }
+      if (isAuditEnabled() && isExternalInvocation()) {
+        logAuditEvent(success, "addPathCacheDirectives", null, null, null);
+      }
+      RetryCache.setState(retryCacheEntry, success, results);
+    }
+    return results;
-  List<Fallible<Long>> removePathCacheEntries(List<Long> ids) {
-    return cacheManager.removeEntries(ids);
+  List<Fallible<Long>> removePathCacheEntries(List<Long> ids) throws IOException {
+    CacheEntryWithPayload retryCacheEntry =
+        RetryCache.waitForCompletion(retryCache, null);
+    if (retryCacheEntry != null && retryCacheEntry.isSuccess()) {
+      return (List<Fallible<Long>>) retryCacheEntry.getPayload();
+    }
+    final FSPermissionChecker pc = getPermissionChecker();
+    boolean success = false;
+    List<Fallible<Long>> results = null;
+    checkOperation(OperationCategory.WRITE);
+    writeLock();
+    try {
+      checkOperation(OperationCategory.WRITE);
+      if (isInSafeMode()) {
+        throw new SafeModeException(
+            "Cannot remove path cache directives", safeMode);
+      }
+      results = cacheManager.removeEntries(ids, pc);
+      //getEditLog().logRemovePathCacheEntries(results); FIXME: HDFS-5119
+      success = true;
+    } finally {
+      writeUnlock();
+      if (isAuditEnabled() && isExternalInvocation()) {
+        logAuditEvent(success, "removePathCacheEntries", null, null, null);
+      }
+      RetryCache.setState(retryCacheEntry, success, results);
+    }
+    getEditLog().logSync();
+    return results;
-      int maxReplies) {
-    return cacheManager.listPathCacheEntries(startId, pool, maxReplies);
+      int maxReplies) throws IOException {
+    checkOperation(OperationCategory.READ);
+    readLock();
+    try {
+      checkOperation(OperationCategory.READ);
+      return cacheManager.listPathCacheEntries(startId, pool, maxReplies);
+    } finally {
+      readUnlock();
+    }
+  }
+
+  public void addCachePool(CachePoolInfo req) throws IOException {
+    final FSPermissionChecker pc = getPermissionChecker();
+    CacheEntry cacheEntry = RetryCache.waitForCompletion(retryCache);
+    if (cacheEntry != null && cacheEntry.isSuccess()) {
+      return; // Return previous response
+    }
+    checkOperation(OperationCategory.WRITE);
+    writeLock();
+    boolean success = false;
+    try {
+      checkOperation(OperationCategory.WRITE);
+      if (!pc.isSuperUser()) {
+        throw new AccessControlException("Non-super users cannot " +
+            "add cache pools.");
+      }
+      if (isInSafeMode()) {
+        throw new SafeModeException(
+            "Cannot add cache pool " + req.getPoolName(), safeMode);
+      }
+      cacheManager.addCachePool(req);
+      //getEditLog().logAddCachePool(req); // FIXME: HDFS-5119
+      success = true;
+    } finally {
+      writeUnlock();
+      if (isAuditEnabled() && isExternalInvocation()) {
+        logAuditEvent(success, "addCachePool", req.getPoolName(), null, null);
+      }
+      RetryCache.setState(cacheEntry, success);
+    }
+    
+    getEditLog().logSync();
+  }
+
+  public void modifyCachePool(CachePoolInfo req) throws IOException {
+    final FSPermissionChecker pc = getPermissionChecker();
+    CacheEntry cacheEntry = RetryCache.waitForCompletion(retryCache);
+    if (cacheEntry != null && cacheEntry.isSuccess()) {
+      return; // Return previous response
+    }
+    checkOperation(OperationCategory.WRITE);
+    writeLock();
+    boolean success = false;
+    try {
+      checkOperation(OperationCategory.WRITE);
+      if (!pc.isSuperUser()) {
+        throw new AccessControlException("Non-super users cannot " +
+            "modify cache pools.");
+      }
+      if (isInSafeMode()) {
+        throw new SafeModeException(
+            "Cannot modify cache pool " + req.getPoolName(), safeMode);
+      }
+      cacheManager.modifyCachePool(req);
+      //getEditLog().logModifyCachePool(req); // FIXME: HDFS-5119
+      success = true;
+    } finally {
+      writeUnlock();
+      if (isAuditEnabled() && isExternalInvocation()) {
+        logAuditEvent(success, "modifyCachePool", req.getPoolName(), null, null);
+      }
+      RetryCache.setState(cacheEntry, success);
+    }
+
+    getEditLog().logSync();
+  }
+
+  public void removeCachePool(String cachePoolName) throws IOException {
+    final FSPermissionChecker pc = getPermissionChecker();
+    CacheEntry cacheEntry = RetryCache.waitForCompletion(retryCache);
+    if (cacheEntry != null && cacheEntry.isSuccess()) {
+      return; // Return previous response
+    }
+    checkOperation(OperationCategory.WRITE);
+    writeLock();
+    boolean success = false;
+    try {
+      checkOperation(OperationCategory.WRITE);
+      if (!pc.isSuperUser()) {
+        throw new AccessControlException("Non-super users cannot " +
+            "remove cache pools.");
+      }
+      if (isInSafeMode()) {
+        throw new SafeModeException(
+            "Cannot remove cache pool " + cachePoolName, safeMode);
+      }
+      cacheManager.removeCachePool(cachePoolName);
+      //getEditLog().logRemoveCachePool(req); // FIXME: HDFS-5119
+      success = true;
+    } finally {
+      writeUnlock();
+      if (isAuditEnabled() && isExternalInvocation()) {
+        logAuditEvent(success, "removeCachePool", cachePoolName, null, null);
+      }
+      RetryCache.setState(cacheEntry, success);
+    }
+    
+    getEditLog().logSync();
+  }
+
+  public List<CachePoolInfo> listCachePools(String prevKey,
+      int maxRepliesPerRequest) throws IOException {
+    final FSPermissionChecker pc = getPermissionChecker();
+    List<CachePoolInfo> results;
+    checkOperation(OperationCategory.READ);
+    readLock();
+    try {
+      checkOperation(OperationCategory.READ);
+      results = cacheManager.listCachePools(pc, prevKey, maxRepliesPerRequest);
+    } finally {
+      readUnlock();
+    }
+    return results;
+  }
+
+  public CacheManager getCacheManager() {
+    return cacheManager;
-
-  public CacheManager getCacheManager() {
-    return cacheManager;
-  }

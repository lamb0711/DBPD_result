HDFS-13783. Add an option to the Balancer to make it run as a long-running service. Contributed by Chen Zhang.

+import com.google.common.annotations.VisibleForTesting;
-      + "on over-utilized machines.";
+      + "on over-utilized machines."
+      + "\n\t[-asService]\tRun as a long running service.";
+
+  @VisibleForTesting
+  private static volatile boolean serviceRunning = false;
+
+  private static volatile int exceptionsSinceLastBalance = 0;
+  private static volatile int failedTimesSinceLastSuccessfulBalance = 0;
+  static int getExceptionsSinceLastBalance() {
+    return exceptionsSinceLastBalance;
+  }
+
+  static int getFailedTimesSinceLastSuccessfulBalance() {
+    return failedTimesSinceLastSuccessfulBalance;
+  }
+
-  static int run(Collection<URI> namenodes, final BalancerParameters p,
-      Configuration conf) throws IOException, InterruptedException {
+  static private int doBalance(Collection<URI> namenodes,
+      final BalancerParameters p, Configuration conf)
+      throws IOException, InterruptedException {
+  static int run(Collection<URI> namenodes, final BalancerParameters p,
+      Configuration conf) throws IOException, InterruptedException {
+    if (!p.getRunAsService()) {
+      return doBalance(namenodes, p, conf);
+    }
+    if (!serviceRunning) {
+      serviceRunning = true;
+    } else {
+      LOG.warn("Balancer already running as a long-service!");
+      return ExitStatus.ALREADY_RUNNING.getExitCode();
+    }
+
+    long scheduleInterval = conf.getTimeDuration(
+          DFSConfigKeys.DFS_BALANCER_SERVICE_INTERVAL_KEY,
+          DFSConfigKeys.DFS_BALANCER_SERVICE_INTERVAL_DEFAULT,
+          TimeUnit.MILLISECONDS);
+    int retryOnException =
+          conf.getInt(DFSConfigKeys.DFS_BALANCER_SERVICE_RETRIES_ON_EXCEPTION,
+              DFSConfigKeys.DFS_BALANCER_SERVICE_RETRIES_ON_EXCEPTION_DEFAULT);
+
+    while (serviceRunning) {
+      try {
+        int retCode = doBalance(namenodes, p, conf);
+        if (retCode < 0) {
+          LOG.info("Balance failed, error code: " + retCode);
+          failedTimesSinceLastSuccessfulBalance++;
+        } else {
+          LOG.info("Balance succeed!");
+          failedTimesSinceLastSuccessfulBalance = 0;
+        }
+        exceptionsSinceLastBalance = 0;
+      } catch (Exception e) {
+        if (++exceptionsSinceLastBalance > retryOnException) {
+          // The caller will process and log the exception
+          throw e;
+        }
+        LOG.warn(
+            "Encounter exception while do balance work. Already tried {} times",
+            exceptionsSinceLastBalance, e);
+      }
+
+      // sleep for next round, will retry for next round when it's interrupted
+      LOG.info("Finished one round, will wait for {} for next round",
+          time2Str(scheduleInterval));
+      Thread.sleep(scheduleInterval);
+    }
+    // normal stop
+    return 0;
+  }
+
+  static void stop() {
+    serviceRunning = false;
+  }
+
+            } else if ("-asService".equalsIgnoreCase(args[i])) {
+              b.setRunAsService(true);
+              LOG.info("Balancer will run as a long running service");

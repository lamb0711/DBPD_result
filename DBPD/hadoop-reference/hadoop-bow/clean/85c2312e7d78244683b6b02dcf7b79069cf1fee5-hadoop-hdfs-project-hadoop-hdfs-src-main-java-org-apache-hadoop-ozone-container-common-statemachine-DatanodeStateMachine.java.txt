HDFS-11492. Ozone: Add the ability to handle sendContainerReport Command. Contributed by Anu Engineer.

+import org.apache.hadoop.ozone.container.common.statemachine.commandhandler.CommandDispatcher;
+import org.apache.hadoop.ozone.container.common.statemachine.commandhandler.ContainerReportHandler;
+import org.apache.hadoop.ozone.protocol.commands.SCMCommand;
+import java.util.concurrent.atomic.AtomicLong;
+  private final CommandDispatcher commandDispatcher;
+  private long commandsHandled;
+  private AtomicLong nextHB;
-   * @param conf - Configration.
+   * @param conf - Configuration.
+    nextHB = new AtomicLong(Time.monotonicNow());
+
+
+     // When we add new handlers just adding a new handler here should do the
+     // trick.
+    commandDispatcher = CommandDispatcher.newBuilder()
+      .addHandler(new ContainerReportHandler())
+      .setConnectionManager(connectionManager)
+      .setContainer(container)
+      .setContext(context)
+      .build();
-    long nextHB = 0;
+
+    initCommandHandlerThread(conf);
-        nextHB = Time.monotonicNow() + heartbeatFrequency;
+        nextHB.set(Time.monotonicNow() + heartbeatFrequency);
-        if (now < nextHB) {
-          Thread.sleep(nextHB - now);
+        if (now < nextHB.get()) {
+          Thread.sleep(nextHB.get() - now);
-        LOG.error("Unable to shutdown statemachine properly.");
+        LOG.error("Unable to shutdown state machine properly.");
+
+  /**
+   * Create a command handler thread.
+   *
+   * @param conf
+   */
+  private void initCommandHandlerThread(Configuration conf) {
+
+    /**
+     * Task that periodically checks if we have any outstanding commands.
+     * It is assumed that commands can be processed slowly and in order.
+     * This assumption might change in future. Right now due to this assumption
+     * we have single command  queue process thread.
+     */
+    Runnable processCommandQueue = () -> {
+      long now;
+      while (getContext().getState() != DatanodeStates.SHUTDOWN) {
+        SCMCommand command = getContext().getNextCommand();
+        if (command != null) {
+          commandDispatcher.handle(command);
+          commandsHandled++;
+        } else {
+          try {
+            // Sleep till the next HB + 1 second.
+            now = Time.monotonicNow();
+            if (nextHB.get() > now) {
+              Thread.sleep((nextHB.get() - now) + 1000L);
+            }
+          } catch (InterruptedException e) {
+            // Ignore this exception.
+          }
+        }
+      }
+    };
+
+    // We will have only one thread for command processing in a datanode.
+    Thread cmdProcessThread = new Thread(processCommandQueue);
+    cmdProcessThread.setDaemon(true);
+    cmdProcessThread.setName("Command processor thread");
+    cmdProcessThread.setUncaughtExceptionHandler((Thread t, Throwable e) -> {
+      // Let us just restart this thread after logging a critical error.
+      // if this thread is not running we cannot handle commands from SCM.
+      LOG.error("Critical Error : Command processor thread encountered an " +
+          "error. Thread: {}", t.toString(), e);
+      cmdProcessThread.start();
+    });
+    cmdProcessThread.start();
+  }
+
+  /**
+   * Returns the number of commands handled  by the datanode.
+   * @return  count
+   */
+  @VisibleForTesting
+  public long getCommandHandled() {
+    return commandsHandled;
+  }

HDFS-8112. Relax permission checking for EC related operations.

+import org.apache.hadoop.security.AccessControlException;
+   * @throws AccessControlException if the user does not have write access
-      final boolean logRetryCache) throws IOException {
+      final FSPermissionChecker pc, final boolean logRetryCache)
+      throws IOException, AccessControlException {
-    FSPermissionChecker pc = null;
-    pc = fsn.getPermissionChecker();
+      // Write access is required to set erasure coding policy
+      if (fsd.isPermissionEnabled()) {
+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);
+      }
-  static List<XAttr> setErasureCodingPolicyXAttr(final FSNamesystem fsn,
+  private static List<XAttr> setErasureCodingPolicyXAttr(final FSNamesystem fsn,
+   * @throws AccessControlException if the user does not have write access
-      final String srcArg, final boolean logRetryCache) throws IOException {
+      final String srcArg, final FSPermissionChecker pc,
+      final boolean logRetryCache) throws IOException {
-    FSPermissionChecker pc = fsn.getPermissionChecker();
+      // Write access is required to unset erasure coding policy
+      if (fsd.isPermissionEnabled()) {
+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);
+      }
+   * @throws AccessControlException if no read access
-      final String src) throws IOException {
+      final String src, FSPermissionChecker pc)
+      throws IOException, AccessControlException {
-    final INodesInPath iip = getINodesInPath(fsn, src);
+    FSDirectory fsd = fsn.getFSDirectory();
+    final INodesInPath iip = fsd.resolvePath(pc, src, DirOp.READ);
+    if (fsn.isPermissionEnabled()) {
+      fsn.getFSDirectory().checkPathAccess(pc, iip, FsAction.READ);
+    }
+
-    return getErasureCodingPolicyForPath(fsn, iip);
-  }
-
-  /**
-   * Check if the file or directory has an erasure coding policy.
-   *
-   * @param fsn namespace
-   * @param srcArg path
-   * @return Whether the file or directory has an erasure coding policy.
-   * @throws IOException
-   */
-  static boolean hasErasureCodingPolicy(final FSNamesystem fsn,
-      final String srcArg) throws IOException {
-    return hasErasureCodingPolicy(fsn, getINodesInPath(fsn, srcArg));
+    return getErasureCodingPolicyForPath(fsd, iip);
-    return getErasureCodingPolicy(fsn, iip) != null;
+    return unprotectedGetErasureCodingPolicy(fsn, iip) != null;
-   * Get the erasure coding policy.
+   * Get the erasure coding policy. This does not do any permission checking.
-  static ErasureCodingPolicy getErasureCodingPolicy(final FSNamesystem fsn,
-      final INodesInPath iip) throws IOException {
+  static ErasureCodingPolicy unprotectedGetErasureCodingPolicy(
+      final FSNamesystem fsn, final INodesInPath iip) throws IOException {
-    return getErasureCodingPolicyForPath(fsn, iip);
+    return getErasureCodingPolicyForPath(fsn.getFSDirectory(), iip);
-  private static INodesInPath getINodesInPath(final FSNamesystem fsn,
-      final String srcArg) throws IOException {
-    final FSDirectory fsd = fsn.getFSDirectory();
-    final FSPermissionChecker pc = fsn.getPermissionChecker();
-    INodesInPath iip = fsd.resolvePath(pc, srcArg, DirOp.READ);
-    if (fsn.isPermissionEnabled()) {
-      fsn.getFSDirectory().checkPathAccess(pc, iip, FsAction.READ);
-    }
-    return iip;
-  }
-
-  private static ErasureCodingPolicy getErasureCodingPolicyForPath(FSNamesystem fsn,
-      INodesInPath iip) throws IOException {
+  private static ErasureCodingPolicy getErasureCodingPolicyForPath(
+      FSDirectory fsd, INodesInPath iip) throws IOException {
-    FSDirectory fsd = fsn.getFSDirectory();

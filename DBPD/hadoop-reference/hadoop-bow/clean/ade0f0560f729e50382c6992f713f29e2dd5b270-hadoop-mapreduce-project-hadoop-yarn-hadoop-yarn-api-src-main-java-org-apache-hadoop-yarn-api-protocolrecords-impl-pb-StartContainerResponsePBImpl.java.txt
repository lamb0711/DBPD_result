MAPREDUCE-2652. Enabled multiple NMs to be runnable on a single node by making shuffle service port to be truely configurable. Contributed by Robert Joseph Evans.



git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1163585 13f79535-47bb-0310-9956-ffa450edef68

+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.List;
+
+
-
-
+import org.apache.hadoop.yarn.proto.YarnServiceProtos.StartContainerResponseProtoOrBuilder;
+import org.apache.hadoop.yarn.proto.YarnProtos.StringBytesMapProto;
-  
+ 
+  private Map<String, ByteBuffer> serviceResponse = null;
+
+    mergeLocalToProto();
+  private void mergeLocalToBuilder() {
+    if (this.serviceResponse != null) {
+      addServiceResponseToProto();
+    }
+  }
+  
+  private void mergeLocalToProto() {
+    if (viaProto) {
+      maybeInitBuilder();
+    }
+    mergeLocalToBuilder();
+    proto = builder.build();
+    viaProto = true;
+  }
+
-    
+   
+
+  @Override
+  public Map<String, ByteBuffer> getAllServiceResponse() {
+    initServiceResponse();
+    return this.serviceResponse;
+  }
+  @Override
+  public ByteBuffer getServiceResponse(String key) {
+    initServiceResponse();
+    return this.serviceResponse.get(key);
+  }
+  private void initServiceResponse() {
+    if (this.serviceResponse != null) {
+      return;
+    }
+    StartContainerResponseProtoOrBuilder p = viaProto ? proto : builder;
+    List<StringBytesMapProto> list = p.getServiceResponseList();
+    this.serviceResponse = new HashMap<String, ByteBuffer>();
-
-
+    for (StringBytesMapProto c : list) {
+      this.serviceResponse.put(c.getKey(), convertFromProtoFormat(c.getValue()));
+    }
+  }
+  
+  @Override
+  public void addAllServiceResponse(final Map<String, ByteBuffer> serviceResponse) {
+    if (serviceResponse == null)
+      return;
+    initServiceResponse();
+    this.serviceResponse.putAll(serviceResponse);
+  }
+  
+  private void addServiceResponseToProto() {
+    maybeInitBuilder();
+    builder.clearServiceResponse();
+    if (serviceResponse == null)
+      return;
+    Iterable<StringBytesMapProto> iterable = new Iterable<StringBytesMapProto>() {
+      
+      @Override
+      public Iterator<StringBytesMapProto> iterator() {
+        return new Iterator<StringBytesMapProto>() {
+          
+          Iterator<String> keyIter = serviceResponse.keySet().iterator();
+          
+          @Override
+          public void remove() {
+            throw new UnsupportedOperationException();
+          }
+          
+          @Override
+          public StringBytesMapProto next() {
+            String key = keyIter.next();
+            return StringBytesMapProto.newBuilder().setKey(key).setValue(convertToProtoFormat(serviceResponse.get(key))).build();
+          }
+          
+          @Override
+          public boolean hasNext() {
+            return keyIter.hasNext();
+          }
+        };
+      }
+    };
+    builder.addAllServiceResponse(iterable);
+  }
+  @Override
+  public void setServiceResponse(String key, ByteBuffer val) {
+    initServiceResponse();
+    this.serviceResponse.put(key, val);
+  }
+  @Override
+  public void removeServiceResponse(String key) {
+    initServiceResponse();
+    this.serviceResponse.remove(key);
+  }
+  @Override
+  public void clearServiceResponse() {
+    initServiceResponse();
+    this.serviceResponse.clear();
+  }

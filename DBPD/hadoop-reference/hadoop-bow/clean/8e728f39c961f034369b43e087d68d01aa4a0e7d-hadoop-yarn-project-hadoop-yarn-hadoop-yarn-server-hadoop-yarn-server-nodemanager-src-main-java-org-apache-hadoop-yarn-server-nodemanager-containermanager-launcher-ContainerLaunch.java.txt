YARN-5714. ContainerExecutor does not order environment map. Contributed by Remi Catherinot and Jim Brennan

+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.Set;
-      return Shell.WINDOWS ? new WindowsShellScriptBuilder() :
-        new UnixShellScriptBuilder();
+      return create(Shell.osType);
+    }
+
+    @VisibleForTesting
+    public static ShellScriptBuilder create(Shell.OSType osType) {
+      return (osType == Shell.OSType.OS_TYPE_WIN) ?
+          new WindowsShellScriptBuilder() :
+          new UnixShellScriptBuilder();
+    /**
+     * Parse an environment value and returns all environment keys it uses.
+     * @param envVal an environment variable's value
+     * @return all environment variable names used in <code>envVal</code>.
+     */
+    public Set<String> getEnvDependencies(final String envVal) {
+      return Collections.emptySet();
+    }
+
+    /**
+     * Returns a dependency ordered version of <code>envs</code>. Does not alter
+     * input <code>envs</code> map.
+     * @param envs environment map
+     * @return a dependency ordered version of <code>envs</code>
+     */
+    public final Map<String, String> orderEnvByDependencies(
+        Map<String, String> envs) {
+      if (envs == null || envs.size() < 2) {
+        return envs;
+      }
+      final Map<String, String> ordered = new LinkedHashMap<String, String>();
+      class Env {
+        private boolean resolved = false;
+        private final Collection<Env> deps = new ArrayList<>();
+        private final String name;
+        private final String value;
+        Env(String name, String value) {
+          this.name = name;
+          this.value = value;
+        }
+        void resolve() {
+          resolved = true;
+          for (Env dep : deps) {
+            if (!dep.resolved) {
+              dep.resolve();
+            }
+          }
+          ordered.put(name, value);
+        }
+      }
+      final Map<String, Env> singletons = new HashMap<>();
+      for (Map.Entry<String, String> e : envs.entrySet()) {
+        Env env = singletons.get(e.getKey());
+        if (env == null) {
+          env = new Env(e.getKey(), e.getValue());
+          singletons.put(env.name, env);
+        }
+        for (String depStr : getEnvDependencies(env.value)) {
+          if (!envs.containsKey(depStr)) {
+            continue;
+          }
+          Env depEnv = singletons.get(depStr);
+          if (depEnv == null) {
+            depEnv = new Env(depStr, envs.get(depStr));
+            singletons.put(depStr, depEnv);
+          }
+          env.deps.add(depEnv);
+        }
+      }
+      for (Env env : singletons.values()) {
+        if (!env.resolved) {
+          env.resolve();
+        }
+      }
+      return ordered;
+    }
+
+    /**
+     * Parse <code>envVal</code> using bash-like syntax to extract env variables
+     * it depends on.
+     */
+    @Override
+    public Set<String> getEnvDependencies(final String envVal) {
+      if (envVal == null || envVal.isEmpty()) {
+        return Collections.emptySet();
+      }
+      final Set<String> deps = new HashSet<>();
+      // env/whitelistedEnv dump values inside double quotes
+      boolean inDoubleQuotes = true;
+      char c;
+      int i = 0;
+      final int len = envVal.length();
+      while (i < len) {
+        c = envVal.charAt(i);
+        if (c == '"') {
+          inDoubleQuotes = !inDoubleQuotes;
+        } else if (c == '\'' && !inDoubleQuotes) {
+          i++;
+          // eat until closing simple quote
+          while (i < len) {
+            c = envVal.charAt(i);
+            if (c == '\\') {
+              i++;
+            }
+            if (c == '\'') {
+              break;
+            }
+            i++;
+          }
+        } else if (c == '\\') {
+          i++;
+        } else if (c == '$') {
+          i++;
+          if (i >= len) {
+            break;
+          }
+          c = envVal.charAt(i);
+          if (c == '{') { // for ${... bash like syntax
+            i++;
+            if (i >= len) {
+              break;
+            }
+            c = envVal.charAt(i);
+            if (c == '#') { // for ${#... bash array syntax
+              i++;
+              if (i >= len) {
+                break;
+              }
+            }
+          }
+          final int start = i;
+          while (i < len) {
+            c = envVal.charAt(i);
+            if (c != '$' && (
+                (i == start && Character.isJavaIdentifierStart(c)) ||
+                    (i > start && Character.isJavaIdentifierPart(c)))) {
+              i++;
+            } else {
+              break;
+            }
+          }
+          if (i > start) {
+            deps.add(envVal.substring(start, i));
+          }
+        }
+        i++;
+      }
+      return deps;
+    }
+
+    /**
+     * Parse <code>envVal</code> using cmd/bat-like syntax to extract env
+     * variables it depends on.
+     */
+    public Set<String> getEnvDependencies(final String envVal) {
+      if (envVal == null || envVal.isEmpty()) {
+        return Collections.emptySet();
+      }
+      final Set<String> deps = new HashSet<>();
+      final int len = envVal.length();
+      int i = 0;
+      while (i < len) {
+        i = envVal.indexOf('%', i); // find beginning of variable
+        if (i < 0 || i == (len - 1)) {
+          break;
+        }
+        i++;
+        // 3 cases: %var%, %var:...% or %%
+        final int j = envVal.indexOf('%', i); // find end of variable
+        if (j == i) {
+          // %% case, just skip it
+          i++;
+          continue;
+        }
+        if (j < 0) {
+          break; // even %var:...% syntax ends with a %, so j cannot be negative
+        }
+        final int k = envVal.indexOf(':', i);
+        if (k >= 0 && k < j) {
+          // %var:...% syntax
+          deps.add(envVal.substring(i, k));
+        } else {
+          // %var% syntax
+          deps.add(envVal.substring(i, j));
+        }
+        i = j + 1;
+      }
+      return deps;
+    }

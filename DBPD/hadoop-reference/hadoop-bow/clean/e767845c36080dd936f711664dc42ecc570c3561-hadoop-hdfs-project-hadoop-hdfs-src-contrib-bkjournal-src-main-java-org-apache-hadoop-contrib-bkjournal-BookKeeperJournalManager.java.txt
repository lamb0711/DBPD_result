HDFS-2717. BookKeeper Journal output stream doesn't check addComplete rc. Contributed by Ivan Kelly.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1342534 13f79535-47bb-0310-9956-ffa450edef68

+      maxTxId.store(txId);
+          long id = currentLedger.getId();
+          bkc.deleteLedger(id);
-  // TODO(HA): Handle inProgressOk
-  EditLogInputStream getInputStream(long fromTxnId, boolean inProgressOk)
+  EditLogInputStream getInputStream(long fromTxId, boolean inProgressOk)
-      if (l.getFirstTxId() == fromTxnId) {
+      long lastTxId = l.getLastTxId();
+      if (l.isInProgress()) {
+        if (!inProgressOk) {
+          continue;
+        }
+
+        lastTxId = recoverLastTxId(l, false);
+      }
+
+      if (fromTxId >= l.getFirstTxId() && fromTxId <= lastTxId) {
-          LedgerHandle h = bkc.openLedger(l.getLedgerId(),
-                                          BookKeeper.DigestType.MAC,
-                                          digestpw.getBytes());
-          return new BookKeeperEditLogInputStream(h, l);
+          LedgerHandle h;
+          if (l.isInProgress()) { // we don't want to fence the current journal
+            h = bkc.openLedgerNoRecovery(l.getLedgerId(),
+                BookKeeper.DigestType.MAC, digestpw.getBytes());
+          } else {
+            h = bkc.openLedger(l.getLedgerId(), BookKeeper.DigestType.MAC,
+                digestpw.getBytes());
+          }
+          BookKeeperEditLogInputStream s = new BookKeeperEditLogInputStream(h,
+              l);
+          s.skipTo(fromTxId);
+          return s;
-          throw new IOException("Could not open ledger for " + fromTxnId, e);
+          throw new IOException("Could not open ledger for " + fromTxId, e);
-  // TODO(HA): Handle inProgressOk
-  long getNumberOfTransactions(long fromTxnId, boolean inProgressOk)
+  long getNumberOfTransactions(long fromTxId, boolean inProgressOk)
+      long lastTxId = l.getLastTxId();
-        long endTxId = recoverLastTxId(l);
-        if (endTxId == HdfsConstants.INVALID_TXID) {
+        if (!inProgressOk) {
+          continue;
+        }
+
+        lastTxId = recoverLastTxId(l, false);
+        if (lastTxId == HdfsConstants.INVALID_TXID) {
-        count += (endTxId - l.getFirstTxId()) + 1;
-        break;
-      if (l.getFirstTxId() < fromTxnId) {
+      assert lastTxId >= l.getFirstTxId();
+
+      if (lastTxId < fromTxId) {
-      } else if (l.getFirstTxId() == fromTxnId) {
-        count = (l.getLastTxId() - l.getFirstTxId()) + 1;
-        expectedStart = l.getLastTxId() + 1;
+      } else if (l.getFirstTxId() <= fromTxId && lastTxId >= fromTxId) {
+        // we can start in the middle of a segment
+        count = (lastTxId - l.getFirstTxId()) + 1;
+        expectedStart = lastTxId + 1;
-        count += (l.getLastTxId() - l.getFirstTxId()) + 1;
-        expectedStart = l.getLastTxId() + 1;
+        count += (lastTxId - l.getFirstTxId()) + 1;
+        expectedStart = lastTxId + 1;
-          long endTxId = recoverLastTxId(l);
+          long endTxId = recoverLastTxId(l, true);
-  private long recoverLastTxId(EditLogLedgerMetadata l) throws IOException {
+  private long recoverLastTxId(EditLogLedgerMetadata l, boolean fence)
+      throws IOException {
-      LedgerHandle lh = bkc.openLedger(l.getLedgerId(),
-                                       BookKeeper.DigestType.MAC,
-                                       digestpw.getBytes());
+      LedgerHandle lh = null;
+      if (fence) {
+        lh = bkc.openLedger(l.getLedgerId(),
+                            BookKeeper.DigestType.MAC,
+                            digestpw.getBytes());
+      } else {
+        lh = bkc.openLedgerNoRecovery(l.getLedgerId(),
+                                      BookKeeper.DigestType.MAC,
+                                      digestpw.getBytes());
+      }

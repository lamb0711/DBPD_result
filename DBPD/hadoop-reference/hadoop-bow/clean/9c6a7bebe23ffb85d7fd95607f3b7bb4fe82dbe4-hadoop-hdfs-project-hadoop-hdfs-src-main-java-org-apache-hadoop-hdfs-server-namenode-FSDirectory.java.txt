HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.hdfs.protocol.NSQuotaExceededException;
-      FileAlreadyExistsException, SnapshotAccessControlException {
+      FileAlreadyExistsException, SnapshotAccessControlException, IOException {
-    FileAlreadyExistsException, SnapshotAccessControlException {
+    FileAlreadyExistsException, SnapshotAccessControlException, IOException {
+    
+    // srcInode and its subtree cannot contain snapshottable directories with
+    // snapshots
+    List<INodeDirectorySnapshottable> snapshottableDirs = 
+        new ArrayList<INodeDirectorySnapshottable>();
+    checkSnapshot(srcInode, snapshottableDirs);
+    
-    final INodesInPath dstIIP = getExistingPathINodes(dstComponents);
+    INodesInPath dstIIP = getExistingPathINodes(dstComponents);
-    final INode dstParent = dstIIP.getINode(-2);
+    INode dstParent = dstIIP.getINode(-2);
+    // Record the snapshot on srcChild. After the rename, before any new 
+    // snapshot is taken on the dst tree, changes will be recorded in the latest
+    // snapshot of the src tree.
+    if (isSrcInSnapshot) {
+      srcChild = srcChild.recordModification(srcIIP.getLatestSnapshot());
+      srcIIP.setLastINode(srcChild);
+    }
+    
+      // add src to the destination
+      if (dstParent.getParent() == null) {
+        // src and dst file/dir are in the same directory, and the dstParent has
+        // been replaced when we removed the src. Refresh the dstIIP and
+        // dstParent.
+        dstIIP = getExistingPathINodes(dstComponents);
+        dstParent = dstIIP.getINode(-2);
+      }
+      
-        final INodeReference ref = new INodeReference(dstIIP.getINode(-2), withCount);
+        Snapshot dstSnapshot = dstIIP.getLatestSnapshot();
+        final INodeReference.DstReference ref = new INodeReference.DstReference(
+            dstParent.asDirectory(), withCount,
+            dstSnapshot == null ? Snapshot.INVALID_ID : dstSnapshot.getId());
-      // add src to the destination
-
+    // srcInode and its subtree cannot contain snapshottable directories with
+    // snapshots
+    checkSnapshot(srcInode, null);
+    
-    final INodesInPath dstIIP = rootDir.getINodesInPath4Write(dst, false);
+    INodesInPath dstIIP = rootDir.getINodesInPath4Write(dst, false);
-    List<INodeDirectorySnapshottable> snapshottableDirs = 
-        new ArrayList<INodeDirectorySnapshottable>();
+    List<INodeDirectorySnapshottable> snapshottableDirs = 
+        new ArrayList<INodeDirectorySnapshottable>();
-      INode snapshotNode = hasSnapshot(dstInode, snapshottableDirs);
-      if (snapshotNode != null) {
-        error = "The direcotry " + dstInode.getFullPathName()
-            + " cannot be deleted for renaming since "
-            + snapshotNode.getFullPathName()
-            + " is snapshottable and already has snapshots";
-        NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: "
-            + error);
-        throw new IOException(error);
-      }
+      checkSnapshot(dstInode, snapshottableDirs);
+    // Record the snapshot on srcChild. After the rename, before any new 
+    // snapshot is taken on the dst tree, changes will be recorded in the latest
+    // snapshot of the src tree.
+    if (isSrcInSnapshot) {
+      srcChild = srcChild.recordModification(srcIIP.getLatestSnapshot());
+      srcIIP.setLastINode(srcChild);
+    }
+    
+    if (dstParent.getParent() == null) {
+      // src and dst file/dir are in the same directory, and the dstParent has
+      // been replaced when we removed the src. Refresh the dstIIP and
+      // dstParent.
+      dstIIP = rootDir.getINodesInPath4Write(dst, false);
+    }
+    
-        final INodeReference ref = new INodeReference(dstIIP.getINode(-2), withCount);
+        Snapshot dstSnapshot = dstIIP.getLatestSnapshot();
+        final INodeReference.DstReference ref = new INodeReference.DstReference(
+            dstIIP.getINode(-2).asDirectory(), withCount,
+            dstSnapshot == null ? Snapshot.INVALID_ID : dstSnapshot.getId());
-        INode snapshotNode = hasSnapshot(targetNode, snapshottableDirs);
-        if (snapshotNode != null) {
-          throw new IOException("The direcotry " + targetNode.getFullPathName()
-              + " cannot be deleted since " + snapshotNode.getFullPathName()
-              + " is snapshottable and already has snapshots");
-        }
+        checkSnapshot(targetNode, snapshottableDirs);
-   * @param target
-   *          The given INode
-   * @param snapshottableDirs
-   *          The list of directories that are snapshottable but do not have
-   *          snapshots yet
-   * @return The INode which is snapshottable and already has snapshots.
+   * @param target The given INode
+   * @param snapshottableDirs The list of directories that are snapshottable 
+   *                          but do not have snapshots yet
-  private static INode hasSnapshot(INode target,
-      List<INodeDirectorySnapshottable> snapshottableDirs) {
+  private static void checkSnapshot(INode target,
+      List<INodeDirectorySnapshottable> snapshottableDirs) throws IOException {
-          return target;
+          throw new IOException("The direcotry " + ssTargetDir.getFullPathName()
+              + " cannot be deleted since " + ssTargetDir.getFullPathName()
+              + " is snapshottable and already has snapshots");
-          snapshottableDirs.add(ssTargetDir);
+          if (snapshottableDirs != null) {
+            snapshottableDirs.add(ssTargetDir);
+          }
-        INode snapshotDir = hasSnapshot(child, snapshottableDirs);
-        if (snapshotDir != null) {
-          return snapshotDir;
-        }
+        checkSnapshot(child, snapshottableDirs);
-    return null;
-   *          0 for removing a reference;
-   *          1 for removing a non-reference inode. 
-   * @throws NSQuotaExceededException 
+   *          0 for removing a reference whose referred inode has other 
+   *            reference nodes;
+   *         >0 otherwise. 

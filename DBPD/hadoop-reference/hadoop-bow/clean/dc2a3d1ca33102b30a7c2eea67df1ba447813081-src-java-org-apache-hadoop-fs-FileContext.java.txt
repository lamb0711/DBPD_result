HADOOP-6900. Make the iterator returned by FileSystem#listLocatedStatus to throw IOException rather than RuntimeException when there is an IO error fetching the next file. Contributed by Hairong Kuang. 



git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@984301 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.LinkedList;
-import java.util.NoSuchElementException;
-  public Iterator<FileStatus> listStatus(final Path f) throws
+  public RemoteIterator<FileStatus> listStatus(final Path f) throws
-    return new FSLinkResolver<Iterator<FileStatus>>() {
-      public Iterator<FileStatus> next(final AbstractFileSystem fs, final Path p) 
+    return new FSLinkResolver<RemoteIterator<FileStatus>>() {
+      public RemoteIterator<FileStatus> next(
+          final AbstractFileSystem fs, final Path p) 
-  public Iterator<LocatedFileStatus> listLocatedStatus(final Path f) throws
+  public RemoteIterator<LocatedFileStatus> listLocatedStatus(
+      final Path f) throws
-    return new FSLinkResolver<Iterator<LocatedFileStatus>>() {
-      public Iterator<LocatedFileStatus> next(
+    return new FSLinkResolver<RemoteIterator<LocatedFileStatus>>() {
+      public RemoteIterator<LocatedFileStatus> next(
-      Iterator<FileStatus> statusIterator = FileContext.this.listStatus(f);
+      RemoteIterator<FileStatus> statusIterator = 
+        FileContext.this.listStatus(f);
-    public Iterator<LocatedFileStatus> listFiles(
+    public RemoteIterator<LocatedFileStatus> listFiles(
-      return new Iterator<LocatedFileStatus>() {
-        private Stack<Iterator<LocatedFileStatus>> itors = 
-          new Stack<Iterator<LocatedFileStatus>>();
-        Iterator<LocatedFileStatus> curItor = listLocatedStatus(f);
+      return new RemoteIterator<LocatedFileStatus>() {
+        private Stack<RemoteIterator<LocatedFileStatus>> itors = 
+          new Stack<RemoteIterator<LocatedFileStatus>>();
+        RemoteIterator<LocatedFileStatus> curItor = listLocatedStatus(f);
-       
+
-         *  {@inheritDoc}
-         *  @return {@inheritDog} 
-         *  @throws Runtimeexception if any IOException occurs during traversal;
-         *  the IOException is set as the cause of the RuntimeException
+         * Returns <tt>true</tt> if the iterator has more files.
+         *
+         * @return <tt>true</tt> if the iterator has more files.
+         * @throws AccessControlException if not allowed to access next
+         *                                file's status or locations
+         * @throws FileNotFoundException if next file does not exist any more
+         * @throws UnsupportedFileSystemException if next file's 
+         *                                        fs is unsupported
+         * @throws IOException for all other IO errors
+         *                     for example, NameNode is not avaialbe or
+         *                     NameNode throws IOException due to an error
+         *                     while getting the status or block locations
-        public boolean hasNext() {
+        public boolean hasNext() throws IOException {
-         * If it is a directory, tranverse the directory if recursive is true;
+         * If it is a directory, traverse the directory if recursive is true;
-         * @throws RuntimeException if any io error occurs; the io exception
-         * is set as the cause of RuntimeException
+         * @throws AccessControlException if access is denied
+         * @throws FileNotFoundException if file is not found
+         * @throws UnsupportedFileSystemException if fs is not supported
+         * @throws IOException for all other IO errors
-        private void handleFileStat(LocatedFileStatus stat) {
-          try {
-            if (stat.isFile()) { // file
-              curFile = stat;
-            } else if (stat.isSymlink()) { // symbolic link
-              // resolve symbolic link
-              FileStatus symstat = FileContext.this.getFileStatus(
-                  stat.getSymlink());
-              if (symstat.isFile() || (recursive && symstat.isDirectory())) {
-                itors.push(curItor);
-                curItor = listLocatedStatus(stat.getPath());
-              }
-            } else if (recursive) { // directory
+        private void handleFileStat(LocatedFileStatus stat)
+        throws IOException {
+          if (stat.isFile()) { // file
+            curFile = stat;
+          } else if (stat.isSymlink()) { // symbolic link
+            // resolve symbolic link
+            FileStatus symstat = FileContext.this.getFileStatus(
+                stat.getSymlink());
+            if (symstat.isFile() || (recursive && symstat.isDirectory())) {
-          } catch (IOException ioe) {
-            throw (RuntimeException)new RuntimeException().initCause(ioe);
+          } else if (recursive) { // directory
+            itors.push(curItor);
+            curItor = listLocatedStatus(stat.getPath());
-         *  {@inheritDoc}
-         *  @return {@inheritDoc} 
-         *  @throws Runtimeexception if any IOException occurs during traversal;
-         *  the IOException is set as the cause of the RuntimeException
-         *  @exception {@inheritDoc}
+         * Returns the next file's status with its block locations
+         *
+         * @throws AccessControlException if not allowed to access next
+         *                                file's status or locations
+         * @throws FileNotFoundException if next file does not exist any more
+         * @throws UnsupportedFileSystemException if next file's 
+         *                                        fs is unsupported
+         * @throws IOException for all other IO errors
+         *                     for example, NameNode is not avaialbe or
+         *                     NameNode throws IOException due to an error
+         *                     while getting the status or block locations
-        public LocatedFileStatus next() {
+        public LocatedFileStatus next() throws IOException {
-
-        @Override
-        public void remove() {
-          throw new UnsupportedOperationException("Remove is not supported");
-
-        }

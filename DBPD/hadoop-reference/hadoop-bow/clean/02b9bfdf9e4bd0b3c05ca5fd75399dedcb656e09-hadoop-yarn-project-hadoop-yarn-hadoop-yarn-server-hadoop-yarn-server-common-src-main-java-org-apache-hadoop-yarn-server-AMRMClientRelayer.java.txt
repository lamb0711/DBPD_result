YARN-8658. [AMRMProxy] Metrics for AMRMClientRelayer inside FederationInterceptor. Contributed by Young Chen.

+import org.apache.hadoop.yarn.api.records.Container;
+import org.apache.hadoop.yarn.server.metrics.AMRMClientRelayerMetrics;
+  /**
+   * Data structures for pending and allocate latency metrics. This only applies
+   * for requests with non-zero allocationRequestId.
+   */
+  private Map<Long, Integer> pendingCountForMetrics = new HashMap<>();
+  private Map<Long, Long> askTimeStamp = new HashMap<>();
+  // List of allocated containerId to avoid double counting
+  private Set<ContainerId> knownContainers = new HashSet<>();
+
+  private Map<ContainerId, Long> changeTimeStamp = new HashMap<>();
+  private String rmId = "";
+  private volatile boolean shutdown = false;
+
+  private AMRMClientRelayerMetrics metrics;
+
+    this.metrics = AMRMClientRelayerMetrics.getInstance();
+    this.rmClient = null;
+    this.appId = null;
+    this.rmId = "";
-      ApplicationId appId) {
+      ApplicationId appId, String rmId) {
+    this.rmId = rmId;
+    shutdown();
+  public void setRMClient(ApplicationMasterProtocol client){
+    this.rmClient = client;
+  }
+
+  public void shutdown() {
+    // On finish, clear out our pending count from the metrics
+    // and set the shut down flag so no more pending requests get
+    // added
+    synchronized (this) {
+      if (this.shutdown) {
+        LOG.warn(
+            "Shutdown called twice for AMRMClientRelayer for RM " + this.rmId);
+        return;
+      }
+      this.shutdown = true;
+      for (Map.Entry<ResourceRequestSetKey, ResourceRequestSet> entry
+          : this.remotePendingAsks .entrySet()) {
+        ResourceRequestSetKey key = entry.getKey();
+        if (key.getAllocationRequestId() == 0) {
+          this.metrics.decrClientPending(this.rmId,
+              AMRMClientRelayerMetrics.getRequestType(key.getExeType()),
+              entry.getValue().getNumContainers());
+        } else {
+          this.askTimeStamp.remove(key.getAllocationRequestId());
+          Integer pending =
+              this.pendingCountForMetrics.remove(key.getAllocationRequestId());
+          if (pending == null) {
+            throw new YarnRuntimeException(
+                "pendingCountForMetrics not found for key " + key
+                    + " during shutdown");
+          }
+          this.metrics.decrClientPending(this.rmId,
+              AMRMClientRelayerMetrics.getRequestType(key.getExeType()),
+              pending);
+        }
+      }
+      for(UpdateContainerRequest req : remotePendingChange.values()) {
+        this.metrics
+            .decrClientPending(rmId, req.getContainerUpdateType(), 1);
+      }
+    }
+  }
+
-      LOG.warn("Out of sync with RM for " + this.appId + ", hence resyncing.");
+      LOG.warn("Out of sync with RM " + rmId
+          + " for " + this.appId + ", hence resyncing.");
-        this.remotePendingChange.put(update.getContainerId(), update);
+        UpdateContainerRequest req =
+            this.remotePendingChange.put(update.getContainerId(), update);
+        this.changeTimeStamp
+            .put(update.getContainerId(), System.currentTimeMillis());
+        if (req == null) {
+          // If this is a brand new request, all we have to do is increment
+          this.metrics
+              .incrClientPending(rmId, update.getContainerUpdateType(), 1);
+        } else if (req.getContainerUpdateType() != update
+            .getContainerUpdateType()) {
+          // If this is replacing a request with a different update type, we
+          // need to decrement the replaced type
+          this.metrics
+              .decrClientPending(rmId, req.getContainerUpdateType(), 1);
+          this.metrics
+              .incrClientPending(rmId, update.getContainerUpdateType(), 1);
+        }
+    long startTime = System.currentTimeMillis();
+    synchronized (this) {
+      if(this.shutdown){
+        throw new YarnException("Allocate called after AMRMClientRelayer for "
+            + "RM " + rmId + " shutdown.");
+      }
+      addNewAllocateRequest(allocateRequest);
+
+      ArrayList<ResourceRequest> askList = new ArrayList<>(ask.size());
+      for (ResourceRequest r : ask) {
+        // create a copy of ResourceRequest as we might change it while the
+        // RPC layer is using it to send info across
+        askList.add(ResourceRequest.clone(r));
+      }
+
+      allocateRequest = AllocateRequest.newBuilder()
+          .responseId(allocateRequest.getResponseId())
+          .progress(allocateRequest.getProgress()).askList(askList)
+          .releaseList(new ArrayList<>(this.release))
+          .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(
+              new ArrayList<>(this.blacklistAdditions),
+              new ArrayList<>(this.blacklistRemovals)))
+          .updateRequests(new ArrayList<>(this.change.values()))
+          .schedulingRequests(new ArrayList<>(this.schedulingRequest))
+          .build();
+
+      if (this.resetResponseId != -1) {
+        LOG.info("Override allocate responseId from "
+            + allocateRequest.getResponseId() + " to " + this.resetResponseId
+            + " for " + this.appId);
+        allocateRequest.setResponseId(this.resetResponseId);
+      }
+    }
+
+    // Do the actual allocate call
+      allocateResponse = this.rmClient.allocate(allocateRequest);
+
+      // Heartbeat succeeded, wipe out responseId overriding
+      this.resetResponseId = -1;
+    } catch (ApplicationMasterNotRegisteredException e) {
+      // This is a retriable exception - we will re register and mke a
+      // recursive call to retry
+      LOG.warn("ApplicationMaster is out of sync with RM " + rmId
+          + " for " + this.appId + ", hence resyncing.");
+
+      this.metrics.incrRMMasterSlaveSwitch(this.rmId);
+
-        addNewAllocateRequest(allocateRequest);
-
-        ArrayList<ResourceRequest> askList = new ArrayList<>(ask.size());
-        for (ResourceRequest r : ask) {
-          // create a copy of ResourceRequest as we might change it while the
-          // RPC layer is using it to send info across
-          askList.add(ResourceRequest.clone(r));
+        // Add all remotePending data into to-send data structures
+        for (ResourceRequestSet requestSet : this.remotePendingAsks
+            .values()) {
+          for (ResourceRequest rr : requestSet.getRRs()) {
+            addResourceRequestToAsk(rr);
+          }
-
-        allocateRequest = AllocateRequest.newBuilder()
-            .responseId(allocateRequest.getResponseId())
-            .progress(allocateRequest.getProgress()).askList(askList)
-            .releaseList(new ArrayList<>(this.release))
-            .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(
-                new ArrayList<>(this.blacklistAdditions),
-                new ArrayList<>(this.blacklistRemovals)))
-            .updateRequests(new ArrayList<>(this.change.values()))
-            .schedulingRequests(new ArrayList<>(this.schedulingRequest))
-            .build();
-
-        if (this.resetResponseId != -1) {
-          LOG.info("Override allocate responseId from "
-              + allocateRequest.getResponseId() + " to " + this.resetResponseId
-              + " for " + this.appId);
-          allocateRequest.setResponseId(this.resetResponseId);
+        this.release.addAll(this.remotePendingRelease);
+        this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);
+        this.change.putAll(this.remotePendingChange);
+        for (List<SchedulingRequest> reqs : this.remotePendingSchedRequest
+            .values()) {
+          this.schedulingRequest.addAll(reqs);
-      // Do the actual allocate call
-      try {
-        allocateResponse = this.rmClient.allocate(allocateRequest);
+      // re-register with RM, then retry allocate recursively
+      registerApplicationMaster(this.amRegistrationRequest);
+      // Reset responseId after re-register
+      allocateRequest.setResponseId(0);
+      allocateResponse = allocate(allocateRequest);
+      return allocateResponse;
+    } catch (Throwable t) {
+      // Unexpected exception - rethrow and increment heart beat failure metric
+      this.metrics.addHeartbeatFailure(this.rmId,
+          System.currentTimeMillis() - startTime);
-        // Heartbeat succeeded, wipe out responseId overriding
-        this.resetResponseId = -1;
-      } catch (ApplicationMasterNotRegisteredException e) {
-        LOG.warn("ApplicationMaster is out of sync with RM for " + this.appId
-            + " hence resyncing.");
+      // If RM is complaining about responseId out of sync, force reset next
+      // time
+      if (t instanceof InvalidApplicationMasterRequestException) {
+        int responseId = AMRMClientUtils
+            .parseExpectedResponseIdFromException(t.getMessage());
+        if (responseId != -1) {
+          this.resetResponseId = responseId;
+          LOG.info("ResponseId out of sync with RM, expect " + responseId
+              + " but " + allocateRequest.getResponseId() + " used by "
+              + this.appId + ". Will override in the next allocate.");
+        } else {
+          LOG.warn("Failed to parse expected responseId out of exception for "
+              + this.appId);
+        }
+      }
-        synchronized (this) {
-          // Add all remotePending data into to-send data structures
-          for (ResourceRequestSet requestSet : this.remotePendingAsks
-              .values()) {
-            for (ResourceRequest rr : requestSet.getRRs()) {
-              addResourceRequestToAsk(rr);
+      throw t;
+    }
+
+    synchronized (this) {
+      if (this.shutdown) {
+        throw new YarnException("Allocate call succeeded for " + this.appId
+            + " after AMRMClientRelayer for RM " + rmId + " shutdown.");
+      }
+
+      updateMetrics(allocateResponse, startTime);
+
+      AMRMClientUtils.removeFromOutstandingSchedulingRequests(
+          allocateResponse.getAllocatedContainers(),
+          this.remotePendingSchedRequest);
+      AMRMClientUtils.removeFromOutstandingSchedulingRequests(
+          allocateResponse.getContainersFromPreviousAttempts(),
+          this.remotePendingSchedRequest);
+
+      this.ask.clear();
+      this.release.clear();
+
+      this.blacklistAdditions.clear();
+      this.blacklistRemovals.clear();
+
+      this.change.clear();
+      this.schedulingRequest.clear();
+      return allocateResponse;
+    }
+  }
+
+  private void updateMetrics(AllocateResponse allocateResponse,
+      long startTime) {
+    this.metrics.addHeartbeatSuccess(this.rmId,
+        System.currentTimeMillis() - startTime);
+    // Process the allocate response from RM
+    if (allocateResponse.getAllocatedContainers() != null) {
+      for (Container container : allocateResponse
+          .getAllocatedContainers()) {
+        // Do not update metrics aggressively for AllocationRequestId zero
+        // case. Also avoid double count to due to re-send
+        if (this.knownContainers.add(container.getId())) {
+          this.metrics.addFulfilledQPS(this.rmId, AMRMClientRelayerMetrics
+              .getRequestType(container.getExecutionType()), 1);
+          if (container.getAllocationRequestId() != 0) {
+            Integer count = this.pendingCountForMetrics
+                .get(container.getAllocationRequestId());
+            if (count != null && count > 0) {
+              this.pendingCountForMetrics
+                  .put(container.getAllocationRequestId(), --count);
+              this.metrics.decrClientPending(this.rmId,
+                  AMRMClientRelayerMetrics
+                      .getRequestType(container.getExecutionType()), 1);
+              this.metrics.addFulfillLatency(this.rmId,
+                  AMRMClientRelayerMetrics
+                      .getRequestType(container.getExecutionType()),
+                  System.currentTimeMillis() - this.askTimeStamp
+                      .get(container.getAllocationRequestId()));
-          this.release.addAll(this.remotePendingRelease);
-          this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);
-          this.change.putAll(this.remotePendingChange);
-          for (List<SchedulingRequest> reqs : this.remotePendingSchedRequest
-              .values()) {
-            this.schedulingRequest.addAll(reqs);
-          }
-        }
-
-        // re-register with RM, then retry allocate recursively
-        registerApplicationMaster(this.amRegistrationRequest);
-        // Reset responseId after re-register
-        allocateRequest.setResponseId(0);
-        return allocate(allocateRequest);
-      } catch (Throwable t) {
-
-        // If RM is complaining about responseId out of sync, force reset next
-        // time
-        if (t instanceof InvalidApplicationMasterRequestException) {
-          int responseId = AMRMClientUtils
-              .parseExpectedResponseIdFromException(t.getMessage());
-          if (responseId != -1) {
-            this.resetResponseId = responseId;
-            LOG.info("ResponseId out of sync with RM, expect " + responseId
-                + " but " + allocateRequest.getResponseId() + " used by "
-                + this.appId + ". Will override in the next allocate.");
-          } else {
-            LOG.warn("Failed to parse expected responseId out of exception for "
-                + this.appId);
-          }
-        }
-
-        throw t;
-      }
-
-      synchronized (this) {
-        // Process the allocate response from RM
-        if (allocateResponse.getCompletedContainersStatuses() != null) {
-          for (ContainerStatus container : allocateResponse
-              .getCompletedContainersStatuses()) {
-            this.remotePendingRelease.remove(container.getContainerId());
-            this.remotePendingChange.remove(container.getContainerId());
-          }
-        }
-
-        if (allocateResponse.getUpdatedContainers() != null) {
-          for (UpdatedContainer updatedContainer : allocateResponse
-              .getUpdatedContainers()) {
-            this.remotePendingChange
-                .remove(updatedContainer.getContainer().getId());
-          }
-        }
-
-        AMRMClientUtils.removeFromOutstandingSchedulingRequests(
-            allocateResponse.getAllocatedContainers(),
-            this.remotePendingSchedRequest);
-        AMRMClientUtils.removeFromOutstandingSchedulingRequests(
-            allocateResponse.getContainersFromPreviousAttempts(),
-            this.remotePendingSchedRequest);
-      }
-
-    } finally {
-      synchronized (this) {
-        /*
-         * If allocateResponse is null, it means exception happened and RM did
-         * not accept the request. Don't clear any data structures so that they
-         * will be re-sent next time.
-         *
-         * Otherwise request was accepted by RM, we are safe to clear these.
-         */
-        if (allocateResponse != null) {
-          this.ask.clear();
-          this.release.clear();
-
-          this.blacklistAdditions.clear();
-          this.blacklistRemovals.clear();
-
-          this.change.clear();
-          this.schedulingRequest.clear();
-    return allocateResponse;
+    if (allocateResponse.getCompletedContainersStatuses() != null) {
+      for (ContainerStatus container : allocateResponse
+          .getCompletedContainersStatuses()) {
+        this.remotePendingRelease.remove(container.getContainerId());
+        UpdateContainerRequest req =
+            this.remotePendingChange.remove(container.getContainerId());
+        if (req != null) {
+          this.metrics
+              .decrClientPending(rmId, req.getContainerUpdateType(), 1);
+        }
+        this.knownContainers.remove(container.getContainerId());
+      }
+    }
+
+    if (allocateResponse.getUpdatedContainers() != null) {
+      for (UpdatedContainer updatedContainer : allocateResponse
+          .getUpdatedContainers()) {
+        UpdateContainerRequest req = this.remotePendingChange
+            .remove(updatedContainer.getContainer().getId());
+        if (req != null) {
+          this.metrics
+              .decrClientPending(rmId, req.getContainerUpdateType(), 1);
+          this.metrics.addFulfillLatency(rmId, req.getContainerUpdateType(),
+              System.currentTimeMillis() - this.changeTimeStamp
+                  .remove(req.getContainerId()));
+          this.metrics
+              .addFulfilledQPS(rmId, req.getContainerUpdateType(), 1);
+        }
+      }
+    }
+
+    Set<ResourceRequestSetKey> nonZeroNewKeys = new HashSet<>();
+        if (key.getAllocationRequestId() != 0) {
+          nonZeroNewKeys.add(key);
+        }
+
+      int numContainers = askSet.getNumContainers();
+      int deltaContainers = askSet.getNumContainers() - numContainers;
+
+      if (key.getAllocationRequestId() == 0) {
+        // AllocationRequestId is zero, keep track of pending count in the
+        // delayed but correct way. Allocation latency is not supported
+        if (deltaContainers != 0) {
+          this.metrics.incrClientPending(this.rmId,
+              AMRMClientRelayerMetrics.getRequestType(key.getExeType()),
+              deltaContainers);
+          if(deltaContainers > 0){
+            this.metrics.addRequestedQPS(this.rmId,
+                AMRMClientRelayerMetrics.getRequestType(key.getExeType()),
+                deltaContainers);
+          }
+        }
+      } else {
+        // AllocationRequestId is non-zero, we do pending decrement and latency
+        // aggressively. So don't update metrics here. Double check AM is not
+        // reusing the requestId for more asks
+        if (deltaContainers > 0 && numContainers != 0) {
+          throw new YarnException("Received new ask ("
+              + askSet.getNumContainers() + ") on top of existing ("
+              + numContainers + ") in key " + key);
+        }
+      }
+
+    // Initialize data for pending metrics for each new key
+    for (ResourceRequestSetKey key : nonZeroNewKeys) {
+      if(remotePendingAsks.containsKey(key)){
+        this.askTimeStamp.put(key.getAllocationRequestId(),
+            System.currentTimeMillis());
+        int count = this.remotePendingAsks.get(key).getNumContainers();
+        this.pendingCountForMetrics.put(key.getAllocationRequestId(), count);
+        this.metrics.incrClientPending(this.rmId,
+            AMRMClientRelayerMetrics.getRequestType(key.getExeType()), count);
+        this.metrics.addRequestedQPS(this.rmId,
+            AMRMClientRelayerMetrics.getRequestType(key.getExeType()), count);
+      }
+    }

YARN-4987. Read cache concurrency issue between read and evict in EntityGroupFS timeline store. Contributed by Li Lu.

+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.classification.InterfaceAudience;
+import java.util.concurrent.atomic.AtomicInteger;
+  private TimelineEntityGroupId groupId;
+  private int refCount = 0;
+  private static AtomicInteger activeStores = new AtomicInteger(0);
-  public EntityCacheItem(Configuration config, FileSystem fs) {
+  public EntityCacheItem(TimelineEntityGroupId gId, Configuration config,
+      FileSystem fs) {
+    this.groupId = gId;
+   * This method will not hold the storage from being reclaimed.
+   * @return The number of currently active stores in all CacheItems.
+   */
+  public static int getActiveStores() {
+    return activeStores.get();
+  }
+
+  /**
-   * @param groupId Group id of the cache
-  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,
-      TimelineACLsManager aclManager, JsonFactory jsonFactory,
-      ObjectMapper objMapper, EntityGroupFSTimelineStoreMetrics metrics)
-      throws IOException {
+  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,
+      JsonFactory jsonFactory, ObjectMapper objMapper,
+      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {
+          activeStores.getAndIncrement();
-   * Release the cache item for the given group id.
-   *
-   * @param groupId the group id that the cache should release
+   * Increase the number of references to this cache item by 1.
-  public synchronized void releaseCache(TimelineEntityGroupId groupId) {
+  public synchronized void incrRefs() {
+    refCount++;
+  }
+
+  /**
+   * Unregister a reader. Try to release the cache if the reader to current
+   * cache reaches 0.
+   *
+   * @return true if the cache has been released, otherwise false
+   */
+  public synchronized boolean tryRelease() {
+    refCount--;
+    // Only reclaim the storage if there is no reader.
+    if (refCount > 0) {
+      LOG.debug("{} references left for cached group {}, skipping the release",
+          refCount, groupId);
+      return false;
+    }
+    forceRelease();
+    return true;
+  }
+
+  /**
+   * Force releasing the cache item for the given group id, even though there
+   * may be active references.
+   */
+  public synchronized void forceRelease() {
+    activeStores.getAndDecrement();
+    refCount = 0;
+    LOG.debug("Cache for group {} released. ", groupId);
+  }
+
+  @InterfaceAudience.Private
+  @VisibleForTesting
+  synchronized int getRefCount() {
+    return refCount;

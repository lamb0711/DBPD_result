HDFS-12474. Ozone: SCM: Handling container report with key count and container usage. Contributed by Nanda kumar.

+import org.apache.hadoop.hdfs.protocol.DatanodeID;
+import org.apache.hadoop.ozone.protocol.proto.StorageContainerDatanodeProtocolProtos;
+import org.apache.hadoop.ozone.protocol.proto
+    .StorageContainerDatanodeProtocolProtos.ContainerReportsRequestProto;
-import org.apache.hadoop.scm.container.common.helpers.BlockContainerInfo;
+  private final float containerCloseThreshold;
+    this.containerCloseThreshold = conf.getFloat(
+        ScmConfigKeys.OZONE_SCM_CONTAINER_CLOSE_THRESHOLD,
+        ScmConfigKeys.OZONE_SCM_CONTAINER_CLOSE_THRESHOLD_DEFAULT);
-          containerStateManager.updateContainerState(
-              new BlockContainerInfo(containerInfo, 0),
+          updateContainerState(containerName,
-      // TODO: Actual used will be updated via Container Reports later.
-      containerInfo.setState(
-          containerStateManager.updateContainerState(
-              new BlockContainerInfo(containerInfo, 0), event));
-
-      containerStore.put(dbKey, containerInfo.getProtobuf().toByteArray());
+      ContainerInfo updatedContainer = containerStateManager
+          .updateContainerState(containerInfo, event);
+      containerStore.put(dbKey, updatedContainer.getProtobuf().toByteArray());
+   * Process container report from Datanode.
+   *
+   * @param datanodeID Datanode ID
+   * @param reportType Type of report
+   * @param containerInfos container details
+   */
+  @Override
+  public void processContainerReports(
+      DatanodeID datanodeID,
+      ContainerReportsRequestProto.reportType reportType,
+      List<StorageContainerDatanodeProtocolProtos.ContainerInfo>
+          containerInfos) throws IOException {
+    for (StorageContainerDatanodeProtocolProtos.ContainerInfo containerInfo :
+        containerInfos) {
+      byte[] dbKey = containerInfo.getContainerNameBytes().toByteArray();
+      lock.lock();
+      try {
+        byte[] containerBytes = containerStore.get(dbKey);
+        if (containerBytes != null) {
+          OzoneProtos.SCMContainerInfo oldInfo =
+              OzoneProtos.SCMContainerInfo.PARSER.parseFrom(containerBytes);
+
+          OzoneProtos.SCMContainerInfo.Builder builder =
+              OzoneProtos.SCMContainerInfo.newBuilder();
+          builder.setContainerName(oldInfo.getContainerName());
+          builder.setPipeline(oldInfo.getPipeline());
+          // If used size is greater than allocated size, we will be updating
+          // allocated size with used size. This update is done as a fallback
+          // mechanism in case SCM crashes without properly updating allocated
+          // size. Correct allocated value will be updated by
+          // ContainerStateManager during SCM shutdown.
+          long usedSize = containerInfo.getUsed();
+          long allocated = oldInfo.getAllocatedBytes() > usedSize ?
+              oldInfo.getAllocatedBytes() : usedSize;
+          builder.setAllocatedBytes(allocated);
+          builder.setUsedBytes(containerInfo.getUsed());
+          builder.setNumberOfKeys(containerInfo.getKeyCount());
+          builder.setState(oldInfo.getState());
+          builder.setStateEnterTime(oldInfo.getStateEnterTime());
+          if (oldInfo.getOwner() != null) {
+            builder.setOwner(oldInfo.getOwner());
+          }
+          OzoneProtos.SCMContainerInfo newContainerInfo = builder.build();
+          containerStore.put(dbKey, newContainerInfo.toByteArray());
+          float containerUsedPercentage = 1.0f *
+              containerInfo.getUsed() / containerInfo.getSize();
+          // TODO: Handling of containers which are already in close queue.
+          if (containerUsedPercentage >= containerCloseThreshold) {
+            // TODO: The container has to be moved to close container queue.
+            // For now, we are just updating the container state to CLOSED.
+            // Close container implementation can decide on how to maintain
+            // list of containers to be closed, this is the place where we
+            // have to add the containers to that list.
+            ContainerInfo updatedContainer =
+                containerStateManager.updateContainerState(
+                    ContainerInfo.fromProtobuf(newContainerInfo),
+                    OzoneProtos.LifeCycleEvent.CLOSE);
+            if (updatedContainer.getState() !=
+                OzoneProtos.LifeCycleState.CLOSED) {
+              LOG.error("Failed to close container {}, reason : Not able to " +
+                      "update container state, current container state: {}." +
+                      "in state {}", containerInfo.getContainerName(),
+                  updatedContainer.getState());
+            }
+          }
+        } else {
+          // Container not found in our container db.
+          LOG.error("Error while processing container report from datanode :" +
+              " {}, for container: {}, reason: container doesn't exist in" +
+              "container database.");
+        }
+      } finally {
+        lock.unlock();
+      }
+    }
+  }
+
+
+  /**

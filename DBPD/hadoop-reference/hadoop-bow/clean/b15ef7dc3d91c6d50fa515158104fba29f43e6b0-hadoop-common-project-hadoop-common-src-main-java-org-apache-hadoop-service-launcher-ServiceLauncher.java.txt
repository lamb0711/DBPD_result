HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.

Contributed by Steve Loughran

Contains

- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.
- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently

This patch doesn't fix the underlying problem but it

* changes some tests to clean up better
* does a lot more in logging operations in against DDB, if enabled
* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)
* adds a purge entry point to help clean up after a test run has got a store into a mess
* s3guard prune command adds -tombstone option to only clear tombstones

The outcome is that tests should pass consistently and if problems occur we have better diagnostics.

Change-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb

-   * {@link #coreServiceLaunch(Configuration, List, boolean, boolean)}
+   * {@link #coreServiceLaunch(Configuration, Service, List, boolean, boolean)}
-    if (exitException.getExitCode() != 0) {
+    if (exitException.getExitCode() == LauncherExitCodes.EXIT_USAGE) {
-    LOG.debug("Exception raised", exitException);
-    serviceExitCode = exitException.getExitCode();
+    int exitCode = exitException.getExitCode();
+    if (exitCode != 0) {
+      LOG.debug("Exception raised with exit code {}",
+          exitCode,
+          exitException);
+      Throwable cause = exitException.getCause();
+      if (cause != null) {
+        // log the nested exception in more detail
+        LOG.warn("{}", cause.toString(), cause);
+      }
+    }
+    serviceExitCode = exitCode;
-  @VisibleForTesting
-    
+    return launchService(conf, null, processedArgs, addShutdownHook, execute);
+  }
+
+  /**
+   * Launch a service catching all exceptions and downgrading them to exit codes
+   * after logging.
+   *
+   * Sets {@link #serviceException} to this value.
+   * @param conf configuration to use
+   * @param instance optional instance of the service.
+   * @param processedArgs command line after the launcher-specific arguments
+   * have been stripped out.
+   * @param addShutdownHook should a shutdown hook be added to terminate
+   * this service on shutdown. Tests should set this to false.
+   * @param execute execute/wait for the service to stop.
+   * @return an exit exception, which will have a status code of 0 if it worked
+   */
+  public ExitUtil.ExitException launchService(Configuration conf,
+      S instance,
+      List<String> processedArgs,
+      boolean addShutdownHook,
+      boolean execute) {
+
-    
+
-      int exitCode = coreServiceLaunch(conf, processedArgs, addShutdownHook,
-          execute);
+      int exitCode = coreServiceLaunch(conf, instance, processedArgs,
+          addShutdownHook, execute);
+      // other errors need a full log.
+      LOG.error("Exception raised {}",
+          service != null
+              ? (service.toString() + " in state  " + service.getServiceState())
+              : "during service instantiation",
+          thrown);
+   * @param instance optional instance of the service.
+      S instance,
-    instantiateService(conf);
+    if (instance == null) {
+      instantiateService(conf);
+    } else {
+      // service already exists, so instantiate
+      configuration = conf;
+      service = instance;
+    }
-    exitException = new ServiceLaunchException(exitCode, message);
-    exitException.initCause(thrown);
+    exitException = new ServiceLaunchException(exitCode, thrown, message);
-      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR,
+      throw new ServiceLaunchException(EXIT_COMMAND_ARGUMENT_ERROR, e,

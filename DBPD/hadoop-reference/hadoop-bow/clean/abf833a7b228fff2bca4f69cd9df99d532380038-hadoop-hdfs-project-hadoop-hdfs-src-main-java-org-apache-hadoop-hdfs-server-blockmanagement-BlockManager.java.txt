HDFS-7907. Erasure Coding: track invalid, corrupt, and under-recovery striped blocks in NameNode. Contributed by Jing Zhao.

-  /** Blocks to be invalidated. */
+  /**
+   * Blocks to be invalidated.
+   * For a striped block to invalidate, we should track its individual internal
+   * blocks.
+   */
-  public final Map<String, LightWeightLinkedSet<Block>> excessReplicateMap =
-    new TreeMap<String, LightWeightLinkedSet<Block>>();
+  public final Map<String, LightWeightLinkedSet<BlockInfo>> excessReplicateMap =
+    new TreeMap<>();
-  public boolean checkMinStorage(BlockInfo block) {
+  public boolean hasMinStorage(BlockInfo block) {
-  public boolean checkMinStorage(BlockInfo block, int liveNum) {
+  public boolean hasMinStorage(BlockInfo block, int liveNum) {
-    if (checkMinStorage(lastBlock)) {
+    if (hasMinStorage(lastBlock)) {
-    if (!force && !checkMinStorage(curBlock, numNodes)) {
+    if (!force && !hasMinStorage(curBlock, numNodes)) {
-        checkMinStorage(oldBlock, targets.length) ? -1 : 0,
+        hasMinStorage(oldBlock, targets.length) ? -1 : 0,
-    final Iterator<? extends Block> it = node.getBlockIterator();
+    final Iterator<BlockInfo> it = node.getBlockIterator();
-    final Iterator<? extends Block> it = storageInfo.getBlockIterator();
+    final Iterator<BlockInfo> it = storageInfo.getBlockIterator();
-      Block block = it.next();
+      BlockInfo block = it.next();
-  private void addToInvalidates(Block b) {
+  private void addToInvalidates(BlockInfo storedBlock) {
-    for(DatanodeStorageInfo storage : blocksMap.getStorages(b, State.NORMAL)) {
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(storedBlock,
+        State.NORMAL)) {
-      invalidateBlocks.add(b, node, false);
-      datanodes.append(node).append(" ");
+      final Block b = getBlockToInvalidate(storedBlock, storage);
+      if (b != null) {
+        invalidateBlocks.add(b, node, false);
+        datanodes.append(node).append(" ");
+      }
-      blockLog.info("BLOCK* addToInvalidates: {} {}", b, datanodes.toString());
+      blockLog.info("BLOCK* addToInvalidates: {} {}", storedBlock,
+          datanodes.toString());
+  private Block getBlockToInvalidate(BlockInfo storedBlock,
+      DatanodeStorageInfo storage) {
+    return storedBlock.isStriped() ?
+        ((BlockInfoStriped) storedBlock).getBlockOnStorage(storage) : storedBlock;
+  }
+
-    if (b.corrupted.isDeleted()) {
+    if (b.stored.isDeleted()) {
-        b.corrupted.getBlockCollection().getPreferredBlockReplication();
+        b.stored.getBlockCollection().getPreferredBlockReplication();
-      storageInfo.addBlock(b.stored, b.reportedBlock);
+      storageInfo.addBlock(b.stored, b.corrupted);
-    boolean minReplicationSatisfied = checkMinStorage(b.stored,
+
+    boolean minReplicationSatisfied = hasMinStorage(b.stored,
+
-                   (blockHasEnoughRacks(block)) ) {
+                   (blockHasEnoughRacks(block, requiredReplication)) ) {
-                 (blockHasEnoughRacks(block)) ) {
+                 (blockHasEnoughRacks(block, requiredReplication)) ) {
-               (!blockHasEnoughRacks(block)) ) {
+               (!blockHasEnoughRacks(block, requiredReplication)) ) {
-      LightWeightLinkedSet<Block> excessBlocks =
+      LightWeightLinkedSet<BlockInfo> excessBlocks =
-    /** The corrupted block in a datanode. */
-    final BlockInfo corrupted;
+    /**
+     * The corrupted block in a datanode. This is the one reported by the
+     * datanode.
+     */
+    final Block corrupted;
-    /** The block reported from a datanode */
-    final Block reportedBlock;
-    BlockToMarkCorrupt(Block reported, BlockInfo corrupted,
-        BlockInfo stored, String reason, Reason reasonCode) {
-      Preconditions.checkNotNull(reported, "reported is null");
+    BlockToMarkCorrupt(Block corrupted, BlockInfo stored, String reason,
+        Reason reasonCode) {
-      this.reportedBlock = reported;
-    BlockToMarkCorrupt(Block reported, BlockInfo stored, String reason,
-        Reason reasonCode) {
-      this(reported, stored, stored, reason, reasonCode);
-    }
-
-    BlockToMarkCorrupt(Block reported, BlockInfo stored, long gs,
+    BlockToMarkCorrupt(Block corrupted, BlockInfo stored, long gs,
-      this(reported, BlockInfo.copyOf(stored), stored, reason,
-          reasonCode);
+      this(corrupted, stored, reason, reasonCode);
-    Collection<Block> toRemove = new TreeSet<Block>();
-    Collection<Block> toInvalidate = new LinkedList<Block>();
-    Collection<BlockToMarkCorrupt> toCorrupt = new LinkedList<BlockToMarkCorrupt>();
-    Collection<StatefulBlockInfo> toUC = new LinkedList<StatefulBlockInfo>();
+    Collection<BlockInfo> toRemove = new TreeSet<>();
+    Collection<Block> toInvalidate = new LinkedList<>();
+    Collection<BlockToMarkCorrupt> toCorrupt = new LinkedList<>();
+    Collection<StatefulBlockInfo> toUC = new LinkedList<>();
-    for (Block b : toRemove) {
+    for (BlockInfo b : toRemove) {
-      Collection<Block> toRemove,           // remove from DatanodeDescriptor
+      Collection<BlockInfo> toRemove,       // remove from DatanodeDescriptor
-    while(it.hasNext())
+    while (it.hasNext()) {
+    }
-        && checkMinStorage(storedBlock, numCurrentReplica)) {
+        && hasMinStorage(storedBlock, numCurrentReplica)) {
-        checkMinStorage(storedBlock, numLiveReplicas)) {
+        hasMinStorage(storedBlock, numLiveReplicas)) {
-          storedBlock + "blockMap has " + numCorruptNodes + 
+          storedBlock + ". blockMap has " + numCorruptNodes +
-  private void processOverReplicatedBlock(final Block block,
+  private void processOverReplicatedBlock(final BlockInfo block,
-    Collection<DatanodeStorageInfo> nonExcess = new ArrayList<DatanodeStorageInfo>();
+    Collection<DatanodeStorageInfo> nonExcess = new ArrayList<>();
-      LightWeightLinkedSet<Block> excessBlocks = excessReplicateMap.get(cur
-          .getDatanodeUuid());
+      LightWeightLinkedSet<BlockInfo> excessBlocks = excessReplicateMap.get(
+          cur.getDatanodeUuid());
-                              Block b, short replication,
+                              BlockInfo storedBlock, short replication,
-    BlockCollection bc = getBlockCollection(b);
-    final BlockStoragePolicy storagePolicy = storagePolicySuite.getPolicy(bc.getStoragePolicyID());
+    BlockCollection bc = getBlockCollection(storedBlock);
+    final BlockStoragePolicy storagePolicy = storagePolicySuite.getPolicy(
+        bc.getStoragePolicyID());
-    final Map<String, List<DatanodeStorageInfo>> rackMap
-        = new HashMap<String, List<DatanodeStorageInfo>>();
-    final List<DatanodeStorageInfo> moreThanOne = new ArrayList<DatanodeStorageInfo>();
-    final List<DatanodeStorageInfo> exactlyOne = new ArrayList<DatanodeStorageInfo>();
+    final Map<String, List<DatanodeStorageInfo>> rackMap = new HashMap<>();
+    final List<DatanodeStorageInfo> moreThanOne = new ArrayList<>();
+    final List<DatanodeStorageInfo> exactlyOne = new ArrayList<>();
-        cur = replicator.chooseReplicaToDelete(bc, b, replication,
+        cur = replicator.chooseReplicaToDelete(bc, storedBlock, replication,
-      addToExcessReplicate(cur.getDatanodeDescriptor(), b);
+      addToExcessReplicate(cur.getDatanodeDescriptor(), storedBlock);
-      // upon giving instructions to the namenode.
+      // upon giving instructions to the datanodes.
-      addToInvalidates(b, cur.getDatanodeDescriptor());
+      final Block blockToInvalidate = getBlockToInvalidate(storedBlock, cur);
+      addToInvalidates(blockToInvalidate, cur.getDatanodeDescriptor());
-                +"({}, {}) is added to invalidated blocks set", cur, b);
+                +"({}, {}) is added to invalidated blocks set", cur, storedBlock);
-  private void addToExcessReplicate(DatanodeInfo dn, Block block) {
+  private void addToExcessReplicate(DatanodeInfo dn, BlockInfo storedBlock) {
-    LightWeightLinkedSet<Block> excessBlocks = excessReplicateMap.get(dn.getDatanodeUuid());
+    LightWeightLinkedSet<BlockInfo> excessBlocks = excessReplicateMap.get(
+        dn.getDatanodeUuid());
-      excessBlocks = new LightWeightLinkedSet<Block>();
+      excessBlocks = new LightWeightLinkedSet<>();
-    if (excessBlocks.add(block)) {
+    if (excessBlocks.add(storedBlock)) {
-          + " excessReplicateMap", dn, block);
+          + " excessReplicateMap", dn, storedBlock);
-  public void removeStoredBlock(Block block, DatanodeDescriptor node) {
-    blockLog.debug("BLOCK* removeStoredBlock: {} from {}", block, node);
+  public void removeStoredBlock(BlockInfo storedBlock, DatanodeDescriptor node) {
+    blockLog.debug("BLOCK* removeStoredBlock: {} from {}", storedBlock, node);
-      BlockInfo storedBlock = getStoredBlock(block);
-            " removed from node {}", block, node);
+            " removed from node {}", storedBlock, node);
-      BlockCollection bc = blocksMap.getBlockCollection(block);
+      BlockCollection bc = storedBlock.getBlockCollection();
-      LightWeightLinkedSet<Block> excessBlocks = excessReplicateMap.get(node
-          .getDatanodeUuid());
+      LightWeightLinkedSet<BlockInfo> excessBlocks = excessReplicateMap.get(
+          node.getDatanodeUuid());
-        if (excessBlocks.remove(block)) {
+        if (excessBlocks.remove(storedBlock)) {
-              "excessBlocks", block);
+              "excessBlocks", storedBlock);
-      corruptReplicas.removeFromCorruptReplicasMap(block, node);
+      corruptReplicas.removeFromCorruptReplicasMap(storedBlock, node);
-        removeStoredBlock(storageInfo, rdbi.getBlock(), node);
+        removeStoredBlock(storageInfo, getStoredBlock(rdbi.getBlock()), node);
-        LightWeightLinkedSet<Block> blocksExcess = excessReplicateMap.get(node
-            .getDatanodeUuid());
+        LightWeightLinkedSet<BlockInfo> blocksExcess = excessReplicateMap.get(
+            node.getDatanodeUuid());
-      BlockCollection bc = blocksMap.getBlockCollection(block);
-      short expectedReplication = bc.getPreferredBlockReplication();
+      int expectedReplication = this.getReplication(block);
-        processOverReplicatedBlock(block, expectedReplication, null, null);
+        processOverReplicatedBlock(block, (short) expectedReplication, null,
+            null);
-  boolean blockHasEnoughRacks(Block b) {
+  // TODO: update the enough rack logic for striped blocks
+  boolean blockHasEnoughRacks(BlockInfo storedBlock, int expectedStorageNum) {
-    Collection<DatanodeDescriptor> corruptNodes = 
-                                  corruptReplicas.getNodes(b);
-    int numExpectedReplicas = getReplication(b);
+    Collection<DatanodeDescriptor> corruptNodes =
+        corruptReplicas.getNodes(storedBlock);
-    for(DatanodeStorageInfo storage : blocksMap.getStorages(b)) {
+    for(DatanodeStorageInfo storage : blocksMap.getStorages(storedBlock)) {
-          if (numExpectedReplicas == 1 ||
-              (numExpectedReplicas > 1 &&
+          if (expectedStorageNum == 1 || (expectedStorageNum > 1 &&
-  boolean isNeededReplication(Block b, int expected, int current) {
-    return current < expected || !blockHasEnoughRacks(b);
+  boolean isNeededReplication(BlockInfo storedBlock, int expected, int current) {
+    return current < expected || !blockHasEnoughRacks(storedBlock, expected);
-   * coding. Recovery is done by transferring data from {@link srcNodes} to
-   * {@link targets}
+   * coding. Recovery is done by transferring data from srcNodes to targets

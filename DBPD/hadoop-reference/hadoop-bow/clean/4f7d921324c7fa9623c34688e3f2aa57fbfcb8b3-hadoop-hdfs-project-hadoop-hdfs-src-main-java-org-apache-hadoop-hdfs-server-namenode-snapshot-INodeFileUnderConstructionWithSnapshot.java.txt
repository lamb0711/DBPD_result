HDFS-4446. Support file snapshots with diff lists.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1443825 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+
+import org.apache.hadoop.fs.permission.FsPermission;
+import org.apache.hadoop.hdfs.server.namenode.snapshot.INodeFileWithSnapshot.FileDiffList;
+  /**
+   * The difference of an {@link INodeFileUnderConstruction} between two snapshots.
+   */
+  static class FileUcDiff extends FileDiff {
+    private FileUcDiff(Snapshot snapshot, INodeFile file) {
+      super(snapshot, file);
+    }
+
+    @Override
+    INodeFileUnderConstruction createSnapshotCopyOfCurrentINode(INodeFile file) {
+      final INodeFileUnderConstruction uc = (INodeFileUnderConstruction)file;
+      final INodeFileUnderConstruction copy = new INodeFileUnderConstruction(
+          uc, uc.getClientName(), uc.getClientMachine(), uc.getClientNode());
+      copy.setBlocks(null);
+      return copy;
+    }
+  }
+
+  /**
+   * A list of file diffs.
+   */
+  static class FileUcDiffList extends FileDiffList {
+    private FileUcDiffList(INodeFile currentINode, final List<FileDiff> diffs) {
+      super(currentINode, diffs);
+    }
+
+    @Override
+    FileDiff addSnapshotDiff(Snapshot snapshot) {
+      return addLast(new FileUcDiff(snapshot, getCurrentINode()));
+    }
+  }
+
+  private final FileUcDiffList diffs;
-      final DatanodeDescriptor clientNode) {
+      final DatanodeDescriptor clientNode,
+      final FileDiffList diffs) {
-    next = this;
+    this.diffs = new FileUcDiffList(this, diffs == null? null: diffs.asList());
+    setNext(this);
-    this(f, f.getClientName(), f.getClientMachine(), f.getClientNode());
+    this(f, f.getClientName(), f.getClientMachine(), f.getClientNode(), null);
-    final INodeFileWithSnapshot f = new INodeFileWithSnapshot(this);
+    final INodeFileWithSnapshot f = new INodeFileWithSnapshot(this, diffs);
-  public Pair<? extends INodeFileUnderConstruction,
-      INodeFileUnderConstructionSnapshot> createSnapshotCopy() {
-    return new Pair<INodeFileUnderConstructionWithSnapshot,
-        INodeFileUnderConstructionSnapshot>(
-            this, new INodeFileUnderConstructionSnapshot(this));
+  public boolean isCurrentFileDeleted() {
+    return getParent() == null;
+  }
+
+  @Override
+  public boolean isEverythingDeleted() {
+    return isCurrentFileDeleted() && diffs.asList().isEmpty();
+  }
+
+  @Override
+  public INodeFileUnderConstructionWithSnapshot recordModification(
+      final Snapshot latest) {
+    // if this object is NOT the latest snapshot copy, this object is created
+    // after the latest snapshot, then do NOT record modification.
+    if (this == getParent().getChild(getLocalNameBytes(), latest)) {
+      diffs.saveSelf2Snapshot(latest, null);
+    }
+    return this;
+  public short getFileReplication(Snapshot snapshot) {
+    final INodeFile inode = diffs.getSnapshotINode(snapshot);
+    return inode != null? inode.getFileReplication()
+        : super.getFileReplication(null);
+  }
+
+  @Override
+  public short getMaxFileReplication() {
+    final short max = isCurrentFileDeleted()? 0: getFileReplication();
+    return Util.getMaxFileReplication(max, diffs);
+  }
+
+  @Override
+  public long computeFileSize(boolean includesBlockInfoUnderConstruction,
+      Snapshot snapshot) {
+    final FileDiff diff = diffs.getDiff(snapshot);
+    return diff != null? diff.fileSize
+        : super.computeFileSize(includesBlockInfoUnderConstruction, null);
+  }
+
+  @Override
+  public long computeMaxFileSize() {
+    if (isCurrentFileDeleted()) {
+      final FileDiff last = diffs.getLast();
+      return last == null? 0: last.fileSize;
+    } else { 
+      return super.computeFileSize(true, null);
+    }
+  }
+
+  @Override
-    if (snapshot != null) {
-      return 0;
-    }
-    if (next == null || next == this) {
-      // this is the only remaining inode.
-      return super.destroySubtreeAndCollectBlocks(null, collectedBlocks);
+    if (snapshot == null) {
+      clearReferences();
-      return Util.collectSubtreeBlocksAndClear(this, collectedBlocks);
+      if (diffs.deleteSnapshotDiff(snapshot, collectedBlocks) == null) {
+        //snapshot diff not found and nothing is deleted.
+        return 0;
+      }
+
+    Util.collectBlocksAndClear(this, collectedBlocks);
+    return 1;
+  }
+
+  @Override
+  public String getUserName(Snapshot snapshot) {
+    final INodeFile inode = diffs.getSnapshotINode(snapshot);
+    return inode != null? inode.getUserName(): super.getUserName(null);
+  }
+
+  @Override
+  public String getGroupName(Snapshot snapshot) {
+    final INodeFile inode = diffs.getSnapshotINode(snapshot);
+    return inode != null? inode.getGroupName(): super.getGroupName(null);
+  }
+
+  @Override
+  public FsPermission getFsPermission(Snapshot snapshot) {
+    final INodeFile inode = diffs.getSnapshotINode(snapshot);
+    return inode != null? inode.getFsPermission(): super.getFsPermission(null);
+  }
+
+  @Override
+  public long getAccessTime(Snapshot snapshot) {
+    final INodeFile inode = diffs.getSnapshotINode(snapshot);
+    return inode != null? inode.getAccessTime(): super.getAccessTime(null);
+  }
+
+  @Override
+  public long getModificationTime(Snapshot snapshot) {
+    final INodeFile inode = diffs.getSnapshotINode(snapshot);
+    return inode != null? inode.getModificationTime()
+        : super.getModificationTime(null);
+  }
+
+  @Override
+  public String toDetailString() {
+    return super.toDetailString()
+        + (isCurrentFileDeleted()? " (DELETED), ": ", ") + diffs;

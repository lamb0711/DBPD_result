HDFS-4877. Snapshot: fix the scenario where a directory is renamed under its prior descendant. Contributed by Jing Zhao.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490421 13f79535-47bb-0310-9956-ffa450edef68

-      BlocksMapUpdateInfo collectedBlocks, final List<INode> removedINodes)
-      throws QuotaExceededException {
+      BlocksMapUpdateInfo collectedBlocks, final List<INode> removedINodes,
+      final boolean countDiffChange) throws QuotaExceededException {
-        removedINodes);
+        removedINodes, countDiffChange);
-    
-    @Override
-    public final void addSpaceConsumed(long nsDelta, long dsDelta,
-        boolean verify, int snapshotId) throws QuotaExceededException {
-      INodeReference parentRef = getParentReference();
-      if (parentRef != null) {
-        parentRef.addSpaceConsumed(nsDelta, dsDelta, verify, snapshotId);
-      }
-      addSpaceConsumedToRenameSrc(nsDelta, dsDelta, verify, snapshotId);
-    }
-    
-    @Override
-    public final void addSpaceConsumedToRenameSrc(long nsDelta, long dsDelta,
-        boolean verify, int snapshotId) throws QuotaExceededException {
-      if (snapshotId != Snapshot.INVALID_ID) {
-        for (INodeReference.WithName withName : withNameList) {
-          if (withName.getLastSnapshotId() >= snapshotId) {
-            withName.addSpaceConsumed(nsDelta, dsDelta, verify, snapshotId);
-            break;
-          }
-        }
-      }
-    }
-      // we cannot use cache for the referred node since its cached quota may
-      // have already been updated by changes in the current tree
-      return referred.computeQuotaUsage(counts, false, this.lastSnapshotId);
+      // We will continue the quota usage computation using the same snapshot id
+      // as time line (if the given snapshot id is valid). Also, we cannot use 
+      // cache for the referred node since its cached quota may have already 
+      // been updated by changes in the current tree.
+      int id = lastSnapshotId > Snapshot.INVALID_ID ? 
+          lastSnapshotId : this.lastSnapshotId;
+      return referred.computeQuotaUsage(counts, false, id);
-        final List<INode> removedINodes) throws QuotaExceededException {
+        final List<INode> removedINodes, final boolean countDiffChange)
+        throws QuotaExceededException {
-          collectedBlocks, removedINodes);
+          collectedBlocks, removedINodes, false);
-            -counts.get(Quota.DISKSPACE), true, Snapshot.INVALID_ID);
+            -counts.get(Quota.DISKSPACE), true);
+      }
+      
+      if (snapshot.getId() < lastSnapshotId) {
+        // for a WithName node, when we compute its quota usage, we only count
+        // in all the nodes existing at the time of the corresponding rename op.
+        // Thus if we are deleting a snapshot before/at the snapshot associated 
+        // with lastSnapshotId, we do not need to update the quota upwards.
+        counts = Quota.Counts.newInstance();
-            // 4. delete snapshot s2
+            // 4. rename foo2 again
+            // 5. delete snapshot s2
-                collectedBlocks, removedINodes);
+                collectedBlocks, removedINodes, false);
-                  -counts.get(Quota.DISKSPACE), true, Snapshot.INVALID_ID);
+                  -counts.get(Quota.DISKSPACE), true);
-        BlocksMapUpdateInfo collectedBlocks, List<INode> removedINodes)
-        throws QuotaExceededException {
+        BlocksMapUpdateInfo collectedBlocks, List<INode> removedINodes,
+        final boolean countDiffChange) throws QuotaExceededException {
-            collectedBlocks, removedINodes);
+            collectedBlocks, removedINodes, countDiffChange);
+              // when calling cleanSubtree of the referred node, since we 
+              // compute quota usage updates before calling this destroy 
+              // function, we use true for countDiffChange
-                  removedINodes);
+                  removedINodes, true);

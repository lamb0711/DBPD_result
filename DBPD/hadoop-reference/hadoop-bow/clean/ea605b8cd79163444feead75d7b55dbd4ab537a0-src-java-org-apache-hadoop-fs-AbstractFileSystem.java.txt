    HADOOP-6421 Adds Symbolic links to FileContext, AbstractFileSystem.
    It also adds a limited implementation for the local file system
     (RawLocalFs) that allows local symlinks. (Eli Collins via Sanjay Radia)


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@910706 13f79535-47bb-0310-9956-ffa450edef68

-   * Prohibits names which contain a ".", "..". ":" or "/" 
+   * Prohibits names which contain a ".", "..", ":" or "/" 
-  protected abstract FsServerDefaults getServerDefaults() throws IOException;
+  protected abstract FsServerDefaults getServerDefaults() throws IOException; 
-    throws IOException {
+    throws IOException, UnresolvedLinkException {
-      int bytesPerChecksum, boolean createParent) throws IOException;
+      int bytesPerChecksum, boolean createParent) 
+      throws IOException, UnresolvedLinkException;
-    throws IOException;
+    throws IOException, UnresolvedLinkException;
-    throws IOException;
+    throws IOException, UnresolvedLinkException;
-  protected FSDataInputStream open(final Path f) throws IOException {
+  protected FSDataInputStream open(final Path f) 
+    throws IOException, UnresolvedLinkException {
+   * @throws UnresolvedLinkException 
-    throws IOException;
+    throws IOException, UnresolvedLinkException;
-    final short replication) throws IOException;
+    final short replication) throws IOException, UnresolvedLinkException;
-    final Options.Rename... options) throws IOException {
+    final Options.Rename... options) 
+    throws IOException, UnresolvedLinkException {
-    throws IOException;
+    throws IOException, UnresolvedLinkException;
-    boolean overwrite) throws IOException {
+    boolean overwrite) throws IOException, UnresolvedLinkException {
-    final FileStatus srcStatus = getFileStatus(src);
+    final FileStatus srcStatus = getFileLinkStatus(src);
-      dstStatus = getFileStatus(dst);
+      dstStatus = getFileLinkStatus(dst);
-      final FileStatus parentStatus = getFileStatus(parent);
+      final FileStatus parentStatus = getFileLinkStatus(parent);
-      if (!parentStatus.isDir()) {
+      if (!parentStatus.isDir() && !parentStatus.isSymlink()) {
+   * Returns true if the file system supports symlinks, false otherwise.
+   */
+  protected boolean supportsSymlinks() {
+    return false;
+  }
+  
+  /**
+   * The specification of this method matches that of  
+   * {@link FileContext#createSymlink(Path, Path, boolean)};
+   */
+  protected void createSymlink(final Path target, final Path link,
+      final boolean createParent) throws IOException, UnresolvedLinkException {
+    throw new IOException("File system does not support symlinks");    
+  }
+
+  /**
+   * The specification of this method matches that of  
+   * {@link FileContext#getLinkTarget(Path)};
+   */
+  protected Path getLinkTarget(final Path f) throws IOException {
+    /* We should never get here. Any file system that threw an
+     * UnresolvedLinkException, causing this function to be called,
+     * needs to override this method.
+     */
+    throw new AssertionError();
+  }
+    
+  /**
-      final FsPermission permission) throws IOException;
+      final FsPermission permission) 
+      throws IOException, UnresolvedLinkException;
-      final String groupname) throws IOException;
+      final String groupname) throws IOException, UnresolvedLinkException;
-    final long atime) throws IOException;
+    final long atime) throws IOException, UnresolvedLinkException;
-    throws IOException;
+    throws IOException, UnresolvedLinkException;
-   * {@link FileContext#setVerifyChecksum(boolean, Path)} except that Path f
-   * must be for this filesystem.
+   * {@link FileContext#getFileStatus(Path)} 
+   * except that an UnresolvedLinkException may be thrown if a symlink is 
+   * encountered in the path.
-  protected abstract FileStatus getFileStatus(final Path f) throws IOException;
+  protected abstract FileStatus getFileStatus(final Path f) 
+    throws IOException, UnresolvedLinkException;
+
+  /**
+   * The specification of this method matches that of
+   * {@link FileContext#getFileLinkStatus(Path)}
+   * except that an UnresolvedLinkException may be thrown if a symlink is  
+   * encountered in the path leading up to the final path component.
+   * If the file system does not support symlinks then the behavior is
+   * equivalent to {@link AbstractFileSystem#getFileStatus(Path)}.
+   */
+  protected FileStatus getFileLinkStatus(final Path f)
+    throws IOException, UnresolvedLinkException {
+    return getFileStatus(f);
+  }
-    final long start, final long len) throws IOException;
+    final long start, final long len) 
+    throws IOException, UnresolvedLinkException;
-  protected FsStatus getFsStatus(final Path f) throws IOException {
+  protected FsStatus getFsStatus(final Path f) 
+    throws IOException, UnresolvedLinkException {
-   * {@link FileContext#getFsStatus(Path)} except that Path f must be for this
-   * filesystem.
+   * {@link FileContext#getFsStatus(Path)}.
-  protected abstract FileStatus[] listStatus(final Path f) throws IOException;
+  protected abstract FileStatus[] listStatus(final Path f) 
+    throws IOException, UnresolvedLinkException;

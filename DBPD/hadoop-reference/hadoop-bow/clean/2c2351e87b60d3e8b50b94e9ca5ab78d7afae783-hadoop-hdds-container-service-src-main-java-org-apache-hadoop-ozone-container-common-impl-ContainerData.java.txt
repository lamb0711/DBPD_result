HDDS-182:CleanUp Reimplemented classes. Contributed by Hansiha Koneru

+import com.google.common.base.Preconditions;
+import java.util.concurrent.atomic.AtomicInteger;
-  private final long containerId;
+  private final long containerID;
+
+  // Path to container root dir.
+  private String containerPath;
+  /**
+   * Number of pending deletion blocks in container.
+   */
+  private final AtomicInteger numPendingDeletionBlocks;
-    this.containerType = type;
-    this.containerId = containerId;
-    this.layOutVersion = ChunkLayOutVersion.getLatestVersion().getVersion();
-    this.metadata = new TreeMap<>();
-    this.state = ContainerLifeCycleState.OPEN;
-    this.readCount = new AtomicLong(0L);
-    this.readBytes =  new AtomicLong(0L);
-    this.writeCount =  new AtomicLong(0L);
-    this.writeBytes =  new AtomicLong(0L);
-    this.bytesUsed = new AtomicLong(0L);
-    this.keyCount = new AtomicLong(0L);
-    this.maxSizeGB = size;
+    this(type, containerId,
+        ChunkLayOutVersion.getLatestVersion().getVersion(), size);
-  public ContainerData(ContainerType type, long containerId, int
-      layOutVersion, int size) {
+  public ContainerData(ContainerType type, long containerId,
+    int layOutVersion, int size) {
+    Preconditions.checkNotNull(type);
+
-    this.containerId = containerId;
+    this.containerID = containerId;
+    this.numPendingDeletionBlocks = new AtomicInteger(0);
-   * Returns the containerId.
+   * Returns the containerID.
-  public long getContainerId() {
-    return containerId;
+  public long getContainerID() {
+    return containerID;
+  }
+
+  /**
+   * Returns the path to base dir of the container.
+   * @return Path to base dir.
+   */
+  public String getContainerPath() {
+    return containerPath;
+  }
+
+  /**
+   * Set the base dir path of the container.
+   * @param baseDir path to base dir
+   */
+  public void setContainerPath(String baseDir) {
+    this.containerPath = baseDir;
-      if (this.metadata.containsKey(key)) {
-        throw new IOException("This key already exists. Key " + key);
-      }
-
+  /**
+   * Returns container metadata path.
+   */
+  public String getMetadataPath() {
+    return null;
+  }
+
+  /**
+   * Returns container data path.
+   */
+  public String getDataPath() {
+    return null;
+  }
+
+  /**
+   * Increase the count of pending deletion blocks.
+   *
+   * @param numBlocks increment number
+   */
+  public void incrPendingDeletionBlocks(int numBlocks) {
+    this.numPendingDeletionBlocks.addAndGet(numBlocks);
+  }
+
+  /**
+   * Decrease the count of pending deletion blocks.
+   *
+   * @param numBlocks decrement number
+   */
+  public void decrPendingDeletionBlocks(int numBlocks) {
+    this.numPendingDeletionBlocks.addAndGet(-1 * numBlocks);
+  }
+
+  /**
+   * Get the number of pending deletion blocks.
+   */
+  public int getNumPendingDeletionBlocks() {
+    return this.numPendingDeletionBlocks.get();
+  }
+
+  /**
+   * Returns a ProtoBuf Message from ContainerData.
+   *
+   * @return Protocol Buffer Message
+   */
+  public ContainerProtos.ContainerData getProtoBufMessage() {
+    ContainerProtos.ContainerData.Builder builder =
+        ContainerProtos.ContainerData.newBuilder();
+
+    builder.setContainerID(this.getContainerID());
+
+    if (this.containerPath != null) {
+      builder.setContainerPath(this.containerPath);
+    }
+
+    builder.setState(this.getState());
+
+    for (Map.Entry<String, String> entry : metadata.entrySet()) {
+      ContainerProtos.KeyValue.Builder keyValBuilder =
+          ContainerProtos.KeyValue.newBuilder();
+      builder.addMetadata(keyValBuilder.setKey(entry.getKey())
+          .setValue(entry.getValue()).build());
+    }
+
+    if (this.getBytesUsed() >= 0) {
+      builder.setBytesUsed(this.getBytesUsed());
+    }
+
+    builder.setContainerType(containerType);
+
+    return builder.build();
+  }

Merge remote-tracking branch 'apache/trunk' into HDFS-7285

+import org.apache.hadoop.yarn.api.protocolrecords.UpdateApplicationPriorityRequest;
+import org.apache.hadoop.yarn.api.protocolrecords.UpdateApplicationPriorityResponse;
+import org.apache.hadoop.yarn.api.records.Priority;
+    if (applicationId == null) {
+      throw new ApplicationNotFoundException("Invalid application id: null");
+    }
+
+  @Override
+  public UpdateApplicationPriorityResponse updateApplicationPriority(
+      UpdateApplicationPriorityRequest request) throws YarnException,
+      IOException {
+
+    ApplicationId applicationId = request.getApplicationId();
+    Priority newAppPriority = request.getApplicationPriority();
+    UserGroupInformation callerUGI;
+    try {
+      callerUGI = UserGroupInformation.getCurrentUser();
+    } catch (IOException ie) {
+      LOG.info("Error getting UGI ", ie);
+      RMAuditLogger.logFailure("UNKNOWN", AuditConstants.UPDATE_APP_PRIORITY,
+          "UNKNOWN", "ClientRMService", "Error getting UGI", applicationId);
+      throw RPCUtil.getRemoteException(ie);
+    }
+
+    RMApp application = this.rmContext.getRMApps().get(applicationId);
+    if (application == null) {
+      RMAuditLogger.logFailure(callerUGI.getUserName(),
+          AuditConstants.UPDATE_APP_PRIORITY, "UNKNOWN", "ClientRMService",
+          "Trying to update priority of an absent application", applicationId);
+      throw new ApplicationNotFoundException(
+          "Trying to update priority o an absent application " + applicationId);
+    }
+
+    if (!checkAccess(callerUGI, application.getUser(),
+        ApplicationAccessType.MODIFY_APP, application)) {
+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),
+          AuditConstants.UPDATE_APP_PRIORITY,
+          "User doesn't have permissions to "
+              + ApplicationAccessType.MODIFY_APP.toString(), "ClientRMService",
+          AuditConstants.UNAUTHORIZED_USER, applicationId);
+      throw RPCUtil.getRemoteException(new AccessControlException("User "
+          + callerUGI.getShortUserName() + " cannot perform operation "
+          + ApplicationAccessType.MODIFY_APP.name() + " on " + applicationId));
+    }
+
+    // Update priority only when app is tracked by the scheduler
+    if (!EnumSet.of(RMAppState.ACCEPTED, RMAppState.RUNNING).contains(
+        application.getState())) {
+      String msg =
+          "Application in " + application.getState()
+              + " state cannot be update priority.";
+      RMAuditLogger
+          .logFailure(callerUGI.getShortUserName(),
+              AuditConstants.UPDATE_APP_PRIORITY, "UNKNOWN", "ClientRMService",
+              msg);
+      throw new YarnException(msg);
+    }
+
+    try {
+      rmContext.getScheduler().updateApplicationPriority(newAppPriority,
+          applicationId);
+    } catch (YarnException ex) {
+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),
+          AuditConstants.UPDATE_APP_PRIORITY, "UNKNOWN", "ClientRMService",
+          ex.getMessage());
+      throw ex;
+    }
+
+    RMAuditLogger.logSuccess(callerUGI.getShortUserName(),
+        AuditConstants.UPDATE_APP_PRIORITY, "ClientRMService", applicationId);
+    UpdateApplicationPriorityResponse response =
+        recordFactory
+            .newRecordInstance(UpdateApplicationPriorityResponse.class);
+    return response;
+  }
+

HDFS-4317. Change INode and its subclasses to support HDFS-4103.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1422748 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.INodeDirectoryWithQuota;
+
+import com.google.common.base.Preconditions;
-public class INodeDirectoryWithSnapshot extends INodeDirectory {
+public class INodeDirectoryWithSnapshot extends INodeDirectoryWithQuota {
+    private static void remove(final List<INode> inodes, final int i,
+        final INode expected) {
+      final INode removed = inodes.remove(-i - 1);
+      Preconditions.checkState(removed == expected,
+          "removed != expected=%s, removed=%s.", expected, removed);
+    }
+
-    /** Create an inode in current state. */
-    void create(final INode inode) {
+    /**
+     * Create an inode in current state.
+     * @return the c-list insertion point for undo.
+     */
+    int create(final INode inode) {
+      return c;
-    /** Delete an inode from current state. */
-    void delete(final INode inode) {
+    void undoCreate(final INode inode, final int insertionPoint) {
+      remove(created, insertionPoint, inode);
+    }
+
+    /**
+     * Delete an inode from current state.
+     * @return a triple for undo.
+     */
+    Triple<Integer, INode, Integer> delete(final INode inode) {
+      INode previous = null;
+      Integer d = null;
-        created.remove(c);
+        previous = created.remove(c);
-        final int d = search(deleted, inode);
+        d = search(deleted, inode);
+      return new Triple<Integer, INode, Integer>(c, previous, d);
+    }
+    
+    void undoDelete(final INode inode,
+        final Triple<Integer, INode, Integer> undoInfo) {
+      final int c = undoInfo.left;
+      if (c >= 0) {
+        created.add(c, undoInfo.middle);
+      } else {
+        remove(deleted, undoInfo.right, inode);
+      }
-    /** Modify an inode in current state. */
-    void modify(final INode oldinode, final INode newinode) {
+    /**
+     * Modify an inode in current state.
+     * @return a triple for undo.
+     */
+    Triple<Integer, INode, Integer> modify(final INode oldinode, final INode newinode) {
+      INode previous = null;
+      Integer d = null;
-        created.set(c, newinode);
+        previous = created.set(c, newinode);
-        final int d = search(deleted, oldinode);
+        d = search(deleted, oldinode);
+      return new Triple<Integer, INode, Integer>(c, previous, d);
-    /**
-     * Given an inode in current state, find the corresponding inode in previous
-     * snapshot. The inodes in current state and previous snapshot can possibly
-     * be the same.
-     *
-     * @param inodeInCurrent The inode, possibly null, in current state.
-     * @return null if the inode is not found in previous snapshot;
-     *         otherwise, return the corresponding inode in previous snapshot.
-     */
-    INode accessPrevious(byte[] name, INode inodeInCurrent) {
-      return accessPrevious(name, inodeInCurrent, created, deleted);
-    }
-
-    private static INode accessPrevious(byte[] name, INode inodeInCurrent,
-        final List<INode> clist, final List<INode> dlist) {
-      final int d = search(dlist, name);
-      if (d >= 0) {
-        // the inode was in previous and was once deleted in current.
-        return dlist.get(d);
+    void undoModify(final INode oldinode, final INode newinode,
+        final Triple<Integer, INode, Integer> undoInfo) {
+      final int c = undoInfo.left;
+      if (c >= 0) {
+        created.set(c, undoInfo.middle);
-        final int c = search(clist, name);
-        // When c >= 0, the inode in current is a newly created inode.
-        return c >= 0? null: inodeInCurrent;
+        final int d = undoInfo.right;
+        if (d < 0) {
+          remove(created, c, newinode);
+          remove(deleted, d, oldinode);
+        }
-     * Given an inode in previous snapshot, find the corresponding inode in
-     * current state. The inodes in current state and previous snapshot can
-     * possibly be the same.
-     *
-     * @param inodeInPrevious The inode, possibly null, in previous snapshot.
-     * @return null if the inode is not found in current state;
-     *         otherwise, return the corresponding inode in current state.
+     * Find an inode in the previous snapshot.
+     * @return null if the inode cannot be determined in the previous snapshot
+     *         since no change is recorded and it should be determined in the
+     *         current snapshot; otherwise, return an array with size one
+     *         containing the inode in the previous snapshot. Note that the
+     *         inode can possibly be null which means that the inode is not
+     *         found in the previous snapshot.
-    INode accessCurrent(byte[] name, INode inodeInPrevious) {
-      return accessPrevious(name, inodeInPrevious, deleted, created);
+    INode[] accessPrevious(byte[] name) {
+      return accessPrevious(name, created, deleted);
+    }
+
+    private static INode[] accessPrevious(byte[] name,
+        final List<INode> clist, final List<INode> dlist) {
+      final int d = search(dlist, name);
+      if (d >= 0) {
+        // the inode was in previous and was once deleted in current.
+        return new INode[]{dlist.get(d)};
+      } else {
+        final int c = search(clist, name);
+        // When c >= 0, the inode in current is a newly created inode.
+        return c >= 0? new INode[]{null}: null;
+      }
+    }
+
+    /**
+     * Find an inode in the current snapshot.
+     * @return null if the inode cannot be determined in the current snapshot
+     *         since no change is recorded and it should be determined in the
+     *         previous snapshot; otherwise, return an array with size one
+     *         containing the inode in the current snapshot. Note that the
+     *         inode can possibly be null which means that the inode is not
+     *         found in the current snapshot.
+     */
+    INode[] accessCurrent(byte[] name) {
+      return accessPrevious(name, deleted, created);
-      if (inodes == null) {
-        return null;
-      } else if (inodes.isEmpty()) {
-        return "[]";
+      if (inodes == null || inodes.isEmpty()) {
+        return "<empty>";
-          .append(inodes.get(0).getLocalName());
+          .append(inodes.get(0));
-        b.append(", ").append(inodes.get(i).getLocalName());
+        b.append(", ").append(inodes.get(i));
-          + ":\n  created=" + toString(created)
-          + "\n  deleted=" + toString(deleted);
+          + "{created=" + toString(created)
+          + ", deleted=" + toString(deleted) + "}";
-  INodeDirectoryWithSnapshot(String name, INodeDirectory dir) {
-    super(name, dir.getPermissionStatus());
-    parent = dir;
+  public INodeDirectoryWithSnapshot(INodeDirectory that, boolean adopt) {
+    super(that, adopt, that.getNsQuota(), that.getDsQuota());

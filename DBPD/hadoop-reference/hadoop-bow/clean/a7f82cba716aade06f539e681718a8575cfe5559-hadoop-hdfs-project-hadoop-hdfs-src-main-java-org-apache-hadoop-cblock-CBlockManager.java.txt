HDFS-11154. Block Storage: store server state to persistent storage. Contributed by Chen Liang

+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.cblock.util.KeyUtil;
+import org.apache.hadoop.utils.LevelDBStore;
+import org.iq80.leveldb.DBIterator;
+import java.io.File;
+import java.nio.charset.Charset;
+import java.util.Map;
+import static org.apache.hadoop.cblock.CBlockConfigKeys.DFS_CBLOCK_SERVICE_LEVELDB_PATH_DEFAULT;
+import static org.apache.hadoop.cblock.CBlockConfigKeys.DFS_CBLOCK_SERVICE_LEVELDB_PATH_KEY;
+  private final LevelDBStore levelDBStore;
+  private final String dbPath;
+
+  private Charset encoding = Charset.forName("UTF-8");
+
+    dbPath = conf.getTrimmed(DFS_CBLOCK_SERVICE_LEVELDB_PATH_KEY,
+        DFS_CBLOCK_SERVICE_LEVELDB_PATH_DEFAULT);
+    levelDBStore = new LevelDBStore(new File(dbPath), true);
+    LOG.info("Try to load exising volume information");
+    readFromPersistentStore();
+
-  public MountVolumeResponse mountVolume(
+  public synchronized MountVolumeResponse mountVolume(
-  public void createVolume(String userName, String volumeName,
+  public synchronized void createVolume(String userName, String volumeName,
+    String volumeKey = KeyUtil.getVolumeKey(userName, volumeName);
+    writeToPersistentStore(volumeKey.getBytes(encoding),
+        volume.toProtobuf().toByteArray());
-  public void deleteVolume(String userName,
+  public synchronized void deleteVolume(String userName,
-    LOG.info("Delete volume received: volume:" + volumeName
-        + " force?:" + force);
+    LOG.info("Delete volume received: volume: {} {} ", volumeName, force);
+    // being here means volume is successfully deleted now
+    String volumeKey = KeyUtil.getVolumeKey(userName, volumeName);
+    removeFromPersistentStore(volumeKey.getBytes(encoding));
+  }
+
+  // No need to synchronize on the following three methods, since write and
+  // remove's caller are synchronized. read's caller is the constructor and
+  // no other method call can happen at that time.
+  @VisibleForTesting
+  public void writeToPersistentStore(byte[] key, byte[] value) {
+    levelDBStore.put(key, value);
+  }
+
+  @VisibleForTesting
+  public void removeFromPersistentStore(byte[] key) {
+    levelDBStore.delete(key);
+  }
+
+  public void readFromPersistentStore() {
+    DBIterator iter = levelDBStore.getIterator();
+    iter.seekToFirst();
+    while (iter.hasNext()) {
+      Map.Entry<byte[], byte[]> entry = iter.next();
+      String volumeKey = new String(entry.getKey(), encoding);
+      try {
+        VolumeDescriptor volumeDescriptor =
+            VolumeDescriptor.fromProtobuf(entry.getValue());
+        storageManager.addVolume(volumeDescriptor);
+      } catch (IOException e) {
+        LOG.error("Loading volume " + volumeKey + " error " + e);
+      }
+    }
-  public VolumeInfo infoVolume(String userName, String volumeName
+  public synchronized VolumeInfo infoVolume(String userName, String volumeName
+  @VisibleForTesting
+  public synchronized List<VolumeDescriptor> getAllVolumes() {
+    return storageManager.getAllVolume(null);
+  }
+
+  public synchronized void close() {
+    try {
+      levelDBStore.close();
+    } catch (IOException e) {
+      LOG.error("Error when closing levelDB " + e);
+    }
+  }
+
+  public synchronized void clean() {
+    try {
+      levelDBStore.close();
+      levelDBStore.destroy();
+    } catch (IOException e) {
+      LOG.error("Error when deleting levelDB " + e);
+    }
+  }
+
-  public List<VolumeInfo> listVolume(String userName) throws IOException {
+  public synchronized List<VolumeInfo> listVolume(String userName)
+      throws IOException {

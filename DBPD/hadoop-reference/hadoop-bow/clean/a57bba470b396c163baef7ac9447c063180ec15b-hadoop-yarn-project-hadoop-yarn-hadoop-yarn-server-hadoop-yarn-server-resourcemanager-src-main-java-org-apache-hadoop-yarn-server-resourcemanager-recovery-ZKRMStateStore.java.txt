Merge branch 'trunk' into HADOOP-12756

-import org.apache.hadoop.yarn.util.ConverterUtils;
+import java.io.IOException;
-import java.security.SecureRandom;
-
-  public static final Log LOG = LogFactory.getLog(ZKRMStateStore.class);
-  private final SecureRandom random = new SecureRandom();
-
-  protected static final String ROOT_ZNODE_NAME = "ZKRMStateRoot";
-  protected static final Version CURRENT_VERSION_INFO = Version
-      .newInstance(1, 3);
+  private static final Log LOG = LogFactory.getLog(ZKRMStateStore.class);
+  protected static final String ROOT_ZNODE_NAME = "ZKRMStateRoot";
+  protected static final Version CURRENT_VERSION_INFO =
+      Version.newInstance(1, 3);
-  /** Znode paths */
+  /* Znode paths */
+
-  /** Fencing related variables */
+  /* Fencing related variables */
-  /** ACL and auth info */
+  /* ACL and auth info */
-  public static final int CREATE_DELETE_PERMS =
+
+  private static final int CREATE_DELETE_PERMS =
+
-   * Given the {@link Configuration} and {@link ACL}s used (zkAcl) for
+   * Given the {@link Configuration} and {@link ACL}s used (sourceACLs) for
-   * In the constructed {@link ACL}, all the users allowed by zkAcl are given
-   * rwa access, while the current RM has exclude create-delete access.
+   * In the constructed {@link ACL}, all the users allowed by sourceACLs are
+   * given read-write-admin access, while the current RM has exclusive
+   * create-delete access.
-   * To be called only when HA is enabled and the configuration doesn't set ACL
-   * for the root node.
+   * To be called only when HA is enabled and the configuration doesn't set an
+   * ACL for the root node.
+   * @param conf the configuration
+   * @param sourceACLs the source ACLs
+   * @return ACLs for the store's root node
+   * @throws java.security.NoSuchAlgorithmException thrown if the digest
+   * algorithm used by Zookeeper cannot be found
-  protected List<ACL> constructZkRootNodeACL(
-      Configuration conf, List<ACL> sourceACLs) throws NoSuchAlgorithmException {
-    List<ACL> zkRootNodeAcl = new ArrayList<>();
+  protected List<ACL> constructZkRootNodeACL(Configuration conf,
+      List<ACL> sourceACLs) throws NoSuchAlgorithmException {
+    List<ACL> zkRootNodeAclList = new ArrayList<>();
+
-      zkRootNodeAcl.add(new ACL(
+      zkRootNodeAclList.add(new ACL(
-        DigestAuthenticationProvider.generateDigest(
-            zkRootNodeUsername + ":" + resourceManager.getZkRootNodePassword()));
-    zkRootNodeAcl.add(new ACL(CREATE_DELETE_PERMS, rmId));
-    return zkRootNodeAcl;
+        DigestAuthenticationProvider.generateDigest(zkRootNodeUsername + ":"
+            + resourceManager.getZkRootNodePassword()));
+    zkRootNodeAclList.add(new ACL(CREATE_DELETE_PERMS, rmId));
+
+    return zkRootNodeAclList;
-  public synchronized void initInternal(Configuration conf) throws Exception {
-
+  public synchronized void initInternal(Configuration conf)
+      throws IOException, NoSuchAlgorithmException {
+
+
+
-          LOG.error("Invalid format for " +
-              YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);
+          LOG.error("Invalid format for "
+              + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);
+
-
+
+
+
+
+
+
+
+
+
-      String planNodePath = getNodePath(reservationRoot, planName);
+      String planNodePath = getNodePath(reservationRoot, planName);
+
-        String reservationNodePath = getNodePath(planNodePath,
-            reservationNodeName);
+        String reservationNodePath =
+            getNodePath(planNodePath, reservationNodeName);
+
+
+
-          rmState.getReservationState().put(planName,
-              new HashMap<ReservationId, ReservationAllocationStateProto>());
+          rmState.getReservationState().put(planName, new HashMap<>());
+
+
-      return;
+    } else {
+      AMRMTokenSecretManagerStatePBImpl stateData =
+          new AMRMTokenSecretManagerStatePBImpl(
+            AMRMTokenSecretManagerStateProto.parseFrom(data));
+      rmState.amrmTokenSecretManagerState =
+          AMRMTokenSecretManagerState.newInstance(
+            stateData.getCurrentMasterKey(), stateData.getNextMasterKey());
-    AMRMTokenSecretManagerStatePBImpl stateData =
-        new AMRMTokenSecretManagerStatePBImpl(
-          AMRMTokenSecretManagerStateProto.parseFrom(data));
-    rmState.amrmTokenSecretManagerState =
-        AMRMTokenSecretManagerState.newInstance(
-          stateData.getCurrentMasterKey(), stateData.getNextMasterKey());
-    List<String> childNodes =
-        getChildren(dtMasterKeysRootPath);
+    List<String> childNodes = getChildren(dtMasterKeysRootPath);
+
-      DataInputStream fsIn = new DataInputStream(is);
-      try {
+      try (DataInputStream fsIn = new DataInputStream(is)) {
+
-      } finally {
-        is.close();
+
-      DataInputStream seqIn = new DataInputStream(seqIs);
-      try {
+      try (DataInputStream seqIn = new DataInputStream(seqIs)) {
-      } finally {
-        seqIn.close();
+
-      DataInputStream fsIn = new DataInputStream(is);
-      try {
+      try (DataInputStream fsIn = new DataInputStream(is)) {
+
-      } finally {
-        is.close();
+
+
+
+
-          throw new YarnRuntimeException("The child node name is different " +
-              "from the application id");
+          throw new YarnRuntimeException("The child node name is different "
+              + "from the application id");
+
+
+
+
-
-  public synchronized void updateApplicationStateInternal(ApplicationId appId,
-      ApplicationStateData appStateDataPB) throws Exception {
+  protected synchronized void updateApplicationStateInternal(
+      ApplicationId appId, ApplicationStateData appStateDataPB)
+      throws Exception {
+
-  public synchronized void storeApplicationAttemptStateInternal(
+  protected synchronized void storeApplicationAttemptStateInternal(
+
-    safeCreate(nodeCreatePath, attemptStateData, zkAcl,
-        CreateMode.PERSISTENT);
+    safeCreate(nodeCreatePath, attemptStateData, zkAcl, CreateMode.PERSISTENT);
-  public synchronized void updateApplicationAttemptStateInternal(
+  protected synchronized void updateApplicationAttemptStateInternal(
+
+
-  public synchronized void removeApplicationAttemptInternal(
-      ApplicationAttemptId appAttemptId)
-      throws Exception {
+  protected synchronized void removeApplicationAttemptInternal(
+      ApplicationAttemptId appAttemptId) throws Exception {
-    String attemptIdRemovePath = getNodePath(appIdRemovePath,
-        appAttemptId.toString());
+    String attemptIdRemovePath =
+        getNodePath(appIdRemovePath, appAttemptId.toString());
+
-  public synchronized void removeApplicationStateInternal(
-      ApplicationStateData  appState)
-      throws Exception {
+  protected synchronized void removeApplicationStateInternal(
+      ApplicationStateData appState) throws Exception {
-      String attemptRemovePath = getNodePath(appIdRemovePath, attemptId.toString());
+      String attemptRemovePath =
+          getNodePath(appIdRemovePath, attemptId.toString());
+
+
+
+
+
-    String nodeCreatePath =
-        getNodePath(delegationTokensRootPath, DELEGATION_TOKEN_PREFIX
-            + rmDTIdentifier.getSequenceNumber());
-    ByteArrayOutputStream seqOs = new ByteArrayOutputStream();
-    DataOutputStream seqOut = new DataOutputStream(seqOs);
+    String nodeCreatePath = getNodePath(delegationTokensRootPath,
+        DELEGATION_TOKEN_PREFIX + rmDTIdentifier.getSequenceNumber());
-    try {
+    ByteArrayOutputStream seqOs = new ByteArrayOutputStream();
+
+    try (DataOutputStream seqOut = new DataOutputStream(seqOs)) {
-        LOG.debug((isUpdate ? "Storing " : "Updating ") + "RMDelegationToken_" +
-            rmDTIdentifier.getSequenceNumber());
+        LOG.debug((isUpdate ? "Storing " : "Updating ") + "RMDelegationToken_"
+            + rmDTIdentifier.getSequenceNumber());
+
-          LOG.debug((isUpdate ? "Storing " : "Updating ") +
-              dtSequenceNumberPath + ". SequenceNumber: "
+          LOG.debug((isUpdate ? "Storing " : "Updating ")
+              + dtSequenceNumberPath + ". SequenceNumber: "
+
-    } finally {
-      seqOs.close();
-    String nodeCreatePath =
-        getNodePath(dtMasterKeysRootPath, DELEGATION_KEY_PREFIX
-            + delegationKey.getKeyId());
-    ByteArrayOutputStream os = new ByteArrayOutputStream();
-    DataOutputStream fsOut = new DataOutputStream(os);
+    String nodeCreatePath = getNodePath(dtMasterKeysRootPath,
+        DELEGATION_KEY_PREFIX + delegationKey.getKeyId());
-    delegationKey.write(fsOut);
-    try {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    try(DataOutputStream fsOut = new DataOutputStream(os)) {
+      delegationKey.write(fsOut);
-    } finally {
-      os.close();
+
+
-  public synchronized void storeOrUpdateAMRMTokenSecretManagerState(
+  protected synchronized void storeOrUpdateAMRMTokenSecretManagerState(
+
-      String reservationIdName)
-      throws Exception {
-    String planNodePath =
-        getNodePath(reservationRoot, planName);
-    String reservationPath = getNodePath(planNodePath,
-        reservationIdName);
+      String reservationIdName) throws Exception {
+    String planNodePath = getNodePath(reservationRoot, planName);
+    String reservationPath = getNodePath(planNodePath, reservationIdName);
+
-      LOG.debug("Removing reservationallocation " + reservationIdName + " for" +
-          " plan " + planName);
+      LOG.debug("Removing reservationallocation " + reservationIdName
+          + " for" + " plan " + planName);
+
+
-      String reservationIdName)
-      throws Exception {
+      String reservationIdName) throws Exception {
-    addOrUpdateReservationState(
-        reservationAllocation, planName, reservationIdName, trx, false);
+    addOrUpdateReservationState(reservationAllocation, planName,
+        reservationIdName, trx, false);
+
+
-      transactionFinal =
-          transaction.create()
-              .withMode(CreateMode.PERSISTENT).withACL(zkAcl)
-              .forPath(fencingNodePath, new byte[0]).and();
+      transactionFinal = transaction.create()
+          .withMode(CreateMode.PERSISTENT).withACL(zkAcl)
+          .forPath(fencingNodePath, new byte[0]).and();
+    @Override
-        while (true) {
-          if(isFencedState()) {
-            break;
-          }
+        while (!isFencedState()) {
-        LOG.info(VerifyActiveStatusThread.class.getName() + " thread " +
-            "interrupted! Exiting!");
+        LOG.info(getName() + " thread interrupted! Exiting!");
+        interrupt();

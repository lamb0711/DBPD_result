HDFS-5163. Miscellaneous cache pool RPC fixes (Contributed by Colin Patrick McCabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520665 13f79535-47bb-0310-9956-ffa450edef68

+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_POOLS_NUM_RESPONSES;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_POOLS_NUM_RESPONSES_DEFAULT;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_DIRECTIVES_NUM_RESPONSES;
+import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMENODE_LIST_CACHE_DIRECTIVES_NUM_RESPONSES_DEFAULT;
+
-import java.util.Map;
+import java.util.Map.Entry;
+import org.apache.hadoop.fs.BatchedRemoteIterator.BatchedListEntries;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.InvalidPoolError;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.PoolWritePermissionDeniedError;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.UnexpectedAddPathCacheDirectiveException;
+import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.InvalidPoolNameError;
+import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.UnexpectedAddPathCacheDirectiveException;
+import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.PoolWritePermissionDeniedError;
-import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.RemovePermissionDeniedException;
+import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.RemovePermissionDeniedException;
-  private final TreeMap<String, CachePool> cachePoolsByName =
+  private final TreeMap<String, CachePool> cachePools =
-   * Cache pools, sorted by ID
-   */
-  private final TreeMap<Long, CachePool> cachePoolsById =
-      new TreeMap<Long, CachePool>();
-
-  /**
-   * The pool ID to use for a new pool.
+   * Maximum number of cache pools to list in one operation.
-  private long nextPoolId;
+  private final int maxListCachePoolsResponses;
+
+  /**
+   * Maximum number of cache pool directives to list in one operation.
+   */
+  private final int maxListCacheDirectivesResponses;
+    maxListCachePoolsResponses = conf.getInt(
+        DFS_NAMENODE_LIST_CACHE_POOLS_NUM_RESPONSES,
+        DFS_NAMENODE_LIST_CACHE_POOLS_NUM_RESPONSES_DEFAULT);
+    maxListCacheDirectivesResponses = conf.getInt(
+        DFS_NAMENODE_LIST_CACHE_DIRECTIVES_NUM_RESPONSES,
+        DFS_NAMENODE_LIST_CACHE_DIRECTIVES_NUM_RESPONSES_DEFAULT);
-    cachePoolsByName.clear();
-    cachePoolsById.clear();
+    cachePools.clear();
-    nextPoolId = 1;
-      throw new IOException("no more available entry IDs");
+      throw new IOException("no more available IDs");
-  synchronized long getNextPoolId() throws IOException {
-    if (nextPoolId == Long.MAX_VALUE) {
-      throw new IOException("no more available pool IDs");
-    }
-    return nextPoolId++;
-  }
-
-        FSPermissionChecker pc, PathCacheDirective directive) {
-    CachePool pool = cachePoolsById.get(directive.getPoolId());
+        PathCacheDirective directive, FSPermissionChecker pc) {
+    CachePool pool = cachePools.get(directive.getPool());
-          new InvalidPoolError(directive));
+          new InvalidPoolNameError(directive));
-    if (!pc.checkPermission(pool, FsAction.WRITE)) {
+    if ((pc != null) && (!pc.checkPermission(pool, FsAction.WRITE))) {
-      FSPermissionChecker pc, List<PathCacheDirective> directives) {
+      List<PathCacheDirective> directives, FSPermissionChecker pc) {
-      results.add(addDirective(pc, directive));
+      results.add(addDirective(directive, pc));
-  private synchronized Fallible<Long> removeEntry(FSPermissionChecker pc,
-        long entryId) {
+  private synchronized Fallible<Long> removeEntry(long entryId,
+        FSPermissionChecker pc) {
-    CachePool pool = cachePoolsById.get(existing.getDirective().getPoolId());
+    CachePool pool = cachePools.get(existing.getDirective().getPool());
-    if (!pc.checkPermission(pool, FsAction.WRITE)) {
+    if ((pc != null) && (!pc.checkPermission(pool, FsAction.WRITE))) {
-
+    
-  public synchronized List<Fallible<Long>> removeEntries(FSPermissionChecker pc,
-      List<Long> entryIds) {
+  public synchronized List<Fallible<Long>> removeEntries(List<Long> entryIds,
+      FSPermissionChecker pc) {
-      results.add(removeEntry(pc, entryId));
+      results.add(removeEntry(entryId, pc));
-  public synchronized List<PathCacheEntry> listPathCacheEntries(
-      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {
-    final int MAX_PRE_ALLOCATED_ENTRIES = 16;
-    ArrayList<PathCacheEntry> replies = new ArrayList<PathCacheEntry>(
-        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));
+  public synchronized BatchedListEntries<PathCacheEntry> 
+        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {
+    final int NUM_PRE_ALLOCATED_ENTRIES = 16;
+    ArrayList<PathCacheEntry> replies =
+        new ArrayList<PathCacheEntry>(NUM_PRE_ALLOCATED_ENTRIES);
-    for (PathCacheEntry entry : tailMap.values()) {
-      if (numReplies >= maxReplies) {
-        return replies;
+    for (Entry<Long, PathCacheEntry> cur : tailMap.entrySet()) {
+      if (numReplies >= maxListCacheDirectivesResponses) {
+        return new BatchedListEntries<PathCacheEntry>(replies, true);
-      long entryPoolId = entry.getDirective().getPoolId();
-      if (poolId == null || poolId <= 0 || entryPoolId == poolId) {
-        if (pc.checkPermission(
-            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {
-          replies.add(entry);
-          numReplies++;
-        }
+      PathCacheEntry curEntry = cur.getValue();
+      if (!filterPool.isEmpty() && 
+          !cur.getValue().getDirective().getPool().equals(filterPool)) {
+        continue;
+      }
+      CachePool pool = cachePools.get(curEntry.getDirective().getPool());
+      if (pool == null) {
+        LOG.error("invalid pool for PathCacheEntry " + curEntry);
+        continue;
+      }
+      if (pc.checkPermission(pool, FsAction.EXECUTE)) {
+        replies.add(cur.getValue());
+        numReplies++;
-    return replies;
-  }
-
-  synchronized CachePool getCachePool(long id) {
-    return cachePoolsById.get(id);
+    return new BatchedListEntries<PathCacheEntry>(replies, false);
-   * @return created CachePool
-  public synchronized CachePool addCachePool(CachePoolInfo info)
+  public synchronized void addCachePool(CachePoolInfo info)
-    if (poolName == null || poolName.isEmpty()) {
+    if (poolName.isEmpty()) {
-    if (cachePoolsByName.containsKey(poolName)) {
+    CachePool pool = cachePools.get(poolName);
+    if (pool != null) {
-    CachePool cachePool = new CachePool(getNextPoolId(), poolName,
+    CachePool cachePool = new CachePool(poolName,
-    cachePoolsById.put(cachePool.getId(), cachePool);
-    cachePoolsByName.put(poolName, cachePool);
+    cachePools.put(poolName, cachePool);
-    return cachePool;
-  public synchronized void modifyCachePool(long poolId, CachePoolInfo info)
+  public synchronized void modifyCachePool(CachePoolInfo info)
-    if (poolId <= 0) {
-      throw new IOException("invalid pool id " + poolId);
+    String poolName = info.getPoolName();
+    if (poolName.isEmpty()) {
+      throw new IOException("invalid empty cache pool name");
-    if (!cachePoolsById.containsKey(poolId)) {
-      throw new IOException("cache pool id " + poolId + " does not exist.");
+    CachePool pool = cachePools.get(poolName);
+    if (pool == null) {
+      throw new IOException("cache pool " + poolName + " does not exist.");
-    CachePool pool = cachePoolsById.get(poolId);
-    // Remove the old CachePoolInfo
-    removeCachePool(poolId);
-    // Build up the new CachePoolInfo
-    CachePoolInfo.Builder newInfo = CachePoolInfo.newBuilder(pool.getInfo());
-    if (info.getPoolName() != null) {
-      newInfo.setPoolName(info.getPoolName());
-      bld.append(prefix).
-      append("set name to ").append(info.getOwnerName());
-      prefix = "; ";
-    }
-      newInfo.setOwnerName(info.getOwnerName());
+      pool.setOwnerName(info.getOwnerName());
-      newInfo.setGroupName(info.getGroupName());
+      pool.setGroupName(info.getGroupName());
-      newInfo.setMode(info.getMode());
+      pool.setMode(info.getMode());
-        append(String.format("set mode to ", info.getMode()));
+        append(String.format("set mode to 0%3o", info.getMode()));
-      newInfo.setWeight(info.getWeight());
+      pool.setWeight(info.getWeight());
-    } else {
-      pool.setInfo(newInfo.build());
-    // Put the newly modified info back in
-    cachePoolsById.put(poolId, pool);
-    cachePoolsByName.put(info.getPoolName(), pool);
-    LOG.info("modified pool id " + pool.getId()
-        + " (" + pool.getInfo().getPoolName() + "); "
-        + bld.toString());
+    LOG.info("modified " + poolName + "; " + bld.toString());
-   * @param poolId
-   *          The id of the cache pool to remove.
+   * @param poolName
+   *          The name for the cache pool to remove.
-  public synchronized void removeCachePool(long poolId) throws IOException {
-    if (!cachePoolsById.containsKey(poolId)) {
-      throw new IOException("can't remove nonexistent cache pool id " + poolId);
+  public synchronized void removeCachePool(String poolName)
+      throws IOException {
+    CachePool pool = cachePools.remove(poolName);
+    if (pool == null) {
+      throw new IOException("can't remove nonexistent cache pool " + poolName);
-    // Remove all the entries associated with the pool
-    Iterator<Map.Entry<Long, PathCacheEntry>> it =
-        entriesById.entrySet().iterator();
-    while (it.hasNext()) {
-      Map.Entry<Long, PathCacheEntry> entry = it.next();
-      if (entry.getValue().getDirective().getPoolId() == poolId) {
-        it.remove();
-        entriesByDirective.remove(entry.getValue().getDirective());
+    
+    // Remove entries using this pool
+    // TODO: could optimize this somewhat to avoid the need to iterate
+    // over all entries in entriesByDirective
+    Iterator<Entry<PathCacheDirective, PathCacheEntry>> iter = 
+        entriesByDirective.entrySet().iterator();
+    while (iter.hasNext()) {
+      Entry<PathCacheDirective, PathCacheEntry> entry = iter.next();
+      if (entry.getKey().getPool().equals(poolName)) {
+        entriesById.remove(entry.getValue().getEntryId());
+        iter.remove();
-    // Remove the pool
-    CachePool pool = cachePoolsById.remove(poolId);
-    cachePoolsByName.remove(pool.getInfo().getPoolName());
-  public synchronized List<CachePool> listCachePools(Long prevKey,
-      int maxRepliesPerRequest) {
-    final int MAX_PREALLOCATED_REPLIES = 16;
-    ArrayList<CachePool> results = 
-        new ArrayList<CachePool>(Math.min(MAX_PREALLOCATED_REPLIES,
-            maxRepliesPerRequest));
-    SortedMap<Long, CachePool> tailMap =
-        cachePoolsById.tailMap(prevKey, false);
-    for (CachePool pool : tailMap.values()) {
-      results.add(pool);
+  public synchronized BatchedListEntries<CachePoolInfo>
+      listCachePools(FSPermissionChecker pc, String prevKey) {
+    final int NUM_PRE_ALLOCATED_ENTRIES = 16;
+    ArrayList<CachePoolInfo> results = 
+        new ArrayList<CachePoolInfo>(NUM_PRE_ALLOCATED_ENTRIES);
+    SortedMap<String, CachePool> tailMap = cachePools.tailMap(prevKey, false);
+    int numListed = 0;
+    for (Entry<String, CachePool> cur : tailMap.entrySet()) {
+      if (numListed++ >= maxListCachePoolsResponses) {
+        return new BatchedListEntries<CachePoolInfo>(results, true);
+      }
+      if (pc == null) {
+        results.add(cur.getValue().getInfo(true));
+      } else {
+        results.add(cur.getValue().getInfo(pc));
+      }
-    return results;
+    return new BatchedListEntries<CachePoolInfo>(results, false);

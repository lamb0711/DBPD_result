HDDS-656. Add logic for pipeline report and action processing in new pipeline code. Contributed by Lokesh Jain.

-import org.apache.hadoop.hdds.protocol.proto.HddsProtos;
-import org.apache.hadoop.hdds.protocol.proto.HddsProtos.LifeCycleEvent;
-import org.apache.hadoop.hdds.protocol.proto.HddsProtos.LifeCycleState;
-import org.apache.hadoop.hdds.scm.ScmConfigKeys;
+import org.apache.hadoop.hdds.protocol.proto.HddsProtos.ReplicationType;
+import org.apache.hadoop.hdds.protocol.proto.HddsProtos.ReplicationFactor;
-import org.apache.hadoop.hdds.scm.exceptions.SCMException;
-import org.apache.hadoop.ozone.common.statemachine.InvalidStateTransitionException;
-import org.apache.hadoop.ozone.common.statemachine.StateMachine;
-import org.apache.hadoop.ozone.lease.LeaseManager;
+import org.apache.hadoop.hdds.scm.pipeline.Pipeline.PipelineState;
-import java.util.HashSet;
-import java.util.concurrent.TimeUnit;
-
-import static org.apache.hadoop.hdds.scm.exceptions.SCMException.ResultCodes.FAILED_TO_CHANGE_PIPELINE_STATE;
-  private final StateMachine<LifeCycleState, LifeCycleEvent> stateMachine;
-  private final LeaseManager<Pipeline> pipelineLeaseManager;
-    Set<LifeCycleState> finalStates = new HashSet<>();
-    long pipelineCreationLeaseTimeout = conf.getTimeDuration(
-        ScmConfigKeys.OZONE_SCM_PIPELINE_CREATION_LEASE_TIMEOUT,
-        ScmConfigKeys.OZONE_SCM_PIPELINE_CREATION_LEASE_TIMEOUT_DEFAULT,
-        TimeUnit.MILLISECONDS);
-    // TODO: Use LeaseManager for creation of pipelines.
-    // Add pipeline initialization logic.
-    this.pipelineLeaseManager = new LeaseManager<>("PipelineCreation",
-        pipelineCreationLeaseTimeout);
-    this.pipelineLeaseManager.start();
-
-    finalStates.add(LifeCycleState.CLOSED);
-    this.stateMachine = new StateMachine<>(LifeCycleState.ALLOCATED,
-        finalStates);
-    initializeStateMachine();
-  }
-
-
-  /*
-   * Event and State Transition Mapping.
-   *
-   * State: ALLOCATED ---------------> CREATING
-   * Event:                CREATE
-   *
-   * State: CREATING  ---------------> OPEN
-   * Event:               CREATED
-   *
-   * State: OPEN      ---------------> CLOSING
-   * Event:               FINALIZE
-   *
-   * State: CLOSING   ---------------> CLOSED
-   * Event:                CLOSE
-   *
-   * State: CREATING  ---------------> CLOSED
-   * Event:               TIMEOUT
-   *
-   *
-   * Container State Flow:
-   *
-   * [ALLOCATED]---->[CREATING]------>[OPEN]-------->[CLOSING]
-   *            (CREATE)     | (CREATED)     (FINALIZE)   |
-   *                         |                            |
-   *                         |                            |
-   *                         |(TIMEOUT)                   |(CLOSE)
-   *                         |                            |
-   *                         +--------> [CLOSED] <--------+
-   */
-
-  /**
-   * Add javadoc.
-   */
-  private void initializeStateMachine() {
-    stateMachine.addTransition(LifeCycleState.ALLOCATED,
-        LifeCycleState.CREATING, LifeCycleEvent.CREATE);
-
-    stateMachine.addTransition(LifeCycleState.CREATING,
-        LifeCycleState.OPEN, LifeCycleEvent.CREATED);
-
-    stateMachine.addTransition(LifeCycleState.OPEN,
-        LifeCycleState.CLOSING, LifeCycleEvent.FINALIZE);
-
-    stateMachine.addTransition(LifeCycleState.CLOSING,
-        LifeCycleState.CLOSED, LifeCycleEvent.CLOSE);
-
-    stateMachine.addTransition(LifeCycleState.CREATING,
-        LifeCycleState.CLOSED, LifeCycleEvent.TIMEOUT);
-  }
-
-  Pipeline updatePipelineState(PipelineID pipelineID, LifeCycleEvent event)
-      throws IOException {
-    Pipeline pipeline = null;
-    try {
-      pipeline = pipelineStateMap.getPipeline(pipelineID);
-      LifeCycleState newState =
-          stateMachine.getNextState(pipeline.getLifeCycleState(), event);
-      return pipelineStateMap.updatePipelineState(pipeline.getID(), newState);
-    } catch (InvalidStateTransitionException ex) {
-      String error = String.format("Failed to update pipeline state %s, "
-              + "reason: invalid state transition from state: %s upon "
-              + "event: %s.", pipeline.getID(), pipeline.getLifeCycleState(),
-          event);
-      LOG.error(error);
-      throw new SCMException(error, FAILED_TO_CHANGE_PIPELINE_STATE);
-    }
-  List<Pipeline> getPipelines(HddsProtos.ReplicationType type) {
-    return pipelineStateMap.getPipelines(type);
+  List<Pipeline> getPipelinesByType(ReplicationType type) {
+    return pipelineStateMap.getPipelinesByType(type);
+  }
+
+  List<Pipeline> getPipelinesByTypeAndFactor(ReplicationType type,
+      ReplicationFactor factor) {
+    return pipelineStateMap.getPipelinesByTypeAndFactor(type, factor);
+  int getNumberOfContainers(PipelineID pipelineID) throws IOException {
+    return pipelineStateMap.getNumberOfContainers(pipelineID);
+  }
+
-  void close() {
-    pipelineLeaseManager.shutdown();
+  Pipeline finalizePipeline(PipelineID pipelineId) throws IOException {
+    Pipeline pipeline = pipelineStateMap.getPipeline(pipelineId);
+    if (!pipeline.isClosed()) {
+      pipeline = pipelineStateMap
+          .updatePipelineState(pipelineId, PipelineState.CLOSED);
+    }
+    return pipeline;
+  }
+
+  Pipeline openPipeline(PipelineID pipelineId) throws IOException {
+    Pipeline pipeline = pipelineStateMap.getPipeline(pipelineId);
+    if (pipeline.isClosed()) {
+      throw new IOException("Closed pipeline can not be opened");
+    }
+    if (pipeline.getPipelineState() == PipelineState.ALLOCATED) {
+      pipeline = pipelineStateMap
+          .updatePipelineState(pipelineId, PipelineState.OPEN);
+    }
+    return pipeline;

HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68

+      // Check if the whole subtree has been saved (for reference nodes)
+      boolean toLoadSubtree = referenceMap.toProcessSubtree(parent.getId());
+      if (!toLoadSubtree) {
+        return;
+      }
+      
-
+      
-
+      int dstSnapshotId = Snapshot.INVALID_ID;
+      if (!isWithName) {
+        dstSnapshotId = in.readInt();
+      }
-        final INodeReference ref = new INodeReference(null, withCount);
+        final INodeReference ref = new INodeReference.DstReference(null,
+            withCount, dstSnapshotId);
-        FSImageSerialization.saveINode2Image(fsDir.rootDir, out, false, referenceMap);
+        FSImageSerialization.saveINode2Image(fsDir.rootDir, out, false,
+            referenceMap);
-        saveImage(strbuf, fsDir.rootDir, out, null);
+        saveImage(strbuf, fsDir.rootDir, out, null, true);
+     * @param toSaveSubtree Whether or not to save the subtree to fsimage. For
+     *                      reference node, its subtree may already have been
+     *                      saved before.
-        DataOutputStream out, Snapshot snapshot)
+        DataOutputStream out, Snapshot snapshot, boolean toSaveSubtree)
-      final ReadOnlyList<INode> children = current.getChildrenList(null);
-      int dirNum = 0;
-      Map<Snapshot, List<INodeDirectory>> snapshotDirMap = null;
-      if (current instanceof INodeDirectoryWithSnapshot) {
-        snapshotDirMap = new HashMap<Snapshot, List<INodeDirectory>>();
-        dirNum += ((INodeDirectoryWithSnapshot) current).
-            getSnapshotDirectory(snapshotDirMap);
-      }
-      
+      if (!toSaveSubtree) {
+        return;
+      }
+      
+      final ReadOnlyList<INode> children = current.getChildrenList(null);
+      int dirNum = 0;
+      Map<Snapshot, List<INodeDirectory>> snapshotDirMap = null;
+      if (current instanceof INodeDirectoryWithSnapshot) {
+        snapshotDirMap = new HashMap<Snapshot, List<INodeDirectory>>();
+        dirNum += ((INodeDirectoryWithSnapshot) current).
+            getSnapshotDirectory(snapshotDirMap);
+      }
+      
-        if(!child.isDirectory())
+        if(!child.isDirectory()) {
-        currentDirName.put(PATH_SEPARATOR).put(child.getLocalNameBytes());
-        saveImage(currentDirName, child.asDirectory(), out, snapshot);
+        }
+        // make sure we only save the subtree under a reference node once
+        boolean toSave = child.isReference() ? 
+            referenceMap.toProcessSubtree(child.getId()) : true;
+        currentDirName.put(PATH_SEPARATOR).put(child.getLocalNameBytes()); 
+        saveImage(currentDirName, child.asDirectory(), out, snapshot, toSave);
+            // make sure we only save the subtree under a reference node once
+            boolean toSave = subDir.getParentReference() != null ? 
+                referenceMap.toProcessSubtree(subDir.getId()) : true;
-            saveImage(currentDirName, subDir, out, ss);
+            saveImage(currentDirName, subDir, out, ss, toSave);

YARN-8696. [AMRMProxy] FederationInterceptor upgrade: home sub-cluster heartbeat async. Contributed by Botong Huang.

-  private HashMap<ApplicationAttemptId,
-      List<ContainerId>> applicationContainerIdMap = new HashMap<>();
+  private HashMap<ApplicationId, List<ContainerId>> applicationContainerIdMap =
+      new HashMap<>();
+  private int rmId;
+  private boolean shouldWaitForSyncNextAllocate = false;
+
+    this.rmId = startContainerIndex;
+    ApplicationId appId = attemptId.getApplicationId();
-      if (applicationContainerIdMap.containsKey(attemptId)) {
-        if (keepContainerOnUams.contains(attemptId.getApplicationId())) {
+      if (applicationContainerIdMap.containsKey(appId)) {
+        if (keepContainerOnUams.contains(appId)) {
-          for (ContainerId containerId : applicationContainerIdMap
-              .get(attemptId)) {
+          for (ContainerId containerId : applicationContainerIdMap.get(appId)) {
-        applicationContainerIdMap.put(attemptId, new ArrayList<ContainerId>());
+        applicationContainerIdMap.put(appId, new ArrayList<ContainerId>());
+    ApplicationId appId = attemptId.getApplicationId();
-          applicationContainerIdMap.containsKey(attemptId));
-      applicationContainerIdMap.remove(attemptId);
+          applicationContainerIdMap.containsKey(appId));
+      applicationContainerIdMap.remove(appId);
+    ApplicationId appId = attemptId.getApplicationId();
+    // Wait for signal for certain test cases
+    synchronized (syncObj) {
+      if (shouldWaitForSyncNextAllocate) {
+        shouldWaitForSyncNextAllocate = false;
+
+        LOG.info("Allocate call in RM start waiting");
+        try {
+          syncObj.wait();
+          LOG.info("Allocate call in RM wait finished");
+        } catch (InterruptedException e) {
+          LOG.info("Allocate call in RM wait interrupted", e);
+        }
+      }
+    }
+
-                    + attemptId,
-                applicationContainerIdMap.containsKey(attemptId));
-            List<ContainerId> ids = applicationContainerIdMap.get(attemptId);
+                    + appId,
+                applicationContainerIdMap.containsKey(appId));
+            List<ContainerId> ids = applicationContainerIdMap.get(appId);
-        Assert
-            .assertTrue(
-                "The application id is not registered before allocate(): "
-                    + attemptId,
-                applicationContainerIdMap.containsKey(attemptId));
-        List<ContainerId> ids = applicationContainerIdMap.get(attemptId);
+        Assert.assertTrue(
+            "The application id is not registered before allocate(): " + appId,
+            applicationContainerIdMap.containsKey(appId));
+        List<ContainerId> ids = applicationContainerIdMap.get(appId);
-    Token newAMRMToken = Token.newInstance(new byte[0], "", new byte[0], "");
+    Token newAMRMToken = Token.newInstance(new byte[0],
+        Integer.toString(this.rmId), new byte[0], "");
+  public void setWaitForSyncNextAllocate(boolean wait) {
+    synchronized (syncObj) {
+      shouldWaitForSyncNextAllocate = wait;
+    }
+  }
+
-    ApplicationAttemptId attemptId = request.getApplicationAttemptId();
+    ApplicationId appId = request.getApplicationAttemptId().getApplicationId();
-      Assert.assertTrue("The application id is NOT registered: " + attemptId,
-          applicationContainerIdMap.containsKey(attemptId));
-      List<ContainerId> ids = applicationContainerIdMap.get(attemptId);
+      Assert.assertTrue("The application id is NOT registered: " + appId,
+          applicationContainerIdMap.containsKey(appId));
+      List<ContainerId> ids = applicationContainerIdMap.get(appId);

HADOOP-16951: Tidy Up Text and ByteWritables Classes.

1. Remove superfluous code
2. Remove superfluous comments
3. Checkstyle fixes
4. Remove methods that simply call super.method()
5. Use Java 8 facilities to streamline code where applicable
6. Simplify and unify some of the constructs between the two classes
7. Expanding of the arrays be 1.5x instead of 2x per expansion.
-import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
-  
+
-        return Charset.forName("UTF-8").newEncoder().
+        return StandardCharsets.UTF_8.newEncoder().
-  
+
-      return Charset.forName("UTF-8").newDecoder().
+      return StandardCharsets.UTF_8.newDecoder().
-  
-  private static final byte [] EMPTY_BYTES = new byte[0];
-  
-  private byte[] bytes;
-  private int length;
+  private static final byte[] EMPTY_BYTES = new byte[0];
+
+  private byte[] bytes = EMPTY_BYTES;
+  private int length = 0;
+
+  /**
+   * Construct an empty text string.
+   */
-    bytes = EMPTY_BYTES;
-  /** Construct from a string. 
+  /**
+   * Construct from a string.
-  /** Construct from another text. */
+  /**
+   * Construct from another text.
+   */
-  /** Construct from a byte array.
+  /**
+   * Construct from a byte array.
-  
+
-    byte[] result = new byte[length];
-    System.arraycopy(bytes, 0, result, 0, length);
-    return result;
+    return Arrays.copyOf(bytes, length);
-  
+
-  /** Returns the number of bytes in the byte array */ 
+  /**
+   * Returns the number of bytes in the byte array.
+   */
-  
+
-      
+
-  
+
-  
+
-      ByteBuffer src = ByteBuffer.wrap(this.bytes,0,this.length);
+      ByteBuffer src = ByteBuffer.wrap(this.bytes, 0, this.length);
-          
+
-      // can't get here
-      e.printStackTrace();
-      return -1;
+      throw new RuntimeException("Should not have happened", e);
-  }  
-  /** Set to contain the contents of a string. 
+  }
+
+  /**
+   * Set to contain the contents of a string.
-    }catch(CharacterCodingException e) {
-      throw new RuntimeException("Should not have happened ", e); 
+    } catch (CharacterCodingException e) {
+      throw new RuntimeException("Should not have happened", e);
-  /** Set to a utf8 byte array
+  /**
+   * Set to a utf8 byte array.
-  
-  /** copy a text. */
+
+  /**
+   * Copy a text.
+   */
-   * Set the Text to range of bytes
+   * Set the Text to range of bytes.
+   *
-    setCapacity(len, false);
+    ensureCapacity(len);
-   * Append a range of bytes to the end of the given text
+   * Append a range of bytes to the end of the given text.
+   *
-    setCapacity(length + len, true);
+    byte[] original = bytes;
+    int capacity = Math.max(length + len, length + (length >> 1));
+    if (ensureCapacity(capacity)) {
+      System.arraycopy(original, 0, bytes, 0, length);
+    }
-  /*
+  /**
-   * <code>len</code> bytes. If the current buffer is longer,
-   * then the capacity and existing content of the buffer are
-   * unchanged. If <code>len</code> is larger
-   * than the current capacity, the Text object's capacity is
-   * increased to match.
-   * @param len the number of bytes we need
-   * @param keepData should the old data be kept
+   * <code>capacity</code> bytes. If the current buffer is longer, then the
+   * capacity and existing content of the buffer are unchanged. If
+   * <code>capacity</code> is larger than the current capacity, the Text
+   * object's capacity is increased to match and any existing data is lost.
+   *
+   * @param capacity the number of bytes we need
+   * @return true if the internal array was resized or false otherwise
-  private void setCapacity(int len, boolean keepData) {
-    if (bytes == null || bytes.length < len) {
-      if (bytes != null && keepData) {
-        bytes = Arrays.copyOf(bytes, Math.max(len,length << 1));
-      } else {
-        bytes = new byte[len];
-      }
+  private boolean ensureCapacity(final int capacity) {
+    if (bytes.length < capacity) {
+      bytes = new byte[capacity];
+      return true;
+    return false;
-   
-  /** 
-   * Convert text back to string
-   * @see java.lang.Object#toString()
-   */
+
-      throw new RuntimeException("Should not have happened " , e); 
+      throw new RuntimeException("Should not have happened", e);
-  
-  /** deserialize 
-   */
+
-  
+
-  /** Skips over one Text in the input. */
+  /**
+   * Skips over one Text in the input.
+   */
-    setCapacity(len, false);
+    ensureCapacity(len);
-  /** serialize
-   * write this object to out
-   * length uses zero-compressed encoding
+  /**
+   * Serialize. Write this object to out length uses zero-compressed encoding.
+   *
-  /** Returns true iff <code>o</code> is a Text with the same contents.  */
+  /**
+   * Returns true iff <code>o</code> is a Text with the same length and same
+   * contents.
+   */
-      return compareBytes(b1, s1+n1, l1-n1, b2, s2+n2, l2-n2);
+      return compareBytes(b1, s1 + n1, l1 - n1, b2, s2 + n2, l2 - n2);
-  
+
-  
+
-  
+
-  
+
-  
-  /** Write a UTF8 encoded string to out
+
+  /**
+   * Write a UTF8 encoded string to out.
-  /** Write a UTF8 encoded string with a maximum size to out
+  /**
+   * Write a UTF8 encoded string with a maximum size to out.
-  
+
-  /** 
-   * Check if a byte array contains valid utf-8
+  /**
+   * Check if a byte array contains valid UTF-8.
+   *
-   * @throws MalformedInputException if the byte array contains invalid utf-8
+   * @throws MalformedInputException if the byte array contains invalid UTF-8
-    validateUTF8(utf8, 0, utf8.length);     
+    validateUTF8(utf8, 0, utf8.length);
-  
+
-   * Check to see if a byte array is valid utf-8
+   * Check to see if a byte array is valid UTF-8.
+   *
-  

HADOOP-9747. Reduce unnecessary UGI synchronization. Contributed by Daryn Sharp.

-import static org.apache.hadoop.fs.CommonConfigurationKeys.HADOOP_TREAT_SUBJECT_EXTERNAL_KEY;
-import static org.apache.hadoop.fs.CommonConfigurationKeys.HADOOP_TREAT_SUBJECT_EXTERNAL_DEFAULT;
+import java.util.EnumMap;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.security.auth.login.Configuration.Parameters;
-      Principal user = null;
-      // if we are using kerberos, try it out
-      if (isAuthenticationMethodEnabled(AuthenticationMethod.KERBEROS)) {
-        user = getCanonicalUser(KerberosPrincipal.class);
+      Principal user = getCanonicalUser(KerberosPrincipal.class);
+      if (user != null) {
-          userEntry = new User(user.getName());
+          // LoginContext will be attached later unless it's an external
+          // subject.
+          AuthenticationMethod authMethod = (user instanceof KerberosPrincipal)
+            ? AuthenticationMethod.KERBEROS : AuthenticationMethod.SIMPLE;
+          userEntry = new User(user.getName(), authMethod, null);
-  /*
-   * This config is a temporary one for backward compatibility.
-   * It means whether to treat the subject passed to
-   * UserGroupInformation(Subject) as external. If true,
-   * -  no renewal thread will be created to do the renew credential
-   * -  reloginFromKeytab() and reloginFromTicketCache will not renew
-   *    credential.
-   * and it assumes that the owner of the subject to renew; if false, it means
-   * to retain the old behavior prior to fixing HADOOP-13558 and HADOOP-13805.
-   * The default is false.
-   */
-  private static boolean treatSubjectExternal = false;
-
-  /*
-   * Some test need the renewal thread to be created even if it does
-   *   UserGroupInformation.loginUserFromSubject(subject);
-   * The test code may set this variable to true via
-   *   setEnableRenewThreadCreationForTest(boolean)
-   * method.
-   */
-  private static boolean enableRenewThreadCreationForTest = false;
-
-
-    treatSubjectExternal = conf.getBoolean(HADOOP_TREAT_SUBJECT_EXTERNAL_KEY,
-        HADOOP_TREAT_SUBJECT_EXTERNAL_DEFAULT);
-    if (treatSubjectExternal) {
-      LOG.info("Config " + HADOOP_TREAT_SUBJECT_EXTERNAL_KEY + " is set to "
-          + "true, the owner of the subject passed to "
-          + " UserGroupInformation(Subject) is supposed to renew the "
-          + "credential.");
-    }
-  static void setEnableRenewThreadCreationForTest(boolean b) {
-    enableRenewThreadCreationForTest = b;
-  }
-
-  @InterfaceAudience.Private
-  @VisibleForTesting
-  static boolean getEnableRenewThreadCreationForTest() {
-    return enableRenewThreadCreationForTest;
-  }
-
-  @InterfaceAudience.Private
-  @VisibleForTesting
-    setEnableRenewThreadCreationForTest(false);
-  private static UserGroupInformation loginUser = null;
-  private static String keytabPrincipal = null;
-  private static String keytabFile = null;
+  private static final AtomicReference<UserGroupInformation> loginUserRef =
+    new AtomicReference<>();
-  private final boolean isKeytab;
-  private final boolean isKrbTkt;
-  private final boolean isLoginExternal;
-  
+
-  
-  /**
-   * A JAAS configuration that defines the login modules that we want
-   * to use for login.
-   */
-  private static class HadoopConfiguration 
-      extends javax.security.auth.login.Configuration {
-    private static final String SIMPLE_CONFIG_NAME = "hadoop-simple";
-    private static final String USER_KERBEROS_CONFIG_NAME = 
-      "hadoop-user-kerberos";
-    private static final String KEYTAB_KERBEROS_CONFIG_NAME = 
-      "hadoop-keytab-kerberos";
-    private static final Map<String, String> BASIC_JAAS_OPTIONS =
-      new HashMap<String,String>();
-    static {
-      String jaasEnvVar = System.getenv("HADOOP_JAAS_DEBUG");
-      if (jaasEnvVar != null && "true".equalsIgnoreCase(jaasEnvVar)) {
-        BASIC_JAAS_OPTIONS.put("debug", "true");
-      }
-    }
-    
-    private static final AppConfigurationEntry OS_SPECIFIC_LOGIN =
-      new AppConfigurationEntry(OS_LOGIN_MODULE_NAME,
-                                LoginModuleControlFlag.REQUIRED,
-                                BASIC_JAAS_OPTIONS);
-    private static final AppConfigurationEntry HADOOP_LOGIN =
-      new AppConfigurationEntry(HadoopLoginModule.class.getName(),
-                                LoginModuleControlFlag.REQUIRED,
-                                BASIC_JAAS_OPTIONS);
-    private static final Map<String,String> USER_KERBEROS_OPTIONS = 
-      new HashMap<String,String>();
-    static {
-      if (IBM_JAVA) {
-        USER_KERBEROS_OPTIONS.put("useDefaultCcache", "true");
-      } else {
-        USER_KERBEROS_OPTIONS.put("doNotPrompt", "true");
-        USER_KERBEROS_OPTIONS.put("useTicketCache", "true");
-      }
-      String ticketCache = System.getenv("KRB5CCNAME");
-      if (ticketCache != null) {
-        if (IBM_JAVA) {
-          // The first value searched when "useDefaultCcache" is used.
-          System.setProperty("KRB5CCNAME", ticketCache);
-        } else {
-          USER_KERBEROS_OPTIONS.put("ticketCache", ticketCache);
-        }
-      }
-      USER_KERBEROS_OPTIONS.put("renewTGT", "true");
-      USER_KERBEROS_OPTIONS.putAll(BASIC_JAAS_OPTIONS);
-    }
-    private static final AppConfigurationEntry USER_KERBEROS_LOGIN =
-      new AppConfigurationEntry(KerberosUtil.getKrb5LoginModuleName(),
-                                LoginModuleControlFlag.OPTIONAL,
-                                USER_KERBEROS_OPTIONS);
-    private static final Map<String,String> KEYTAB_KERBEROS_OPTIONS = 
-      new HashMap<String,String>();
-    static {
-      if (IBM_JAVA) {
-        KEYTAB_KERBEROS_OPTIONS.put("credsType", "both");
-      } else {
-        KEYTAB_KERBEROS_OPTIONS.put("doNotPrompt", "true");
-        KEYTAB_KERBEROS_OPTIONS.put("useKeyTab", "true");
-        KEYTAB_KERBEROS_OPTIONS.put("storeKey", "true");
-      }
-      KEYTAB_KERBEROS_OPTIONS.put("refreshKrb5Config", "true");
-      KEYTAB_KERBEROS_OPTIONS.putAll(BASIC_JAAS_OPTIONS);      
-    }
-    private static final AppConfigurationEntry KEYTAB_KERBEROS_LOGIN =
-      new AppConfigurationEntry(KerberosUtil.getKrb5LoginModuleName(),
-                                LoginModuleControlFlag.REQUIRED,
-                                KEYTAB_KERBEROS_OPTIONS);
-    
-    private static final AppConfigurationEntry[] SIMPLE_CONF = 
-      new AppConfigurationEntry[]{OS_SPECIFIC_LOGIN, HADOOP_LOGIN};
-    
-    private static final AppConfigurationEntry[] USER_KERBEROS_CONF =
-      new AppConfigurationEntry[]{OS_SPECIFIC_LOGIN, USER_KERBEROS_LOGIN,
-                                  HADOOP_LOGIN};
-
-    private static final AppConfigurationEntry[] KEYTAB_KERBEROS_CONF =
-      new AppConfigurationEntry[]{KEYTAB_KERBEROS_LOGIN, HADOOP_LOGIN};
-
-    @Override
-    public AppConfigurationEntry[] getAppConfigurationEntry(String appName) {
-      if (SIMPLE_CONFIG_NAME.equals(appName)) {
-        return SIMPLE_CONF;
-      } else if (USER_KERBEROS_CONFIG_NAME.equals(appName)) {
-        return USER_KERBEROS_CONF;
-      } else if (KEYTAB_KERBEROS_CONFIG_NAME.equals(appName)) {
-        if (IBM_JAVA) {
-          KEYTAB_KERBEROS_OPTIONS.put("useKeytab",
-              prependFileAuthority(keytabFile));
-        } else {
-          KEYTAB_KERBEROS_OPTIONS.put("keyTab", keytabFile);
-        }
-        KEYTAB_KERBEROS_OPTIONS.put("principal", keytabPrincipal);
-        return KEYTAB_KERBEROS_CONF;
-      }
-      return null;
-    }
-  }
-
-  private static String prependFileAuthority(String keytabPath) {
-    return keytabPath.startsWith("file://") ? keytabPath
-        : "file://" + keytabPath;
-  }
-
-  /**
-   * Represents a javax.security configuration that is created at runtime.
-   */
-  private static class DynamicConfiguration
-      extends javax.security.auth.login.Configuration {
-    private AppConfigurationEntry[] ace;
-    
-    DynamicConfiguration(AppConfigurationEntry[] ace) {
-      this.ace = ace;
-    }
-    
-    @Override
-    public AppConfigurationEntry[] getAppConfigurationEntry(String appName) {
-      return ace;
-    }
-  }
-
-  private static LoginContext
+  private static HadoopLoginContext
-    javax.security.auth.login.Configuration loginConf)
+                  HadoopConfiguration loginConf)
-      return new LoginContext(appName, subject, null, loginConf);
+      return new HadoopLoginContext(appName, subject, loginConf);
-  private LoginContext getLogin() {
-    return user.getLogin();
+  // return the LoginContext only if it's managed by the ugi.  externally
+  // managed login contexts will be ignored.
+  private HadoopLoginContext getLogin() {
+    LoginContext login = user.getLogin();
+    return (login instanceof HadoopLoginContext)
+      ? (HadoopLoginContext)login : null;
-  
+
-    this(subject, treatSubjectExternal);
-  }
-
-  /**
-   * Create a UGI from the given subject.
-   * @param subject the subject
-   * @param isLoginExternal if the subject's keytab is managed by other UGI.
-   *                       Setting this to true will prevent UGI from attempting
-   *                       to login the keytab, or to renew it.
-   */
-  private UserGroupInformation(Subject subject, final boolean isLoginExternal) {
+    // do not access ANY private credentials since they are mutable
+    // during a relogin.  no principal locking necessary since
+    // relogin/logout does not remove User principal.
-
-    this.isKeytab = KerberosUtil.hasKerberosKeyTab(subject);
-    this.isKrbTkt = KerberosUtil.hasKerberosTicket(subject);
-    this.isLoginExternal = isLoginExternal;
+    if (user == null || user.getName() == null) {
+      throw new IllegalStateException("Subject does not contain a valid User");
+    }
-  
+
-    return isKeytab || isKrbTkt;
+    return user.getAuthenticationMethod() == AuthenticationMethod.KERBEROS;
-  public synchronized
-  static UserGroupInformation getCurrentUser() throws IOException {
+  public static UserGroupInformation getCurrentUser() throws IOException {
-    try {
-      Map<String,String> krbOptions = new HashMap<String,String>();
-      if (IBM_JAVA) {
-        krbOptions.put("useDefaultCcache", "true");
-        // The first value searched when "useDefaultCcache" is used.
-        System.setProperty("KRB5CCNAME", ticketCache);
-      } else {
-        krbOptions.put("doNotPrompt", "true");
-        krbOptions.put("useTicketCache", "true");
-        krbOptions.put("useKeyTab", "false");
-        krbOptions.put("ticketCache", ticketCache);
-      }
-      krbOptions.put("renewTGT", "false");
-      krbOptions.putAll(HadoopConfiguration.BASIC_JAAS_OPTIONS);
-      AppConfigurationEntry ace = new AppConfigurationEntry(
-          KerberosUtil.getKrb5LoginModuleName(),
-          LoginModuleControlFlag.REQUIRED,
-          krbOptions);
-      DynamicConfiguration dynConf =
-          new DynamicConfiguration(new AppConfigurationEntry[]{ ace });
-      LoginContext login = newLoginContext(
-          HadoopConfiguration.USER_KERBEROS_CONFIG_NAME, null, dynConf);
-      login.login();
-
-      Subject loginSubject = login.getSubject();
-      Set<Principal> loginPrincipals = loginSubject.getPrincipals();
-      if (loginPrincipals.isEmpty()) {
-        throw new RuntimeException("No login principals found!");
-      }
-      if (loginPrincipals.size() != 1) {
-        LOG.warn("found more than one principal in the ticket cache file " +
-          ticketCache);
-      }
-      User ugiUser = new User(loginPrincipals.iterator().next().getName(),
-          AuthenticationMethod.KERBEROS, login);
-      loginSubject.getPrincipals().add(ugiUser);
-      UserGroupInformation ugi = new UserGroupInformation(loginSubject, false);
-      ugi.setLogin(login);
-      ugi.setAuthenticationMethod(AuthenticationMethod.KERBEROS);
-      return ugi;
-    } catch (LoginException le) {
-      KerberosAuthException kae =
-          new KerberosAuthException(FAILURE_TO_LOGIN, le);
-      kae.setUser(user);
-      kae.setTicketCacheFile(ticketCache);
-      throw kae;
-    }
+    LoginParams params = new LoginParams();
+    params.put(LoginParam.PRINCIPAL, user);
+    params.put(LoginParam.CCACHE, ticketCache);
+    return doSubjectLogin(null, params);
-    KerberosPrincipal principal =
-        subject.getPrincipals(KerberosPrincipal.class).iterator().next();
-
-    User ugiUser = new User(principal.getName(),
-        AuthenticationMethod.KERBEROS, null);
-    subject.getPrincipals().add(ugiUser);
-    UserGroupInformation ugi = new UserGroupInformation(subject);
-    ugi.setLogin(null);
-    ugi.setAuthenticationMethod(AuthenticationMethod.KERBEROS);
-    return ugi;
+    // null params indicate external subject login.  no login context will
+    // be attached.
+    return doSubjectLogin(subject, null);
-   * Get the currently logged in user.
+   * Get the currently logged in user.  If no explicit login has occurred,
+   * the user will automatically be logged in with either kerberos credentials
+   * if available, or as the local OS user, based on security settings.
-  public synchronized 
-  static UserGroupInformation getLoginUser() throws IOException {
+  public static UserGroupInformation getLoginUser() throws IOException {
+    UserGroupInformation loginUser = loginUserRef.get();
+    // a potential race condition exists only for the initial creation of
+    // the login user.  there's no need to penalize all subsequent calls
+    // with sychronization overhead so optimistically create a login user
+    // and discard if we lose the race.
-      loginUserFromSubject(null);
+      UserGroupInformation newLoginUser = createLoginUser(null);
+      do {
+        // it's extremely unlikely that the login user will be non-null
+        // (lost CAS race), but be nulled before the subsequent get, but loop
+        // for correctness.
+        if (loginUserRef.compareAndSet(null, newLoginUser)) {
+          loginUser = newLoginUser;
+          // only spawn renewal if this login user is the winner.
+          loginUser.spawnAutoRenewalThreadForUserCreds(false);
+        } else {
+          loginUser = loginUserRef.get();
+        }
+      } while (loginUser == null);
-  public synchronized 
-  static void loginUserFromSubject(Subject subject) throws IOException {
-    ensureInitialized();
-    boolean externalSubject = false;
-    try {
-      if (subject == null) {
-        subject = new Subject();
-      } else {
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Treat subject external: " + treatSubjectExternal
-              + ". When true, assuming keytab is managed extenally since "
-              + " logged in from subject");
-        }
-        externalSubject = treatSubjectExternal;
-      }
-      LoginContext login =
-          newLoginContext(authenticationMethod.getLoginAppName(), 
-                          subject, new HadoopConfiguration());
-      login.login();
+  public static void loginUserFromSubject(Subject subject) throws IOException {
+    setLoginUser(createLoginUser(subject));
+  }
-      UserGroupInformation realUser =
-          new UserGroupInformation(subject, externalSubject);
-      realUser.setLogin(login);
-      realUser.setAuthenticationMethod(authenticationMethod);
+  private static
+  UserGroupInformation createLoginUser(Subject subject) throws IOException {
+    UserGroupInformation realUser = doSubjectLogin(subject, null);
+    UserGroupInformation loginUser = null;
+    try {
-      loginUser.spawnAutoRenewalThreadForUserCreds();
-    } catch (LoginException le) {
-      LOG.debug("failure to login", le);
-      throw new KerberosAuthException(FAILURE_TO_LOGIN, le);
+    } catch (IOException ioe) {
+      LOG.debug("failure to load login credentials", ioe);
+      throw ioe;
-    } 
+    }
+    return loginUser;
-  public synchronized static void setLoginUser(UserGroupInformation ugi) {
+  public static void setLoginUser(UserGroupInformation ugi) {
-    loginUser = ugi;
+    loginUserRef.set(ugi);
+  private String getKeytab() {
+    HadoopLoginContext login = getLogin();
+    return (login != null)
+      ? login.getConfiguration().getParameters().get(LoginParam.KEYTAB)
+      : null;
+  }
+
-   * Is this user logged in from a keytab file?
+   * Is the ugi managed by the UGI or an external subject?
+   * @return true if managed by UGI.
+   */
+  private boolean isHadoopLogin() {
+    // checks if the private hadoop login context is managing the ugi.
+    return getLogin() != null;
+  }
+
+  /**
+   * Is this user logged in from a keytab file managed by the UGI?
-    return isKeytab;
+    // can't simply check if keytab is present since a relogin failure will
+    // have removed the keytab from priv creds.  instead, check login params.
+    return hasKerberosCredentials() && isHadoopLogin() && getKeytab() != null;
+   *  Is this user logged in from a ticket (but no keytab) managed by the UGI?
+   * @return true if the credentials are from a ticket cache.
+   */
+  private boolean isFromTicket() {
+    return hasKerberosCredentials() && isHadoopLogin() && getKeytab() == null;
+  }
+
+  /**
-  private synchronized KerberosTicket getTGT() {
+  private KerberosTicket getTGT() {
-  /**
-   * Should relogin if security is enabled using Kerberos, and
-   * the Subject is not owned by another UGI.
-   * @return true if this UGI should relogin
-   */
-    return isSecurityEnabled()
-        && user.getAuthenticationMethod() == AuthenticationMethod.KERBEROS
-        && !isLoginExternal;
+    return hasKerberosCredentials() && isHadoopLogin();
-  /**Spawn a thread to do periodic renewals of kerberos credentials*/
-  private void spawnAutoRenewalThreadForUserCreds() {
-    if (getEnableRenewThreadCreationForTest()) {
-      LOG.warn("Spawning thread to auto renew user credential since " +
-          " enableRenewThreadCreationForTest was set to true.");
-    } else if (!shouldRelogin() || isKeytab) {
+  @InterfaceAudience.Private
+  @InterfaceStability.Unstable
+  @VisibleForTesting
+  /**
+   * Spawn a thread to do periodic renewals of kerberos credentials from
+   * a ticket cache.  NEVER directly call this method.
+   * @param force - used by tests to forcibly spawn thread
+   */
+  void spawnAutoRenewalThreadForUserCreds(boolean force) {
+    if (!force && (!shouldRelogin() || isFromKeytab())) {
-  public synchronized
+  public
-    keytabFile = path;
-    keytabPrincipal = user;
-    Subject subject = new Subject();
-    LoginContext login; 
-    long start = 0;
-    try {
-      login = newLoginContext(HadoopConfiguration.KEYTAB_KERBEROS_CONFIG_NAME,
-            subject, new HadoopConfiguration());
-      start = Time.now();
-      login.login();
-      metrics.loginSuccess.add(Time.now() - start);
-      loginUser = new UserGroupInformation(subject, false);
-      loginUser.setLogin(login);
-      loginUser.setAuthenticationMethod(AuthenticationMethod.KERBEROS);
-    } catch (LoginException le) {
-      if (start > 0) {
-        metrics.loginFailure.add(Time.now() - start);
-      }
-      KerberosAuthException kae = new KerberosAuthException(LOGIN_FAILURE, le);
-      kae.setUser(user);
-      kae.setKeytabFile(path);
-      throw kae;
-    }
-    LOG.info("Login successful for user " + keytabPrincipal
-        + " using keytab file " + keytabFile);
+    setLoginUser(loginUserFromKeytabAndReturnUGI(user, path));
+    LOG.info("Login successful for user " + user
+        + " using keytab file " + path);
-    if (!isSecurityEnabled() ||
-        user.getAuthenticationMethod() != AuthenticationMethod.KERBEROS) {
+    if (!hasKerberosCredentials()) {
-    LoginContext login = getLogin();
+    HadoopLoginContext login = getLogin();
+    String keytabFile = getKeytab();
-      synchronized (UserGroupInformation.class) {
-        login.logout();
-      }
+      // hadoop login context internally locks credentials.
+      login.logout();
-    LOG.info("Logout successful for user " + keytabPrincipal
+    LOG.info("Logout successful for user " + getUserName()
-  public synchronized void checkTGTAndReloginFromKeytab() throws IOException {
-    if (!isSecurityEnabled()
-        || user.getAuthenticationMethod() != AuthenticationMethod.KERBEROS
-        || !isKeytab) {
-      return;
-    }
-    KerberosTicket tgt = getTGT();
-    if (tgt != null && !shouldRenewImmediatelyForTests &&
-        Time.now() < getRefreshTime(tgt)) {
-      return;
-    }
-    reloginFromKeytab();
+  public void checkTGTAndReloginFromKeytab() throws IOException {
+    reloginFromKeytab(true);
-  public synchronized void reloginFromKeytab() throws IOException {
-    if (!shouldRelogin() || !isKeytab) {
+  public void reloginFromKeytab() throws IOException {
+    reloginFromKeytab(false);
+  }
+
+  private void reloginFromKeytab(boolean checkTGT) throws IOException {
+    if (!shouldRelogin() || !isFromKeytab()) {
-
-    long now = Time.now();
-    if (!shouldRenewImmediatelyForTests && !hasSufficientTimeElapsed(now)) {
-      return;
-    }
-
-    KerberosTicket tgt = getTGT();
-    //Return if TGT is valid and is not going to expire soon.
-    if (tgt != null && !shouldRenewImmediatelyForTests &&
-        now < getRefreshTime(tgt)) {
-      return;
-    }
-
-    LoginContext login = getLogin();
-    if (login == null || keytabFile == null) {
+    HadoopLoginContext login = getLogin();
+    if (login == null) {
-
-    long start = 0;
-    // register most recent relogin attempt
-    user.setLastLogin(now);
-    try {
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Initiating logout for " + getUserName());
+    if (checkTGT) {
+      KerberosTicket tgt = getTGT();
+      if (tgt != null && !shouldRenewImmediatelyForTests &&
+        Time.now() < getRefreshTime(tgt)) {
+        return;
-      synchronized (UserGroupInformation.class) {
-        // clear up the kerberos state. But the tokens are not cleared! As per
-        // the Java kerberos login module code, only the kerberos credentials
-        // are cleared
-        login.logout();
-        // login and also update the subject field of this instance to
-        // have the new credentials (pass it to the LoginContext constructor)
-        login = newLoginContext(
-            HadoopConfiguration.KEYTAB_KERBEROS_CONFIG_NAME, getSubject(),
-            new HadoopConfiguration());
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("Initiating re-login for " + keytabPrincipal);
-        }
-        start = Time.now();
-        login.login();
-        fixKerberosTicketOrder();
-        metrics.loginSuccess.add(Time.now() - start);
-        setLogin(login);
-      }
-    } catch (LoginException le) {
-      if (start > 0) {
-        metrics.loginFailure.add(Time.now() - start);
-      }
-      KerberosAuthException kae = new KerberosAuthException(LOGIN_FAILURE, le);
-      kae.setPrincipal(keytabPrincipal);
-      kae.setKeytabFile(keytabFile);
-      throw kae;
+    relogin(login);
-  public synchronized void reloginFromTicketCache() throws IOException {
-    if (!shouldRelogin() || !isKrbTkt) {
+  public void reloginFromTicketCache() throws IOException {
+    if (!shouldRelogin() || !isFromTicket()) {
-    LoginContext login = getLogin();
+    HadoopLoginContext login = getLogin();
+    relogin(login);
+  }
+
+  private void relogin(HadoopLoginContext login) throws IOException {
+    // ensure the relogin is atomic to avoid leaving credentials in an
+    // inconsistent state.  prevents other ugi instances, SASL, and SPNEGO
+    // from accessing or altering credentials during the relogin.
+    synchronized(login.getSubjectLock()) {
+      // another racing thread may have beat us to the relogin.
+      if (login == getLogin()) {
+        unprotectedRelogin(login);
+      }
+    }
+  }
+
+  private void unprotectedRelogin(HadoopLoginContext login) throws IOException {
+    assert Thread.holdsLock(login.getSubjectLock());
-      login = 
-        newLoginContext(HadoopConfiguration.USER_KERBEROS_CONFIG_NAME, 
-            getSubject(), new HadoopConfiguration());
+      login = newLoginContext(
+        login.getAppName(), login.getSubject(), login.getConfiguration());
+      // this should be unnecessary.  originally added due to improper locking
+      // of the subject during relogin.
-  public synchronized
+  public
-    String oldKeytabFile = null;
-    String oldKeytabPrincipal = null;
-    long start = 0;
-    try {
-      oldKeytabFile = keytabFile;
-      oldKeytabPrincipal = keytabPrincipal;
-      keytabFile = path;
-      keytabPrincipal = user;
-      Subject subject = new Subject();
-      
-      LoginContext login = newLoginContext(
-          HadoopConfiguration.KEYTAB_KERBEROS_CONFIG_NAME, subject,
-          new HadoopConfiguration());
-       
-      start = Time.now();
-      login.login();
-      metrics.loginSuccess.add(Time.now() - start);
-      UserGroupInformation newLoginUser =
-          new UserGroupInformation(subject, false);
-      newLoginUser.setLogin(login);
-      newLoginUser.setAuthenticationMethod(AuthenticationMethod.KERBEROS);
-      
-      return newLoginUser;
-    } catch (LoginException le) {
-      if (start > 0) {
-        metrics.loginFailure.add(Time.now() - start);
-      }
-      KerberosAuthException kae = new KerberosAuthException(LOGIN_FAILURE, le);
-      kae.setUser(user);
-      kae.setKeytabFile(path);
-      throw kae;
-    } finally {
-      if(oldKeytabFile != null) keytabFile = oldKeytabFile;
-      if(oldKeytabPrincipal != null) keytabPrincipal = oldKeytabPrincipal;
-    }
+    LoginParams params = new LoginParams();
+    params.put(LoginParam.PRINCIPAL, user);
+    params.put(LoginParam.KEYTAB, path);
+    return doSubjectLogin(null, params);
-    if (now - user.getLastLogin() < kerberosMinSecondsBeforeRelogin ) {
+    if (!shouldRenewImmediatelyForTests &&
+        now - user.getLastLogin() < kerberosMinSecondsBeforeRelogin ) {
-  public synchronized static boolean isLoginKeytabBased() throws IOException {
-    return getLoginUser().isKeytab;
+  public static boolean isLoginKeytabBased() throws IOException {
+    return getLoginUser().isFromKeytab();
-    return getLoginUser().isKrbTkt;
+    return getLoginUser().isFromTicket();
-    UserGroupInformation result = new UserGroupInformation(subject, false);
+    UserGroupInformation result = new UserGroupInformation(subject);
-        HadoopConfiguration.USER_KERBEROS_CONFIG_NAME),
+        HadoopConfiguration.KERBEROS_CONFIG_NAME),
-    principals.add(new User(user));
+    principals.add(new User(user, AuthenticationMethod.PROXY, null));
-    UserGroupInformation result =new UserGroupInformation(subject, false);
-    result.setAuthenticationMethod(AuthenticationMethod.PROXY);
-    return result;
+    return new UserGroupInformation(subject);
+   * Login a subject with the given parameters.  If the subject is null,
+   * the login context used to create the subject will be attached.
+   * @param subject to login, null for new subject.
+   * @param params for login, null for externally managed ugi.
+   * @return UserGroupInformation for subject
+   * @throws IOException
+   */
+  private static UserGroupInformation doSubjectLogin(
+      Subject subject, LoginParams params) throws IOException {
+    ensureInitialized();
+    // initial default login.
+    if (subject == null && params == null) {
+      params = LoginParams.getDefaults();
+    }
+    HadoopConfiguration loginConf = new HadoopConfiguration(params);
+    try {
+      HadoopLoginContext login = newLoginContext(
+        authenticationMethod.getLoginAppName(), subject, loginConf);
+      login.login();
+      UserGroupInformation ugi = new UserGroupInformation(login.getSubject());
+      // attach login context for relogin unless this was a pre-existing
+      // subject.
+      if (subject == null) {
+        params.put(LoginParam.PRINCIPAL, ugi.getUserName());
+        ugi.setLogin(login);
+      }
+      return ugi;
+    } catch (LoginException le) {
+      KerberosAuthException kae =
+        new KerberosAuthException(FAILURE_TO_LOGIN, le);
+      if (params != null) {
+        kae.setPrincipal(params.get(LoginParam.PRINCIPAL));
+        kae.setKeytabFile(params.get(LoginParam.KEYTAB));
+        kae.setTicketCacheFile(params.get(LoginParam.CCACHE));
+      }
+      throw kae;
+    }
+  }
+
+  // parameters associated with kerberos logins.  may be extended to support
+  // additional authentication methods.
+  enum LoginParam {
+    PRINCIPAL,
+    KEYTAB,
+    CCACHE,
+  }
+
+  // explicitly private to prevent external tampering.
+  private static class LoginParams extends EnumMap<LoginParam,String>
+      implements Parameters {
+    LoginParams() {
+      super(LoginParam.class);
+    }
+
+    // do not add null values, nor allow existing values to be overriden.
+    @Override
+    public String put(LoginParam param, String val) {
+      boolean add = val != null && !containsKey(param);
+      return add ? super.put(param, val) : null;
+    }
+
+    static LoginParams getDefaults() {
+      LoginParams params = new LoginParams();
+      params.put(LoginParam.PRINCIPAL, System.getenv("KRB5PRINCIPAL"));
+      params.put(LoginParam.KEYTAB, System.getenv("KRB5KEYTAB"));
+      params.put(LoginParam.CCACHE, System.getenv("KRB5CCNAME"));
+      return params;
+    }
+  }
+
+  // wrapper to allow access to fields necessary to recreate the same login
+  // context for relogin.  explicitly private to prevent external tampering.
+  private static class HadoopLoginContext extends LoginContext {
+    private final String appName;
+    private final HadoopConfiguration conf;
+
+    HadoopLoginContext(String appName, Subject subject,
+                       HadoopConfiguration conf) throws LoginException {
+      super(appName, subject, null, conf);
+      this.appName = appName;
+      this.conf = conf;
+    }
+
+    String getAppName() {
+      return appName;
+    }
+
+    HadoopConfiguration getConfiguration() {
+      return conf;
+    }
+
+    // the locking model for logins cannot rely on ugi instance synchronization
+    // since a subject will be referenced by multiple ugi instances.
+    Object getSubjectLock() {
+      Subject subject = getSubject();
+      // if subject is null, the login context will create the subject
+      // so just lock on this context.
+      return (subject == null) ? this : subject.getPrivateCredentials();
+    }
+
+    @Override
+    public void login() throws LoginException {
+      synchronized(getSubjectLock()) {
+        MutableRate metric = metrics.loginFailure;
+        long start = Time.monotonicNow();
+        try {
+          super.login();
+          metric = metrics.loginSuccess;
+        } finally {
+          metric.add(Time.monotonicNow() - start);
+        }
+      }
+    }
+
+    @Override
+    public void logout() throws LoginException {
+      synchronized(getSubjectLock()) {
+        super.logout();
+      }
+    }
+  }
+
+  /**
+   * A JAAS configuration that defines the login modules that we want
+   * to use for login.
+   */
+  @InterfaceAudience.Private
+  @InterfaceStability.Unstable
+  private static class HadoopConfiguration
+  extends javax.security.auth.login.Configuration {
+    static final String KRB5_LOGIN_MODULE =
+        KerberosUtil.getKrb5LoginModuleName();
+    static final String SIMPLE_CONFIG_NAME = "hadoop-simple";
+    static final String KERBEROS_CONFIG_NAME = "hadoop-kerberos";
+
+    private static final Map<String, String> BASIC_JAAS_OPTIONS =
+        new HashMap<String,String>();
+    static {
+      if ("true".equalsIgnoreCase(System.getenv("HADOOP_JAAS_DEBUG"))) {
+        BASIC_JAAS_OPTIONS.put("debug", "true");
+      }
+    }
+
+    static final AppConfigurationEntry OS_SPECIFIC_LOGIN =
+        new AppConfigurationEntry(
+            OS_LOGIN_MODULE_NAME,
+            LoginModuleControlFlag.REQUIRED,
+            BASIC_JAAS_OPTIONS);
+
+    static final AppConfigurationEntry HADOOP_LOGIN =
+        new AppConfigurationEntry(
+            HadoopLoginModule.class.getName(),
+            LoginModuleControlFlag.REQUIRED,
+            BASIC_JAAS_OPTIONS);
+
+    private final LoginParams params;
+
+    HadoopConfiguration(LoginParams params) {
+      this.params = params;
+    }
+
+    @Override
+    public LoginParams getParameters() {
+      return params;
+    }
+
+    @Override
+    public AppConfigurationEntry[] getAppConfigurationEntry(String appName) {
+      ArrayList<AppConfigurationEntry> entries = new ArrayList<>();
+      // login of external subject passes no params.  technically only
+      // existing credentials should be used but other components expect
+      // the login to succeed with local user fallback if no principal.
+      if (params == null || appName.equals(SIMPLE_CONFIG_NAME)) {
+        entries.add(OS_SPECIFIC_LOGIN);
+      } else if (appName.equals(KERBEROS_CONFIG_NAME)) {
+        // existing semantics are the initial default login allows local user
+        // fallback. this is not allowed when a principal explicitly
+        // specified or during a relogin.
+        if (!params.containsKey(LoginParam.PRINCIPAL)) {
+          entries.add(OS_SPECIFIC_LOGIN);
+        }
+        entries.add(getKerberosEntry());
+      }
+      entries.add(HADOOP_LOGIN);
+      return entries.toArray(new AppConfigurationEntry[0]);
+    }
+
+    private AppConfigurationEntry getKerberosEntry() {
+      final Map<String,String> options = new HashMap<>(BASIC_JAAS_OPTIONS);
+      LoginModuleControlFlag controlFlag = LoginModuleControlFlag.OPTIONAL;
+      // kerberos login is mandatory if principal is specified.  principal
+      // will not be set for initial default login, but will always be set
+      // for relogins.
+      final String principal = params.get(LoginParam.PRINCIPAL);
+      if (principal != null) {
+        options.put("principal", principal);
+        controlFlag = LoginModuleControlFlag.REQUIRED;
+      }
+
+      // use keytab if given else fallback to ticket cache.
+      if (IBM_JAVA) {
+        if (params.containsKey(LoginParam.KEYTAB)) {
+          final String keytab = params.get(LoginParam.KEYTAB);
+          if (keytab != null) {
+            options.put("useKeytab", prependFileAuthority(keytab));
+          } else {
+            options.put("useDefaultKeytab", "true");
+          }
+          options.put("credsType", "both");
+        } else {
+          String ticketCache = params.get(LoginParam.CCACHE);
+          if (ticketCache != null) {
+            options.put("useCcache", prependFileAuthority(ticketCache));
+          } else {
+            options.put("useDefaultCcache", "true");
+          }
+          options.put("renewTGT", "true");
+        }
+      } else {
+        if (params.containsKey(LoginParam.KEYTAB)) {
+          options.put("useKeyTab", "true");
+          final String keytab = params.get(LoginParam.KEYTAB);
+          if (keytab != null) {
+            options.put("keyTab", keytab);
+          }
+          options.put("storeKey", "true");
+        } else {
+          options.put("useTicketCache", "true");
+          String ticketCache = params.get(LoginParam.CCACHE);
+          if (ticketCache != null) {
+            options.put("ticketCache", ticketCache);
+          }
+          options.put("renewTGT", "true");
+        }
+        options.put("doNotPrompt", "true");
+      }
+      options.put("refreshKrb5Config", "true");
+
+      return new AppConfigurationEntry(
+          KRB5_LOGIN_MODULE, controlFlag, options);
+    }
+
+    private static String prependFileAuthority(String keytabPath) {
+      return keytabPath.startsWith("file://")
+          ? keytabPath
+          : "file://" + keytabPath;
+    }
+  }
+
+  /**
-    System.out.println("Keytab " + ugi.isKeytab);
+    System.out.println("Keytab " + ugi.isFromKeytab());
-      System.out.println("Auth method " + loginUser.user.getAuthenticationMethod());
-      System.out.println("Keytab " + loginUser.isKeytab);
+      UserGroupInformation loginUgi = getLoginUser();
+      System.out.println("Auth method " + loginUgi.getAuthenticationMethod());
+      System.out.println("Keytab " + loginUgi.isFromKeytab());

HDFS-8979. Clean up checkstyle warnings in hadoop-hdfs-client module. Contributed by Mingliang Liu.

- * in case any issues spring up with the new {@link RemoteBlockReader2} implementation.
+ * in case any issues spring up with the new {@link RemoteBlockReader2}
+ * implementation.
-      if startOffset is not chunk-aligned */
+   if startOffset is not chunk-aligned */
-  
+
-  
+
-  
+
-  
+
-  
+
-  public synchronized int read(byte[] buf, int off, int len) 
-                               throws IOException {
-    
+  public synchronized int read(byte[] buf, int off, int len)
+      throws IOException {
+
-    
+
-     * in majority of the cases?. This one throws. */  
+     * in majority of the cases?. This one throws. */
-                          "Use read(buf, off, len) instead.");
+        "Use read(buf, off, len) instead.");
-  
+
-    /* Checksum errors are handled outside the BlockReader. 
-     * DFSInputStream does not always call 'seekToNewSource'. In the 
+    /* Checksum errors are handled outside the BlockReader.
+     * DFSInputStream does not always call 'seekToNewSource'. In the
-     */ 
+     */
-  
+
-                               "since seek is not required");
+        "since seek is not required");
-  
+
-   * Makes sure that checksumBytes has enough capacity 
-   * and limit is set to the number of checksum bytes needed 
+   * Makes sure that checksumBytes has enough capacity
+   * and limit is set to the number of checksum bytes needed
-    int requiredSize = 
-      ((dataLen + bytesPerChecksum - 1)/bytesPerChecksum)*checksumSize;
+    int requiredSize =
+        ((dataLen + bytesPerChecksum - 1)/bytesPerChecksum)*checksumSize;
-  
+
-  protected synchronized int readChunk(long pos, byte[] buf, int offset, 
-                                       int len, byte[] checksumBuf) 
-                                       throws IOException {
-    TraceScope scope = tracer.
-        newScope("RemoteBlockReader#readChunk(" + blockId + ")");
-    try {
+  protected synchronized int readChunk(long pos, byte[] buf, int offset,
+      int len, byte[] checksumBuf)
+      throws IOException {
+    try (TraceScope ignored = tracer.newScope(
+        "RemoteBlockReader#readChunk(" + blockId + ")")) {
-    } finally {
-      scope.close();
-                                     int len, byte[] checksumBuf)
-                                     throws IOException {
+      int len, byte[] checksumBuf)
+      throws IOException {
-    
+
-    
+
-      throw new IOException("Mismatch in pos : " + pos + " + " + 
-                            firstChunkOffset + " != " + chunkOffset);
+      throw new IOException("Mismatch in pos : " + pos + " + " +
+          firstChunkOffset + " != " + chunkOffset);
-           throw new IOException("BlockReader: error in packet header " +
-                                 header);
+        throw new IOException("BlockReader: error in packet header " +
+            header);
-                          checksumBytes.limit());
+            checksumBytes.limit());
-                                  checksumBuf.length / checksumSize);
+          checksumBuf.length / checksumSize);
-        checksumsToRead * bytesPerChecksum, // full chunks
-        dataLeft); // in case we have a partial
+          checksumsToRead * bytesPerChecksum, // full chunks
+          dataLeft); // in case we have a partial
-                              hdr);
+            hdr);
-  
+
-                    ":" + bpid + ":of:"+ file)/*too non path-like?*/,
-          1, verifyChecksum,
-          checksum.getChecksumSize() > 0? checksum : null, 
-          checksum.getBytesPerChecksum(),
-          checksum.getChecksumSize());
+            ":" + bpid + ":of:"+ file)/*too non path-like?*/,
+        1, verifyChecksum,
+        checksum.getChecksumSize() > 0? checksum : null,
+        checksum.getBytesPerChecksum(),
+        checksum.getChecksumSize());
-    
+
-                                     ExtendedBlock block, 
-                                     Token<BlockTokenIdentifier> blockToken,
-                                     long startOffset, long len,
-                                     int bufferSize, boolean verifyChecksum,
-                                     String clientName, Peer peer,
-                                     DatanodeID datanodeID,
-                                     PeerCache peerCache,
-                                     CachingStrategy cachingStrategy,
-                                     Tracer tracer)
-                                       throws IOException {
+      ExtendedBlock block,
+      Token<BlockTokenIdentifier> blockToken,
+      long startOffset, long len,
+      int bufferSize, boolean verifyChecksum,
+      String clientName, Peer peer,
+      DatanodeID datanodeID,
+      PeerCache peerCache,
+      CachingStrategy cachingStrategy,
+      Tracer tracer)
+      throws IOException {
-    
+
-    
+
-      status.getReadOpChecksumInfo();
+        status.getReadOpChecksumInfo();
-    
+
-    
+
-                            firstChunkOffset + ") startOffset is " + 
-                            startOffset + " for file " + file);
+          firstChunkOffset + ") startOffset is " +
+          startOffset + " for file " + file);
-  
+
-               peer.getRemoteAddressString() + ": " + e.getMessage());
+          peer.getRemoteAddressString() + ": " + e.getMessage());
-  
+
-  public int available() throws IOException {
+  public int available() {
-  
+

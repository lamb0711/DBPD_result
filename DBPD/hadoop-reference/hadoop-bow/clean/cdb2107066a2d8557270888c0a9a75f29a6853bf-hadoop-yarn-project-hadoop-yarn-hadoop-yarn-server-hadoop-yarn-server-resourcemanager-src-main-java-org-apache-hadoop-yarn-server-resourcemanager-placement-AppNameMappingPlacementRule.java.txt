YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.

-import static org.apache.hadoop.yarn.server.resourcemanager.placement.QueuePlacementRuleUtils.extractQueuePath;
+  protected CapacitySchedulerQueueManager queueManager;
-    CapacitySchedulerQueueManager queueManager =
-        schedulerContext.getCapacitySchedulerQueueManager();
+    queueManager = schedulerContext.getCapacitySchedulerQueueManager();
+      QueuePath queuePath = mapping.getQueuePath();
-      QueuePath queuePath = extractQueuePath(mapping.getQueue());
-        //Try getting queue by its leaf queue name
-        // without splitting into parent/leaf queues
-        CSQueue queue = queueManager.getQueue(mapping.getQueue());
-        if (ifQueueDoesNotExist(queue)) {
-          //Try getting the queue by extracting leaf and parent queue names
-          //Assuming its a potential auto created leaf queue
-          queue = queueManager.getQueue(queuePath.getLeafQueue());
+        //at this point mapping.getQueueName() return only the queue name, since
+        //the config parsing have been changed making QueueMapping more
+        //consistent
-          if (ifQueueDoesNotExist(queue)) {
-            //if leaf queue does not exist,
-            // this could be a potential auto created leaf queue
-            //validate if parent queue is specified,
-            // then it should exist and
-            // be an instance of AutoCreateEnabledParentQueue
-            QueueMappingEntity newMapping =
-                validateAndGetAutoCreatedQueueMapping(queueManager, mapping,
-                    queuePath);
-            if (newMapping == null) {
-              throw new IOException(
-                  "mapping contains invalid or non-leaf queue " + mapping
-                      .getQueue());
-            }
-            newMappings.add(newMapping);
-          } else{
-            QueueMappingEntity newMapping = validateAndGetQueueMapping(
-                queueManager, queue, mapping, queuePath);
-            newMappings.add(newMapping);
+        CSQueue queue = queueManager.getQueue(mapping.getFullPath());
+        if (ifQueueDoesNotExist(queue)) {
+          //Try getting queue by its full path name, if it exists it is a static
+          //leaf queue indeed, without any auto creation magic
+
+          if (queueManager.isAmbiguous(queuePath.getFullPath())) {
+            throw new IOException(
+              "mapping contains ambiguous leaf queue reference " + mapping
+                .getFullPath());
-        } else{
+
+          //if leaf queue does not exist,
+          // this could be a potential auto created leaf queue
+          //validate if parent queue is specified,
+          // then it should exist and
+          // be an instance of AutoCreateEnabledParentQueue
+          QueueMappingEntity newMapping =
+              validateAndGetAutoCreatedQueueMapping(queueManager, mapping,
+                  queuePath);
+          if (newMapping == null) {
+            throw new IOException(
+                "mapping contains invalid or non-leaf queue " + mapping
+                    .getQueue());
+          }
+          newMappings.add(newMapping);
+        } else {
-      } else{
+      } else {
-          return getPlacementContext(mapping, applicationName);
+          return getPlacementContext(mapping, applicationName, queueManager);
-          return getPlacementContext(mapping);
+          return getPlacementContext(mapping, queueManager);
-        return getPlacementContext(mapping);
+        return getPlacementContext(mapping, queueManager);

YARN-7557. It should be possible to specify resource types in the fair scheduler increment value (grepas via rkanter)

+import static org.apache.hadoop.yarn.util.resource.ResourceUtils.RESOURCE_REQUEST_VALUE_PATTERN;
+
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.hadoop.yarn.api.records.ResourceInformation;
+import org.apache.hadoop.yarn.util.UnitsConversionUtil;
-  
-  /** Increment request grant-able by the RM scheduler. 
-   * These properties are looked up in the yarn-site.xml  */
+
+  /** Increment request grant-able by the RM scheduler.
+   * These properties are looked up in the yarn-site.xml.
+   * Kept for backward-compatibility - the new preferred way to configure the
+   * increment is the yarn.resource-types.{RESOURCE_NAME}.increment-allocation
+   * property, specifically: yarn.resource-types.memory-mb.increment-allocation
+   * for memory and yarn.resource-types.vcores.increment-allocation for CPU */
+  @Deprecated
+  @Deprecated
+   * Postfix for resource allocation increments in the
+   * yarn.resource-types.{RESOURCE_NAME}.increment-allocation property.
+   */
+  static final String INCREMENT_ALLOCATION = ".increment-allocation";
+
+  /**
-    int incrementMemory = getInt(
-      RM_SCHEDULER_INCREMENT_ALLOCATION_MB,
-      DEFAULT_RM_SCHEDULER_INCREMENT_ALLOCATION_MB);
-    int incrementCores = getInt(
-      RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES,
-      DEFAULT_RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES);
-    return Resources.createResource(incrementMemory, incrementCores);
+    Long memory = null;
+    Integer vCores = null;
+    Map<String, Long> others = new HashMap<>();
+    ResourceInformation[] resourceTypes = ResourceUtils.getResourceTypesArray();
+    for (int i=0; i < resourceTypes.length; ++i) {
+      String name = resourceTypes[i].getName();
+      String propertyKey = getAllocationIncrementPropKey(name);
+      String propValue = get(propertyKey);
+      if (propValue != null) {
+        Matcher matcher = RESOURCE_REQUEST_VALUE_PATTERN.matcher(propValue);
+        if (matcher.matches()) {
+          long value = Long.parseLong(matcher.group(1));
+          String unit = matcher.group(2);
+          long valueInDefaultUnits = getValueInDefaultUnits(value, unit, name);
+          others.put(name, valueInDefaultUnits);
+        } else {
+          throw new IllegalArgumentException("Property " + propertyKey +
+              " is not in \"value [unit]\" format: " + propValue);
+        }
+      }
+    }
+    if (others.containsKey(ResourceInformation.MEMORY_MB.getName())) {
+      memory = others.get(ResourceInformation.MEMORY_MB.getName());
+      if (get(RM_SCHEDULER_INCREMENT_ALLOCATION_MB) != null) {
+        String overridingKey = getAllocationIncrementPropKey(
+                ResourceInformation.MEMORY_MB.getName());
+        LOG.warn("Configuration " + overridingKey + "=" + get(overridingKey) +
+            " is overriding the " + RM_SCHEDULER_INCREMENT_ALLOCATION_MB +
+            "=" + get(RM_SCHEDULER_INCREMENT_ALLOCATION_MB) + " property");
+      }
+      others.remove(ResourceInformation.MEMORY_MB.getName());
+    } else {
+      memory = getLong(
+          RM_SCHEDULER_INCREMENT_ALLOCATION_MB,
+          DEFAULT_RM_SCHEDULER_INCREMENT_ALLOCATION_MB);
+    }
+    if (others.containsKey(ResourceInformation.VCORES.getName())) {
+      vCores = others.get(ResourceInformation.VCORES.getName()).intValue();
+      if (get(RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES) != null) {
+        String overridingKey = getAllocationIncrementPropKey(
+            ResourceInformation.VCORES.getName());
+        LOG.warn("Configuration " + overridingKey + "=" + get(overridingKey) +
+            " is overriding the " + RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES +
+            "=" + get(RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES) + " property");
+      }
+      others.remove(ResourceInformation.VCORES.getName());
+    } else {
+      vCores = getInt(
+          RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES,
+          DEFAULT_RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES);
+    }
+    return Resource.newInstance(memory, vCores, others);
+  }
+
+  private long getValueInDefaultUnits(long value, String unit,
+      String resourceName) {
+    return unit.isEmpty() ? value : UnitsConversionUtil.convert(unit,
+        ResourceUtils.getDefaultUnit(resourceName), value);
+  }
+
+  private String getAllocationIncrementPropKey(String resourceName) {
+    return YarnConfiguration.RESOURCE_TYPES + "." + resourceName +
+        INCREMENT_ALLOCATION;

YARN-7644. NM gets backed up deleting docker containers. Contributed by Chandni Singh

-import org.apache.hadoop.yarn.server.nodemanager.ContainerExecutor.DelayedProcessKiller;
-import org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.runtime.DockerLinuxContainerRuntime;
-  private static final String EXIT_CODE_FILE_SUFFIX = ".exitcode";
+  static final String EXIT_CODE_FILE_SUFFIX = ".exitcode";
-  private long sleepDelayBeforeSigKill = 250;
-    this.sleepDelayBeforeSigKill =
-        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,
-            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS);
+  void reapContainer() throws IOException {
+    containerExecLock.lock();
+    try {
+      // Reap the container
+      boolean result = exec.reapContainer(
+          new ContainerReapContext.Builder()
+              .setContainer(container)
+              .setUser(container.getUser())
+              .build());
+      if (!result) {
+        throw new IOException("Reap container failed for container " +
+            container.getContainerId());
+      }
+      cleanupContainerFiles(getContainerWorkDir());
+    } finally {
+      containerExecLock.unlock();
+    }
+  }
+
-  
-  /**
-   * Cleanup the container.
-   * Cancels the launch if launch has not started yet or signals
-   * the executor to not execute the process if not already done so.
-   * Also, sends a SIGTERM followed by a SIGKILL to the process if
-   * the process id is available.
-   * @throws IOException
-   */
-  public void cleanupContainer() throws IOException {
-    ContainerId containerId = container.getContainerId();
-    String containerIdStr = containerId.toString();
-    LOG.info("Cleaning up container " + containerIdStr);
-
-    try {
-      context.getNMStateStore().storeContainerKilled(containerId);
-    } catch (IOException e) {
-      LOG.error("Unable to mark container " + containerId
-          + " killed in store", e);
-    }
-
-    // launch flag will be set to true if process already launched
-    boolean alreadyLaunched =
-        !containerAlreadyLaunched.compareAndSet(false, true);
-    if (!alreadyLaunched) {
-      LOG.info("Container " + containerIdStr + " not launched."
-          + " No cleanup needed to be done");
-      return;
-    }
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Marking container " + containerIdStr + " as inactive");
-    }
-    // this should ensure that if the container process has not launched 
-    // by this time, it will never be launched
-    exec.deactivateContainer(containerId);
-
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Getting pid for container " + containerIdStr + " to kill"
-          + " from pid file " 
-          + (pidFilePath != null ? pidFilePath.toString() : "null"));
-    }
-    
-    // however the container process may have already started
-    try {
-
-      // get process id from pid file if available
-      // else if shell is still active, get it from the shell
-      String processId = null;
-      if (pidFilePath != null) {
-        processId = getContainerPid(pidFilePath);
-      }
-
-      // kill process
-      String user = container.getUser();
-      if (processId != null) {
-        signalProcess(processId, user, containerIdStr);
-      } else {
-        // Normally this means that the process was notified about
-        // deactivateContainer above and did not start.
-        // Since we already set the state to RUNNING or REINITIALIZING
-        // we have to send a killed event to continue.
-        if (!completed.get()) {
-          LOG.warn("Container clean up before pid file created "
-              + containerIdStr);
-          dispatcher.getEventHandler().handle(
-              new ContainerExitEvent(container.getContainerId(),
-                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,
-                  Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :
-                      ExitCode.TERMINATED.getExitCode(),
-                  "Container terminated before pid file created."));
-          // There is a possibility that the launch grabbed the file name before
-          // the deactivateContainer above but it was slow enough to avoid
-          // getContainerPid.
-          // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS
-          // reduces the likelihood of this race condition and process leak.
-        }
-        // The Docker container may not have fully started, reap the container.
-        if (DockerLinuxContainerRuntime.isDockerContainerRequested(
-            conf,
-            container.getLaunchContext().getEnvironment())) {
-          reapDockerContainerNoPid(user);
-        }
-      }
-    } catch (Exception e) {
-      String message =
-          "Exception when trying to cleanup container " + containerIdStr
-              + ": " + StringUtils.stringifyException(e);
-      LOG.warn(message);
-      dispatcher.getEventHandler().handle(
-        new ContainerDiagnosticsUpdateEvent(containerId, message));
-    } finally {
-      // cleanup pid file if present
-      if (pidFilePath != null) {
-        FileContext lfs = FileContext.getLocalFSFileContext();
-        lfs.delete(pidFilePath, false);
-        lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);
-      }
-    }
-    containerExecLock.lock();
-    try {
-      // Reap the container
-      boolean result = exec.reapContainer(
-          new ContainerReapContext.Builder()
-              .setContainer(container)
-              .setUser(container.getUser())
-              .build());
-      if (!result) {
-        throw new IOException("Reap container failed for container "
-            + containerIdStr);
-      }
-      cleanupContainerFiles(getContainerWorkDir());
-    } finally {
-      containerExecLock.unlock();
-    }
-  }
-      String processId = null;
-      if (pidFilePath != null) {
-        processId = getContainerPid(pidFilePath);
-      }
-
+      String processId = getContainerPid();
-  private boolean sendSignal(String user, String processId, Signal signal)
-      throws IOException {
-    return exec.signalContainer(
-        new ContainerSignalContext.Builder().setContainer(container)
-            .setUser(user).setPid(processId).setSignal(signal).build());
-  }
-
-  private void signalProcess(String processId, String user,
-      String containerIdStr) throws IOException {
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Sending signal to pid " + processId + " as user " + user
-          + " for container " + containerIdStr);
-    }
-    final Signal signal =
-        sleepDelayBeforeSigKill > 0 ? Signal.TERM : Signal.KILL;
-
-    boolean result = sendSignal(user, processId, signal);
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Sent signal " + signal + " to pid " + processId + " as user "
-          + user + " for container " + containerIdStr + ", result="
-          + (result ? "success" : "failed"));
-    }
-    if (sleepDelayBeforeSigKill > 0) {
-      new DelayedProcessKiller(container, user, processId,
-          sleepDelayBeforeSigKill, Signal.KILL, exec).start();
-    }
-  }
-
-  private void reapDockerContainerNoPid(String user) throws IOException {
-    String containerIdStr =
-        container.getContainerTokenIdentifier().getContainerID().toString();
-    LOG.info("Unable to obtain pid, but docker container request detected. "
-            + "Attempting to reap container " + containerIdStr);
-    boolean result = exec.reapContainer(
-        new ContainerReapContext.Builder()
-            .setContainer(container)
-            .setUser(container.getUser())
-            .build());
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Sent signal to docker container " + containerIdStr
-          + " as user " + user + ", result=" + (result ? "success" : "failed"));
-    }
-  }
-
-   * @param pidFilePath File from which to read the process id
-   * @return Process ID
+   * @return Process ID; null when pidFilePath is null
-  private String getContainerPid(Path pidFilePath) throws Exception {
+  String getContainerPid() throws Exception {
+    if (pidFilePath == null) {
+      return null;
+    }
-    String processId = null;
+    String processId;
+
+  /**
+   * Returns the PID File Path.
+   */
+  Path getPidFilePath() {
+    return pidFilePath;
+  }
+
+  /**
+   * Marks the container to be launched only if it was not launched.
+   *
+   * @return true if successful; false otherwise.
+   */
+  boolean markLaunched() {
+    return containerAlreadyLaunched.compareAndSet(false, true);
+  }
+
+  /**
+   * Returns if the launch is completed or not.
+   */
+  boolean isLaunchCompleted() {
+    return completed.get();
+  }
+

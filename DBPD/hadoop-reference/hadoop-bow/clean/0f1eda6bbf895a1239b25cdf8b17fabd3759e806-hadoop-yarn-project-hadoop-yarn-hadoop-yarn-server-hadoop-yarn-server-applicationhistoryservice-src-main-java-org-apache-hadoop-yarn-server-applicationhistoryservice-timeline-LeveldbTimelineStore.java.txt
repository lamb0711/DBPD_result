YARN-1838. Enhanced timeline service getEntities API to get entities from a given entity ID or insertion timestamp. Contributed by Billie Rinaldi.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580960 13f79535-47bb-0310-9956-ffa450edef68

-  private Map<EntityIdentifier, Long> startTimeWriteCache;
+  private Map<EntityIdentifier, StartAndInsertTime> startTimeWriteCache;
+  private static class StartAndInsertTime {
+    final long startTime;
+    final long insertTime;
+
+    public StartAndInsertTime(long startTime, long insertTime) {
+      this.startTime = startTime;
+      this.insertTime = insertTime;
+    }
+  }
+
-      Long limit, Long windowStart, Long windowEnd,
+      Long limit, Long windowStart, Long windowEnd, String fromId, Long fromTs,
-          windowStart, windowEnd, secondaryFilters, fields);
+          windowStart, windowEnd, fromId, fromTs, secondaryFilters, fields);
-          secondaryFilters, fields);
+          fromId, fromTs, secondaryFilters, fields);
+   * @param fromId Retrieve entities starting with this entity
+   * @param fromTs Ignore entities with insert timestamp later than this ts
-      Collection<NameValuePair> secondaryFilters, EnumSet<Field> fields)
-      throws IOException {
+      String fromId, Long fromTs, Collection<NameValuePair> secondaryFilters,
+      EnumSet<Field> fields) throws IOException {
-      // using end time, construct a first key that will be seeked to
-      byte[] revts = writeReverseOrderedLong(endtime);
-      kb.add(revts);
-      byte[] first = kb.getBytesForLookup();
+      // construct a first key that will be seeked to using end time or fromId
+      byte[] first = null;
+      if (fromId != null) {
+        Long fromIdStartTime = getStartTimeLong(fromId, entityType);
+        if (fromIdStartTime == null) {
+          // no start time for provided id, so return empty entities
+          return new TimelineEntities();
+        }
+        if (fromIdStartTime <= endtime) {
+          // if provided id's start time falls before the end of the window,
+          // use it to construct the seek key
+          first = kb.add(writeReverseOrderedLong(fromIdStartTime))
+              .add(fromId).getBytesForLookup();
+        }
+      }
+      // if seek key wasn't constructed using fromId, construct it using end ts
+      if (first == null) {
+        first = kb.add(writeReverseOrderedLong(endtime)).getBytesForLookup();
+      }
+
+        if (fromTs != null) {
+          long insertTime = readReverseOrderedLong(iterator.peekNext()
+              .getValue(), 0);
+          if (insertTime > fromTs) {
+            byte[] firstKey = key;
+            while (iterator.hasNext() && prefixMatches(firstKey,
+                kp.getOffset(), key)) {
+              iterator.next();
+              key = iterator.peekNext().getKey();
+            }
+            continue;
+          }
+        }
+
-      revStartTime = getAndSetStartTime(entity.getEntityId(),
-          entity.getEntityType(), entity.getStartTime(), events);
-      if (revStartTime == null) {
+      StartAndInsertTime startAndInsertTime = getAndSetStartTime(
+          entity.getEntityId(), entity.getEntityType(),
+          entity.getStartTime(), events);
+      if (startAndInsertTime == null) {
+      revStartTime = writeReverseOrderedLong(startAndInsertTime
+          .startTime);
+
-      writeBatch.put(createEntityMarkerKey(entity.getEntityId(),
-          entity.getEntityType(), revStartTime), EMPTY_BYTES);
+      byte[] markerKey = createEntityMarkerKey(entity.getEntityId(),
+          entity.getEntityType(), revStartTime);
+      byte[] markerValue = writeReverseOrderedLong(startAndInsertTime
+          .insertTime);
+      writeBatch.put(markerKey, markerValue);
+      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,
+          markerValue);
-        byte[] relatedEntityStartTime = getAndSetStartTime(
-            relatedEntity.getId(), relatedEntity.getType(),
+        StartAndInsertTime relatedEntityStartAndInsertTime =
+            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),
-        if (relatedEntityStartTime == null) {
+        if (relatedEntityStartAndInsertTime == null) {
+        byte[] relatedEntityStartTime = writeReverseOrderedLong(
+            relatedEntityStartAndInsertTime.startTime);
-            relatedEntity.getType(), relatedEntityStartTime), EMPTY_BYTES);
+            relatedEntity.getType(), relatedEntityStartTime),
+            writeReverseOrderedLong(relatedEntityStartAndInsertTime
+                .insertTime));
-   * @return A byte array
+   * @return A StartAndInsertTime
-  private byte[] getAndSetStartTime(String entityId, String entityType,
-      Long startTime, List<TimelineEvent> events)
+  private StartAndInsertTime getAndSetStartTime(String entityId,
+      String entityType, Long startTime, List<TimelineEvent> events)
-        startTime = startTimeWriteCache.get(entity);
-        return writeReverseOrderedLong(startTime);
+        return startTimeWriteCache.get(entity);
-        // check the provided start time matches the cache
-        if (!startTime.equals(startTimeWriteCache.get(entity))) {
-          // the start time is already in the cache,
-          // and it is different from the provided start time,
-          // so use the one from the cache
-          startTime = startTimeWriteCache.get(entity);
-        }
-        return writeReverseOrderedLong(startTime);
+        // always use start time from cache if it exists
+        return startTimeWriteCache.get(entity);
-  private byte[] checkStartTimeInDb(EntityIdentifier entity,
+  private StartAndInsertTime checkStartTimeInDb(EntityIdentifier entity,
+    StartAndInsertTime startAndInsertTime = null;
-    byte[] revStartTime;
+      startAndInsertTime = new StartAndInsertTime(suggestedStartTime,
+          System.currentTimeMillis());
+
-      revStartTime = writeReverseOrderedLong(suggestedStartTime);
+      v = new byte[16];
+      writeReverseOrderedLong(suggestedStartTime, v, 0);
+      writeReverseOrderedLong(startAndInsertTime.insertTime, v, 8);
-      db.put(b, revStartTime, writeOptions);
+      db.put(b, v, writeOptions);
-      suggestedStartTime = readReverseOrderedLong(v, 0);
-      revStartTime = v;
+      startAndInsertTime = new StartAndInsertTime(readReverseOrderedLong(v, 0),
+          readReverseOrderedLong(v, 8));
-    startTimeWriteCache.put(entity, suggestedStartTime);
-    startTimeReadCache.put(entity, suggestedStartTime);
-    return revStartTime;
+    startTimeWriteCache.put(entity, startAndInsertTime);
+    startTimeReadCache.put(entity, startAndInsertTime.startTime);
+    return startAndInsertTime;
-  // warning is suppressed to prevent eclipse from noting unclosed resource
-  @SuppressWarnings("resource")

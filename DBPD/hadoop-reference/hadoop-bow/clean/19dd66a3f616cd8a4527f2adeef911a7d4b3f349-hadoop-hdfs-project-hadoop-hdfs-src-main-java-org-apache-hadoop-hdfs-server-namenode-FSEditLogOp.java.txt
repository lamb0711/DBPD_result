HDFS-3510.  Editlog pre-allocation is performed prior to writing edits to avoid partial edits case disk out of space. Contributed by Collin McCabe.
        


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1355189 13f79535-47bb-0310-9956-ffa450edef68

-          limiter.setLimit(MAX_OP_SIZE);
-          in.mark(MAX_OP_SIZE);
-        } catch (GarbageAfterTerminatorException e) {
-          in.reset();
-          if (!skipBrokenEdits) {
-            throw e;
-          }
-          // If we saw a terminator opcode followed by a long region of 0x00 or
-          // 0xff, we want to skip over that region, because there's nothing
-          // interesting there.
-          long numSkip = e.getNumAfterTerminator();
-          try {
-            IOUtils.skipFully(in,  numSkip);
-          } catch (Throwable t) {
-            FSImage.LOG.error("Failed to skip " + numSkip + " bytes of " +
-              "garbage after an OP_INVALID.", t);
-            return null;
-          }
-      long off = 0;
+      limiter.clearLimit();
+      int numRead = -1, idx = 0;
-        int numRead = in.read(buf);
-        if (numRead == -1) {
-          return;
-        }
-        for (int i = 0; i < numRead; i++, off++) {
-          if ((buf[i] != (byte)0) && (buf[i] != (byte)-1)) {
-            throw new GarbageAfterTerminatorException("Read garbage after " +
-            		"the terminator!", off);
+        try {
+          numRead = -1;
+          idx = 0;
+          numRead = in.read(buf);
+          if (numRead == -1) {
+            return;
+          }
+          while (idx < numRead) {
+            if ((buf[idx] != (byte)0) && (buf[idx] != (byte)-1)) {
+              throw new IOException("Read extra bytes after " +
+                "the terminator!");
+            }
+            idx++;
+          }
+        } finally {
+          // After reading each group of bytes, we reposition the mark one
+          // byte before the next group.  Similarly, if there is an error, we
+          // want to reposition the mark one byte before the error
+          if (numRead != -1) { 
+            in.reset();
+            IOUtils.skipFully(in, idx);
+            in.mark(buf.length + 1);
+            IOUtils.skipFully(in, 1);
+    /**
+     * Read an opcode from the input stream.
+     *
+     * @return   the opcode, or null on EOF.
+     *
+     * If an exception is thrown, the stream's mark will be set to the first
+     * problematic byte.  This usually means the beginning of the opcode.
+     */
+      limiter.setLimit(MAX_OP_SIZE);
+      in.mark(MAX_OP_SIZE);
+
-
-  /**
-   * Exception indicating that we found an OP_INVALID followed by some 
-   * garbage.  An OP_INVALID should signify the end of the file... if there 
-   * is additional content after that, then the edit log is corrupt. 
-   */
-  static class GarbageAfterTerminatorException extends IOException {
-    private static final long serialVersionUID = 1L;
-    private final long numAfterTerminator;
-
-    public GarbageAfterTerminatorException(String str,
-        long numAfterTerminator) {
-      super(str);
-      this.numAfterTerminator = numAfterTerminator;
-    }
-
-    /**
-     * Get the number of bytes after the terminator at which the garbage
-     * appeared.
-     *
-     * So if you had an OP_INVALID followed immediately by another valid opcode,
-     * this would be 0.
-     * If you had an OP_INVALID followed by some padding bytes, followed by a
-     * stray byte at the end, this would be the number of padding bytes.
-     * 
-     * @return numAfterTerminator
-     */
-    public long getNumAfterTerminator() {
-      return numAfterTerminator;
-    }
-  }

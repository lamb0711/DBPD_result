HADOOP-6920. Metrics instrumentation to move new metrics2 framework. Contributed by Luke Lu.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1101682 13f79535-47bb-0310-9956-ffa450edef68

+import java.lang.management.ManagementFactory;
+import java.lang.management.MemoryMXBean;
+import java.lang.management.MemoryUsage;
+import java.lang.management.ThreadInfo;
+import java.lang.management.ThreadMXBean;
+import static java.lang.Thread.State.*;
+import java.lang.management.GarbageCollectorMXBean;
+import java.util.Map;
+import java.util.List;
+
+import com.google.common.collect.Maps;
+
-import org.apache.hadoop.classification.InterfaceStability;
+import org.apache.hadoop.log.metrics.EventCounter;
+import org.apache.hadoop.metrics2.MetricsCollector;
+import org.apache.hadoop.metrics2.MetricsInfo;
+import org.apache.hadoop.metrics2.MetricsRecordBuilder;
+import org.apache.hadoop.metrics2.MetricsSource;
+import org.apache.hadoop.metrics2.MetricsSystem;
+import org.apache.hadoop.metrics2.lib.DefaultMetricsSystem;
+import org.apache.hadoop.metrics2.lib.Interns;
+import static org.apache.hadoop.metrics2.source.JvmMetricsInfo.*;
+import static org.apache.hadoop.metrics2.impl.MsInfo.*;
- * JVM related metrics. Mostly used by various servers as part of the metrics
- * they export.
+ * JVM and logging related metrics.
+ * Mostly used by various servers as a part of the metrics they export.
-@InterfaceStability.Evolving
-public class JvmMetrics {
-  // placeholder for javadoc to prevent broken links, until
-  // HADOOP-6920
+public class JvmMetrics implements MetricsSource {
+  enum Singleton {
+    INSTANCE;
+
+    JvmMetrics impl;
+
+    synchronized JvmMetrics init(String processName, String sessionId) {
+      if (impl == null) {
+        impl = create(processName, sessionId, DefaultMetricsSystem.instance());
+      }
+      return impl;
+    }
+  }
+
+  static final float M = 1024*1024;
+
+  final MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();
+  final List<GarbageCollectorMXBean> gcBeans =
+      ManagementFactory.getGarbageCollectorMXBeans();
+  final ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
+  final String processName, sessionId;
+  final Map<String, MetricsInfo[]> gcInfoCache = Maps.newHashMap();
+
+  JvmMetrics(String processName, String sessionId) {
+    this.processName = processName;
+    this.sessionId = sessionId;
+  }
+
+  public static JvmMetrics create(String processName, String sessionId,
+                                  MetricsSystem ms) {
+    return ms.register(JvmMetrics.name(), JvmMetrics.description(),
+                       new JvmMetrics(processName, sessionId));
+  }
+
+  public static JvmMetrics initSingleton(String processName, String sessionId) {
+    return Singleton.INSTANCE.init(processName, sessionId);
+  }
+
+  @Override
+  public void getMetrics(MetricsCollector collector, boolean all) {
+    MetricsRecordBuilder rb = collector.addRecord(JvmMetrics)
+        .setContext("jvm").tag(ProcessName, processName)
+        .tag(SessionId, sessionId);
+    getMemoryUsage(rb);
+    getGcUsage(rb);
+    getThreadUsage(rb);
+    getEventCounters(rb);
+  }
+
+  private void getMemoryUsage(MetricsRecordBuilder rb) {
+    MemoryUsage memNonHeap = memoryMXBean.getNonHeapMemoryUsage();
+    MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage();
+    rb.addGauge(MemNonHeapUsedM, memNonHeap.getUsed() / M)
+      .addGauge(MemNonHeapCommittedM, memNonHeap.getCommitted() / M)
+      .addGauge(MemHeapUsedM, memHeap.getUsed() / M)
+      .addGauge(MemHeapCommittedM, memHeap.getCommitted() / M);
+  }
+
+  private void getGcUsage(MetricsRecordBuilder rb) {
+    long count = 0;
+    long timeMillis = 0;
+    for (GarbageCollectorMXBean gcBean : gcBeans) {
+      long c = gcBean.getCollectionCount();
+      long t = gcBean.getCollectionTime();
+      MetricsInfo[] gcInfo = getGcInfo(gcBean.getName());
+      rb.addCounter(gcInfo[0], c).addCounter(gcInfo[1], t);
+      count += c;
+      timeMillis += t;
+    }
+    rb.addCounter(GcCount, count)
+      .addCounter(GcTimeMillis, timeMillis);
+  }
+
+  private synchronized MetricsInfo[] getGcInfo(String gcName) {
+    MetricsInfo[] gcInfo = gcInfoCache.get(gcName);
+    if (gcInfo == null) {
+      gcInfo = new MetricsInfo[2];
+      gcInfo[0] = Interns.info("GcCount"+ gcName, "GC Count for "+ gcName);
+      gcInfo[1] = Interns.info("GcTimeMillis"+ gcName, "GC Time for "+ gcName);
+      gcInfoCache.put(gcName, gcInfo);
+    }
+    return gcInfo;
+  }
+
+  private void getThreadUsage(MetricsRecordBuilder rb) {
+    int threadsNew = 0;
+    int threadsRunnable = 0;
+    int threadsBlocked = 0;
+    int threadsWaiting = 0;
+    int threadsTimedWaiting = 0;
+    int threadsTerminated = 0;
+    long threadIds[] = threadMXBean.getAllThreadIds();
+    for (ThreadInfo threadInfo : threadMXBean.getThreadInfo(threadIds, 0)) {
+      if (threadInfo == null) continue; // race protection
+      switch (threadInfo.getThreadState()) {
+        case NEW:           threadsNew++;           break;
+        case RUNNABLE:      threadsRunnable++;      break;
+        case BLOCKED:       threadsBlocked++;       break;
+        case WAITING:       threadsWaiting++;       break;
+        case TIMED_WAITING: threadsTimedWaiting++;  break;
+        case TERMINATED:    threadsTerminated++;    break;
+      }
+    }
+    rb.addGauge(ThreadsNew, threadsNew)
+      .addGauge(ThreadsRunnable, threadsRunnable)
+      .addGauge(ThreadsBlocked, threadsBlocked)
+      .addGauge(ThreadsWaiting, threadsWaiting)
+      .addGauge(ThreadsTimedWaiting, threadsTimedWaiting)
+      .addGauge(ThreadsTerminated, threadsTerminated);
+  }
+
+  private void getEventCounters(MetricsRecordBuilder rb) {
+    rb.addCounter(LogFatal, EventCounter.getFatal())
+      .addCounter(LogError, EventCounter.getError())
+      .addCounter(LogWarn, EventCounter.getWarn())
+      .addCounter(LogInfo, EventCounter.getInfo());
+  }

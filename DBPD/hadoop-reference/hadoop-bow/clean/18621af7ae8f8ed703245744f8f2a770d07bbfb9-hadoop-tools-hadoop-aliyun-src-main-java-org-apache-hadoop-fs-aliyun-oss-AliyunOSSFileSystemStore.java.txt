HADOOP-14993. AliyunOSS: Override listFiles and listLocatedStatus. Contributed Genmao Yu

+import org.apache.hadoop.fs.BlockLocation;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.LocatedFileStatus;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.fs.PathFilter;
+import org.apache.hadoop.fs.RemoteIterator;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+  public RemoteIterator<LocatedFileStatus> singleStatusRemoteIterator(
+      final FileStatus fileStatus, final BlockLocation[] locations) {
+    return new RemoteIterator<LocatedFileStatus>() {
+      private boolean hasNext = true;
+      @Override
+      public boolean hasNext() throws IOException {
+        return fileStatus != null && hasNext;
+      }
+
+      @Override
+      public LocatedFileStatus next() throws IOException {
+        if (hasNext()) {
+          LocatedFileStatus s = new LocatedFileStatus(fileStatus,
+              fileStatus.isFile() ? locations : null);
+          hasNext = false;
+          return s;
+        } else {
+          throw new NoSuchElementException();
+        }
+      }
+    };
+  }
+
+  public RemoteIterator<LocatedFileStatus> createLocatedFileStatusIterator(
+      final String prefix, final int maxListingLength, FileSystem fs,
+      PathFilter filter, FileStatusAcceptor acceptor, String delimiter) {
+    return new RemoteIterator<LocatedFileStatus>() {
+      private String nextMarker = null;
+      private boolean firstListing = true;
+      private boolean meetEnd = false;
+      private ListIterator<FileStatus> batchIterator;
+
+      @Override
+      public boolean hasNext() throws IOException {
+        if (firstListing) {
+          requestNextBatch();
+          firstListing = false;
+        }
+        return batchIterator.hasNext() || requestNextBatch();
+      }
+
+      @Override
+      public LocatedFileStatus next() throws IOException {
+        if (hasNext()) {
+          FileStatus status = batchIterator.next();
+          BlockLocation[] locations = fs.getFileBlockLocations(status,
+            0, status.getLen());
+          return new LocatedFileStatus(
+              status, status.isFile() ? locations : null);
+        } else {
+          throw new NoSuchElementException();
+        }
+      }
+
+      private boolean requestNextBatch() {
+        if (meetEnd) {
+          return false;
+        }
+        ListObjectsRequest listRequest = new ListObjectsRequest(bucketName);
+        listRequest.setPrefix(AliyunOSSUtils.maybeAddTrailingSlash(prefix));
+        listRequest.setMaxKeys(maxListingLength);
+        listRequest.setMarker(nextMarker);
+        listRequest.setDelimiter(delimiter);
+        ObjectListing listing = ossClient.listObjects(listRequest);
+        List<FileStatus> stats = new ArrayList<>(
+            listing.getObjectSummaries().size() +
+            listing.getCommonPrefixes().size());
+        for(OSSObjectSummary summary: listing.getObjectSummaries()) {
+          String key = summary.getKey();
+          Path path = fs.makeQualified(new Path("/" + key));
+          if (filter.accept(path) && acceptor.accept(path, summary)) {
+            FileStatus status = new FileStatus(summary.getSize(),
+                key.endsWith("/"), 1, fs.getDefaultBlockSize(path),
+                summary.getLastModified().getTime(), path);
+            stats.add(status);
+          }
+        }
+
+        for(String commonPrefix: listing.getCommonPrefixes()) {
+          Path path = fs.makeQualified(new Path("/" + commonPrefix));
+          if (filter.accept(path) && acceptor.accept(path, commonPrefix)) {
+            FileStatus status = new FileStatus(0, true, 1, 0, 0, path);
+            stats.add(status);
+          }
+        }
+
+        batchIterator = stats.listIterator();
+        if (listing.isTruncated()) {
+          nextMarker = listing.getNextMarker();
+        } else {
+          meetEnd = true;
+        }
+        statistics.incrementReadOps(1);
+        return batchIterator.hasNext();
+      }
+    };
+  }

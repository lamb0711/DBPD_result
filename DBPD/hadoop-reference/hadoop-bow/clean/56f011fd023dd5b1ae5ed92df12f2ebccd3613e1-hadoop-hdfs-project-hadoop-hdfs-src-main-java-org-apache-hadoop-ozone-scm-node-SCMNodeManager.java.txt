HDFS-11447. Ozone: SCM: Send node report to SCM with heartbeat.Contributed by Xiaoyu Yao.

+import org.apache.commons.collections.map.HashedMap;
+import org.apache.hadoop.ozone.protocol
+    .proto.StorageContainerDatanodeProtocolProtos.SCMNodeReport;
+import org.apache.hadoop.ozone.protocol
+    .proto.StorageContainerDatanodeProtocolProtos.SCMStorageReport;
+import org.apache.hadoop.util.Time;
- * thread will lookup the healthynodes map and update the timestamp if the entry
+ * thread will lookup the healthynodes map and set the timestamp if the entry
+
-  private final Queue<DatanodeID> heartbeatQueue;
+  private final Queue<HeartbeatQueueItem> heartbeatQueue;
+  // Individual live node stats
+  private final Map<String, SCMNodeStat> nodeStats;
+  // Aggregated node stats
+  private SCMNodeStat scmStat;
+  // TODO: expose nodeStats and scmStat as metrics
+    nodeStats = new HashedMap();
+    scmStat = new SCMNodeStat();
-    // TODO : Fix me.
+    // TODO : Fix me when adding the SCM CLI.
-      DatanodeID datanodeID = heartbeatQueue.poll();
+      HeartbeatQueueItem hbItem = heartbeatQueue.poll();
-        handleHeartbeat(datanodeID);
+        handleHeartbeat(hbItem);
-    if (!Thread.currentThread().isInterrupted()) {
+    if (!Thread.currentThread().isInterrupted() &&
+        !executorService.isShutdown()) {
+
+    // Update SCM node stats
+    SCMNodeStat deadNodeStat = nodeStats.get(entry.getKey());
+    scmStat.subtract(deadNodeStat);
+    nodeStats.remove(entry.getKey());
-   * @param datanodeID - datanode ID.
+   * @param hbItem - heartbeat item from a datanode.
-  private void handleHeartbeat(DatanodeID datanodeID) {
+  private void handleHeartbeat(HeartbeatQueueItem hbItem) {
+    String datanodeID = hbItem.getDatanodeID().getDatanodeUuid();
+    SCMNodeReport nodeReport = hbItem.getNodeReport();
+    long recvTimestamp = hbItem.getRecvTimestamp();
+    long processTimestamp = Time.monotonicNow();
+    if (LOG.isTraceEnabled()) {
+      //TODO: add average queue time of heartbeat request as metrics
+      LOG.trace("Processing Heartbeat from datanode {}: queueing time {}",
+          datanodeID, processTimestamp - recvTimestamp);
+    }
+
-    // just update the last timestamp and return.
-    if (healthyNodes.containsKey(datanodeID.getDatanodeUuid())) {
-      healthyNodes.put(datanodeID.getDatanodeUuid(), monotonicNow());
+    // just set the last timestamp and return.
+    if (healthyNodes.containsKey(datanodeID)) {
+      healthyNodes.put(datanodeID, processTimestamp);
+      updateNodeStat(datanodeID, nodeReport);
-    if (staleNodes.containsKey(datanodeID.getDatanodeUuid())) {
-      staleNodes.remove(datanodeID.getDatanodeUuid());
-      healthyNodes.put(datanodeID.getDatanodeUuid(), monotonicNow());
+    if (staleNodes.containsKey(datanodeID)) {
+      staleNodes.remove(datanodeID);
+      healthyNodes.put(datanodeID, processTimestamp);
+      updateNodeStat(datanodeID, nodeReport);
-    if (deadNodes.containsKey(datanodeID.getDatanodeUuid())) {
-      deadNodes.remove(datanodeID.getDatanodeUuid());
-      healthyNodes.put(datanodeID.getDatanodeUuid(), monotonicNow());
+    if (deadNodes.containsKey(datanodeID)) {
+      deadNodes.remove(datanodeID);
+      healthyNodes.put(datanodeID, processTimestamp);
+      updateNodeStat(datanodeID, nodeReport);
+      return;
+    }
+    LOG.warn("SCM receive heartbeat from unregistered datanode {}", datanodeID);
+  }
+
+  private void updateNodeStat(String datanodeID, SCMNodeReport nodeReport) {
+    SCMNodeStat stat = nodeStats.get(datanodeID);
+    if (stat == null) {
+      LOG.debug("SCM updateNodeStat based on heartbeat from previous" +
+          "dead datanode {}", datanodeID);
+      stat = new SCMNodeStat();
+    }
+
+    if (nodeReport != null && nodeReport.getStorageReportCount() > 0) {
+      long totalCapacity = 0;
+      long totalRemaining = 0;
+      long totalScmUsed = 0;
+      List<SCMStorageReport> storageReports = nodeReport.getStorageReportList();
+      for (SCMStorageReport report : storageReports) {
+        totalCapacity += report.getCapacity();
+        totalRemaining += report.getRemaining();
+        totalScmUsed += report.getScmUsed();
+      }
+      scmStat.subtract(stat);
+      stat.set(totalCapacity, totalScmUsed, totalRemaining);
+      nodeStats.put(datanodeID, stat);
+      scmStat.add(stat);
+    nodeStats.put(datanodeID.getDatanodeUuid(), new SCMNodeStat());
+   * @param nodeReport - node report.
-  public List<SCMCommand> sendHeartbeat(DatanodeID datanodeID) {
+  public List<SCMCommand> sendHeartbeat(DatanodeID datanodeID,
+      SCMNodeReport nodeReport) {
-      heartbeatQueue.add(datanodeID);
-
+      heartbeatQueue.add(
+          new HeartbeatQueueItem.Builder()
+              .setDatanodeID(datanodeID)
+              .setNodeReport(nodeReport)
+              .build());
-}
+
+  /**
+   * Returns the aggregated node stats.
+   * @return the aggregated node stats.
+   */
+  @Override
+  public SCMNodeStat getStats() {
+    return new SCMNodeStat(this.scmStat);
+  }
+
+  /**
+   * Return a list of node stats.
+   * @return a list of individual node stats (live/stale but not dead).
+   */
+  @Override
+  public List<SCMNodeStat> getNodeStats(){
+    return nodeStats.entrySet().stream().map(
+        entry -> nodeStats.get(entry.getKey())).collect(Collectors.toList());
+  }
+}

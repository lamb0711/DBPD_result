MAPREDUCE-4371. Check for cyclic dependencies in Jobcontrol job DAG (madhukara phatak via bobby)


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1355139 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.HashSet;
+          if (isCircular(jobsInProgress)) {
+	    throw new IllegalArgumentException(
+		"job control has circular dependency");
+	  }
+
+ /**
+   * Uses topological sorting algorithm for finding circular dependency
+   */
+  private boolean isCircular(final List<ControlledJob> jobList) {
+    boolean cyclePresent = false;
+    HashSet<ControlledJob> SourceSet = new HashSet<ControlledJob>();
+    HashMap<ControlledJob, List<ControlledJob>> processedMap =
+	new HashMap<ControlledJob, List<ControlledJob>>();
+    for (ControlledJob n : jobList) {
+      processedMap.put(n, new ArrayList<ControlledJob>());
+    }
+    for (ControlledJob n : jobList) {
+      if (!hasInComingEdge(n, jobList, processedMap)) {
+	SourceSet.add(n);
+      }
+    }
+    while (!SourceSet.isEmpty()) {
+      ControlledJob controlledJob = SourceSet.iterator().next();
+      SourceSet.remove(controlledJob);
+      if (controlledJob.getDependentJobs() != null) {
+	for (int i = 0; i < controlledJob.getDependentJobs().size(); i++) {
+	  ControlledJob depenControlledJob =
+	      controlledJob.getDependentJobs().get(i);
+	  processedMap.get(controlledJob).add(depenControlledJob);
+	  if (!hasInComingEdge(controlledJob, jobList, processedMap)) {
+	    SourceSet.add(depenControlledJob);
+	  }
+	}
+      }
+    }
+
+    for (ControlledJob controlledJob : jobList) {
+      if (controlledJob.getDependentJobs() != null
+	  && controlledJob.getDependentJobs().size() != processedMap.get(
+	      controlledJob).size()) {
+	cyclePresent = true;
+	LOG.error("Job control has circular dependency for the  job "
+	    + controlledJob.getJobName());
+	break;
+      }
+    }
+    return cyclePresent;
+  }
+
+  private boolean hasInComingEdge(ControlledJob controlledJob,
+      List<ControlledJob> controlledJobList,
+      HashMap<ControlledJob, List<ControlledJob>> processedMap) {
+    boolean hasIncomingEdge = false;
+    for (ControlledJob k : controlledJobList) {
+      if (k != controlledJob && k.getDependentJobs() != null
+	  && !processedMap.get(k).contains(controlledJob)
+	  && k.getDependentJobs().contains(controlledJob)) {
+	hasIncomingEdge = true;
+	break;
+      }
+    }
+    return hasIncomingEdge;
+
+  }

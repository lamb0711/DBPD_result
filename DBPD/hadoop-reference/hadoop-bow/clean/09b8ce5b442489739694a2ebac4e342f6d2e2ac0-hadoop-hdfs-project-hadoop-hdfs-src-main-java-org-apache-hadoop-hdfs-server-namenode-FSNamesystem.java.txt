HDFS-5786. Support QUERY and FINALIZE actions of rolling upgrade.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1559304 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.protocol.RollingUpgradeException;
+  private RollingUpgradeInfo rollingUpgradeInfo;
+
-  RollingUpgradeInfo addUpgradeMarker() throws IOException {
-    final long startTime;
+  RollingUpgradeInfo queryRollingUpgrade() throws IOException {
+    checkSuperuserPrivilege();
+    checkOperation(OperationCategory.READ);
+    readLock();
+    try {
+      return rollingUpgradeInfo != null? rollingUpgradeInfo
+          : RollingUpgradeInfo.EMPTY_INFO;
+    } finally {
+      readUnlock();
+    }
+  }
+
+  RollingUpgradeInfo startRollingUpgrade() throws IOException {
+      final String err = "Failed to start rolling upgrade";
+      checkNameNodeSafeMode(err);
-      startTime = now();
-      getEditLog().logUpgradeMarker();
+      if (rollingUpgradeInfo != null) {
+        throw new RollingUpgradeException(err
+            + " since a rolling upgrade is already in progress."
+            + "\nExisting rolling upgrade info: " + rollingUpgradeInfo);
+      }
+
+      final CheckpointSignature cs = getFSImage().rollEditLog();
+      LOG.info("Successfully rolled edit log for preparing rolling upgrade."
+          + " Checkpoint signature: " + cs);
+      rollingUpgradeInfo = new RollingUpgradeInfo(now());
+      getEditLog().logUpgradeMarker(rollingUpgradeInfo.getStartTime());
-      logAuditEvent(true, "upgrade", null, null, null);
+      logAuditEvent(true, "startRollingUpgrade", null, null, null);
-    return new RollingUpgradeInfo(startTime, 0L);
+    return rollingUpgradeInfo;
+  }
+
+  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {
+    checkSuperuserPrivilege();
+    checkOperation(OperationCategory.WRITE);
+    writeLock();
+    final RollingUpgradeInfo returnInfo;
+    try {
+      checkOperation(OperationCategory.WRITE);
+      final String err = "Failed to finalize rolling upgrade";
+      checkNameNodeSafeMode(err);
+
+      if (rollingUpgradeInfo == null) {
+        throw new RollingUpgradeException(err
+            + " since there is no rolling upgrade in progress.");
+      }
+
+      returnInfo = new RollingUpgradeInfo(rollingUpgradeInfo.getStartTime(), now());
+      getFSImage().saveNamespace(this);
+      rollingUpgradeInfo = null;
+    } finally {
+      writeUnlock();
+    }
+
+    if (auditLog.isInfoEnabled() && isExternalInvocation()) {
+      logAuditEvent(true, "finalizeRollingUpgrade", null, null, null);
+    }
+    return returnInfo;

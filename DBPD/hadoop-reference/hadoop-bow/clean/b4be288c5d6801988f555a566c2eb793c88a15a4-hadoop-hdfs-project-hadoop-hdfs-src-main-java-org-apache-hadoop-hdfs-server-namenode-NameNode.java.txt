HDFS-10207. Support enable Hadoop IPC backoff without namenode restart. Contributed by Xiaobing Zhou.

+import com.google.common.collect.Sets;
-import java.util.Collections;
+import java.util.TreeSet;
+import static org.apache.hadoop.fs.CommonConfigurationKeys.IPC_BACKOFF_ENABLE;
+import static org.apache.hadoop.fs.CommonConfigurationKeys.IPC_NAMESPACE;
+import static org.apache.hadoop.fs.CommonConfigurationKeys.IPC_BACKOFF_ENABLE_DEFAULT;
+  private String ipcClientRPCBackoffEnable;
+
-  static final List<String> RECONFIGURABLE_PROPERTIES = Collections
-      .unmodifiableList(Arrays
-          .asList(DFS_HEARTBEAT_INTERVAL_KEY,
-              DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,
-              FS_PROTECTED_DIRECTORIES,
-              HADOOP_CALLER_CONTEXT_ENABLED_KEY));
+  private final TreeSet<String> reconfigurableProperties = Sets
+      .newTreeSet(Lists.newArrayList(
+          DFS_HEARTBEAT_INTERVAL_KEY,
+          DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,
+          FS_PROTECTED_DIRECTORIES,
+          HADOOP_CALLER_CONTEXT_ENABLED_KEY));
+
+    initReconfigurableBackoffKey();
+
+  private void initReconfigurableBackoffKey() {
+    ipcClientRPCBackoffEnable = buildBackoffEnableKey(rpcServer
+        .getClientRpcServer().getPort());
+    reconfigurableProperties.add(ipcClientRPCBackoffEnable);
+  }
+
+  static String buildBackoffEnableKey(final int port) {
+    // format used to construct backoff enable key, e.g. ipc.8020.backoff.enable
+    String format = "%s.%d.%s";
+    return String.format(format, IPC_NAMESPACE, port, IPC_BACKOFF_ENABLE);
+  }
+
-    return RECONFIGURABLE_PROPERTIES;
+    return reconfigurableProperties;
-    switch (property) {
-    case DFS_HEARTBEAT_INTERVAL_KEY:
-      namesystem.writeLock();
-      try {
-        if (newVal == null) {
-          // set to default
-          datanodeManager.setHeartbeatInterval(DFS_HEARTBEAT_INTERVAL_DEFAULT);
-          return String.valueOf(DFS_HEARTBEAT_INTERVAL_DEFAULT);
-        } else {
-          datanodeManager.setHeartbeatInterval(Long.parseLong(newVal));
-          return String.valueOf(datanodeManager.getHeartbeatInterval());
-        }
-      } catch (NumberFormatException nfe) {
-        throw new ReconfigurationException(property, newVal, getConf().get(
-            property), nfe);
-      } finally {
-        namesystem.writeUnlock();
-        LOG.info("RECONFIGURE* changed heartbeatInterval to "
-            + datanodeManager.getHeartbeatInterval());
-      }
-    case DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY:
-      namesystem.writeLock();
-      try {
-        if (newVal == null) {
-          // set to default
-          datanodeManager
-              .setHeartbeatRecheckInterval(
-                  DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT);
-          return String
-              .valueOf(DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT);
-        } else {
-          datanodeManager.setHeartbeatRecheckInterval(Integer.parseInt(newVal));
-          return String.valueOf(datanodeManager.getHeartbeatRecheckInterval());
-        }
-      } catch (NumberFormatException nfe) {
-        throw new ReconfigurationException(property, newVal, getConf().get(
-            property), nfe);
-      } finally {
-        namesystem.writeUnlock();
-        LOG.info("RECONFIGURE* changed heartbeatRecheckInterval to "
-            + datanodeManager.getHeartbeatRecheckInterval());
-      }
-    case FS_PROTECTED_DIRECTORIES:
+    if (property.equals(DFS_HEARTBEAT_INTERVAL_KEY)) {
+      return reconfHeartbeatInterval(datanodeManager, property, newVal);
+    } else if (property.equals(DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY)) {
+      return reconfHeartbeatRecheckInterval(datanodeManager, property, newVal);
+    } else if (property.equals(FS_PROTECTED_DIRECTORIES)) {
-    case HADOOP_CALLER_CONTEXT_ENABLED_KEY:
+    } else if (property.equals(HADOOP_CALLER_CONTEXT_ENABLED_KEY)) {
-    default:
-      break;
+    } else if (property.equals(ipcClientRPCBackoffEnable)) {
+      return reconfigureIPCBackoffEnabled(newVal);
+    } else {
+      throw new ReconfigurationException(property, newVal, getConf().get(
+          property));
-    throw new ReconfigurationException(property, newVal, getConf()
-        .get(property));
+  }
+
+  private String reconfHeartbeatInterval(final DatanodeManager datanodeManager,
+      final String property, final String newVal)
+      throws ReconfigurationException {
+    namesystem.writeLock();
+    try {
+      if (newVal == null) {
+        // set to default
+        datanodeManager.setHeartbeatInterval(DFS_HEARTBEAT_INTERVAL_DEFAULT);
+        return String.valueOf(DFS_HEARTBEAT_INTERVAL_DEFAULT);
+      } else {
+        datanodeManager.setHeartbeatInterval(Long.parseLong(newVal));
+        return String.valueOf(datanodeManager.getHeartbeatInterval());
+      }
+    } catch (NumberFormatException nfe) {
+      throw new ReconfigurationException(property, newVal, getConf().get(
+          property), nfe);
+    } finally {
+      namesystem.writeUnlock();
+      LOG.info("RECONFIGURE* changed heartbeatInterval to "
+          + datanodeManager.getHeartbeatInterval());
+    }
+  }
+
+  private String reconfHeartbeatRecheckInterval(
+      final DatanodeManager datanodeManager, final String property,
+      final String newVal) throws ReconfigurationException {
+    namesystem.writeLock();
+    try {
+      if (newVal == null) {
+        // set to default
+        datanodeManager.setHeartbeatRecheckInterval(
+            DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT);
+        return String.valueOf(DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT);
+      } else {
+        datanodeManager.setHeartbeatRecheckInterval(Integer.parseInt(newVal));
+        return String.valueOf(datanodeManager.getHeartbeatRecheckInterval());
+      }
+    } catch (NumberFormatException nfe) {
+      throw new ReconfigurationException(property, newVal, getConf().get(
+          property), nfe);
+    } finally {
+      namesystem.writeUnlock();
+      LOG.info("RECONFIGURE* changed heartbeatRecheckInterval to "
+          + datanodeManager.getHeartbeatRecheckInterval());
+    }
+  String reconfigureIPCBackoffEnabled(String newVal) {
+    boolean clientBackoffEnabled;
+    if (newVal == null) {
+      clientBackoffEnabled = IPC_BACKOFF_ENABLE_DEFAULT;
+    } else {
+      clientBackoffEnabled = Boolean.parseBoolean(newVal);
+    }
+    rpcServer.getClientRpcServer()
+        .setClientBackoffEnabled(clientBackoffEnabled);
+    return Boolean.toString(clientBackoffEnabled);
+  }
+

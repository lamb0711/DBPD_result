Merge trunk into branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1396918 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import org.apache.hadoop.fs.FileContext;
+import org.apache.hadoop.fs.permission.FsPermission;
+import org.apache.hadoop.yarn.YarnException;
+  
+  private static String FILE_SCHEME = "file";
-    public MonitoringTimerTask(Configuration conf) {
+    public MonitoringTimerTask(Configuration conf) throws YarnException {
-          conf.getTrimmedStrings(YarnConfiguration.NM_LOCAL_DIRS));
+          validatePaths(conf.getTrimmedStrings(YarnConfiguration.NM_LOCAL_DIRS)));
-          conf.getTrimmedStrings(YarnConfiguration.NM_LOG_DIRS));
-      localDirsAllocator =
-          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS);
+          validatePaths(conf.getTrimmedStrings(YarnConfiguration.NM_LOG_DIRS)));
+      localDirsAllocator = new LocalDirAllocator(
+          YarnConfiguration.NM_LOCAL_DIRS);
+   * 
+    FileContext localFs;
+    try {
+      localFs = FileContext.getLocalFSFileContext(config);
+    } catch (IOException e) {
+      throw new YarnException("Unable to get the local filesystem", e);
+    }
+    FsPermission perm = new FsPermission((short)0755);
+    boolean createSucceeded = localDirs.createNonExistentDirs(localFs, perm);
+    createSucceeded &= logDirs.createNonExistentDirs(localFs, perm);
+    if (!createSucceeded) {
+      updateDirsAfterFailure();
+    }
+
-  private void updateDirsInConfiguration() {
+  private void updateDirsAfterFailure() {
+    LOG.info("Disk(s) failed. " + getDisksHealthReport());
+    if (!areDisksHealthy()) {
+      // Just log.
+      LOG.error("Most of the disks failed. " + getDisksHealthReport());
+    }
-        LOG.info("Disk(s) failed. " + getDisksHealthReport());
-        updateDirsInConfiguration();
-        if (!areDisksHealthy()) {
-          // Just log.
-          LOG.error("Most of the disks failed. " + getDisksHealthReport());
-        }
+        updateDirsAfterFailure();
+  
+  public static String[] validatePaths(String[] paths) {
+    ArrayList<String> validPaths = new ArrayList<String>();
+    for (int i = 0; i < paths.length; ++i) {
+      try {
+        URI uriPath = new URI(paths[i]);
+        if (uriPath.getScheme() == null
+            || uriPath.getScheme().equals(FILE_SCHEME)) {
+          validPaths.add(uriPath.getPath());
+        } else {
+          LOG.warn(paths[i] + " is not a valid path. Path should be with "
+              + FILE_SCHEME + " scheme or without scheme");
+          throw new YarnException(paths[i]
+              + " is not a valid path. Path should be with " + FILE_SCHEME
+              + " scheme or without scheme");
+        }
+      } catch (URISyntaxException e) {
+        LOG.warn(e.getMessage());
+        throw new YarnException(paths[i]
+            + " is not a valid path. Path should be with " + FILE_SCHEME
+            + " scheme or without scheme");
+      }
+    }
+    String[] arrValidPaths = new String[validPaths.size()];
+    validPaths.toArray(arrValidPaths);
+    return arrValidPaths;
+  }

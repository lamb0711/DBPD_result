HADOOP-16951: Tidy Up Text and ByteWritables Classes.

1. Remove superfluous code
2. Remove superfluous comments
3. Checkstyle fixes
4. Remove methods that simply call super.method()
5. Use Java 8 facilities to streamline code where applicable
6. Simplify and unify some of the constructs between the two classes
7. Expanding of the arrays be 1.5x instead of 2x per expansion.
+import java.util.Arrays;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
-  private static final byte[] EMPTY_BYTES = {};
+
+  private static final byte[] EMPTY_BYTES = new byte[0];
-  
+
-  public BytesWritable() {this(EMPTY_BYTES);}
-  
+  public BytesWritable() {
+    this.bytes = EMPTY_BYTES;
+    this.size = 0;
+  }
+
-  
+
-    byte[] result = new byte[size];
-    System.arraycopy(bytes, 0, result, 0, size);
-    return result;
+    return Arrays.copyOf(bytes, size);
-  
+
-  
+
-  
+
+   *
-  
+
-   * Change the capacity of the backing storage.
-   * The data is preserved.
-   * @param new_cap The new capacity in bytes.
+   * Change the capacity of the backing storage. The data is preserved.
+   *
+   * @param capacity The new capacity in bytes.
-  public void setCapacity(int new_cap) {
-    if (new_cap != getCapacity()) {
-      byte[] new_data = new byte[new_cap];
-      if (new_cap < size) {
-        size = new_cap;
-      }
-      if (size != 0) {
-        System.arraycopy(bytes, 0, new_data, 0, size);
-      }
-      bytes = new_data;
+  public void setCapacity(final int capacity) {
+    if (capacity != getCapacity()) {
+      this.size = Math.min(size, capacity);
+      this.bytes = Arrays.copyOf(this.bytes, capacity);
+   *
-   * Set the value to a copy of the given byte range
+   * Set the value to a copy of the given byte range.
+   *
-  // inherit javadoc
-  
-  // inherit javadoc
+
-  
-  @Override
-  public int hashCode() {
-    return super.hashCode();
-  }
+  @Override
+  public int hashCode() {
+    return super.hashCode();
+  }
+
-  public String toString() { 
-    StringBuilder sb = new StringBuilder(3*size);
-    for (int idx = 0; idx < size; idx++) {
-      // if not the first, put a blank separator in
-      if (idx != 0) {
-        sb.append(' ');
-      }
-      String num = Integer.toHexString(0xff & bytes[idx]);
-      // if it is only one digit, add a leading 0.
-      if (num.length() < 2) {
-        sb.append('0');
-      }
-      sb.append(num);
-    }
-    return sb.toString();
+  public String toString() {
+    return IntStream.range(0, size)
+        .mapToObj(idx -> String.format("%02x", bytes[idx]))
+        .collect(Collectors.joining(" "));
-    
+
-      return compareBytes(b1, s1+LENGTH_BYTES, l1-LENGTH_BYTES, 
-                          b2, s2+LENGTH_BYTES, l2-LENGTH_BYTES);
+      return compareBytes(b1, s1 + LENGTH_BYTES, l1 - LENGTH_BYTES,
+                          b2, s2 + LENGTH_BYTES, l2 - LENGTH_BYTES);
-  
+
-  
+

HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68

+import static org.apache.hadoop.hdfs.server.namenode.FSEditLogOpCodes.OP_MODIFY_PATH_BASED_CACHE_DIRECTIVE;
-import static org.apache.hadoop.hdfs.server.namenode.FSEditLogOpCodes.OP_REMOVE_PATH_BASED_CACHE_DESCRIPTOR;
+import static org.apache.hadoop.hdfs.server.namenode.FSEditLogOpCodes.OP_REMOVE_PATH_BASED_CACHE_DIRECTIVE;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hdfs.protocol.PathBasedCacheDirective;
-      inst.put(OP_REMOVE_PATH_BASED_CACHE_DESCRIPTOR,
-          new RemovePathBasedCacheDescriptorOp());
+      inst.put(OP_MODIFY_PATH_BASED_CACHE_DIRECTIVE,
+          new ModifyPathBasedCacheDirectiveOp());
+      inst.put(OP_REMOVE_PATH_BASED_CACHE_DIRECTIVE,
+          new RemovePathBasedCacheDirectiveOp());
-    String path;
-    short replication;
-    String pool;
+    PathBasedCacheDirective directive;
-    public AddPathBasedCacheDirectiveOp setPath(String path) {
-      this.path = path;
-      return this;
-    }
-
-    public AddPathBasedCacheDirectiveOp setReplication(short replication) {
-      this.replication = replication;
-      return this;
-    }
-
-    public AddPathBasedCacheDirectiveOp setPool(String pool) {
-      this.pool = pool;
+    public AddPathBasedCacheDirectiveOp setDirective(
+        PathBasedCacheDirective directive) {
+      this.directive = directive;
+      assert(directive.getId() != null);
+      assert(directive.getPath() != null);
+      assert(directive.getReplication() != null);
+      assert(directive.getPool() != null);
-      this.path = FSImageSerialization.readString(in);
-      this.replication = FSImageSerialization.readShort(in);
-      this.pool = FSImageSerialization.readString(in);
+      long id = FSImageSerialization.readLong(in);
+      String path = FSImageSerialization.readString(in);
+      short replication = FSImageSerialization.readShort(in);
+      String pool = FSImageSerialization.readString(in);
+      directive = new PathBasedCacheDirective.Builder().
+          setId(id).
+          setPath(new Path(path)).
+          setReplication(replication).
+          setPool(pool).
+          build();
-      FSImageSerialization.writeString(path, out);
-      FSImageSerialization.writeShort(replication, out);
-      FSImageSerialization.writeString(pool, out);
+      FSImageSerialization.writeLong(directive.getId(), out);
+      FSImageSerialization.writeString(directive.getPath().toUri().getPath(), out);
+      FSImageSerialization.writeShort(directive.getReplication(), out);
+      FSImageSerialization.writeString(directive.getPool(), out);
-      XMLUtils.addSaxString(contentHandler, "PATH", path);
+      XMLUtils.addSaxString(contentHandler, "ID",
+          directive.getId().toString());
+      XMLUtils.addSaxString(contentHandler, "PATH",
+          directive.getPath().toUri().getPath());
-          Short.toString(replication));
-      XMLUtils.addSaxString(contentHandler, "POOL", pool);
+          Short.toString(directive.getReplication()));
+      XMLUtils.addSaxString(contentHandler, "POOL", directive.getPool());
-      path = st.getValue("PATH");
-      replication = Short.parseShort(st.getValue("REPLICATION"));
-      pool = st.getValue("POOL");
+      directive = new PathBasedCacheDirective.Builder().
+          setId(Long.parseLong(st.getValue("ID"))).
+          setPath(new Path(st.getValue("PATH"))).
+          setReplication(Short.parseShort(st.getValue("REPLICATION"))).
+          setPool(st.getValue("POOL")).
+          build();
-      builder.append("path=" + path + ",");
-      builder.append("replication=" + replication + ",");
-      builder.append("pool=" + pool);
+      builder.append("id=" + directive.getId() + ",");
+      builder.append("path=" + directive.getPath().toUri().getPath() + ",");
+      builder.append("replication=" + directive.getReplication() + ",");
+      builder.append("pool=" + directive.getPool());
-   * {@link ClientProtocol#removePathBasedCacheDescriptor}
+   * {@link ClientProtocol#modifyPathBasedCacheDirective}
-  static class RemovePathBasedCacheDescriptorOp extends FSEditLogOp {
+  static class ModifyPathBasedCacheDirectiveOp extends FSEditLogOp {
+    PathBasedCacheDirective directive;
+
+    public ModifyPathBasedCacheDirectiveOp() {
+      super(OP_MODIFY_PATH_BASED_CACHE_DIRECTIVE);
+    }
+
+    static ModifyPathBasedCacheDirectiveOp getInstance(OpInstanceCache cache) {
+      return (ModifyPathBasedCacheDirectiveOp) cache
+          .get(OP_MODIFY_PATH_BASED_CACHE_DIRECTIVE);
+    }
+
+    public ModifyPathBasedCacheDirectiveOp setDirective(
+        PathBasedCacheDirective directive) {
+      this.directive = directive;
+      assert(directive.getId() != null);
+      return this;
+    }
+
+    @Override
+    void readFields(DataInputStream in, int logVersion) throws IOException {
+      PathBasedCacheDirective.Builder builder =
+          new PathBasedCacheDirective.Builder();
+      builder.setId(FSImageSerialization.readLong(in));
+      byte flags = in.readByte();
+      if ((flags & 0x1) != 0) {
+        builder.setPath(new Path(FSImageSerialization.readString(in)));
+      }
+      if ((flags & 0x2) != 0) {
+        builder.setReplication(FSImageSerialization.readShort(in));
+      }
+      if ((flags & 0x4) != 0) {
+        builder.setPool(FSImageSerialization.readString(in));
+      }
+      if ((flags & ~0x7) != 0) {
+        throw new IOException("unknown flags set in " +
+            "ModifyPathBasedCacheDirectiveOp: " + flags);
+      }
+      this.directive = builder.build();
+      readRpcIds(in, logVersion);
+    }
+
+    @Override
+    public void writeFields(DataOutputStream out) throws IOException {
+      FSImageSerialization.writeLong(directive.getId(), out);
+      byte flags = (byte)(
+          ((directive.getPath() != null) ? 0x1 : 0) |
+          ((directive.getReplication() != null) ? 0x2 : 0) |
+          ((directive.getPool() != null) ? 0x4 : 0)
+        );
+      out.writeByte(flags);
+      if (directive.getPath() != null) {
+        FSImageSerialization.writeString(
+            directive.getPath().toUri().getPath(), out);
+      }
+      if (directive.getReplication() != null) {
+        FSImageSerialization.writeShort(directive.getReplication(), out);
+      }
+      if (directive.getPool() != null) {
+        FSImageSerialization.writeString(directive.getPool(), out);
+      }
+      writeRpcIds(rpcClientId, rpcCallId, out);
+    }
+
+    @Override
+    protected void toXml(ContentHandler contentHandler) throws SAXException {
+      XMLUtils.addSaxString(contentHandler, "ID",
+          Long.toString(directive.getId()));
+      if (directive.getPath() != null) {
+        XMLUtils.addSaxString(contentHandler, "PATH",
+            directive.getPath().toUri().getPath());
+      }
+      if (directive.getReplication() != null) {
+        XMLUtils.addSaxString(contentHandler, "REPLICATION",
+            Short.toString(directive.getReplication()));
+      }
+      if (directive.getPool() != null) {
+        XMLUtils.addSaxString(contentHandler, "POOL", directive.getPool());
+      }
+      appendRpcIdsToXml(contentHandler, rpcClientId, rpcCallId);
+    }
+
+    @Override
+    void fromXml(Stanza st) throws InvalidXmlException {
+      PathBasedCacheDirective.Builder builder =
+          new PathBasedCacheDirective.Builder();
+      builder.setId(Long.parseLong(st.getValue("ID")));
+      String path = st.getValueOrNull("PATH");
+      if (path != null) {
+        builder.setPath(new Path(path));
+      }
+      String replicationString = st.getValueOrNull("REPLICATION");
+      if (replicationString != null) {
+        builder.setReplication(Short.parseShort(replicationString));
+      }
+      String pool = st.getValueOrNull("POOL");
+      if (pool != null) {
+        builder.setPool(pool);
+      }
+      this.directive = builder.build();
+      readRpcIdsFromXml(st);
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder builder = new StringBuilder();
+      builder.append("ModifyPathBasedCacheDirectiveOp[");
+      builder.append("id=").append(directive.getId());
+      if (directive.getPath() != null) {
+        builder.append(",").append("path=").append(directive.getPath());
+      }
+      if (directive.getReplication() != null) {
+        builder.append(",").append("replication=").
+            append(directive.getReplication());
+      }
+      if (directive.getPool() != null) {
+        builder.append(",").append("pool=").append(directive.getPool());
+      }
+      appendRpcIdsToString(builder, rpcClientId, rpcCallId);
+      builder.append("]");
+      return builder.toString();
+    }
+  }
+
+  /**
+   * {@literal @AtMostOnce} for
+   * {@link ClientProtocol#removePathBasedCacheDirective}
+   */
+  static class RemovePathBasedCacheDirectiveOp extends FSEditLogOp {
-    public RemovePathBasedCacheDescriptorOp() {
-      super(OP_REMOVE_PATH_BASED_CACHE_DESCRIPTOR);
+    public RemovePathBasedCacheDirectiveOp() {
+      super(OP_REMOVE_PATH_BASED_CACHE_DIRECTIVE);
-    static RemovePathBasedCacheDescriptorOp getInstance(OpInstanceCache cache) {
-      return (RemovePathBasedCacheDescriptorOp) cache
-          .get(OP_REMOVE_PATH_BASED_CACHE_DESCRIPTOR);
+    static RemovePathBasedCacheDirectiveOp getInstance(OpInstanceCache cache) {
+      return (RemovePathBasedCacheDirectiveOp) cache
+          .get(OP_REMOVE_PATH_BASED_CACHE_DIRECTIVE);
-    public RemovePathBasedCacheDescriptorOp setId(long id) {
+    public RemovePathBasedCacheDirectiveOp setId(long id) {
-      builder.append("RemovePathBasedCacheDescriptor [");
+      builder.append("RemovePathBasedCacheDirective [");

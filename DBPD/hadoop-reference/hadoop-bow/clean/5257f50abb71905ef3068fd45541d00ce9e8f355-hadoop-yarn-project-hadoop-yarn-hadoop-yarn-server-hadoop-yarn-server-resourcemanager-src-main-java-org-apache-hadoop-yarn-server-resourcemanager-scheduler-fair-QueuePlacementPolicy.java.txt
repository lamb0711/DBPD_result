YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.

-import java.util.Set;
-import org.apache.hadoop.security.Groups;
-import org.apache.hadoop.util.ReflectionUtils;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.DefaultPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.FSPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.PlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.PrimaryGroupPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.RejectPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.SecondaryGroupExistingPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.SpecifiedPlacementRule;
+import org.apache.hadoop.yarn.server.resourcemanager.placement.UserPlacementRule;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import static org.apache.hadoop.yarn.server.resourcemanager.placement.PlacementFactory.getPlacementRule;
+
+/**
+ * The FairScheduler rules based policy for placing an application in a queue.
+ * It parses the configuration and updates the {@link
+ * org.apache.hadoop.yarn.server.resourcemanager.placement.PlacementManager}
+ * with a list of {@link PlacementRule}s to execute in order.
+ */
-public class QueuePlacementPolicy {
-  private static final Map<String, Class<? extends QueuePlacementRule>> ruleClasses;
-  static {
-    Map<String, Class<? extends QueuePlacementRule>> map =
-        new HashMap<String, Class<? extends QueuePlacementRule>>();
-    map.put("user", QueuePlacementRule.User.class);
-    map.put("primaryGroup", QueuePlacementRule.PrimaryGroup.class);
-    map.put("secondaryGroupExistingQueue",
-        QueuePlacementRule.SecondaryGroupExistingQueue.class);
-    map.put("specified", QueuePlacementRule.Specified.class);
-    map.put("nestedUserQueue",
-        QueuePlacementRule.NestedUserQueue.class);
-    map.put("default", QueuePlacementRule.Default.class);
-    map.put("reject", QueuePlacementRule.Reject.class);
-    ruleClasses = Collections.unmodifiableMap(map);
+final class QueuePlacementPolicy {
+  private static final Logger LOG =
+      LoggerFactory.getLogger(QueuePlacementPolicy.class);
+
+  // Simple private class to make the rule mapping simpler.
+  private static final class RuleMap {
+    private final Class<? extends PlacementRule> ruleClass;
+    private final String terminal;
+
+    private RuleMap(Class<? extends PlacementRule> clazz, String terminate) {
+      this.ruleClass = clazz;
+      this.terminal = terminate;
+    }
-  
-  private final List<QueuePlacementRule> rules;
-  private final Map<FSQueueType, Set<String>> configuredQueues;
-  private final Groups groups;
-  
-  public QueuePlacementPolicy(List<QueuePlacementRule> rules,
-      Map<FSQueueType, Set<String>> configuredQueues, Configuration conf)
+
+  // The list of known rules:
+  // key to the map is the name in the configuration.
+  // for each name the mapping contains the class name of the implementation
+  // and a flag (true, false or create) which describes the terminal state
+  // see the method getTerminal() for more comments.
+  private static final Map<String, RuleMap> RULES;
+  static {
+    Map<String, RuleMap> map = new HashMap<>();
+    map.put("user", new RuleMap(UserPlacementRule.class, "create"));
+    map.put("primaryGroup",
+        new RuleMap(PrimaryGroupPlacementRule.class, "create"));
+    map.put("secondaryGroupExistingQueue",
+        new RuleMap(SecondaryGroupExistingPlacementRule.class, "false"));
+    map.put("specified", new RuleMap(SpecifiedPlacementRule.class, "false"));
+    map.put("nestedUserQueue", new RuleMap(UserPlacementRule.class, "create"));
+    map.put("default", new RuleMap(DefaultPlacementRule.class, "create"));
+    map.put("reject", new RuleMap(RejectPlacementRule.class, "true"));
+    RULES = Collections.unmodifiableMap(map);
+  }
+
+  private QueuePlacementPolicy() {
+  }
+
+  /**
+   * Update the rules in the manager based on this placement policy.
+   * @param newRules The new list of rules to set in the manager.
+   * @param newTerminalState The list of terminal states for this set of rules.
+   * @param fs the reference to the scheduler needed in the rule on init.
+   * @throws AllocationConfigurationException for any errors
+   */
+  private static void updateRuleSet(List<PlacementRule> newRules,
+                                    List<Boolean> newTerminalState,
+                                    FairScheduler fs)
-    for (int i = 0; i < rules.size()-1; i++) {
-      if (rules.get(i).isTerminal()) {
+    if (newRules.isEmpty()) {
+      LOG.debug("Empty rule set defined, ignoring update");
+      return;
+    }
+    LOG.debug("Placement rule order check");
+    for (int i = 0; i < newTerminalState.size()-1; i++) {
+      if (newTerminalState.get(i)) {
-            + i + " in queue placement policy can never be reached");
+            + (i+1) + " in queue placement policy can never be reached");
-    if (!rules.get(rules.size()-1).isTerminal()) {
+    if (!newTerminalState.get(newTerminalState.size()-1)) {
-    this.rules = rules;
-    this.configuredQueues = configuredQueues;
-    groups = new Groups(conf);
+    // Set the scheduler in the rule to get queues etc
+    LOG.debug("Initialising new rule set");
+    try {
+      for (PlacementRule rule: newRules){
+        rule.initialize(fs);
+      }
+    } catch (IOException ioe) {
+      // We should never throw as we pass in a FS object, however we still
+      // should consider any exception here a config error.
+      throw new AllocationConfigurationException(
+          "Rule initialisation failed with exception", ioe);
+    }
+    // Update the placement manager with the new rule list.
+    // We only get here when all rules are OK.
+    fs.getRMContext().getQueuePlacementManager().updateRules(newRules);
+    LOG.debug("PlacementManager active with new rule set");
-  
+
-   * Builds a QueuePlacementPolicy from an xml element.
+   * Builds a QueuePlacementPolicy from a xml element.
+   * @param confElement the placement policy xml snippet from the
+   *                    {@link FairSchedulerConfiguration}
+   * @param fs the reference to the scheduler needed in the rule on init.
+   * @throws AllocationConfigurationException for any errors
-  public static QueuePlacementPolicy fromXml(Element el,
-      Map<FSQueueType, Set<String>> configuredQueues, Configuration conf)
+  static void fromXml(Element confElement, FairScheduler fs)
-    List<QueuePlacementRule> rules = new ArrayList<QueuePlacementRule>();
-    NodeList elements = el.getChildNodes();
+    LOG.debug("Reloading placement policy from allocation config");
+    if (confElement == null || !confElement.hasChildNodes()) {
+      throw new AllocationConfigurationException(
+          "Empty configuration for QueuePlacementPolicy is not allowed");
+    }
+    List<PlacementRule> newRules = new ArrayList<>();
+    List<Boolean> newTerminalState = new ArrayList<>();
+    NodeList elements = confElement.getChildNodes();
-      if (node instanceof Element) {
-        QueuePlacementRule rule = createAndInitializeRule(node);
-        rules.add(rule);
+      if (node instanceof Element &&
+          node.getNodeName().equalsIgnoreCase("rule")) {
+        String name = ((Element) node).getAttribute("name");
+        LOG.debug("Creating new rule: {}", name);
+        PlacementRule rule = createRule((Element)node);
+
+        // The only child node that we currently know is a parent rule
+        PlacementRule parentRule = null;
+        String parentName = null;
+        Element child = getParentRuleElement(node);
+        if (child != null) {
+          parentName = child.getAttribute("name");
+          parentRule = getParentRule(child, fs);
+        }
+        // Need to make sure that the nestedUserQueue has a parent for
+        // backwards compatibility
+        if (name.equalsIgnoreCase("nestedUserQueue") && parentRule == null) {
+          throw new AllocationConfigurationException("Rule '" + name
+              + "' must have a parent rule set");
+        }
+        newRules.add(rule);
+        if (parentRule == null) {
+          newTerminalState.add(
+              getTerminal(RULES.get(name).terminal, rule));
+        } else {
+          ((FSPlacementRule)rule).setParentRule(parentRule);
+          newTerminalState.add(
+              getTerminal(RULES.get(name).terminal, rule) &&
+              getTerminal(RULES.get(parentName).terminal, parentRule));
+        }
-    return new QueuePlacementPolicy(rules, configuredQueues, conf);
+    updateRuleSet(newRules, newTerminalState, fs);
-  
+
-   * Create and initialize a rule given a xml node
-   * @param node
-   * @return QueuePlacementPolicy
-   * @throws AllocationConfigurationException
+   * Find the element that defines the parent rule.
+   * @param node the xml node to check for a parent rule
+   * @return {@link Element} that describes the parent rule or
+   * <code>null</code> if none is found
-  public static QueuePlacementRule createAndInitializeRule(Node node)
+  private static Element getParentRuleElement(Node node)
-    Element element = (Element) node;
+    Element parent = null;
+    // walk over the node list
+    if (node.hasChildNodes()) {
+      NodeList childList = node.getChildNodes();
+      for (int j = 0; j < childList.getLength(); j++) {
+        Node child = childList.item(j);
+        if (child instanceof Element &&
+            child.getNodeName().equalsIgnoreCase("rule")) {
+          if (parent != null) {
+            LOG.warn("Rule '{}' has multiple parent rules defined, only the " +
+                "last parent rule will be used",
+                ((Element) node).getAttribute("name"));
+          }
+          parent = ((Element) child);
+        }
+      }
+    }
+    // sanity check the rule that is configured
+    if (parent != null) {
+      String parentName = parent.getAttribute("name");
+      if (parentName.equals("reject") ||
+          parentName.equals("nestedUserQueue")) {
+        throw new AllocationConfigurationException("Rule '"
+            + parentName
+            + "' is not allowed as a parent rule for any rule");
+      }
+    }
+    return parent;
+  }
+
+  /**
+   * Retrieve the configured parent rule from the xml config.
+   * @param parent the xml element that contains the name of the rule to add.
+   * @param fs the reference to the scheduler needed in the rule on init.
+   * @return {@link PlacementRule} to set as a parent
+   * @throws AllocationConfigurationException for any error
+   */
+  private static PlacementRule getParentRule(Element parent,
+                                             FairScheduler fs)
+      throws AllocationConfigurationException {
+    LOG.debug("Creating new parent rule: {}", parent.getAttribute("name"));
+    PlacementRule parentRule = createRule(parent);
+    // Init the rule, we do not want to add it to the list of the
+    // placement manager
+    try {
+      parentRule.initialize(fs);
+    } catch (IOException ioe) {
+      // We should never throw as we pass in a FS object, however we
+      // still should consider any exception here a config error.
+      throw new AllocationConfigurationException(
+          "Parent Rule initialisation failed with exception", ioe);
+    }
+    return parentRule;
+  }
+
+  /**
+   * Returns the terminal status of the rule based on the definition and the
+   * create flag set in the rule.
+   * @param terminal The definition of the terminal flag
+   * @param rule The rule to check
+   * @return <code>true</code> if the rule is terminal <code>false</code> in
+   * all other cases.
+   */
+  private static Boolean getTerminal(String terminal, PlacementRule rule) {
+    switch (terminal) {
+    case "true":    // rule is always terminal
+      return true;
+    case "false":   // rule is never terminal
+      return false;
+    default:        // rule is terminal based on the create flag
+      return ((FSPlacementRule)rule).getCreateFlag();
+    }
+  }
+
+  /**
+   * Create a rule from a given a xml node.
+   * @param element the xml element to create the rule from
+   * @return PlacementRule
+   * @throws AllocationConfigurationException for any error
+   */
+  @SuppressWarnings("unchecked")
+  private static PlacementRule createRule(Element element)
+      throws AllocationConfigurationException {
-    Class<? extends QueuePlacementRule> clazz = ruleClasses.get(ruleName);
-    if (clazz == null) {
+    Class<? extends PlacementRule> ruleClass = null;
+    if (RULES.containsKey(ruleName)) {
+      ruleClass = RULES.get(ruleName).ruleClass;
+    }
+    if (ruleClass == null) {
-    QueuePlacementRule rule = ReflectionUtils.newInstance(clazz, null);
-    rule.initializeFromXml(element);
-    return rule;
+    return getPlacementRule(ruleClass, element);
-   * Build a simple queue placement policy from the allow-undeclared-pools and
-   * user-as-default-queue configuration options.
+   * Build a simple queue placement policy from the configuration options
+   * {@link FairSchedulerConfiguration#ALLOW_UNDECLARED_POOLS} and
+   * {@link FairSchedulerConfiguration#USER_AS_DEFAULT_QUEUE}.
+   * @param fs the reference to the scheduler needed in the rule on init.
-  public static QueuePlacementPolicy fromConfiguration(Configuration conf,
-      Map<FSQueueType, Set<String>> configuredQueues) {
+  static void fromConfiguration(FairScheduler fs) {
+    LOG.debug("Creating base placement policy from config");
+    Configuration conf = fs.getConfig();
+
-    List<QueuePlacementRule> rules = new ArrayList<QueuePlacementRule>();
-    rules.add(new QueuePlacementRule.Specified().initialize(create, null));
+    List<PlacementRule> newRules = new ArrayList<>();
+    List<Boolean> newTerminalState = new ArrayList<>();
+    Class<? extends PlacementRule> clazz =
+        RULES.get("specified").ruleClass;
+    newRules.add(getPlacementRule(clazz, create));
+    newTerminalState.add(false);
-      rules.add(new QueuePlacementRule.User().initialize(create, null));
+      clazz = RULES.get("user").ruleClass;
+      newRules.add(getPlacementRule(clazz, create));
+      newTerminalState.add(create);
-      rules.add(new QueuePlacementRule.Default().initialize(true, null));
+      clazz = RULES.get("default").ruleClass;
+      newRules.add(getPlacementRule(clazz, true));
+      newTerminalState.add(true);
-      return new QueuePlacementPolicy(rules, configuredQueues, conf);
+      updateRuleSet(newRules, newTerminalState, fs);
-      		"placement policy from conf", ex);
+          "placement policy from conf", ex);
-
-  /**
-   * Applies this rule to an app with the given requested queue and user/group
-   * information.
-   * 
-   * @param requestedQueue
-   *    The queue specified in the ApplicationSubmissionContext
-   * @param user
-   *    The user submitting the app
-   * @return
-   *    The name of the queue to assign the app to.  Or null if the app should
-   *    be rejected.
-   * @throws IOException
-   *    If an exception is encountered while getting the user's groups
-   */
-  public String assignAppToQueue(String requestedQueue, String user)
-      throws IOException {
-    for (QueuePlacementRule rule : rules) {
-      String queue = rule.assignAppToQueue(requestedQueue, user, groups,
-          configuredQueues);
-      if (queue == null || !queue.isEmpty()) {
-        return queue;
-      }
-    }
-    throw new IllegalStateException("Should have applied a rule before " +
-    		"reaching here");
-  }
-  
-  public List<QueuePlacementRule> getRules() {
-    return rules;
-  }

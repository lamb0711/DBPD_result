HDFS-13946. Log longest FSN write/read lock held stack trace.

+import java.util.concurrent.atomic.AtomicReference;
+import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
-  /** Longest time (ms) a read lock was held since the last report. */
-  private final AtomicLong longestReadLockHeldIntervalMs = new AtomicLong(0);
+  /**
+   * The info (lock held time and stack trace) when longest time (ms) a read
+   * lock was held since the last report.
+   */
+  private final AtomicReference<ReadLockHeldInfo> longestReadLockHeldInfo =
+      new AtomicReference<>(new ReadLockHeldInfo(0, null));
+
+  /**
+   * The stack trace when longest time of the write lock
+   * was held since the last report.
+   */
+  private volatile String longestWriteLockHeldStackTrace;
-      long localLongestReadLock;
+      ReadLockHeldInfo localLockHeldInfo;
-        localLongestReadLock = longestReadLockHeldIntervalMs.get();
-      } while (localLongestReadLock - readLockIntervalMs < 0 &&
-          !longestReadLockHeldIntervalMs.compareAndSet(localLongestReadLock,
-              readLockIntervalMs));
+        localLockHeldInfo = longestReadLockHeldInfo.get();
+      } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs < 0 &&
+          !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,
+              new ReadLockHeldInfo(readLockIntervalMs,
+                  StringUtils.getStackTrace(Thread.currentThread()))));
-      long longestLockHeldIntervalMs =
-          longestReadLockHeldIntervalMs.getAndSet(0);
-      FSNamesystem.LOG.info("FSNamesystem read lock held for " +
-          readLockIntervalMs + " ms via\n" +
-          StringUtils.getStackTrace(Thread.currentThread()) +
-          "\tNumber of suppressed read-lock reports: " + numSuppressedWarnings +
-          "\n\tLongest read-lock held interval: " + longestLockHeldIntervalMs);
+      ReadLockHeldInfo lockHeldInfo = longestReadLockHeldInfo
+          .getAndSet(new ReadLockHeldInfo(0, null));
+      FSNamesystem.LOG.info(
+          "\tNumber of suppressed read-lock reports: {}" +
+          "\n\tLongest read-lock held interval: {}ms via {}",
+          numSuppressedWarnings, lockHeldInfo.getIntervalMs(),
+          lockHeldInfo.getStackTrace());
+      SummaryStatistics currentStats =
+          writeLockReportLogger.getCurrentStats("write", 0);
+      double currentMaxTime = currentStats != null ? currentStats.getMax() : 0;
+      if (currentMaxTime < writeLockIntervalMs) {
+        longestWriteLockHeldStackTrace =
+            StringUtils.getStackTrace(Thread.currentThread());
+      }
+
-      FSNamesystem.LOG.info("FSNamesystem write lock held for {} ms via {}\t" +
-          "Number of suppressed write-lock reports: {}\n\tLongest write-lock " +
-          "held interval: {} \n\tTotal suppressed write-lock held time: {}",
-          writeLockIntervalMs,
-          StringUtils.getStackTrace(Thread.currentThread()),
+      FSNamesystem.LOG.info(
+          "\tNumber of suppressed write-lock reports: {}" +
+          "\n\tLongest write-lock held interval: {}ms via {} " +
+          "\n\tTotal suppressed write-lock held time: {}",
+          longestWriteLockHeldStackTrace,
+
+  /**
+   * Read lock Held Info.
+   */
+  private static class ReadLockHeldInfo {
+    /** Read lock held time. */
+    private Long intervalMs;
+    /** The stack trace read lock was held. */
+    private String stackTrace;
+
+    ReadLockHeldInfo(long intervalMs, String stackTrace) {
+      this.intervalMs = intervalMs;
+      this.stackTrace = stackTrace;
+    }
+
+    public Long getIntervalMs() {
+      return this.intervalMs;
+    }
+
+    public String getStackTrace() {
+      return this.stackTrace;
+    }
+
+    @Override
+    public int hashCode() {
+      return this.intervalMs.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      return obj instanceof ReadLockHeldInfo && ((ReadLockHeldInfo) obj)
+          .getIntervalMs().compareTo(intervalMs) == 0;
+    }
+  }

YARN-3946. Update exact reason as to why a submitted app is in ACCEPTED state to app's diagnostic message. (Naganarasimha G R via wangda)

-import java.util.Collections;
+import org.apache.commons.lang.time.FastDateFormat;
+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMApp;
+  private FastDateFormat fdf =
+      FastDateFormat.getInstance("EEE MMM dd HH:mm:ss Z yyyy");
+
-  private String appAMNodePartitionName = CommonNodeLabelsManager.NO_LABEL;
+  protected String appAMNodePartitionName = CommonNodeLabelsManager.NO_LABEL;
-  
+
+  private RMAppAttempt appAttempt;
+
+      RMApp rmApp = rmContext.getRMApps().get(applicationAttemptId.getApplicationId());
-          rmContext.getRMApps().get(applicationAttemptId.getApplicationId())
+          rmApp
+      appAttempt = rmApp.getCurrentAppAttempt();
-    if (isWaitingForAMContainer(getApplicationId())) {
+    if (isWaitingForAMContainer()) {
-  public boolean isWaitingForAMContainer(ApplicationId applicationId) {
+  public boolean isWaitingForAMContainer() {
-    RMAppAttempt appAttempt =
-        rmContext.getRMApps().get(applicationId).getCurrentAppAttempt();
-    return (appAttempt != null && appAttempt.getMasterContainer() == null
-        && appAttempt.getSubmissionContext().getUnmanagedAM() == false);
+    return (!unmanagedAM && appAttempt.getMasterContainer() == null);
-    boolean useAMBlacklist = isWaitingForAMContainer(getApplicationId());
+    boolean useAMBlacklist = isWaitingForAMContainer();
+
+  public void updateAMContainerDiagnostics(AMState state,
+      String diagnosticMessage) {
+    if (!isWaitingForAMContainer()) {
+      return;
+    }
+    StringBuilder diagnosticMessageBldr = new StringBuilder();
+    diagnosticMessageBldr.append("[");
+    diagnosticMessageBldr.append(fdf.format(System.currentTimeMillis()));
+    diagnosticMessageBldr.append("] ");
+    switch (state) {
+    case INACTIVATED:
+      diagnosticMessageBldr.append(state.diagnosticMessage);
+      if (diagnosticMessage != null) {
+        diagnosticMessageBldr.append(diagnosticMessage);
+      }
+      getPendingAppDiagnosticMessage(diagnosticMessageBldr);
+      break;
+    case ACTIVATED:
+      diagnosticMessageBldr.append(state.diagnosticMessage);
+      if (diagnosticMessage != null) {
+        diagnosticMessageBldr.append(diagnosticMessage);
+      }
+      getActivedAppDiagnosticMessage(diagnosticMessageBldr);
+      break;
+    default:
+      // UNMANAGED , ASSIGNED
+      diagnosticMessageBldr.append(state.diagnosticMessage);
+      break;
+    }
+    appAttempt.updateAMLaunchDiagnostics(diagnosticMessageBldr.toString());
+  }
+
+  protected void getPendingAppDiagnosticMessage(
+      StringBuilder diagnosticMessage) {
+    // Give the specific information which might be applicable for the
+    // respective scheduler
+    // like partitionAMResourcelimit,UserAMResourceLimit, queue'AMResourceLimit
+  }
+
+  protected void getActivedAppDiagnosticMessage(
+      StringBuilder diagnosticMessage) {
+    // Give the specific information which might be applicable for the
+    // respective scheduler
+    // queue's resource usage for specific partition
+  }
+
+  public static enum AMState {
+    UNMANAGED("User launched the Application Master, since it's unmanaged. "),
+    INACTIVATED("Application is added to the scheduler and is not yet activated. "),
+    ACTIVATED("Application is Activated, waiting for resources to be assigned for AM. "),
+    ASSIGNED("Scheduler has assigned a container for AM, waiting for AM "
+        + "container to be launched"),
+    LAUNCHED("AM container is launched, waiting for AM container to Register "
+        + "with RM")
+    ;
+
+    private String diagnosticMessage;
+
+    AMState(String diagnosticMessage) {
+      this.diagnosticMessage = diagnosticMessage;
+    }
+
+    public String getDiagnosticMessage() {
+      return diagnosticMessage;
+    }
+  }

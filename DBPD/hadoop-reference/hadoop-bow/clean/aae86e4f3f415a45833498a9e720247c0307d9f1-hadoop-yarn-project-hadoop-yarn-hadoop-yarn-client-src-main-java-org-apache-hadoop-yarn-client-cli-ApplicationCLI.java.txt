merge changes from trunk to HDFS-4949 branch

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524865 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.EnumSet;
+import org.apache.commons.cli.MissingArgumentException;
+import org.apache.hadoop.yarn.api.records.YarnApplicationState;
+  private static final String APP_STATE_CMD ="appStates";
+  private static final String ALLSTATES_OPTION = "ALL";
+
+  private boolean allAppStates;
-        "Supports optional use of --appTypes to filter applications " +
-        "based on application type.");
+        "Supports optional use of -appTypes to filter applications " +
+        "based on application type, " +
+        "and -appStates to filter applications based on application state");
-    Option appTypeOpt = new Option(APP_TYPE_CMD, true,
-        "Works with --list to filter applications based on their type.");
+    Option appTypeOpt = new Option(APP_TYPE_CMD, true, "Works with -list to " +
+        "filter applications based on " +
+        "input comma-separated list of application types.");
-    appTypeOpt.setArgName("Comma-separated list of application types");
+    appTypeOpt.setArgName("Types");
+    Option appStateOpt = new Option(APP_STATE_CMD, true, "Works with -list " +
+        "to filter applications based on input comma-separated list of " +
+        "application states. " + getAllValidApplicationStates());
+    appStateOpt.setValueSeparator(',');
+    appStateOpt.setArgs(Option.UNLIMITED_VALUES);
+    appStateOpt.setArgName("States");
+    opts.addOption(appStateOpt);
-    CommandLine cliParser = new GnuParser().parse(opts, args);
+    CommandLine cliParser = null;
+    try {
+      cliParser = new GnuParser().parse(opts, args);
+    } catch (MissingArgumentException ex) {
+      sysout.println("Missing argument for options");
+      printUsage(opts);
+      return exitCode;
+    }
+
+      allAppStates = false;
-              appTypes.add(type.trim());
+              appTypes.add(type.toUpperCase().trim());
-      listApplications(appTypes);
+
+      EnumSet<YarnApplicationState> appStates =
+          EnumSet.noneOf(YarnApplicationState.class);
+      if (cliParser.hasOption(APP_STATE_CMD)) {
+        String[] states = cliParser.getOptionValues(APP_STATE_CMD);
+        if (states != null) {
+          for (String state : states) {
+            if (!state.trim().isEmpty()) {
+              if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {
+                allAppStates = true;
+                break;
+              }
+              try {
+                appStates.add(YarnApplicationState.valueOf(state.toUpperCase()
+                    .trim()));
+              } catch (IllegalArgumentException ex) {
+                sysout.println("The application state " + state
+                    + " is invalid.");
+                sysout.println(getAllValidApplicationStates());
+                return exitCode;
+              }
+            }
+          }
+        }
+      }
+      listApplications(appTypes, appStates);
-   * present in the Resource Manager
+   * And application States present in the Resource Manager
+   * @param appStates
-  private void listApplications(Set<String> appTypes)
-      throws YarnException, IOException {
+  private void listApplications(Set<String> appTypes,
+      EnumSet<YarnApplicationState> appStates) throws YarnException,
+      IOException {
-    List<ApplicationReport> appsReport =
-        client.getApplications(appTypes);
+    if (allAppStates) {
+      for(YarnApplicationState appState : YarnApplicationState.values()) {
+        appStates.add(appState);
+      }
+    } else {
+      if (appStates.isEmpty()) {
+        appStates.add(YarnApplicationState.RUNNING);
+        appStates.add(YarnApplicationState.ACCEPTED);
+        appStates.add(YarnApplicationState.SUBMITTED);
+      }
+    }
-    writer.println("Total Applications:" + appsReport.size());
+    List<ApplicationReport> appsReport =
+        client.getApplications(appTypes, appStates);
+
+    writer
+        .println("Total number of applications (application-types: " + appTypes
+            + " and states: " + appStates + ")" + ":" + appsReport.size());
-    sysout.println("Killing application " + applicationId);
-    client.killApplication(appId);
+    ApplicationReport appReport = client.getApplicationReport(appId);
+    if (appReport.getYarnApplicationState() == YarnApplicationState.FINISHED
+        || appReport.getYarnApplicationState() == YarnApplicationState.KILLED
+        || appReport.getYarnApplicationState() == YarnApplicationState.FAILED) {
+      sysout.println("Application " + applicationId + " has already finished ");
+    } else {
+      sysout.println("Killing application " + applicationId);
+      client.killApplication(appId);
+    }
+  private String getAllValidApplicationStates() {
+    StringBuilder sb = new StringBuilder();
+    sb.append("The valid application state can be"
+        + " one of the following: ");
+    sb.append(ALLSTATES_OPTION + ",");
+    for (YarnApplicationState appState : YarnApplicationState
+        .values()) {
+      sb.append(appState+",");
+    }
+    String output = sb.toString();
+    return output.substring(0, output.length()-1);
+  }

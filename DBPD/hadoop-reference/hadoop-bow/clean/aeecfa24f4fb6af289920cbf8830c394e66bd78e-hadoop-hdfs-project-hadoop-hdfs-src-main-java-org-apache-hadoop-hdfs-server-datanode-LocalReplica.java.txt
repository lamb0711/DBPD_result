HADOOP-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.

-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.fs.FileStatus;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
-  static final Log LOG = LogFactory.getLog(LocalReplica.class);
-  private final static boolean IS_NATIVE_IO_AVAIL;
-  static {
-    IS_NATIVE_IO_AVAIL = NativeIO.isAvailable();
-    if (Path.WINDOWS && !IS_NATIVE_IO_AVAIL) {
-      LOG.warn("Data node cannot fully support concurrent reading"
-          + " and writing without native code extensions on Windows.");
-    }
-  }
+  static final Logger LOG = LoggerFactory.getLogger(LocalReplica.class);
-        IOUtils.copyBytes(in, out, 16 * 1024);
+        copyBytes(in, out, 16 * 1024);
-      FileUtil.replaceFile(tmpFile, file);
+      replaceFile(tmpFile, file);
-    int linkCount = HardLink.getLinkCount(file);
+    int linkCount = getHardLinkCount(file);
-    if (HardLink.getLinkCount(meta) > 1) {
+    if (getHardLinkCount(meta) > 1) {
-
-    File blockFile = getBlockFile();
-    if (IS_NATIVE_IO_AVAIL) {
-      return NativeIO.getShareDeleteFileInputStream(blockFile, seekOffset);
-    } else {
-      try {
-        return FsDatasetUtil.openAndSeek(blockFile, seekOffset);
-      } catch (FileNotFoundException fnfe) {
-        throw new IOException("Block " + this + " is not valid. " +
-            "Expected block file at " + blockFile + " does not exist.");
-      }
-    }
+    return getDataInputStream(getBlockFile(), seekOffset);
-    return getBlockFile().delete();
+    return fullyDelete(getBlockFile());
-    return getMetaFile().delete();
+    return fullyDelete(getMetaFile());
-      NativeIO.renameTo(srcfile, destfile);
+      rename(srcfile, destfile);
-    FileStatus fss =
-        localFS.getFileStatus(new Path(getBlockFile().getAbsolutePath()));
-    return fss.getPermission().getStickyBit();
+    return getPinning(localFS, new Path(getBlockFile().getAbsolutePath()));
-
-    FsPermission oldPermission = localFS.getFileStatus(
-        new Path(f.getAbsolutePath())).getPermission();
-    //sticky bit is used for pinning purpose
-    FsPermission permission = new FsPermission(oldPermission.getUserAction(),
-        oldPermission.getGroupAction(), oldPermission.getOtherAction(), true);
-    localFS.setPermission(p, permission);
+    setPinning(localFS, p);
-      NativeIO.renameTo(oldmeta, newmeta);
+      rename(oldmeta, newmeta);
-  static public void truncateBlock(File blockFile, File metaFile,
+  @Override
+  public void copyMetadata(URI destination) throws IOException {
+    //for local replicas, we assume the destination URI is file
+    nativeCopyFileUnbuffered(getMetaFile(), new File(destination), true);
+  }
+
+  @Override
+  public void copyBlockdata(URI destination) throws IOException {
+    //for local replicas, we assume the destination URI is file
+    nativeCopyFileUnbuffered(getBlockFile(), new File(destination), true);
+  }
+
+  public void renameMeta(File newMetaFile) throws IOException {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Renaming " + getMetaFile() + " to " + newMetaFile);
+    }
+    renameFile(getMetaFile(), newMetaFile);
+  }
+
+  public void renameBlock(File newBlockFile) throws IOException {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Renaming " + getBlockFile() + " to " + newBlockFile
+          + ", file length=" + getBlockFile().length());
+    }
+    renameFile(getBlockFile(), newBlockFile);
+  }
+
+  public static void rename(File from, File to) throws IOException {
+    Storage.rename(from, to);
+  }
+
+  /**
+   * Get input stream for a local file and optionally seek to the offset.
+   * @param f path to the file
+   * @param seekOffset offset to seek
+   * @return
+   * @throws IOException
+   */
+  private FileInputStream getDataInputStream(File f, long seekOffset)
+      throws IOException {
+    FileInputStream fis;
+    if (NativeIO.isAvailable()) {
+      fis = NativeIO.getShareDeleteFileInputStream(f, seekOffset);
+    } else {
+      try {
+        fis = FsDatasetUtil.openAndSeek(f, seekOffset);
+      } catch (FileNotFoundException fnfe) {
+        throw new IOException("Expected block file at " + f +
+            " does not exist.");
+      }
+    }
+    return fis;
+  }
+
+  private void nativeCopyFileUnbuffered(File srcFile, File destFile,
+      boolean preserveFileDate) throws IOException {
+    Storage.nativeCopyFileUnbuffered(srcFile, destFile, preserveFileDate);
+  }
+
+  private void copyBytes(InputStream in, OutputStream out, int
+      buffSize) throws IOException{
+    IOUtils.copyBytes(in, out, buffSize);
+  }
+
+  private void replaceFile(File src, File target) throws IOException {
+    FileUtil.replaceFile(src, target);
+  }
+
+  public static boolean fullyDelete(final File dir) {
+    boolean result = DataStorage.fullyDelete(dir);
+    return result;
+  }
+
+  public static int getHardLinkCount(File fileName) throws IOException {
+    int linkCount = HardLink.getLinkCount(fileName);
+    return linkCount;
+  }
+
+  /**
+   *  Get pin status of a file by checking the sticky bit.
+   * @param localFS local file system
+   * @param path path to be checked
+   * @return
+   * @throws IOException
+   */
+  public boolean getPinning(LocalFileSystem localFS, Path path) throws
+      IOException {
+    boolean stickyBit =
+        localFS.getFileStatus(path).getPermission().getStickyBit();
+    return stickyBit;
+  }
+
+  /**
+   * Set sticky bit on path to pin file.
+   * @param localFS local file system
+   * @param path path to be pinned with sticky bit
+   * @throws IOException
+   */
+  public void setPinning(LocalFileSystem localFS, Path path) throws
+      IOException {
+    FsPermission oldPermission = localFS.getFileStatus(path).getPermission();
+    FsPermission permission = new FsPermission(oldPermission.getUserAction(),
+        oldPermission.getGroupAction(), oldPermission.getOtherAction(), true);
+    localFS.setPermission(path, permission);
+  }
+
+  public static void truncateBlock(File blockFile, File metaFile,
-
-  @Override
-  public void copyMetadata(URI destination) throws IOException {
-    //for local replicas, we assume the destination URI is file
-    Storage.nativeCopyFileUnbuffered(getMetaFile(),
-        new File(destination), true);
-  }
-
-  @Override
-  public void copyBlockdata(URI destination) throws IOException {
-    //for local replicas, we assume the destination URI is file
-    Storage.nativeCopyFileUnbuffered(getBlockFile(),
-        new File(destination), true);
-  }
-

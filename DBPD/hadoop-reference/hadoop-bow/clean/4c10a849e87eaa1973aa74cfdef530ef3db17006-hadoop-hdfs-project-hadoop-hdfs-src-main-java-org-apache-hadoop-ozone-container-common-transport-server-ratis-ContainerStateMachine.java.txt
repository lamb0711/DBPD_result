HDFS-13078. Ozone: Update Ratis on Ozone to 0.1.1-alpha-8fd74ed-SNAPSHOT.
To fix large chunk reads (>4M) from Datanodes. Contributed by Mukul Kumar Singh.

-import org.apache.ratis.protocol.RaftClientReply;
-import org.apache.ratis.statemachine.BaseStateMachine;
-import org.apache.ratis.statemachine.SimpleStateMachineStorage;
+import org.apache.ratis.statemachine.impl.BaseStateMachine;
+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;
+import org.apache.ratis.statemachine.impl.TransactionContextImpl;
- * and these readonly requests are replied from the
- * {@link #query(RaftClientRequest)}
+ * and these readonly requests are replied from the {@link #query(Message)}.
-  private final ConcurrentHashMap<String, CompletableFuture<Message>>
+  private final ConcurrentHashMap<Long, CompletableFuture<Message>>
-    return new TransactionContext(this, request, log);
+    return new TransactionContextImpl(this, request, log);
+  private CompletableFuture<Message> handleWriteChunk(
+      ContainerCommandRequestProto requestProto, long entryIndex) {
+    final WriteChunkRequestProto write = requestProto.getWriteChunk();
+    String containerName = write.getPipeline().getContainerName();
+    CompletableFuture<Message> future =
+        createContainerFutureMap.get(containerName);
+    CompletableFuture<Message> writeChunkFuture;
+    if (future != null) {
+      writeChunkFuture = future.thenApplyAsync(
+          v -> runCommand(requestProto), writeChunkExecutor);
+    } else {
+      writeChunkFuture = CompletableFuture.supplyAsync(
+          () -> runCommand(requestProto), writeChunkExecutor);
+    }
+    writeChunkFutureMap.put(entryIndex, writeChunkFuture);
+    return writeChunkFuture;
+  }
+
+  private CompletableFuture<Message> handleCreateContainer(
+      ContainerCommandRequestProto requestProto) {
+    String containerName =
+        requestProto.getCreateContainer().getContainerData().getName();
+    createContainerFutureMap.
+        computeIfAbsent(containerName, k -> new CompletableFuture<>());
+    return CompletableFuture.completedFuture(() -> ByteString.EMPTY);
+  }
+
-      if (requestProto.getCmdType() == ContainerProtos.Type.CreateContainer) {
-        String containerName =
-            requestProto.getCreateContainer().getContainerData().getName();
-        createContainerFutureMap.
-            computeIfAbsent(containerName, k -> new CompletableFuture<>());
-        return CompletableFuture.completedFuture(() -> ByteString.EMPTY);
-      } else {
-        final WriteChunkRequestProto write = requestProto.getWriteChunk();
-        String containerName = write.getPipeline().getContainerName();
-        CompletableFuture<Message> future =
-            createContainerFutureMap.get(containerName);
-
-        CompletableFuture<Message> writeChunkFuture;
-        if (future != null) {
-          writeChunkFuture = future.thenApplyAsync(
-              v -> runCommand(requestProto), writeChunkExecutor);
-        } else {
-          writeChunkFuture = CompletableFuture.supplyAsync(
-              () -> runCommand(requestProto), writeChunkExecutor);
-        }
-        writeChunkFutureMap
-            .put(write.getChunkData().getChunkName(), writeChunkFuture);
-        return writeChunkFuture;
+      ContainerProtos.Type cmdType = requestProto.getCmdType();
+      switch (cmdType) {
+      case CreateContainer:
+        return handleCreateContainer(requestProto);
+      case WriteChunk:
+        return handleWriteChunk(requestProto, entry.getIndex());
+      default:
+        throw new IllegalStateException("Cmd Type:" + cmdType
+            + " should not have state machine data");
-  public CompletableFuture<RaftClientReply> query(RaftClientRequest request) {
+  public CompletableFuture<Message> query(Message request) {
-          getRequestProto(request.getMessage().getContent());
-      RaftClientReply raftClientReply =
-          new RaftClientReply(request, runCommand(requestProto));
-      return CompletableFuture.completedFuture(raftClientReply);
+          getRequestProto(request.getContent());
+      return CompletableFuture.completedFuture(runCommand(requestProto));
+      ContainerProtos.Type cmdType = requestProto.getCmdType();
-      if (requestProto.getCmdType() == ContainerProtos.Type.WriteChunk) {
+      if (cmdType == ContainerProtos.Type.WriteChunk) {
-            writeChunkFutureMap.remove(write.getChunkData().getChunkName());
+            writeChunkFutureMap.remove(trx.getLogEntry().getIndex());
-        if (requestProto.getCmdType() == ContainerProtos.Type.CreateContainer) {
+        if (cmdType == ContainerProtos.Type.CreateContainer) {

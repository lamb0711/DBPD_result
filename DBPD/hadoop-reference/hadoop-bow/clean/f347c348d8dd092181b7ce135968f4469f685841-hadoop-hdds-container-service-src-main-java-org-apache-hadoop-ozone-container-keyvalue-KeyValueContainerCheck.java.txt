Add support for checksum verification in data scrubber

Signed-off-by: Anu Engineer <aengineer@apache.org>

+import org.apache.hadoop.hdfs.util.Canceler;
+import org.apache.hadoop.hdfs.util.DataTransferThrottler;
+import org.apache.hadoop.ozone.common.Checksum;
+import org.apache.hadoop.ozone.common.ChecksumData;
+import org.apache.hadoop.ozone.common.OzoneChecksumException;
+import org.apache.hadoop.ozone.container.common.utils.ReferenceCountedDB;
+import java.io.FileInputStream;
-import java.util.List;
+import java.io.InputStream;
+import java.util.Arrays;
-import org.apache.hadoop.ozone.container.common.utils.ReferenceCountedDB;
+import org.apache.ratis.thirdparty.com.google.protobuf.ByteString;
-  public boolean fullCheck() {
+  public boolean fullCheck(DataTransferThrottler throttler, Canceler canceler) {
-        checkBlockDB();
+        scanData(throttler, canceler);
-  private void checkBlockDB() throws IOException {
+  private void scanData(DataTransferThrottler throttler, Canceler canceler)
+      throws IOException {
-
-            BlockUtils.getDB(onDiskContainerData, checkConfig)) {
-      iterateBlockDB(db);
-    }
-  }
+            BlockUtils.getDB(onDiskContainerData, checkConfig);
+        KeyValueBlockIterator kvIter = new KeyValueBlockIterator(containerID,
+            new File(onDiskContainerData.getContainerPath()))) {
-  private void iterateBlockDB(ReferenceCountedDB db)
-      throws IOException {
-    Preconditions.checkState(db != null);
-
-    // get "normal" keys from the Block DB
-    try(KeyValueBlockIterator kvIter = new KeyValueBlockIterator(containerID,
-        new File(onDiskContainerData.getContainerPath()))) {
-
-      // ensure there is a chunk file for each key in the DB
-      while (kvIter.hasNext()) {
+      while(kvIter.hasNext()) {
-
-        List<ContainerProtos.ChunkInfo> chunkInfoList = block.getChunks();
-        for (ContainerProtos.ChunkInfo chunk : chunkInfoList) {
-          File chunkFile;
-          chunkFile = ChunkUtils.getChunkFile(onDiskContainerData,
+        for(ContainerProtos.ChunkInfo chunk : block.getChunks()) {
+          File chunkFile = ChunkUtils.getChunkFile(onDiskContainerData,
-
-            if (bdata == null) {
-              LOG.trace("concurrency with delete, ignoring deleted block");
-              break; // skip to next block from kvIter
-            } else {
-              String errorStr = "Missing chunk file "
-                  + chunkFile.getAbsolutePath();
-              throw new IOException(errorStr);
+            if (bdata != null) {
+              throw new IOException("Missing chunk file "
+                  + chunkFile.getAbsolutePath());
+            }
+          } else if (chunk.getChecksumData().getType()
+              != ContainerProtos.ChecksumType.NONE){
+            int length = chunk.getChecksumData().getChecksumsList().size();
+            ChecksumData cData = new ChecksumData(
+                chunk.getChecksumData().getType(),
+                chunk.getChecksumData().getBytesPerChecksum(),
+                chunk.getChecksumData().getChecksumsList());
+            long bytesRead = 0;
+            byte[] buffer = new byte[cData.getBytesPerChecksum()];
+            try (InputStream fs = new FileInputStream(chunkFile)) {
+              int i = 0, v = 0;
+              for (; i < length; i++) {
+                v = fs.read(buffer);
+                if (v == -1) {
+                  break;
+                }
+                bytesRead += v;
+                throttler.throttle(v, canceler);
+                Checksum cal = new Checksum(cData.getChecksumType(),
+                    cData.getBytesPerChecksum());
+                ByteString expected = cData.getChecksums().get(i);
+                ByteString actual = cal.computeChecksum(buffer)
+                    .getChecksums().get(0);
+                if (!Arrays.equals(expected.toByteArray(),
+                    actual.toByteArray())) {
+                  throw new OzoneChecksumException(String
+                      .format("Inconsistent read for chunk=%s len=%d expected" +
+                              " checksum %s actual checksum %s for block %s",
+                          chunk.getChunkName(), chunk.getLen(),
+                          Arrays.toString(expected.toByteArray()),
+                          Arrays.toString(actual.toByteArray()),
+                          block.getBlockID()));
+                }
+
+              }
+              if (v == -1 && i < length) {
+                throw new OzoneChecksumException(String
+                    .format("Inconsistent read for chunk=%s expected length=%d"
+                            + " actual length=%d for block %s",
+                        chunk.getChunkName(),
+                        chunk.getLen(), bytesRead, block.getBlockID()));
+              }

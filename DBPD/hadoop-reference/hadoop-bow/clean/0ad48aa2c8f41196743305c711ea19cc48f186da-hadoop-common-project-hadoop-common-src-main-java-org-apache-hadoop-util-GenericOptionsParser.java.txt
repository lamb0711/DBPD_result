HADOOP-12747. support wildcard in libjars argument (sjlee)

+import java.io.File;
+import org.apache.hadoop.fs.FileUtil;
-    parseGeneralOptions(options, conf, args);
+    parseGeneralOptions(options, args);
-   * Modify configuration according user-specified generic options
-   * @param conf Configuration to be modified
+   * Modify configuration according user-specified generic options.
+   *
-  private void processGeneralOptions(Configuration conf,
-      CommandLine line) throws IOException {
+  private void processGeneralOptions(CommandLine line) throws IOException {
-      conf.set("tmpjars", 
-               validateFiles(line.getOptionValue("libjars"), conf),
+      // for libjars, we allow expansion of wildcards
+      conf.set("tmpjars",
+               validateFiles(line.getOptionValue("libjars"), true),
-               validateFiles(line.getOptionValue("files"), conf),
+               validateFiles(line.getOptionValue("files")),
-                validateFiles(line.getOptionValue("archives"), conf),
+                validateFiles(line.getOptionValue("archives")),
-    if(jars==null) {
+    if (jars == null || jars.trim().isEmpty()) {
-          "filesystem. Ignoring.");
+            "filesystem. It will not be added to the local classpath.");
-   * file:///home/user/file1,file:///home/user/file2
-   * @param files
-   * @return
+   * file:///home/user/file1,file:///home/user/file2.
+   *
+   * This method does not recognize wildcards.
+   *
+   * @param files the input files argument
+   * @return a comma-separated list of validated and qualified paths, or null
+   * if the input files argument is null
-  private String validateFiles(String files, Configuration conf) 
-      throws IOException  {
-    if (files == null) 
+  private String validateFiles(String files) throws IOException {
+    return validateFiles(files, false);
+  }
+
+  /**
+   * takes input as a comma separated list of files
+   * and verifies if they exist. It defaults for file:///
+   * if the files specified do not have a scheme.
+   * it returns the paths uri converted defaulting to file:///.
+   * So an input of  /home/user/file1,/home/user/file2 would return
+   * file:///home/user/file1,file:///home/user/file2.
+   *
+   * @param files the input files argument
+   * @param expandWildcard whether a wildcard entry is allowed and expanded. If
+   * true, any directory followed by a wildcard is a valid entry and is replaced
+   * with the list of jars in that directory. It is used to support the wildcard
+   * notation in a classpath.
+   * @return a comma-separated list of validated and qualified paths, or null
+   * if the input files argument is null
+   */
+  private String validateFiles(String files, boolean expandWildcard)
+      throws IOException {
+    if (files == null) {
+    }
-    String[] finalArr = new String[fileArr.length];
+    List<String> finalPaths = new ArrayList<>(fileArr.length);
-      String finalPath;
+      final String wildcard = "*";
+      boolean isWildcard = tmp.endsWith(wildcard) && expandWildcard;
-        pathURI = new URI(tmp);
+        if (isWildcard) {
+          // strip the wildcard
+          tmp = tmp.substring(0, tmp.length() - 1);
+        }
+        // handle the case where a wildcard alone ("*") or the wildcard on the
+        // current directory ("./*") is specified
+        pathURI = matchesCurrentDirectory(tmp) ?
+            new File(Path.CUR_DIR).toURI() :
+            new URI(tmp);
-        finalPath = path.makeQualified(localFs.getUri(),
-            localFs.getWorkingDirectory()).toString();
-      }
-      else {
+        if (isWildcard) {
+          expandWildcard(finalPaths, path, localFs);
+        } else {
+          finalPaths.add(path.makeQualified(localFs.getUri(),
+              localFs.getWorkingDirectory()).toString());
+        }
+      } else {
-        finalPath = path.makeQualified(fs.getUri(),
-            fs.getWorkingDirectory()).toString();
+        if (isWildcard) {
+          expandWildcard(finalPaths, path, fs);
+        } else {
+          finalPaths.add(path.makeQualified(fs.getUri(),
+              fs.getWorkingDirectory()).toString());
+        }
-      finalArr[i] = finalPath;
-    return StringUtils.arrayToString(finalArr);
+    if (finalPaths.isEmpty()) {
+      throw new IllegalArgumentException("Path " + files + " cannot be empty.");
+    }
+    return StringUtils.join(",", finalPaths);
+  }
+
+  private boolean matchesCurrentDirectory(String path) {
+    return path.isEmpty() || path.equals(Path.CUR_DIR) ||
+        path.equals(Path.CUR_DIR + File.separator);
+  }
+
+  private void expandWildcard(List<String> finalPaths, Path path, FileSystem fs)
+      throws IOException {
+    if (!fs.isDirectory(path)) {
+      throw new FileNotFoundException(path + " is not a directory.");
+    }
+    // get all the jars in the directory
+    List<Path> jars = FileUtil.getJarsInDirectory(path.toString(),
+        fs.equals(FileSystem.getLocal(conf)));
+    if (jars.isEmpty()) {
+      LOG.warn(path + " does not have jars in it. It will be ignored.");
+    } else {
+      for (Path jar: jars) {
+        finalPaths.add(jar.makeQualified(fs.getUri(),
+            fs.getWorkingDirectory()).toString());
+      }
+    }
-   * configuration accordingly
+   * configuration accordingly.
+   *
-   * @param conf Configuration to be modified
-  private void parseGeneralOptions(Options opts, Configuration conf, 
-      String[] args) throws IOException {
+  private void parseGeneralOptions(Options opts, String[] args)
+      throws IOException {
-      processGeneralOptions(conf, commandLine);
+      processGeneralOptions(commandLine);

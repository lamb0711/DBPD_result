HDFS-13972. RBF: Support for Delegation Token (WebHDFS). Contributed by CR Hota.

-import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.hdfs.server.federation.resolver.ActiveNamenodeResolver;
-import org.apache.hadoop.hdfs.server.federation.resolver.FederationNamenodeContext;
-import org.apache.hadoop.hdfs.server.federation.resolver.RemoteLocation;
+import org.apache.hadoop.hdfs.server.federation.router.security.RouterSecurityManager;
-import javax.servlet.http.HttpServletResponse;
-import org.apache.hadoop.hdfs.web.URLConnectionFactory;
+import org.apache.hadoop.security.Credentials;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.net.URLDecoder;
-import java.security.PrivilegedAction;
-      final URI uri = redirectURI(router, fullpath);
+      final URI uri = redirectURI(router, ugi, delegation, username,
+          doAsUser, fullpath, op.getValue(), -1L,
+          exclDatanodes.getValue(), permission, unmaskedPermission,
+          overwrite, bufferSize, replication, blockSize, createParent,
+          createFlagParam);
+      case GETDELEGATIONTOKEN:
-   * Get the redirect URI from the Namenode responsible for a path.
-   * @param router Router to check.
-   * @param path Path to get location for.
-   * @return URI returned by the Namenode.
-   * @throws IOException If it cannot get the redirect URI.
-   */
-  private URI redirectURI(final Router router, final String path)
-      throws IOException {
-    // Forward the request to the proper Namenode
-    final HttpURLConnection conn = forwardRequest(router, path);
-    try {
-      conn.setInstanceFollowRedirects(false);
-      conn.setDoOutput(true);
-      conn.connect();
-
-      // Read the reply from the Namenode
-      int responseCode = conn.getResponseCode();
-      if (responseCode != HttpServletResponse.SC_TEMPORARY_REDIRECT) {
-        LOG.info("We expected a redirection from the Namenode, not {}",
-            responseCode);
-        return null;
-      }
-
-      // Extract the redirect location and return it
-      String redirectLocation = conn.getHeaderField("Location");
-      try {
-        // We modify the namenode location and the path
-        redirectLocation = redirectLocation
-            .replaceAll("(?<=[?&;])namenoderpcaddress=.*?(?=[&;])",
-                "namenoderpcaddress=" + router.getRouterId())
-            .replaceAll("(?<=[/])webhdfs/v1/.*?(?=[?])",
-                "webhdfs/v1" + path);
-        return new URI(redirectLocation);
-      } catch (URISyntaxException e) {
-        LOG.error("Cannot parse redirect location {}", redirectLocation);
-      }
-    } finally {
-      if (conn != null) {
-        conn.disconnect();
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Forwards a request to a subcluster.
-   * @param router Router to check.
-   * @param path Path in HDFS.
-   * @return Reply from the subcluster.
-   * @throws IOException
-   */
-  private HttpURLConnection forwardRequest(
-      final Router router, final String path) throws IOException {
-    final Configuration conf =
-        (Configuration)getContext().getAttribute(JspHelper.CURRENT_CONF);
-    URLConnectionFactory connectionFactory =
-        URLConnectionFactory.newDefaultURLConnectionFactory(conf);
-
-    // Find the namespace responsible for a path
-    final RouterRpcServer rpcServer = getRPCServer(router);
-    RemoteLocation createLoc = rpcServer.getCreateLocation(path);
-    String nsId = createLoc.getNameserviceId();
-    String dest = createLoc.getDest();
-    ActiveNamenodeResolver nnResolver = router.getNamenodeResolver();
-    List<? extends FederationNamenodeContext> namenodes =
-        nnResolver.getNamenodesForNameserviceId(nsId);
-
-    // Go over the namenodes responsible for that namespace
-    for (FederationNamenodeContext namenode : namenodes) {
-      try {
-        // Generate the request for the namenode
-        String nnWebAddress = namenode.getWebAddress();
-        String[] nnWebAddressSplit = nnWebAddress.split(":");
-        String host = nnWebAddressSplit[0];
-        int port = Integer.parseInt(nnWebAddressSplit[1]);
-
-        // Avoid double-encoding here
-        query = URLDecoder.decode(query, "UTF-8");
-        URI uri = new URI(getScheme(), null, host, port,
-            reqPath + dest, query, null);
-        URL url = uri.toURL();
-
-        // Send a request to the proper Namenode
-        final HttpURLConnection conn =
-            (HttpURLConnection)connectionFactory.openConnection(url);
-        conn.setRequestMethod(method);
-
-        connectionFactory.destroy();
-        return conn;
-      } catch (Exception e) {
-        LOG.error("Cannot redirect request to {}", namenode, e);
-      }
-    }
-    connectionFactory.destroy();
-    return null;
-  }
-
-  /**
-          router, ugi, request.getUserPrincipal().getName());
+          ugi, ugi.getUserName());
+    RouterRpcServer.setCurrentUser(loginUser);
-    DatanodeInfo[] dns = loginUser.doAs(
-        new PrivilegedAction<DatanodeInfo[]>() {
-          @Override
-          public DatanodeInfo[] run() {
-            try {
-              return rpcServer.getDatanodeReport(DatanodeReportType.LIVE);
-            } catch (IOException e) {
-              LOG.error("Cannot get the datanodes from the RPC server", e);
-              return null;
-            }
-          }
-        });
+    DatanodeInfo[] dns = null;
+    try {
+      dns = rpcServer.getDatanodeReport(DatanodeReportType.LIVE);
+    } catch (IOException e) {
+      LOG.error("Cannot get the datanodes from the RPC server", e);
+    } finally {
+      // Reset ugi to remote user for remaining operations.
+      RouterRpcServer.resetCurrentUser();
+    }
-   * Generate the delegation tokens for this request.
-   * @param router Router.
+   * Generate the credentials for this request.
-   * @return The delegation tokens.
-   * @throws IOException If it cannot create the tokens.
+   * @return Credentials holding delegation token.
+   * @throws IOException If it cannot create the credentials.
-  private Token<? extends TokenIdentifier> generateDelegationToken(
-      final Router router, final UserGroupInformation ugi,
+  @Override
+  public Credentials createCredentials(
+      final UserGroupInformation ugi,
-    throw new UnsupportedOperationException("TODO Generate token for ugi=" +
-        ugi + " request=" + request);
+    final Router router = (Router)getContext().getAttribute("name.node");
+    final Credentials c = RouterSecurityManager.createCredentials(router, ugi,
+        renewer != null? renewer: ugi.getShortUserName());
+    return c;

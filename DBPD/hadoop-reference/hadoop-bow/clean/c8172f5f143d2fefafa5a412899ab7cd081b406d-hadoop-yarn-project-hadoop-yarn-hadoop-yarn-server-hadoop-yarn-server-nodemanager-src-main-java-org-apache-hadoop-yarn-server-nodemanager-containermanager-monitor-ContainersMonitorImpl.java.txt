YARN-2883. Queuing of container requests in the NM. (Konstantinos Karanasos and Arun Suresh via kasha)

-  private final Context context;
+  protected final Context context;
+  // Tracks the aggregated allocation of the currently allocated containers
+  // when queuing of containers at the NMs is enabled.
+  private ResourceUtilization containersAllocation;
+    this.containersAllocation = ResourceUtilization.newInstance(0, 0, 0.0f);
-        NodeManagerHardwareUtils.getContainerMemoryMB(conf) * 1024 * 1024L;
+        NodeManagerHardwareUtils.getContainerMemoryMB(
+            this.resourceCalculatorPlugin, conf) * 1024 * 1024L;
-        NodeManagerHardwareUtils.getVCores(conf);
+        NodeManagerHardwareUtils.getVCores(this.resourceCalculatorPlugin, conf);
-  @VisibleForTesting
-  static class ProcessTreeInfo {
+  public static class ProcessTreeInfo {
+  public ResourceUtilization getContainersAllocation() {
+    return this.containersAllocation;
+  }
+
+  /**
+   * @return true if there are available allocated resources for the given
+   *         container to start.
+   */
+  @Override
+  public boolean hasResourcesAvailable(ProcessTreeInfo pti) {
+    synchronized (this.containersAllocation) {
+      // Check physical memory.
+      if (this.containersAllocation.getPhysicalMemory() +
+          (int) (pti.getPmemLimit() >> 20) >
+          (int) (getPmemAllocatedForContainers() >> 20)) {
+        return false;
+      }
+      // Check virtual memory.
+      if (isVmemCheckEnabled() &&
+          this.containersAllocation.getVirtualMemory() +
+          (int) (pti.getVmemLimit() >> 20) >
+          (int) (getVmemAllocatedForContainers() >> 20)) {
+        return false;
+      }
+      // Check CPU.
+      if (this.containersAllocation.getCPU()
+          + allocatedCpuUsage(pti) > 1.0f) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  @Override
+  public void increaseContainersAllocation(ProcessTreeInfo pti) {
+    synchronized (this.containersAllocation) {
+      increaseResourceUtilization(this.containersAllocation, pti);
+    }
+  }
+
+  @Override
+  public void decreaseContainersAllocation(ProcessTreeInfo pti) {
+    synchronized (this.containersAllocation) {
+      decreaseResourceUtilization(this.containersAllocation, pti);
+    }
+  }
+
+  @Override
+  public void increaseResourceUtilization(ResourceUtilization resourceUtil,
+      ProcessTreeInfo pti) {
+    resourceUtil.addTo((int) (pti.getPmemLimit() >> 20),
+        (int) (pti.getVmemLimit() >> 20), allocatedCpuUsage(pti));
+  }
+
+  @Override
+  public void decreaseResourceUtilization(ResourceUtilization resourceUtil,
+      ProcessTreeInfo pti) {
+    resourceUtil.subtractFrom((int) (pti.getPmemLimit() >> 20),
+        (int) (pti.getVmemLimit() >> 20), allocatedCpuUsage(pti));
+  }
+
+  @Override
+  public void subtractNodeResourcesFromResourceUtilization(
+      ResourceUtilization resourceUtil) {
+    resourceUtil.subtractFrom((int) (getPmemAllocatedForContainers() >> 20),
+        (int) (getVmemAllocatedForContainers() >> 20), 1.0f);
+  }
+
+  private float allocatedCpuUsage(ProcessTreeInfo pti) {
+    float cpuUsagePercentPerCore = pti.getCpuVcores() * 100.0f;
+    float cpuUsageTotalCoresPercentage = cpuUsagePercentPerCore
+        / resourceCalculatorPlugin.getNumProcessors();
+    return (cpuUsageTotalCoresPercentage * 1000 *
+        maxVCoresAllottedForContainers / nodeCpuPercentageForYARN) / 1000.0f;
+  }
+
-      ContainerStartMonitoringEvent startEvent =
-          (ContainerStartMonitoringEvent) monitoringEvent;
-      LOG.info("Starting resource-monitoring for " + containerId);
-      updateContainerMetrics(monitoringEvent);
-      trackingContainers.put(containerId,
-          new ProcessTreeInfo(containerId, null, null,
-              startEvent.getVmemLimit(), startEvent.getPmemLimit(),
-              startEvent.getCpuVcores()));
+      onStartMonitoringContainer(monitoringEvent, containerId);
-      LOG.info("Stopping resource-monitoring for " + containerId);
-      updateContainerMetrics(monitoringEvent);
-      trackingContainers.remove(containerId);
+      onStopMonitoringContainer(monitoringEvent, containerId);
-      ChangeMonitoringContainerResourceEvent changeEvent =
-          (ChangeMonitoringContainerResourceEvent) monitoringEvent;
-      ProcessTreeInfo processTreeInfo = trackingContainers.get(containerId);
-      if (processTreeInfo == null) {
-        LOG.warn("Failed to track container "
-            + containerId.toString()
-            + ". It may have already completed.");
-        break;
-      }
-      LOG.info("Changing resource-monitoring for " + containerId);
-      updateContainerMetrics(monitoringEvent);
-      long pmemLimit = changeEvent.getResource().getMemory() * 1024L * 1024L;
-      long vmemLimit = (long) (pmemLimit * vmemRatio);
-      int cpuVcores = changeEvent.getResource().getVirtualCores();
-      processTreeInfo.setResourceLimit(pmemLimit, vmemLimit, cpuVcores);
-      changeContainerResource(containerId, changeEvent.getResource());
+      onChangeMonitoringContainerResource(monitoringEvent, containerId);
+
+  protected void onChangeMonitoringContainerResource(
+      ContainersMonitorEvent monitoringEvent, ContainerId containerId) {
+    ChangeMonitoringContainerResourceEvent changeEvent =
+        (ChangeMonitoringContainerResourceEvent) monitoringEvent;
+    ProcessTreeInfo processTreeInfo = trackingContainers.get(containerId);
+    if (processTreeInfo == null) {
+      LOG.warn("Failed to track container "
+          + containerId.toString()
+          + ". It may have already completed.");
+      return;
+    }
+    LOG.info("Changing resource-monitoring for " + containerId);
+    updateContainerMetrics(monitoringEvent);
+    long pmemLimit = changeEvent.getResource().getMemory() * 1024L * 1024L;
+    long vmemLimit = (long) (pmemLimit * vmemRatio);
+    int cpuVcores = changeEvent.getResource().getVirtualCores();
+    processTreeInfo.setResourceLimit(pmemLimit, vmemLimit, cpuVcores);
+    changeContainerResource(containerId, changeEvent.getResource());
+  }
+
+  protected void onStopMonitoringContainer(
+      ContainersMonitorEvent monitoringEvent, ContainerId containerId) {
+    LOG.info("Stopping resource-monitoring for " + containerId);
+    updateContainerMetrics(monitoringEvent);
+    trackingContainers.remove(containerId);
+  }
+
+  protected void onStartMonitoringContainer(
+      ContainersMonitorEvent monitoringEvent, ContainerId containerId) {
+    ContainerStartMonitoringEvent startEvent =
+        (ContainerStartMonitoringEvent) monitoringEvent;
+    LOG.info("Starting resource-monitoring for " + containerId);
+    updateContainerMetrics(monitoringEvent);
+    trackingContainers.put(containerId,
+        new ProcessTreeInfo(containerId, null, null,
+            startEvent.getVmemLimit(), startEvent.getPmemLimit(),
+            startEvent.getCpuVcores()));
+  }
+

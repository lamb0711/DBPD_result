HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes. Contributed by Colin Patrick McCabe.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1431097 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.Closeable;
-import java.net.Socket;
-import java.net.SocketAddress;
-
-import java.io.IOException;
+import com.google.common.annotations.VisibleForTesting;
-import org.apache.hadoop.HadoopIllegalArgumentException;
-import org.apache.hadoop.classification.InterfaceAudience;
-import org.apache.hadoop.hdfs.protocol.datatransfer.IOStreamPair;
+import org.apache.hadoop.hdfs.protocol.DatanodeID;
+import org.apache.hadoop.hdfs.net.Peer;
-import org.apache.hadoop.util.StringUtils;
-class SocketCache {
-  private static final Log LOG = LogFactory.getLog(SocketCache.class);
+class PeerCache {
+  private static final Log LOG = LogFactory.getLog(PeerCache.class);
+  
+  private static class Value {
+    private final Peer peer;
+    private final long time;
-  @InterfaceAudience.Private
-  static class SocketAndStreams implements Closeable {
-    public final Socket sock;
-    public final IOStreamPair ioStreams;
-    long createTime;
-    
-    public SocketAndStreams(Socket s, IOStreamPair ioStreams) {
-      this.sock = s;
-      this.ioStreams = ioStreams;
-      this.createTime = Time.monotonicNow();
-    }
-    
-    @Override
-    public void close() {
-      if (ioStreams != null) { 
-        IOUtils.closeStream(ioStreams.in);
-        IOUtils.closeStream(ioStreams.out);
-      }
-      IOUtils.closeSocket(sock);
+    Value(Peer peer, long time) {
+      this.peer = peer;
+      this.time = time;
-    public long getCreateTime() {
-      return this.createTime;
+    Peer getPeer() {
+      return peer;
+    }
+
+    long getTime() {
+      return time;
-  private static LinkedListMultimap<SocketAddress, SocketAndStreams> multimap =
+  private static LinkedListMultimap<DatanodeID, Value> multimap =
-  private static SocketCache scInstance = new SocketCache();
+  private static PeerCache instance = new PeerCache();
-  public static synchronized SocketCache getInstance(int c, long e) {
+  public static synchronized PeerCache getInstance(int c, long e) {
-    return scInstance;
+    return instance;
-          SocketCache.this.run();
+          PeerCache.this.run();
-          SocketCache.this.clear();
+          PeerCache.this.clear();
-        return String.valueOf(SocketCache.this);
+        return String.valueOf(PeerCache.this);
-   * Get a cached socket to the given address.
-   * @param remote  Remote address the socket is connected to.
-   * @return  A socket with unknown state, possibly closed underneath. Or null.
+   * Get a cached peer connected to the given DataNode.
+   * @param dnId         The DataNode to get a Peer for.
+   * @return             An open Peer connected to the DN, or null if none
+   *                     was found. 
-  public synchronized SocketAndStreams get(SocketAddress remote) {
+  public synchronized Peer get(DatanodeID dnId) {
-    List<SocketAndStreams> sockStreamList = multimap.get(remote);
+    List<Value> sockStreamList = multimap.get(dnId);
-    Iterator<SocketAndStreams> iter = sockStreamList.iterator();
+    Iterator<Value> iter = sockStreamList.iterator();
-      SocketAndStreams candidate = iter.next();
+      Value candidate = iter.next();
-      if (!candidate.sock.isClosed()) {
-        return candidate;
+      if (!candidate.getPeer().isClosed()) {
+        return candidate.getPeer();
-  public synchronized void put(Socket sock, IOStreamPair ioStreams) {
-
-    Preconditions.checkNotNull(sock);
-    SocketAndStreams s = new SocketAndStreams(sock, ioStreams);
+  public synchronized void put(DatanodeID dnId, Peer peer) {
+    Preconditions.checkNotNull(dnId);
+    Preconditions.checkNotNull(peer);
+    if (peer.isClosed()) return;
-      s.close();
+      IOUtils.cleanup(LOG, peer);
-    SocketAddress remoteAddr = sock.getRemoteSocketAddress();
-    if (remoteAddr == null) {
-      LOG.warn("Cannot cache (unconnected) socket with no remote address: " +
-               sock);
-      IOUtils.closeSocket(sock);
-      return;
-    }
-
-    multimap.put(remoteAddr, s);
+    multimap.put(dnId, new Value(peer, Time.monotonicNow()));
-      Iterator<Entry<SocketAddress, SocketAndStreams>> iter =
+      Iterator<Entry<DatanodeID, Value>> iter =
-      Entry<SocketAddress, SocketAndStreams> entry = iter.next();
+      Entry<DatanodeID, Value> entry = iter.next();
-        Time.monotonicNow() - entry.getValue().getCreateTime() < 
+        Time.monotonicNow() - entry.getValue().getTime() <
+      IOUtils.cleanup(LOG, entry.getValue().getPeer());
-      SocketAndStreams s = entry.getValue();
-      s.close();
-    Iterator<Entry<SocketAddress, SocketAndStreams>> iter =
+    // We can get the oldest element immediately, because of an interesting
+    // property of LinkedListMultimap: its iterator traverses entries in the
+    // order that they were added.
+    Iterator<Entry<DatanodeID, Value>> iter =
-    Entry<SocketAddress, SocketAndStreams> entry = iter.next();
+    Entry<DatanodeID, Value> entry = iter.next();
+    IOUtils.cleanup(LOG, entry.getValue().getPeer());
-    SocketAndStreams s = entry.getValue();
-    s.close();
-  private synchronized void clear() {
-    for (SocketAndStreams sockAndStream : multimap.values()) {
-      sockAndStream.close();
+  @VisibleForTesting
+  synchronized void clear() {
+    for (Value value : multimap.values()) {
+      IOUtils.cleanup(LOG, value.getPeer());

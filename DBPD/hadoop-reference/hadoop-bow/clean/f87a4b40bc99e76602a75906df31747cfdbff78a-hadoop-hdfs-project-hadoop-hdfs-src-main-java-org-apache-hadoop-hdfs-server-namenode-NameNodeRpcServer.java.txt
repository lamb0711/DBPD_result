HDFS-1975. Support for sharing the namenode state from active to standby. Contributed by Jitendra Nath Pandey, Aaron T Myers, and Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208813 13f79535-47bb-0310-9956-ffa450edef68

+    this.clientRpcServer.addProtocol(HAServiceProtocol.class, this);
+    if (nn.isStandbyState()) {
+      if (namesystem.isGenStampInFuture(newgenerationstamp)) {
+        LOG.info("Required GS=" + newgenerationstamp
+            + ", Queuing commitBlockSynchronization message");
+        namesystem.getPendingDataNodeMessages().queueMessage(
+            new PendingDataNodeMessages.CommitBlockSynchronizationMessage(
+                block, newgenerationstamp, newlength, closeFile, deleteblock,
+                newtargets, newgenerationstamp));
+        return;
+      }
+    }
-    nn.checkOperation(OperationCategory.READ);
+    // TODO(HA): decide on OperationCategory for this
+    if (nn.isStandbyState()) {
+      long maxGs = blist.getMaxGsInBlockList();
+      if (namesystem.isGenStampInFuture(maxGs)) {
+        LOG.info("Required GS="+maxGs+", Queuing blockReport message");
+        namesystem.getPendingDataNodeMessages().queueMessage(
+            new PendingDataNodeMessages.BlockReportMessage(nodeReg, poolId,
+                blist, maxGs));
+        return null;
+      }
+    }
-    if (nn.getFSImage().isUpgradeFinalized())
+    if (nn.getFSImage().isUpgradeFinalized() && !nn.isStandbyState())
+    if (nn.isStandbyState()) {
+      if (receivedAndDeletedBlocks.length > 0) {
+        long maxGs = receivedAndDeletedBlocks[0].getBlock()
+            .getGenerationStamp();
+        for (ReceivedDeletedBlockInfo binfo : receivedAndDeletedBlocks) {
+          if (binfo.getBlock().getGenerationStamp() > maxGs) {
+            maxGs = binfo.getBlock().getGenerationStamp();
+          }
+        }
+        if (namesystem.isGenStampInFuture(maxGs)) {
+          LOG.info("Required GS=" + maxGs
+              + ", Queuing blockReceivedAndDeleted message");
+          namesystem.getPendingDataNodeMessages().queueMessage(
+              new PendingDataNodeMessages.BlockReceivedDeleteMessage(nodeReg,
+                  poolId, receivedAndDeletedBlocks, maxGs));
+          return;
+        }
+      }
+    }

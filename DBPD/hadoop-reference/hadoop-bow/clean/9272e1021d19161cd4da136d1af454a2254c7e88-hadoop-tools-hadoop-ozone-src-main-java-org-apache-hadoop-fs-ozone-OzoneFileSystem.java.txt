HDFS-12636. Ozone: OzoneFileSystem: Implement seek functionality for rpc client. Contributed by Lokesh Jain.

-import java.io.File;
-import java.text.ParseException;
+import java.util.Iterator;
-import org.apache.hadoop.fs.LocalDirAllocator;
-import org.apache.hadoop.ozone.web.client.OzoneKey;
-import org.apache.hadoop.ozone.web.client.OzoneRestClient;
-import org.apache.hadoop.ozone.web.utils.OzoneUtils;
+import org.apache.hadoop.io.IOUtils;
+import org.apache.hadoop.ozone.client.ObjectStore;
+import org.apache.hadoop.ozone.client.OzoneBucket;
+import org.apache.hadoop.ozone.client.OzoneClient;
+import org.apache.hadoop.ozone.client.OzoneClientFactory;
+import org.apache.hadoop.ozone.OzoneConfigKeys;
+import org.apache.hadoop.ozone.client.OzoneKey;
+import org.apache.hadoop.ozone.client.OzoneVolume;
+import org.apache.hadoop.ozone.client.ReplicationFactor;
+import org.apache.hadoop.ozone.client.ReplicationType;
-import org.apache.hadoop.ozone.web.client.OzoneBucket;
-import org.apache.hadoop.ozone.web.client.OzoneVolume;
-import org.apache.hadoop.ozone.client.rest.OzoneException;
+import org.apache.hadoop.ozone.client.io.OzoneInputStream;
+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;
-import static org.apache.hadoop.fs.ozone.Constants.OZONE_HTTP_SCHEME;
-import static org.apache.hadoop.fs.ozone.Constants.BUFFER_DIR_KEY;
-  private OzoneRestClient ozone;
+  private OzoneClient ozoneClient;
+  private ObjectStore objectStore;
+  private OzoneVolume volume;
+  private ReplicationType replicationType;
+  private ReplicationFactor replicationFactor;
-      this.ozone = new OzoneRestClient(OZONE_HTTP_SCHEME + hostStr);
+      this.ozoneClient = OzoneClientFactory.getRpcClient(conf);
+      objectStore = ozoneClient.getObjectStore();
+      this.volume = objectStore.getVolume(volumeStr);
+      this.bucket = volume.getBucket(bucketStr);
+      this.replicationType = ReplicationType.valueOf(
+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,
+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT));
+      this.replicationFactor = ReplicationFactor.valueOf(
+          conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,
+              OzoneConfigKeys.OZONE_REPLICATION_DEFAULT));
-      this.ozone.setUserAuth(userName);
-
-      OzoneVolume volume = ozone.getVolume(volumeStr);
-      this.bucket = volume.getBucket(bucketStr);
-    } catch (OzoneException oe) {
-      final String msg = "Ozone server exception when initializing file system";
-      LOG.error(msg, oe);
-      throw new IOException(msg, oe);
-      ozone.close();
+      ozoneClient.close();
-
+    final String key = pathToKey(f);
-        new OzoneInputStream(getConf(), uri, bucket, pathToKey(f),
-            fileStatus.getLen(), bufferSize, statistics));
+        new OzoneFSInputStream(bucket.readKey(key).getInputStream()));
-    final OzoneOutputStream stream =
-        new OzoneOutputStream(getConf(), uri, bucket, key, this.statistics);
+    OzoneOutputStream ozoneOutputStream =
+        bucket.createKey(key, 0, replicationType, replicationFactor);
-    return new FSDataOutputStream(stream, null);
+    return new FSDataOutputStream(
+        new OzoneFSOutputStream(ozoneOutputStream.getOutputStream()), null);
-      super(srcPath, true);
+      super(srcPath);
-      return rename(key, newKeyName);
+      rename(key, newKeyName);
+      return true;
-    // TODO: currently rename work by copying the file, with changes in KSM,
-    // this operation can be made improved by renaming the keys in KSM directly.
-    private boolean rename(String src, String dst) throws IOException {
-      final LocalDirAllocator dirAlloc = new LocalDirAllocator(BUFFER_DIR_KEY);
-      final File tmpFile = dirAlloc.createTmpFileForWrite("output-",
-          LocalDirAllocator.SIZE_UNKNOWN, getConf());
-
-      try {
-        LOG.trace("rename by copying file from:{} to:{}", src, dst);
-        bucket.getKey(src, tmpFile.toPath());
-        bucket.putKey(dst, tmpFile);
-        return true;
-      } catch (OzoneException oe) {
-        String msg = String.format("Error when renaming key from:%s to:%s",
-            src, dst);
-        LOG.error(msg, oe);
-        throw new IOException(msg, oe);
-      } finally {
-        if (!tmpFile.delete()) {
-          LOG.warn("Can not delete tmpFile: " + tmpFile);
-        }
+    // TODO: currently rename work by copying the streams, with changes in KSM,
+    // this operation can be improved by renaming the keys in KSM directly.
+    private void rename(String src, String dst) throws IOException {
+      try (OzoneInputStream inputStream = bucket.readKey(src);
+          OzoneOutputStream outputStream = bucket
+              .createKey(dst, 0, replicationType, replicationFactor)) {
+        IOUtils.copyBytes(inputStream, outputStream, getConf());
-      super(f, recursive);
+      super(f);
+      if (getStatus().isDirectory()
+          && !this.recursive
+          && listStatus(f).length != 0) {
+        throw new PathIsNotEmptyDirectoryException(f.toString());
+      }
-      super(f, true);
+      super(f);
-          getModifiedTime(bucket.getCreatedOn(), OZONE_URI_DELIMITER),
-          qualifiedPath);
+          bucket.getCreationTime(), qualifiedPath);
-          getModifiedTime(meta.getObjectInfo().getModifiedOn(), key),
-          qualifiedPath);
+          meta.getModificationTime(), qualifiedPath);
-      return new FileStatus(meta.getObjectInfo().getSize(), false, 1,
-            getDefaultBlockSize(f),
-          getModifiedTime(meta.getObjectInfo().getModifiedOn(), key),
-          qualifiedPath);
+      return new FileStatus(meta.getDataSize(), false, 1,
+            getDefaultBlockSize(f), meta.getModificationTime(), qualifiedPath);
-      return bucket.getKeyInfo(key);
-    } catch (OzoneException e) {
+      return bucket.getKey(key);
+    } catch (IOException e) {
-   * Helper method to get the modified time of the key.
-   * @param key key to fetch the modified time
-   * @return last modified time of the key
-   */
-  private long getModifiedTime(String modifiedTime, String key) {
-    try {
-      return OzoneUtils.formatDate(modifiedTime);
-    } catch (ParseException pe) {
-      LOG.error("Invalid time:{} for key:{}", modifiedTime, key, pe);
-      return 0;
-    }
-  }
-
-  /**
-    LOG.trace("key name:{} size:{}", key.getObjectInfo().getKeyName(),
-        key.getObjectInfo().getSize());
-    return key.getObjectInfo().getKeyName().endsWith(OZONE_URI_DELIMITER)
-        && (key.getObjectInfo().getSize() == 0);
-  }
-
-  /**
-   * Helper method to list entries matching the key name in bucket.
-   * @param dirKey key prefix for listing the keys
-   * @param lastKey last iterated key
-   * @return List of Keys
-   */
-  List<OzoneKey> listKeys(String dirKey, String lastKey)
-      throws IOException {
-    LOG.trace("list keys dirKey:{} lastKey:{}", dirKey, lastKey);
-    try {
-      return bucket.listKeys(dirKey, LISTING_PAGE_SIZE, lastKey);
-    } catch (OzoneException oe) {
-      LOG.error("list keys failed dirKey:{} lastKey:{}", dirKey, lastKey, oe);
-      throw new IOException("List keys failed " + oe.getMessage());
-    }
+    LOG.trace("key name:{} size:{}", key.getName(),
+        key.getDataSize());
+    return key.getName().endsWith(OZONE_URI_DELIMITER)
+        && (key.getDataSize() == 0);
-      LOG.trace("creating dir for key:{}", keyName);
-      bucket.putKey(keyName, "");
+      LOG.info("creating dir for key:{}", keyName);
+      bucket.createKey(keyName, 0, replicationType, replicationFactor).close();
-    } catch (OzoneException oe) {
-      LOG.error("create key failed for key:{}", keyName, oe);
+    } catch (IOException ioe) {
+      LOG.error("create key failed for key:{}", keyName, ioe);
-    } catch (OzoneException oe) {
-      LOG.error("delete key failed " + oe.getMessage());
+    } catch (IOException ioe) {
+      LOG.error("delete key failed " + ioe.getMessage());
-  String addTrailingSlashIfNeeded(String key) {
+  private String addTrailingSlashIfNeeded(String key) {
-    private final boolean recursive;
+    private Iterator<OzoneKey> keyIterator;
-    OzoneListingIterator(Path path, boolean recursive)
+    OzoneListingIterator(Path path)
-      this.recursive = recursive;
+      keyIterator = bucket.listKeys(pathKey);
-      LOG.trace("Iterating path {} - recursive {}", path, recursive);
+      LOG.trace("Iterating path {}", path);
-        String lastKey = pathKey;
-        while (true) {
-          List<OzoneKey> ozoneKeys = listKeys(pathKey, lastKey);
-          LOG.trace("number of sub keys:{}", ozoneKeys.size());
-          if (ozoneKeys.size() == 0) {
-            return processKey(pathKey);
-          } else {
-            if (!recursive) {
-              throw new PathIsNotEmptyDirectoryException(path.toString());
-            } else {
-              for (OzoneKey ozoneKey : ozoneKeys) {
-                lastKey = ozoneKey.getObjectInfo().getKeyName();
-                if (!processKey(lastKey)) {
-                  return false;
-                }
-              }
-            }
+        while (keyIterator.hasNext()) {
+          OzoneKey key = keyIterator.next();
+          LOG.info("iterating key:{}", key.getName());
+          if (!processKey(key.getName())) {
+            return false;
+        return true;
+
+    FileStatus getStatus() {
+      return status;
+    }

HDFS-1073. Redesign the NameNode's storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.zip.CheckedInputStream;
+import org.apache.hadoop.hdfs.protocol.FSConstants;
-import org.apache.hadoop.hdfs.server.common.GenerationStamp;
+import org.apache.hadoop.hdfs.server.common.GenerationStamp;
+import org.apache.hadoop.hdfs.server.common.Storage;
+  long txid;
+
-        instances.put(OP_CHECKPOINT_TIME, new CheckpointTimeOp());
-        instances.put(OP_JSPOOL_START, new JSpoolStartOp());
+        instances.put(OP_START_LOG_SEGMENT,
+                      new LogSegmentOp(OP_START_LOG_SEGMENT));
+        instances.put(OP_END_LOG_SEGMENT,
+                      new LogSegmentOp(OP_END_LOG_SEGMENT));
+    this.txid = 0;
+  }
+
+  public void setTransactionId(long txid) {
+    this.txid = txid;
+  
+  static class LogSegmentOp extends FSEditLogOp {
+    private LogSegmentOp(FSEditLogOpCodes code) {
+      super(code);
+      assert code == OP_START_LOG_SEGMENT ||
+             code == OP_END_LOG_SEGMENT : "Bad op: " + code;
+    }
+
+    static LogSegmentOp getInstance(FSEditLogOpCodes code) {
+      return (LogSegmentOp)opInstances.get().get(code);
+    }
+
+    public void readFields(DataInputStream in, int logVersion)
+        throws IOException {
+      // no data stored in these ops yet
+    }
+
+    @Override
+    void writeFields(DataOutputStream out) throws IOException {
+      // no data stored
+    }
+  }
-  static class JSpoolStartOp extends FSEditLogOp {
-    private JSpoolStartOp() {
-      super(OP_JSPOOL_START);
-    }
-
-    static JSpoolStartOp getInstance() {
-      return (JSpoolStartOp)opInstances.get().get(OP_JSPOOL_START);
-    }
-
-    @Override 
-    void writeFields(DataOutputStream out) throws IOException {
-    }
-    
-    @Override
-    void readFields(DataInputStream in, int logVersion)
-        throws IOException {
-    }
-  }
-
-  static class CheckpointTimeOp extends FSEditLogOp {
-    long checkpointTime;
-
-    private CheckpointTimeOp() {
-      super(OP_CHECKPOINT_TIME);            
-    }
-    
-    CheckpointTimeOp setCheckpointTime(long time) {
-      this.checkpointTime = time;
-      return this;
-    }
-
-    static CheckpointTimeOp getInstance() {
-      return (CheckpointTimeOp)opInstances.get()
-        .get(OP_CHECKPOINT_TIME);
-    }
-
-    @Override 
-    void writeFields(DataOutputStream out) throws IOException {
-      new LongWritable(checkpointTime).write(out);
-    }
-    
-    @Override
-    void readFields(DataInputStream in, int logVersion)
-        throws IOException {
-      this.checkpointTime = readLong(in);
-    }
-  }
-
+  
+  /**
+   * Class to encapsulate the header at the top of a log file.
+   */
+  static class LogHeader {
+    final int logVersion;
+    final Checksum checksum;
+
+    public LogHeader(int logVersion, Checksum checksum) {
+      this.logVersion = logVersion;
+      this.checksum = checksum;
+    }
+
+    static LogHeader read(DataInputStream in) throws IOException {
+      int logVersion = 0;
+
+      logVersion = FSEditLogOp.LogHeader.readLogVersion(in);
+      Checksum checksum = null;
+      if (LayoutVersion.supports(Feature.EDITS_CHESKUM, logVersion)) {
+        checksum = FSEditLog.getChecksum();
+      }
+      return new LogHeader(logVersion, checksum);
+    }
+    
+    /**
+     * Read the header of fsedit log
+     * @param in fsedit stream
+     * @return the edit log version number
+     * @throws IOException if error occurs
+     */
+    private static int readLogVersion(DataInputStream in) throws IOException {
+      int logVersion = 0;
+      // Read log file version. Could be missing.
+      in.mark(4);
+      // If edits log is greater than 2G, available method will return negative
+      // numbers, so we avoid having to call available
+      boolean available = true;
+      try {
+        logVersion = in.readByte();
+      } catch (EOFException e) {
+        available = false;
+      }
+      if (available) {
+        in.reset();
+        logVersion = in.readInt();
+        if (logVersion < FSConstants.LAYOUT_VERSION) // future version
+          throw new IOException(
+              "Unexpected version of the file system log file: "
+              + logVersion + ". Current version = "
+              + FSConstants.LAYOUT_VERSION + ".");
+      }
+      assert logVersion <= Storage.LAST_UPGRADABLE_LAYOUT_VERSION :
+        "Unsupported version " + logVersion;
+      return logVersion;
+    }
+  }
+      buf.writeLong(op.txid);
-      this.in = in;
+      if (checksum != null) {
+        this.in = new DataInputStream(
+            new CheckedInputStream(in, checksum));
+      } else {
+        this.in = in;
+      }
+
+      if (LayoutVersion.supports(Feature.STORED_TXIDS, logVersion)) {
+        // Read the txid
+        op.setTransactionId(in.readLong());
+      }
+
-      validateChecksum(in, checksum);
+      validateChecksum(in, checksum, op.txid);
-                                  Checksum checksum)
+                                  Checksum checksum,
+                                  long txid)
-              calculatedChecksum + " but read checksum " + readChecksum, -1);
+              calculatedChecksum + " but read checksum " + readChecksum, txid);

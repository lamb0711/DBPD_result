HDFS-7647. DatanodeManager.sortLocatedBlocks sorts DatanodeInfos but not StorageIDs. (Contributed by Milan Desai)

+import org.apache.hadoop.hdfs.server.protocol.DatanodeInfoWithStorage;
-  private final DatanodeInfo[] locs;
-  /** Storage ID for each replica */
-  private final String[] storageIDs;
-  // Storage type for each replica, if reported.
-  private final StorageType[] storageTypes;
+  private final DatanodeInfoWithStorage[] locs;
+  private final boolean hasStorageIDs;
+  private final boolean hasStorageTypes;
+  /** Cached storage ID for each replica */
+  private String[] storageIDs;
+  /** Cached storage type for each replica, if reported. */
+  private StorageType[] storageTypes;
-  private static final DatanodeInfo[] EMPTY_LOCS = new DatanodeInfo[0];
+  private static final DatanodeInfoWithStorage[] EMPTY_LOCS =
+      new DatanodeInfoWithStorage[0];
-      this.locs = locs;
+      this.locs = new DatanodeInfoWithStorage[locs.length];
+      for(int i = 0; i < locs.length; i++) {
+        DatanodeInfo di = locs[i];
+        DatanodeInfoWithStorage storage = new DatanodeInfoWithStorage(di,
+            storageIDs != null ? storageIDs[i] : null,
+            storageTypes != null ? storageTypes[i] : null);
+        storage.setDependentHostNames(di.getDependentHostNames());
+        storage.setLevel(di.getLevel());
+        storage.setParent(di.getParent());
+        this.locs[i] = storage;
+      }
+    this.hasStorageIDs = storageIDs != null;
+    this.hasStorageTypes = storageTypes != null;
-  public DatanodeInfo[] getLocations() {
+  /**
+   * Returns the locations associated with this block. The returned array is not
+   * expected to be modified. If it is, caller must immediately invoke
+   * {@link org.apache.hadoop.hdfs.protocol.LocatedBlock#invalidateCachedStorageInfo}
+   * to invalidate the cached Storage ID/Type arrays.
+   */
+  public DatanodeInfoWithStorage[] getLocations() {
+    if(!hasStorageTypes) {
+      return null;
+    }
+    if(storageTypes != null) {
+      return storageTypes;
+    }
+    storageTypes = new StorageType[locs.length];
+    for(int i = 0; i < locs.length; i++) {
+      storageTypes[i] = locs[i].getStorageType();
+    }
+    if(!hasStorageIDs) {
+      return null;
+    }
+    if(storageIDs != null) {
+      return storageIDs;
+    }
+    storageIDs = new String[locs.length];
+    for(int i = 0; i < locs.length; i++) {
+      storageIDs[i] = locs[i].getStorageID();
+    }
+  /**
+   * Invalidates the cached StorageID and StorageType information. Must be
+   * called when the locations array is modified.
+   */
+  public void invalidateCachedStorageInfo() {
+    storageIDs = null;
+    storageTypes = null;
+  }
+
-    for (int i=0; i<locs.length; i++) {
-      if (locs[i].equals(loc)) {
-        cachedList.add(locs[i]);
+    for (DatanodeInfoWithStorage di : locs) {
+      if (loc.equals(di)) {
+        cachedList.add(di);
-        + "; storageIDs=" +
-            (storageIDs != null ? Arrays.asList(storageIDs) : null)
-        + "; storageTypes=" +
-            (storageTypes != null ? Arrays.asList(storageTypes) : null)

HDFS-4372. Track NameNode startup progress. Contributed by Chris Nauroth.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502120 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.startupprogress.Phase;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.StartupProgress;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.StartupProgress.Counter;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.Step;
+import org.apache.hadoop.hdfs.server.namenode.startupprogress.StepType;
+      StartupProgress prog = NameNode.getStartupProgress();
+      Step step = new Step(StepType.INODES);
+      prog.beginStep(Phase.LOADING_FSIMAGE, step);
+        prog.setTotal(Phase.LOADING_FSIMAGE, step, numFiles);
+        Counter counter = prog.getCounter(Phase.LOADING_FSIMAGE, step);
-            loadLocalNameINodesWithSnapshot(in);
+            loadLocalNameINodesWithSnapshot(numFiles, in, counter);
-            loadLocalNameINodes(numFiles, in);
+            loadLocalNameINodes(numFiles, in, counter);
-          loadFullNameINodes(numFiles, in);
+          loadFullNameINodes(numFiles, in, counter);
-        loadFilesUnderConstruction(in, supportSnapshot);
+        loadFilesUnderConstruction(in, supportSnapshot, counter);
+        prog.endStep(Phase.LOADING_FSIMAGE, step);
+        // Now that the step is finished, set counter equal to total to adjust
+        // for possible under-counting due to reference inodes.
+        prog.setCount(Phase.LOADING_FSIMAGE, step, numFiles);
+     * @param numFiles number of files expected to be read
+     * @param counter Counter to increment for namenode startup progress
-    private void loadLocalNameINodesWithSnapshot(DataInput in)
-        throws IOException {
+    private void loadLocalNameINodesWithSnapshot(long numFiles, DataInput in,
+        Counter counter) throws IOException {
-      loadRoot(in);
+      loadRoot(in, counter);
-      loadDirectoryWithSnapshot(in);
+      loadDirectoryWithSnapshot(in, counter);
+   * @param counter Counter to increment for namenode startup progress
-   private void loadLocalNameINodes(long numFiles, DataInput in) 
+   private void loadLocalNameINodes(long numFiles, DataInput in, Counter counter)
-     loadRoot(in);
+     loadRoot(in, counter);
-       numFiles -= loadDirectory(in);
+       numFiles -= loadDirectory(in, counter);
+     * @param counter Counter to increment for namenode startup progress
-    private void loadRoot(DataInput in) throws IOException {
+    private void loadRoot(DataInput in, Counter counter)
+        throws IOException {
-      final INodeDirectory root = loadINode(null, false, in).asDirectory();
+      final INodeDirectory root = loadINode(null, false, in, counter)
+        .asDirectory();
-    private int loadChildren(INodeDirectory parent, DataInput in)
-        throws IOException {
+    private int loadChildren(INodeDirectory parent, DataInput in,
+        Counter counter) throws IOException {
-        INode newNode = loadINodeWithLocalName(false, in, true);
+        INode newNode = loadINodeWithLocalName(false, in, true, counter);
+     * @param counter Counter to increment for namenode startup progress
-    private void loadDirectoryWithSnapshot(DataInput in)
+    private void loadDirectoryWithSnapshot(DataInput in, Counter counter)
-      loadChildren(parent, in);
+      loadChildren(parent, in, counter);
-        loadDirectoryWithSnapshot(in);
+        loadDirectoryWithSnapshot(in, counter);
+    * @param counter Counter to increment for namenode startup progress
-   private int loadDirectory(DataInput in) throws IOException {
+   private int loadDirectory(DataInput in, Counter counter) throws IOException {
-     return loadChildren(parent, in);
+     return loadChildren(parent, in, counter);
+   * @param counter Counter to increment for namenode startup progress
-  private void loadFullNameINodes(long numFiles,
-      DataInput in) throws IOException {
+  private void loadFullNameINodes(long numFiles, DataInput in, Counter counter)
+      throws IOException {
-          pathComponents[pathComponents.length-1], false, in);
+          pathComponents[pathComponents.length-1], false, in, counter);
+    public INode loadINodeWithLocalName(boolean isSnapshotINode, DataInput in,
+        boolean updateINodeMap) throws IOException {
+      return loadINodeWithLocalName(isSnapshotINode, in, updateINodeMap, null);
+    }
+
-        DataInput in, boolean updateINodeMap) throws IOException {
+        DataInput in, boolean updateINodeMap, Counter counter)
+        throws IOException {
-      INode inode = loadINode(localName, isSnapshotINode, in);
+      INode inode = loadINode(localName, isSnapshotINode, in, counter);
+   * @param counter Counter to increment for namenode startup progress
-      DataInput in) throws IOException {
+      DataInput in, Counter counter) throws IOException {
+      if (counter != null) {
+        counter.increment();
+      }
+      if (counter != null) {
+        counter.increment();
+      }
+      if (counter != null) {
+        counter.increment();
+      }
+      // Intentionally do not increment counter, because it is too difficult at
+      // this point to assess whether or not this is a reference that counts
+      // toward quota.
-        boolean supportSnapshot) throws IOException {
+        boolean supportSnapshot, Counter counter) throws IOException {
+        counter.increment();
+      String sdPath = newFile.getParentFile().getParentFile().getAbsolutePath();
+      Step step = new Step(StepType.INODES, sdPath);
+      StartupProgress prog = NameNode.getStartupProgress();
+      prog.beginStep(Phase.SAVING_CHECKPOINT, step);
+      prog.setTotal(Phase.SAVING_CHECKPOINT, step,
+        fsDir.rootDir.numItemsInTree());
+      Counter counter = prog.getCounter(Phase.SAVING_CHECKPOINT, step);
-        FSImageSerialization.saveINode2Image(fsDir.rootDir, out, false,
-            referenceMap);
+        saveINode2Image(fsDir.rootDir, out, false, referenceMap, counter);
-        saveImage(fsDir.rootDir, out, true);
+        saveImage(fsDir.rootDir, out, true, counter);
+        prog.endStep(Phase.SAVING_CHECKPOINT, step);
+        // Now that the step is finished, set counter equal to total to adjust
+        // for possible under-counting due to reference inodes.
+        prog.setCount(Phase.SAVING_CHECKPOINT, step,
+          fsDir.rootDir.numItemsInTree());
-        sourceNamesystem.saveSecretManagerState(out);
+        sourceNamesystem.saveSecretManagerState(out, sdPath);
+     * @param counter Counter to increment for namenode startup progress
-    private int saveChildren(ReadOnlyList<INode> children, DataOutputStream out)
-        throws IOException {
+    private int saveChildren(ReadOnlyList<INode> children, DataOutputStream out,
+        Counter counter) throws IOException {
-        FSImageSerialization.saveINode2Image(child, out, false, referenceMap);
+        saveINode2Image(child, out, false, referenceMap, counter);
+     * @param counter Counter to increment for namenode startup progress
-        boolean toSaveSubtree) throws IOException {
+        boolean toSaveSubtree, Counter counter) throws IOException {
-      dirNum += saveChildren(children, out);
+      dirNum += saveChildren(children, out, counter);
-        saveImage(child.asDirectory(), out, toSave);
+        saveImage(child.asDirectory(), out, toSave, counter);
-          saveImage(subDir, out, toSave);
+          saveImage(subDir, out, toSave, counter);
+
+    /**
+     * Saves inode and increments progress counter.
+     * 
+     * @param inode INode to save
+     * @param out DataOutputStream to receive inode
+     * @param writeUnderConstruction boolean true if this is under construction
+     * @param referenceMap ReferenceMap containing reference inodes
+     * @param counter Counter to increment for namenode startup progress
+     * @throws IOException thrown if there is an I/O error
+     */
+    private void saveINode2Image(INode inode, DataOutputStream out,
+        boolean writeUnderConstruction, ReferenceMap referenceMap,
+        Counter counter) throws IOException {
+      FSImageSerialization.saveINode2Image(inode, out, writeUnderConstruction,
+        referenceMap);
+      // Intentionally do not increment counter for reference inodes, because it
+      // is too difficult at this point to assess whether or not this is a
+      // reference that counts toward quota.
+      if (!(inode instanceof INodeReference)) {
+        counter.increment();
+      }
+    }

HADOOP-16371: Option to disable GCM for SSL connections when running on Java 8.

Contributed by Sahil Takiar.

This moves the SSLSocketFactoryEx class from hadoop-azure into hadoop-common
as the DelegatingSSLSocketFactory and binds the S3A connector to it so that
it can avoid using those HTTPS algorithms which are underperformant on Java 8.

Change-Id: Ie9e6ac24deac1aa05e136e08899620efa7d22abd

-package org.apache.hadoop.fs.azurebfs.utils;
+package org.apache.hadoop.security.ssl;
- * Extension to use native OpenSSL library instead of JSSE for better
- * performance.
+ * A {@link SSLSocketFactory} that can delegate to various SSL implementations.
+ * Specifically, either OpenSSL or JSSE can be used. OpenSSL offers better
+ * performance than JSSE and is made available via the
+ * <a href="https://github.com/wildfly/wildfly-openssl">wildlfy-openssl</a>
+ * library.
+ * <p>
+ *   The factory has several different modes of operation:
+ *   <ul>
+ *     <li>OpenSSL: Uses the wildly-openssl library to delegate to the
+ *     system installed OpenSSL. If the wildfly-openssl integration is not
+ *     properly setup, an exception is thrown.</li>
+ *     <li>Default: Attempts to use the OpenSSL mode, if it cannot load the
+ *     necessary libraries, it falls back to the Default_JSEE mode.</li>
+ *     <li>Default_JSSE: Delegates to the JSSE implementation of SSL, but
+ *     it disables the GCM cipher when running on Java 8.</li>
+ *     <li>Default_JSSE_with_GCM: Delegates to the JSSE implementation of
+ *     SSL with no modification to the list of enabled ciphers.</li>
+ *   </ul>
+ * </p>
-public final class SSLSocketFactoryEx extends SSLSocketFactory {
+public final class DelegatingSSLSocketFactory extends SSLSocketFactory {
-   * back to Default_JSSE
+   * back to Default_JSSE.
+   *
+   * <p>
+   *   Default_JSSE is not truly the the default JSSE implementation because
+   *   the GCM cipher is disabled when running on Java 8. However, the name
+   *   was not changed in order to preserve backwards compatibility. Instead,
+   *   a new mode called Default_JSSE_with_GCM delegates to the default JSSE
+   *   implementation with no changes to the list of enabled ciphers.
+   * </p>
-    Default_JSSE
+    Default_JSSE,
+    Default_JSSE_with_GCM
-  private static SSLSocketFactoryEx instance = null;
+  private static DelegatingSSLSocketFactory instance = null;
-      SSLSocketFactoryEx.class);
+          DelegatingSSLSocketFactory.class);
+  // This should only be modified within the #initializeDefaultFactory
+  // method which is synchronized
+  private boolean openSSLProviderRegistered;
+
-      instance = new SSLSocketFactoryEx(preferredMode);
+      instance = new DelegatingSSLSocketFactory(preferredMode);
-  public static SSLSocketFactoryEx getDefaultFactory() {
+  public static DelegatingSSLSocketFactory getDefaultFactory() {
-  static {
-    OpenSSLProvider.register();
-  }
-
-  private SSLSocketFactoryEx(SSLChannelMode preferredChannelMode)
+  private DelegatingSSLSocketFactory(SSLChannelMode preferredChannelMode)
-      case Default:
-        try {
-          java.util.logging.Logger logger = java.util.logging.Logger.getLogger(SSL.class.getName());
-          logger.setLevel(Level.WARNING);
-          ctx = SSLContext.getInstance("openssl.TLS");
-          ctx.init(null, null, null);
-          // Strong reference needs to be kept to logger until initialization of SSLContext finished (see HADOOP-16174):
-          logger.setLevel(Level.INFO);
-          channelMode = SSLChannelMode.OpenSSL;
-        } catch (NoSuchAlgorithmException e) {
-          LOG.warn("Failed to load OpenSSL. Falling back to the JSSE default.");
-          ctx = SSLContext.getDefault();
-          channelMode = SSLChannelMode.Default_JSSE;
-        }
-        break;
-      case OpenSSL:
+    case Default:
+      if (!openSSLProviderRegistered) {
+        OpenSSLProvider.register();
+        openSSLProviderRegistered = true;
+      }
+      try {
+        java.util.logging.Logger logger = java.util.logging.Logger.getLogger(
+                SSL.class.getName());
+        logger.setLevel(Level.WARNING);
+        // Strong reference needs to be kept to logger until initialization of
+        // SSLContext finished (see HADOOP-16174):
+        logger.setLevel(Level.INFO);
-        break;
-      case Default_JSSE:
+      } catch (NoSuchAlgorithmException e) {
+        LOG.debug("Failed to load OpenSSL. Falling back to the JSSE default.");
-        break;
-      default:
-        throw new AssertionError("Unknown channel mode: "
-            + preferredChannelMode);
+      }
+      break;
+    case OpenSSL:
+      if (!openSSLProviderRegistered) {
+        OpenSSLProvider.register();
+        openSSLProviderRegistered = true;
+      }
+      ctx = SSLContext.getInstance("openssl.TLS");
+      ctx.init(null, null, null);
+      channelMode = SSLChannelMode.OpenSSL;
+      break;
+    case Default_JSSE:
+      ctx = SSLContext.getDefault();
+      channelMode = SSLChannelMode.Default_JSSE;
+      break;
+    case Default_JSSE_with_GCM:
+      ctx = SSLContext.getDefault();
+      channelMode = SSLChannelMode.Default_JSSE_with_GCM;
+      break;
+    default:
+      throw new NoSuchAlgorithmException("Unknown channel mode: "
+          + preferredChannelMode);
-        LOG.debug("Removed Cipher - " + defaultCiphers[i]);
+        LOG.debug("Removed Cipher - {} from list of enabled SSLSocket ciphers",
+                defaultCiphers[i]);

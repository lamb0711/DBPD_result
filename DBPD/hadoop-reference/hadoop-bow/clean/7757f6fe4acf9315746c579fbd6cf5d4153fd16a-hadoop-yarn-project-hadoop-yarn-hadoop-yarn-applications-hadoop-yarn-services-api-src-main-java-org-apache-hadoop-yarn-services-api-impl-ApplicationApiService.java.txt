YARN-5812. Exception during GET call - "Failed to retrieve application: null". Contributed by Gour Saha

-import org.apache.hadoop.fs.PathNotFoundException;
+    if (appState == null) {
+      // consider that app is still in ACCEPTED state
+      appState = String.valueOf(StateValues.STATE_INCOMPLETE);
+    }
+            } catch (BadClusterStateException e) {
+              logger.warn("Application not running yet", e);
+              return EMPTY_JSON_OBJECT;
-            } catch (FileNotFoundException | PathNotFoundException e) {
+            } catch (FileNotFoundException | NotFoundException e) {
-    // EXIT_APPLICATION_IN_USE), before giving up.
+    // EXIT_APPLICATION_IN_USE or EXIT_INSTANCE_EXISTS), before giving up.
-    int maxDeleteAttempt = 5;
-    int deleteAttempt = 0;
-    while (keepTrying && deleteAttempt < maxDeleteAttempt) {
+    int maxDeleteAttempts = 5;
+    int deleteAttempts = 0;
+    int sleepIntervalInMillis = 500;
+    while (keepTrying && deleteAttempts < maxDeleteAttempts) {
-        logger.error("Delete application threw exception", e);
-        if (e.getExitCode() == SliderExitCodes.EXIT_APPLICATION_IN_USE) {
-          deleteAttempt++;
+        if (e.getExitCode() == SliderExitCodes.EXIT_APPLICATION_IN_USE
+            || e.getExitCode() == SliderExitCodes.EXIT_INSTANCE_EXISTS) {
+          deleteAttempts++;
+          // If we used up all the allowed delete attempts, let's log it as
+          // error before giving up. Otherwise log as warn.
+          if (deleteAttempts < maxDeleteAttempts) {
+            logger.warn("Application not in stopped state, waiting for {}ms"
+                + " before trying delete again", sleepIntervalInMillis);
+          } else {
+            logger.error("Delete application failed", e);
+          }
-            Thread.sleep(500);
+            Thread.sleep(sleepIntervalInMillis);
+          logger.error("Delete application threw exception", e);

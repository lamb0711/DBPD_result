YARN-3998. Add support in the NodeManager to re-launch containers. Contributed by Jun Gong.

+import org.apache.hadoop.yarn.exceptions.YarnException;
-  private final Application app;
+  protected final Application app;
-  private final LocalDirsHandlerService dirsHandler;
+  protected final LocalDirsHandlerService dirsHandler;
+    if (!validateContainerState()) {
+      return 0;
+    }
+
-    Map<Path,List<String>> localResources = null;
-    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container
-    // is already at KILLING
-    if (container.getContainerState() == ContainerState.KILLING) {
-      dispatcher.getEventHandler().handle(
-          new ContainerExitEvent(containerID,
-              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,
-              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :
-                  ExitCode.TERMINATED.getExitCode(),
-              "Container terminated before launch."));
-      return 0;
-    }
-
-      localResources = container.getLocalizedResources();
-      if (localResources == null) {
-        throw RPCUtil.getRemoteException(
-            "Unable to get local resources when Container " + containerID +
-            " is at " + container.getContainerState());
-      }
+      Map<Path, List<String>> localResources = getLocalizedResources();
+      recordContainerLogDir(containerID, containerLogDir.toString());
+      recordContainerWorkDir(containerID, containerWorkDir.toString());
-
-      List<String> containerLogDirs = new ArrayList<String>();
-      for( String logDir : logDirs) {
-        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);
-      }
+      List<String> containerLocalDirs = getContainerLocalDirs(localDirs);
+      List<String> containerLogDirs = getContainerLogDirs(logDirs);
-      List<String> containerLocalDirs = new ArrayList<>(localDirs.size());
-
-          String containerLocalDir = localDir + Path.SEPARATOR +
-              ContainerLocalizer.USERCACHE + Path.SEPARATOR + user
-              + Path.SEPARATOR
-              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr
-              + Path.SEPARATOR;
-
-          containerLocalDirs.add(containerLocalDir);
-      // LaunchContainer is a blocking call. We are here almost means the
-      // container is launched, so send out the event.
-      dispatcher.getEventHandler().handle(new ContainerEvent(
-            containerID,
-            ContainerEventType.CONTAINER_LAUNCHED));
-      context.getNMStateStore().storeContainerLaunched(containerID);
-
-      // Check if the container is signalled to be killed.
-      if (!shouldLaunchContainer.compareAndSet(false, true)) {
-        LOG.info("Container " + containerIdStr + " not launched as "
-            + "cleanup already called");
-        ret = ExitCode.TERMINATED.getExitCode();
-      }
-      else {
-        exec.activateContainer(containerID, pidFilePath);
-        ret = exec.launchContainer(new ContainerStartContext.Builder()
-            .setContainer(container)
-            .setLocalizedResources(localResources)
-            .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)
-            .setNmPrivateTokensPath(nmPrivateTokensPath)
-            .setUser(user)
-            .setAppId(appIdStr)
-            .setContainerWorkDir(containerWorkDir)
-            .setLocalDirs(localDirs)
-            .setLogDirs(logDirs)
-            .setContainerLocalDirs(containerLocalDirs)
-            .setContainerLogDirs(containerLogDirs)
-            .build());
-      }
+      ret = launchContainer(new ContainerStartContext.Builder()
+          .setContainer(container)
+          .setLocalizedResources(localResources)
+          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)
+          .setNmPrivateTokensPath(nmPrivateTokensPath)
+          .setUser(user)
+          .setAppId(appIdStr)
+          .setContainerWorkDir(containerWorkDir)
+          .setLocalDirs(localDirs)
+          .setLogDirs(logDirs)
+          .setContainerLocalDirs(containerLocalDirs)
+          .setContainerLogDirs(containerLogDirs)
+          .build());
-      completed.set(true);
-      exec.deactivateContainer(containerID);
-      try {
-        context.getNMStateStore().storeContainerCompleted(containerID, ret);
-      } catch (IOException e) {
-        LOG.error("Unable to set exit code for container " + containerID);
-      }
+      setContainerCompletedStatus(ret);
+    handleContainerExitCode(ret, containerLogDir);
+
+    return ret;
+  }
+
+  @SuppressWarnings("unchecked")
+  protected boolean validateContainerState() {
+    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container
+    // is already at KILLING
+    if (container.getContainerState() == ContainerState.KILLING) {
+      dispatcher.getEventHandler().handle(
+          new ContainerExitEvent(container.getContainerId(),
+              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,
+              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :
+                  ExitCode.TERMINATED.getExitCode(),
+              "Container terminated before launch."));
+      return false;
+    }
+
+    return true;
+  }
+
+  protected List<String> getContainerLogDirs(List<String> logDirs) {
+    List<String> containerLogDirs = new ArrayList<>(logDirs.size());
+    String appIdStr = app.getAppId().toString();
+    String containerIdStr = ConverterUtils.toString(container.getContainerId());
+    String relativeContainerLogDir = ContainerLaunch
+        .getRelativeContainerLogDir(appIdStr, containerIdStr);
+
+    for(String logDir : logDirs) {
+      containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);
+    }
+
+    return containerLogDirs;
+  }
+
+  protected List<String> getContainerLocalDirs(List<String> localDirs) {
+    List<String> containerLocalDirs = new ArrayList<>(localDirs.size());
+    String user = container.getUser();
+    String appIdStr = app.getAppId().toString();
+    String relativeContainerLocalDir = ContainerLocalizer.USERCACHE
+        + Path.SEPARATOR + user + Path.SEPARATOR + ContainerLocalizer.APPCACHE
+        + Path.SEPARATOR + appIdStr + Path.SEPARATOR;
+
+    for (String localDir : localDirs) {
+      containerLocalDirs.add(localDir + Path.SEPARATOR
+          + relativeContainerLocalDir);
+    }
+
+    return containerLocalDirs;
+  }
+
+  protected Map<Path, List<String>> getLocalizedResources()
+      throws YarnException {
+    Map<Path, List<String>> localResources = container.getLocalizedResources();
+    if (localResources == null) {
+      throw RPCUtil.getRemoteException(
+          "Unable to get local resources when Container " + container
+              + " is at " + container.getContainerState());
+    }
+    return localResources;
+  }
+
+  @SuppressWarnings("unchecked")
+  protected int launchContainer(ContainerStartContext ctx) throws IOException {
+    ContainerId containerId = container.getContainerId();
+
+    // LaunchContainer is a blocking call. We are here almost means the
+    // container is launched, so send out the event.
+    dispatcher.getEventHandler().handle(new ContainerEvent(
+        containerId,
+        ContainerEventType.CONTAINER_LAUNCHED));
+    context.getNMStateStore().storeContainerLaunched(containerId);
+
+    // Check if the container is signalled to be killed.
+    if (!shouldLaunchContainer.compareAndSet(false, true)) {
+      LOG.info("Container " + containerId + " not launched as "
+          + "cleanup already called");
+      return ExitCode.TERMINATED.getExitCode();
+    } else {
+      exec.activateContainer(containerId, pidFilePath);
+      return exec.launchContainer(ctx);
+    }
+  }
+
+  protected void setContainerCompletedStatus(int exitCode) {
+    ContainerId containerId = container.getContainerId();
+    completed.set(true);
+    exec.deactivateContainer(containerId);
+    try {
+      if (!container.shouldRetry(exitCode)) {
+        context.getNMStateStore().storeContainerCompleted(containerId,
+            exitCode);
+      }
+    } catch (IOException e) {
+      LOG.error("Unable to set exit code for container " + containerId);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  protected void handleContainerExitCode(int exitCode, Path containerLogDir) {
+    ContainerId containerId = container.getContainerId();
+
-      LOG.debug("Container " + containerIdStr + " completed with exit code "
-                + ret);
+      LOG.debug("Container " + containerId + " completed with exit code "
+          + exitCode);
-    diagnosticInfo.append(ret);
+    diagnosticInfo.append(exitCode);
-    if (ret == ExitCode.FORCE_KILLED.getExitCode()
-        || ret == ExitCode.TERMINATED.getExitCode()) {
+    if (exitCode == ExitCode.FORCE_KILLED.getExitCode()
+        || exitCode == ExitCode.TERMINATED.getExitCode()) {
-            new ContainerExitEvent(containerID,
-                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,
-                diagnosticInfo.toString()));
-      return ret;
-    }
-
-    if (ret != 0) {
-      handleContainerExitWithFailure(containerID, ret, containerLogDir,
+          new ContainerExitEvent(containerId,
+              ContainerEventType.CONTAINER_KILLED_ON_REQUEST, exitCode,
+              diagnosticInfo.toString()));
+    } else if (exitCode != 0) {
+      handleContainerExitWithFailure(containerId, exitCode, containerLogDir,
-      return ret;
+    } else {
+      LOG.info("Container " + containerId + " succeeded ");
+      dispatcher.getEventHandler().handle(
+          new ContainerEvent(containerId,
+              ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));
-
-    LOG.info("Container " + containerIdStr + " succeeded ");
-    dispatcher.getEventHandler().handle(
-        new ContainerEvent(containerID,
-            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));
-    return 0;
-  private void handleContainerExitWithFailure(ContainerId containerID, int ret,
-      Path containerLogDir, StringBuilder diagnosticInfo) {
+  protected void handleContainerExitWithFailure(ContainerId containerID,
+      int ret, Path containerLogDir, StringBuilder diagnosticInfo) {
-  private String getContainerPrivateDir(String appIdStr, String containerIdStr) {
+  protected String getContainerPrivateDir(String appIdStr,
+      String containerIdStr) {
+
+  private void recordContainerLogDir(ContainerId containerId,
+      String logDir) throws IOException{
+    if (container.isRetryContextSet()) {
+      container.setLogDir(logDir);
+      context.getNMStateStore().storeContainerLogDir(containerId, logDir);
+    }
+  }
+
+  private void recordContainerWorkDir(ContainerId containerId,
+      String workDir) throws IOException{
+    if (container.isRetryContextSet()) {
+      container.setWorkDir(workDir);
+      context.getNMStateStore().storeContainerWorkDir(containerId, workDir);
+    }
+  }

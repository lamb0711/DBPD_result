YARN-6903. Yarn-native-service framework core rewrite. Contributed by Jian He

-
-import org.apache.commons.lang.StringUtils;
-import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.conf.Configured;
-import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext;
-import org.apache.hadoop.yarn.api.records.LogAggregationContext;
-import org.apache.hadoop.yarn.api.records.Resource;
-import org.apache.slider.api.ResourceKeys;
-import org.apache.slider.api.RoleKeys;
-import org.apache.slider.common.SliderKeys;
+import org.apache.hadoop.yarn.service.conf.SliderKeys;
-import org.apache.slider.core.conf.MapOperations;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-import static org.apache.slider.providers.docker.DockerKeys.DEFAULT_DOCKER_NETWORK;
+import static org.apache.hadoop.yarn.service.provider.docker.DockerKeys.DEFAULT_DOCKER_NETWORK;
-public abstract class AbstractLauncher extends Configured {
+public class AbstractLauncher {
-  protected final MapOperations env = new MapOperations("env", envVars);
-  protected LogAggregationContext logAggregationContext;
-  protected String yarnContainerMountPoints;
-   * @param conf configuration
-  protected AbstractLauncher(Configuration conf,
+  public AbstractLauncher(
-    super(conf);
-
-  /**
-   * Get the container. Until "completed", this isn't valid to launch.
-   * @return the container to launch
-   */
-  public ContainerLaunchContext getContainerLaunchContext() {
-    return containerLaunchContext;
-  }
-  public MapOperations getEnv() {
-    return env;
+  public Map<String, String> getEnv() {
+    return envVars;
-  /**
-   * Get the map of local resources.
-   * @return the live map of local resources.
-   */
-  public Map<String, LocalResource> getLocalResources() {
-    return localResources;
-  }
-
-   * Add a set of local resources
-   * @param resourceMap map of name:resource to add
-   */
-  public void addLocalResources(Map<String, LocalResource> resourceMap) {
-    localResources.putAll(resourceMap);
-  }
-
-  public Map<String, ByteBuffer> getServiceData() {
-    return serviceData;
-  }
-
-  /**
-  /**
-   * Add a command line. It is converted to a single command before being
-   * added.
-   * @param cmd
-   */
-  public void addCommandLine(CommandLineBuilder cmd) {
-    commands.add(cmd.build());
-  }
-   * Add a list of commands. Each element in the list becomes a single command
-   * @param commandList list of commands
-   */
-  public void addCommands(List<String> commandList) {
-    commands.addAll(commandList);
-  }
-
-  /**
-   * Get all commands as a string, separated by ";". This is for diagnostics
-   * @return a string description of the commands
-   */
-  public String getCommandsAsString() {
-    return SliderUtils.join(getCommands(), "; ");
-  }
-
-  /**
-    containerLaunchContext.setEnvironment(env);
+    containerLaunchContext.setEnvironment(envVars);
-    env.put(SliderKeys.HADOOP_USER_NAME, userName);
-  }
-
-  /**
-   * Extract any resource requirements from this component's settings.
-   * All fields that are set will override the existing values -if
-   * unset that resource field will be left unchanged.
-   *
-   * Important: the configuration must already be fully resolved 
-   * in order to pick up global options.
-   * @param resource resource to configure
-   * @param map map of options
-   */
-  public void extractResourceRequirements(Resource resource,
-                                          Map<String, String> map) {
-
-    if (map != null) {
-      MapOperations options = new MapOperations("", map);
-      resource.setMemory(options.getOptionInt(ResourceKeys.YARN_MEMORY,
-                                              resource.getMemory()));
-      resource.setVirtualCores(options.getOptionInt(ResourceKeys.YARN_CORES,
-                                                    resource.getVirtualCores()));
-    }
-  }
-
-  public void extractLogAggregationContext(Map<String, String> map) {
-    if (map != null) {
-      String logPatternSepStr = "\\|";
-      String logPatternJoinStr = "|";
-      MapOperations options = new MapOperations("", map);
-
-      List<String> logIncludePatterns = new ArrayList<>();
-      String includePatternExpression = options.getOption(
-          ResourceKeys.YARN_LOG_INCLUDE_PATTERNS, "").trim();
-      if (!includePatternExpression.isEmpty()) {
-        String[] includePatterns = includePatternExpression
-            .split(logPatternSepStr);
-        for (String includePattern : includePatterns) {
-          String trimmedIncludePattern = includePattern.trim();
-          if (!trimmedIncludePattern.isEmpty()) {
-            logIncludePatterns.add(trimmedIncludePattern);
-          }
-        }
-      }
-      String logIncludePattern = StringUtils.join(logIncludePatterns,
-          logPatternJoinStr);
-      log.info("Log include patterns: {}", logIncludePattern);
-
-      List<String> logExcludePatterns = new ArrayList<>();
-      String excludePatternExpression = options.getOption(
-          ResourceKeys.YARN_LOG_EXCLUDE_PATTERNS, "").trim();
-      if (!excludePatternExpression.isEmpty()) {
-        String[] excludePatterns = excludePatternExpression
-            .split(logPatternSepStr);
-        for (String excludePattern : excludePatterns) {
-          String trimmedExcludePattern = excludePattern.trim();
-          if (!trimmedExcludePattern.isEmpty()) {
-            logExcludePatterns.add(trimmedExcludePattern);
-          }
-        }
-      }
-      String logExcludePattern = StringUtils.join(logExcludePatterns,
-          logPatternJoinStr);
-      log.info("Log exclude patterns: {}", logExcludePattern);
-
-      // SLIDER-810/YARN-3154 - hadoop 2.7.0 onwards a new instance method has
-      // been added for log aggregation for LRS. Existing newInstance method's
-      // behavior has changed and is used for log aggregation only after the
-      // application has finished. This forces Slider users to move to hadoop
-      // 2.7.0+ just for log aggregation, which is not very desirable. So we
-      // decided to use reflection here to find out if the new 2.7.0 newInstance
-      // method is available. If yes, then we use it, so log aggregation will
-      // work in hadoop 2.7.0+ env. If no, then we fallback to the pre-2.7.0
-      // newInstance method, which means log aggregation will work as expected
-      // in hadoop 2.6 as well.
-      // TODO: At some point, say 2-3 Slider releases down, when most users are
-      // running hadoop 2.7.0, we should get rid of the reflection code here.
-      try {
-        Method logAggregationContextMethod = LogAggregationContext.class
-            .getMethod("newInstance", String.class, String.class, String.class,
-                String.class);
-        // Need to set include/exclude patterns appropriately since by default
-        // rolled log aggregation is not done for any files, so defaults are
-        // - include pattern set to ""
-        // - exclude pattern set to "*"
-        // For Slider we want all logs to be uploaded if include/exclude
-        // patterns are left empty by the app owner in resources file
-        if (StringUtils.isEmpty(logIncludePattern)
-            && StringUtils.isEmpty(logExcludePattern)) {
-          logIncludePattern = ".*";
-          logExcludePattern = "";
-        } else if (StringUtils.isEmpty(logIncludePattern)
-            && StringUtils.isNotEmpty(logExcludePattern)) {
-          logIncludePattern = ".*";
-        } else if (StringUtils.isNotEmpty(logIncludePattern)
-            && StringUtils.isEmpty(logExcludePattern)) {
-          logExcludePattern = "";
-        }
-        log.debug("LogAggregationContext newInstance method for rolled logs "
-            + "include/exclude patterns is available");
-        log.info("Modified log include patterns: {}", logIncludePattern);
-        log.info("Modified log exclude patterns: {}", logExcludePattern);
-        logAggregationContext = (LogAggregationContext) logAggregationContextMethod
-            .invoke(null, null, null, logIncludePattern, logExcludePattern);
-      } catch (NoSuchMethodException | SecurityException
-          | IllegalAccessException | IllegalArgumentException
-          | InvocationTargetException e) {
-        log.debug("LogAggregationContext newInstance method for rolled logs "
-            + "include/exclude patterns is not available - fallback to old one");
-        log.debug(e.toString());
-        logAggregationContext = LogAggregationContext.newInstance(
-            logIncludePattern, logExcludePattern);
-      }
-    }
+    envVars.put(SliderKeys.HADOOP_USER_NAME, userName);
-    env.put(var, value);
+    envVars.put(var, value);
-  /**
-   * Set an environment variable if its value is non-null.
-   * @param var variable name
-   * @param value value (may be null)
-   */
-  public void maybeSetEnv(String var, String value) {
-    if (value != null) {
-      setEnv(var, value);
-    }
-  }
-    env.putAll(map);
+    envVars.putAll(map);
-  public String[] dumpEnvToString() {
-
-    List<String> nodeEnv = new ArrayList<>();
-
-    for (Map.Entry<String, String> entry : env.entrySet()) {
-      String envElt = String.format("%s=\"%s\"",
-                                    entry.getKey(),
-                                    entry.getValue());
-      log.debug(envElt);
-      nodeEnv.add(envElt);
-    }
-    String[] envDescription = nodeEnv.toArray(new String[nodeEnv.size()]);
-
-    return envDescription;
-  }
-
-  /**
-   * Submit an entire directory
-   * @param srcDir src path in filesystem
-   * @param destRelativeDir relative path under destination local dir
-   * @throws IOException IO problems
-   */
-  public void submitDirectory(Path srcDir, String destRelativeDir)
-      throws IOException {
-    //add the configuration resources
-    Map<String, LocalResource> confResources;
-    confResources = coreFileSystem.submitDirectory(
-      srcDir,
-      destRelativeDir);
-    addLocalResources(confResources);
-  }
-
-  public void setYarnContainerMountPoints(String yarnContainerMountPoints) {
-    this.yarnContainerMountPoints = yarnContainerMountPoints;
-  }
-
-  public void setRunPrivilegedContainer(String runPrivilegedContainer) {
-    this.runPrivilegedContainer = runPrivilegedContainer;
-  }
-

HDDS-1217. Refactor ChillMode rules and chillmode manager. (#558)



+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.hdds.scm.events.SCMEvents;
-import org.apache.hadoop.hdds.server.events.EventHandler;
-import org.apache.hadoop.hdds.server.events.EventPublisher;
+
+import org.apache.hadoop.hdds.server.events.EventQueue;
+import org.apache.hadoop.hdds.server.events.TypedEvent;
-    implements ChillModeExitRule<PipelineReportFromDatanode>,
-    EventHandler<PipelineReportFromDatanode> {
+    extends ChillModeExitRule<PipelineReportFromDatanode>{
-  private final SCMChillModeManager chillModeManager;
-  HealthyPipelineChillModeRule(PipelineManager pipelineManager,
+  HealthyPipelineChillModeRule(String ruleName, EventQueue eventQueue,
+      PipelineManager pipelineManager,
+    super(manager, ruleName, eventQueue);
-    this.chillModeManager = manager;
+    Preconditions.checkArgument(
+        (healthyPipelinesPercent >= 0.0 && healthyPipelinesPercent <= 1.0),
+        HddsConfigKeys.
+            HDDS_SCM_CHILLMODE_HEALTHY_PIPELINE_THRESHOLD_PCT
+            + " value should be >= 0.0 and <= 1.0");
+
-  public boolean validate() {
+  protected TypedEvent<PipelineReportFromDatanode> getEventType() {
+    return SCMEvents.PROCESSED_PIPELINE_REPORT;
+  }
+
+  @Override
+  protected boolean validate() {
-  public void process(PipelineReportFromDatanode pipelineReportFromDatanode) {
-    Pipeline pipeline;
-    Preconditions.checkNotNull(pipelineReportFromDatanode);
-    PipelineReportsProto pipelineReport =
-        pipelineReportFromDatanode.getReport();
-
-    for (PipelineReport report : pipelineReport.getPipelineReportList()) {
-      PipelineID pipelineID = PipelineID
-          .getFromProtobuf(report.getPipelineID());
-      try {
-        pipeline = pipelineManager.getPipeline(pipelineID);
-      } catch (PipelineNotFoundException e) {
-        continue;
-      }
-
-      if (pipeline.getFactor() == HddsProtos.ReplicationFactor.THREE &&
-          pipeline.getPipelineState() == Pipeline.PipelineState.OPEN) {
-        // If the pipeline is open state mean, all 3 datanodes are reported
-        // for this pipeline.
-        currentHealthyPipelineCount++;
-      }
-    }
-  }
-
-  @Override
-  public void cleanup() {
-    // No need to deal with
-  }
-
-  @Override
-  public void onMessage(PipelineReportFromDatanode pipelineReportFromDatanode,
-      EventPublisher publisher) {
-    // If we have already reached healthy pipeline threshold, skip processing
-    // pipeline report from datanode.
-
-    if (validate()) {
-      chillModeManager.validateChillModeExitRules(publisher);
-      return;
-    }
-
+  protected void process(PipelineReportFromDatanode
+      pipelineReportFromDatanode) {
+    Preconditions.checkNotNull(pipelineReportFromDatanode);
-      // Process pipeline report from datanode
-      process(pipelineReportFromDatanode);
+      Pipeline pipeline;
+      PipelineReportsProto pipelineReport =
+          pipelineReportFromDatanode.getReport();
-      if (chillModeManager.getInChillMode()) {
+      for (PipelineReport report : pipelineReport.getPipelineReportList()) {
+        PipelineID pipelineID = PipelineID
+            .getFromProtobuf(report.getPipelineID());
+        try {
+          pipeline = pipelineManager.getPipeline(pipelineID);
+        } catch (PipelineNotFoundException e) {
+          continue;
+        }
+
+        if (pipeline.getFactor() == HddsProtos.ReplicationFactor.THREE &&
+            pipeline.getPipelineState() == Pipeline.PipelineState.OPEN) {
+          // If the pipeline is open state mean, all 3 datanodes are reported
+          // for this pipeline.
+          currentHealthyPipelineCount++;
+        }
+      }
+
+      if (scmInChillMode()) {
-    if (validate()) {
-      chillModeManager.validateChillModeExitRules(publisher);
-    }
+  }
+
+  @Override
+  protected void cleanup() {
+    processedDatanodeDetails.clear();
+  }
+
+  @VisibleForTesting
+  public int getCurrentHealthyPipelineCount() {
+    return currentHealthyPipelineCount;
+  }
+
+  @VisibleForTesting
+  public int getHealthyPipelineThresholdCount() {
+    return healthyPipelineThresholdCount;

YARN-5368. Memory leak in timeline server (Jonathan Eagles via Varun Saxena)

-    FileSystem localFS = null;
-    try {
-      localFS = FileSystem.getLocal(conf);
+    try (FileSystem localFS = FileSystem.getLocal(conf)) {
-    } finally {
-      IOUtils.cleanup(LOG, localFS);
-    DBIterator iterator = null;
-    try {
-      DB db = entitydb.getDBForStartTime(revStartTime);
-      if (db == null) {
-        return null;
-      }
-      iterator = db.iterator();
+    DB db = entitydb.getDBForStartTime(revStartTime);
+    if (db == null) {
+      return null;
+    }
+    try (DBIterator iterator = db.iterator()) {
-    } finally {
-      IOUtils.cleanup(LOG, iterator);
-    DBIterator iterator = null;
-    try {
+
-      for (String entityId : entityIds) {
-        byte[] startTime = getStartTime(entityId, entityType);
-        if (startTime != null) {
-          List<EntityIdentifier> entities = startTimeMap.get(startTime);
-          if (entities == null) {
-            entities = new ArrayList<EntityIdentifier>();
-            startTimeMap.put(startTime, entities);
-          }
-          entities.add(new EntityIdentifier(entityId, entityType));
+    for (String entityId : entityIds) {
+      byte[] startTime = getStartTime(entityId, entityType);
+      if (startTime != null) {
+        List<EntityIdentifier> entities = startTimeMap.get(startTime);
+        if (entities == null) {
+          entities = new ArrayList<EntityIdentifier>();
+          startTimeMap.put(startTime, entities);
+        entities.add(new EntityIdentifier(entityId, entityType));
-      for (Entry<byte[], List<EntityIdentifier>> entry : startTimeMap
+    }
+    for (Entry<byte[], List<EntityIdentifier>> entry : startTimeMap
-        // look up the events matching the given parameters (limit,
-        // start time, end time, event types) for entities whose start times
-        // were found and add the entities to the return list
-        byte[] revStartTime = entry.getKey();
-        for (EntityIdentifier entityIdentifier : entry.getValue()) {
-          EventsOfOneEntity entity = new EventsOfOneEntity();
-          entity.setEntityId(entityIdentifier.getId());
-          entity.setEntityType(entityType);
-          events.addEvent(entity);
-          KeyBuilder kb = KeyBuilder.newInstance().add(entityType)
-              .add(revStartTime).add(entityIdentifier.getId())
-              .add(EVENTS_COLUMN);
-          byte[] prefix = kb.getBytesForLookup();
-          if (windowEnd == null) {
-            windowEnd = Long.MAX_VALUE;
-          }
-          byte[] revts = writeReverseOrderedLong(windowEnd);
-          kb.add(revts);
-          byte[] first = kb.getBytesForLookup();
-          byte[] last = null;
-          if (windowStart != null) {
-            last = KeyBuilder.newInstance().add(prefix)
-                .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();
-          }
-          if (limit == null) {
-            limit = DEFAULT_LIMIT;
-          }
-          DB db = entitydb.getDBForStartTime(readReverseOrderedLong(
-              revStartTime, 0));
-          if (db == null) {
-            continue;
-          }
-          iterator = db.iterator();
+      // look up the events matching the given parameters (limit,
+      // start time, end time, event types) for entities whose start times
+      // were found and add the entities to the return list
+      byte[] revStartTime = entry.getKey();
+      for (EntityIdentifier entityIdentifier : entry.getValue()) {
+        EventsOfOneEntity entity = new EventsOfOneEntity();
+        entity.setEntityId(entityIdentifier.getId());
+        entity.setEntityType(entityType);
+        events.addEvent(entity);
+        KeyBuilder kb = KeyBuilder.newInstance().add(entityType)
+            .add(revStartTime).add(entityIdentifier.getId())
+            .add(EVENTS_COLUMN);
+        byte[] prefix = kb.getBytesForLookup();
+        if (windowEnd == null) {
+          windowEnd = Long.MAX_VALUE;
+        }
+        byte[] revts = writeReverseOrderedLong(windowEnd);
+        kb.add(revts);
+        byte[] first = kb.getBytesForLookup();
+        byte[] last = null;
+        if (windowStart != null) {
+          last = KeyBuilder.newInstance().add(prefix)
+              .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();
+        }
+        if (limit == null) {
+          limit = DEFAULT_LIMIT;
+        }
+        DB db = entitydb.getDBForStartTime(readReverseOrderedLong(
+            revStartTime, 0));
+        if (db == null) {
+          continue;
+        }
+        try (DBIterator iterator = db.iterator()) {
-                    key.length, last, 0, last.length) > 0)) {
+                key.length, last, 0, last.length) > 0)) {
-    } finally {
-      IOUtils.cleanup(LOG, iterator);
-    DBIterator iterator = null;
-    try {
-      KeyBuilder kb = KeyBuilder.newInstance().add(base).add(entityType);
-      // only db keys matching the prefix (base + entity type) will be parsed
-      byte[] prefix = kb.getBytesForLookup();
-      if (endtime == null) {
-        // if end time is null, place no restriction on end time
-        endtime = Long.MAX_VALUE;
-      }
+    KeyBuilder kb = KeyBuilder.newInstance().add(base).add(entityType);
+    // only db keys matching the prefix (base + entity type) will be parsed
+    byte[] prefix = kb.getBytesForLookup();
+    if (endtime == null) {
+      // if end time is null, place no restriction on end time
+      endtime = Long.MAX_VALUE;
+    }
-      // Sanitize the fields parameter
-      if (fields == null) {
-        fields = EnumSet.allOf(Field.class);
-      }
+    // Sanitize the fields parameter
+    if (fields == null) {
+      fields = EnumSet.allOf(Field.class);
+    }
-      // construct a first key that will be seeked to using end time or fromId
-      long firstStartTime = Long.MAX_VALUE;
-      byte[] first = null;
-      if (fromId != null) {
-        Long fromIdStartTime = getStartTimeLong(fromId, entityType);
-        if (fromIdStartTime == null) {
-          // no start time for provided id, so return empty entities
-          return new TimelineEntities();
-        }
-        if (fromIdStartTime <= endtime) {
-          // if provided id's start time falls before the end of the window,
-          // use it to construct the seek key
-          firstStartTime = fromIdStartTime;
-          first = kb.add(writeReverseOrderedLong(fromIdStartTime)).add(fromId)
-              .getBytesForLookup();
-        }
+    // construct a first key that will be seeked to using end time or fromId
+    long firstStartTime = Long.MAX_VALUE;
+    byte[] first = null;
+    if (fromId != null) {
+      Long fromIdStartTime = getStartTimeLong(fromId, entityType);
+      if (fromIdStartTime == null) {
+        // no start time for provided id, so return empty entities
+        return new TimelineEntities();
-      // if seek key wasn't constructed using fromId, construct it using end ts
-      if (first == null) {
-        firstStartTime = endtime;
-        first = kb.add(writeReverseOrderedLong(endtime)).getBytesForLookup();
+      if (fromIdStartTime <= endtime) {
+        // if provided id's start time falls before the end of the window,
+        // use it to construct the seek key
+        firstStartTime = fromIdStartTime;
+        first = kb.add(writeReverseOrderedLong(fromIdStartTime)).add(fromId)
+            .getBytesForLookup();
-      byte[] last = null;
-      if (starttime != null) {
-        // if start time is not null, set a last key that will not be
-        // iterated past
-        last = KeyBuilder.newInstance().add(base).add(entityType)
-            .add(writeReverseOrderedLong(starttime)).getBytesForLookup();
-      }
-      if (limit == null) {
-        // if limit is not specified, use the default
-        limit = DEFAULT_LIMIT;
-      }
+    }
+    // if seek key wasn't constructed using fromId, construct it using end ts
+    if (first == null) {
+      firstStartTime = endtime;
+      first = kb.add(writeReverseOrderedLong(endtime)).getBytesForLookup();
+    }
+    byte[] last = null;
+    if (starttime != null) {
+      // if start time is not null, set a last key that will not be
+      // iterated past
+      last = KeyBuilder.newInstance().add(base).add(entityType)
+          .add(writeReverseOrderedLong(starttime)).getBytesForLookup();
+    }
+    if (limit == null) {
+      // if limit is not specified, use the default
+      limit = DEFAULT_LIMIT;
+    }
-      TimelineEntities entities = new TimelineEntities();
-      RollingLevelDB rollingdb = null;
-      if (usingPrimaryFilter) {
-        rollingdb = indexdb;
-      } else {
-        rollingdb = entitydb;
-      }
+    TimelineEntities entities = new TimelineEntities();
+    RollingLevelDB rollingdb = null;
+    if (usingPrimaryFilter) {
+      rollingdb = indexdb;
+    } else {
+      rollingdb = entitydb;
+    }
-      DB db = rollingdb.getDBForStartTime(firstStartTime);
-      while (entities.getEntities().size() < limit && db != null) {
-        iterator = db.iterator();
+    DB db = rollingdb.getDBForStartTime(firstStartTime);
+    while (entities.getEntities().size() < limit && db != null) {
+      try (DBIterator iterator = db.iterator()) {
-                  key.length, last, 0, last.length) > 0)) {
+              key.length, last, 0, last.length) > 0)) {
-      return entities;
-    } finally {
-      IOUtils.cleanup(LOG, iterator);
+    return entities;
-    DBIterator iterator = null;
-    try {
-      writeBatch = starttimedb.createWriteBatch();
-      ReadOptions readOptions = new ReadOptions();
-      readOptions.fillCache(false);
-      iterator = starttimedb.iterator(readOptions);
+    ReadOptions readOptions = new ReadOptions();
+    readOptions.fillCache(false);
+    try (DBIterator iterator = starttimedb.iterator(readOptions)) {
+
+      writeBatch = starttimedb.createWriteBatch();
-      IOUtils.cleanup(LOG, iterator);
-    WriteBatch domainWriteBatch = null;
-    WriteBatch ownerWriteBatch = null;
-    try {
-      domainWriteBatch = domaindb.createWriteBatch();
-      ownerWriteBatch = ownerdb.createWriteBatch();
+    try (WriteBatch domainWriteBatch = domaindb.createWriteBatch();
+         WriteBatch ownerWriteBatch = ownerdb.createWriteBatch();) {
+
-    } finally {
-      IOUtils.cleanup(LOG, domainWriteBatch);
-      IOUtils.cleanup(LOG, ownerWriteBatch);
-    DBIterator iterator = null;
-    try {
+    try (DBIterator iterator = domaindb.iterator()) {
-      iterator = domaindb.iterator();
-    } finally {
-      IOUtils.cleanup(LOG, iterator);
-    DBIterator iterator = null;
-    try {
+    try (DBIterator iterator = ownerdb.iterator()) {
+      iterator.seek(prefix);
-      for (iterator = ownerdb.iterator(), iterator.seek(prefix); iterator
-          .hasNext();) {
+      while (iterator.hasNext()) {
-    } finally {
-      IOUtils.cleanup(LOG, iterator);

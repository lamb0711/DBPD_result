HDFS-13070. Ozone: SCM: Support for container replica reconciliation - 1. Contributed by Nanda kumar.

+import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.conf.OzoneConfiguration;
-import org.apache.hadoop.ozone.scm.node.CommandQueue;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import static org.apache.hadoop.scm.ScmConfigKeys
+    .OZONE_SCM_MAX_NODEPOOL_PROCESSING_THREADS;
+import static org.apache.hadoop.scm.ScmConfigKeys
+    .OZONE_SCM_MAX_NODEPOOL_PROCESSING_THREADS_DEFAULT;
-public class ContainerReplicationManager implements Closeable {
+public class ContainerSupervisor implements Closeable {
-      LoggerFactory.getLogger(ContainerReplicationManager.class);
+      LoggerFactory.getLogger(ContainerSupervisor.class);
-  private final CommandQueue commandQueue;
+  private final int inProgressPoolMaxCount;
+
+  private final ReadWriteLock inProgressPoolListLock;
-   * @param commandQueue - Datanodes Command Queue.
-  public ContainerReplicationManager(OzoneConfiguration conf,
-      NodeManager nodeManager, NodePoolManager poolManager,
-      CommandQueue commandQueue) {
+  public ContainerSupervisor(Configuration conf, NodeManager nodeManager,
+                             NodePoolManager poolManager) {
-    Preconditions.checkNotNull(commandQueue);
+    this.inProgressPoolMaxCount = conf.getInt(
+        OZONE_SCM_MAX_NODEPOOL_PROCESSING_THREADS,
+        OZONE_SCM_MAX_NODEPOOL_PROCESSING_THREADS_DEFAULT);
-    this.commandQueue = commandQueue;
-    runnable = new AtomicBoolean(true);
+    this.runnable = new AtomicBoolean(true);
-    executorService = HadoopExecutors.newCachedThreadPool(
+    this.executorService = HadoopExecutors.newCachedThreadPool(
-    inProgressPoolList = new LinkedList<>();
+    this.inProgressPoolList = new LinkedList<>();
+    this.inProgressPoolListLock = new ReentrantReadWriteLock();
-        PeriodicPool pool = poolQueue.poll();
-        if (pool != null) {
-          if (pool.getLastProcessedTime() + this.containerProcessingLag <
-              Time.monotonicNow()) {
-            LOG.debug("Adding pool {} to container processing queue", pool
-                .getPoolName());
-            InProgressPool inProgressPool =  new InProgressPool(maxPoolWait,
-                pool, this.nodeManager, this.poolManager, this.commandQueue,
-                this.executorService);
-            inProgressPool.startReconciliation();
-            inProgressPoolList.add(inProgressPool);
-            poolProcessCount++;
-
-          } else {
-
-            LOG.debug("Not within the time window for processing: {}",
+        while (inProgressPoolList.size() < inProgressPoolMaxCount) {
+          PeriodicPool pool = poolQueue.poll();
+          if (pool != null) {
+            if (pool.getLastProcessedTime() + this.containerProcessingLag >
+                Time.monotonicNow()) {
+              LOG.debug("Not within the time window for processing: {}",
+                  pool.getPoolName());
+              // we might over sleep here, not a big deal.
+              sleepUninterruptibly(this.containerProcessingLag,
+                  TimeUnit.MILLISECONDS);
+            }
+            LOG.debug("Adding pool {} to container processing queue",
-            // Put back this pool since we are not planning to process it.
-            poolQueue.add(pool);
-            // we might over sleep here, not a big deal.
-            sleepUninterruptibly(this.containerProcessingLag,
-                TimeUnit.MILLISECONDS);
+            InProgressPool inProgressPool = new InProgressPool(maxPoolWait,
+                pool, this.nodeManager, this.poolManager, this.executorService);
+            inProgressPool.startReconciliation();
+            inProgressPoolListLock.writeLock().lock();
+            try {
+              inProgressPoolList.add(inProgressPool);
+            } finally {
+              inProgressPoolListLock.writeLock().unlock();
+            }
+            poolProcessCount++;
+          } else {
+            break;
+        inProgressPoolListLock.readLock().lock();
+        try {
+          for (InProgressPool inProgressPool : inProgressPoolList) {
+            inProgressPool.finalizeReconciliation();
+            poolQueue.add(inProgressPool.getPool());
+          }
+        } finally {
+          inProgressPoolListLock.readLock().unlock();
+        }
+        inProgressPoolListLock.writeLock().lock();
+        try {
+          inProgressPoolList.clear();
+        } finally {
+          inProgressPoolListLock.writeLock().unlock();
+        }
-    String poolName = null;
-    DatanodeID datanodeID = DatanodeID
-        .getFromProtoBuf(containerReport.getDatanodeID());
+    DatanodeID datanodeID = DatanodeID.getFromProtoBuf(
+        containerReport.getDatanodeID());
+    inProgressPoolListLock.readLock().lock();
-      poolName = poolManager.getNodePool(datanodeID);
+      String poolName = poolManager.getNodePool(datanodeID);
+      for (InProgressPool ppool : inProgressPoolList) {
+        if (ppool.getPoolName().equalsIgnoreCase(poolName)) {
+          ppool.handleContainerReport(containerReport);
+          return;
+        }
+      }
+      // TODO: Decide if we can do anything else with this report.
+      LOG.debug("Discarding the container report for pool {}. " +
+              "That pool is not currently in the pool reconciliation process." +
+              " Container Name: {}", poolName, containerReport.getDatanodeID());
-      return;
+    } finally {
+      inProgressPoolListLock.readLock().unlock();
-
-    for(InProgressPool ppool : inProgressPoolList) {
-      if(ppool.getPoolName().equalsIgnoreCase(poolName)) {
-        ppool.handleContainerReport(containerReport);
-        return;
-      }
-    }
-    // TODO: Decide if we can do anything else with this report.
-    LOG.debug("Discarding the container report for pool {}. That pool is not " +
-        "currently in the pool reconciliation process. Container Name: {}",
-        poolName, containerReport.getDatanodeID());

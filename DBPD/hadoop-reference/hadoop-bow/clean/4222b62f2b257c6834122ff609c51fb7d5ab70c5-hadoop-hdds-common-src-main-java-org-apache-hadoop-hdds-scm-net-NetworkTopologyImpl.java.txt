HDDS-1879.  Support multiple excluded scopes when choosing datanodes in NetworkTopology (#1194)


+import org.apache.commons.collections.CollectionUtils;
-      return chooseRandom(ROOT, scope.substring(1), null, null,
+      ArrayList<String> excludedScopes = new ArrayList();
+      excludedScopes.add(scope.substring(1));
+      return chooseRandom(ROOT, excludedScopes, null, null,
-   * @param excludedScope the chosen node cannot be in this range. cannot
+   * @param excludedScopes the chosen node cannot be in these ranges. cannot
-  public Node chooseRandom(String scope, String excludedScope) {
-    return chooseRandom(scope, excludedScope, null, null,
+  public Node chooseRandom(String scope, List<String> excludedScopes) {
+    return chooseRandom(scope, excludedScopes, null, null,
-      return chooseRandom(ROOT, scope.substring(1), excludedNodes, null,
+      ArrayList<String> excludedScopes = new ArrayList();
+      excludedScopes.add(scope.substring(1));
+      return chooseRandom(ROOT, excludedScopes, excludedNodes, null,
-      return chooseRandom(ROOT, scope.substring(1), excludedNodes, null,
+      ArrayList<String> excludedScopes = new ArrayList();
+      excludedScopes.add(scope.substring(1));
+      return chooseRandom(ROOT, excludedScopes, excludedNodes, null,
-   * Randomly choose a leaf node.
-   *
-   * @param scope range from which a node will be chosen, cannot start with ~
-   * @param excludedNodes nodes to be excluded
-   * @param excludedScope excluded node range. Cannot start with ~
-   * @param ancestorGen matters when excludeNodes is not null. It means the
-   * ancestor generation that's not allowed to share between chosen node and the
-   * excludedNodes. For example, if ancestorGen is 1, means chosen node
-   * cannot share the same parent with excludeNodes. If value is 2, cannot
-   * share the same grand parent, and so on. If ancestorGen is 0, then no
-   * effect.
-   *
-   * @return the chosen node
-   */
-  public Node chooseRandom(String scope, String excludedScope,
-      Collection<Node> excludedNodes, int ancestorGen) {
-    return chooseRandom(scope, excludedScope, excludedNodes, null, ancestorGen);
-  }
-
-  /**
-   * @param excludedScope range of nodes to be excluded, cannot start with ~
+   * @param excludedScopes ranges of nodes to be excluded, cannot start with ~
-  public Node chooseRandom(String scope, String excludedScope,
+  public Node chooseRandom(String scope, List<String> excludedScopes,
-    checkExcludedScope(excludedScope);
+    checkExcludedScopes(excludedScopes);
-      return chooseNodeInternal(scope, -1, excludedScope,
+      return chooseNodeInternal(scope, -1, excludedScopes,
-   * @param excludedScope range of nodes to be excluded, cannot start with ~
+   * @param excludedScopes ranges of nodes to be excluded, cannot start with ~
-  public Node getNode(int leafIndex, String scope, String excludedScope,
+  public Node getNode(int leafIndex, String scope, List<String> excludedScopes,
-    checkExcludedScope(excludedScope);
+    checkExcludedScopes(excludedScopes);
-      return chooseNodeInternal(scope, leafIndex, excludedScope,
+      return chooseNodeInternal(scope, leafIndex, excludedScopes,
-      String excludedScope, Collection<Node> excludedNodes, Node affinityNode,
-      int ancestorGen) {
+      List<String> excludedScopes, Collection<Node> excludedNodes,
+      Node affinityNode, int ancestorGen) {
-    // check overlap of excludedScope and finalScope
-    if (excludedScope != null) {
-      // excludeScope covers finalScope
-      if (finalScope.startsWith(excludedScope)) {
-        return null;
-      }
-      // excludeScope and finalScope share nothing
-      if (!excludedScope.startsWith(finalScope)) {
-        excludedScope = null;
+    // check overlap of excludedScopes and finalScope
+    List<String> mutableExcludedScopes = null;
+    if (excludedScopes != null && !excludedScopes.isEmpty()) {
+      mutableExcludedScopes = new ArrayList<>();
+      for (String s: excludedScopes) {
+        // excludeScope covers finalScope
+        if (finalScope.startsWith(s)) {
+          return null;
+        }
+        // excludeScope and finalScope share nothing case
+        if (s.startsWith(finalScope)) {
+          if (!mutableExcludedScopes.stream().anyMatch(
+              e -> s.startsWith(e))) {
+            mutableExcludedScopes.add(s);
+          }
+        }
+
+    // Remove duplicate in excludedNodes
-      // Remove duplicate in excludedNodes
-    // remove duplicate in mutableExNodes and excludedScope, given ancestorGen
-    excludedScope = NetUtils.removeDuplicate(this, mutableExNodes,
-        excludedScope, ancestorGen);
+    // remove duplicate in mutableExNodes and mutableExcludedScopes
+    NetUtils.removeDuplicate(this, mutableExNodes, mutableExcludedScopes,
+        ancestorGen);
-        scopeNode.getNetworkFullPath(), excludedScope, mutableExNodes,
+        scopeNode.getNetworkFullPath(), mutableExcludedScopes, mutableExNodes,
-          scopeNode.getNetworkFullPath(), excludedScope, excludedNodes,
+          scopeNode.getNetworkFullPath(), excludedScopes, excludedNodes,
-      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, excludedScope,
+      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, mutableExcludedScopes,
-      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, excludedScope,
+      ret = ((InnerNode)scopeNode).getLeaf(nodeIndex, mutableExcludedScopes,
-        scopeNode.getNetworkFullPath(), excludedScope, excludedNodes);
+        scopeNode.getNetworkFullPath(), excludedScopes, excludedNodes);
-   * @param excludedScope excluded scope
+   * @param excludedScopes excluded scopes
-  private int getAvailableNodesCount(String scope, String excludedScope,
+  private int getAvailableNodesCount(String scope, List<String> excludedScopes,
-    if (excludedScope != null) {
-      Node excludedScopeNode = getNode(excludedScope);
-      if (excludedScopeNode != null) {
-        if (excludedScope.startsWith(scope)) {
-          excludedCount += excludedScopeNode.getNumOfLeaves();
-        } else if (scope.startsWith(excludedScope)) {
-          return 0;
+    if (excludedScopes != null) {
+      for (String excludedScope: excludedScopes) {
+        Node excludedScopeNode = getNode(excludedScope);
+        if (excludedScopeNode != null) {
+          if (excludedScope.startsWith(scope)) {
+            excludedCount += excludedScopeNode.getNumOfLeaves();
+          } else if (scope.startsWith(excludedScope)) {
+            return 0;
+          }
-  private void checkExcludedScope(String excludedScope) {
-    if (excludedScope != null &&
-        (excludedScope.startsWith(SCOPE_REVERSE_STR))) {
-      throw new IllegalArgumentException("excludedScope " + excludedScope +
-          " cannot start with " + SCOPE_REVERSE_STR);
+  private void checkExcludedScopes(List<String> excludedScopes) {
+    if (!CollectionUtils.isEmpty(excludedScopes)) {
+      excludedScopes.stream().forEach(scope -> {
+        if (scope.startsWith(SCOPE_REVERSE_STR)) {
+          throw new IllegalArgumentException("excludedScope " + scope +
+              " cannot start with " + SCOPE_REVERSE_STR);
+        }
+      });

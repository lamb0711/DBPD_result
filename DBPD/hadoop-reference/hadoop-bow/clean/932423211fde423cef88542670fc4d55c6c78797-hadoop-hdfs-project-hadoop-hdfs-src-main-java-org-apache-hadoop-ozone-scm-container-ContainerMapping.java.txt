HDFS-11469. Ozone: SCM: Container allocation based on node report. Contributed by Xiaoyu Yao.

+import org.apache.hadoop.ozone.OzoneConsts;
+import org.apache.hadoop.scm.ScmConfigKeys;
+import org.apache.hadoop.scm.client.ScmClient;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
-import java.util.Random;
-  private final Random rand;
+  private final ContainerPlacementPolicy placementPolicy;
+  private final long containerSize;
+   * @throws IOException
-  public ContainerMapping(Configuration conf, NodeManager nodeManager,
-      int cacheSizeMB) throws IOException {
+  public ContainerMapping(final Configuration conf,
+      final NodeManager nodeManager, final int cacheSizeMB) throws IOException {
-    options.cacheSize(this.cacheSize * (1024L * 1024L));
+    options.cacheSize(this.cacheSize * OzoneConsts.MB);
-    rand = new Random();
+
+    this.containerSize = OzoneConsts.GB * conf.getInt(
+        ScmConfigKeys.OZONE_SCM_CONTAINER_SIZE_GB,
+        ScmConfigKeys.OZONE_SCM_CONTAINER_SIZE_DEFAULT);
+
+    this.placementPolicy =  createContainerPlacementPolicy(nodeManager, conf);
-   * // TODO : Fix the code to handle multiple nodes.
+   * Create pluggable container placement policy implementation instance.
+   *
+   * @param nodeManager - SCM node manager.
+   * @param conf - configuration.
+   * @return SCM container placement policy implementation instance.
+   */
+  private static ContainerPlacementPolicy createContainerPlacementPolicy(
+      final NodeManager nodeManager, final Configuration conf) {
+    Class<? extends  ContainerPlacementPolicy> implClass =
+        (Class<? extends ContainerPlacementPolicy>) conf.getClass(
+            ScmConfigKeys.OZONE_SCM_CONTAINER_PLACEMENT_IMPL_KEY,
+            SCMContainerPlacementRandom.class);
+
+    try {
+      Constructor<? extends ContainerPlacementPolicy> ctor =
+          implClass.getDeclaredConstructor(NodeManager.class,
+              Configuration.class);
+      return ctor.newInstance(nodeManager, conf);
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(implClass.getName()
+          + " could not be constructed.", e.getCause());
+    } catch (Exception e) {
+    }
+    return null;
+  }
+
+  /**
-   *
-   * @param node datanode on which we will allocate the contianer.
+   * @param nodes - list of datanodes on which we will allocate the container.
+   *              The first of the list will be the leader node.
-  private static Pipeline newPipelineFromNodes(DatanodeID node, String
-      containerName) {
-    Preconditions.checkNotNull(node);
-    String leaderId = node.getDatanodeUuid();
+  private static Pipeline newPipelineFromNodes(final List<DatanodeID> nodes,
+      final String containerName) {
+    Preconditions.checkNotNull(nodes);
+    Preconditions.checkArgument(nodes.size() > 0);
+    String leaderId = nodes.get(0).getDatanodeUuid();
-    pipeline.addMember(node);
+    for (DatanodeID node : nodes) {
+      pipeline.addMember(node);
+    }
-
-  public Pipeline getContainer(String containerName) throws IOException {
+  public Pipeline getContainer(final String containerName) throws IOException {
-  public Pipeline allocateContainer(String containerName) throws IOException {
+  public Pipeline allocateContainer(final String containerName)
+      throws IOException {
+    return allocateContainer(containerName, ScmClient.ReplicationFactor.ONE);
+  }
+
+  /**
+   * Allocates a new container.
+   *
+   * @param containerName - Name of the container.
+   * @param replicationFactor - replication factor of the container.
+   * @return - Pipeline that makes up this container.
+   * @throws IOException
+   */
+  @Override
+  public Pipeline allocateContainer(final String containerName,
+      final ScmClient.ReplicationFactor replicationFactor) throws IOException {
-      DatanodeID id = getDatanodeID();
-      if (id != null) {
-        pipeline = newPipelineFromNodes(id, containerName);
+      List<DatanodeID> datanodes = placementPolicy.chooseDatanodes(
+          replicationFactor.getValue(), containerSize);
+      // TODO: handle under replicated container
+      if (datanodes != null && datanodes.size() > 0) {
+        pipeline = newPipelineFromNodes(datanodes, containerName);
-   * Returns a random Datanode ID from the list of healthy nodes.
-   *
-   * @return Datanode ID
-   * @throws IOException
-   */
-  private DatanodeID getDatanodeID() throws IOException {
-    List<DatanodeID> healthyNodes =
-        nodeManager.getNodes(NodeManager.NODESTATE.HEALTHY);
-
-    if (healthyNodes.size() == 0) {
-      throw new IOException("No healthy node found to allocate container.");
-    }
-
-    int index = rand.nextInt() % healthyNodes.size();
-    return healthyNodes.get(Math.abs(index));
-  }
-
-  /**

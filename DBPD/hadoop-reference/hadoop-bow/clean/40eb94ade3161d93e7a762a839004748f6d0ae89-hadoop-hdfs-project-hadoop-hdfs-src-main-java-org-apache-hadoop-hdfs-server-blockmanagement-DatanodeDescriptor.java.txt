HDFS-5053. NameNode should invoke DataNode APIs to coordinate caching. (Andrew Wang)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1523145 13f79535-47bb-0310-9956-ffa450edef68

+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
+
+  /**
+   * Head of the list of blocks on the datanode
+   */
+  /**
+   * Number of blocks on the datanode
+   */
+
+  /**
+   * Head of the list of cached blocks on the datanode
+   */
+  private volatile BlockInfo cachedBlockList = null;
+  /**
+   * Number of cached blocks on the datanode
+   */
+  private int numCachedBlocks = 0;
+
+  /** A queue of blocks to be cached by this datanode */
+  private BlockQueue<Block> cacheBlocks = new BlockQueue<Block>();
+  /** A set of blocks to be uncached by this datanode */
+  private LightWeightHashSet<Block> blocksToUncache =
+      new LightWeightHashSet<Block>();
+
+   * Add block to the list of cached blocks on the data-node.
+   * @return true if block was successfully added, false if already present
+   */
+  public boolean addCachedBlock(BlockInfo b) {
+    if (!b.addNode(this))
+      return false;
+    // add to the head of the data-node list
+    cachedBlockList = b.listInsert(cachedBlockList, this);
+    numCachedBlocks++;
+    return true;
+  }
+
+  /**
+   * Remove block from the list of cached blocks on the data-node.
+   * @return true if block was successfully removed, false if not present
+   */
+  public boolean removeCachedBlock(BlockInfo b) {
+    cachedBlockList = b.listRemove(cachedBlockList, this);
+    if (b.removeNode(this)) {
+      numCachedBlocks--;
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  /**
+   * Move block to the head of the list of cached blocks on the data-node.
+   * @return the index of the head of the blockList
+   */
+  int moveCachedBlockToHead(BlockInfo b, int curIndex, int headIndex) {
+    cachedBlockList = b.moveBlockToHead(cachedBlockList, this, curIndex,
+        headIndex);
+    return curIndex;
+  }
+
+  /**
+  @VisibleForTesting
+  @VisibleForTesting
+  protected BlockInfo getCachedHead() {
+    return cachedBlockList;
+  }
+
+    this.cachedBlockList = null;
+    this.blocksToUncache.clear();
+    synchronized(blocksToUncache) {
+      this.blocksToUncache.clear();
+      this.cacheBlocks.clear();
+    }
+  public int numCachedBlocks() {
+    return numCachedBlocks;
+  }
+
-  
+
+  public Iterator<BlockInfo> getCachedBlockIterator() {
+    return new BlockIterator(this.cachedBlockList, this);
+  }
+
+   * Store block caching work.
+   */
+  void addBlockToBeCached(Block block) {
+    assert(block != null);
+    cacheBlocks.offer(block);
+  }
+
+  /**
+  
+  /**
+   * Store block uncaching work.
+   */
+  void addBlocksToBeUncached(List<Block> blocklist) {
+    assert(blocklist != null && blocklist.size() > 0);
+    synchronized (blocksToUncache) {
+      for (Block blk : blocklist) {
+        blocksToUncache.add(blk);
+      }
+    }
+  }
+   * The number of pending cache work items
+   */
+  int getNumberOfBlocksToBeCached() {
+    return cacheBlocks.size();
+  }
+
+  /**
-  
+
+  /**
+   * The number of pending uncache work items
+   */
+  int getNumberOfBlocksToBeUncached() {
+    synchronized (blocksToUncache) {
+      return blocksToUncache.size();
+    }
+  }
+
+  public List<Block> getCacheBlocks() {
+    return cacheBlocks.poll(cacheBlocks.size());
+  }
+
+   * Remove up to the maximum number of blocks to be uncached
+   */
+  public Block[] getInvalidateCacheBlocks() {
+    synchronized (blocksToUncache) {
+      Block[] deleteList = blocksToUncache.pollToArray(
+          new Block[blocksToUncache.size()]);
+      return deleteList.length == 0 ? null : deleteList;
+    }
+  }
+
+  /**

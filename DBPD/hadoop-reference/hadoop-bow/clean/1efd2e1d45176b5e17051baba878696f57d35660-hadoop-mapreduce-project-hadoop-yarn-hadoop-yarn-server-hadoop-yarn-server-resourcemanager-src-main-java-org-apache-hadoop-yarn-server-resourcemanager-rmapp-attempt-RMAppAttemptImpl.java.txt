MAPREDUCE-4157. ResourceManager should not kill apps that are well behaved (Jason Lowe via bobby)


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1363067 13f79535-47bb-0310-9956-ffa450edef68

-      .addTransition(RMAppAttemptState.RUNNING, RMAppAttemptState.FINISHED,
+      .addTransition(RMAppAttemptState.RUNNING,
+          EnumSet.of(RMAppAttemptState.FINISHING, RMAppAttemptState.FINISHED),
+      // Transitions from FINISHING State
+      .addTransition(RMAppAttemptState.FINISHING,
+          EnumSet.of(RMAppAttemptState.FINISHING, RMAppAttemptState.FINISHED),
+          RMAppAttemptEventType.CONTAINER_FINISHED,
+          new AMFinishingContainerFinishedTransition())
+      .addTransition(RMAppAttemptState.FINISHING, RMAppAttemptState.FINISHED,
+          RMAppAttemptEventType.EXPIRE,
+          new FinalTransition(RMAppAttemptState.FINISHED))
+      .addTransition(RMAppAttemptState.FINISHING, RMAppAttemptState.FINISHING,
+          EnumSet.of(
+              RMAppAttemptEventType.UNREGISTERED,
+              RMAppAttemptEventType.STATUS_UPDATE,
+              RMAppAttemptEventType.CONTAINER_ALLOCATED,
+              RMAppAttemptEventType.KILL))
+
+      appAttempt.rmContext.getAMFinishingMonitor().unregister(
+          appAttempt.getAppAttemptId());
-  private static final class AMUnregisteredTransition extends FinalTransition {
-
-    public AMUnregisteredTransition() {
-      super(RMAppAttemptState.FINISHED);
-    }
+  private static final class AMUnregisteredTransition implements
+      MultipleArcTransition<RMAppAttemptImpl, RMAppAttemptEvent, RMAppAttemptState> {
-    public void transition(RMAppAttemptImpl appAttempt,
+    public RMAppAttemptState transition(RMAppAttemptImpl appAttempt,
+      ApplicationAttemptId appAttemptId = appAttempt.getAppAttemptId();
+
+      appAttempt.rmContext.getAMLivelinessMonitor().unregister(appAttemptId);
+
+      // Remove the AppAttempt from the ApplicationTokenSecretManager
+      appAttempt.rmContext.getApplicationTokenSecretManager()
+        .applicationMasterFinished(appAttemptId);
+
+      appAttempt.progress = 1.0f;
-      // Tell the app and the scheduler
-      super.transition(appAttempt, event);
+      // Tell the app
+      if (appAttempt.getSubmissionContext().getUnmanagedAM()) {
+        // Unmanaged AMs have no container to wait for, so they skip
+        // the FINISHING state and go straight to FINISHED.
+        new FinalTransition(RMAppAttemptState.FINISHED).transition(
+            appAttempt, event);
+        return RMAppAttemptState.FINISHED;
+      }
+      appAttempt.rmContext.getAMFinishingMonitor().register(appAttemptId);
+      ApplicationId applicationId =
+          appAttempt.getAppAttemptId().getApplicationId();
+      appAttempt.eventHandler.handle(
+          new RMAppEvent(applicationId, RMAppEventType.ATTEMPT_FINISHING));
+      return RMAppAttemptState.FINISHING;
+  private static final class AMFinishingContainerFinishedTransition
+      implements
+      MultipleArcTransition<RMAppAttemptImpl, RMAppAttemptEvent, RMAppAttemptState> {
+
+    @Override
+    public RMAppAttemptState transition(RMAppAttemptImpl appAttempt,
+        RMAppAttemptEvent event) {
+
+      RMAppAttemptContainerFinishedEvent containerFinishedEvent
+        = (RMAppAttemptContainerFinishedEvent) event;
+      ContainerStatus containerStatus =
+          containerFinishedEvent.getContainerStatus();
+
+      // Is this container the ApplicationMaster container?
+      if (appAttempt.masterContainer.getId().equals(
+          containerStatus.getContainerId())) {
+        new FinalTransition(RMAppAttemptState.FINISHED).transition(
+            appAttempt, containerFinishedEvent);
+        return RMAppAttemptState.FINISHED;
+      }
+
+      // Normal container.
+      appAttempt.justFinishedContainers.add(containerStatus);
+      return RMAppAttemptState.FINISHING;
+    }
+  }
+

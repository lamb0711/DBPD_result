HDDS-1491. Ozone KeyInputStream seek() should not read the chunk file. (#795)


+import com.google.common.annotations.VisibleForTesting;
+  // ChunkIndex points to the index current chunk in the buffers or the the
+  // index of chunk which will be read next into the buffers in
+  // readChunkFromContainer().
+  // ChunkIndexOfCurrentBuffer points to the index of chunk read into the
+  // buffers or index of the last chunk in the buffers. It is updated only
+  // when a new chunk is read from container into the buffers.
+  private int chunkIndexOfCurrentBuffer;
+  private long bufferPosition;
+   * @param initialPosition the initial position of the stream pointer. This
+   *                        position is seeked now if the up-stream was seeked
+   *                        before this was created.
-      boolean verifyChecksum) {
+      boolean verifyChecksum, long initialPosition) throws IOException {
-    this.chunkIndex = -1;
+    this.chunkIndex = 0;
+    this.chunkIndexOfCurrentBuffer = -1;
+    this.bufferPosition = -1;
+    if (initialPosition > 0) {
+      // The stream was seeked to a position before the stream was
+      // initialized. So seeking to the position now.
+      seek(initialPosition);
+    }
-  private boolean blockStreamEOF() {
+  protected boolean blockStreamEOF() {
+      if (!buffersAllocated()) {
+        // The current chunk at chunkIndex has not been read from the
+        // container. Read the chunk and put the data into buffers.
+        readChunkFromContainer();
+      }
+        // Read the next chunk in the block.
+        chunkIndex += 1;
-  private boolean buffersHaveData() {
-    boolean hasData = false;
-
+  private boolean buffersAllocated() {
+    return true;
+  }
-    while (bufferIndex < (buffers.size())) {
-      if (buffers.get(bufferIndex).hasRemaining()) {
-        // current buffer has data
-        hasData = true;
-        break;
-      } else {
-        if (buffersRemaining()) {
-          // move to next available buffer
-          ++bufferIndex;
-          Preconditions.checkState(bufferIndex < buffers.size());
-        } else {
-          // no more buffers remaining
+  private boolean buffersHaveData() {
+    boolean hasData = false;
+
+    if (buffersAllocated()) {
+      while (bufferIndex < (buffers.size())) {
+        if (buffers.get(bufferIndex).hasRemaining()) {
+          // current buffer has data
+          hasData = true;
+        } else {
+          if (buffersRemaining()) {
+            // move to next available buffer
+            ++bufferIndex;
+            Preconditions.checkState(bufferIndex < buffers.size());
+          } else {
+            // no more buffers remaining
+            break;
+          }
-    return (chunkIndex < (chunks.size() - 1));
+    // Check if more chunks are remaining in the stream after chunkIndex
+    if (chunkIndex < (chunks.size() - 1)) {
+      return true;
+    }
+    // ChunkIndex is the last chunk in the stream. Check if this chunk has
+    // been read from container or not. Return true if chunkIndex has not
+    // been read yet and false otherwise.
+    return chunkIndexOfCurrentBuffer != chunkIndex;
-    // On every chunk read chunkIndex should be increased so as to read the
-    // next chunk
-    chunkIndex += 1;
-    XceiverClientReply reply;
-    ReadChunkResponseProto readChunkResponse = null;
+    // Read the chunk at chunkIndex
-    List<DatanodeDetails> dnList = xceiverClient.getPipeline().getNodes();
+    List<DatanodeDetails> dnList = getDatanodeList();
-      try {
-        reply = ContainerProtocolCalls
-            .readChunk(xceiverClient, chunkInfo, blockID, traceID, excludeDns);
-        ContainerProtos.ContainerCommandResponseProto response;
-        response = reply.getResponse().get();
-        ContainerProtocolCalls.validateContainerResponse(response);
-        readChunkResponse = response.getReadChunk();
-      } catch (IOException e) {
-        if (e instanceof StorageContainerException) {
-          throw e;
-        }
-        throw new IOException("Unexpected OzoneException: " + e.toString(), e);
-      } catch (ExecutionException | InterruptedException e) {
-        throw new IOException(
-            "Failed to execute ReadChunk command for chunk  " + chunkInfo
-                .getChunkName(), e);
-      }
-      byteString = readChunkResponse.getData();
+      List<DatanodeDetails> dnListFromReadChunkCall = new ArrayList<>();
+      byteString = readChunk(chunkInfo, excludeDns, dnListFromReadChunkCall);
-        excludeDns.addAll(reply.getDatanodes());
+        excludeDns.addAll(dnListFromReadChunkCall);
+    chunkIndexOfCurrentBuffer = chunkIndex;
+
+    // The bufferIndex and position might need to be adjusted if seek() was
+    // called on the stream before. This needs to be done so that the buffer
+    // position can be advanced to the 'seeked' position.
+    adjustBufferIndex();
+  }
+
+  /**
+   * Send RPC call to get the chunk from the container.
+   */
+  @VisibleForTesting
+  protected ByteString readChunk(final ChunkInfo chunkInfo,
+      List<DatanodeDetails> excludeDns, List<DatanodeDetails> dnListFromReply)
+      throws IOException {
+    XceiverClientReply reply;
+    ReadChunkResponseProto readChunkResponse = null;
+    try {
+      reply = ContainerProtocolCalls
+          .readChunk(xceiverClient, chunkInfo, blockID, traceID, excludeDns);
+      ContainerProtos.ContainerCommandResponseProto response;
+      response = reply.getResponse().get();
+      ContainerProtocolCalls.validateContainerResponse(response);
+      readChunkResponse = response.getReadChunk();
+      dnListFromReply.addAll(reply.getDatanodes());
+    } catch (IOException e) {
+      if (e instanceof StorageContainerException) {
+        throw e;
+      }
+      throw new IOException("Unexpected OzoneException: " + e.toString(), e);
+    } catch (ExecutionException | InterruptedException e) {
+      throw new IOException(
+          "Failed to execute ReadChunk command for chunk  " + chunkInfo
+              .getChunkName(), e);
+    }
+    return readChunkResponse.getData();
+  }
+
+  @VisibleForTesting
+  protected List<DatanodeDetails> getDatanodeList() {
+    return xceiverClient.getPipeline().getNodes();
-    if (chunkIndex == -1) {
-      chunkIndex = Arrays.binarySearch(chunkOffset, pos);
-    } else if (pos < chunkOffset[chunkIndex]) {
+
+    if (pos < chunkOffset[chunkIndex]) {
-    // adjust chunkIndex so that readChunkFromContainer reads the correct chunk
-    chunkIndex -= 1;
-    readChunkFromContainer();
-    adjustBufferIndex(pos);
+
+    // The bufferPosition should be adjusted to account for the chunk offset
+    // of the chunk the the pos actually points to.
+    bufferPosition = pos - chunkOffset[chunkIndex];
+
+    // Check if current buffers correspond to the chunk index being seeked
+    // and if the buffers have any data.
+    if (chunkIndex == chunkIndexOfCurrentBuffer && buffersAllocated()) {
+      // Position the buffer to the seeked position.
+      adjustBufferIndex();
+    } else {
+      // Release the current buffers. The next readChunkFromContainer will
+      // read the required chunk and position the buffer to the seeked
+      // position.
+      releaseBuffers();
+    }
-  private void adjustBufferIndex(long pos) {
-    long tempOffest = chunkOffset[chunkIndex];
+  private void adjustBufferIndex() {
+    if (bufferPosition == -1) {
+      // The stream has not been seeked to a position. No need to adjust the
+      // buffer Index and position.
+      return;
+    }
+    // The bufferPosition is w.r.t the buffers for current chunk.
+    // Adjust the bufferIndex and position to the seeked position.
+    long tempOffest = 0;
-      if (pos - tempOffest >= buffers.get(i).capacity()) {
+      if (bufferPosition - tempOffest >= buffers.get(i).capacity()) {
-    buffers.get(bufferIndex).position((int) (pos - tempOffest));
+    buffers.get(bufferIndex).position((int) (bufferPosition - tempOffest));
+    // Reset the bufferPosition as the seek() operation has been completed.
+    bufferPosition = -1;
-    if (chunkIndex == -1) {
-      // no data consumed yet, a new stream OR after seek
-      return 0;
-    }
+    // position = chunkOffset of current chunk (at chunkIndex) + position of
+    // the buffer corresponding to the chunk.
+    long bufferPos = 0;
-    if (blockStreamEOF()) {
+    if (bufferPosition >= 0) {
+      // seek has been called but the buffers were empty. Hence, the buffer
+      // position will be advanced after the buffers are filled.
+      // We return the chunkOffset + bufferPosition here as that will be the
+      // position of the buffer pointer after reading the chunk file.
+      bufferPos = bufferPosition;
+
+    } else if (blockStreamEOF()) {
-      return chunkOffset[chunkIndex] + chunks.get(chunkIndex).getLen();
+      bufferPos = chunks.get(chunkIndex).getLen();
+
+    } else if (buffersAllocated()) {
+      // get position from available buffers of current chunk
+      bufferPos = buffers.get(bufferIndex).position();
+
-    // get position from available buffers of current chunk
-    return chunkOffset[chunkIndex] + buffers.get(bufferIndex).position();
+    return chunkOffset[chunkIndex] + bufferPos;
+
+  @VisibleForTesting
+  protected int getChunkIndex() {
+    return chunkIndex;
+  }

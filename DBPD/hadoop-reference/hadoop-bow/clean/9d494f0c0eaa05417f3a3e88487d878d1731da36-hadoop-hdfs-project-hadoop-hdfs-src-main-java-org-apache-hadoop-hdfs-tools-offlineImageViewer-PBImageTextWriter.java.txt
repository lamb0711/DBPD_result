HDFS-9721. Allow Delimited PB OIV tool to run upon fsimage that contains INodeReference. (Xiao Chen via lei)

+import com.google.common.collect.ImmutableList;
+    @Override
-      Preconditions.checkState(parent != null,
-          "Can not find parent directory for INode: %s", inode);
+      if (parent == null) {
+        // The inode is an INodeReference, which is generated from snapshot.
+        // For delimited oiv tool, no need to print out metadata in snapshots.
+        PBImageTextWriter.ignoreSnapshotName(inode);
+      }
-      Preconditions.checkState(bytes != null && bytes.length == 8,
-          "Can not find parent directory for inode %s, "
-              + "fsimage might be corrupted", inode);
+      if (bytes == null) {
+        // The inode is an INodeReference, which is generated from snapshot.
+        // For delimited oiv tool, no need to print out metadata in snapshots.
+        PBImageTextWriter.ignoreSnapshotName(inode);
+      }
+      if (bytes.length != 8) {
+        throw new IOException(
+            "bytes array length error. Actual length is " + bytes.length);
+      }
-        if (parent != INodeId.ROOT_INODE_ID) {
-          Preconditions.checkState(bytes != null,
-              "Can not find parent directory for inode %s, "
-                  + ", the fsimage might be corrupted.", parent);
+        if (parent != INodeId.ROOT_INODE_ID && bytes == null) {
+          // The parent is an INodeReference, which is generated from snapshot.
+          // For delimited oiv tool, no need to print out metadata in snapshots.
+          PBImageTextWriter.ignoreSnapshotName(parent);
+    out.flush();
+  /**
+   * Get text output for the header line.
+   */
+  abstract protected String getHeader();
+
+      ImmutableList<Long> refIdList = null;
+          LOG.info("Loading string table");
+        case INODE_REFERENCE:
+          // Load INodeReference so that all INodes can be processed.
+          // Snapshots are not handled and will just be ignored for now.
+          LOG.info("Loading inode references");
+          refIdList = FSImageLoader.loadINodeReferenceSection(is);
+          break;
-      loadINodeDirSection(fin, sections, summary, conf);
+      loadINodeDirSection(fin, sections, summary, conf, refIdList);
+    out.println(getHeader());
-      FileSummary summary, Configuration conf)
+      FileSummary summary, Configuration conf, List<Long> refIdList)
-        buildNamespace(is);
+        buildNamespace(is, refIdList);
-  private void buildNamespace(InputStream in) throws IOException {
+  private void buildNamespace(InputStream in, List<Long> refIdList)
+      throws IOException {
-      // Referred INode is not support for now.
-      Preconditions.checkState(e.getRefChildrenCount() == 0);
+      for (int i = e.getChildrenCount();
+           i < e.getChildrenCount() + e.getRefChildrenCount(); i++) {
+        int refId = e.getRefChildren(i - e.getChildrenCount());
+        metadataMap.putDirChild(parentId, refIdList.get(refId));
+      }
+    long ignored = 0;
+    long ignoredSnapshots = 0;
-      String parentPath = metadataMap.getParentPath(p.getId());
-      out.println(getEntry(parentPath, p));
+      try {
+        String parentPath = metadataMap.getParentPath(p.getId());
+        out.println(getEntry(parentPath, p));
+      } catch (IOException ioe) {
+        ignored++;
+        if (!(ioe instanceof IgnoreSnapshotException)) {
+          LOG.warn("Exception caught, ignoring node:{}", p.getId(), ioe);
+        } else {
+          ignoredSnapshots++;
+          if (LOG.isDebugEnabled()) {
+            LOG.debug("Exception caught, ignoring node:{}.", p.getId(), ioe);
+          }
+        }
+      }
+    if (ignored > 0) {
+      LOG.warn("Ignored {} nodes, including {} in snapshots. Please turn on"
+              + " debug log for details", ignored, ignoredSnapshots);
+    }
+
+  static void ignoreSnapshotName(long inode) throws IOException {
+    // Ignore snapshots - we want the output similar to -ls -R.
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("No snapshot name found for inode {}", inode);
+    }
+    throw new IgnoreSnapshotException();
+  }

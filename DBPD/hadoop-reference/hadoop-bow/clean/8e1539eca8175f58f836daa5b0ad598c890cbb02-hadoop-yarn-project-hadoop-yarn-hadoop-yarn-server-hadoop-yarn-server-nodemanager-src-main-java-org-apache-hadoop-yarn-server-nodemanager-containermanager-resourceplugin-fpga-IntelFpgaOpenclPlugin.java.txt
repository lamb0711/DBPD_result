YARN-9266. General improvements in IntelFpgaOpenclPlugin. Contributed by Peter Bacsko.

+import org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources.fpga.FpgaResourceAllocator.FpgaDevice;
-import java.util.*;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Function;
- * 1. It uses Intel's toolchain "aocl" to discover devices/reprogram IP to the device
- *    before container launch to achieve a quickest reprogramming path
+ * 1. It uses Intel's toolchain "aocl" to discover devices/reprogram IP
+ *    to the device before container launch to achieve a quickest
+ *    reprogramming path
-  public static final Logger LOG = LoggerFactory.getLogger(
+  private static final Logger LOG = LoggerFactory.getLogger(
-  private Configuration conf;
-  protected static final String DEFAULT_BINARY_NAME = "aocl";
+  private static final String DEFAULT_BINARY_NAME = "aocl";
-  protected static final String ALTERAOCLSDKROOT_NAME = "ALTERAOCLSDKROOT";
+  private static final String ALTERAOCLSDKROOT_NAME = "ALTERAOCLSDKROOT";
+
+  private Function<String, String> envProvider = System::getenv;
-  // a mapping of major:minor number to acl0-31
-  private Map<String, String> aliasMap;
+  @VisibleForTesting
+  void setInnerShellExecutor(InnerShellExecutor shellExecutor) {
+    this.shell = shellExecutor;
+  }
+
+  @VisibleForTesting
+  String getPathToExecutable() {
+    return pathToExecutable;
+  }
+
+  @VisibleForTesting
+  void setEnvProvider(Function<String, String> envProvider) {
+    this.envProvider = envProvider;
+  }
-  public String getDefaultBinaryName() {
-    return DEFAULT_BINARY_NAME;
-  }
-
-    return System.getenv(ALTERAOCLSDKROOT_NAME);
-  }
-
-  public static String getDefaultPathEnvName() {
-    return ALTERAOCLSDKROOT_NAME;
-  }
-
-  @VisibleForTesting
-  public String getPathToExecutable() {
-    return pathToExecutable;
-  }
-
-  public void setPathToExecutable(String pathToExecutable) {
-    this.pathToExecutable = pathToExecutable;
-  }
-
-  @VisibleForTesting
-  public void setShell(InnerShellExecutor shell) {
-    this.shell = shell;
-  }
-
-  public Map<String, String> getAliasMap() {
-    return aliasMap;
+    return envProvider.apply(ALTERAOCLSDKROOT_NAME);
-   * Check the Intel FPGA for OpenCL toolchain
+   * Check the Intel FPGA for OpenCL toolchain.
-  public boolean initPlugin(Configuration conf) {
-    this.aliasMap = new HashMap<>();
-    if (this.initialized) {
+  public boolean initPlugin(Configuration config) {
+    if (initialized) {
-    String pluginDefaultBinaryName = getDefaultBinaryName();
-    String pathToExecutable = conf.get(YarnConfiguration.NM_FPGA_PATH_TO_EXEC,
-        "");
-    if (pathToExecutable.isEmpty()) {
-      pathToExecutable = pluginDefaultBinaryName;
-    }
+    String pluginDefaultBinaryName = DEFAULT_BINARY_NAME;
+    String executable = config.get(YarnConfiguration.NM_FPGA_PATH_TO_EXEC,
+        pluginDefaultBinaryName);
+
-    File binaryPath = new File(pathToExecutable);
+    File binaryPath = new File(executable);
-      pathToExecutable = pluginDefaultBinaryName;
+      executable = pluginDefaultBinaryName;
-        LOG.warn("Failed to find FPGA discoverer executable from system environment " +
-            getDefaultPathEnvName()+
+        LOG.warn("Failed to find FPGA discoverer executable from system "
+            + " environment " + ALTERAOCLSDKROOT_NAME +
-        binaryPath = new File(pluginDefaultPreferredPath + "/bin", pluginDefaultBinaryName);
+        binaryPath = new File(pluginDefaultPreferredPath + "/bin",
+            pluginDefaultBinaryName);
-          pathToExecutable = binaryPath.getAbsolutePath();
+          executable = binaryPath.getAbsolutePath();
-              pathToExecutable);
+              executable);
-          pathToExecutable = pluginDefaultBinaryName;
+          executable = pluginDefaultBinaryName;
-              pluginDefaultPreferredPath + ", file doesn't exists! Use default binary" + pathToExecutable);
+              pluginDefaultPreferredPath +
+              ", file doesn't exists! Use default binary" + executable);
-    setPathToExecutable(pathToExecutable);
+
+    pathToExecutable = executable;
+
-      this.initialized = false;
+      initialized = false;
-      this.initialized = true;
+      initialized = true;
-    return this.initialized;
+    return initialized;
-    parseDiagnoseInfo(output, list);
+
+    list = AoclDiagnosticOutputParser.parseDiagnosticOutput(output,
+        shell, getFpgaType());
+
+  /**
+   *  Helper class to run aocl diagnose & determine major/minor numbers.
+   */
-        output = Integer.parseInt(strs[0], 16) + ":" + Integer.parseInt(strs[1], 16);
+        output = Integer.parseInt(strs[0], 16) + ":" +
+            Integer.parseInt(strs[1], 16);
-        String msg =
-            "Failed to get major-minor number from reading /dev/" + devName;
-        LOG.warn(msg);
-        LOG.debug("Command output:" + shexec.getOutput() + ", exit code:" +
-            shexec.getExitCode());
+        LOG.warn("Failed to get major-minor number from reading /dev/" +
+            devName);
+        LOG.warn("Command output:" + shexec.getOutput() + ", exit code: " +
+            shexec.getExitCode(), e);
-          new String[]{binary, "diagnose"});
+          new String[]{binary, "diagnose"}, null, null, timeout);
-
-  }
-
-  /**
-   * One real sample output of Intel FPGA SDK 17.0's "aocl diagnose" is as below:
-   * "
-   * aocl diagnose: Running diagnose from /home/fpga/intelFPGA_pro/17.0/hld/board/nalla_pcie/linux64/libexec
-   *
-   * ------------------------- acl0 -------------------------
-   * Vendor: Nallatech ltd
-   *
-   * Phys Dev Name  Status   Information
-   *
-   * aclnalla_pcie0Passed   nalla_pcie (aclnalla_pcie0)
-   *                        PCIe dev_id = 2494, bus:slot.func = 02:00.00, Gen3 x8
-   *                        FPGA temperature = 54.4 degrees C.
-   *                        Total Card Power Usage = 31.7 Watts.
-   *                        Device Power Usage = 0.0 Watts.
-   *
-   * DIAGNOSTIC_PASSED
-   * ---------------------------------------------------------
-   * "
-   *
-   * While per Intel's guide, the output(should be outdated or prior SDK version's) is as below:
-   *
-   * "
-   * aocl diagnose: Running diagnostic from ALTERAOCLSDKROOT/board/&lt;board_name&gt;/
-   * &lt;platform&gt;/libexec
-   * Verified that the kernel mode driver is installed on the host machine.
-   * Using board package from vendor: &lt;board_vendor_name&gt;
-   * Querying information for all supported devices that are installed on the host
-   * machine ...
-   *
-   * device_name Status Information
-   *
-   * acl0 Passed &lt;descriptive_board_name&gt;
-   *             PCIe dev_id = &lt;device_ID&gt;, bus:slot.func = 02:00.00,
-   *               at Gen 2 with 8 lanes.
-   *             FPGA temperature=43.0 degrees C.
-   * acl1 Passed &lt;descriptive_board_name&gt;
-   *             PCIe dev_id = &lt;device_ID&gt;, bus:slot.func = 03:00.00,
-   *               at Gen 2 with 8 lanes.
-   *             FPGA temperature = 35.0 degrees C.
-   *
-   * Found 2 active device(s) installed on the host machine, to perform a full
-   * diagnostic on a specific device, please run aocl diagnose &lt;device_name&gt;
-   *
-   * DIAGNOSTIC_PASSED
-   * "
-   * But this method only support the first output
-   * */
-  public void parseDiagnoseInfo(String output, List<FpgaResourceAllocator.FpgaDevice> list) {
-    if (output.contains("DIAGNOSTIC_PASSED")) {
-      Matcher headerStartMatcher = Pattern.compile("acl[0-31]").matcher(output);
-      Matcher headerEndMatcher = Pattern.compile("(?i)DIAGNOSTIC_PASSED").matcher(output);
-      int sectionStartIndex;
-      int sectionEndIndex;
-      String aliasName;
-      while (headerStartMatcher.find()) {
-        sectionStartIndex = headerStartMatcher.end();
-        String section = null;
-        aliasName = headerStartMatcher.group();
-        while (headerEndMatcher.find(sectionStartIndex)) {
-          sectionEndIndex = headerEndMatcher.start();
-          section = output.substring(sectionStartIndex, sectionEndIndex);
-          break;
-        }
-        if (null == section) {
-          LOG.warn("Unsupported diagnose output");
-          return;
-        }
-        // devName, \(.*\)
-        // busNum, bus:slot.func\s=\s.*,
-        // FPGA temperature\s=\s.*
-        // Total\sCard\sPower\sUsage\s=\s.*
-        String[] fieldRegexes = new String[]{"\\(.*\\)\n", "(?i)bus:slot.func\\s=\\s.*,",
-            "(?i)FPGA temperature\\s=\\s.*", "(?i)Total\\sCard\\sPower\\sUsage\\s=\\s.*"};
-        String[] fields = new String[4];
-        String tempFieldValue;
-        for (int i = 0; i < fieldRegexes.length; i++) {
-          Matcher fieldMatcher = Pattern.compile(fieldRegexes[i]).matcher(section);
-          if (!fieldMatcher.find()) {
-            LOG.warn("Couldn't find " + fieldRegexes[i] + " pattern");
-            fields[i] = "";
-            continue;
-          }
-          tempFieldValue = fieldMatcher.group().trim();
-          if (i == 0) {
-            // special case for Device name
-            fields[i] = tempFieldValue.substring(1, tempFieldValue.length() - 1);
-          } else {
-            String ss = tempFieldValue.split("=")[1].trim();
-            fields[i] = ss.substring(0, ss.length() - 1);
-          }
-        }
-        String majorMinorNumber = this.shell.getMajorAndMinorNumber(fields[0]);
-        if (null != majorMinorNumber) {
-          String[] mmn = majorMinorNumber.split(":");
-          this.aliasMap.put(majorMinorNumber, aliasName);
-          list.add(new FpgaResourceAllocator.FpgaDevice(getFpgaType(),
-              Integer.parseInt(mmn[0]),
-              Integer.parseInt(mmn[1]), null,
-              fields[0], aliasName, fields[1], fields[2], fields[3]));
-        }
-      }// end while
-    }// end if
-  public String downloadIP(String id, String dstDir, Map<Path, List<String>> localizedResources) {
+  public String retrieveIPfilePath(String id, String dstDir,
+      Map<Path, List<String>> localizedResources) {
-    String r = "";
-    Path path;
-    LOG.info("Got environment: " + id + ", search IP file in localized resources");
+    String ipFilePath = null;
+
+    LOG.info("Got environment: " + id +
+        ", search IP file in localized resources");
-      return r;
+      return null;
+
-      for (Map.Entry<Path, List<String>> resourceEntry :
-          localizedResources.entrySet()) {
-        path = resourceEntry.getKey();
-        LOG.debug("Check:" + path.toUri().toString());
-        if (path.getName().toLowerCase().contains(id.toLowerCase()) && path.getName().endsWith(".aocx")) {
-          r = path.toUri().toString();
-          LOG.debug("Found: " + r);
-          break;
-        }
+      Optional<Path> aocxPath = localizedResources
+          .keySet()
+          .stream()
+          .filter(path -> matchesIpid(path, id))
+          .findFirst();
+
+      if (aocxPath.isPresent()) {
+        ipFilePath = aocxPath.get().toUri().toString();
+        LOG.debug("Found: " + ipFilePath);
-    return r;
+
+    return ipFilePath;
+  }
+
+  private boolean matchesIpid(Path p, String id) {
+    return p.getName().toLowerCase().equals(id.toLowerCase())
+        && p.getName().endsWith(".aocx");
-   * It's ok for the offline "aocl program" failed because the application will always invoke API to program
-   * The reason we do offline reprogramming is to make the application's program process faster
+   * It's ok for the offline "aocl program" failed because the application will
+   * always invoke API to program.
+   * The reason we do offline reprogramming is to make the application's
+   * program process faster.
-   * @param majorMinorNumber major:minor string
-   * @return True or False
+   * @param device Fpga device object which represents the card
+   * @return false if programming the card fails
-  public boolean configureIP(String ipPath, String majorMinorNumber) {
+  public boolean configureIP(String ipPath, FpgaDevice device) {
-    // we need a mapping of "major:minor" to "acl0" to issue command "aocl program <acl0> <ipPath>"
+    // we need a mapping of "major:minor" to "acl0" to
+    // issue command "aocl program <acl0> <ipPath>"
-    aclName = this.aliasMap.get(majorMinorNumber);
+    aclName = device.getAliasDevName();
-        LOG.info("Intel aocl program " + ipPath + " to " + aclName + " successfully");
+        LOG.info("Intel aocl program " + ipPath + " to " +
+            aclName + " successfully");
+        LOG.error("Device programming failed, aocl output is:");
+        LOG.error(shexec.getOutput());
-      LOG.error("Intel aocl program " + ipPath + " to " + aclName + " failed!");
-      e.printStackTrace();
+      LOG.error("Intel aocl program " + ipPath + " to " +
+          aclName + " failed!", e);
+      LOG.error("Aocl output: " + shexec.getOutput());
-
-  @Override
-  public void setConf(Configuration conf) {
-    this.conf = conf;
-  }
-
-  @Override
-  public Configuration getConf() {
-    return this.conf;
-  }

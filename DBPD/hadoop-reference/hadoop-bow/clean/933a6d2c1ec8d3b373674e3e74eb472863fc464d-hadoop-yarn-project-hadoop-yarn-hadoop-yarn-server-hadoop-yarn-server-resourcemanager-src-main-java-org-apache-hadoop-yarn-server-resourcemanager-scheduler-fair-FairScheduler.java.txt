YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68

-    return this.conf;
+    return conf;
-    return this.queueMgr;
+    return queueMgr;
-  protected void update() {
-    synchronized (this) {
-      queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file
-      updateRunnability(); // Set job runnability based on user/queue limits
-      updatePreemptionVariables(); // Determine if any queues merit preemption
+  protected synchronized void update() {
+    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file
+    updateRunnability(); // Set job runnability based on user/queue limits
+    updatePreemptionVariables(); // Determine if any queues merit preemption
-      // Update demands of apps and queues
-      for (FSQueue queue: queueMgr.getQueues()) {
-        queue.getQueueSchedulable().updateDemand();
-      }
-
-      // Compute fair shares based on updated demands
-      List<FSQueueSchedulable> queueScheds = this.getQueueSchedulables();
-      SchedulingAlgorithms.computeFairShares(
-          queueScheds, clusterCapacity);
-
-      // Update queue metrics for this queue
-      for (FSQueueSchedulable sched : queueScheds) {
-        sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());
-      }
-
-      // Use the computed shares to assign shares within each queue
-      for (FSQueue queue: queueMgr.getQueues()) {
-        queue.getQueueSchedulable().redistributeShare();
-      }
-
-      // Update recorded capacity of root queue (child queues are updated
-      // when fair share is calculated).
-      rootMetrics.setAvailableResourcesToQueue(clusterCapacity);
+    // Update demands of apps and queues
+    for (FSQueue queue: queueMgr.getQueues()) {
+      queue.getQueueSchedulable().updateDemand();
+
+    // Compute fair shares based on updated demands
+    List<FSQueueSchedulable> queueScheds = getQueueSchedulables();
+    SchedulingAlgorithms.computeFairShares(
+        queueScheds, clusterCapacity);
+
+    // Update queue metrics for this queue
+    for (FSQueueSchedulable sched : queueScheds) {
+      sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());
+    }
+
+    // Use the computed shares to assign shares within each queue
+    for (FSQueue queue: queueMgr.getQueues()) {
+      queue.getQueueSchedulable().redistributeShare();
+    }
+
+    // Update recorded capacity of root queue (child queues are updated
+    // when fair share is calculated).
+    rootMetrics.setAvailableResourcesToQueue(clusterCapacity);
-   *
-   * This method computes and logs the number of tasks we want to preempt even
-   * if preemption is disabled, for debugging purposes.
-    if (!preemptionEnabled)
+    if (!preemptionEnabled) {
+    }
-    if (curTime - lastPreemptCheckTime < preemptionInterval)
+    if (curTime - lastPreemptCheckTime < preemptionInterval) {
+    }
-    if (scheds.isEmpty() || Resources.equals(toPreempt, Resources.none()))
+    if (scheds.isEmpty() || Resources.equals(toPreempt, Resources.none())) {
+    }
-        this.completedContainer(container, status, RMContainerEventType.KILL);
+        completedContainer(container, status, RMContainerEventType.KILL);
-    return this.rmContext.getContainerTokenSecretManager();
+    return rmContext.getContainerTokenSecretManager();
-    return this.minimumAllocation;
+    return minimumAllocation;
-    return this.maximumAllocation;
+    return maximumAllocation;
-    return this.nodeLocalityThreshold;
+    return nodeLocalityThreshold;
-    return this.rackLocalityThreshold;
+    return rackLocalityThreshold;
-    return this.clusterCapacity;
+    return clusterCapacity;
-    return this.clock;
+    return clock;
-    FSQueue queue = this.queueMgr.getQueue(queueName);
+    FSQueue queue = queueMgr.getQueue(queueName);
-            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),
+            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),
-    FSQueue queue = this.queueMgr.getQueue(application.getQueue().getQueueName());
-    queue.removeJob(application);
+    FSQueue queue = queueMgr.getQueue(application.getQueue().getQueueName());
+    queue.removeApp(application);
-    this.nodes.put(node.getNodeID(), new FSSchedulerNode(node));
+    nodes.put(node.getNodeID(), new FSSchedulerNode(node));
-    FSSchedulerNode node = this.nodes.get(rmNode.getNodeID());
+    FSSchedulerNode node = nodes.get(rmNode.getNodeID());
-    this.nodes.remove(rmNode.getNodeID());
+    nodes.remove(rmNode.getNodeID());
-
-
-        if(LOG.isDebugEnabled()) {
+        if (LOG.isDebugEnabled()) {
-      if(LOG.isDebugEnabled()) {
+      if (LOG.isDebugEnabled()) {
-        List<FSQueueSchedulable> scheds = this.getQueueSchedulables();
+        List<FSQueueSchedulable> scheds = getQueueSchedulables();
-    if (!this.applications.containsKey(appAttemptId)) {
+    if (!applications.containsKey(appAttemptId)) {
-    return new SchedulerAppReport(this.applications.get(appAttemptId));
+    return new SchedulerAppReport(applications.get(appAttemptId));
-    {
-    }
-    break;
+      break;
-    {
-    }
-    break;
+      break;
-    {
-      this.nodeUpdate(nodeUpdatedEvent.getRMNode(),
+      nodeUpdate(nodeUpdatedEvent.getRMNode(),
-    }
-    break;
+      break;
-    {
-    }
-    break;
+      break;
-    {
-      this.removeApplication(appRemovedEvent.getApplicationAttemptID(),
+      removeApplication(appRemovedEvent.getApplicationAttemptID(),
-    }
-    break;
+      break;
-    {
-    }
-    break;
+      break;
-    if (!this.initialized) {
+    if (!initialized) {
-      this.rootMetrics = QueueMetrics.forQueue("root", null, true, conf);
+      rootMetrics = QueueMetrics.forQueue("root", null, true, conf);
-    return this.nodes.size();
+    return nodes.size();

YARN-7921. Transform a PlacementConstraint to a string expression. Contributed by Weiwei Yang.

+import java.util.stream.Collectors;
+import java.util.Iterator;
+  @Override
+  public String toString() {
+    return this.constraintExpr.toString();
+  }
+
+    public String toString() {
+      int max = getMaxCardinality();
+      int min = getMinCardinality();
+      List<String> targetExprList = getTargetExpressions().stream()
+          .map(TargetExpression::toString).collect(Collectors.toList());
+      List<String> targetConstraints = new ArrayList<>();
+      for (String targetExpr : targetExprList) {
+        if (min == 0 && max == 0) {
+          // anti-affinity
+          targetConstraints.add(new StringBuilder()
+              .append("notin").append(",")
+              .append(getScope()).append(",")
+              .append(targetExpr)
+              .toString());
+        } else if (min == 1 && max == Integer.MAX_VALUE) {
+          // affinity
+          targetConstraints.add(new StringBuilder()
+              .append("in").append(",")
+              .append(getScope()).append(",")
+              .append(targetExpr)
+              .toString());
+        } else {
+          // cardinality
+          targetConstraints.add(new StringBuilder()
+              .append("cardinality").append(",")
+              .append(getScope()).append(",")
+              .append(targetExpr).append(",")
+              .append(min).append(",")
+              .append(max)
+              .toString());
+        }
+      }
+      return String.join(":", targetConstraints);
+    }
+
+    @Override
+    public String toString() {
+      StringBuffer sb = new StringBuffer();
+      if (TargetType.ALLOCATION_TAG == this.targetType) {
+        // following by a comma separated tags
+        sb.append(String.join(",", getTargetValues()));
+      } else if (TargetType.NODE_ATTRIBUTE == this.targetType) {
+        // following by a comma separated key value pairs
+        if (this.getTargetValues() != null) {
+          String attributeName = this.getTargetKey();
+          String attributeValues = String.join(":", this.getTargetValues());
+          sb.append(attributeName + "=[" + attributeValues + "]");
+        }
+      }
+      return sb.toString();
+    }
+
+    @Override
-      IN, NOT_IN
+      IN("in"), NOT_IN("notin");
+
+      private String operator;
+      TargetOperator(String op) {
+        this.operator = op;
+      }
+
+      String getOperator() {
+        return this.operator;
+      }
+    public String toString() {
+      List<String> targetExprs = getTargetExpressions().stream().map(
+          targetExpression -> new StringBuilder()
+              .append(op.getOperator()).append(",")
+              .append(scope).append(",")
+              .append(targetExpression.toString())
+              .toString()).collect(Collectors.toList());
+      return String.join(":", targetExprs);
+    }
+
+    @Override
+
+    @Override
+    public String toString() {
+      StringBuffer sb = new StringBuffer();
+      sb.append("cardinality").append(",").append(getScope()).append(",");
+      for (String tag : getAllocationTags()) {
+        sb.append(tag).append(",");
+      }
+      sb.append(minCardinality).append(",").append(maxCardinality);
+      return sb.toString();
+    }
+
+    @Override
+    public String toString() {
+      StringBuffer sb = new StringBuffer();
+      sb.append("and(");
+      Iterator<AbstractConstraint> it = getChildren().iterator();
+      while (it.hasNext()) {
+        AbstractConstraint child = it.next();
+        sb.append(child.toString());
+        if (it.hasNext()) {
+          sb.append(":");
+        }
+      }
+      sb.append(")");
+      return sb.toString();
+    }
+
+    @Override
+    public String toString() {
+      StringBuffer sb = new StringBuffer();
+      sb.append("or(");
+      Iterator<AbstractConstraint> it = getChildren().iterator();
+      while (it.hasNext()) {
+        AbstractConstraint child = it.next();
+        sb.append(child.toString());
+        if (it.hasNext()) {
+          sb.append(":");
+        }
+      }
+      sb.append(")");
+      return sb.toString();
+    }
+
+    @Override
+    public String toString() {
+      StringBuffer sb = new StringBuffer();
+      sb.append("DelayedOr(");
+      Iterator<TimedPlacementConstraint> it = getChildren().iterator();
+      while (it.hasNext()) {
+        TimedPlacementConstraint child = it.next();
+        sb.append(child.toString());
+        if (it.hasNext()) {
+          sb.append(",");
+        }
+      }
+      sb.append(")");
+      return sb.toString();
+    }

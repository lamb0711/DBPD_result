HDFS-10999. Introduce separate stats for Replicated and Erasure Coded Blocks apart from the current Aggregated stats. (Manoj Govindassamy via lei)

-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.TreeMap;
+import java.util.concurrent.atomic.LongAdder;
+import org.apache.hadoop.hdfs.protocol.BlockType;
+  private final LongAdder totalCorruptBlocks = new LongAdder();
+  private final LongAdder totalCorruptECBlockGroups = new LongAdder();
+
+      incrementBlockStat(blk);
-   * Remove Block from CorruptBlocksMap
-   *
+   * Remove Block from CorruptBlocksMap.
-      corruptReplicasMap.remove(blk);
+      Map<DatanodeDescriptor, Reason> value = corruptReplicasMap.remove(blk);
+      if (value != null) {
+        decrementBlockStat(blk);
+      }
-    if (datanodes==null)
+    if (datanodes == null) {
+    }
+        decrementBlockStat(blk);
-    
+
+  private void incrementBlockStat(Block block) {
+    if (BlockIdManager.isStripedBlockID(block.getBlockId())) {
+      totalCorruptECBlockGroups.increment();
+    } else {
+      totalCorruptBlocks.increment();
+    }
+  }
+
+  private void decrementBlockStat(Block block) {
+    if (BlockIdManager.isStripedBlockID(block.getBlockId())) {
+      totalCorruptECBlockGroups.decrement();
+    } else {
+      totalCorruptBlocks.decrement();
+    }
+  }
-   *
-  long[] getCorruptReplicaBlockIdsForTesting(int numExpectedBlocks,
-                                   Long startingBlockId) {
+  long[] getCorruptBlockIdsForTesting(BlockType blockType,
+      int numExpectedBlocks, Long startingBlockId) {
-    
-    Iterator<Block> blockIt = 
-        new TreeMap<>(corruptReplicasMap).keySet().iterator();
-    
-    // if the starting block id was specified, iterate over keys until
-    // we find the matching block. If we find a matching block, break
-    // to leave the iterator on the next block after the specified block. 
-    if (startingBlockId != null) {
-      boolean isBlockFound = false;
-      while (blockIt.hasNext()) {
-        Block b = blockIt.next();
-        if (b.getBlockId() == startingBlockId) {
-          isBlockFound = true;
-          break; 
-        }
-      }
-      
-      if (!isBlockFound) {
-        return null;
-      }
-    }
-
-    ArrayList<Long> corruptReplicaBlockIds = new ArrayList<Long>();
-
-    // append up to numExpectedBlocks blockIds to our list
-    for(int i=0; i<numExpectedBlocks && blockIt.hasNext(); i++) {
-      corruptReplicaBlockIds.add(blockIt.next().getBlockId());
-    }
-    
-    long[] ret = new long[corruptReplicaBlockIds.size()];
-    for(int i=0; i<ret.length; i++) {
-      ret[i] = corruptReplicaBlockIds.get(i);
-    }
-    
-    return ret;
+    long cursorBlockId =
+        startingBlockId != null ? startingBlockId : Long.MIN_VALUE;
+    return corruptReplicasMap.keySet()
+        .stream()
+        .filter(r -> {
+          if (blockType == BlockType.STRIPED) {
+            return BlockIdManager.isStripedBlockID(r.getBlockId()) &&
+                r.getBlockId() >= cursorBlockId;
+          } else {
+            return !BlockIdManager.isStripedBlockID(r.getBlockId()) &&
+                r.getBlockId() >= cursorBlockId;
+          }
+        })
+        .sorted()
+        .limit(numExpectedBlocks)
+        .mapToLong(Block::getBlockId)
+        .toArray();
+
+  long getCorruptBlocksStat() {
+    return totalCorruptBlocks.longValue();
+  }
+
+  long getCorruptECBlockGroupsStat() {
+    return totalCorruptECBlockGroups.longValue();
+  }

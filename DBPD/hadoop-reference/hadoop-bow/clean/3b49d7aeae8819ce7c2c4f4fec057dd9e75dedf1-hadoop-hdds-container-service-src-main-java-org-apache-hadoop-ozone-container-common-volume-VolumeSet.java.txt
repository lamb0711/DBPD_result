HDDS-989. Check Hdds Volumes for errors. Contributed by Arpit Agarwal.

+import org.apache.curator.shaded.com.google.common.collect.ImmutableSet;
+import org.apache.hadoop.util.DiskChecker;
+import org.apache.hadoop.util.Timer;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
- * VolumeSet to manage volumes in a DataNode.
+ * VolumeSet to manage HDDS volumes in a DataNode.
+   * An executor for periodic disk checks.
+   */
+  final ScheduledExecutorService diskCheckerservice;
+  final ScheduledFuture<?> periodicDiskChecker;
+
+  private static final long DISK_CHECK_INTERVAL_MINUTES = 15;
+
+  /**
+  private final HddsVolumeChecker volumeChecker;
-
+    this.volumeChecker = getVolumeChecker(conf);
+    this.diskCheckerservice = Executors.newScheduledThreadPool(
+        1, r -> new Thread(r, "Periodic HDDS volume checker"));
+    this.periodicDiskChecker =
+        diskCheckerservice.scheduleWithFixedDelay(() -> {
+            try {
+              checkAllVolumes();
+            } catch (IOException e) {
+              LOG.warn("Exception while checking disks", e);
+            }
+          }, DISK_CHECK_INTERVAL_MINUTES, DISK_CHECK_INTERVAL_MINUTES,
+              TimeUnit.MINUTES);
-  // Add DN volumes configured through ConfigKeys to volumeMap.
+  @VisibleForTesting
+  HddsVolumeChecker getVolumeChecker(Configuration conf)
+      throws DiskChecker.DiskErrorException {
+    return new HddsVolumeChecker(conf, new Timer());
+  }
+
+  /**
+   * Add DN volumes configured through ConfigKeys to volumeMap.
+   */
-      volumeStateMap.put(storageType, new ArrayList<HddsVolume>());
+      volumeStateMap.put(storageType, new ArrayList<>());
+
+        if (!hddsVolume.getHddsRootDir().mkdirs() &&
+            !hddsVolume.getHddsRootDir().exists()) {
+          throw new IOException("Failed to create HDDS storage dir " +
+              hddsVolume.getHddsRootDir());
+        }
+    checkAllVolumes();
+
-      throw new DiskOutOfSpaceException("No storage location configured");
+      throw new DiskOutOfSpaceException("No storage locations configured");
+   * Run a synchronous parallel check of all HDDS volumes, removing
+   * failed volumes.
+   */
+  private void checkAllVolumes() throws IOException {
+    List<HddsVolume> allVolumes = getVolumesList();
+    Set<HddsVolume> failedVolumes;
+    try {
+      failedVolumes = volumeChecker.checkAllVolumes(allVolumes);
+    } catch (InterruptedException e) {
+      throw new IOException("Interrupted while running disk check", e);
+    }
+
+    if (failedVolumes.size() > 0) {
+      LOG.warn("checkAllVolumes got {} failed volumes - {}",
+          failedVolumes.size(), failedVolumes);
+      handleVolumeFailures(failedVolumes);
+    } else {
+      LOG.debug("checkAllVolumes encountered no failures");
+    }
+  }
+
+  /**
+   * Handle one or more failed volumes.
+   * @param failedVolumes
+   */
+  private void handleVolumeFailures(Set<HddsVolume> failedVolumes) {
+    for (HddsVolume v: failedVolumes) {
+      this.writeLock();
+      try {
+        // Immediately mark the volume as failed so it is unavailable
+        // for new containers.
+        volumeMap.remove(v.getHddsRootDir().getPath());
+        failedVolumeMap.putIfAbsent(v.getHddsRootDir().getPath(), v);
+      } finally {
+        this.writeUnlock();
+      }
+
+      // TODO:
+      // 1. Mark all closed containers on the volume as unhealthy.
+      // 2. Consider stopping IO on open containers and tearing down
+      //    active pipelines.
+      // 3. Handle Ratis log disk failure.
+    }
+  }
+
+  /**
-  public boolean addVolume(String dataDir) {
+  boolean addVolume(String dataDir) {
-  public boolean addVolume(String volumeRoot, StorageType storageType) {
+  private boolean addVolume(String volumeRoot, StorageType storageType) {
-   * Shutdown's the volumeset, if saveVolumeSetUsed is false, call's
-   * {@link VolumeSet#saveVolumeSetUsed}.
+   * Shutdown the volumeset.
+    stopDiskChecker();
+  private void stopDiskChecker() {
+    periodicDiskChecker.cancel(true);
+    volumeChecker.shutdownAndWait(0, TimeUnit.SECONDS);
+    diskCheckerservice.shutdownNow();
+  }
+

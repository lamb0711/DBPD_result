HDDS-638. Enable ratis snapshots for HDDS datanodes. Contributed by Mukul Kumar Singh.

+import org.apache.ratis.server.impl.RaftServerConstants;
+import org.apache.ratis.server.protocol.TermIndex;
+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;
+import java.io.File;
+import java.util.Map;
+  private final Map<Long, Long> containerCommandCompletionMap;
+    containerCommandCompletionMap = new ConcurrentHashMap<>();
-    //  TODO handle snapshots
-    // TODO: Add a flag that tells you that initialize has been called.
-    // Check with Ratis if this feature is done in Ratis.
+    loadSnapshot(storage.getLatestSnapshot());
+  }
+
+  private long loadSnapshot(SingleFileSnapshotInfo snapshot) {
+    if (snapshot == null) {
+      TermIndex empty = TermIndex.newTermIndex(0, 0);
+      LOG.info("The snapshot info is null." +
+          "Setting the last applied index to:" + empty);
+      setLastAppliedTermIndex(empty);
+      return RaftServerConstants.INVALID_LOG_INDEX;
+    }
+
+    final TermIndex last =
+        SimpleStateMachineStorage.getTermIndexFromSnapshotFile(
+            snapshot.getFile().getPath().toFile());
+    LOG.info("Setting the last applied index to " + last);
+    setLastAppliedTermIndex(last);
+    return last.getIndex();
+  }
+
+  @Override
+  public long takeSnapshot() throws IOException {
+    TermIndex ti = getLastAppliedTermIndex();
+    LOG.info("Taking snapshot at termIndex:" + ti);
+    if (ti != null) {
+      final File snapshotFile =
+          storage.getSnapshotFile(ti.getTerm(), ti.getIndex());
+      LOG.info("Taking a snapshot to file {}", snapshotFile);
+      try {
+        //TODO: For now, just create the file to save the term index,
+        //persist open container info to snapshot later.
+        snapshotFile.createNewFile();
+      } catch(IOException ioe) {
+        LOG.warn("Failed to write snapshot file \"" + snapshotFile
+            + "\", last applied index=" + ti);
+        throw ioe;
+      }
+      return ti.getIndex();
+    }
+    return -1;
-            .map(x -> x.getValue()).collect(Collectors.toList());
-    CompletableFuture<Void> combinedFuture = CompletableFuture.allOf(
+            .map(Map.Entry::getValue).collect(Collectors.toList());
+    return CompletableFuture.allOf(
-    return combinedFuture;
+  private void updateLastApplied() {
+    Long appliedTerm = null;
+    long appliedIndex = -1;
+    for(long i = getLastAppliedTermIndex().getIndex() + 1;; i++) {
+      final Long removed = containerCommandCompletionMap.remove(i);
+      if (removed == null) {
+        break;
+      }
+      appliedTerm = removed;
+      appliedIndex = i;
+    }
+    if (appliedTerm != null) {
+      updateLastAppliedTermIndex(appliedIndex, appliedTerm);
+    }
+  }
+
+    long index = trx.getLogEntry().getIndex();
-        blockData.setBlockCommitSequenceId(trx.getLogEntry().getIndex());
+        blockData.setBlockCommitSequenceId(index);
+
+      future.thenAccept(m -> {
+        final Long previous =
+            containerCommandCompletionMap
+                .put(index, trx.getLogEntry().getTerm());
+        Preconditions.checkState(previous == null);
+        updateLastApplied();
+      });
-    for (int i = 0; i < numExecutors; i++){
+    takeSnapshot();
+    for (int i = 0; i < numExecutors; i++) {

HDFS-11402. HDFS Snapshots should capture point-in-time copies of OPEN files. (Manoj Govindassamy via Yongjun Zhang)

-  static INodesInPath fromINode(INode inode) {
+  private static INode[] getINodes(final INode inode) {
-    final byte[][] path = new byte[depth][];
-    final INode[] inodes = new INode[depth];
+    INode[] inodes = new INode[depth];
-      path[index] = tmp.getKey();
-    return new INodesInPath(inodes, path);
+    return inodes;
+  }
+
+  private static byte[][] getPaths(final INode[] inodes) {
+    byte[][] paths = new byte[inodes.length][];
+    for (int i = 0; i < inodes.length; i++) {
+      paths[i] = inodes[i].getKey();
+    }
+    return paths;
+  }
+
+  /**
+   * Construct {@link INodesInPath} from {@link INode}.
+   *
+   * @param inode to construct from
+   * @return INodesInPath
+   */
+  static INodesInPath fromINode(INode inode) {
+    INode[] inodes = getINodes(inode);
+    byte[][] paths = getPaths(inodes);
+    return new INodesInPath(inodes, paths);
+  }
+
+  /**
+   * Construct {@link INodesInPath} from {@link INode} and its root
+   * {@link INodeDirectory}. INodesInPath constructed this way will
+   * each have its snapshot and latest snapshot id filled in.
+   *
+   * This routine is specifically for
+   * {@link LeaseManager#getINodeWithLeases(INodeDirectory)} to get
+   * open files along with their snapshot details which is used during
+   * new snapshot creation to capture their meta data.
+   *
+   * @param rootDir the root {@link INodeDirectory} under which inode
+   *                needs to be resolved
+   * @param inode the {@link INode} to be resolved
+   * @return INodesInPath
+   */
+  static INodesInPath fromINode(final INodeDirectory rootDir, INode inode) {
+    byte[][] paths = getPaths(getINodes(inode));
+    return resolve(rootDir, paths);
+   * Verify if this {@link INodesInPath} is a descendant of the
+   * requested {@link INodeDirectory}.
+   *
+   * @param inodeDirectory the ancestor directory
+   * @return true if this INodesInPath is a descendant of inodeDirectory
+   */
+  public boolean isDescendant(final INodeDirectory inodeDirectory) {
+    final INodesInPath dirIIP = fromINode(inodeDirectory);
+    return isDescendant(dirIIP);
+  }
+
+  private boolean isDescendant(final INodesInPath ancestorDirIIP) {
+    int ancestorDirINodesLength = ancestorDirIIP.length();
+    int myParentINodesLength = length() - 1;
+    if (myParentINodesLength < ancestorDirINodesLength) {
+      return false;
+    }
+
+    int index = 0;
+    while (index < ancestorDirINodesLength) {
+      if (inodes[index] != ancestorDirIIP.getINode(index)) {
+        return false;
+      }
+      index++;
+    }
+    return true;
+  }
+
+
+  /**

YARN-2113. Add cross-user preemption within CapacityScheduler's leaf-queue. (Sunil G via wangda)

Change-Id: I9b19f69788068be05b3295247cdd7b972f8a573c

+import org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity.ProportionalCapacityPreemptionPolicy.IntraQueuePreemptionOrderPolicy;
+import java.util.Collection;
-import java.util.Iterator;
+import java.util.HashMap;
-    public int compare(TempAppPerPartition tq1, TempAppPerPartition tq2) {
-      Priority p1 = Priority.newInstance(tq1.getPriority());
-      Priority p2 = Priority.newInstance(tq2.getPriority());
+    public int compare(TempAppPerPartition ta1, TempAppPerPartition ta2) {
+      Priority p1 = Priority.newInstance(ta1.getPriority());
+      Priority p2 = Priority.newInstance(ta2.getPriority());
-      return tq1.getApplicationId().compareTo(tq2.getApplicationId());
+      return ta1.getApplicationId().compareTo(ta2.getApplicationId());
-        // 6. Based on the selected resource demand per partition, select
+        // Default preemption iterator considers only FIFO+priority. For
+        // userlimit preemption, its possible that some lower priority apps
+        // needs from high priority app of another user. Hence use apps
+        // ordered by userlimit starvation as well.
+        Collection<FiCaSchedulerApp> apps = fifoPreemptionComputePlugin
+            .getPreemptableApps(queueName, partition);
+
+        // 6. Get user-limit to ensure that we do not preempt resources which
+        // will force user's resource to come under its UL.
+        Map<String, Resource> rollingResourceUsagePerUser = new HashMap<>();
+        initializeUsageAndUserLimitForCompute(clusterResource, partition,
+            leafQueue, rollingResourceUsagePerUser);
+
+        // 7. Based on the selected resource demand per partition, select
-          Iterator<FiCaSchedulerApp> desc = leafQueue.getOrderingPolicy()
-              .getPreemptionIterator();
-          while (desc.hasNext()) {
-            FiCaSchedulerApp app = desc.next();
-            preemptFromLeastStarvedApp(selectedCandidates, clusterResource,
-                totalPreemptedResourceAllowed, resToObtainByPartition,
-                leafQueue, app);
+          for (FiCaSchedulerApp app : apps) {
+            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,
+                clusterResource, totalPreemptedResourceAllowed,
+                resToObtainByPartition, rollingResourceUsagePerUser);
-  private void preemptFromLeastStarvedApp(
+  private void initializeUsageAndUserLimitForCompute(Resource clusterResource,
+      String partition, LeafQueue leafQueue,
+      Map<String, Resource> rollingResourceUsagePerUser) {
+    for (String user : leafQueue.getAllUsers()) {
+      // Initialize used resource of a given user for rolling computation.
+      rollingResourceUsagePerUser.put(user, Resources.clone(
+          leafQueue.getUser(user).getResourceUsage().getUsed(partition)));
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Rolling resource usage for user:" + user + " is : "
+            + rollingResourceUsagePerUser.get(user));
+      }
+    }
+  }
+
+  private void preemptFromLeastStarvedApp(LeafQueue leafQueue,
+      FiCaSchedulerApp app,
-      Map<String, Resource> resToObtainByPartition, LeafQueue leafQueue,
-      FiCaSchedulerApp app) {
+      Map<String, Resource> resToObtainByPartition,
+      Map<String, Resource> rollingResourceUsagePerUser) {
-    List<RMContainer> liveContainers = new ArrayList<>(
-        app.getLiveContainers());
+    List<RMContainer> liveContainers = new ArrayList<>(app.getLiveContainers());
+    Resource rollingUsedResourcePerUser = rollingResourceUsagePerUser
+        .get(app.getUser());
-      // Try to preempt this container
-      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(
-          rc, preemptionContext, resToObtainByPartition, c, clusterResource,
-          selectedCandidates, totalPreemptedResourceAllowed);
-    }
+      // If selected container brings down resource usage under its user's
+      // UserLimit (or equals to), we must skip such containers.
+      if (fifoPreemptionComputePlugin.skipContainerBasedOnIntraQueuePolicy(app,
+          clusterResource, rollingUsedResourcePerUser, c)) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug(
+              "Skipping container: " + c.getContainerId() + " with resource:"
+                  + c.getAllocatedResource() + " as UserLimit for user:"
+                  + app.getUser() + " with resource usage: "
+                  + rollingUsedResourcePerUser + " is going under UL");
+        }
+        break;
+      }
+      // Try to preempt this container
+      boolean ret = CapacitySchedulerPreemptionUtils
+          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,
+              resToObtainByPartition, c, clusterResource, selectedCandidates,
+              totalPreemptedResourceAllowed);
+
+      // Subtract from respective user's resource usage once a container is
+      // selected for preemption.
+      if (ret && preemptionContext.getIntraQueuePreemptionOrderPolicy()
+          .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {
+        Resources.subtractFrom(rollingUsedResourcePerUser,
+            c.getAllocatedResource());
+      }
+    }
-      // 2. Its better to get partition based resource limit earlier before
-      // starting calculation
-      Resource partitionBasedResource =
-          context.getPartitionResource(partition);
-
-      // 3. loop through all queues corresponding to a partition.
+      // 2. loop through all queues corresponding to a partition.
-        // 4. Consider reassignableResource as (used - actuallyToBePreempted).
+        // 3. Consider reassignableResource as (used - actuallyToBePreempted).
-        // 5. Check queue's used capacity. Make sure that the used capacity is
+        // 4. Check queue's used capacity. Make sure that the used capacity is
-        // 6. compute the allocation of all apps based on queue's unallocated
+        // 5. compute the allocation of all apps based on queue's unallocated
-            partitionBasedResource, tq, selectedCandidates,
-            totalPreemptedResourceAllowed,
+            tq, selectedCandidates, totalPreemptedResourceAllowed,

commit correct version of HDFS-5121

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520090 13f79535-47bb-0310-9956-ffa450edef68

-    checkOperation(OperationCategory.WRITE);
+  @SuppressWarnings("unchecked")
-    checkOperation(OperationCategory.WRITE);
-      results = cacheManager.addDirectives(directives, pc);
+      results = cacheManager.addDirectives(pc, directives);
-      if (isAuditEnabled() && isExternalInvocation()) {
+      if (auditLog.isInfoEnabled() && isExternalInvocation()) {
-  List<Fallible<Long>> removePathCacheEntries(List<Long> ids) throws IOException {
-    CacheEntryWithPayload retryCacheEntry =
-        RetryCache.waitForCompletion(retryCache, null);
-    if (retryCacheEntry != null && retryCacheEntry.isSuccess()) {
-      return (List<Fallible<Long>>) retryCacheEntry.getPayload();
-    }
+  @SuppressWarnings("unchecked")
+  List<Fallible<Long>> removePathCacheEntries(List<Long> ids)
+      throws IOException {
-    checkOperation(OperationCategory.WRITE);
-            "Cannot remove path cache directives", safeMode);
+            "Cannot add path cache directive", safeMode);
-      results = cacheManager.removeEntries(ids, pc);
+      results = cacheManager.removeEntries(pc, ids);
-      if (isAuditEnabled() && isExternalInvocation()) {
+      if (success) {
+        getEditLog().logSync();
+      }
+      if (auditLog.isInfoEnabled() && isExternalInvocation()) {
-      RetryCache.setState(retryCacheEntry, success, results);
-    getEditLog().logSync();
-  List<PathCacheEntry> listPathCacheEntries(long startId, String pool,
-      int maxReplies) throws IOException {
-    checkOperation(OperationCategory.READ);
-    readLock();
-    try {
-      checkOperation(OperationCategory.READ);
-      return cacheManager.listPathCacheEntries(startId, pool, maxReplies);
-    } finally {
-      readUnlock();
-    }
+  List<PathCacheEntry> listPathCacheEntries(long startId,
+      Long poolId, int maxReplies) throws IOException {
+    LOG.info("listPathCacheEntries with " + startId + " " + poolId);
+    final FSPermissionChecker pc = getPermissionChecker();
+    return cacheManager.listPathCacheEntries(pc, startId, poolId, maxReplies);
-  public void addCachePool(CachePoolInfo req) throws IOException {
+  public CachePool addCachePool(CachePoolInfo req) throws IOException {
-    CacheEntry cacheEntry = RetryCache.waitForCompletion(retryCache);
+    CacheEntryWithPayload cacheEntry =
+        RetryCache.waitForCompletion(retryCache, null);
-      return; // Return previous response
+      return (CachePool)cacheEntry.getPayload(); // Return previous response
-    checkOperation(OperationCategory.WRITE);
-    boolean success = false;
+    CachePool pool = null;
-      cacheManager.addCachePool(req);
+      pool = cacheManager.addCachePool(req);
+      RetryCache.setState(cacheEntry, true);
-      success = true;
-      if (isAuditEnabled() && isExternalInvocation()) {
-        logAuditEvent(success, "addCachePool", req.getPoolName(), null, null);
-      }
-      RetryCache.setState(cacheEntry, success);
-    
+
+    if (auditLog.isInfoEnabled() && isExternalInvocation()) {
+      logAuditEvent(true, "addCachePool", req.getPoolName(), null, null);
+    }
+    return pool;
-  public void modifyCachePool(CachePoolInfo req) throws IOException {
+  public void modifyCachePool(long poolId, CachePoolInfo info)
+      throws IOException {
-    checkOperation(OperationCategory.WRITE);
-    boolean success = false;
-            "Cannot modify cache pool " + req.getPoolName(), safeMode);
+            "Cannot modify cache pool " + info.getPoolName(), safeMode);
-      cacheManager.modifyCachePool(req);
+      cacheManager.modifyCachePool(poolId, info);
+      RetryCache.setState(cacheEntry, true);
-      success = true;
-      if (isAuditEnabled() && isExternalInvocation()) {
-        logAuditEvent(success, "modifyCachePool", req.getPoolName(), null, null);
-      }
-      RetryCache.setState(cacheEntry, success);
+    if (auditLog.isInfoEnabled() && isExternalInvocation()) {
+      logAuditEvent(true, "modifyCachePool", info.getPoolName(), null, null);
+    }
-  public void removeCachePool(String cachePoolName) throws IOException {
+  public void removeCachePool(long poolId) throws IOException {
-    CacheEntry cacheEntry = RetryCache.waitForCompletion(retryCache);
-    if (cacheEntry != null && cacheEntry.isSuccess()) {
-      return; // Return previous response
-    }
-    checkOperation(OperationCategory.WRITE);
-    boolean success = false;
+    CachePool pool;
+      pool = cacheManager.getCachePool(poolId);
+        String identifier;
+        if (pool == null) {
+          identifier = "with id " + Long.toString(poolId);
+        } else {
+          identifier = pool.getInfo().getPoolName();
+        }
-            "Cannot remove cache pool " + cachePoolName, safeMode);
+            "Cannot remove cache pool " + identifier, safeMode);
-      cacheManager.removeCachePool(cachePoolName);
+      cacheManager.removeCachePool(poolId);
-      success = true;
-      if (isAuditEnabled() && isExternalInvocation()) {
-        logAuditEvent(success, "removeCachePool", cachePoolName, null, null);
-      }
-      RetryCache.setState(cacheEntry, success);
-    
+
+    if (auditLog.isInfoEnabled() && isExternalInvocation()) {
+      logAuditEvent(true, "removeCachePool", pool.getInfo().getPoolName(),
+          null, null);
+    }
-  public List<CachePoolInfo> listCachePools(String prevKey,
+  public List<CachePool> listCachePools(long prevKey,
-    final FSPermissionChecker pc = getPermissionChecker();
-    List<CachePoolInfo> results;
-    checkOperation(OperationCategory.READ);
+    List<CachePool> results;
-      results = cacheManager.listCachePools(pc, prevKey, maxRepliesPerRequest);
+      results = cacheManager.listCachePools(prevKey, maxRepliesPerRequest);

HDFS-14649. Add suspect probe for DeadNodeDetector. Contributed by Lisheng Sun.

+import com.google.common.annotations.VisibleForTesting;
+import static org.apache.hadoop.hdfs.client.HdfsClientConfigKeys.DFS_CLIENT_DEAD_NODE_DETECTION_PROBE_SUSPECT_NODE_INTERVAL_MS_DEFAULT;
+import static org.apache.hadoop.hdfs.client.HdfsClientConfigKeys.DFS_CLIENT_DEAD_NODE_DETECTION_PROBE_SUSPECT_NODE_INTERVAL_MS_KEY;
+import static org.apache.hadoop.hdfs.client.HdfsClientConfigKeys.DFS_CLIENT_DEAD_NODE_DETECTION_PROBE_SUSPECT_NODE_THREADS_DEFAULT;
+import static org.apache.hadoop.hdfs.client.HdfsClientConfigKeys.DFS_CLIENT_DEAD_NODE_DETECTION_PROBE_SUSPECT_NODE_THREADS_KEY;
+import static org.apache.hadoop.hdfs.client.HdfsClientConfigKeys.DFS_CLIENT_DEAD_NODE_DETECTION_SUSPECT_NODE_QUEUE_MAX_DEFAULT;
+import static org.apache.hadoop.hdfs.client.HdfsClientConfigKeys.DFS_CLIENT_DEAD_NODE_DETECTION_SUSPECT_NODE_QUEUE_MAX_KEY;
-   * Record dead nodes by one DFSInputStream. When dead node is not used by one
-   * DFSInputStream, remove it from dfsInputStreamNodes#DFSInputStream. If
-   * DFSInputStream does not include any dead node, remove DFSInputStream from
-   * dfsInputStreamNodes.
+   * Record suspect and dead nodes by one DFSInputStream. When node is not used
+   * by one DFSInputStream, remove it from suspectAndDeadNodes#DFSInputStream.
+   * If DFSInputStream does not include any node, remove DFSInputStream from
+   * suspectAndDeadNodes.
-          dfsInputStreamNodes;
+          suspectAndDeadNodes;
+   * Interval time in milliseconds for probing suspect node behavior.
+   */
+  private long suspectNodeDetectInterval = 0;
+
+  /**
+   * The max queue size of probing suspect node.
+   */
+  private int maxSuspectNodesProbeQueueLen;
+
+  /**
+   * The suspect node probe queue.
+   */
+  private Queue<DatanodeInfo> suspectNodesProbeQueue;
+
+  /**
+   * The thread pool of probing suspect node.
+   */
+  private ExecutorService probeSuspectNodesThreadPool;
+
+  /**
+   * The scheduler thread of probing suspect node.
+   */
+  private Thread probeSuspectNodesSchedulerThr;
+
+  /**
-    CHECK_DEAD
+    CHECK_DEAD, CHECK_SUSPECT
+  /**
+   * Disabled start probe suspect/dead thread for the testing.
+   */
+  private static volatile boolean disabledProbeThreadForTest = false;
+
-    this.dfsInputStreamNodes =
+    this.suspectAndDeadNodes =
+    suspectNodeDetectInterval = conf.getLong(
+        DFS_CLIENT_DEAD_NODE_DETECTION_PROBE_SUSPECT_NODE_INTERVAL_MS_KEY,
+        DFS_CLIENT_DEAD_NODE_DETECTION_PROBE_SUSPECT_NODE_INTERVAL_MS_DEFAULT);
+    maxSuspectNodesProbeQueueLen =
+        conf.getInt(DFS_CLIENT_DEAD_NODE_DETECTION_SUSPECT_NODE_QUEUE_MAX_KEY,
+            DFS_CLIENT_DEAD_NODE_DETECTION_SUSPECT_NODE_QUEUE_MAX_DEFAULT);
+    this.suspectNodesProbeQueue =
+        new ArrayBlockingQueue<DatanodeInfo>(maxSuspectNodesProbeQueueLen);
+    int suspectNodeDetectDeadThreads = conf.getInt(
+        DFS_CLIENT_DEAD_NODE_DETECTION_PROBE_SUSPECT_NODE_THREADS_KEY,
+        DFS_CLIENT_DEAD_NODE_DETECTION_PROBE_SUSPECT_NODE_THREADS_DEFAULT);
+    probeSuspectNodesThreadPool = Executors.newFixedThreadPool(
+        suspectNodeDetectDeadThreads, new Daemon.DaemonFactory());
-    startProbeScheduler();
+    if (!disabledProbeThreadForTest) {
+      startProbeScheduler();
+    }
+  @VisibleForTesting
+  static void disabledProbeThreadForTest() {
+    disabledProbeThreadForTest = true;
+  }
+
-   * Start probe dead node thread.
+   * Start probe dead node and suspect node thread.
-  private void startProbeScheduler() {
+  @VisibleForTesting
+  void startProbeScheduler() {
+
+    probeSuspectNodesSchedulerThr =
+            new Thread(new ProbeScheduler(this, ProbeType.CHECK_SUSPECT));
+    probeSuspectNodesSchedulerThr.setDaemon(true);
+    probeSuspectNodesSchedulerThr.start();
+    } else if (type == ProbeType.CHECK_SUSPECT) {
+      while ((datanodeInfo = suspectNodesProbeQueue.poll()) != null) {
+        if (probeInProg.containsKey(datanodeInfo.getDatanodeUuid())) {
+          continue;
+        }
+        probeInProg.put(datanodeInfo.getDatanodeUuid(), datanodeInfo);
+        Probe probe = new Probe(this, datanodeInfo, ProbeType.CHECK_SUSPECT);
+        probeSuspectNodesThreadPool.execute(probe);
+      }
-        ProbeType type) {
+           ProbeType type) {
-        LOG.info("Remove the node out from dead node list: {}. ",
+        LOG.info("Remove the node out from dead node list: {}.",
-        removeNodeFromDeadNode(probe.getDatanodeInfo());
+        removeDeadNode(probe.getDatanodeInfo());
+      } else if (probe.getType() == ProbeType.CHECK_SUSPECT) {
+        LOG.debug("Remove the node out from suspect node list: {}.",
+            probe.getDatanodeInfo());
+        removeNodeFromDeadNodeDetector(probe.getDatanodeInfo());
+      }
+    } else {
+      if (probe.getType() == ProbeType.CHECK_SUSPECT) {
+        LOG.info("Add the node to dead node list: {}.",
+            probe.getDatanodeInfo());
+        addToDead(probe.getDatanodeInfo());
+  public Queue<DatanodeInfo> getSuspectNodesProbeQueue() {
+    return suspectNodesProbeQueue;
+  }
+
-   * Add datanode in deadNodes and dfsInputStreamNodes. The node is considered
-   * to dead node. The dead node is shared by all the DFSInputStreams in the
-   * same client.
+   * Add datanode to suspectNodes and suspectAndDeadNodes.
-        dfsInputStreamNodes.get(dfsInputStream);
+        suspectAndDeadNodes.get(dfsInputStream);
-      dfsInputStreamNodes.putIfAbsent(dfsInputStream, datanodeInfos);
+      suspectAndDeadNodes.putIfAbsent(dfsInputStream, datanodeInfos);
-    addToDead(datanodeInfo);
+    addSuspectNodeToDetect(datanodeInfo);
-   * Remove dead node which is not used by any DFSInputStream from deadNodes.
-   * @return new dead node shared by all DFSInputStreams.
+   * Add datanode to suspectNodes.
+  private boolean addSuspectNodeToDetect(DatanodeInfo datanodeInfo) {
+    return suspectNodesProbeQueue.offer(datanodeInfo);
+  }
+
+    /**
+     * Remove dead node which is not used by any DFSInputStream from deadNodes.
+     * @return new dead node shared by all DFSInputStreams.
+     */
-    for (HashSet<DatanodeInfo> datanodeInfos : dfsInputStreamNodes.values()) {
+    for (HashSet<DatanodeInfo> datanodeInfos : suspectAndDeadNodes.values()) {
-   * Remove dead node from dfsInputStreamNodes#dfsInputStream. If
-   * dfsInputStreamNodes#dfsInputStream does not contain any dead node, remove
-   * it from dfsInputStreamNodes.
+   * Remove suspect and dead node from suspectAndDeadNodes#dfsInputStream and
+   *  local deadNodes.
-    Set<DatanodeInfo> datanodeInfos = dfsInputStreamNodes.get(dfsInputStream);
+    Set<DatanodeInfo> datanodeInfos = suspectAndDeadNodes.get(dfsInputStream);
+      dfsInputStream.removeFromLocalDeadNodes(datanodeInfo);
-        dfsInputStreamNodes.remove(dfsInputStream);
+        suspectAndDeadNodes.remove(dfsInputStream);
-   * Remove dead node from dfsInputStreamNodes#dfsInputStream and deadNodes.
+   * Remove suspect and dead node from suspectAndDeadNodes#dfsInputStream and
+   *  local deadNodes.
-  public synchronized void removeNodeFromDeadNode(DatanodeInfo datanodeInfo) {
+  private synchronized void removeNodeFromDeadNodeDetector(
+      DatanodeInfo datanodeInfo) {
-            dfsInputStreamNodes.entrySet()) {
+            suspectAndDeadNodes.entrySet()) {
+        if (datanodeInfos.isEmpty()) {
+          suspectAndDeadNodes.remove(dfsInputStream);
+        }
+  }
+  /**
+   * Remove suspect and dead node from suspectAndDeadNodes#dfsInputStream and
+   * deadNodes.
+   */
+  private void removeDeadNode(DatanodeInfo datanodeInfo) {
+    removeNodeFromDeadNodeDetector(datanodeInfo);
-        probeSleep(deadNodeDetector.deadNodeDetectInterval);
+        if (type == ProbeType.CHECK_SUSPECT) {
+          probeSleep(deadNodeDetector.suspectNodeDetectInterval);
+        } else {
+          probeSleep(deadNodeDetector.deadNodeDetectInterval);
+        }

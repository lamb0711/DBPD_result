YARN-2883. Queuing of container requests in the NM. (Konstantinos Karanasos and Arun Suresh via kasha)

-  static final String INVALID_NMTOKEN_MSG = "Invalid NMToken";
+  public static final String INVALID_NMTOKEN_MSG = "Invalid NMToken";
-  final Context context;
+  protected final Context context;
-  private final NodeStatusUpdater nodeStatusUpdater;
+  protected final NodeStatusUpdater nodeStatusUpdater;
-    this.containersMonitor =
-        new ContainersMonitorImpl(exec, dispatcher, this.context);
+    this.containersMonitor = createContainersMonitor(exec);
-        new ApplicationEventDispatcher());
+        createApplicationEventDispatcher());
+
+  protected ContainersMonitor createContainersMonitor(ContainerExecutor exec) {
+    return new ContainersMonitorImpl(exec, dispatcher, this.context);
+  }
+
+  protected EventHandler<ApplicationEvent> createApplicationEventDispatcher() {
+    return new ApplicationEventDispatcher();
+  }
+
-
+          performContainerPreStartChecks(nmTokenIdentifier, request,
+              containerTokenIdentifier);
+  private void performContainerPreStartChecks(
+      NMTokenIdentifier nmTokenIdentifier, StartContainerRequest request,
+      ContainerTokenIdentifier containerTokenIdentifier)
+      throws YarnException, InvalidToken {
+  /*
+   * 1) It should save the NMToken into NMTokenSecretManager. This is done
+   * here instead of RPC layer because at the time of opening/authenticating
+   * the connection it doesn't know what all RPC calls user will make on it.
+   * Also new NMToken is issued only at startContainer (once it gets
+   * renewed).
+   *
+   * 2) It should validate containerToken. Need to check below things. a) It
+   * is signed by correct master key (part of retrieve password). b) It
+   * belongs to correct Node Manager (part of retrieve password). c) It has
+   * correct RMIdentifier. d) It is not expired.
+   */
+    authorizeStartAndResourceIncreaseRequest(
+        nmTokenIdentifier, containerTokenIdentifier, true);
+    // update NMToken
+    updateNMTokenIdentifier(nmTokenIdentifier);
+
+    ContainerLaunchContext launchContext = request.getContainerLaunchContext();
+
+    Map<String, ByteBuffer> serviceData = getAuxServiceMetaData();
+    if (launchContext.getServiceData()!=null &&
+        !launchContext.getServiceData().isEmpty()) {
+      for (Entry<String, ByteBuffer> meta : launchContext.getServiceData()
+          .entrySet()) {
+        if (null == serviceData.get(meta.getKey())) {
+          throw new InvalidAuxServiceException("The auxService:" + meta.getKey()
+              + " does not exist");
+        }
+      }
+    }
+  }
+
-  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,
+  protected void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,
-    /*
-     * 1) It should save the NMToken into NMTokenSecretManager. This is done
-     * here instead of RPC layer because at the time of opening/authenticating
-     * the connection it doesn't know what all RPC calls user will make on it.
-     * Also new NMToken is issued only at startContainer (once it gets renewed).
-     * 
-     * 2) It should validate containerToken. Need to check below things. a) It
-     * is signed by correct master key (part of retrieve password). b) It
-     * belongs to correct Node Manager (part of retrieve password). c) It has
-     * correct RMIdentifier. d) It is not expired.
-     */
-    authorizeStartAndResourceIncreaseRequest(
-        nmTokenIdentifier, containerTokenIdentifier, true);
-    // update NMToken
-    updateNMTokenIdentifier(nmTokenIdentifier);
-
-    Map<String, ByteBuffer> serviceData = getAuxServiceMetaData();
-    if (launchContext.getServiceData()!=null && 
-        !launchContext.getServiceData().isEmpty()) {
-      for (Map.Entry<String, ByteBuffer> meta : launchContext.getServiceData()
-          .entrySet()) {
-        if (null == serviceData.get(meta.getKey())) {
-          throw new InvalidAuxServiceException("The auxService:" + meta.getKey()
-              + " does not exist");
-        }
-      }
-    }
-
-      if (!serviceStopped) {
+      if (!isServiceStopped()) {
-        Application application =
-            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);
+        Application application = new ApplicationImpl(dispatcher, user,
+            applicationID, credentials, context);
-          LOG.info("Creating a new application reference for app " + applicationID);
+          LOG.info("Creating a new application reference for app "
+              + applicationID);
-        stopContainerInternal(identifier, id);
+        Container container = this.context.getContainers().get(id);
+        authorizeGetAndStopContainerRequest(id, container, true, identifier);
+        stopContainerInternal(id);
-  private void stopContainerInternal(NMTokenIdentifier nmTokenIdentifier,
-      ContainerId containerID) throws YarnException, IOException {
+  protected void stopContainerInternal(ContainerId containerID)
+      throws YarnException, IOException {
-    authorizeGetAndStopContainerRequest(containerID, container, true,
-      nmTokenIdentifier);
-  private ContainerStatus getContainerStatusInternal(ContainerId containerID,
+  protected ContainerStatus getContainerStatusInternal(ContainerId containerID,
+  protected boolean isServiceStopped() {
+    return serviceStopped;
+  }

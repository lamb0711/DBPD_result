HDFS-13097: [SPS]: Fix the branch review comments(Part1). Contributed by Surendra Singh.

-import org.apache.hadoop.hdfs.DFSUtil;
+import com.google.common.base.Preconditions;
-    this.spsWorkMultiplier = DFSUtil.getSPSWorkMultiplier(getConf());
+    this.spsWorkMultiplier = getSPSWorkMultiplier(getConf());
-    isRunning = true;
-    this.spsMode = serviceMode;
+    isRunning = true;
+    this.spsMode = serviceMode;
-  public synchronized void disable(boolean forceStop) {
+  public synchronized void stop(boolean forceStop) {
-      disable(true);
+      stop(false);
-    if (storagePolicySatisfierThread == null) {
-      return;
-    }
-    try {
-      storagePolicySatisfierThread.join(3000);
-    } catch (InterruptedException ie) {
+    if (storagePolicySatisfierThread != null) {
+      try {
+        storagePolicySatisfierThread.join(3000);
+      } catch (InterruptedException ie) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Interrupted Exception while waiting to join sps thread,"
+              + " ignoring it", ie);
+        }
+      }
+      } catch (IOException e) {
+        LOG.error("Exception during StoragePolicySatisfier execution - "
+            + "will continue next cycle", e);
-        handleException(t);
-      }
-    }
-  }
-
-  private void handleException(Throwable t) {
-    // double check to avoid entering into synchronized block.
-    if (isRunning) {
-      synchronized (this) {
-        if (isRunning) {
-          if (t instanceof InterruptedException) {
+        synchronized (this) {
+          if (isRunning) {
-            LOG.info("Stopping StoragePolicySatisfier.");
+            if (t instanceof InterruptedException) {
+              LOG.info("Stopping StoragePolicySatisfier.", t);
+            } else {
+              LOG.error("StoragePolicySatisfier thread received "
+                  + "runtime exception.", t);
+            }
-          } else {
-            LOG.error(
-                "StoragePolicySatisfier thread received runtime exception, "
-                    + "ignoring", t);
-    return;
-      if (!DFSUtil.removeOverlapBetweenStorageTypes(expectedStorageTypes,
+      if (!removeOverlapBetweenStorageTypes(expectedStorageTypes,
-    if (!DFSUtil.removeOverlapBetweenStorageTypes(expectedStorageTypes,
+    if (!removeOverlapBetweenStorageTypes(expectedStorageTypes,
-   * Set file inode in queue for which storage movement needed for its blocks.
-   *
-   * @param inodeId
-   *          - file inode/blockcollection id.
-   */
-  public void satisfyStoragePolicy(Long inodeId) {
-    //For file startId and trackId is same
-    storageMovementNeeded.add(new ItemInfo(inodeId, inodeId));
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Added track info for inode {} to block "
-          + "storageMovementNeeded queue", inodeId);
-    }
-  }
-
-  /**
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Added track info for inode {} to block "
+          + "storageMovementNeeded queue", trackInfo.getFileId());
+    }
+
+  /**
+   * Remove the overlap between the expected types and the existing types.
+   *
+   * @param expected
+   *          - Expected storage types list.
+   * @param existing
+   *          - Existing storage types list.
+   * @param ignoreNonMovable
+   *          ignore non-movable storage types by removing them from both
+   *          expected and existing storage type list to prevent non-movable
+   *          storage from being moved.
+   * @returns if the existing types or the expected types is empty after
+   *          removing the overlap.
+   */
+  private static boolean removeOverlapBetweenStorageTypes(
+      List<StorageType> expected,
+      List<StorageType> existing, boolean ignoreNonMovable) {
+    for (Iterator<StorageType> i = existing.iterator(); i.hasNext();) {
+      final StorageType t = i.next();
+      if (expected.remove(t)) {
+        i.remove();
+      }
+    }
+    if (ignoreNonMovable) {
+      removeNonMovable(existing);
+      removeNonMovable(expected);
+    }
+    return expected.isEmpty() || existing.isEmpty();
+  }
+
+  private static void removeNonMovable(List<StorageType> types) {
+    for (Iterator<StorageType> i = types.iterator(); i.hasNext();) {
+      final StorageType t = i.next();
+      if (!t.isMovable()) {
+        i.remove();
+      }
+    }
+  }
+
+  /**
+   * Get DFS_SPS_WORK_MULTIPLIER_PER_ITERATION from
+   * configuration.
+   *
+   * @param conf Configuration
+   * @return Value of DFS_SPS_WORK_MULTIPLIER_PER_ITERATION
+   */
+  private static int getSPSWorkMultiplier(Configuration conf) {
+    int spsWorkMultiplier = conf
+        .getInt(
+            DFSConfigKeys.DFS_SPS_WORK_MULTIPLIER_PER_ITERATION,
+            DFSConfigKeys.DFS_SPS_WORK_MULTIPLIER_PER_ITERATION_DEFAULT);
+    Preconditions.checkArgument(
+        (spsWorkMultiplier > 0),
+        DFSConfigKeys.DFS_SPS_WORK_MULTIPLIER_PER_ITERATION +
+        " = '" + spsWorkMultiplier + "' is invalid. " +
+        "It should be a positive, non-zero integer value.");
+    return spsWorkMultiplier;
+  }

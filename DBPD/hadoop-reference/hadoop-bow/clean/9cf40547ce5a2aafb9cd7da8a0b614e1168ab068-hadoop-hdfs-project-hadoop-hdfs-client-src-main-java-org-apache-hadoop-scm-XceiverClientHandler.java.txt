HDFS-11580. Ozone: Support asynchronus client API for SCM and containers. Contributed by Anu Engineer.

+import com.google.common.base.Preconditions;
+import org.apache.hadoop.hdfs.ozone.protocol.proto.ContainerProtos
+    .ContainerCommandResponseProto;
+
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
-    SimpleChannelInboundHandler<ContainerProtos.ContainerCommandResponseProto> {
+    SimpleChannelInboundHandler<ContainerCommandResponseProto> {
-  private final BlockingQueue<ContainerProtos.ContainerCommandResponseProto>
-      responses = new LinkedBlockingQueue<>();
+  private final ConcurrentMap<String,
+      CompletableFuture<ContainerCommandResponseProto>> responses =
+      new ConcurrentHashMap<>();
+
-   *            SimpleChannelInboundHandler} belongs to
+   * SimpleChannelInboundHandler} belongs to
-                           ContainerProtos.ContainerCommandResponseProto msg)
+      ContainerProtos.ContainerCommandResponseProto msg)
-    responses.add(msg);
+    Preconditions.checkNotNull(msg);
+    String key = msg.getTraceID();
+    CompletableFuture<ContainerCommandResponseProto> future =
+        responses.remove(key);
+    if (future != null) {
+      future.complete(msg);
+    } else {
+      LOG.error("A reply received for message that was not queued. trace " +
+          "ID: {}", msg.getTraceID());
+    }
-  public ContainerProtos.ContainerCommandResponseProto
-      sendCommand(ContainerProtos.ContainerCommandRequestProto request) {
-    ContainerProtos.ContainerCommandResponseProto response;
-    channel.writeAndFlush(request);
-    boolean interrupted = false;
-    for (;;) {
-      try {
-        response = responses.take();
-        break;
-      } catch (InterruptedException ignore) {
-        interrupted = true;
-      }
-    }
-
-    if (interrupted) {
-      Thread.currentThread().interrupt();
-    }
-    return response;
+  public ContainerCommandResponseProto
+    sendCommand(ContainerProtos.ContainerCommandRequestProto request)
+      throws ExecutionException, InterruptedException {
+    Future<ContainerCommandResponseProto> future = sendCommandAsync(request);
+    return future.get();
+  /**
+   * SendCommandAsyc queues a command to the Netty Subsystem and returns a
+   * CompletableFuture. This Future is marked compeleted in the channelRead0
+   * when the call comes back.
+   * @param request - Request to execute
+   * @return CompletableFuture
+   */
+  public CompletableFuture<ContainerCommandResponseProto>
+    sendCommandAsync(ContainerProtos.ContainerCommandRequestProto request) {
+    CompletableFuture<ContainerCommandResponseProto> response =
+        new CompletableFuture<>();
+
+    CompletableFuture<ContainerCommandResponseProto> previous =
+        responses.putIfAbsent(request.getTraceID(), response);
+
+    if (previous != null) {
+      LOG.error("Command with Trace already exists. Ignoring this command. " +
+              "{}. Previous Command: {}", request.getTraceID(),
+          previous.toString());
+      throw new IllegalStateException("Duplicate trace ID. Command with this " +
+          "trace ID is already executing. Please ensure that " +
+          "trace IDs are not reused. ID: " + request.getTraceID());
+    }
+
+    channel.writeAndFlush(request);
+    return response;
+  }

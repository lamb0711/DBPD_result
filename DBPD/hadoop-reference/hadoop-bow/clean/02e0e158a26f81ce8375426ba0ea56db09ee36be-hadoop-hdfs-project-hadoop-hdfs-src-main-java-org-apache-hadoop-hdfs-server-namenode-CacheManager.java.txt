HDFS-5158. Add command-line support for manipulating cache directives

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.DFSUtil;
-import org.apache.hadoop.hdfs.protocol.PathCacheDirective;
-import org.apache.hadoop.hdfs.protocol.PathCacheEntry;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.InvalidPoolNameError;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.UnexpectedAddPathCacheDirectiveException;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.PoolWritePermissionDeniedError;
-import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.InvalidIdException;
-import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.NoSuchIdException;
-import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.UnexpectedRemovePathCacheEntryException;
-import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.RemovePermissionDeniedException;
+import org.apache.hadoop.hdfs.protocol.PathBasedCacheDirective;
+import org.apache.hadoop.hdfs.protocol.PathBasedCacheEntry;
+import org.apache.hadoop.hdfs.protocol.AddPathBasedCacheDirectiveException.InvalidPoolNameError;
+import org.apache.hadoop.hdfs.protocol.AddPathBasedCacheDirectiveException.UnexpectedAddPathBasedCacheDirectiveException;
+import org.apache.hadoop.hdfs.protocol.AddPathBasedCacheDirectiveException.PoolWritePermissionDeniedError;
+import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheEntryException.InvalidIdException;
+import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheEntryException.NoSuchIdException;
+import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheEntryException.UnexpectedRemovePathBasedCacheEntryException;
+import org.apache.hadoop.hdfs.protocol.RemovePathBasedCacheEntryException.RemovePermissionDeniedException;
-   * listPathCacheEntries relies on the ordering of elements in this map 
+   * listPathBasedCacheEntries relies on the ordering of elements in this map 
-  private final TreeMap<Long, PathCacheEntry> entriesById =
-      new TreeMap<Long, PathCacheEntry>();
+  private final TreeMap<Long, PathBasedCacheEntry> entriesById =
+      new TreeMap<Long, PathBasedCacheEntry>();
-  private final TreeMap<PathCacheDirective, PathCacheEntry> entriesByDirective =
-      new TreeMap<PathCacheDirective, PathCacheEntry>();
+  private final TreeMap<PathBasedCacheDirective, PathBasedCacheEntry> entriesByDirective =
+      new TreeMap<PathBasedCacheDirective, PathBasedCacheEntry>();
-  private synchronized Fallible<PathCacheEntry> addDirective(
-        PathCacheDirective directive, FSPermissionChecker pc) {
+  private synchronized Fallible<PathBasedCacheEntry> addDirective(
+        PathBasedCacheDirective directive, FSPermissionChecker pc) {
-      return new Fallible<PathCacheEntry>(
+      return new Fallible<PathBasedCacheEntry>(
-      return new Fallible<PathCacheEntry>(
+      return new Fallible<PathBasedCacheEntry>(
-      return new Fallible<PathCacheEntry>(ioe);
+      return new Fallible<PathBasedCacheEntry>(ioe);
-    PathCacheEntry existing = entriesByDirective.get(directive);
+    PathBasedCacheEntry existing = entriesByDirective.get(directive);
-      return new Fallible<PathCacheEntry>(existing);
+      return new Fallible<PathBasedCacheEntry>(existing);
-    PathCacheEntry entry;
+    PathBasedCacheEntry entry;
-      entry = new PathCacheEntry(getNextEntryId(), directive);
+      entry = new PathBasedCacheEntry(getNextEntryId(), directive);
-      return new Fallible<PathCacheEntry>(
-          new UnexpectedAddPathCacheDirectiveException(directive));
+      return new Fallible<PathBasedCacheEntry>(
+          new UnexpectedAddPathBasedCacheDirectiveException(directive));
-    return new Fallible<PathCacheEntry>(entry);
+    return new Fallible<PathBasedCacheEntry>(entry);
-  public synchronized List<Fallible<PathCacheEntry>> addDirectives(
-      List<PathCacheDirective> directives, FSPermissionChecker pc) {
-    ArrayList<Fallible<PathCacheEntry>> results = 
-        new ArrayList<Fallible<PathCacheEntry>>(directives.size());
-    for (PathCacheDirective directive: directives) {
+  public synchronized List<Fallible<PathBasedCacheEntry>> addDirectives(
+      List<PathBasedCacheDirective> directives, FSPermissionChecker pc) {
+    ArrayList<Fallible<PathBasedCacheEntry>> results = 
+        new ArrayList<Fallible<PathBasedCacheEntry>>(directives.size());
+    for (PathBasedCacheDirective directive: directives) {
-    PathCacheEntry existing = entriesById.get(entryId);
+    PathBasedCacheEntry existing = entriesById.get(entryId);
-          new UnexpectedRemovePathCacheEntryException(entryId));
+          new UnexpectedRemovePathBasedCacheEntryException(entryId));
-          new UnexpectedRemovePathCacheEntryException(entryId));
+          new UnexpectedRemovePathBasedCacheEntryException(entryId));
-  public synchronized BatchedListEntries<PathCacheEntry> 
-        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {
+  public synchronized BatchedListEntries<PathBasedCacheEntry> 
+        listPathBasedCacheEntries(long prevId, String filterPool,
+            String filterPath, FSPermissionChecker pc) throws IOException {
-    ArrayList<PathCacheEntry> replies =
-        new ArrayList<PathCacheEntry>(NUM_PRE_ALLOCATED_ENTRIES);
-    int numReplies = 0;
-    SortedMap<Long, PathCacheEntry> tailMap = entriesById.tailMap(prevId + 1);
-    for (Entry<Long, PathCacheEntry> cur : tailMap.entrySet()) {
-      if (numReplies >= maxListCacheDirectivesResponses) {
-        return new BatchedListEntries<PathCacheEntry>(replies, true);
+    if (filterPath != null) {
+      if (!DFSUtil.isValidName(filterPath)) {
+        throw new IOException("invalid path name '" + filterPath + "'");
-      PathCacheEntry curEntry = cur.getValue();
-      if (!filterPool.isEmpty() && 
-          !cur.getValue().getDirective().getPool().equals(filterPool)) {
+    }
+    ArrayList<PathBasedCacheEntry> replies =
+        new ArrayList<PathBasedCacheEntry>(NUM_PRE_ALLOCATED_ENTRIES);
+    int numReplies = 0;
+    SortedMap<Long, PathBasedCacheEntry> tailMap = entriesById.tailMap(prevId + 1);
+    for (Entry<Long, PathBasedCacheEntry> cur : tailMap.entrySet()) {
+      if (numReplies >= maxListCacheDirectivesResponses) {
+        return new BatchedListEntries<PathBasedCacheEntry>(replies, true);
+      }
+      PathBasedCacheEntry curEntry = cur.getValue();
+      PathBasedCacheDirective directive = cur.getValue().getDirective();
+      if (filterPool != null && 
+          !directive.getPool().equals(filterPool)) {
+        continue;
+      }
+      if (filterPath != null &&
+          !directive.getPath().equals(filterPath)) {
-        LOG.error("invalid pool for PathCacheEntry " + curEntry);
+        LOG.error("invalid pool for PathBasedCacheEntry " + curEntry);
-      if (pc.checkPermission(pool, FsAction.EXECUTE)) {
+      if (pc.checkPermission(pool, FsAction.READ)) {
-    return new BatchedListEntries<PathCacheEntry>(replies, false);
+    return new BatchedListEntries<PathBasedCacheEntry>(replies, false);
-      bld.append(prefix).
-        append(String.format("set mode to 0%3o", info.getMode()));
+      bld.append(prefix).append("set mode to " + info.getMode());
-    Iterator<Entry<PathCacheDirective, PathCacheEntry>> iter = 
+    Iterator<Entry<PathBasedCacheDirective, PathBasedCacheEntry>> iter = 
-      Entry<PathCacheDirective, PathCacheEntry> entry = iter.next();
+      Entry<PathBasedCacheDirective, PathBasedCacheEntry> entry = iter.next();

Merge remote-tracking branch 'apache/trunk' into HDFS-7285

Conflicts:
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSConfigKeys.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java
	hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Namesystem.java
	hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/DFSTestUtil.java

Change-Id: I8511c4d64b0959e79129febc179845a3892fedcc

-import org.apache.commons.logging.impl.Log4JLogger;
+import org.apache.hadoop.hdfs.client.HdfsClientConfigKeys;
+import org.apache.hadoop.hdfs.server.common.MetricsLoggerTask;
-import org.apache.log4j.Appender;
-import org.apache.log4j.AsyncAppender;
-import javax.management.Attribute;
-import javax.management.AttributeList;
-import javax.management.MBeanAttributeInfo;
-import javax.management.MBeanInfo;
-import javax.management.MBeanServer;
-import javax.management.MalformedObjectNameException;
-import java.lang.management.ManagementFactory;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
+import static org.apache.hadoop.hdfs.client.HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT;
-  public static final int DEFAULT_PORT = 8020;
+  /**
+   * @deprecated Use {@link HdfsClientConfigKeys#DFS_NAMENODE_RPC_PORT_DEFAULT}
+   *             instead.
+   */
+  @Deprecated
+  public static final int DEFAULT_PORT = DFS_NAMENODE_RPC_PORT_DEFAULT;
-  public static InetSocketAddress getAddress(String address) {
-    return NetUtils.createSocketAddr(address, DEFAULT_PORT);
-  }
-  
-      return fallback ? getAddress(conf) : null;
+      return fallback ? DFSUtilClient.getNNAddress(conf) : null;
-    return getAddress(addr);
-  }
-
-  public static InetSocketAddress getAddress(Configuration conf) {
-    URI filesystemURI = FileSystem.getDefaultUri(conf);
-    return getAddress(filesystemURI);
-  }
-
-
-  /**
-   * @return address of file system
-   */
-  public static InetSocketAddress getAddress(URI filesystemURI) {
-    String authority = filesystemURI.getAuthority();
-    if (authority == null) {
-      throw new IllegalArgumentException(String.format(
-          "Invalid URI for NameNode address (check %s): %s has no authority.",
-          FileSystem.FS_DEFAULT_NAME_KEY, filesystemURI.toString()));
-    }
-    if (!HdfsConstants.HDFS_URI_SCHEME.equalsIgnoreCase(
-        filesystemURI.getScheme())) {
-      throw new IllegalArgumentException(String.format(
-          "Invalid URI for NameNode address (check %s): %s is not of scheme '%s'.",
-          FileSystem.FS_DEFAULT_NAME_KEY, filesystemURI.toString(),
-          HdfsConstants.HDFS_URI_SCHEME));
-    }
-    return getAddress(authority);
-  }
-
-  public static URI getUri(InetSocketAddress namenode) {
-    int port = namenode.getPort();
-    String portString = port == DEFAULT_PORT ? "" : (":"+port);
-    return URI.create(HdfsConstants.HDFS_URI_SCHEME + "://"
-        + namenode.getHostName()+portString);
+    return DFSUtilClient.getNNAddress(addr);
-    return getAddress(conf);
+    return DFSUtilClient.getNNAddress(conf);
-    FileSystem.setDefaultUri(conf, getUri(rpcAddress));
+    FileSystem.setDefaultUri(conf, DFSUtilClient.getNNUri(rpcAddress));
-    makeMetricsLoggerAsync();
+    MetricsLoggerTask.makeMetricsLoggerAsync(MetricsLog);
-    metricsLoggerTimer.scheduleWithFixedDelay(new MetricsLoggerTask(),
+    metricsLoggerTimer.scheduleWithFixedDelay(new MetricsLoggerTask(MetricsLog,
+        "NameNode", (short) 128),
-  /**
-   * Make the metrics logger async and add all pre-existing appenders
-   * to the async appender.
-   */
-  private static void makeMetricsLoggerAsync() {
-    if (!(MetricsLog instanceof Log4JLogger)) {
-      LOG.warn(
-          "Metrics logging will not be async since the logger is not log4j");
-      return;
-    }
-    org.apache.log4j.Logger logger = ((Log4JLogger) MetricsLog).getLogger();
-    logger.setAdditivity(false);  // Don't pollute NN logs with metrics dump
-
-    @SuppressWarnings("unchecked")
-    List<Appender> appenders = Collections.list(logger.getAllAppenders());
-    // failsafe against trying to async it more than once
-    if (!appenders.isEmpty() && !(appenders.get(0) instanceof AsyncAppender)) {
-      AsyncAppender asyncAppender = new AsyncAppender();
-      // change logger to have an async appender containing all the
-      // previously configured appenders
-      for (Appender appender : appenders) {
-        logger.removeAppender(appender);
-        asyncAppender.addAppender(appender);
-      }
-      logger.addAppender(asyncAppender);
-    }
-  }
-
-      InetSocketAddress socAddr = getAddress(conf);
+      InetSocketAddress socAddr = DFSUtilClient.getNNAddress(conf);
-      InetSocketAddress socAddr = getAddress(conf);
+      InetSocketAddress socAddr = DFSUtilClient.getNNAddress(conf);
-
-  private static class MetricsLoggerTask implements Runnable {
-    private static final int MAX_LOGGED_VALUE_LEN = 128;
-    private static ObjectName OBJECT_NAME = null;
-
-    static {
-      try {
-        OBJECT_NAME = new ObjectName("Hadoop:*");
-      } catch (MalformedObjectNameException m) {
-        // This should not occur in practice since we pass
-        // a valid pattern to the constructor above.
-      }
-    }
-
-    /**
-     * Write NameNode metrics to the metrics appender when invoked.
-     */
-    @Override
-    public void run() {
-      // Skip querying metrics if there are no known appenders.
-      if (!MetricsLog.isInfoEnabled() ||
-          !hasAppenders(MetricsLog) ||
-          OBJECT_NAME == null) {
-        return;
-      }
-
-      MetricsLog.info(" >> Begin NameNode metrics dump");
-      final MBeanServer server = ManagementFactory.getPlatformMBeanServer();
-
-      // Iterate over each MBean.
-      for (final ObjectName mbeanName : server.queryNames(OBJECT_NAME, null)) {
-        try {
-          MBeanInfo mBeanInfo = server.getMBeanInfo(mbeanName);
-          final String mBeanNameName = MBeans.getMbeanNameName(mbeanName);
-          final Set<String> attributeNames = getFilteredAttributes(mBeanInfo);
-
-          final AttributeList attributes =
-              server.getAttributes(mbeanName,
-                  attributeNames.toArray(new String[attributeNames.size()]));
-
-          for (Object o : attributes) {
-            final Attribute attribute = (Attribute) o;
-            final Object value = attribute.getValue();
-            final String valueStr =
-                (value != null) ? value.toString() : "null";
-            // Truncate the value if it is too long
-            MetricsLog.info(mBeanNameName + ":" + attribute.getName() + "=" +
-                (valueStr.length() < MAX_LOGGED_VALUE_LEN ? valueStr :
-                    valueStr.substring(0, MAX_LOGGED_VALUE_LEN) + "..."));
-          }
-        } catch (Exception e) {
-          MetricsLog.error("Failed to get NameNode metrics for mbean " +
-              mbeanName.toString(), e);
-        }
-      }
-      MetricsLog.info(" << End NameNode metrics dump");
-    }
-
-    private static boolean hasAppenders(Log logger) {
-      if (!(logger instanceof Log4JLogger)) {
-        // Don't bother trying to determine the presence of appenders.
-        return true;
-      }
-      Log4JLogger log4JLogger = ((Log4JLogger) MetricsLog);
-      return log4JLogger.getLogger().getAllAppenders().hasMoreElements();
-    }
-
-    /**
-     * Get the list of attributes for the MBean, filtering out a few
-     * attribute types.
-     */
-    private static Set<String> getFilteredAttributes(
-        MBeanInfo mBeanInfo) {
-      Set<String> attributeNames = new HashSet<>();
-      for (MBeanAttributeInfo attributeInfo : mBeanInfo.getAttributes()) {
-        if (!attributeInfo.getType().equals(
-                "javax.management.openmbean.TabularData") &&
-            !attributeInfo.getType().equals(
-                "javax.management.openmbean.CompositeData") &&
-            !attributeInfo.getType().equals(
-                "[Ljavax.management.openmbean.CompositeData;")) {
-          attributeNames.add(attributeInfo.getName());
-        }
-      }
-      return attributeNames;
-    }
-  }

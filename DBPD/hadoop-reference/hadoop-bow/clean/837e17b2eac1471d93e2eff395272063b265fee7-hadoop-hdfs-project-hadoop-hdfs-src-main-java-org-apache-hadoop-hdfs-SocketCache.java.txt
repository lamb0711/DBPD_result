svn merge -c -1430507 . for reverting HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430662 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.Closeable;
+import java.net.Socket;
+import java.net.SocketAddress;
+
-import com.google.common.annotations.VisibleForTesting;
+import java.io.IOException;
+import org.apache.hadoop.HadoopIllegalArgumentException;
-import org.apache.hadoop.hdfs.protocol.DatanodeID;
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.hdfs.protocol.datatransfer.IOStreamPair;
-import org.apache.hadoop.hdfs.net.Peer;
+import org.apache.hadoop.util.StringUtils;
-class PeerCache {
-  private static final Log LOG = LogFactory.getLog(PeerCache.class);
-  
-  private static class Value {
-    private final Peer peer;
-    private final long time;
+class SocketCache {
+  private static final Log LOG = LogFactory.getLog(SocketCache.class);
-    Value(Peer peer, long time) {
-      this.peer = peer;
-      this.time = time;
+  @InterfaceAudience.Private
+  static class SocketAndStreams implements Closeable {
+    public final Socket sock;
+    public final IOStreamPair ioStreams;
+    long createTime;
+    
+    public SocketAndStreams(Socket s, IOStreamPair ioStreams) {
+      this.sock = s;
+      this.ioStreams = ioStreams;
+      this.createTime = Time.monotonicNow();
+    }
+    
+    @Override
+    public void close() {
+      if (ioStreams != null) { 
+        IOUtils.closeStream(ioStreams.in);
+        IOUtils.closeStream(ioStreams.out);
+      }
+      IOUtils.closeSocket(sock);
-    Peer getPeer() {
-      return peer;
-    }
-
-    long getTime() {
-      return time;
+    public long getCreateTime() {
+      return this.createTime;
-  private static LinkedListMultimap<DatanodeID, Value> multimap =
+  private static LinkedListMultimap<SocketAddress, SocketAndStreams> multimap =
-  private static PeerCache instance = new PeerCache();
+  private static SocketCache scInstance = new SocketCache();
-  public static synchronized PeerCache getInstance(int c, long e) {
+  public static synchronized SocketCache getInstance(int c, long e) {
-    return instance;
+    return scInstance;
-          PeerCache.this.run();
+          SocketCache.this.run();
-          PeerCache.this.clear();
+          SocketCache.this.clear();
-        return String.valueOf(PeerCache.this);
+        return String.valueOf(SocketCache.this);
-   * Get a cached peer connected to the given DataNode.
-   * @param dnId         The DataNode to get a Peer for.
-   * @return             An open Peer connected to the DN, or null if none
-   *                     was found. 
+   * Get a cached socket to the given address.
+   * @param remote  Remote address the socket is connected to.
+   * @return  A socket with unknown state, possibly closed underneath. Or null.
-  public synchronized Peer get(DatanodeID dnId) {
+  public synchronized SocketAndStreams get(SocketAddress remote) {
-    List<Value> sockStreamList = multimap.get(dnId);
+    List<SocketAndStreams> sockStreamList = multimap.get(remote);
-    Iterator<Value> iter = sockStreamList.iterator();
+    Iterator<SocketAndStreams> iter = sockStreamList.iterator();
-      Value candidate = iter.next();
+      SocketAndStreams candidate = iter.next();
-      if (!candidate.getPeer().isClosed()) {
-        return candidate.getPeer();
+      if (!candidate.sock.isClosed()) {
+        return candidate;
-  public synchronized void put(DatanodeID dnId, Peer peer) {
-    Preconditions.checkNotNull(dnId);
-    Preconditions.checkNotNull(peer);
-    if (peer.isClosed()) return;
+  public synchronized void put(Socket sock, IOStreamPair ioStreams) {
+
+    Preconditions.checkNotNull(sock);
+    SocketAndStreams s = new SocketAndStreams(sock, ioStreams);
-      IOUtils.cleanup(LOG, peer);
+      s.close();
+    SocketAddress remoteAddr = sock.getRemoteSocketAddress();
+    if (remoteAddr == null) {
+      LOG.warn("Cannot cache (unconnected) socket with no remote address: " +
+               sock);
+      IOUtils.closeSocket(sock);
+      return;
+    }
+
-    multimap.put(dnId, new Value(peer, Time.monotonicNow()));
+    multimap.put(remoteAddr, s);
-      Iterator<Entry<DatanodeID, Value>> iter =
+      Iterator<Entry<SocketAddress, SocketAndStreams>> iter =
-      Entry<DatanodeID, Value> entry = iter.next();
+      Entry<SocketAddress, SocketAndStreams> entry = iter.next();
-        Time.monotonicNow() - entry.getValue().getTime() <
+        Time.monotonicNow() - entry.getValue().getCreateTime() < 
-      IOUtils.cleanup(LOG, entry.getValue().getPeer());
+      SocketAndStreams s = entry.getValue();
+      s.close();
-    // We can get the oldest element immediately, because of an interesting
-    // property of LinkedListMultimap: its iterator traverses entries in the
-    // order that they were added.
-    Iterator<Entry<DatanodeID, Value>> iter =
+    Iterator<Entry<SocketAddress, SocketAndStreams>> iter =
-    Entry<DatanodeID, Value> entry = iter.next();
-    IOUtils.cleanup(LOG, entry.getValue().getPeer());
+    Entry<SocketAddress, SocketAndStreams> entry = iter.next();
+    SocketAndStreams s = entry.getValue();
+    s.close();
-  @VisibleForTesting
-  synchronized void clear() {
-    for (Value value : multimap.values()) {
-      IOUtils.cleanup(LOG, value.getPeer());
+  private synchronized void clear() {
+    for (SocketAndStreams sockAndStream : multimap.values()) {
+      sockAndStream.close();

YARN-5554. MoveApplicationAcrossQueues does not check user permission on the target queue
(Contributed by Wilfred Spiegelenburg via Daniel Templeton)

+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FSQueue;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler;
-        // Application exists but the associated queue does not exist.
-        // This may be due to queue is removed after RM restarts. Here, we choose
-        // to allow users to be able to view the apps for removed queue.
+        // The application exists but the associated queue does not exist.
+        // This may be due to a queue that is not defined when the RM restarts.
+        // At this point we choose to log the fact and allow users to access
+        // and view the apps in a removed queue. This should only happen on
+        // application recovery.
+
+  /**
+   * Check access to a targetQueue in the case of a move of an application.
+   * The application cannot contain the destination queue since it has not
+   * been moved yet, thus need to pass it in separately.
+   *
+   * @param callerUGI the caller UGI
+   * @param acl the acl for the Queue to check
+   * @param app the application to move
+   * @param remoteAddress server ip address
+   * @param forwardedAddresses forwarded adresses
+   * @param targetQueue the name of the queue to move the application to
+   * @return true: if submission is allowed and queue exists,
+   *         false: in all other cases (also non existing target queue)
+   */
+  public boolean checkAccess(UserGroupInformation callerUGI, QueueACL acl,
+      RMApp app, String remoteAddress, List<String> forwardedAddresses,
+      String targetQueue) {
+    if (!isACLsEnable) {
+      return true;
+    }
+
+    // Based on the discussion in YARN-5554 detail on why there are two
+    // versions:
+    // The access check inside these calls is currently scheduler dependent.
+    // This is due to the extra parameters needed for the CS case which are not
+    // in the version defined in the YarnScheduler interface. The second
+    // version is added for the moving the application case. The check has
+    // extra logging to distinguish between the queue not existing in the
+    // application move request case and the real access denied case.
+
+    if (scheduler instanceof CapacityScheduler) {
+      CSQueue queue = ((CapacityScheduler) scheduler).getQueue(targetQueue);
+      if (queue == null) {
+        LOG.warn("Target queue " + targetQueue
+            + " does not exist while trying to move "
+            + app.getApplicationId());
+        return false;
+      }
+      return authorizer.checkPermission(
+          new AccessRequest(queue.getPrivilegedEntity(), callerUGI,
+              SchedulerUtils.toAccessType(acl),
+              app.getApplicationId().toString(), app.getName(),
+              remoteAddress, forwardedAddresses));
+    } else if (scheduler instanceof FairScheduler) {
+      FSQueue queue = ((FairScheduler) scheduler).getQueueManager().
+          getQueue(targetQueue);
+      if (queue == null) {
+        LOG.warn("Target queue " + targetQueue
+            + " does not exist while trying to move "
+            + app.getApplicationId());
+        return false;
+      }
+      return scheduler.checkAccess(callerUGI, acl, targetQueue);
+    } else {
+      // Any other scheduler just try
+      return scheduler.checkAccess(callerUGI, acl, targetQueue);
+    }
+  }

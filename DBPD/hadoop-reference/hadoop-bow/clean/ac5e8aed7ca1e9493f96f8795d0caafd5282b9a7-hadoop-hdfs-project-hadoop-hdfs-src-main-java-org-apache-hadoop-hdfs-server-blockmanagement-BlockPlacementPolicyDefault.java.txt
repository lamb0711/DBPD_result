HDFS-6686. Change BlockPlacementPolicy to use fallback when some storage types are unavailable.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-6584@1612880 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.EnumSet;
-        blocksize, maxNodesPerRack, results, avoidStaleNodes, storagePolicy);
+        blocksize, maxNodesPerRack, results, avoidStaleNodes, storagePolicy,
+        EnumSet.noneOf(StorageType.class), results.isEmpty());
-    
+
+  private static List<StorageType> selectStorageTypes(
+      final BlockStoragePolicy storagePolicy,
+      final short replication,
+      final Iterable<StorageType> chosen,
+      final EnumSet<StorageType> unavailableStorages,
+      final boolean isNewBlock) {
+    final List<StorageType> storageTypes = storagePolicy.chooseStorageTypes(
+        replication, chosen);
+    final List<StorageType> removed = new ArrayList<StorageType>();
+    for(int i = storageTypes.size() - 1; i >= 0; i--) {
+      // replace/remove unavailable storage types.
+      final StorageType t = storageTypes.get(i);
+      if (unavailableStorages.contains(t)) {
+        final StorageType fallback = isNewBlock?
+            storagePolicy.getCreationFallback(unavailableStorages)
+            : storagePolicy.getReplicationFallback(unavailableStorages);
+        if (fallback == null) {
+          removed.add(storageTypes.remove(i));
+        } else {
+          storageTypes.set(i, fallback);
+        }
+      }
+    }
+    if (storageTypes.size() < replication) {
+      LOG.warn("Failed to place enough replicas: replication is " + replication
+          + " but only " + storageTypes.size() + " storage types can be selected "
+          + "(selected=" + storageTypes
+          + ", unavailable=" + unavailableStorages
+          + ", removed=" + removed
+          + ", policy=" + storagePolicy + ")");
+    }
+    return storageTypes;
+  }
-                            final BlockStoragePolicy storagePolicy) {
+                            final BlockStoragePolicy storagePolicy,
+                            final EnumSet<StorageType> unavailableStorages,
+                            final boolean newBlock) {
-    int totalReplicasExpected = numOfReplicas + results.size();
-      
-    int numOfResults = results.size();
-    boolean newBlock = (numOfResults==0);
+    final int numOfResults = results.size();
+    final int totalReplicasExpected = numOfReplicas + numOfResults;
-    final List<StorageType> storageTypes = storagePolicy.chooseStorageTypes(
-        (short)totalReplicasExpected, DatanodeStorageInfo.toStorageTypes(results));
+
+    // choose storage types; use fallbacks for unavailable storages
+    final List<StorageType> storageTypes = selectStorageTypes(storagePolicy,
+        (short)totalReplicasExpected, DatanodeStorageInfo.toStorageTypes(results),
+        unavailableStorages, newBlock);
+
+    StorageType curStorageType = null;
+      if ((numOfReplicas = storageTypes.size()) == 0) {
+        throw new NotEnoughReplicasException(
+            "All required storage types are unavailable: "
+            + " unavailableStorages=" + unavailableStorages
+            + ", storagePolicy=" + storagePolicy);
+      }
+
+        curStorageType = storageTypes.remove(0);
-            maxNodesPerRack, results, avoidStaleNodes, storageTypes.remove(0), true)
+            maxNodesPerRack, results, avoidStaleNodes, curStorageType, true)
+        curStorageType = storageTypes.remove(0);
-            results, avoidStaleNodes, storageTypes.remove(0));
+            results, avoidStaleNodes, curStorageType);
+        curStorageType = storageTypes.remove(0);
-              results, avoidStaleNodes, storageTypes.remove(0));
+              results, avoidStaleNodes, curStorageType);
-              results, avoidStaleNodes, storageTypes.remove(0));
+              results, avoidStaleNodes, curStorageType);
-              results, avoidStaleNodes, storageTypes.remove(0));
+              results, avoidStaleNodes, curStorageType);
+      curStorageType = storageTypes.remove(0);
-          maxNodesPerRack, results, avoidStaleNodes, storageTypes.remove(0));
+          maxNodesPerRack, results, avoidStaleNodes, curStorageType);
-            maxNodesPerRack, results, false, storagePolicy);
+            maxNodesPerRack, results, false, storagePolicy, unavailableStorages,
+            newBlock);
+      }
+
+      if (storageTypes.size() > 0) {
+        // Retry chooseTarget with fallback storage types
+        unavailableStorages.add(curStorageType);
+        return chooseTarget(numOfReplicas, writer, excludedNodes, blocksize,
+            maxNodesPerRack, results, false, storagePolicy, unavailableStorages,
+            newBlock);

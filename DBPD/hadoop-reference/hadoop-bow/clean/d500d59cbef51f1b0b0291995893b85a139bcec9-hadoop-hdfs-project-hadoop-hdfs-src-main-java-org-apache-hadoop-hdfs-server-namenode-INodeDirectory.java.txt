Merging trunk to HDFS-2802 branch.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1416603 13f79535-47bb-0310-9956-ffa450edef68

-
+  
-  private int searchChildren(INode inode) {
+  public int searchChildren(INode inode) {
-  INode removeChild(INode node) {
+  public int searchChildrenForExistingINode(INode inode) {
+    final int i = searchChildren(inode);
+    if (i < 0) {
+      throw new AssertionError("Child not found: inode=" + inode);
+    }
+    return i;
+  }
+
+  public INode removeChild(INode node, Snapshot latestSnapshot) {
+
+    if (latestSnapshot != null) {
+      final INodeDirectoryWithSnapshot dir
+          = INodeDirectoryWithSnapshot.replaceDir(this, latestSnapshot);
+      return dir.removeChild(node, latestSnapshot);
+    }
+
-
-  void replaceChild(INode newChild) {
+  public INode replaceChild(INodeDirectory newChild, Snapshot latestSnapshot) {
-    final int low = searchChildren(newChild);
-    if (low>=0) { // an old child exists so replace by the newChild
-      children.set(low, newChild);
-    } else {
-      throw new IllegalArgumentException("No child exists to be replaced");
+    if (latestSnapshot != null) {
+      final INodeDirectoryWithSnapshot dir
+          = INodeDirectoryWithSnapshot.replaceDir(this, latestSnapshot);
+      return dir.replaceChild(newChild, latestSnapshot);
+
+    // find the old child and replace it
+    final int low = searchChildrenForExistingINode(newChild);
+    final INode oldChild = children.set(low, newChild);
+    // set the parent of the children of the child.
+    for(INode i : newChild.getChildrenList(null)) {
+      i.parent = newChild;
+    }
+    return oldChild;
-  private INode getChild(byte[] name, Snapshot snapshot) {
+  public INode getChild(byte[] name, Snapshot snapshot) {
+    assertNull(snapshot);
+
-  public boolean addChild(final INode node, final boolean setModTime) {
+  public boolean addChild(final INode node, final boolean setModTime,
+      Snapshot latestSnapshot) {
+    if (latestSnapshot != null) {
+      final INodeDirectoryWithSnapshot dir
+          = INodeDirectoryWithSnapshot.replaceDir(this, latestSnapshot);
+      return dir.addChild(node, setModTime, latestSnapshot);
+    }
+
-    if (setModTime)
-      setModificationTime(node.getModificationTime());
+    if (setModTime) {
+      updateModificationTime(node.getModificationTime());
+    }
-    INodeDirectory parent = getParent(pathComponents);
-    return parent.addChild(newNode, true);
+    INodesInPath inodes =  getExistingPathINodes(pathComponents, 2, false);
+    INodeDirectory parent = INodeDirectory.valueOf(inodes.inodes[0], pathComponents);
+    return parent.addChild(newNode, true, inodes.getLatestSnapshot());
+    return (INodeDirectory)getParentINodesInPath(pathComponents).getINode(0);
+  }
+
+  INodesInPath getParentINodesInPath(byte[][] pathComponents
+      ) throws FileNotFoundException, PathIsNotDirectoryException,
+      UnresolvedLinkException {
-    return INodeDirectory.valueOf(inodes.inodes[0], pathComponents);
+    INodeDirectory.valueOf(inodes.inodes[0], pathComponents);
+    return inodes;
-
+  
-    //TODO: use snapshot to select children list
+    assertNull(snapshot);
+
-  static class INodesInPath {
+  public static class INodesInPath {
-    INode getINode(int i) {
+    public INode getINode(int i) {
+
+  /** 
+   * Get last modification time of inode.
+   * @return access time
+   */
+  public long getModificationTime(Snapshot snapshot) {
+    assertNull(snapshot);
+    return getModificationTime();
+  }

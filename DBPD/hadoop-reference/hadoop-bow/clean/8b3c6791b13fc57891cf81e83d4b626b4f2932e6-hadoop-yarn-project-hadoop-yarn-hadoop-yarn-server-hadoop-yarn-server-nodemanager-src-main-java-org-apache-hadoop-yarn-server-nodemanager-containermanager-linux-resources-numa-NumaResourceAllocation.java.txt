YARN-9135. NM State store ResourceMappings serialization are tested with Strings instead of real Device objects. Contributed by Peter Bacsko

+import com.google.common.collect.ImmutableMap;
+
-import java.util.HashMap;
+import java.util.Objects;
-  private Map<String, Long> nodeVsMemory;
-  private Map<String, Integer> nodeVsCpus;
+  private final ImmutableMap<String, Long> nodeVsMemory;
+  private final ImmutableMap<String, Integer> nodeVsCpus;
-  public NumaResourceAllocation() {
-    nodeVsMemory = new HashMap<>();
-    nodeVsCpus = new HashMap<>();
+  public NumaResourceAllocation(Map<String, Long> memoryAllocations,
+      Map<String, Integer> cpuAllocations) {
+    nodeVsMemory = ImmutableMap.copyOf(memoryAllocations);
+    nodeVsCpus = ImmutableMap.copyOf(cpuAllocations);
-    this();
-    nodeVsMemory.put(memNodeId, memory);
-    nodeVsCpus.put(cpuNodeId, cpus);
-  }
-
-  public void addMemoryNode(String memNodeId, long memory) {
-    nodeVsMemory.put(memNodeId, memory);
-  }
-
-  public void addCpuNode(String cpuNodeId, int cpus) {
-    nodeVsCpus.put(cpuNodeId, cpus);
+    this(ImmutableMap.of(memNodeId, memory), ImmutableMap.of(cpuNodeId, cpus));
-  public Map<String, Long> getNodeVsMemory() {
+  public ImmutableMap<String, Long> getNodeVsMemory() {
-  public Map<String, Integer> getNodeVsCpus() {
+  public ImmutableMap<String, Integer> getNodeVsCpus() {
-}
+
+  @Override
+  public String toString() {
+    return "NumaResourceAllocation{" +
+        "nodeVsMemory=" + nodeVsMemory +
+        ", nodeVsCpus=" + nodeVsCpus +
+        '}';
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    NumaResourceAllocation that = (NumaResourceAllocation) o;
+    return Objects.equals(nodeVsMemory, that.nodeVsMemory) &&
+        Objects.equals(nodeVsCpus, that.nodeVsCpus);
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(nodeVsMemory, nodeVsCpus);
+  }
+}

HDFS-13110: [SPS]: Reduce the number of APIs in NamenodeProtocol used by external satisfier. Contributed by Rakesh R.

- * where users may want to physically move the blocks by a dedidated daemon (can
+ * where users may want to physically move the blocks by a dedicated daemon (can
-public class StoragePolicySatisfier implements SPSService, Runnable {
+public class StoragePolicySatisfier<T> implements SPSService<T>, Runnable {
-  private BlockStorageMovementNeeded storageMovementNeeded;
-  private BlockStorageMovementAttemptedItems storageMovementsMonitor;
+  private BlockStorageMovementNeeded<T> storageMovementNeeded;
+  private BlockStorageMovementAttemptedItems<T> storageMovementsMonitor;
-  private Context ctxt;
+  private Context<T> ctxt;
-  public void init(final Context context, final FileIdCollector fileIDCollector,
+  public void init(final Context<T> context,
+      final FileCollector<T> fileIDCollector,
-    this.storageMovementNeeded =
-        new BlockStorageMovementNeeded(context, fileIDCollector);
-    this.storageMovementsMonitor =
-        new BlockStorageMovementAttemptedItems(this,
-        storageMovementNeeded, blockMovementListener);
+    this.storageMovementNeeded = new BlockStorageMovementNeeded<T>(context,
+        fileIDCollector);
+    this.storageMovementsMonitor = new BlockStorageMovementAttemptedItems<T>(
+        this, storageMovementNeeded, blockMovementListener);
+        ItemInfo<T> itemInfo = null;
+        boolean retryItem = false;
-          ItemInfo itemInfo = storageMovementNeeded.get();
+          itemInfo = storageMovementNeeded.get();
-                  + itemInfo.getFileId() + " from the queue");
+                  + itemInfo.getFile() + " from the queue");
-            long trackId = itemInfo.getFileId();
+            T trackId = itemInfo.getFile();
-            boolean hasLowRedundancyBlocks = ctxt
-                .hasLowRedundancyBlocks(trackId);
-                  hasLowRedundancyBlocks, existingStoragePolicy, liveDnReports);
+                  existingStoragePolicy, liveDnReports);
-                this.storageMovementsMonitor.add(new AttemptedItemInfo(itemInfo
-                    .getStartId(), itemInfo.getFileId(), monotonicNow(),
+                this.storageMovementsMonitor.add(new AttemptedItemInfo<T>(
+                    itemInfo.getStartPath(), itemInfo.getFile(), monotonicNow(),
-                itemInfo.increRetryCount();
-                this.storageMovementNeeded.add(itemInfo);
+                retryItem = true;
-                itemInfo.increRetryCount();
-                this.storageMovementNeeded.add(itemInfo);
+                retryItem = true;
-                this.storageMovementNeeded.add(itemInfo);
+                retryItem = true;
+        if (retryItem) {
+          itemInfo.increRetryCount();
+          this.storageMovementNeeded.add(itemInfo);
+        }
-      HdfsLocatedFileStatus fileInfo, boolean hasLowRedundancyBlocks,
+      HdfsLocatedFileStatus fileInfo,
-
+    boolean hasLowRedundancyBlocks = false;
+    int replication = fileInfo.getReplication();
+
+      // Block is considered as low redundancy when the block locations array
+      // length is less than expected replication factor. If any of the block is
+      // low redundant, then hasLowRedundancyBlocks will be marked as true.
+      hasLowRedundancyBlocks |= isLowRedundancyBlock(blockInfo, replication,
+          ecPolicy);
+
-      } else if (hasLowRedundancyBlocks
-          && status != BlocksMovingAnalysis.Status.BLOCKS_TARGETS_PAIRED) {
-        // Check if the previous block was successfully paired.
-        status = BlocksMovingAnalysis.Status.FEW_LOW_REDUNDANCY_BLOCKS;
+    // If there is no block paired and few blocks are low redundant, so marking
+    // the status as FEW_LOW_REDUNDANCY_BLOCKS.
+    if (hasLowRedundancyBlocks
+        && status == BlocksMovingAnalysis.Status.NO_BLOCKS_TARGETS_PAIRED) {
+      status = BlocksMovingAnalysis.Status.FEW_LOW_REDUNDANCY_BLOCKS;
+    }
+   * The given block is considered as low redundancy when the block locations
+   * length is less than expected replication factor. For EC blocks, redundancy
+   * is the summation of data + parity blocks.
+   *
+   * @param blockInfo
+   *          block
+   * @param replication
+   *          replication factor of the given file block
+   * @param ecPolicy
+   *          erasure coding policy of the given file block
+   * @return true if the given block is low redundant.
+   */
+  private boolean isLowRedundancyBlock(LocatedBlock blockInfo, int replication,
+      ErasureCodingPolicy ecPolicy) {
+    boolean hasLowRedundancyBlock = false;
+    if (blockInfo.isStriped()) {
+      // For EC blocks, redundancy is the summation of data + parity blocks.
+      replication = ecPolicy.getNumDataUnits() + ecPolicy.getNumParityUnits();
+    }
+    // block is considered as low redundancy when the block locations length is
+    // less than expected replication factor.
+    hasLowRedundancyBlock = blockInfo.getLocations().length < replication ? true
+        : false;
+    return hasLowRedundancyBlock;
+  }
+
+  /**
-  BlockStorageMovementAttemptedItems getAttemptedItemsMonitor() {
+  public BlockStorageMovementAttemptedItems<T> getAttemptedItemsMonitor() {
-  public void clearQueue(long trackId) {
+  public void clearQueue(T trackId) {
-  final static class AttemptedItemInfo extends ItemInfo {
+  final static class AttemptedItemInfo<T> extends ItemInfo<T> {
-    AttemptedItemInfo(long rootId, long trackId,
+    AttemptedItemInfo(T rootId, T trackId,
+  /**
+   * Returns sps invoked path status. This method is used by internal satisfy
+   * storage policy service.
+   *
+   * @param path
+   *          sps path
+   * @return storage policy satisfy path status
+   * @throws IOException
+   */
-  public void addFileIdToProcess(ItemInfo trackInfo, boolean scanCompleted) {
+  public void addFileToProcess(ItemInfo<T> trackInfo, boolean scanCompleted) {
-          + "storageMovementNeeded queue", trackInfo.getFileId());
+          + "storageMovementNeeded queue", trackInfo.getFile());
-  public void addAllFileIdsToProcess(long startId, List<ItemInfo> itemInfoList,
+  public void addAllFilesToProcess(T startPath, List<ItemInfo<T>> itemInfoList,
-    getStorageMovementQueue().addAll(startId, itemInfoList, scanCompleted);
+    getStorageMovementQueue().addAll(startPath, itemInfoList, scanCompleted);
-  public BlockStorageMovementNeeded getStorageMovementQueue() {
+  public BlockStorageMovementNeeded<T> getStorageMovementQueue() {
-  public void markScanCompletedForPath(Long inodeId) {
+  public void markScanCompletedForPath(T inodeId) {
-    //TODO Add join here on SPS rpc server also

HDDS-358. Use DBStore and TableStore for DeleteKeyService. Contributed by Anu Engineer

- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership.  The ASF
+ * licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+import com.google.common.annotations.VisibleForTesting;
-import org.apache.hadoop.ozone.common.DeleteBlockGroupResult;
-import org.apache.hadoop.ozone.common.BlockGroup;
-import org.apache.hadoop.util.StringUtils;
+import org.apache.hadoop.hdfs.DFSUtil;
+import org.apache.hadoop.ozone.common.BlockGroup;
+import org.apache.hadoop.ozone.common.DeleteBlockGroupResult;
+import org.apache.hadoop.utils.db.Table;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import java.util.concurrent.atomic.AtomicLong;
- * This is the background service to delete keys.
- * Scan the metadata of om periodically to get
- * the keys with prefix "#deleting" and ask scm to
- * delete metadata accordingly, if scm returns
- * success for keys, then clean up those keys.
+ * This is the background service to delete keys. Scan the metadata of om
+ * periodically to get the keys from DeletedTable and ask scm to delete
+ * metadata accordingly, if scm returns success for keys, then clean up those
+ * keys.
-
+  private final AtomicLong deletedKeyCount;
+  private final AtomicLong runCount;
+    this.deletedKeyCount = new AtomicLong(0);
+    this.runCount = new AtomicLong(0);
+  }
+
+  /**
+   * Returns the number of times this Background service has run.
+   *
+   * @return Long, run count.
+   */
+  @VisibleForTesting
+  public AtomicLong getRunCount() {
+    return runCount;
+  }
+
+  /**
+   * Returns the number of keys deleted by the background service.
+   *
+   * @return Long count.
+   */
+  @VisibleForTesting
+  public AtomicLong getDeletedKeyCount() {
+    return deletedKeyCount;
-   * A key deleting task scans OM DB and looking for a certain number
-   * of pending-deletion keys, sends these keys along with their associated
-   * blocks to SCM for deletion. Once SCM confirms keys are deleted (once
-   * SCM persisted the blocks info in its deletedBlockLog), it removes
-   * these keys from the DB.
+   * A key deleting task scans OM DB and looking for a certain number of
+   * pending-deletion keys, sends these keys along with their associated blocks
+   * to SCM for deletion. Once SCM confirms keys are deleted (once SCM persisted
+   * the blocks info in its deletedBlockLog), it removes these keys from the
+   * DB.
+      runCount.incrementAndGet();
-        if (keyBlocksList.size() > 0) {
-          LOG.info("Found {} to-delete keys in OM", keyBlocksList.size());
+        if (keyBlocksList != null && keyBlocksList.size() > 0) {
-          for (DeleteBlockGroupResult result : results) {
-            if (result.isSuccess()) {
-              try {
-                // Purge key from OM DB.
-                manager.deletePendingDeletionKey(result.getObjectKey());
-                LOG.debug("Key {} deleted from OM DB", result.getObjectKey());
-              } catch (IOException e) {
-                // if a pending deletion key is failed to delete,
-                // print a warning here and retain it in this state,
-                // so that it can be attempt to delete next time.
-                LOG.warn("Failed to delete pending-deletion key {}",
-                    result.getObjectKey(), e);
-              }
-            } else {
-              // Key deletion failed, retry in next interval.
-              LOG.warn("Key {} deletion failed because some of the blocks"
-                  + " were failed to delete, failed blocks: {}",
-                  result.getObjectKey(),
-                  StringUtils.join(",", result.getFailedBlocks()));
-            }
+          if (results != null) {
+            int delCount = deleteAllKeys(results);
+            LOG.debug("Number of keys deleted: {}, elapsed time: {}ms",
+                delCount, Time.monotonicNow() - startTime);
+            deletedKeyCount.addAndGet(delCount);
-
-          if (!results.isEmpty()) {
-            LOG.info("Number of key deleted from OM DB: {},"
-                + " task elapsed time: {}ms",
-                results.size(), Time.monotonicNow() - startTime);
-          }
-
-          return results::size;
-        } else {
-          LOG.debug("No pending deletion key found in OM");
-        LOG.error("Unable to get pending deletion keys, retry in"
-            + " next interval", e);
+        LOG.error("Error while running delete keys background task. Will " +
+            "retry at next run.", e);
+      // By desing, no one cares about the results of this call back.
+
+    /**
+     * Deletes all the keys that SCM has acknowledged and queued for delete.
+     *
+     * @param results DeleteBlockGroups returned by SCM.
+     * @throws RocksDBException on Error.
+     * @throws IOException      on Error
+     */
+    private int deleteAllKeys(List<DeleteBlockGroupResult> results)
+        throws RocksDBException, IOException {
+      Table deletedTable = manager.getMetadataManager().getDeletedTable();
+      // Put all keys to delete in a single transaction and call for delete.
+      int deletedCount = 0;
+      try (WriteBatch writeBatch = new WriteBatch()) {
+        for (DeleteBlockGroupResult result : results) {
+          if (result.isSuccess()) {
+            // Purge key from OM DB.
+            writeBatch.delete(deletedTable.getHandle(),
+                DFSUtil.string2Bytes(result.getObjectKey()));
+            LOG.debug("Key {} deleted from OM DB", result.getObjectKey());
+            deletedCount++;
+          }
+        }
+        // Write a single transaction for delete.
+        manager.getMetadataManager().getStore().write(writeBatch);
+      }
+      return deletedCount;
+    }

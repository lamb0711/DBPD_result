YARN-2616 [YARN-913] Add CLI client to the registry to list, view and manipulate entries. (Akshay Radia via stevel)

+import java.io.Closeable;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.service.ServiceOperations;
+import org.apache.hadoop.util.ExitUtil;
-import org.apache.hadoop.yarn.conf.YarnConfiguration;
-public class RegistryCli extends Configured implements Tool {
+/**
+ * Command line for registry operations.
+ */
+public class RegistryCli extends Configured implements Tool, Closeable {
-	protected final PrintStream sysout;
-	protected final PrintStream syserr;
+  protected final PrintStream sysout;
+  protected final PrintStream syserr;
-	private RegistryOperations registry;
+  private RegistryOperations registry;
-  static final String LS_USAGE = "ls pathName";
-  static final String RESOLVE_USAGE = "resolve pathName";
-  static final String BIND_USAGE =
+  private static final String LS_USAGE = "ls pathName";
+  private static final String RESOLVE_USAGE = "resolve pathName";
+  private static final String BIND_USAGE =
-  static final String MKNODE_USAGE = "mknode directoryName";
-  static final String RM_USAGE = "rm pathName";
-  static final String USAGE =
+  private static final String MKNODE_USAGE = "mknode directoryName";
+  private static final String RM_USAGE = "rm pathName";
+  private static final String USAGE =
-
-	public RegistryCli(PrintStream sysout, PrintStream syserr) {
-	    super(new YarnConfiguration());
+  public RegistryCli(PrintStream sysout, PrintStream syserr) {
+    Configuration conf = new Configuration();
+    super.setConf(conf);
+    registry = RegistryOperationsFactory.createInstance(conf);
+    registry.start();
-	}
+  }
+  public RegistryCli(RegistryOperations reg,
+      Configuration conf,
+      PrintStream sysout,
+      PrintStream syserr) {
+    super(conf);
+    Preconditions.checkArgument(reg != null, "Null registry");
+    registry = reg;
+    this.sysout = sysout;
+    this.syserr = syserr;
+  }
-    RegistryCli cli = new RegistryCli(System.out, System.err);
-    int res = ToolRunner.run(cli, args);
-    System.exit(res);
+    int res = -1;
+    try (RegistryCli cli = new RegistryCli(System.out, System.err)) {
+      res = ToolRunner.run(cli, args);
+    } catch (Exception e) {
+      ExitUtil.terminate(res, e);
+    }
+    ExitUtil.terminate(res);
+  }
+
+  /**
+   * Close the object by stopping the registry.
+   * <p>
+   * <i>Important:</i>
+   * <p>
+   *   After this call is made, no operations may be made of this
+   *   object, <i>or of a YARN registry instance used when constructing
+   *   this object. </i>
+   * @throws IOException
+   */
+  @Override
+  public void close() throws IOException {
+    ServiceOperations.stopQuietly(registry);
+    registry = null;
+
-    registry = RegistryOperationsFactory.createInstance(
-        new YarnConfiguration(getConf()));
-    registry.start();
-      if (args[0].equals("ls")) {
-        return ls(args);
-      } else if (args[0].equals("resolve")) {
-        return resolve(args);
-      } else if (args[0].equals("bind")) {
-        return bind(args);
-      } else if (args[0].equals("mknode")) {
-        return mknode(args);
-      } else if (args[0].equals("rm")) {
-        return rm(args);
+      switch (args[0]) {
+        case "ls":
+          return ls(args);
+        case "resolve":
+          return resolve(args);
+        case "bind":
+          return bind(args);
+        case "mknode":
+          return mknode(args);
+        case "rm":
+          return rm(args);
+        default:
+          return usageError("Invalid command: " + args[0], USAGE);
-    return usageError("Invalid command: " + args[0], USAGE);
+    return usageError("No command arg passed.", USAGE);
-	public int ls(String [] args) {
+  public int ls(String[] args) {
-		Options lsOption = new Options();
-		CommandLineParser parser = new GnuParser();
-		try {
-			CommandLine line = parser.parse(lsOption, args);
+    Options lsOption = new Options();
+    CommandLineParser parser = new GnuParser();
+    try {
+      CommandLine line = parser.parse(lsOption, args);
-			List<String> argsList = line.getArgList();
-			if (argsList.size() != 2) {
-				return usageError("ls requires exactly one path argument", LS_USAGE);
-		    }
-			if (!validatePath(argsList.get(1)))
-				return -1;
+      List<String> argsList = line.getArgList();
+      if (argsList.size() != 2) {
+        return usageError("ls requires exactly one path argument", LS_USAGE);
+      }
+      if (!validatePath(argsList.get(1))) {
+        return -1;
+      }
-			try {
-				List<String> children = registry.list(argsList.get(1));
+      try {
+        List<String> children = registry.list(argsList.get(1));
-				return 0;
+        return 0;
-			return -1;
-		} catch (ParseException exp) {
-			return usageError("Invalid syntax " + exp, LS_USAGE);
-		}
-	}
+      return -1;
+    } catch (ParseException exp) {
+      return usageError("Invalid syntax " + exp, LS_USAGE);
+    }
+  }
-  public int resolve(String [] args) {
-		Options resolveOption = new Options();
-		CommandLineParser parser = new GnuParser();
-		try {
-			CommandLine line = parser.parse(resolveOption, args);
+  public int resolve(String[] args) {
+    Options resolveOption = new Options();
+    CommandLineParser parser = new GnuParser();
+    try {
+      CommandLine line = parser.parse(resolveOption, args);
-			List<String> argsList = line.getArgList();
-			if (argsList.size() != 2) {
-				return usageError("resolve requires exactly one path argument", RESOLVE_USAGE);
-		    }
-			if (!validatePath(argsList.get(1)))
-				return -1;
+      List<String> argsList = line.getArgList();
+      if (argsList.size() != 2) {
+        return usageError("resolve requires exactly one path argument",
+            RESOLVE_USAGE);
+      }
+      if (!validatePath(argsList.get(1))) {
+        return -1;
+      }
-			try {
-				ServiceRecord record = registry.resolve(argsList.get(1));
+      try {
+        ServiceRecord record = registry.resolve(argsList.get(1));
-				for (Endpoint endpoint : record.external) {
-						sysout.println(" Endpoint(ProtocolType="
-								+ endpoint.protocolType + ", Api="
-								+ endpoint.api + ");"
-								+ " Addresses(AddressType="
-								+ endpoint.addressType + ") are: ");
+        for (Endpoint endpoint : record.external) {
+          sysout.println(" Endpoint(ProtocolType="
+                         + endpoint.protocolType + ", Api="
+                         + endpoint.api + ");"
+                         + " Addresses(AddressType="
+                         + endpoint.addressType + ") are: ");
-            sysout.println("  [ ");
+            sysout.println("[ ");
-              sysout.println("    " + entry.getKey()
-                             + ": \"" + entry.getValue() + "\"");
+              sysout.print("\t" + entry.getKey()
+                             + ":" + entry.getValue());
-            sysout.println("  ]");
+
+            sysout.println("\n]");
-				return 0;
+        return 0;
-			return -1;
-		} catch (org.apache.commons.cli.ParseException exp) {
-			return usageError("Invalid syntax " + exp, RESOLVE_USAGE);
-		}
+      return -1;
+    } catch (ParseException exp) {
+      return usageError("Invalid syntax " + exp, RESOLVE_USAGE);
+    }
-	}
+  }
-	public int bind(String [] args) {
-		Option rest = OptionBuilder.withArgName("rest")
-				.hasArg()
-				.withDescription("rest Option")
-				.create("rest");
-		Option webui = OptionBuilder.withArgName("webui")
-				.hasArg()
-				.withDescription("webui Option")
-				.create("webui");
-		Option inet = OptionBuilder.withArgName("inet")
-				.withDescription("inet Option")
-				.create("inet");
-		Option port = OptionBuilder.withArgName("port")
-				.hasArg()
-				.withDescription("port to listen on [9999]")
-				.create("p");
-		Option host = OptionBuilder.withArgName("host")
-				.hasArg()
-				.withDescription("host name")
-				.create("h");
-		Option apiOpt = OptionBuilder.withArgName("api")
-				.hasArg()
-				.withDescription("api")
-				.create("api");
-		Options inetOption = new Options();
-		inetOption.addOption(inet);
-		inetOption.addOption(port);
-		inetOption.addOption(host);
-		inetOption.addOption(apiOpt);
+  public int bind(String[] args) {
+    Option rest = OptionBuilder.withArgName("rest")
+                               .hasArg()
+                               .withDescription("rest Option")
+                               .create("rest");
+    Option webui = OptionBuilder.withArgName("webui")
+                                .hasArg()
+                                .withDescription("webui Option")
+                                .create("webui");
+    Option inet = OptionBuilder.withArgName("inet")
+                               .withDescription("inet Option")
+                               .create("inet");
+    Option port = OptionBuilder.withArgName("port")
+                               .hasArg()
+                               .withDescription("port to listen on [9999]")
+                               .create("p");
+    Option host = OptionBuilder.withArgName("host")
+                               .hasArg()
+                               .withDescription("host name")
+                               .create("h");
+    Option apiOpt = OptionBuilder.withArgName("api")
+                                 .hasArg()
+                                 .withDescription("api")
+                                 .create("api");
+    Options inetOption = new Options();
+    inetOption.addOption(inet);
+    inetOption.addOption(port);
+    inetOption.addOption(host);
+    inetOption.addOption(apiOpt);
-		Options webuiOpt = new Options();
-		webuiOpt.addOption(webui);
-		webuiOpt.addOption(apiOpt);
+    Options webuiOpt = new Options();
+    webuiOpt.addOption(webui);
+    webuiOpt.addOption(apiOpt);
-		Options restOpt = new Options();
-		restOpt.addOption(rest);
-		restOpt.addOption(apiOpt);
+    Options restOpt = new Options();
+    restOpt.addOption(rest);
+    restOpt.addOption(apiOpt);
-    CommandLine line = null;
+    CommandLine line;
-        portNum = Integer.parseInt(line.getOptionValue("p"));
+        try {
+          portNum = Integer.parseInt(line.getOptionValue("p"));
+        } catch (NumberFormatException exp) {
+          return usageError("Invalid Port - int required" + exp.getMessage(),
+              BIND_USAGE);
+        }
-        URI theUri = null;
+        URI theUri;
-		List<String> argsList = line.getArgList();
-		if (argsList.size() != 2) {
-			return usageError("bind requires exactly one path argument", BIND_USAGE);
-	    }
-		if (!validatePath(argsList.get(1)))
-			return -1;
+    List<String> argsList = line.getArgList();
+    if (argsList.size() != 2) {
+      return usageError("bind requires exactly one path argument", BIND_USAGE);
+    }
+    if (!validatePath(argsList.get(1))) {
+      return -1;
+    }
-		try {
-			registry.bind(argsList.get(1), sr, BindFlags.OVERWRITE);
-			return 0;
+    try {
+      registry.bind(argsList.get(1), sr, BindFlags.OVERWRITE);
+      return 0;
-	}
+  }
-	public int mknode(String [] args) {
-		Options mknodeOption = new Options();
-		CommandLineParser parser = new GnuParser();
-		try {
-			CommandLine line = parser.parse(mknodeOption, args);
+  public int mknode(String[] args) {
+    Options mknodeOption = new Options();
+    CommandLineParser parser = new GnuParser();
+    try {
+      CommandLine line = parser.parse(mknodeOption, args);
-			List<String> argsList = line.getArgList();
-			if (argsList.size() != 2) {
-				return usageError("mknode requires exactly one path argument", MKNODE_USAGE);
-		    }
-			if (!validatePath(argsList.get(1)))
-				return -1;
+      List<String> argsList = line.getArgList();
+      if (argsList.size() != 2) {
+        return usageError("mknode requires exactly one path argument",
+            MKNODE_USAGE);
+      }
+      if (!validatePath(argsList.get(1))) {
+        return -1;
+      }
-			try {
-				registry.mknode(args[1], false);
-				return 0;
-			} catch (Exception e) {
+      try {
+        registry.mknode(args[1], false);
+        return 0;
+      } catch (Exception e) {
-			}
-			return -1;
-		} catch (ParseException exp) {
-			return usageError("Invalid syntax " + exp.toString(), MKNODE_USAGE);
-		}
-	}
+      }
+      return -1;
+    } catch (ParseException exp) {
+      return usageError("Invalid syntax " + exp.toString(), MKNODE_USAGE);
+    }
+  }
-		Option recursive = OptionBuilder.withArgName("recursive")
-				.withDescription("delete recursively").create("r");
+    Option recursive = OptionBuilder.withArgName("recursive")
+                                    .withDescription("delete recursively")
+                                    .create("r");
-		Options rmOption = new Options();
-		rmOption.addOption(recursive);
+    Options rmOption = new Options();
+    rmOption.addOption(recursive);
-		boolean recursiveOpt = false;
+    boolean recursiveOpt = false;
-		CommandLineParser parser = new GnuParser();
-		try {
-			CommandLine line = parser.parse(rmOption, args);
+    CommandLineParser parser = new GnuParser();
+    try {
+      CommandLine line = parser.parse(rmOption, args);
-			List<String> argsList = line.getArgList();
-			if (argsList.size() != 2) {
-				return usageError("RM requires exactly one path argument", RM_USAGE);
-		    }
-			if (!validatePath(argsList.get(1)))
-				return -1;
+      List<String> argsList = line.getArgList();
+      if (argsList.size() != 2) {
+        return usageError("RM requires exactly one path argument", RM_USAGE);
+      }
+      if (!validatePath(argsList.get(1))) {
+        return -1;
+      }
-			try {
-				if (line.hasOption("r")) {
-					recursiveOpt = true;
-				}
+      try {
+        if (line.hasOption("r")) {
+          recursiveOpt = true;
+        }
-				registry.delete(argsList.get(1), recursiveOpt);
-				return 0;
+        registry.delete(argsList.get(1), recursiveOpt);
+        return 0;
-		} catch (ParseException exp) {
-			return usageError("Invalid syntax " + exp.toString(), RM_USAGE);
-		}
-	}
+    } catch (ParseException exp) {
+      return usageError("Invalid syntax " + exp.toString(), RM_USAGE);
+    }
+  }

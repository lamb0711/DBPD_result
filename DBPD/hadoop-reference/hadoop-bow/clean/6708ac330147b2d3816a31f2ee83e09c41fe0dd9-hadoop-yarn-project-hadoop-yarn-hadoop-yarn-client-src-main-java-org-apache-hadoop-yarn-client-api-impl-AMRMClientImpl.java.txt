YARN-5587. Add support for resource profiles. (vvasudev via asuresh)

+import org.apache.hadoop.yarn.api.records.ProfileCapability;
+
+  protected Map<String, Resource> resourceProfilesMap;
-    
+
-        String resourceName, Resource capability, boolean relaxLocality) {
+        String resourceName, Resource capability, boolean relaxLocality,
+        String resourceProfile) {
+      ProfileCapability profileCapability = ProfileCapability
+          .newInstance(resourceProfile, capability);
-          .allocationRequestId(allocationRequestId)
-          .relaxLocality(relaxLocality).build();
+          .allocationRequestId(allocationRequestId).relaxLocality(relaxLocality)
+          .profileCapability(profileCapability).build();
-   * Class compares Resource by memory then cpu in reverse order
+   * Class compares Resource by memory, then cpu and then the remaining resource
+   * types in reverse order.
-  static class ResourceReverseMemoryThenCpuComparator implements
-      Comparator<Resource>, Serializable {
-    static final long serialVersionUID = 12345L;
-    @Override
-    public int compare(Resource arg0, Resource arg1) {
-      long mem0 = arg0.getMemorySize();
-      long mem1 = arg1.getMemorySize();
-      long cpu0 = arg0.getVirtualCores();
-      long cpu1 = arg1.getVirtualCores();
-      if(mem0 == mem1) {
-        if(cpu0 == cpu1) {
-          return 0;
-        }
-        if(cpu0 < cpu1) {
-          return 1;
-        }
-        return -1;
-      }
-      if(mem0 < mem1) { 
-        return 1;
-      }
-      return -1;
-    }    
+  static class ProfileCapabilityComparator<T extends ProfileCapability>
+      implements Comparator<T> {
+
+    HashMap<String, Resource> resourceProfilesMap;
+
+    public ProfileCapabilityComparator(
+        HashMap<String, Resource> resourceProfileMap) {
+      this.resourceProfilesMap = resourceProfileMap;
+    }
+
+    public int compare(T arg0, T arg1) {
+      Resource resource0 =
+          ProfileCapability.toResource(arg0, resourceProfilesMap);
+      Resource resource1 =
+          ProfileCapability.toResource(arg1, resourceProfilesMap);
+      return resource1.compareTo(resource0);
+    }
-  static boolean canFit(Resource arg0, Resource arg1) {
-    long mem0 = arg0.getMemorySize();
-    long mem1 = arg1.getMemorySize();
-    long cpu0 = arg0.getVirtualCores();
-    long cpu1 = arg1.getVirtualCores();
-    
-    return (mem0 <= mem1 && cpu0 <= cpu1);
+  boolean canFit(ProfileCapability arg0, ProfileCapability arg1) {
+    Resource resource0 =
+        ProfileCapability.toResource(arg0, resourceProfilesMap);
+    Resource resource1 =
+        ProfileCapability.toResource(arg1, resourceProfilesMap);
+    return Resources.fitsIn(resource0, resource1);
+
+  @SuppressWarnings("unchecked")
+      this.resourceProfilesMap = response.getResourceProfiles();
-      ResourceRequest rr = ResourceRequest.newBuilder()
-          .priority(r.getPriority()).resourceName(r.getResourceName())
-          .capability(r.getCapability()).numContainers(r.getNumContainers())
-          .relaxLocality(r.getRelaxLocality())
-          .nodeLabelExpression(r.getNodeLabelExpression())
-          .executionTypeRequest(r.getExecutionTypeRequest())
-          .allocationRequestId(r.getAllocationRequestId()).build();
+      ResourceRequest rr =
+          ResourceRequest.newBuilder().priority(r.getPriority())
+              .resourceName(r.getResourceName()).capability(r.getCapability())
+              .numContainers(r.getNumContainers())
+              .relaxLocality(r.getRelaxLocality())
+              .nodeLabelExpression(r.getNodeLabelExpression())
+              .executionTypeRequest(r.getExecutionTypeRequest())
+              .allocationRequestId(r.getAllocationRequestId())
+              .profileCapability(r.getProfileCapability()).build();
+    ProfileCapability profileCapability = ProfileCapability
+        .newInstance(req.getResourceProfile(), req.getCapability());
+    checkResourceProfile(req.getResourceProfile());
+
-            req.getExecutionTypeRequest(), req.getCapability(), req, true,
+            req.getExecutionTypeRequest(), profileCapability, req, true,
-          req.getCapability(), req, true, req.getNodeLabelExpression());
+          profileCapability, req, true, req.getNodeLabelExpression());
-          req.getCapability(), req, req.getRelaxLocality(),
+          profileCapability, req, req.getRelaxLocality(),
-        req.getExecutionTypeRequest(), req.getCapability(), req,
+        req.getExecutionTypeRequest(), profileCapability, req,
+    ProfileCapability profileCapability = ProfileCapability
+        .newInstance(req.getResourceProfile(), req.getCapability());
-            req.getExecutionTypeRequest(), req.getCapability(), req);
+            req.getExecutionTypeRequest(), profileCapability, req);
-          req.getExecutionTypeRequest(), req.getCapability(), req);
+          req.getExecutionTypeRequest(), profileCapability, req);
-        req.getExecutionTypeRequest(), req.getCapability(), req);
+        req.getExecutionTypeRequest(), profileCapability, req);
+    ProfileCapability profileCapability =
+        ProfileCapability.newInstance(capability);
+    return getMatchingRequests(priority, resourceName, executionType,
+        profileCapability);
+  }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public synchronized List<? extends Collection<T>> getMatchingRequests(
+      Priority priority, String resourceName, ExecutionType executionType,
+      ProfileCapability capability) {
-      List<ResourceRequestInfo<T>> matchingRequests =
-          remoteRequestsTable.getMatchingRequests(priority, resourceName,
-              executionType, capability);
+      List<ResourceRequestInfo<T>> matchingRequests = remoteRequestsTable
+          .getMatchingRequests(priority, resourceName, executionType,
+              capability);
-          if (canFit(resReqInfo.remoteRequest.getCapability(), capability) &&
-              !resReqInfo.containerRequests.isEmpty()) {
+          if (canFit(resReqInfo.remoteRequest.getProfileCapability(),
+              capability) && !resReqInfo.containerRequests.isEmpty()) {
-    return list;          
+    return list;
+
+  private void checkResourceProfile(String profile) {
+    if (resourceProfilesMap != null && !resourceProfilesMap.isEmpty()
+        && !resourceProfilesMap.containsKey(profile)) {
+      throw new InvalidContainerRequestException(
+          "Invalid profile name, valid profile names are " + resourceProfilesMap
+              .keySet());
+    }
+  }
-      ExecutionTypeRequest execTypeReq, Resource capability, T req,
+      ExecutionTypeRequest execTypeReq, ProfileCapability capability, T req,
+      if (this.resourceProfilesMap instanceof HashMap) {
+        remoteRequestsTable.setResourceComparator(
+            new ProfileCapabilityComparator((HashMap) resourceProfilesMap));
+      }
+      LOG.debug("Adding request to ask " + resourceRequestInfo.remoteRequest);
-      ExecutionTypeRequest execTypeReq, Resource capability, T req) {
+      ExecutionTypeRequest execTypeReq, ProfileCapability capability, T req) {
-      // previously then sending 0 ought to be a no-op on RM
+      // previously then sending 0 aught to be a no-op on RM

Revert "HADOOP-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao."

This reverts commit aeecfa24f4fb6af289920cbf8830c394e66bd78e.

+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.fs.FileStatus;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-  static final Logger LOG = LoggerFactory.getLogger(LocalReplica.class);
+  static final Log LOG = LogFactory.getLog(LocalReplica.class);
+  private final static boolean IS_NATIVE_IO_AVAIL;
+  static {
+    IS_NATIVE_IO_AVAIL = NativeIO.isAvailable();
+    if (Path.WINDOWS && !IS_NATIVE_IO_AVAIL) {
+      LOG.warn("Data node cannot fully support concurrent reading"
+          + " and writing without native code extensions on Windows.");
+    }
+  }
-        copyBytes(in, out, 16 * 1024);
+        IOUtils.copyBytes(in, out, 16 * 1024);
-      replaceFile(tmpFile, file);
+      FileUtil.replaceFile(tmpFile, file);
-    int linkCount = getHardLinkCount(file);
+    int linkCount = HardLink.getLinkCount(file);
-    if (getHardLinkCount(meta) > 1) {
+    if (HardLink.getLinkCount(meta) > 1) {
-    return getDataInputStream(getBlockFile(), seekOffset);
+
+    File blockFile = getBlockFile();
+    if (IS_NATIVE_IO_AVAIL) {
+      return NativeIO.getShareDeleteFileInputStream(blockFile, seekOffset);
+    } else {
+      try {
+        return FsDatasetUtil.openAndSeek(blockFile, seekOffset);
+      } catch (FileNotFoundException fnfe) {
+        throw new IOException("Block " + this + " is not valid. " +
+            "Expected block file at " + blockFile + " does not exist.");
+      }
+    }
-    return fullyDelete(getBlockFile());
+    return getBlockFile().delete();
-    return fullyDelete(getMetaFile());
+    return getMetaFile().delete();
-      rename(srcfile, destfile);
+      NativeIO.renameTo(srcfile, destfile);
-    return getPinning(localFS, new Path(getBlockFile().getAbsolutePath()));
+    FileStatus fss =
+        localFS.getFileStatus(new Path(getBlockFile().getAbsolutePath()));
+    return fss.getPermission().getStickyBit();
-    setPinning(localFS, p);
+
+    FsPermission oldPermission = localFS.getFileStatus(
+        new Path(f.getAbsolutePath())).getPermission();
+    //sticky bit is used for pinning purpose
+    FsPermission permission = new FsPermission(oldPermission.getUserAction(),
+        oldPermission.getGroupAction(), oldPermission.getOtherAction(), true);
+    localFS.setPermission(p, permission);
-      rename(oldmeta, newmeta);
+      NativeIO.renameTo(oldmeta, newmeta);
-  @Override
-  public void copyMetadata(URI destination) throws IOException {
-    //for local replicas, we assume the destination URI is file
-    nativeCopyFileUnbuffered(getMetaFile(), new File(destination), true);
-  }
-
-  @Override
-  public void copyBlockdata(URI destination) throws IOException {
-    //for local replicas, we assume the destination URI is file
-    nativeCopyFileUnbuffered(getBlockFile(), new File(destination), true);
-  }
-
-  public void renameMeta(File newMetaFile) throws IOException {
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Renaming " + getMetaFile() + " to " + newMetaFile);
-    }
-    renameFile(getMetaFile(), newMetaFile);
-  }
-
-  public void renameBlock(File newBlockFile) throws IOException {
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Renaming " + getBlockFile() + " to " + newBlockFile
-          + ", file length=" + getBlockFile().length());
-    }
-    renameFile(getBlockFile(), newBlockFile);
-  }
-
-  public static void rename(File from, File to) throws IOException {
-    Storage.rename(from, to);
-  }
-
-  /**
-   * Get input stream for a local file and optionally seek to the offset.
-   * @param f path to the file
-   * @param seekOffset offset to seek
-   * @return
-   * @throws IOException
-   */
-  private FileInputStream getDataInputStream(File f, long seekOffset)
-      throws IOException {
-    FileInputStream fis;
-    if (NativeIO.isAvailable()) {
-      fis = NativeIO.getShareDeleteFileInputStream(f, seekOffset);
-    } else {
-      try {
-        fis = FsDatasetUtil.openAndSeek(f, seekOffset);
-      } catch (FileNotFoundException fnfe) {
-        throw new IOException("Expected block file at " + f +
-            " does not exist.");
-      }
-    }
-    return fis;
-  }
-
-  private void nativeCopyFileUnbuffered(File srcFile, File destFile,
-      boolean preserveFileDate) throws IOException {
-    Storage.nativeCopyFileUnbuffered(srcFile, destFile, preserveFileDate);
-  }
-
-  private void copyBytes(InputStream in, OutputStream out, int
-      buffSize) throws IOException{
-    IOUtils.copyBytes(in, out, buffSize);
-  }
-
-  private void replaceFile(File src, File target) throws IOException {
-    FileUtil.replaceFile(src, target);
-  }
-
-  public static boolean fullyDelete(final File dir) {
-    boolean result = DataStorage.fullyDelete(dir);
-    return result;
-  }
-
-  public static int getHardLinkCount(File fileName) throws IOException {
-    int linkCount = HardLink.getLinkCount(fileName);
-    return linkCount;
-  }
-
-  /**
-   *  Get pin status of a file by checking the sticky bit.
-   * @param localFS local file system
-   * @param path path to be checked
-   * @return
-   * @throws IOException
-   */
-  public boolean getPinning(LocalFileSystem localFS, Path path) throws
-      IOException {
-    boolean stickyBit =
-        localFS.getFileStatus(path).getPermission().getStickyBit();
-    return stickyBit;
-  }
-
-  /**
-   * Set sticky bit on path to pin file.
-   * @param localFS local file system
-   * @param path path to be pinned with sticky bit
-   * @throws IOException
-   */
-  public void setPinning(LocalFileSystem localFS, Path path) throws
-      IOException {
-    FsPermission oldPermission = localFS.getFileStatus(path).getPermission();
-    FsPermission permission = new FsPermission(oldPermission.getUserAction(),
-        oldPermission.getGroupAction(), oldPermission.getOtherAction(), true);
-    localFS.setPermission(path, permission);
-  }
-
-  public static void truncateBlock(File blockFile, File metaFile,
+  static public void truncateBlock(File blockFile, File metaFile,
+
+  @Override
+  public void copyMetadata(URI destination) throws IOException {
+    //for local replicas, we assume the destination URI is file
+    Storage.nativeCopyFileUnbuffered(getMetaFile(),
+        new File(destination), true);
+  }
+
+  @Override
+  public void copyBlockdata(URI destination) throws IOException {
+    //for local replicas, we assume the destination URI is file
+    Storage.nativeCopyFileUnbuffered(getBlockFile(),
+        new File(destination), true);
+  }
+

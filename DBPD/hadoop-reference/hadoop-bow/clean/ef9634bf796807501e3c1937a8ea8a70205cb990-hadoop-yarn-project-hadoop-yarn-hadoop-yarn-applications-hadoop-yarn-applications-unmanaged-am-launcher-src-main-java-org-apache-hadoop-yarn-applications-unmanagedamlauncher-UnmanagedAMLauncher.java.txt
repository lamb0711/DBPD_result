YARN-1577. Made UnmanagedAMLauncher do launchAM after the attempt reaches the LAUNCHED state. Contributed by Jian He.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580164 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.yarn.api.records.ApplicationAttemptReport;
+import org.apache.hadoop.yarn.api.records.YarnApplicationAttemptState;
-  private YarnClient rmClient;
+  protected YarnClient rmClient;
+  private static final long AM_STATE_WAIT_TIMEOUT_MS = 10000;
-    ApplicationReport report = 
-      rmClient.getApplicationReport(attemptId.getApplicationId());
-    if (report.getYarnApplicationState() != YarnApplicationState.ACCEPTED) {
-      throw new YarnException(
-          "Umanaged AM must be in ACCEPTED state before launching");
-    }
-  
-      // Monitor the application to wait for launch state
-      ApplicationReport appReport = monitorApplication(appId,
-          EnumSet.of(YarnApplicationState.ACCEPTED));
-      ApplicationAttemptId attemptId = appReport.getCurrentApplicationAttemptId();
-      LOG.info("Launching application with id: " + attemptId);
-  
-      // launch AM
-      launchAM(attemptId);
-  
-      // Monitor the application for end state
-      appReport = monitorApplication(appId, EnumSet.of(
-          YarnApplicationState.KILLED, YarnApplicationState.FAILED,
-          YarnApplicationState.FINISHED));
+
+      ApplicationReport appReport =
+          monitorApplication(appId, EnumSet.of(YarnApplicationState.ACCEPTED,
+            YarnApplicationState.KILLED, YarnApplicationState.FAILED,
+            YarnApplicationState.FINISHED));
+
+      if (appReport.getYarnApplicationState() == YarnApplicationState.ACCEPTED) {
+        // Monitor the application attempt to wait for launch state
+        ApplicationAttemptReport attemptReport =
+            monitorCurrentAppAttempt(appId,
+              YarnApplicationAttemptState.LAUNCHED);
+        ApplicationAttemptId attemptId =
+            attemptReport.getApplicationAttemptId();
+        LOG.info("Launching AM with application attempt id " + attemptId);
+        // launch AM
+        launchAM(attemptId);
+        // Monitor the application for end state
+        appReport =
+            monitorApplication(appId, EnumSet.of(YarnApplicationState.KILLED,
+              YarnApplicationState.FAILED, YarnApplicationState.FINISHED));
+      }
+  private ApplicationAttemptReport monitorCurrentAppAttempt(
+      ApplicationId appId, YarnApplicationAttemptState attemptState)
+      throws YarnException, IOException {
+    long startTime = System.currentTimeMillis();
+    ApplicationAttemptId attemptId = null;
+    while (true) {
+      if (attemptId == null) {
+        attemptId =
+            rmClient.getApplicationReport(appId)
+              .getCurrentApplicationAttemptId();
+      }
+      ApplicationAttemptReport attemptReport = null;
+      if (attemptId != null) {
+        attemptReport = rmClient.getApplicationAttemptReport(attemptId);
+        if (attemptState.equals(attemptReport.getYarnApplicationAttemptState())) {
+          return attemptReport;
+        }
+      }
+      LOG.info("Current attempt state of " + appId + " is " + (attemptReport == null
+            ? " N/A " : attemptReport.getYarnApplicationAttemptState())
+                + ", waiting for current attempt to reach " + attemptState);
+      try {
+        Thread.sleep(1000);
+      } catch (InterruptedException e) {
+        LOG.warn("Interrupted while waiting for current attempt of " + appId
+            + " to reach " + attemptState);
+      }
+      if (System.currentTimeMillis() - startTime > AM_STATE_WAIT_TIMEOUT_MS) {
+        String errmsg =
+            "Timeout for waiting current attempt of " + appId + " to reach "
+                + attemptState;
+        LOG.error(errmsg);
+        throw new RuntimeException(errmsg);
+      }
+    }
+  }
+
-    final int timeToWaitMS = 10000;
-            > timeToWaitMS) {
-          LOG.warn("Waited " + timeToWaitMS/1000
+            > AM_STATE_WAIT_TIMEOUT_MS) {
+          LOG.warn("Waited " + AM_STATE_WAIT_TIMEOUT_MS/1000

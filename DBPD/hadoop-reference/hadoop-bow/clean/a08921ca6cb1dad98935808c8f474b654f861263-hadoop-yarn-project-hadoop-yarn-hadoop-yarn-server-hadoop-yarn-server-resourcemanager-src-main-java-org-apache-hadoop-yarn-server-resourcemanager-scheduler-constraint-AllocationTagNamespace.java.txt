YARN-8002. Support NOT_SELF and ALL namespace types for allocation tag. (Weiwei Yang via wangda)

Change-Id: I63b4e4192a95bf7ded98c54e46a2871c72869700

-package org.apache.hadoop.yarn.api.records;
+package org.apache.hadoop.yarn.server.resourcemanager.scheduler.constraint;
-import org.apache.hadoop.yarn.exceptions.InvalidAllocationTagException;
+import org.apache.hadoop.yarn.api.records.AllocationTagNamespaceType;
+import org.apache.hadoop.yarn.api.records.ApplicationId;
+import java.util.Arrays;
+import java.util.stream.Collectors;
-import static org.apache.hadoop.yarn.api.records.AllocationTagNamespaceType.fromString;
-   * Before calling this method, {@link #evaluate(TargetApplications)}
-   * must be called in prior to ensure the scope is proper evaluated.
+  /**
+   * Evaluate the namespace against given target applications
+   * if it is necessary. Only self/not-self/app-label namespace types
+   * require this evaluation step, because they are not binding to a
+   * specific scope during initiating. So we do lazy binding for them
+   * in this method.
+   *
+   * @param target a generic type target that impacts this evaluation.
+   * @throws InvalidAllocationTagsQueryException
+   */
-  public abstract void evaluate(TargetApplications target)
-      throws InvalidAllocationTagException;
-
-  /**
-   * @return true if the namespace is effective in all applications
-   * in this cluster. Specifically the namespace prefix should be
-   * "all".
-   */
-  public boolean isGlobal() {
-    return AllocationTagNamespaceType.ALL.equals(getNamespaceType());
-  }
-
-  /**
-   * @return true if the namespace is effective within a single application
-   * by its application ID, the namespace prefix should be "app-id";
-   * false otherwise.
-   */
-  public boolean isSingleInterApp() {
-    return AllocationTagNamespaceType.APP_ID.equals(getNamespaceType());
-  }
-
-  /**
-   * @return true if the namespace is effective to the application itself,
-   * the namespace prefix should be "self"; false otherwise.
-   */
-  public boolean isIntraApp() {
-    return AllocationTagNamespaceType.SELF.equals(getNamespaceType());
-  }
-
-  /**
-   * @return true if the namespace is effective to all applications except
-   * itself, the namespace prefix should be "not-self"; false otherwise.
-   */
-  public boolean isNotSelf() {
-    return AllocationTagNamespaceType.NOT_SELF.equals(getNamespaceType());
-  }
-
-  /**
-   * @return true if the namespace is effective to a group of applications
-   * identified by a application label, the namespace prefix should be
-   * "app-label"; false otherwise.
-   */
-  public boolean isAppLabel() {
-    return AllocationTagNamespaceType.APP_LABEL.equals(getNamespaceType());
+  public void evaluate(TargetApplications target)
+      throws InvalidAllocationTagsQueryException {
+    // Sub-class needs to override this when it requires the eval step.
-        throws InvalidAllocationTagException {
+        throws InvalidAllocationTagsQueryException {
-        throw new InvalidAllocationTagException("Namespace Self must"
+        throw new InvalidAllocationTagsQueryException("Namespace Self must"
-
-    @Override
-    public void evaluate(TargetApplications target) {
-      Set<ApplicationId> allAppIds = target.getAllApplicationIds();
-      setScopeIfNotNull(allAppIds);
-    }
-    }
-
-    @Override
-    public void evaluate(TargetApplications target) {
-   * @throws InvalidAllocationTagException
+   * @throws InvalidAllocationTagsQueryException
-      throws InvalidAllocationTagException {
+      throws InvalidAllocationTagsQueryException {
-        throw new InvalidAllocationTagException(
+        throw new InvalidAllocationTagsQueryException(
-      throw new InvalidAllocationTagException(
+      throw new InvalidAllocationTagsQueryException(
+  private static AllocationTagNamespaceType fromString(String prefix) throws
+      InvalidAllocationTagsQueryException {
+    for (AllocationTagNamespaceType type :
+        AllocationTagNamespaceType.values()) {
+      if(type.getTypeKeyword().equals(prefix)) {
+        return type;
+      }
+    }
+
+    Set<String> values = Arrays.stream(AllocationTagNamespaceType.values())
+        .map(AllocationTagNamespaceType::toString)
+        .collect(Collectors.toSet());
+    throw new InvalidAllocationTagsQueryException(
+        "Invalid namespace prefix: " + prefix
+            + ", valid values are: " + String.join(",", values));
+  }
+
-      throws InvalidAllocationTagException {
+      throws InvalidAllocationTagsQueryException {
-      throw new InvalidAllocationTagException(
+      throw new InvalidAllocationTagsQueryException(
-   * @throws InvalidAllocationTagException
+   * @throws InvalidAllocationTagsQueryException
-      throws InvalidAllocationTagException {
+      throws InvalidAllocationTagsQueryException {
-      throw new InvalidAllocationTagException("Invalid namespace string: "
+      throw new InvalidAllocationTagsQueryException("Invalid namespace string: "

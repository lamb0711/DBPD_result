YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.

-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.concurrent.ConcurrentHashMap;
-  static final Comparator<CSQueue> NON_PARTITIONED_QUEUE_COMPARATOR =
-      new Comparator<CSQueue>() {
-    @Override
-    public int compare(CSQueue q1, CSQueue q2) {
-      int result = Float.compare(q1.getUsedCapacity(),
-          q2.getUsedCapacity());
-      if (result < 0) {
-        return -1;
-      } else if (result > 0) {
-        return 1;
-      }
-
-      return q1.getQueuePath().compareTo(q2.getQueuePath());
-    }
-  };
-
-  private final Map<String, CSQueue> queues = new ConcurrentHashMap<>();
+  private final CSQueueStore queues = new CSQueueStore();
-    return queues;
+    return queues.getFullNameQueues();
+  }
+
+  @VisibleForTesting
+  public Map<String, CSQueue> getShortNameQueues() {
+    return queues.getShortNameQueues();
-    this.queues.put(queueName, queue);
+    this.queues.add(queue);
+  public CSQueue getQueueByFullName(String name) {
+    return queues.getByFullName(name);
+  }
+
+  String normalizeQueueName(String name) {
+    CSQueue queue = this.queues.get(name);
+    if (queue != null) {
+      return queue.getQueuePath();
+    }
+    //We return the original name here instead of null, to make sure we don't
+    // introduce a NPE, and let the process fail where it would fail for unknown
+    // queues, resulting more informative error messages.
+    return name;
+  }
+
+  public boolean isAmbiguous(String shortName) {
+    return queues.isAmbiguous(shortName);
+  }
+
-    Map<String, CSQueue> newQueues = new HashMap<>();
+    CSQueueStore newQueues = new CSQueueStore();
-      CSQueue parent, String queueName, Map<String, CSQueue> queues,
-      Map<String, CSQueue> oldQueues,
+      CSQueue parent, String queueName,
+      CSQueueStore queues,
+      CSQueueStore oldQueues,
-            oldQueues.get(queueName));
+            oldQueues.get(fullQueueName));
-        queues.put(defReservationId, resQueue);
+        queues.add(resQueue);
-            oldQueues.get(queueName));
+            oldQueues.get(fullQueueName));
-            oldQueues.get(queueName));
+            oldQueues.get(fullQueueName));
-            "Only Leaf Queues can be reservable for " + queueName);
+            "Only Leaf Queues can be reservable for " + fullQueueName);
-            oldQueues.get(queueName));
+            oldQueues.get(fullQueueName));
-            oldQueues.get(queueName));
+            oldQueues.get(fullQueueName));
-    if (queue instanceof LeafQueue && queues.containsKey(queueName) && queues
-        .get(queueName) instanceof LeafQueue) {
-      throw new IOException("Two leaf queues were named " + queueName
-          + ". Leaf queue names must be distinct");
-    }
-    queues.put(queueName, queue);
+    queues.add(queue);
-    LOG.info("Initialized queue: " + queue);
+    LOG.info("Initialized queue: " + fullQueueName);
-
-  private void updateQueues(Map<String, CSQueue> existingQueues,
-      Map<String, CSQueue> newQueues) {
+  private void updateQueues(CSQueueStore existingQueues,
+                            CSQueueStore newQueues) {
-    for (Map.Entry<String, CSQueue> e : newQueues.entrySet()) {
-      String queueName = e.getKey();
-      CSQueue queue = e.getValue();
-      if (!existingQueues.containsKey(queueName)) {
-        existingQueues.put(queueName, queue);
+    for (CSQueue queue : newQueues.getQueues()) {
+      if (existingQueues.get(queue.getQueuePath()) == null) {
+        existingQueues.add(queue);
-    for (Iterator<Map.Entry<String, CSQueue>> itr = existingQueues.entrySet()
-        .iterator(); itr.hasNext();) {
-      Map.Entry<String, CSQueue> e = itr.next();
-      String queueName = e.getKey();
-      CSQueue existingQueue = e.getValue();
-      if (!newQueues.containsKey(queueName) && !(
-          existingQueue instanceof AutoCreatedLeafQueue && conf
+    for (CSQueue queue: existingQueues.getQueues()) {
+      if (newQueues.get(queue.getQueuePath()) == null && !(
+          queue instanceof AutoCreatedLeafQueue && conf
-                  existingQueue.getParent().getQueuePath()))) {
-        itr.remove();
+                queue.getParent().getQueuePath()))) {
+        existingQueues.remove(queue);
+
-      AppPriorityACLsManager appPriorityACLManager, Map<String, CSQueue> queues)
+      AppPriorityACLsManager appPriorityACLManager, CSQueueStore queues)
-    for (CSQueue queue : queues.values()) {
+    for (CSQueue queue : queues.getQueues()) {
-        appPriorityACLManager.clearPriorityACLs(lQueue.getQueueName());
+        appPriorityACLManager.clearPriorityACLs(lQueue.getQueuePath());
-            lQueue.getQueueName());
+            lQueue.getQueuePath());
-      queueToLabels.put(queue.getQueueName(), queue.getAccessibleNodeLabels());
+      queueToLabels.put(queue.getQueuePath(), queue.getAccessibleNodeLabels());

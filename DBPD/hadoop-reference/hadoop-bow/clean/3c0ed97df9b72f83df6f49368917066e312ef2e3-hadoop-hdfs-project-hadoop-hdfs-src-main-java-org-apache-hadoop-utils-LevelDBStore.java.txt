HDFS-11926. Ozone: Implement a common helper to return a range of KVs in levelDB. Contributed by  Weiwei Yang.

+import org.apache.hadoop.utils.LevelDBKeyFilters.LevelDBKeyFilter;
+import org.iq80.leveldb.Options;
-import org.iq80.leveldb.Options;
+import org.iq80.leveldb.Snapshot;
+import org.iq80.leveldb.ReadOptions;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Map.Entry;
+
+  private static final Logger LOG =
+      LoggerFactory.getLogger(LevelDBStore.class);
+
+
+  /**
+   * Returns a certain range of key value pairs as a list based on a startKey
+   * or count.
+   *
+   * @param keyPrefix start key.
+   * @param count number of entries to return.
+   * @return a range of entries or an empty list if nothing found.
+   * @throws IOException
+   *
+   * @see #getRangeKVs(byte[], int, LevelDBKeyFilter...)
+   */
+  public List<Entry<byte[], byte[]>> getRangeKVs(byte[] keyPrefix, int count)
+      throws IOException {
+    LevelDBKeyFilter emptyFilter = (preKey, currentKey, nextKey) -> true;
+    return getRangeKVs(keyPrefix, count, emptyFilter);
+  }
+
+  /**
+   * Returns a certain range of key value pairs as a list based on a
+   * startKey or count. Further a {@link LevelDBKeyFilter} can be added to
+   * filter keys if necessary. To prevent race conditions while listing
+   * entries, this implementation takes a snapshot and lists the entries from
+   * the snapshot. This may, on the other hand, cause the range result slight
+   * different with actual data if data is updating concurrently.
+   * <p>
+   * If the startKey is specified and found in levelDB, this key and the keys
+   * after this key will be included in the result. If the startKey is null
+   * all entries will be included as long as other conditions are satisfied.
+   * If the given startKey doesn't exist, an IOException will be thrown.
+   * <p>
+   * The count argument is to limit number of total entries to return,
+   * the value for count must be an integer greater than 0.
+   * <p>
+   * This method allows to specify one or more {@link LevelDBKeyFilter}
+   * to filter keys by certain condition. Once given, only the entries
+   * whose key passes all the filters will be included in the result.
+   *
+   * @param startKey a start key.
+   * @param count max number of entries to return.
+   * @param filters customized one or more {@link LevelDBKeyFilter}.
+   * @return a list of entries found in the database.
+   * @throws IOException if an invalid startKey is given or other I/O errors.
+   * @throws IllegalArgumentException if count is less than 0.
+   */
+  public List<Entry<byte[], byte[]>> getRangeKVs(byte[] startKey,
+      int count, LevelDBKeyFilter... filters) throws IOException {
+    List<Entry<byte[], byte[]>> result = new ArrayList<>();
+    long start = System.currentTimeMillis();
+    if (count < 0) {
+      throw new IllegalArgumentException(
+          "Invalid count given " + count + ", count must be greater than 0");
+    }
+    Snapshot snapShot = null;
+    DBIterator dbIter = null;
+    try {
+      snapShot = db.getSnapshot();
+      ReadOptions readOptions = new ReadOptions().snapshot(snapShot);
+      dbIter = db.iterator(readOptions);
+      dbIter.seekToFirst();
+      if (startKey == null) {
+        dbIter.seekToFirst();
+      } else {
+        if (db.get(startKey) == null) {
+          throw new IOException("Invalid start key, not found in current db.");
+        }
+        dbIter.seek(startKey);
+      }
+      while (dbIter.hasNext() && result.size() < count) {
+        byte[] preKey = dbIter.hasPrev() ? dbIter.peekPrev().getKey() : null;
+        byte[] nextKey = dbIter.hasNext() ? dbIter.peekNext().getKey() : null;
+        Entry<byte[], byte[]> current = dbIter.next();
+        if (filters == null || Arrays.asList(filters).stream()
+            .allMatch(entry -> entry.filterKey(preKey,
+                current.getKey(), nextKey))) {
+          result.add(current);
+        }
+      }
+    } finally {
+      if (snapShot != null) {
+        snapShot.close();
+      }
+      if (dbIter != null) {
+        dbIter.close();
+      }
+      long end = System.currentTimeMillis();
+      long timeConsumed = end - start;
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Time consumed for getRangeKVs() is {},"
+                + " result length is {}.",
+            timeConsumed, result.size());
+      }
+    }
+    return result;
+  }

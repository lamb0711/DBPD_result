HDFS-12919. RBF: Support erasure coding methods in RouterRpcServer. Contributed by Inigo Goiri.

+   * Get the active namenode resolver used by this client.
+   * @return Active namenode resolver.
+   */
+  public ActiveNamenodeResolver getNamenodeResolver() {
+    return this.namenodeResolver;
+  }
+
+  /**
-  public Object invokeSequential(
+  public <T> T invokeSequential(
-      final RemoteMethod remoteMethod, Class<?> expectedResultClass,
+      final RemoteMethod remoteMethod, Class<T> expectedResultClass,
-          return result;
+          @SuppressWarnings("unchecked")
+          T ret = (T)result;
+          return ret;
-    return firstResult;
+    @SuppressWarnings("unchecked")
+    T ret = (T)firstResult;
+    return ret;
-   * Invokes multiple concurrent proxy calls to different clients. Returns an
+   * Invoke multiple concurrent proxy calls to different clients. Returns an
-   * @return Result of invoking the method per subcluster: nsId -> result.
-   * @throws IOException If requiredResponse=true and any of the calls throw an
-   *           exception.
+   * @throws IOException If all the calls throw an exception.
-  public <T extends RemoteLocationContext> Map<T, Object> invokeConcurrent(
+  public <T extends RemoteLocationContext, R> void invokeConcurrent(
-    return invokeConcurrent(locations, method, requireResponse, standby, -1);
+    invokeConcurrent(locations, method, requireResponse, standby, void.class);
+   * @param <T> The type of the remote location.
+   * @param <R> The type of the remote method return.
+   * @param locations List of remote locations to call concurrently.
+   * @param method The remote method and parameters to invoke.
+   * @param requireResponse If true an exception will be thrown if all calls do
+   *          not complete. If false exceptions are ignored and all data results
+   *          successfully received are returned.
+   * @param standby If the requests should go to the standby namenodes too.
+   * @param clazz Type of the remote return type.
+   * @return Result of invoking the method per subcluster: nsId -> result.
+   * @throws IOException If requiredResponse=true and any of the calls throw an
+   *           exception.
+   */
+  public <T extends RemoteLocationContext, R> Map<T, R> invokeConcurrent(
+      final Collection<T> locations, final RemoteMethod method,
+      boolean requireResponse, boolean standby, Class<R> clazz)
+          throws IOException {
+    return invokeConcurrent(
+        locations, method, requireResponse, standby, -1, clazz);
+  }
+
+  /**
+   * Invokes multiple concurrent proxy calls to different clients. Returns an
+   * array of results.
+   *
+   * Re-throws exceptions generated by the remote RPC call as either
+   * RemoteException or IOException.
+   *
+   * @param <T> The type of the remote location.
+   * @param <R> The type of the remote method return.
+   * @param clazz Type of the remote return type.
-  public <T extends RemoteLocationContext> Map<T, Object> invokeConcurrent(
+  public <T extends RemoteLocationContext, R> Map<T, R> invokeConcurrent(
-      boolean requireResponse, boolean standby, long timeOutMs)
+      boolean requireResponse, boolean standby, long timeOutMs, Class<R> clazz)
-      return Collections.singletonMap(location, result);
+      return Collections.singletonMap(location, clazz.cast(result));
-      Map<T, Object> results = new TreeMap<>();
+      Map<T, R> results = new TreeMap<>();
-          results.put(location, result);
+          results.put(location, clazz.cast(result));

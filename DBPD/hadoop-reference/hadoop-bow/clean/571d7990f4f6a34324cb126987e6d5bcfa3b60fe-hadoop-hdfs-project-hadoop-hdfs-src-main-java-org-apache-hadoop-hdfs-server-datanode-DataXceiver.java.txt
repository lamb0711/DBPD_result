Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1196458 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.protocol.datatransfer.DataTransferProtoUtil;
+import org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BlockOpResponseProto.Builder;
+import org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.BlockOpResponseProtoOrBuilder;
+import org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.ReadOpChecksumInfoProto;
-    dataXceiverServer.childSockets.put(s, s);
+    dataXceiverServer.childSockets.put(s, s);
-            true, true, false, datanode, clientTraceFmt);
+            true, false, datanode, clientTraceFmt);
-        LOG.info("opReadBlock " + block + " received exception " + e);
-        sendResponse(s, ERROR, datanode.socketWriteTimeout);
+        String msg = "opReadBlock " + block + " received exception " + e; 
+        LOG.info(msg);
+        sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);
-      sendResponse(s, SUCCESS, datanode.socketWriteTimeout);
+      writeSuccessWithChecksumInfo(blockSender,
+          getStreamWithTimeout(s, datanode.socketWriteTimeout));
-      final long latestGenerationStamp) throws IOException {
+      final long latestGenerationStamp,
+      DataChecksum requestedChecksum) throws IOException {
-            clientname, srcDataNode, datanode);
+            clientname, srcDataNode, datanode, requestedChecksum);
-              minBytesRcvd, maxBytesRcvd, latestGenerationStamp);
+              minBytesRcvd, maxBytesRcvd, latestGenerationStamp, requestedChecksum);
-          if (blockReceiver != null) { // send checksum header
-            blockReceiver.writeChecksumHeader(mirrorOut);
-          }
-          writeResponse(SUCCESS, replyOut);
+          writeResponse(SUCCESS, null, replyOut);
-      writeResponse(Status.SUCCESS, out);
+      writeResponse(Status.SUCCESS, null, out);
-        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);
+        sendResponse(s, ERROR_ACCESS_TOKEN, "Invalid access token", datanode.socketWriteTimeout);
-      LOG.info("Not able to copy block " + block.getBlockId() + " to " 
-          + s.getRemoteSocketAddress() + " because threads quota is exceeded.");
-      sendResponse(s, ERROR, datanode.socketWriteTimeout);
+      String msg = "Not able to copy block " + block.getBlockId() + " to " 
+      + s.getRemoteSocketAddress() + " because threads quota is exceeded."; 
+      LOG.info(msg);
+      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);
-      blockSender = new BlockSender(block, 0, -1, false, false, false, 
-          datanode, null);
+      blockSender = new BlockSender(block, 0, -1, false, false, datanode, 
+          null);
-      writeResponse(SUCCESS, reply);
+      writeSuccessWithChecksumInfo(blockSender, reply);
-        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);
+        sendResponse(s, ERROR_ACCESS_TOKEN, "Invalid access token",
+            datanode.socketWriteTimeout);
-      LOG.warn("Not able to receive block " + block.getBlockId() + " from " 
-          + s.getRemoteSocketAddress() + " because threads quota is exceeded.");
-      sendResponse(s, ERROR, datanode.socketWriteTimeout);
+      String msg = "Not able to receive block " + block.getBlockId() + " from " 
+          + s.getRemoteSocketAddress() + " because threads quota is exceeded."; 
+      LOG.warn(msg);
+      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);
+    String errMsg = null;
+      
+      // get checksum info about the block we're copying
+      ReadOpChecksumInfoProto checksumInfo = copyResponse.getReadOpChecksumInfo();
+      DataChecksum remoteChecksum = DataTransferProtoUtil.fromProto(
+          checksumInfo.getChecksum());
-          null, 0, 0, 0, "", null, datanode);
+          null, 0, 0, 0, "", null, datanode, remoteChecksum);
-      LOG.info("opReplaceBlock " + block + " received exception " + ioe);
+      errMsg = "opReplaceBlock " + block + " received exception " + ioe; 
+      LOG.info(errMsg);
-        sendResponse(s, opStatus, datanode.socketWriteTimeout);
+        sendResponse(s, opStatus, errMsg, datanode.socketWriteTimeout);
-  private void sendResponse(Socket s, Status status,
+  private static void sendResponse(Socket s, Status status, String message,
-    DataOutputStream reply = 
-      new DataOutputStream(NetUtils.getOutputStream(s, timeout));
+    DataOutputStream reply = getStreamWithTimeout(s, timeout);
-    writeResponse(status, reply);
+    writeResponse(status, message, reply);
-  private void writeResponse(Status status, OutputStream out)
+  private static DataOutputStream getStreamWithTimeout(Socket s, long timeout)
+      throws IOException {
+    return new DataOutputStream(NetUtils.getOutputStream(s, timeout));
+  }
+
+  private static void writeResponse(Status status, String message, OutputStream out)
-    BlockOpResponseProto response = BlockOpResponseProto.newBuilder()
-      .setStatus(status)
+    BlockOpResponseProto.Builder response = BlockOpResponseProto.newBuilder()
+      .setStatus(status);
+    if (message != null) {
+      response.setMessage(message);
+    }
+    response.build().writeDelimitedTo(out);
+    out.flush();
+  }
+  
+  private void writeSuccessWithChecksumInfo(BlockSender blockSender,
+      DataOutputStream out) throws IOException {
+
+    ReadOpChecksumInfoProto ckInfo = ReadOpChecksumInfoProto.newBuilder()
+      .setChecksum(DataTransferProtoUtil.toProto(blockSender.getChecksum()))
+      .setChunkOffset(blockSender.getOffset())
-    
+      
+    BlockOpResponseProto response = BlockOpResponseProto.newBuilder()
+      .setStatus(SUCCESS)
+      .setReadOpChecksumInfo(ckInfo)
+      .build();

Revert "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)"

This reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.

-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.preemption.KillableContainer;
-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.preemption.PreemptionManager;
-  private PreemptionManager preemptionManager = new PreemptionManager();
-
-  private volatile boolean isLazyPreemptionEnabled = false;
-
-    this.applications = new ConcurrentHashMap<>();
+    this.applications =
+        new ConcurrentHashMap<ApplicationId,
+            SchedulerApplication<FiCaSchedulerApp>>();
-    this.isLazyPreemptionEnabled = conf.getLazyPreemptionEnabled();
-
-    // update lazy preemption
-    this.isLazyPreemptionEnabled = this.conf.getLazyPreemptionEnabled();
-
-    // Notify Preemption Manager
-    preemptionManager.refreshQueues(null, root);
-
-    // Notify Preemption Manager
-    preemptionManager.refreshQueues(null, root);
-      if (calculator.computeAvailableContainers(Resources
-              .add(node.getUnallocatedResource(), node.getTotalKillableResources()),
-          minimumAllocation) > 0) {
-
+      if (calculator.computeAvailableContainers(node.getUnallocatedResource(),
+        minimumAllocation) > 0) {
+            // TODO, now we only consider limits for parent for non-labeled
+            // resources, should consider labeled resources as well.
-                node.getPartition(), getClusterResource())),
+                RMNodeLabelsManager.NO_LABEL, getClusterResource())),
-    case MARK_CONTAINER_FOR_KILLABLE:
+    case KILL_PREEMPTED_CONTAINER:
-      ContainerPreemptEvent containerKillableEvent = (ContainerPreemptEvent)event;
-      RMContainer killableContainer = containerKillableEvent.getContainer();
-      markContainerForKillable(killableContainer);
-    }
-    break;
-    case MARK_CONTAINER_FOR_NONKILLABLE:
-    {
-      if (isLazyPreemptionEnabled) {
-        ContainerPreemptEvent cancelKillContainerEvent =
-            (ContainerPreemptEvent) event;
-        markContainerForNonKillable(cancelKillContainerEvent.getContainer());
-      }
+      ContainerPreemptEvent killContainerEvent = (ContainerPreemptEvent)event;
+      RMContainer containerToBeKilled = killContainerEvent.getContainer();
+      killPreemptedContainer(containerToBeKilled);
+    
-    ContainerId containerId = container.getId();
-        containerId.getApplicationAttemptId().getApplicationId();
+        container.getId().getApplicationAttemptId().getApplicationId();
+
+    if (containerStatus.getExitStatus() == ContainerExitStatus.PREEMPTED) {
+      schedulerHealth.updatePreemption(Time.now(), container.getNodeId(),
+        container.getId(), queue.getQueuePath());
+      schedulerHealth.updateSchedulerPreemptionCounts(1);
+    } else {
+      schedulerHealth.updateRelease(lastNodeUpdateTime, container.getNodeId(),
+        container.getId(), queue.getQueuePath());
+    }
-
+  
-  public synchronized void markContainerForKillable(
-      RMContainer killableContainer) {
+  @Override
+  public void killPreemptedContainer(RMContainer cont) {
-      LOG.debug(SchedulerEventType.MARK_CONTAINER_FOR_KILLABLE + ": container"
-          + killableContainer.toString());
+      LOG.debug(SchedulerEventType.KILL_PREEMPTED_CONTAINER + ": container"
+          + cont.toString());
-
-    if (!isLazyPreemptionEnabled) {
-      super.completedContainer(killableContainer, SchedulerUtils
-          .createPreemptedContainerStatus(killableContainer.getContainerId(),
-              SchedulerUtils.PREEMPTED_CONTAINER), RMContainerEventType.KILL);
-    } else {
-      FiCaSchedulerNode node = (FiCaSchedulerNode) getSchedulerNode(
-          killableContainer.getAllocatedNode());
-
-      FiCaSchedulerApp application = getCurrentAttemptForContainer(
-          killableContainer.getContainerId());
-
-      node.markContainerToKillable(killableContainer.getContainerId());
-
-      // notify PreemptionManager
-      // Get the application for the finished container
-      if (null != application) {
-        String leafQueueName = application.getCSLeafQueue().getQueueName();
-        getPreemptionManager().addKillableContainer(
-            new KillableContainer(killableContainer, node.getPartition(),
-                leafQueueName));
-      }    }
-  }
-
-  private synchronized void markContainerForNonKillable(
-      RMContainer nonKillableContainer) {
-    if (LOG.isDebugEnabled()) {
-      LOG.debug(
-          SchedulerEventType.MARK_CONTAINER_FOR_NONKILLABLE + ": container"
-              + nonKillableContainer.toString());
-    }
-
-    FiCaSchedulerNode node = (FiCaSchedulerNode) getSchedulerNode(
-        nonKillableContainer.getAllocatedNode());
-
-    FiCaSchedulerApp application = getCurrentAttemptForContainer(
-        nonKillableContainer.getContainerId());
-
-    node.markContainerToNonKillable(nonKillableContainer.getContainerId());
-
-    // notify PreemptionManager
-    // Get the application for the finished container
-    if (null != application) {
-      String leafQueueName = application.getCSLeafQueue().getQueueName();
-      getPreemptionManager().removeKillableContainer(
-          new KillableContainer(nonKillableContainer, node.getPartition(),
-              leafQueueName));
-    }
+    super.completedContainer(cont, SchedulerUtils
+        .createPreemptedContainerStatus(cont.getContainerId(),
+        SchedulerUtils.PREEMPTED_CONTAINER), RMContainerEventType.KILL);
-  @Override
-  public long getLastNodeUpdateTime() {
-    return lastNodeUpdateTime;
-  }
-
-  @Override
-
-  @Override
-  public PreemptionManager getPreemptionManager() {
-    return preemptionManager;
-  }

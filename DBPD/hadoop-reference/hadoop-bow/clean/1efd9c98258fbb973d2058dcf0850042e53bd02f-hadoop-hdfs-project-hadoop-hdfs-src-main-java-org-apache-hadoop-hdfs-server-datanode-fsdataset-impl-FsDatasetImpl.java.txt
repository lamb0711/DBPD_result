HDFS-7112. LazyWriter should use either async IO or one thread per physical disk. Contributed by Xiaoyu Yao.

+  final RamDiskAsyncLazyPersistService asyncLazyPersistService;
+    asyncLazyPersistService = new RamDiskAsyncLazyPersistService(datanode);
+    setupAsyncLazyPersistThreads();
+    setupAsyncLazyPersistThreads();
+
+    setupAsyncLazyPersistThreads();
-          if (replicaInfo.getIsPersisted() ==  false) {
+          if (!replicaInfo.getIsPersisted()) {
-          discardRamDiskReplica(replicaInfo, true);
+          ramDiskReplicaTracker.discardReplica(replicaInfo.getBlockPoolId(),
+            replicaInfo.getBlockId(), true);
+
+    if (asyncLazyPersistService != null) {
+      asyncLazyPersistService.shutdown();
+    }
+  public void onCompleteLazyPersist(String bpId, long blockId,
+      long creationTime, File[] savedFiles, FsVolumeImpl targetVolume) {
+    synchronized (FsDatasetImpl.this) {
+      ramDiskReplicaTracker.recordEndLazyPersist(bpId, blockId, savedFiles);
+
+      targetVolume.incDfsUsed(bpId,
+          savedFiles[0].length() + savedFiles[1].length());
+
+      // Update metrics (ignore the metadata file size)
+      datanode.getMetrics().incrRamDiskBlocksLazyPersisted();
+      datanode.getMetrics().incrRamDiskBytesLazyPersisted(savedFiles[1].length());
+      datanode.getMetrics().addRamDiskBlocksLazyPersistWindowMs(
+          Time.monotonicNow() - creationTime);
+
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("LazyWriter: Finish persisting RamDisk block: "
+            + " block pool Id: " + bpId + " block id: " + blockId
+            + " to block file " + savedFiles[1] + " and meta file " + savedFiles[0]
+            + " on target volume " + targetVolume);
+      }
+    }
+  }
+
+  @Override
+  public void onFailLazyPersist(String bpId, long blockId) {
+    RamDiskReplica block = null;
+    block = ramDiskReplicaTracker.getReplica(bpId, blockId);
+    if (block != null) {
+      LOG.warn("Failed to save replica " + block + ". re-enqueueing it.");
+      ramDiskReplicaTracker.reenqueueReplicaNotPersisted(block);
+    }
+  }
+
+  @Override
-  void discardRamDiskReplica(RamDiskReplica replica, boolean deleteSavedCopies) {
-    ramDiskReplicaTracker.discardReplica(replica.getBlockPoolId(),
-      replica.getBlockId(), deleteSavedCopies);
+  private boolean ramDiskConfigured() {
+    for (FsVolumeImpl v: getVolumes()){
+      if (v.isTransientStorage()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  // Add/Remove per DISK volume async lazy persist thread when RamDisk volume is
+  // added or removed.
+  // This should only be called when the FsDataSetImpl#volumes list is finalized.
+  private void setupAsyncLazyPersistThreads() {
+    boolean ramDiskConfigured = ramDiskConfigured();
+    for (FsVolumeImpl v: getVolumes()){
+      // Skip transient volumes
+      if (v.isTransientStorage()) {
+        continue;
+      }
+
+      // Add thread for DISK volume if RamDisk is configured
+      if (ramDiskConfigured &&
+          !asyncLazyPersistService.queryVolume(v.getCurrentDir())) {
+        asyncLazyPersistService.addVolume(v.getCurrentDir());
+      }
+
+      // Remove thread for DISK volume if RamDisk is not configured
+      if (!ramDiskConfigured &&
+          asyncLazyPersistService.queryVolume(v.getCurrentDir())) {
+        asyncLazyPersistService.removeVolume(v.getCurrentDir());
+      }
+    }
-    private void moveReplicaToNewVolume(String bpid, long blockId, long creationTime)
-        throws IOException {
-
-      FsVolumeImpl targetVolume;
-      ReplicaInfo replicaInfo;
-      BlockPoolSlice bpSlice;
-      File srcFile, srcMeta;
-      long genStamp;
-
-      synchronized (FsDatasetImpl.this) {
-        replicaInfo = volumeMap.get(bpid, blockId);
-
-        if (replicaInfo == null || !replicaInfo.getVolume().isTransientStorage()) {
-          // The block was either deleted before it could be checkpointed or
-          // it is already on persistent storage. This can occur if a second
-          // replica on persistent storage was found after the lazy write was
-          // scheduled.
-          return;
-        }
-
-        // Pick a target volume for the block.
-        targetVolume = volumes.getNextVolume(
-            StorageType.DEFAULT, replicaInfo.getNumBytes());
-
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("LazyWriter starting to save blockId=" + blockId + "; bpid=" + bpid);
-        }
-
-        ramDiskReplicaTracker.recordStartLazyPersist(bpid, blockId, targetVolume);
-        bpSlice = targetVolume.getBlockPoolSlice(bpid);
-        srcMeta = replicaInfo.getMetaFile();
-        srcFile = replicaInfo.getBlockFile();
-        genStamp = replicaInfo.getGenerationStamp();
-      }
-
-      // Drop the FsDatasetImpl lock for the file copy.
-      File[] savedFiles =
-          bpSlice.lazyPersistReplica(blockId, genStamp, srcMeta, srcFile);
-
-      synchronized (FsDatasetImpl.this) {
-        ramDiskReplicaTracker.recordEndLazyPersist(bpid, blockId, savedFiles);
-
-        // Update metrics (ignore the metadata file size)
-        datanode.getMetrics().incrRamDiskBlocksLazyPersisted();
-        datanode.getMetrics().incrRamDiskBytesLazyPersisted(replicaInfo.getNumBytes());
-        datanode.getMetrics().addRamDiskBlocksLazyPersistWindowMs(
-          Time.monotonicNow() - creationTime);
-
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("LazyWriter finished saving blockId=" + blockId + "; bpid=" + bpid +
-                        " to file " + savedFiles[1]);
-        }
-      }
-    }
-
+      FsVolumeImpl targetVolume;
+      ReplicaInfo replicaInfo;
-          moveReplicaToNewVolume(block.getBlockPoolId(), block.getBlockId(),
-            block.getCreationTime());
+          synchronized (FsDatasetImpl.this) {
+            replicaInfo = volumeMap.get(block.getBlockPoolId(), block.getBlockId());
+
+            // If replicaInfo is null, the block was either deleted before
+            // it could be checkpointed or it is already on persistent storage.
+            // This can occur if a second replica on persistent storage was found
+            // after the lazy write was scheduled.
+            if (replicaInfo != null &&
+                replicaInfo.getVolume().isTransientStorage()) {
+              // Pick a target volume to persist the block.
+              targetVolume = volumes.getNextVolume(
+                  StorageType.DEFAULT, replicaInfo.getNumBytes());
+
+              ramDiskReplicaTracker.recordStartLazyPersist(
+                  block.getBlockPoolId(), block.getBlockId(), targetVolume);
+
+              if (LOG.isDebugEnabled()) {
+                LOG.debug("LazyWriter: Start persisting RamDisk block:"
+                    + " block pool Id: " + block.getBlockPoolId()
+                    + " block id: " + block.getBlockId()
+                    + " on target volume " + targetVolume);
+              }
+
+              asyncLazyPersistService.submitLazyPersistTask(
+                  block.getBlockPoolId(), block.getBlockId(),
+                  replicaInfo.getGenerationStamp(), block.getCreationTime(),
+                  replicaInfo.getMetaFile(), replicaInfo.getBlockFile(),
+                  targetVolume);
+            }
+          }
-          ramDiskReplicaTracker.reenqueueReplicaNotPersisted(block);
+          onFailLazyPersist(block.getBlockPoolId(), block.getBlockId());
-
-          discardRamDiskReplica(replicaState, false);
+          ramDiskReplicaTracker.discardReplica(replicaState.getBlockPoolId(),
+              replicaState.getBlockId(), false);

Merge branch 'trunk' into HADOOP-12756

+import org.apache.hadoop.hdfs.server.diskbalancer.DiskBalancerException;
-import org.apache.hadoop.hdfs.tools.DiskBalancer;
+import org.apache.hadoop.hdfs.tools.DiskBalancerCLI;
-    addValidCommandParameters(DiskBalancer.REPORT,
+    addValidCommandParameters(DiskBalancerCLI.REPORT,
-    addValidCommandParameters(DiskBalancer.TOP, desc);
+    addValidCommandParameters(DiskBalancerCLI.TOP, desc);
-    desc = String.format("Print out volume information for a DataNode.");
-    addValidCommandParameters(DiskBalancer.NODE, desc);
+    desc = String.format("Print out volume information for DataNode(s).");
+    addValidCommandParameters(DiskBalancerCLI.NODE, desc);
-    Preconditions.checkState(cmd.hasOption(DiskBalancer.REPORT));
-    verifyCommandOptions(DiskBalancer.REPORT, cmd);
+    Preconditions.checkState(cmd.hasOption(DiskBalancerCLI.REPORT));
+    verifyCommandOptions(DiskBalancerCLI.REPORT, cmd);
-    if (cmd.hasOption(DiskBalancer.NODE)) {
+    if (cmd.hasOption(DiskBalancerCLI.NODE)) {
-       * Reporting volume information for a specific DataNode
+       * Reporting volume information for specific DataNode(s)
-     * get value that identifies a DataNode from command line, it could be UUID,
-     * IP address or host name.
+     * get value that identifies DataNode(s) from command line, it could be
+     * UUID, IP address or host name.
-    final String nodeVal = cmd.getOptionValue(DiskBalancer.NODE);
+    final String nodeVal = cmd.getOptionValue(DiskBalancerCLI.NODE);
-       * Reporting volume information for a specific DataNode
+       * Reporting volume information for specific DataNode(s)
-          "Reporting volume information for DataNode '%s'.", nodeVal);
+          "Reporting volume information for DataNode(s) '%s'.", nodeVal);
-      final String trueStr = "True";
-      final String falseStr = "False";
-      DiskBalancerDataNode dbdn = getNode(nodeVal);
-      // get storage path of datanode
-      populatePathNames(dbdn);
+      List<DiskBalancerDataNode> dbdns = Lists.newArrayList();
+      try {
+        dbdns = getNodes(nodeVal);
+      } catch (DiskBalancerException e) {
+        // If there are some invalid nodes that contained in nodeVal,
+        // the exception will be threw.
+        recordOutput(result, e.getMessage());
+        return;
+      }
-      if (dbdn == null) {
-        outputLine = String.format(
-            "Can't find a DataNode that matches '%s'.", nodeVal);
-        recordOutput(result, outputLine);
-      } else {
-        result.appendln(String.format(nodeFormat,
-            dbdn.getDataNodeName(),
-            dbdn.getDataNodeIP(),
-            dbdn.getDataNodePort(),
-            dbdn.getDataNodeUUID(),
-            dbdn.getVolumeCount(),
-            dbdn.getNodeDataDensity()));
-
-        List<String> volumeList = Lists.newArrayList();
-        for (DiskBalancerVolumeSet vset : dbdn.getVolumeSets().values()) {
-          for (DiskBalancerVolume vol : vset.getVolumes()) {
-            volumeList.add(String.format(volumeFormat,
-                vol.getStorageType(),
-                vol.getPath(),
-                vol.getUsedRatio(),
-                vol.getUsed(),
-                vol.getCapacity(),
-                vol.getFreeRatio(),
-                vol.getFreeSpace(),
-                vol.getCapacity(),
-                vol.isFailed() ? trueStr : falseStr,
-                vol.isReadOnly() ? trueStr : falseStr,
-                vol.isSkip() ? trueStr : falseStr,
-                vol.isTransient() ? trueStr : falseStr));
-          }
+      if (!dbdns.isEmpty()) {
+        for (DiskBalancerDataNode node : dbdns) {
+          recordNodeReport(result, node, nodeFormat, volumeFormat);
+          result.append(System.lineSeparator());
-
-        Collections.sort(volumeList);
-        result.appendln(
-            StringUtils.join(volumeList.toArray(), System.lineSeparator()));
+   * Put node report lines to string buffer.
+   */
+  private void recordNodeReport(StrBuilder result, DiskBalancerDataNode dbdn,
+      final String nodeFormat, final String volumeFormat) throws Exception {
+    final String trueStr = "True";
+    final String falseStr = "False";
+
+    // get storage path of datanode
+    populatePathNames(dbdn);
+    result.appendln(String.format(nodeFormat,
+        dbdn.getDataNodeName(),
+        dbdn.getDataNodeIP(),
+        dbdn.getDataNodePort(),
+        dbdn.getDataNodeUUID(),
+        dbdn.getVolumeCount(),
+        dbdn.getNodeDataDensity()));
+
+    List<String> volumeList = Lists.newArrayList();
+    for (DiskBalancerVolumeSet vset : dbdn.getVolumeSets().values()) {
+      for (DiskBalancerVolume vol : vset.getVolumes()) {
+        volumeList.add(String.format(volumeFormat,
+            vol.getStorageType(),
+            vol.getPath(),
+            vol.getUsedRatio(),
+            vol.getUsed(),
+            vol.getCapacity(),
+            vol.getFreeRatio(),
+            vol.getFreeSpace(),
+            vol.getCapacity(),
+            vol.isFailed() ? trueStr : falseStr,
+            vol.isReadOnly() ? trueStr: falseStr,
+            vol.isSkip() ? trueStr : falseStr,
+            vol.isTransient() ? trueStr : falseStr));
+      }
+    }
+
+    Collections.sort(volumeList);
+    result.appendln(
+        StringUtils.join(volumeList.toArray(), System.lineSeparator()));
+  }
+
+  /**
-    String header = "Report command reports the volume information of a given" +
-        " datanode, or prints out the list of nodes that will benefit from " +
-        "running disk balancer. Top defaults to " + getDefaultTop();
+    String header = "Report command reports the volume information of given" +
+        " datanode(s), or prints out the list of nodes that will benefit " +
+        "from running disk balancer. Top defaults to " + getDefaultTop();
-        + "-node {DataNodeID | IP | Hostname}";
+        + "-node [<DataNodeID|IP|Hostname>,...]";
-        header, DiskBalancer.getReportOptions(), footer);
+        header, DiskBalancerCLI.getReportOptions(), footer);

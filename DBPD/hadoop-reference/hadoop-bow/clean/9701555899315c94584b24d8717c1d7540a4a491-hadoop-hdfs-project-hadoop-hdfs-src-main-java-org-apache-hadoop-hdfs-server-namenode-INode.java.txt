HDFS-4534. Add INodeReference in order to support rename with snapshots.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1458164 13f79535-47bb-0310-9956-ffa450edef68

-import com.google.common.base.Preconditions;
-  private static enum PermissionStatusFormat {
-    MODE(0, 16),
-    GROUP(MODE.OFFSET + MODE.LENGTH, 25),
-    USER(GROUP.OFFSET + GROUP.LENGTH, 23);
+  /** parent is either an {@link INodeDirectory} or an {@link INodeReference}.*/
+  private INode parent = null;
-    final int OFFSET;
-    final int LENGTH; //bit length
-    final long MASK;
-
-    PermissionStatusFormat(int offset, int length) {
-      OFFSET = offset;
-      LENGTH = length;
-      MASK = ((-1L) >>> (64 - LENGTH)) << OFFSET;
-    }
-
-    long retrieve(long record) {
-      return (record & MASK) >>> OFFSET;
-    }
-
-    long combine(long bits, long record) {
-      return (record & ~MASK) | (bits << OFFSET);
-    }
-
-    /** Encode the {@link PermissionStatus} to a long. */
-    static long toLong(PermissionStatus ps) {
-      long permission = 0L;
-      final int user = SerialNumberManager.INSTANCE.getUserSerialNumber(
-          ps.getUserName());
-      permission = USER.combine(user, permission);
-      final int group = SerialNumberManager.INSTANCE.getGroupSerialNumber(
-          ps.getGroupName());
-      permission = GROUP.combine(group, permission);
-      final int mode = ps.getPermission().toShort();
-      permission = MODE.combine(mode, permission);
-      return permission;
-    }
-  }
-
-  /**
-   * The inode id
-   */
-  final private long id;
-
-  /**
-   *  The inode name is in java UTF8 encoding; 
-   *  The name in HdfsFileStatus should keep the same encoding as this.
-   *  if this encoding is changed, implicitly getFileInfo and listStatus in
-   *  clientProtocol are changed; The decoding at the client
-   *  side should change accordingly.
-   */
-  private byte[] name = null;
-  /** 
-   * Permission encoded using {@link PermissionStatusFormat}.
-   * Codes other than {@link #clonePermissionStatus(INode)}
-   * and {@link #updatePermissionStatus(PermissionStatusFormat, long)}
-   * should not modify it.
-   */
-  private long permission = 0L;
-  private INodeDirectory parent = null;
-  private long modificationTime = 0L;
-  private long accessTime = 0L;
-
-  private INode(long id, byte[] name, long permission, INodeDirectory parent,
-      long modificationTime, long accessTime) {
-    this.id = id;
-    this.name = name;
-    this.permission = permission;
+  INode(INode parent) {
-    this.modificationTime = modificationTime;
-    this.accessTime = accessTime;
-  }
-
-  INode(long id, byte[] name, PermissionStatus permissions,
-      long modificationTime, long accessTime) {
-    this(id, name, PermissionStatusFormat.toLong(permissions), null,
-        modificationTime, accessTime);
-  }
-  
-  /** @param other Other node to be copied */
-  INode(INode other) {
-    this(other.id, other.name, other.permission, other.parent, 
-        other.modificationTime, other.accessTime);
-  public long getId() {
-    return this.id;
-  }
+  public abstract long getId();
-  boolean isRoot() {
-    return name.length == 0;
+  final boolean isRoot() {
+    return getLocalNameBytes().length == 0;
-  /** Clone the {@link PermissionStatus}. */
-  void clonePermissionStatus(INode that) {
-    this.permission = that.permission;
-  }
-  public final PermissionStatus getPermissionStatus(Snapshot snapshot) {
-    return new PermissionStatus(getUserName(snapshot), getGroupName(snapshot),
-        getFsPermission(snapshot));
-  }
+  abstract PermissionStatus getPermissionStatus(Snapshot snapshot);
+
-  public final PermissionStatus getPermissionStatus() {
+  final PermissionStatus getPermissionStatus() {
-  private void updatePermissionStatus(PermissionStatusFormat f, long n) {
-    this.permission = f.combine(n, permission);
-  }
+
-  public final String getUserName(Snapshot snapshot) {
-    if (snapshot != null) {
-      return getSnapshotINode(snapshot).getUserName();
-    }
+  abstract String getUserName(Snapshot snapshot);
-    int n = (int)PermissionStatusFormat.USER.retrieve(permission);
-    return SerialNumberManager.INSTANCE.getUser(n);
-  }
+
-  final void setUser(String user) {
-    int n = SerialNumberManager.INSTANCE.getUserSerialNumber(user);
-    updatePermissionStatus(PermissionStatusFormat.USER, n);
-  }
+  abstract void setUser(String user);
+
-  public final String getGroupName(Snapshot snapshot) {
-    if (snapshot != null) {
-      return getSnapshotINode(snapshot).getGroupName();
-    }
+  abstract String getGroupName(Snapshot snapshot);
-    int n = (int)PermissionStatusFormat.GROUP.retrieve(permission);
-    return SerialNumberManager.INSTANCE.getGroup(n);
-  }
+
-  final void setGroup(String group) {
-    int n = SerialNumberManager.INSTANCE.getGroupSerialNumber(group);
-    updatePermissionStatus(PermissionStatusFormat.GROUP, n);
-  }
+  abstract void setGroup(String group);
+
+
-  public final FsPermission getFsPermission(Snapshot snapshot) {
-    if (snapshot != null) {
-      return getSnapshotINode(snapshot).getFsPermission();
-    }
-
-    return new FsPermission(
-        (short)PermissionStatusFormat.MODE.retrieve(permission));
-  }
+  abstract FsPermission getFsPermission(Snapshot snapshot);
+  
-  protected short getFsPermissionShort() {
-    return (short)PermissionStatusFormat.MODE.retrieve(permission);
-  }
+
-  void setPermission(FsPermission permission) {
-    final short mode = permission.toShort();
-    updatePermissionStatus(PermissionStatusFormat.MODE, mode);
-  }
+  abstract void setPermission(FsPermission permission);
+
-    return latest != null
-        && (parent == null
-            || (parent.isInLatestSnapshot(latest)
-                && this == parent.getChild(getLocalNameBytes(), latest)));
+    if (latest == null) {
+      return false;
+    }
+    final INodeDirectory parentDir = getParent();
+    if (parentDir == null) { // root
+      return true;
+    }
+    if (!parentDir.isInLatestSnapshot(latest)) {
+      return false;
+    }
+    final INode child = parentDir.getChild(getLocalNameBytes(), latest);
+    if (this == child) {
+      return true;
+    }
+    if (child == null || !(child.isReference())) {
+      return false;
+    }
+    return this == child.asReference().getReferredINode();
+  /** Check whether it's a reference. */
+  public boolean isReference() {
+    return false;
+  }
+
+  /** Cast this inode to an {@link INodeReference}.  */
+  public INodeReference asReference() {
+    throw new IllegalStateException("Current inode is not a reference: "
+        + this.toDetailString());
+  }
+
+   * Check whether it's a symlink
+   */
+  public boolean isSymlink() {
+    return false;
+  }
+
+  /** Cast this inode to an {@link INodeSymlink}.  */
+  public INodeSymlink asSymlink() {
+    throw new IllegalStateException("Current inode is not a symlink: "
+        + this.toDetailString());
+  }
+
+  /**
-    if (parent != null) {
-      parent.addSpaceConsumed(nsDelta, dsDelta);
+    final INodeDirectory parentDir = getParent();
+    if (parentDir != null) {
+      parentDir.addSpaceConsumed(nsDelta, dsDelta);
-  public String getLocalName() {
+  public final String getLocalName() {
+    final byte[] name = getLocalNameBytes();
-  public byte[] getLocalNameBytes() {
-    return name;
-  }
+  public abstract byte[] getLocalNameBytes();
-  public byte[] getKey() {
+  public final byte[] getKey() {
-  public void setLocalName(byte[] name) {
-    this.name = name;
-  }
+  public abstract void setLocalName(byte[] name);
-  public byte[][] getRelativePathNameBytes(INode ancestor) {
+  public final byte[][] getRelativePathNameBytes(INode ancestor) {
+    final INodeDirectory p = getParent();
-        + ", parent=" + (parent == null? null: parent.toStringWithObjectType());
+        + ", parent=" + (p == null? null: p.toStringWithObjectType());
+  }
+
+  /** @return the parent directory */
+  public final INodeDirectory getParent() {
+    return parent == null? null
+        : parent.isReference()? getParentReference().getParent(): parent.asDirectory();
-   * Get parent directory 
-   * @return parent INode
+   * @return the parent as a reference if this is a referred inode;
+   *         otherwise, return null.
-  public final INodeDirectory getParent() {
-    return this.parent;
+  public INodeReference getParentReference() {
+    return parent == null || !parent.isReference()? null: (INodeReference)parent;
-  public void setParent(INodeDirectory parent) {
+  public final void setParent(INodeDirectory parent) {
+    this.parent = parent;
+  }
+
+  /** Set container. */
+  public final void setParentReference(INodeReference parent) {
-  public void clearReferences() {
+  public void clear() {
-  public final long getModificationTime(Snapshot snapshot) {
-    if (snapshot != null) {
-      return getSnapshotINode(snapshot).modificationTime;
-    }
-
-    return this.modificationTime;
-  }
+  abstract long getModificationTime(Snapshot snapshot);
-  public final INode updateModificationTime(long mtime, Snapshot latest)
-      throws QuotaExceededException {
-    Preconditions.checkState(isDirectory());
-    if (mtime <= modificationTime) {
-      return this;
-    }
-    return setModificationTime(mtime, latest);
-  }
-
-  void cloneModificationTime(INode that) {
-    this.modificationTime = that.modificationTime;
-  }
+  public abstract INode updateModificationTime(long mtime, Snapshot latest)
+      throws QuotaExceededException;
-  public final void setModificationTime(long modificationTime) {
-    this.modificationTime = modificationTime;
-  }
+  public abstract void setModificationTime(long modificationTime);
+
-  public final long getAccessTime(Snapshot snapshot) {
-    if (snapshot != null) {
-      return getSnapshotINode(snapshot).accessTime;
-    }
-
-    return accessTime;
-  }
+  abstract long getAccessTime(Snapshot snapshot);
-  public void setAccessTime(long accessTime) {
-    this.accessTime = accessTime;
-  }
+  public abstract void setAccessTime(long accessTime);
+
-  public INode setAccessTime(long accessTime, Snapshot latest)
+  public final INode setAccessTime(long accessTime, Snapshot latest)
-  /**
-   * Check whether it's a symlink
-   */
-  public boolean isSymlink() {
-    return false;
-  }
-
-  /** Cast this inode to an {@link INodeSymlink}.  */
-  public INodeSymlink asSymlink() {
-    throw new IllegalStateException("Current inode is not a symlink: "
-        + this.toDetailString());
-  }
+    final byte[] name = getLocalNameBytes();
-    return Arrays.equals(this.name, ((INode)that).name);
+    return Arrays.equals(this.getLocalNameBytes(),
+        ((INode)that).getLocalNameBytes());
-    return Arrays.hashCode(this.name);
+    return Arrays.hashCode(getLocalNameBytes());
-    out.print(parent == null? null: parent.getLocalName() + "/");
+
+    final INodeDirectory p = getParent();
+    out.print(p == null? null: p.getLocalName() + "/");

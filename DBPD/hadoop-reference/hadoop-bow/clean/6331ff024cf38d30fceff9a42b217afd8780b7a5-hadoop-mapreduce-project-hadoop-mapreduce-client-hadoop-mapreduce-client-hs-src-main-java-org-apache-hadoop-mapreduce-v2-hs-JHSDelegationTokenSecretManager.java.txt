Merging r1526971 through r1527683 from trunk to branch HDFS-2832

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1527697 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.IOException;
+import java.util.Map.Entry;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.mapreduce.v2.hs.HistoryServerStateStoreService.HistoryServerState;
+import org.apache.hadoop.security.token.delegation.DelegationKey;
+  private static final Log LOG = LogFactory.getLog(
+      JHSDelegationTokenSecretManager.class);
+
+  private HistoryServerStateStoreService store;
+
+   * @param store history server state store for persisting state
-                                      long delegationTokenRemoverScanInterval) {
+                                      long delegationTokenRemoverScanInterval,
+                                      HistoryServerStateStoreService store) {
+    this.store = store;
+
+  @Override
+  protected void storeNewMasterKey(DelegationKey key) throws IOException {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Storing master key " + key.getKeyId());
+    }
+    try {
+      store.storeTokenMasterKey(key);
+    } catch (IOException e) {
+      LOG.error("Unable to store master key " + key.getKeyId(), e);
+    }
+  }
+
+  @Override
+  protected void removeStoredMasterKey(DelegationKey key) {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Removing master key " + key.getKeyId());
+    }
+    try {
+      store.removeTokenMasterKey(key);
+    } catch (IOException e) {
+      LOG.error("Unable to remove master key " + key.getKeyId(), e);
+    }
+  }
+
+  @Override
+  protected void storeNewToken(MRDelegationTokenIdentifier tokenId,
+      long renewDate) {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Storing token " + tokenId.getSequenceNumber());
+    }
+    try {
+      store.storeToken(tokenId, renewDate);
+    } catch (IOException e) {
+      LOG.error("Unable to store token " + tokenId.getSequenceNumber(), e);
+    }
+  }
+
+  @Override
+  protected void removeStoredToken(MRDelegationTokenIdentifier tokenId)
+      throws IOException {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Storing token " + tokenId.getSequenceNumber());
+    }
+    try {
+      store.removeToken(tokenId);
+    } catch (IOException e) {
+      LOG.error("Unable to remove token " + tokenId.getSequenceNumber(), e);
+    }
+  }
+
+  @Override
+  protected void updateStoredToken(MRDelegationTokenIdentifier tokenId,
+      long renewDate) {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Updating token " + tokenId.getSequenceNumber());
+    }
+    try {
+      store.updateToken(tokenId, renewDate);
+    } catch (IOException e) {
+      LOG.error("Unable to update token " + tokenId.getSequenceNumber(), e);
+    }
+  }
+
+  public void recover(HistoryServerState state) throws IOException {
+    LOG.info("Recovering " + getClass().getSimpleName());
+    for (DelegationKey key : state.tokenMasterKeyState) {
+      addKey(key);
+    }
+    for (Entry<MRDelegationTokenIdentifier, Long> entry :
+        state.tokenState.entrySet()) {
+      addPersistedDelegationToken(entry.getKey(), entry.getValue());
+    }
+  }

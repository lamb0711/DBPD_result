YARN-996. REST API support for node resource configuration. Contributed by Inigo Goiri.

+import java.util.Collection;
+import java.util.Map.Entry;
+import org.apache.hadoop.yarn.server.resourcemanager.webapp.dao.ResourceInfo;
+import org.apache.hadoop.yarn.server.resourcemanager.webapp.dao.ResourceOptionInfo;
+   * Get the active subclusters in the federation.
+   * @return Map from subcluster id to its info.
+   * @throws NotFoundException If the subclusters cannot be found.
+   */
+  private Map<SubClusterId, SubClusterInfo> getActiveSubclusters()
+      throws NotFoundException {
+    try {
+      return federationFacade.getSubClusters(true);
+    } catch (YarnException e) {
+      throw new NotFoundException(e.getMessage());
+    }
+  }
+
+  /**
-    Map<SubClusterId, SubClusterInfo> subClustersActive = null;
-    try {
-      subClustersActive = federationFacade.getSubClusters(true);
-    } catch (YarnException e) {
-      throw new NotFoundException(e.getMessage());
-    }
-
+    final Map<SubClusterId, SubClusterInfo> subClustersActive =
+        getActiveSubclusters();
+    final Map<SubClusterInfo, NodeInfo> results =
+        getNode(subClustersActive.values(), nodeId);
-    // Send the requests in parallel
-    CompletionService<NodeInfo> compSvc =
-        new ExecutorCompletionService<NodeInfo>(this.threadpool);
-
-    for (final SubClusterInfo info : subClustersActive.values()) {
-      compSvc.submit(new Callable<NodeInfo>() {
-        @Override
-        public NodeInfo call() {
-          DefaultRequestInterceptorREST interceptor =
-              getOrCreateInterceptorForSubCluster(
-                  info.getSubClusterId(), info.getRMWebServiceAddress());
-          try {
-            NodeInfo nodeInfo = interceptor.getNode(nodeId);
-            return nodeInfo;
-          } catch (Exception e) {
-            LOG.error("Subcluster {} failed to return nodeInfo.",
-                info.getSubClusterId());
-            return null;
-          }
-        }
-      });
-    }
-
-    // Collect all the responses in parallel
+    // Collect the responses
-    for (int i = 0; i < subClustersActive.size(); i++) {
+    for (NodeInfo nodeResponse : results.values()) {
-        Future<NodeInfo> future = compSvc.take();
-        NodeInfo nodeResponse = future.get();
-
-        // Check if the node was found in this SubCluster
-        if (nodeResponse != null) {
-          // Check if the node was already found in a different SubCluster and
-          // it has an old health report
-          if (nodeInfo == null || nodeInfo.getLastHealthUpdate() <
-              nodeResponse.getLastHealthUpdate()) {
-            nodeInfo = nodeResponse;
-          }
+        // Check if the node was already found in a different SubCluster and
+        // it has an old health report
+        if (nodeInfo == null || nodeInfo.getLastHealthUpdate() <
+            nodeResponse.getLastHealthUpdate()) {
+          nodeInfo = nodeResponse;
+
+   * Get a node and the subcluster where it is.
+   * @param subClusters Subclusters where to search.
+   * @param nodeId Identifier of the node we are looking for.
+   * @return Map between subcluster and node.
+   */
+  private Map<SubClusterInfo, NodeInfo> getNode(
+      Collection<SubClusterInfo> subClusters, String nodeId) {
+
+    // Send the requests in parallel
+    CompletionService<NodeInfo> compSvc =
+        new ExecutorCompletionService<NodeInfo>(this.threadpool);
+    final Map<SubClusterInfo, Future<NodeInfo>> futures = new HashMap<>();
+    for (final SubClusterInfo subcluster : subClusters) {
+      final SubClusterId subclusterId = subcluster.getSubClusterId();
+      Future<NodeInfo> result = compSvc.submit(() -> {
+        try {
+          DefaultRequestInterceptorREST interceptor =
+              getOrCreateInterceptorForSubCluster(
+                  subclusterId, subcluster.getRMWebServiceAddress());
+          return interceptor.getNode(nodeId);
+        } catch (Exception e) {
+          LOG.error("Subcluster {} failed to return nodeInfo.",
+              subclusterId);
+          return null;
+        }
+      });
+      futures.put(subcluster, result);
+    }
+
+    // Collect the results
+    final Map<SubClusterInfo, NodeInfo> results = new HashMap<>();
+    for (Entry<SubClusterInfo, Future<NodeInfo>> entry : futures.entrySet()) {
+      try {
+        final Future<NodeInfo> future = entry.getValue();
+        final NodeInfo nodeInfo = future.get();
+        // Check if the node was found in this SubCluster
+        if (nodeInfo != null) {
+          SubClusterInfo subcluster = entry.getKey();
+          results.put(subcluster, nodeInfo);
+        }
+      } catch (Throwable e) {
+        LOG.warn("Failed to get node report ", e);
+      }
+    }
+
+    return results;
+  }
+
+  /**
+   * Get the subcluster a node belongs to.
+   * @param nodeId Identifier of the node we are looking for.
+   * @return The subcluster containing the node.
+   * @throws NotFoundException If the node cannot be found.
+   */
+  private SubClusterInfo getNodeSubcluster(String nodeId)
+      throws NotFoundException {
+
+    final Collection<SubClusterInfo> subClusters =
+        getActiveSubclusters().values();
+    final Map<SubClusterInfo, NodeInfo> results =
+        getNode(subClusters, nodeId);
+    SubClusterInfo subcluster = null;
+    NodeInfo nodeInfo = null;
+    for (Entry<SubClusterInfo, NodeInfo> entry : results.entrySet()) {
+      NodeInfo nodeResponse = entry.getValue();
+      if (nodeInfo == null || nodeInfo.getLastHealthUpdate() <
+          nodeResponse.getLastHealthUpdate()) {
+        subcluster = entry.getKey();
+        nodeInfo = nodeResponse;
+      }
+    }
+    if (subcluster == null) {
+      throw new NotFoundException(
+          "Cannot find " + nodeId + " in any subcluster");
+    }
+    return subcluster;
+  }
+
+  /**
-    Map<SubClusterId, SubClusterInfo> subClustersActive = null;
+    final Map<SubClusterId, SubClusterInfo> subClustersActive;
-      subClustersActive = federationFacade.getSubClusters(true);
-    } catch (YarnException e) {
+      subClustersActive = getActiveSubclusters();
+    } catch (Exception e) {
+  public ResourceInfo updateNodeResource(HttpServletRequest hsr,
+      String nodeId, ResourceOptionInfo resourceOption) {
+    SubClusterInfo subcluster = getNodeSubcluster(nodeId);
+    DefaultRequestInterceptorREST interceptor =
+        getOrCreateInterceptorForSubCluster(
+            subcluster.getSubClusterId(),
+            subcluster.getRMWebServiceAddress());
+    return interceptor.updateNodeResource(hsr, nodeId, resourceOption);
+  }
+
+  @Override
-    Map<SubClusterId, SubClusterInfo> subClustersActive = null;
+    final Map<SubClusterId, SubClusterInfo> subClustersActive;
-      subClustersActive = federationFacade.getSubClusters(true);
-    } catch (YarnException e) {
+      subClustersActive = getActiveSubclusters();
+    } catch (Exception e) {

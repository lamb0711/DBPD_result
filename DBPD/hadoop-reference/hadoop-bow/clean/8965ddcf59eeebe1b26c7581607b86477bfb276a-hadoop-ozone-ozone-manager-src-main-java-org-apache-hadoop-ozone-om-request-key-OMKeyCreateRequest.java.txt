HDDS-1731. Implement File CreateFile Request to use Cache and DoubleBuffer. (#1044)



+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
-import org.apache.hadoop.ozone.audit.AuditLogger;
-import org.apache.hadoop.ozone.om.exceptions.OMException;
-import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;
+import org.apache.hadoop.ozone.om.exceptions.OMException;
+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;
+import org.apache.hadoop.ozone.om.response.file.OMFileCreateResponse;
-
+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.CreateKey;
+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.CreateFile;
-
-    AuditLogger auditLogger = ozoneManager.getAuditLogger();
-
-    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);
-
-    OMResponse.Builder omResponse = OMResponse.newBuilder().setCmdType(
-            OzoneManagerProtocolProtos.Type.CreateKey).setStatus(
-            OzoneManagerProtocolProtos.Status.OK).setSuccess(true);
-
+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();
+    OmKeyInfo omKeyInfo = null;
+    final List< OmKeyLocationInfo > locations = new ArrayList<>();
+    FileEncryptionInfo encryptionInfo = null;
+    IOException exception = null;
+    boolean acquireLock = false;
-    } catch (IOException ex) {
-      LOG.error("Open failed for Key: {} in volume/bucket:{}/{}",
-          keyName, bucketName, volumeName, ex);
-      omMetrics.incNumKeyAllocateFails();
-      auditLog(auditLogger, buildAuditMessage(OMAction.ALLOCATE_KEY, auditMap,
-          ex, getOmRequest().getUserInfo()));
-      return new OMKeyCreateResponse(null, -1L,
-          createErrorOMResponse(omResponse, ex));
-    }
-    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();
-    String dbOpenKeyName = omMetadataManager.getOpenKey(volumeName,
-        bucketName, keyName, createKeyRequest.getClientID());
-    String dbKeyName = omMetadataManager.getOzoneKey(volumeName, bucketName,
-        keyName);
-    String dbBucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);
-
-    OmKeyInfo omKeyInfo = null;
-    final List< OmKeyLocationInfo > locations = new ArrayList<>();
-    FileEncryptionInfo encryptionInfo = null;
-    long openVersion = 0L;
-    IOException exception = null;
-    omMetadataManager.getLock().acquireLock(BUCKET_LOCK, volumeName,
-        bucketName);
-    try {
+      acquireLock = omMetadataManager.getLock().acquireLock(BUCKET_LOCK,
+          volumeName, bucketName);
-      OmBucketInfo bucketInfo =
-          omMetadataManager.getBucketTable().get(dbBucketKey);
+
+      OmBucketInfo bucketInfo = omMetadataManager.getBucketTable().get(
+              omMetadataManager.getBucketKey(volumeName, bucketName));
+
-      omKeyInfo = prepareKeyInfo(omMetadataManager, keyArgs, dbKeyName,
+
+      omKeyInfo = prepareKeyInfo(omMetadataManager, keyArgs,
+          omMetadataManager.getOzoneKey(volumeName, bucketName, keyName),
+
-      omMetadataManager.getLock().releaseLock(BUCKET_LOCK, volumeName,
-          bucketName);
+      if (acquireLock) {
+        omMetadataManager.getLock().releaseLock(BUCKET_LOCK, volumeName,
+            bucketName);
+      }
+    return prepareCreateKeyResponse(keyArgs, omKeyInfo, locations,
+        encryptionInfo, exception, createKeyRequest.getClientID(),
+        transactionLogIndex, volumeName, bucketName, keyName, ozoneManager,
+        OMAction.ALLOCATE_KEY);
+  }
+  /**
+   * Prepare the response returned to the client.
+   * @param keyArgs
+   * @param omKeyInfo
+   * @param locations
+   * @param encryptionInfo
+   * @param exception
+   * @param clientID
+   * @param transactionLogIndex
+   * @param volumeName
+   * @param bucketName
+   * @param keyName
+   * @param ozoneManager
+   * @return OMClientResponse
+   */
+  @SuppressWarnings("parameternumber")
+  protected OMClientResponse prepareCreateKeyResponse(@Nonnull KeyArgs keyArgs,
+      OmKeyInfo omKeyInfo, @Nonnull List<OmKeyLocationInfo> locations,
+      FileEncryptionInfo encryptionInfo, @Nullable IOException exception,
+      long clientID, long transactionLogIndex, @Nonnull String volumeName,
+      @Nonnull String bucketName, @Nonnull String keyName,
+      @Nonnull OzoneManager ozoneManager, @Nonnull OMAction omAction) {
+
+    OMResponse.Builder omResponse = OMResponse.newBuilder().setStatus(
+        OzoneManagerProtocolProtos.Status.OK);
+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();
+
+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);
+
+    OMClientResponse omClientResponse = null;
-      openVersion = omKeyInfo.getLatestVersionLocations().getVersion();
+      long openVersion = omKeyInfo.getLatestVersionLocations().getVersion();
+      // Append blocks
-        LOG.error("Open failed for Key: {} in volume/bucket:{}/{}",
-            keyName, bucketName, volumeName, ex);
-        omMetrics.incNumKeyAllocateFails();
-        auditLog(auditLogger, buildAuditMessage(OMAction.ALLOCATE_KEY, auditMap,
-            ex, getOmRequest().getUserInfo()));
-        return new OMKeyCreateResponse(null, -1L,
-            createErrorOMResponse(omResponse, ex));
+        exception = ex;
-      // Add to cache entry can be done outside of lock for this openKey.
-      // Even if bucket gets deleted, when commitKey we shall identify if
-      // bucket gets deleted.
-      omMetadataManager.getOpenKeyTable().addCacheEntry(
-          new CacheKey<>(dbOpenKeyName),
-          new CacheValue<>(Optional.of(omKeyInfo), transactionLogIndex));
+      if (exception != null) {
+        LOG.error("{} failed for Key: {} in volume/bucket:{}/{}",
+            omAction.getAction(), keyName, bucketName, volumeName, exception);
+        omClientResponse = createKeyErrorResponse(ozoneManager.getMetrics(),
+            omAction, exception, omResponse);
+      } else {
+        String dbOpenKeyName = omMetadataManager.getOpenKey(volumeName,
+            bucketName, keyName, clientID);
-      LOG.debug("Key {} allocated in volume/bucket: {}/{}", keyName, volumeName,
-          bucketName);
+        // Add to cache entry can be done outside of lock for this openKey.
+        // Even if bucket gets deleted, when commitKey we shall identify if
+        // bucket gets deleted.
+        omMetadataManager.getOpenKeyTable().addCacheEntry(
+            new CacheKey<>(dbOpenKeyName),
+            new CacheValue<>(Optional.of(omKeyInfo), transactionLogIndex));
-      auditLog(auditLogger, buildAuditMessage(OMAction.ALLOCATE_KEY, auditMap,
-          exception, getOmRequest().getUserInfo()));
+        LOG.debug("{} for Key: {} in volume/bucket: {}/{}",
+            omAction.getAction(), keyName, volumeName, bucketName);
-      long clientID = createKeyRequest.getClientID();
-      omResponse.setCreateKeyResponse(CreateKeyResponse.newBuilder()
-          .setKeyInfo(omKeyInfo.getProtobuf())
-          .setID(clientID).setOpenVersion(openVersion)
-          .build());
-
-      return new OMKeyCreateResponse(omKeyInfo, clientID, omResponse.build());
+        if (omAction == OMAction.CREATE_FILE) {
+          ozoneManager.getMetrics().incNumCreateFile();
+          omResponse.setCreateFileResponse(
+              OzoneManagerProtocolProtos.CreateFileResponse.newBuilder()
+                  .setKeyInfo(omKeyInfo.getProtobuf())
+                  .setID(clientID)
+                  .setOpenVersion(openVersion).build());
+          omResponse.setCmdType(OzoneManagerProtocolProtos.Type.CreateFile);
+          omClientResponse = new OMFileCreateResponse(omKeyInfo, clientID,
+              omResponse.build());
+        } else {
+          ozoneManager.getMetrics().incNumKeyAllocates();
+          omResponse.setCreateKeyResponse(CreateKeyResponse.newBuilder()
+              .setKeyInfo(omKeyInfo.getProtobuf())
+              .setID(clientID).setOpenVersion(openVersion)
+              .build());
+          omResponse.setCmdType(OzoneManagerProtocolProtos.Type.CreateKey);
+          omClientResponse = new OMKeyCreateResponse(omKeyInfo, clientID,
+            omResponse.build());
+        }
+      }
-      auditLog(auditLogger, buildAuditMessage(OMAction.ALLOCATE_KEY, auditMap,
-          exception, getOmRequest().getUserInfo()));
-      LOG.error("Open failed for Key: {} in volume/bucket:{}/{}",
-          keyName, bucketName, volumeName, exception);
+      LOG.error("{} failed for Key: {} in volume/bucket:{}/{}",
+          omAction.getAction(), keyName, volumeName, bucketName, exception);
+      omClientResponse = createKeyErrorResponse(ozoneManager.getMetrics(),
+          omAction, exception, omResponse);
+    }
+    // audit log
+    auditLog(ozoneManager.getAuditLogger(), buildAuditMessage(omAction,
+        auditMap, exception, getOmRequest().getUserInfo()));
+    return omClientResponse;
+  }
+
+  private OMClientResponse createKeyErrorResponse(@Nonnull OMMetrics omMetrics,
+      @Nonnull OMAction omAction, @Nonnull IOException exception,
+      @Nonnull OMResponse.Builder omResponse) {
+    if (omAction == OMAction.CREATE_FILE) {
+      omMetrics.incNumCreateFileFails();
+      omResponse.setCmdType(CreateFile);
+      return new OMFileCreateResponse(null, -1L,
+          createErrorOMResponse(omResponse, exception));
+    } else {
+      omResponse.setCmdType(CreateKey);
-  private OmKeyInfo prepareKeyInfo(OMMetadataManager omMetadataManager,
-      KeyArgs keyArgs, String dbKeyName, long size,
-      List<OmKeyLocationInfo> locations, FileEncryptionInfo encInfo)
+  /**
+   * Prepare OmKeyInfo which will be persisted to openKeyTable.
+   * @param omMetadataManager
+   * @param keyArgs
+   * @param dbKeyName
+   * @param size
+   * @param locations
+   * @param encInfo
+   * @return OmKeyInfo
+   * @throws IOException
+   */
+  protected OmKeyInfo prepareKeyInfo(
+      @Nonnull OMMetadataManager omMetadataManager,
+      @Nonnull KeyArgs keyArgs, @Nonnull String dbKeyName, long size,
+      @Nonnull List<OmKeyLocationInfo> locations, FileEncryptionInfo encInfo)
-  private OmKeyInfo prepareMultipartKeyInfo(OMMetadataManager omMetadataManager,
-      KeyArgs args, long size, List<OmKeyLocationInfo> locations,
+  /**
+   * Prepare OmKeyInfo for multi-part upload part key which will be persisted
+   * to openKeyTable.
+   * @param omMetadataManager
+   * @param args
+   * @param size
+   * @param locations
+   * @param encInfo
+   * @return OmKeyInfo
+   * @throws IOException
+   */
+  private OmKeyInfo prepareMultipartKeyInfo(
+      @Nonnull OMMetadataManager omMetadataManager,
+      @Nonnull KeyArgs args, long size,
+      @Nonnull List<OmKeyLocationInfo> locations,
-   * @return
+   * @return OmKeyInfo
-  private OmKeyInfo createKeyInfo(KeyArgs keyArgs,
-      List<OmKeyLocationInfo> locations, HddsProtos.ReplicationFactor factor,
-      HddsProtos.ReplicationType type, long size, FileEncryptionInfo encInfo) {
+  private OmKeyInfo createKeyInfo(@Nonnull KeyArgs keyArgs,
+      @Nonnull List<OmKeyLocationInfo> locations,
+      @Nonnull HddsProtos.ReplicationFactor factor,
+      @Nonnull HddsProtos.ReplicationType type, long size,
+      FileEncryptionInfo encInfo) {
+

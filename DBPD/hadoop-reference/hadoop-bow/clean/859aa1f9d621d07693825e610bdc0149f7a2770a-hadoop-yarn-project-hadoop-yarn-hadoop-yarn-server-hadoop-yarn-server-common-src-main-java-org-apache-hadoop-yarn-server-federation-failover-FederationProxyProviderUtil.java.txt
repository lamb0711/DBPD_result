YARN-5531. UnmanagedAM pool manager for federating application across clusters. (Botong Huang via Subru).

(cherry picked from commit 73bb2102ce4b82b3a3bed91319f7c8f067ddc3e8)

-import java.security.PrivilegedExceptionAction;
-import org.apache.hadoop.fs.CommonConfigurationKeysPublic;
-import org.apache.hadoop.security.SaslRpcServer;
+import org.apache.hadoop.security.token.TokenIdentifier;
-import org.apache.hadoop.yarn.exceptions.YarnRuntimeException;
+import org.apache.hadoop.yarn.server.utils.AMRMClientUtils;
+  // Disable constructor
+  private FederationProxyProviderUtil() {
+  }
+
-   * Create a proxy for the specified protocol. For non-HA, this is a direct
-   * connection to the ResourceManager address. When HA is enabled, the proxy
-   * handles the failover between the ResourceManagers as well.
+   * Create a proxy for the specified protocol in the context of Federation. For
+   * non-HA, this is a direct connection to the ResourceManager address. When HA
+   * is enabled, the proxy handles the failover between the ResourceManagers as
+   * well.
-      final Class<T> protocol, SubClusterId subClusterId,
-      UserGroupInformation user) throws IOException {
+      Class<T> protocol, SubClusterId subClusterId, UserGroupInformation user)
+      throws IOException {
-   * Create a proxy for the specified protocol. For non-HA, this is a direct
-   * connection to the ResourceManager address. When HA is enabled, the proxy
-   * handles the failover between the ResourceManagers as well.
+   * Create a proxy for the specified protocol in the context of Federation. For
+   * non-HA, this is a direct connection to the ResourceManager address. When HA
+   * is enabled, the proxy handles the failover between the ResourceManagers as
+   * well.
-  @SuppressWarnings("unchecked")
-  public static <T> T createRMProxy(final Configuration configuration,
+  public static <T> T createRMProxy(Configuration configuration,
-      UserGroupInformation user, final Token token) throws IOException {
-    try {
-      final YarnConfiguration conf = new YarnConfiguration(configuration);
-      updateConf(conf, subClusterId);
-      if (token != null) {
-        LOG.info(
-            "Creating RMProxy with a token: {} to subcluster: {}"
-                + " for protocol: {}",
-            token, subClusterId, protocol.getSimpleName());
-        user.addToken(token);
-        setAuthModeInConf(conf);
-      } else {
-        LOG.info("Creating RMProxy without a token to subcluster: {}"
-            + " for protocol: {}", subClusterId, protocol.getSimpleName());
-      }
-      final T proxyConnection = user.doAs(new PrivilegedExceptionAction<T>() {
-        @Override
-        public T run() throws Exception {
-          return ClientRMProxy.createRMProxy(conf, protocol);
-        }
-      });
-
-      return proxyConnection;
-    } catch (IOException e) {
-      String message =
-          "Error while creating of RM application master service proxy for"
-              + " appAttemptId: " + user;
-      LOG.info(message);
-      throw new YarnRuntimeException(message, e);
-    } catch (InterruptedException e) {
-      throw new YarnRuntimeException(e);
-    }
+      UserGroupInformation user, Token<? extends TokenIdentifier> token)
+      throws IOException {
+    final YarnConfiguration config = new YarnConfiguration(configuration);
+    updateConfForFederation(config, subClusterId.getId());
+    return AMRMClientUtils.createRMProxy(config, protocol, user, token);
-  private static void setAuthModeInConf(Configuration conf) {
-    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,
-        SaslRpcServer.AuthMethod.TOKEN.toString());
-  }
-
-  // updating the conf with the refreshed RM addresses as proxy creations
-  // are based out of conf
-  private static void updateConf(Configuration conf,
-      SubClusterId subClusterId) {
-    conf.set(YarnConfiguration.RM_CLUSTER_ID, subClusterId.getId());
-    // In a Federation setting, we will connect to not just the local cluster RM
-    // but also multiple external RMs. The membership information of all the RMs
-    // that are currently
-    // participating in Federation is available in the central
-    // FederationStateStore.
-    // So we will:
-    // 1. obtain the RM service addresses from FederationStateStore using the
-    // FederationRMFailoverProxyProvider.
-    // 2. disable traditional HA as that depends on local configuration lookup
-    // for RMs using indexes.
-    // 3. we will enable federation failover IF traditional HA is enabled so
-    // that the appropriate failover RetryPolicy is initialized.
+  /**
+   * Updating the conf with Federation as long as certain subclusterId.
+   *
+   * @param conf configuration
+   * @param subClusterId subclusterId for the conf
+   */
+  public static void updateConfForFederation(Configuration conf,
+      String subClusterId) {
+    conf.set(YarnConfiguration.RM_CLUSTER_ID, subClusterId);
+    /*
+     * In a Federation setting, we will connect to not just the local cluster RM
+     * but also multiple external RMs. The membership information of all the RMs
+     * that are currently participating in Federation is available in the
+     * central FederationStateStore. So we will: 1. obtain the RM service
+     * addresses from FederationStateStore using the
+     * FederationRMFailoverProxyProvider. 2. disable traditional HA as that
+     * depends on local configuration lookup for RMs using indexes. 3. we will
+     * enable federation failover IF traditional HA is enabled so that the
+     * appropriate failover RetryPolicy is initialized.
+     */
-  // disable instantiation
-  private FederationProxyProviderUtil() {
-  }
-

YARN-5516. Add REST API for supporting recurring reservations. (Sean Po via Subru).

+  private final long maxPeriodicity;
-      long maxPeriodicty, RMContext rmContext) {
+      long maxPeriodicity, RMContext rmContext) {
-        maxAlloc, queueName, replanner, getMoveOnExpiry, maxPeriodicty,
+        maxAlloc, queueName, replanner, getMoveOnExpiry, maxPeriodicity,
+    this.maxPeriodicity = maxPeriodicty;
-        new PeriodicRLESparseResourceAllocation(resCalc, maxPeriodicty);
+        new PeriodicRLESparseResourceAllocation(resCalc, this.maxPeriodicity);
-              long t = endTime % period;
-              // check for both contained and wrap-around reservations
-              if ((t - startTime) * (t - endTime)
-                  * (startTime - endTime) >= 0) {
+              // The shift is used to remove the wrap around for the
+              // reservation interval. The wrap around will still
+              // exist for the search interval.
+              long shift = reservation.getStartTime() % period;
+              // This is the duration of the reservation since
+              // duration < period.
+              long periodicReservationEnd =
+                  (reservation.getEndTime() -shift) % period;
+              long periodicSearchStart = (startTime - shift) % period;
+              long periodicSearchEnd = (endTime - shift) % period;
+              long searchDuration = endTime - startTime;
+
+              // 1. If the searchDuration is greater than the period, then
+              // the reservation is within the interval. This will allow
+              // us to ignore cases where search end > search start >
+              // reservation end.
+              // 2/3. If the search end is less than the reservation end, or if
+              // the search start is less than the reservation end, then the
+              // reservation will be in the reservation since
+              // periodic reservation start is always zero. Note that neither
+              // of those values will ever be negative.
+              // 4. If the search end is less than the search start, then
+              // there is a wrap around, and both values are implicitly
+              // greater than the reservation end because of condition 2/3,
+              // so the reservation is within the search interval.
+              if (searchDuration > period
+                  || periodicSearchEnd < periodicReservationEnd
+                  || periodicSearchStart < periodicReservationEnd
+                  || periodicSearchStart > periodicSearchEnd) {
-              + ") must be" + "an exact divider of the system maxPeriod ("
+              + ") must be" + " an exact divider of the system maxPeriod ("
+  @Override
+  public long getMaximumPeriodicity() {
+    return this.maxPeriodicity;
+  }
+

YARN-8881. [YARN-8851] Add basic pluggable device plugin framework. (Zhankun Tang via wangda)

Change-Id: If9a2f68cd4713b4ec932cdeda68106f17437c3d3

+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.util.ReflectionUtils;
+import org.apache.hadoop.yarn.api.records.ResourceInformation;
+import org.apache.hadoop.yarn.server.nodemanager.api.deviceplugin.DevicePlugin;
+import org.apache.hadoop.yarn.server.nodemanager.api.deviceplugin.DeviceRegisterRequest;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.resourceplugin.deviceframework.DevicePluginAdapter;
+import org.apache.hadoop.yarn.util.resource.ResourceUtils;
+import java.lang.reflect.Method;
+
-      throws YarnException {
+      throws YarnException, ClassNotFoundException {
-      throws YarnRuntimeException {
+      throws YarnRuntimeException, ClassNotFoundException {
+
+    for (String pluginClassName : pluginClassNames) {
+      Class<?> pluginClazz = Class.forName(pluginClassName);
+      if (!DevicePlugin.class.isAssignableFrom(pluginClazz)) {
+        throw new YarnRuntimeException("Class: " + pluginClassName
+            + " not instance of " + DevicePlugin.class.getCanonicalName());
+      }
+      // sanity-check before initialization
+      checkInterfaceCompatibility(DevicePlugin.class, pluginClazz);
+
+      DevicePlugin dpInstance =
+          (DevicePlugin) ReflectionUtils.newInstance(
+              pluginClazz, configuration);
+
+      // Try to register plugin
+      // TODO: handle the plugin method timeout issue
+      DeviceRegisterRequest request = null;
+      try {
+        request = dpInstance.getRegisterRequestInfo();
+      } catch (Exception e) {
+        throw new YarnRuntimeException("Exception thrown from plugin's"
+            + " getRegisterRequestInfo:"
+            + e.getMessage());
+      }
+      String resourceName = request.getResourceName();
+      // check if someone has already registered this resource type name
+      if (pluginMap.containsKey(resourceName)) {
+        throw new YarnRuntimeException(resourceName
+            + " already registered! Please change resource type name"
+            + " or configure correct resource type name"
+            + " in resource-types.xml for "
+            + pluginClassName);
+      }
+      // check resource name is valid and configured in resource-types.xml
+      if (!isConfiguredResourceName(resourceName)) {
+        throw new YarnRuntimeException(resourceName
+            + " is not configured inside "
+            + YarnConfiguration.RESOURCE_TYPES_CONFIGURATION_FILE
+            + " , please configure it first");
+      }
+      LOG.info("New resource type: {} registered successfully by {}",
+          resourceName,
+          pluginClassName);
+      DevicePluginAdapter pluginAdapter = new DevicePluginAdapter(
+          resourceName, dpInstance);
+      LOG.info("Adapter of {} created. Initializing..", pluginClassName);
+      try {
+        pluginAdapter.initialize(context);
+      } catch (YarnException e) {
+        throw new YarnRuntimeException("Adapter of "
+            + pluginClassName + " init failed!");
+      }
+      LOG.info("Adapter of {} init success!", pluginClassName);
+      // Store plugin as adapter instance
+      pluginMap.put(request.getResourceName(), pluginAdapter);
+    } // end for
+  }
+
+  @VisibleForTesting
+  // Check if the implemented interfaces' signature is compatible
+  public void checkInterfaceCompatibility(Class<?> expectedClass,
+      Class<?> actualClass) throws YarnRuntimeException{
+    LOG.debug("Checking implemented interface's compatibility: {}",
+        expectedClass.getSimpleName());
+    Method[] expectedDevicePluginMethods = expectedClass.getMethods();
+
+    // Check method compatibility
+    boolean found;
+    for (Method method: expectedDevicePluginMethods) {
+      found = false;
+      LOG.debug("Try to find method: {}",
+          method.getName());
+      for (Method m : actualClass.getDeclaredMethods()) {
+        if (m.getName().equals(method.getName())) {
+          LOG.debug("Method {} found in class {}",
+              actualClass.getSimpleName(),
+              m.getName());
+          found = true;
+          break;
+        }
+      }
+      if (!found) {
+        LOG.error("Method {} is not found in plugin",
+            method.getName());
+        throw new YarnRuntimeException(
+            "Method " + method.getName()
+                + " is expected but not implemented in "
+                + actualClass.getCanonicalName());
+      }
+    }// end for
+    LOG.info("{} compatibility is ok.",
+        expectedClass.getSimpleName());
+  }
+
+  @VisibleForTesting
+  public boolean isConfiguredResourceName(String resourceName) {
+    // check configured
+    Map<String, ResourceInformation> configuredResourceTypes =
+        ResourceUtils.getResourceTypes();
+    if (!configuredResourceTypes.containsKey(resourceName)) {
+      return false;
+    }
+    return true;

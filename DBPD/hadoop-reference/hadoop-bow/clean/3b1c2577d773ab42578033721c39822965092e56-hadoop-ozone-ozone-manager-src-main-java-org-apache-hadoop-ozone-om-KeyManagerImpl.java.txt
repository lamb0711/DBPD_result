HDDS-1541. Implement addAcl,removeAcl,setAcl,getAcl for Key. Contributed by Ajay Kumat. (#885)



+import java.util.Objects;
+import java.util.stream.Collectors;
+import org.apache.hadoop.ozone.OzoneAcl;
+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OzoneAclInfo;
+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OzoneAclInfo.OzoneAclRights;
+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;
+import org.apache.hadoop.ozone.security.acl.OzoneObj;
+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.BUCKET_NOT_FOUND;
+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;
+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.VOLUME_NOT_FOUND;
+import static org.apache.hadoop.ozone.security.acl.OzoneObj.ResourceType.KEY;
-            OMException.ResultCodes.VOLUME_NOT_FOUND);
+            VOLUME_NOT_FOUND);
-          OMException.ResultCodes.BUCKET_NOT_FOUND);
+          BUCKET_NOT_FOUND);
-          ResultCodes.BUCKET_NOT_FOUND);
+          BUCKET_NOT_FOUND);
-          OMException.ResultCodes.KEY_NOT_FOUND);
+          KEY_NOT_FOUND);
-          OMException.ResultCodes.KEY_NOT_FOUND);
+          KEY_NOT_FOUND);
+    Preconditions.checkNotNull(args.getAcls(), "Default acls " +
+        "should be set.");
+
-    return new OmKeyInfo.Builder()
+    OmKeyInfo.Builder builder = new OmKeyInfo.Builder()
-        .setFileEncryptionInfo(encInfo)
-        .build();
+        .setFileEncryptionInfo(encInfo);
+    if(keyArgs.getAcls() != null) {
+      builder.setAcls(keyArgs.getAcls().stream().map(a ->
+          OzoneAcl.toProtobuf(a)).collect(Collectors.toList()));
+    }
+    return builder.build();
-            objectKey, ResultCodes.KEY_NOT_FOUND);
+            objectKey, KEY_NOT_FOUND);
-            OMException.ResultCodes.KEY_NOT_FOUND);
+            KEY_NOT_FOUND);
-          OMException.ResultCodes.KEY_NOT_FOUND);
+          KEY_NOT_FOUND);
-            OMException.ResultCodes.KEY_NOT_FOUND);
+            KEY_NOT_FOUND);
-            OMException.ResultCodes.KEY_NOT_FOUND);
+            KEY_NOT_FOUND);
+          .setAcls(keyArgs.getAcls().stream().map(a ->
+              OzoneAcl.toProtobuf(a)).collect(Collectors.toList()))
-            .build();
+            .setAcls(omKeyArgs.getAcls().stream().map(a ->
+                OzoneAcl.toProtobuf(a)).collect(Collectors.toList())).build();
-        // key approach.
-        // When versioning support comes, then we can uncomment below code
-        // keyInfo.addNewVersion(locations);
+        // key approach. When versioning support comes, then we can uncomment
+        // below code keyInfo.addNewVersion(locations);
+   * Add acl for Ozone object. Return true if acl is added successfully else
+   * false.
+   *
+   * @param obj Ozone object for which acl should be added.
+   * @param acl ozone acl top be added.
+   * @throws IOException if there is error.
+   */
+  @Override
+  public boolean addAcl(OzoneObj obj, OzoneAcl acl) throws IOException {
+    validateOzoneObj(obj);
+    String volume = obj.getVolumeName();
+    String bucket = obj.getBucketName();
+    String keyName = obj.getKeyName();
+
+    metadataManager.getLock().acquireBucketLock(volume, bucket);
+    try {
+      validateBucket(volume, bucket);
+      String objectKey = metadataManager.getOzoneKey(volume, bucket, keyName);
+      OmKeyInfo keyInfo = metadataManager.getKeyTable().get(objectKey);
+      Table keyTable;
+      if (keyInfo == null) {
+        keyInfo = metadataManager.getOpenKeyTable().get(objectKey);
+        if (keyInfo == null) {
+          throw new OMException("Key not found. Key:" +
+              objectKey, KEY_NOT_FOUND);
+        }
+        keyTable = metadataManager.getOpenKeyTable();
+      } else {
+        keyTable = metadataManager.getKeyTable();
+      }
+      List<OzoneAclInfo> newAcls = new ArrayList<>(keyInfo.getAcls());
+      OzoneAclInfo newAcl = null;
+      for(OzoneAclInfo a: keyInfo.getAcls()) {
+        if(a.getName().equals(acl.getName())) {
+          List<OzoneAclRights> rights =
+              new ArrayList<>(a.getRightsList());
+          for (IAccessAuthorizer.ACLType aclType : acl.getAclList()) {
+            rights.add(OzoneAclRights.valueOf(aclType.name()));
+          }
+          newAcl = OzoneAclInfo.newBuilder()
+              .setType(a.getType())
+              .setName(a.getName())
+              .addAllRights(rights)
+              .build();
+          newAcls.remove(a);
+          newAcls.add(newAcl);
+          break;
+        }
+      }
+      if(newAcl == null) {
+        newAcls.add(OzoneAcl.toProtobuf(acl));
+      }
+
+      OmKeyInfo newObj = new OmKeyInfo.Builder()
+          .setBucketName(keyInfo.getBucketName())
+          .setKeyName(keyInfo.getKeyName())
+          .setReplicationFactor(keyInfo.getFactor())
+          .setReplicationType(keyInfo.getType())
+          .setVolumeName(keyInfo.getVolumeName())
+          .setOmKeyLocationInfos(keyInfo.getKeyLocationVersions())
+          .setCreationTime(keyInfo.getCreationTime())
+          .setModificationTime(keyInfo.getModificationTime())
+          .setAcls(newAcls)
+          .setDataSize(keyInfo.getDataSize())
+          .setFileEncryptionInfo(keyInfo.getFileEncryptionInfo())
+          .build();
+      keyTable.put(objectKey, newObj);
+    } catch (IOException ex) {
+      if (!(ex instanceof OMException)) {
+        LOG.error("Add acl operation failed for key:{}/{}/{}", volume,
+            bucket, keyName, ex);
+      }
+      throw ex;
+    } finally {
+      metadataManager.getLock().releaseBucketLock(volume, bucket);
+    }
+    return true;
+  }
+
+  /**
+   * Remove acl for Ozone object. Return true if acl is removed successfully
+   * else false.
+   *
+   * @param obj Ozone object.
+   * @param acl Ozone acl to be removed.
+   * @throws IOException if there is error.
+   */
+  @Override
+  public boolean removeAcl(OzoneObj obj, OzoneAcl acl) throws IOException {
+    validateOzoneObj(obj);
+    String volume = obj.getVolumeName();
+    String bucket = obj.getBucketName();
+    String keyName = obj.getKeyName();
+
+    metadataManager.getLock().acquireBucketLock(volume, bucket);
+    try {
+      validateBucket(volume, bucket);
+      String objectKey = metadataManager.getOzoneKey(volume, bucket, keyName);
+      OmKeyInfo keyInfo = metadataManager.getKeyTable().get(objectKey);
+      Table keyTable;
+      if (keyInfo == null) {
+        keyInfo = metadataManager.getOpenKeyTable().get(objectKey);
+        if (keyInfo == null) {
+          throw new OMException("Key not found. Key:" +
+              objectKey, KEY_NOT_FOUND);
+        }
+        keyTable = metadataManager.getOpenKeyTable();
+      } else {
+        keyTable = metadataManager.getKeyTable();
+      }
+
+      List<OzoneAclInfo> newAcls = new ArrayList<>(keyInfo.getAcls());
+      OzoneAclInfo newAcl = OzoneAcl.toProtobuf(acl);
+
+      if(newAcls.contains(OzoneAcl.toProtobuf(acl))) {
+        newAcls.remove(newAcl);
+      } else {
+        // Acl to be removed might be a subset of existing acls.
+        for(OzoneAclInfo a: keyInfo.getAcls()) {
+          if(a.getName().equals(acl.getName())) {
+            List<OzoneAclRights> rights =
+                new ArrayList<>(a.getRightsList());
+            for (IAccessAuthorizer.ACLType aclType : acl.getAclList()) {
+              rights.remove(OzoneAclRights.valueOf(aclType.name()));
+            }
+            newAcl = OzoneAclInfo.newBuilder()
+                .setType(a.getType())
+                .setName(a.getName())
+                .addAllRights(rights)
+                .build();
+            newAcls.remove(a);
+            newAcls.add(newAcl);
+            break;
+          }
+        }
+        if(newAcl == null) {
+          newAcls.add(OzoneAcl.toProtobuf(acl));
+        }
+      }
+
+      OmKeyInfo newObj = new OmKeyInfo.Builder()
+          .setBucketName(keyInfo.getBucketName())
+          .setKeyName(keyInfo.getKeyName())
+          .setReplicationFactor(keyInfo.getFactor())
+          .setReplicationType(keyInfo.getType())
+          .setVolumeName(keyInfo.getVolumeName())
+          .setOmKeyLocationInfos(keyInfo.getKeyLocationVersions())
+          .setCreationTime(keyInfo.getCreationTime())
+          .setModificationTime(keyInfo.getModificationTime())
+          .setAcls(newAcls)
+          .setDataSize(keyInfo.getDataSize())
+          .setFileEncryptionInfo(keyInfo.getFileEncryptionInfo())
+          .build();
+
+      keyTable.put(objectKey, newObj);
+    } catch (IOException ex) {
+      if (!(ex instanceof OMException)) {
+        LOG.error("Remove acl operation failed for key:{}/{}/{}", volume,
+            bucket, keyName, ex);
+      }
+      throw ex;
+    } finally {
+      metadataManager.getLock().releaseBucketLock(volume, bucket);
+    }
+    return true;
+  }
+
+  /**
+   * Acls to be set for given Ozone object. This operations reset ACL for given
+   * object to list of ACLs provided in argument.
+   *
+   * @param obj Ozone object.
+   * @param acls List of acls.
+   * @throws IOException if there is error.
+   */
+  @Override
+  public boolean setAcl(OzoneObj obj, List<OzoneAcl> acls) throws IOException {
+    validateOzoneObj(obj);
+    String volume = obj.getVolumeName();
+    String bucket = obj.getBucketName();
+    String keyName = obj.getKeyName();
+
+    metadataManager.getLock().acquireBucketLock(volume, bucket);
+    try {
+      validateBucket(volume, bucket);
+      String objectKey = metadataManager.getOzoneKey(volume, bucket, keyName);
+      OmKeyInfo keyInfo = metadataManager.getKeyTable().get(objectKey);
+      Table keyTable;
+      if (keyInfo == null) {
+        keyInfo = metadataManager.getOpenKeyTable().get(objectKey);
+        if (keyInfo == null) {
+          throw new OMException("Key not found. Key:" +
+              objectKey, KEY_NOT_FOUND);
+        }
+        keyTable = metadataManager.getOpenKeyTable();
+      } else {
+        keyTable = metadataManager.getKeyTable();
+      }
+
+      List<OzoneAclInfo> newAcls = new ArrayList<>();
+      for (OzoneAcl a : acls) {
+        newAcls.add(OzoneAcl.toProtobuf(a));
+      }
+      OmKeyInfo newObj = new OmKeyInfo.Builder()
+          .setBucketName(keyInfo.getBucketName())
+          .setKeyName(keyInfo.getKeyName())
+          .setReplicationFactor(keyInfo.getFactor())
+          .setReplicationType(keyInfo.getType())
+          .setVolumeName(keyInfo.getVolumeName())
+          .setOmKeyLocationInfos(keyInfo.getKeyLocationVersions())
+          .setCreationTime(keyInfo.getCreationTime())
+          .setModificationTime(keyInfo.getModificationTime())
+          .setAcls(newAcls)
+          .setDataSize(keyInfo.getDataSize())
+          .setFileEncryptionInfo(keyInfo.getFileEncryptionInfo())
+          .build();
+
+      keyTable.put(objectKey, newObj);
+    } catch (IOException ex) {
+      if (!(ex instanceof OMException)) {
+        LOG.error("Set acl operation failed for key:{}/{}/{}", volume,
+            bucket, keyName, ex);
+      }
+      throw ex;
+    } finally {
+      metadataManager.getLock().releaseBucketLock(volume, bucket);
+    }
+    return true;
+  }
+
+  /**
+   * Returns list of ACLs for given Ozone object.
+   *
+   * @param obj Ozone object.
+   * @throws IOException if there is error.
+   */
+  @Override
+  public List<OzoneAcl> getAcl(OzoneObj obj) throws IOException {
+    validateOzoneObj(obj);
+    String volume = obj.getVolumeName();
+    String bucket = obj.getBucketName();
+    String keyName = obj.getKeyName();
+
+    metadataManager.getLock().acquireBucketLock(volume, bucket);
+    try {
+      validateBucket(volume, bucket);
+      String objectKey = metadataManager.getOzoneKey(volume, bucket, keyName);
+      OmKeyInfo keyInfo = metadataManager.getKeyTable().get(objectKey);
+      if (keyInfo == null) {
+        keyInfo = metadataManager.getOpenKeyTable().get(objectKey);
+        if (keyInfo == null) {
+          throw new OMException("Key not found. Key:" +
+              objectKey, KEY_NOT_FOUND);
+        }
+      }
+
+      List<OzoneAcl> acls = new ArrayList<>();
+      for (OzoneAclInfo a : keyInfo.getAcls()) {
+        acls.add(OzoneAcl.fromProtobuf(a));
+      }
+      return acls;
+    } catch (IOException ex) {
+      if (!(ex instanceof OMException)) {
+        LOG.error("Get acl operation failed for key:{}/{}/{}", volume,
+            bucket, keyName, ex);
+      }
+      throw ex;
+    } finally {
+      metadataManager.getLock().releaseBucketLock(volume, bucket);
+    }
+  }
+
+  /**
+   * Helper method to validate ozone object.
+   * @param obj
+   * */
+  private void validateOzoneObj(OzoneObj obj) throws OMException {
+    Objects.requireNonNull(obj);
+
+    if (!obj.getResourceType().equals(KEY)) {
+      throw new IllegalArgumentException("Unexpected argument passed to " +
+          "KeyManager. OzoneObj type:" + obj.getResourceType());
+    }
+    String volume = obj.getVolumeName();
+    String bucket = obj.getBucketName();
+    String keyName = obj.getKeyName();
+
+    if (Strings.isNullOrEmpty(volume)) {
+      throw new OMException("Volume name is required.", VOLUME_NOT_FOUND);
+    }
+    if (Strings.isNullOrEmpty(bucket)) {
+      throw new OMException("Bucket name is required.", BUCKET_NOT_FOUND);
+    }
+    if (Strings.isNullOrEmpty(keyName)) {
+      throw new OMException("Key name is required.", KEY_NOT_FOUND);
+    }
+  }
+
+  /**
-          createDirectoryKey(volumeName, bucketName, keyName);
+          createDirectoryKey(volumeName, bucketName, keyName, args.getAcls());
-      String keyName) throws IOException {
+      String keyName, List<OzoneAcl> acls) throws IOException {
+        .setAcls(acls.stream().map(a ->
+            OzoneAcl.toProtobuf(a)).collect(Collectors.toList()))

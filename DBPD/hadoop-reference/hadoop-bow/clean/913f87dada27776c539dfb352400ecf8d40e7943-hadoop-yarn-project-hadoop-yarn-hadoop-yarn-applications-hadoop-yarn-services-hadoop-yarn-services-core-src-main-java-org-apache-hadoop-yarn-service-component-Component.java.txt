YARN-8665.  Added Yarn service cancel upgrade option.
            Contributed by Chandni Singh

-import org.apache.hadoop.yarn.api.records.ContainerId;
-import org.apache.hadoop.yarn.service.component.instance.ComponentInstanceEventType;
+import static org.apache.hadoop.yarn.service.component.ComponentEventType.CANCEL_UPGRADE;
+import static org.apache.hadoop.yarn.service.component.ComponentEventType.UPGRADE;
-  private AtomicBoolean upgradeInProgress = new AtomicBoolean(false);
-  private ComponentEvent upgradeEvent;
-  private AtomicLong numContainersThatNeedUpgrade = new AtomicLong(0);
+  private UpgradeStatus upgradeStatus = new UpgradeStatus();
+  private UpgradeStatus cancelUpgradeStatus = new UpgradeStatus();
+          .addTransition(FLEXING, EnumSet.of(UPGRADING, FLEXING, STABLE),
+              CHECK_STABLE, new CheckStableTransition())
-          .addTransition(STABLE, UPGRADING, ComponentEventType.UPGRADE,
-              new ComponentNeedsUpgradeTransition())
-          //Upgrade while previous upgrade is still in progress
-          .addTransition(UPGRADING, UPGRADING, ComponentEventType.UPGRADE,
-              new ComponentNeedsUpgradeTransition())
-          .addTransition(UPGRADING, EnumSet.of(UPGRADING, FLEXING, STABLE),
-              CHECK_STABLE, new CheckStableTransition())
-          .addTransition(FLEXING, EnumSet.of(UPGRADING, FLEXING, STABLE),
-              CHECK_STABLE, new CheckStableTransition())
+          .addTransition(STABLE, UPGRADING, UPGRADE,
+              new NeedsUpgradeTransition())
+          .addTransition(STABLE, CANCEL_UPGRADING, CANCEL_UPGRADE,
+              new NeedsUpgradeTransition())
-          .addTransition(UPGRADING, FLEXING, CONTAINER_COMPLETED,
-              new ContainerCompletedTransition())
+
+          // Cancel upgrade while previous upgrade is still in progress
+          .addTransition(UPGRADING, CANCEL_UPGRADING,
+              CANCEL_UPGRADE, new NeedsUpgradeTransition())
+          .addTransition(UPGRADING, EnumSet.of(UPGRADING, STABLE),
+              CHECK_STABLE, new CheckStableTransition())
+          .addTransition(UPGRADING, UPGRADING, CONTAINER_COMPLETED,
+              new CompletedAfterUpgradeTransition())
+
+          .addTransition(CANCEL_UPGRADING, EnumSet.of(CANCEL_UPGRADING, FLEXING,
+              STABLE), CHECK_STABLE, new CheckStableTransition())
+          .addTransition(CANCEL_UPGRADING, CANCEL_UPGRADING,
+              CONTAINER_COMPLETED, new CompletedAfterUpgradeTransition())
+          .addTransition(CANCEL_UPGRADING, FLEXING, CONTAINER_ALLOCATED,
+              new ContainerAllocatedTransition())
+
-        component.componentSpec.setState(
+        component.setComponentState(
-      component.componentSpec.setState(
+      component.setComponentState(
-      component.componentSpec.setState(
+      component.setComponentState(
-        .getComponentSpec().getNumberOfContainers()
-        && component.numContainersThatNeedUpgrade.get() == 0) {
-      component.componentSpec.setState(
+        .getComponentSpec().getNumberOfContainers() &&
+        !component.doesNeedUpgrade()) {
+      component.setComponentState(
+    } else if (component.doesNeedUpgrade()) {
+      component.setComponentState(org.apache.hadoop.yarn.service.api.records.
+          ComponentState.NEEDS_UPGRADE);
+      return component.getState();
-      component.componentSpec.setState(
+      component.setComponentState(
-    } else {
-      //  component.numContainersThatNeedUpgrade.get() > 0
-      component.componentSpec.setState(org.apache.hadoop.yarn.service.api.
-          records.ComponentState.NEEDS_UPGRADE);
-      return UPGRADING;
+    return component.getState();
-    org.apache.hadoop.yarn.service.api.records.ComponentState curState =
-        component.componentSpec.getState();
-        if (component.numContainersThatNeedUpgrade.get() == 0
-            && component.componentMetrics.containersReady.value()
-            == component.componentMetrics.containersDesired.value()) {
-          component.componentSpec.setState(
+        if (!component.upgradeStatus.areContainersUpgrading() &&
+            !component.cancelUpgradeStatus.areContainersUpgrading() &&
+            component.componentMetrics.containersReady.value() ==
+                component.componentMetrics.containersDesired.value()) {
+          component.setComponentState(
-          if (curState != component.componentSpec.getState()) {
-            LOG.info("[COMPONENT {}] state changed from {} -> {}",
-                component.componentSpec.getName(), curState,
-                component.componentSpec.getState());
-          }
-          component.componentSpec.setState(
+          component.setComponentState(
-          component.componentSpec.setState(
+          component.setComponentState(
-        if (curState != component.componentSpec.getState()) {
-          LOG.info("[COMPONENT {}] state changed from {} -> {}",
-              component.componentSpec.getName(), curState,
-              component.componentSpec.getState());
-        }
-    // when the service is stable then the state of component needs to
-    // transition to stable
+    // triggers the state machine in component to reach appropriate state
+    // once the state in spec is changed.
-  private static class ComponentNeedsUpgradeTransition extends BaseTransition {
+  private static class CompletedAfterUpgradeTransition extends BaseTransition {
-      component.upgradeInProgress.set(true);
-      component.upgradeEvent = event;
-      component.componentSpec.setState(org.apache.hadoop.yarn.service.api.
-          records.ComponentState.NEEDS_UPGRADE);
-      component.numContainersThatNeedUpgrade.set(
+      Preconditions.checkNotNull(event.getContainerId());
+      component.updateMetrics(event.getStatus());
+      component.dispatcher.getEventHandler().handle(
+          new ComponentInstanceEvent(event.getContainerId(), STOP)
+              .setStatus(event.getStatus()));
+    }
+  }
+
+  private static class NeedsUpgradeTransition extends BaseTransition {
+    @Override
+    public void transition(Component component, ComponentEvent event) {
+      boolean isCancel = event.getType().equals(CANCEL_UPGRADE);
+      UpgradeStatus status = !isCancel ? component.upgradeStatus :
+          component.cancelUpgradeStatus;
+
+      status.inProgress.set(true);
+      status.targetSpec = event.getTargetSpec();
+      status.targetVersion = event.getUpgradeVersion();
+      LOG.info("[COMPONENT {}]: need upgrade to {}",
+          component.getName(), status.targetVersion);
+
+      status.containersNeedUpgrade.set(
-      component.componentSpec.getContainers().forEach(container -> {
-        container.setState(ContainerState.NEEDS_UPGRADE);
-        if (event.isExpressUpgrade()) {
-          ComponentInstanceEvent upgradeEvent = new ComponentInstanceEvent(
-              ContainerId.fromString(container.getId()),
-                  ComponentInstanceEventType.UPGRADE);
-          LOG.info("Upgrade container {}", container.getId());
-          component.dispatcher.getEventHandler().handle(upgradeEvent);
-        }
+
+      component.setComponentState(org.apache.hadoop.yarn.service.api.
+          records.ComponentState.NEEDS_UPGRADE);
+
+      component.getAllComponentInstances().forEach(instance -> {
+        instance.setContainerState(ContainerState.NEEDS_UPGRADE);
+
+      if (event.getType().equals(CANCEL_UPGRADE)) {
+        component.upgradeStatus.reset();
+      }
-      org.apache.hadoop.yarn.service.api.records.ComponentState currState =
-          component.componentSpec.getState();
-      if (currState.equals(org.apache.hadoop.yarn.service.api.records
-          .ComponentState.STABLE)) {
-        return ComponentState.STABLE;
-      }
-      if (targetState.equals(STABLE) && component.upgradeInProgress.get()) {
-        component.componentSpec.overwrite(
-            component.upgradeEvent.getTargetSpec());
-        component.upgradeEvent = null;
+
+      if (targetState.equals(STABLE) &&
+          !(component.upgradeStatus.isCompleted() &&
+              component.cancelUpgradeStatus.isCompleted())) {
+        // Component stable after upgrade or cancel upgrade
+        UpgradeStatus status = !component.cancelUpgradeStatus.isCompleted() ?
+            component.cancelUpgradeStatus : component.upgradeStatus;
+
+        component.componentSpec.overwrite(status.getTargetSpec());
+        status.reset();
+
-        component.upgradeInProgress.set(false);
-    if (upgradeInProgress.get()) {
+    if (!(upgradeStatus.isCompleted() && cancelUpgradeStatus.isCompleted())) {
+      UpgradeStatus status = !cancelUpgradeStatus.isCompleted() ?
+          cancelUpgradeStatus : upgradeStatus;
+
-              createLaunchContext(upgradeEvent.getTargetSpec(),
-                  upgradeEvent.getUpgradeVersion()));
+              createLaunchContext(status.getTargetSpec(),
+                  status.getTargetVersion()));
+  private boolean doesNeedUpgrade() {
+    return cancelUpgradeStatus.areContainersUpgrading() ||
+        upgradeStatus.areContainersUpgrading() ||
+        upgradeStatus.failed.get();
+  }
+
-  public void decContainersThatNeedUpgrade() {
-    numContainersThatNeedUpgrade.decrementAndGet();
-  }
-
-  public ComponentEvent getUpgradeEvent() {
+  /**
+   * Returns whether a component is upgrading or not.
+   */
+  public boolean isUpgrading() {
+    this.readLock.lock();
+
+    try {
+      return !(upgradeStatus.isCompleted() &&
+          cancelUpgradeStatus.isCompleted());
+    } finally {
+      this.readLock.unlock();
+    }
+  }
+
+  public UpgradeStatus getUpgradeStatus() {
-      return upgradeEvent;
+      return upgradeStatus;
+    } finally {
+      this.readLock.unlock();
+    }
+  }
+
+  public UpgradeStatus getCancelUpgradeStatus() {
+    this.readLock.lock();
+    try {
+      return cancelUpgradeStatus;
+  /**
+   * Sets the state of the component in the component spec.
+   * @param state component state
+   */
+  private void setComponentState(
+      org.apache.hadoop.yarn.service.api.records.ComponentState state) {
+    org.apache.hadoop.yarn.service.api.records.ComponentState curState =
+        componentSpec.getState();
+    if (!curState.equals(state)) {
+      componentSpec.setState(state);
+      LOG.info("[COMPONENT {}] spec state changed from {} -> {}",
+          componentSpec.getName(), curState, state);
+    }
+  }
+
+  /**
+   * Status of upgrade.
+   */
+  public static class UpgradeStatus {
+    private org.apache.hadoop.yarn.service.api.records.Component targetSpec;
+    private String targetVersion;
+    private AtomicBoolean inProgress = new AtomicBoolean(false);
+    private AtomicLong containersNeedUpgrade = new AtomicLong(0);
+    private AtomicBoolean failed = new AtomicBoolean(false);
+
+    public org.apache.hadoop.yarn.service.api.records.
+        Component getTargetSpec() {
+      return targetSpec;
+    }
+
+    public String getTargetVersion() {
+      return targetVersion;
+    }
+
+    /*
+     * @return whether the upgrade is completed or not
+     */
+    public boolean isCompleted() {
+      return !inProgress.get();
+    }
+
+    public void decContainersThatNeedUpgrade() {
+      if (inProgress.get()) {
+        containersNeedUpgrade.decrementAndGet();
+      }
+    }
+
+    public void containerFailedUpgrade() {
+      failed.set(true);
+    }
+
+    void reset() {
+      containersNeedUpgrade.set(0);
+      targetSpec = null;
+      targetVersion = null;
+      inProgress.set(false);
+      failed.set(false);
+    }
+
+    boolean areContainersUpgrading() {
+      return containersNeedUpgrade.get() != 0;
+    }
+  }
+

YARN-638. Modified ResourceManager to restore RMDelegationTokens after restarting. Contributed by Jian He.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487720 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.IOException;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.classification.InterfaceAudience.Private;
+import org.apache.hadoop.security.token.delegation.DelegationKey;
+import org.apache.hadoop.util.ExitUtil;
+import org.apache.hadoop.yarn.server.resourcemanager.RMContext;
+import org.apache.hadoop.yarn.server.resourcemanager.recovery.RMStateStore.RMState;
+import org.apache.hadoop.yarn.server.resourcemanager.recovery.Recoverable;
+
+import com.google.common.annotations.VisibleForTesting;
-public class RMDelegationTokenSecretManager
-    extends AbstractDelegationTokenSecretManager<RMDelegationTokenIdentifier> {
+public class RMDelegationTokenSecretManager extends
+    AbstractDelegationTokenSecretManager<RMDelegationTokenIdentifier> implements
+    Recoverable {
+  private static final Log LOG = LogFactory
+      .getLog(RMDelegationTokenSecretManager.class);
+
+  protected final RMContext rmContext;
-                                      long delegationTokenRemoverScanInterval) {
+                                      long delegationTokenRemoverScanInterval,
+                                      RMContext rmContext) {
+    this.rmContext = rmContext;
+
+  @Override
+  protected void storeNewMasterKey(DelegationKey newKey) {
+    try {
+      LOG.info("storing master key with keyID " + newKey.getKeyId());
+      rmContext.getStateStore().storeRMDTMasterKey(newKey);
+    } catch (Exception e) {
+      LOG.error("Error in storing master key with KeyID: " + newKey.getKeyId());
+      ExitUtil.terminate(1, e);
+    }
+  }
+
+  @Override
+  protected void removeStoredMasterKey(DelegationKey key) {
+    try {
+      LOG.info("removing master key with keyID " + key.getKeyId());
+      rmContext.getStateStore().removeRMDTMasterKey(key);
+    } catch (Exception e) {
+      LOG.error("Error in removing master key with KeyID: " + key.getKeyId());
+      ExitUtil.terminate(1, e);
+    }
+  }
+
+  @Override
+  protected void storeNewToken(RMDelegationTokenIdentifier identifier,
+      long renewDate) {
+    try {
+      LOG.info("storing RMDelegation token with sequence number: "
+          + identifier.getSequenceNumber());
+      rmContext.getStateStore().storeRMDelegationTokenAndSequenceNumber(
+        identifier, renewDate, identifier.getSequenceNumber());
+    } catch (Exception e) {
+      LOG.error("Error in storing RMDelegationToken with sequence number: "
+          + identifier.getSequenceNumber());
+      ExitUtil.terminate(1, e);
+    }
+  }
+
+  @Override
+  protected void updateStoredToken(RMDelegationTokenIdentifier id,
+      long renewDate) {
+    try {
+      LOG.info("updating RMDelegation token with sequence number: "
+          + id.getSequenceNumber());
+      rmContext.getStateStore().removeRMDelegationToken(id,
+        delegationTokenSequenceNumber);
+      rmContext.getStateStore().storeRMDelegationTokenAndSequenceNumber(id,
+        renewDate, id.getSequenceNumber());
+    } catch (Exception e) {
+      LOG.error("Error in updating persisted RMDelegationToken with sequence number: "
+            + id.getSequenceNumber());
+      ExitUtil.terminate(1, e);
+    }
+  }
+
+  @Override
+  protected void removeStoredToken(RMDelegationTokenIdentifier ident)
+      throws IOException {
+    try {
+      LOG.info("removing RMDelegation token with sequence number: "
+          + ident.getSequenceNumber());
+      rmContext.getStateStore().removeRMDelegationToken(ident,
+        delegationTokenSequenceNumber);
+    } catch (Exception e) {
+      LOG.error("Error in removing RMDelegationToken with sequence number: "
+          + ident.getSequenceNumber());
+      ExitUtil.terminate(1, e);
+    }
+  }
+
+  @Private
+  @VisibleForTesting
+  public synchronized Set<DelegationKey> getAllMasterKeys() {
+    HashSet<DelegationKey> keySet = new HashSet<DelegationKey>();
+    keySet.addAll(allKeys.values());
+    return keySet;
+  }
+
+  @Private
+  @VisibleForTesting
+  public synchronized Map<RMDelegationTokenIdentifier, Long> getAllTokens() {
+    Map<RMDelegationTokenIdentifier, Long> allTokens =
+        new HashMap<RMDelegationTokenIdentifier, Long>();
+
+    for (Map.Entry<RMDelegationTokenIdentifier,
+        DelegationTokenInformation> entry : currentTokens.entrySet()) {
+      allTokens.put(entry.getKey(), entry.getValue().getRenewDate());
+    }
+    return allTokens;
+  }
+
+  @Private
+  @VisibleForTesting
+  public int getLatestDTSequenceNumber() {
+    return delegationTokenSequenceNumber;
+  }
+
+  @Override
+  public void recover(RMState rmState) throws Exception {
+
+    LOG.info("recovering RMDelegationTokenSecretManager.");
+    // recover RMDTMasterKeys
+    for (DelegationKey dtKey : rmState.getRMDTSecretManagerState()
+      .getMasterKeyState()) {
+      addKey(dtKey);
+    }
+
+    // recover RMDelegationTokens
+    Map<RMDelegationTokenIdentifier, Long> rmDelegationTokens =
+        rmState.getRMDTSecretManagerState().getTokenState();
+    this.delegationTokenSequenceNumber =
+        rmState.getRMDTSecretManagerState().getDTSequenceNumber();
+    for (Map.Entry<RMDelegationTokenIdentifier, Long> entry : rmDelegationTokens
+      .entrySet()) {
+      addPersistedDelegationToken(entry.getKey(), entry.getValue());
+    }
+  }

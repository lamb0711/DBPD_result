YARN-7417. Remove duplicated code from IndexedFileAggregatedLogsBlock
           and TFileAggregatedLogsBlock.
           Contributed by Zian Chen

-import static org.apache.hadoop.yarn.webapp.YarnWebParams.APP_OWNER;
-import static org.apache.hadoop.yarn.webapp.YarnWebParams.CONTAINER_ID;
-import static org.apache.hadoop.yarn.webapp.YarnWebParams.ENTITY_STRING;
-import static org.apache.hadoop.yarn.webapp.YarnWebParams.NM_NODENAME;
-import org.apache.hadoop.yarn.webapp.hamlet2.Hamlet.PRE;
-        Algorithm compressName = Compression.getCompressionAlgorithmByName(
-            compressAlgo);
-        Decompressor decompressor = compressName.getDecompressor();
-        FileContext fileContext = FileContext.getFileContext(
-            thisNodeFile.getPath().toUri(), conf);
-        FSDataInputStream fsin = fileContext.open(thisNodeFile.getPath());
-        int bufferSize = 65536;
-        for (IndexedFileLogMeta candidate : candidates) {
-          if (candidate.getLastModifiedTime() < startTime
-              || candidate.getLastModifiedTime() > endTime) {
-            continue;
-          }
-          byte[] cbuf = new byte[bufferSize];
-          InputStream in = null;
-          try {
-            in = compressName.createDecompressionStream(
-                new BoundedRangeFileInputStream(fsin,
-                    candidate.getStartIndex(),
-                    candidate.getFileCompressedSize()),
-                    decompressor,
-                    LogAggregationIndexedFileController.getFSInputBufferSize(
-                        conf));
-            long logLength = candidate.getFileSize();
-            html.pre().__("\n\n").__();
-            html.p().__("Log Type: " + candidate.getFileName()).__();
-            html.p().__("Log Upload Time: " + Times.format(
-                candidate.getLastModifiedTime())).__();
-            html.p().__("Log Length: " + Long.toString(
-                logLength)).__();
-            long startIndex = start < 0
-                ? logLength + start : start;
-            startIndex = startIndex < 0 ? 0 : startIndex;
-            startIndex = startIndex > logLength ? logLength : startIndex;
-            long endLogIndex = end < 0
-                ? logLength + end : end;
-            endLogIndex = endLogIndex < 0 ? 0 : endLogIndex;
-            endLogIndex = endLogIndex > logLength ? logLength : endLogIndex;
-            endLogIndex = endLogIndex < startIndex ?
-                startIndex : endLogIndex;
-            long toRead = endLogIndex - startIndex;
-            if (toRead < logLength) {
-              html.p().__("Showing " + toRead + " bytes of " + logLength
-                  + " total. Click ").a(url("logs", $(NM_NODENAME),
-                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),
-                      candidate.getFileName(), "?start=0&start.time="
-                      + startTime + "&end.time=" + endTime), "here").
-                      __(" for the full log.").__();
-            }
-            long totalSkipped = 0;
-            while (totalSkipped < startIndex) {
-              long ret = in.skip(startIndex - totalSkipped);
-              if (ret == 0) {
-                //Read one byte
-                int nextByte = in.read();
-                // Check if we have reached EOF
-                if (nextByte == -1) {
-                  throw new IOException("Premature EOF from container log");
-                }
-                ret = 1;
-              }
-              totalSkipped += ret;
-            }
-            int len = 0;
-            int currentToRead = toRead > bufferSize ? bufferSize : (int) toRead;
-            PRE<Hamlet> pre = html.pre();
-
-            while (toRead > 0
-                && (len = in.read(cbuf, 0, currentToRead)) > 0) {
-              pre.__(new String(cbuf, 0, len, Charset.forName("UTF-8")));
-              toRead = toRead - len;
-              currentToRead = toRead > bufferSize ? bufferSize : (int) toRead;
-            }
-
-            pre.__();
-            foundLog = true;
-          } catch (Exception ex) {
-            LOG.error("Error getting logs for " + logEntity, ex);
-            continue;
-          } finally {
-            IOUtils.closeQuietly(in);
-          }
-        }
+        foundLog = readContainerLog(compressAlgo, html, thisNodeFile, start,
+            end, candidates, startTime, endTime, foundLog, logEntity);
+
+  private boolean readContainerLog(String compressAlgo, Block html,
+      FileStatus thisNodeFile, long start, long end,
+      List<IndexedFileLogMeta> candidates, long startTime, long endTime,
+      boolean foundLog, String logEntity) throws IOException {
+    Algorithm compressName = Compression.getCompressionAlgorithmByName(
+        compressAlgo);
+    Decompressor decompressor = compressName.getDecompressor();
+    FileContext fileContext = FileContext.getFileContext(
+        thisNodeFile.getPath().toUri(), conf);
+    FSDataInputStream fsin = fileContext.open(thisNodeFile.getPath());
+    int bufferSize = 65536;
+    for (IndexedFileLogMeta candidate : candidates) {
+      if (candidate.getLastModifiedTime() < startTime
+          || candidate.getLastModifiedTime() > endTime) {
+        continue;
+      }
+      byte[] cbuf = new byte[bufferSize];
+      InputStream in = null;
+      try {
+        in = compressName.createDecompressionStream(
+            new BoundedRangeFileInputStream(fsin, candidate.getStartIndex(),
+                candidate.getFileCompressedSize()), decompressor,
+            LogAggregationIndexedFileController.getFSInputBufferSize(conf));
+        long logLength = candidate.getFileSize();
+        html.pre().__("\n\n").__();
+        html.p().__("Log Type: " + candidate.getFileName()).__();
+        html.p().__(
+            "Log Upload Time: " + Times.format(candidate.getLastModifiedTime()))
+            .__();
+        html.p().__("Log Length: " + Long.toString(logLength)).__();
+
+        long[] range = checkParseRange(html, start, end, startTime, endTime,
+            logLength, candidate.getFileName());
+        processContainerLog(html, range, in, bufferSize, cbuf);
+
+        foundLog = true;
+      } catch (Exception ex) {
+        LOG.error("Error getting logs for " + logEntity, ex);
+        continue;
+      } finally {
+        IOUtils.closeQuietly(in);
+      }
+    }
+    return foundLog;
+  }
+

Merging r1536573 through r1536889 from trunk to branch HDFS-2832

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1536890 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.protobuf.BlockingService;
+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;
+import org.apache.hadoop.ha.ServiceFailedException;
+import org.apache.hadoop.ha.proto.HAServiceProtocolProtos;
+import org.apache.hadoop.ha.protocolPB.HAServiceProtocolPB;
+import org.apache.hadoop.ha.protocolPB.HAServiceProtocolServerSideTranslatorPB;
+import org.apache.hadoop.ipc.ProtobufRpcEngine;
+import org.apache.hadoop.ipc.RPC;
+import org.apache.hadoop.ipc.Server;
+import org.apache.hadoop.ipc.WritableRpcEngine;
+import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.security.authorize.AccessControlList;
-import org.apache.hadoop.yarn.exceptions.YarnRuntimeException;
+import org.apache.hadoop.yarn.conf.YarnConfiguration;
+import org.apache.hadoop.yarn.server.resourcemanager.security.authorize.RMPolicyProvider;
+import java.net.InetSocketAddress;
+/**
+ * Internal class to handle HA related aspects of the {@link ResourceManager}.
+ *
+ * TODO (YARN-1318): Some/ all of this functionality should be merged with
+ * {@link AdminService}. Currently, marking this as Private and Unstable for
+ * those reasons.
+ */
+  private AccessControlList adminAcl;
+  private Server haAdminServer;
+      adminAcl = new AccessControlList(conf.get(
+          YarnConfiguration.YARN_ADMIN_ACL,
+          YarnConfiguration.DEFAULT_YARN_ADMIN_ACL));
+      startHAAdminServer();
+    if (haEnabled) {
+      stopHAAdminServer();
+    }
+
+  protected void startHAAdminServer() throws Exception {
+    InetSocketAddress haAdminServiceAddress = conf.getSocketAddr(
+        YarnConfiguration.RM_HA_ADMIN_ADDRESS,
+        YarnConfiguration.DEFAULT_RM_HA_ADMIN_ADDRESS,
+        YarnConfiguration.DEFAULT_RM_HA_ADMIN_PORT);
+
+    RPC.setProtocolEngine(conf, HAServiceProtocolPB.class,
+        ProtobufRpcEngine.class);
+
+    HAServiceProtocolServerSideTranslatorPB haServiceProtocolXlator =
+        new HAServiceProtocolServerSideTranslatorPB(this);
+    BlockingService haPbService =
+        HAServiceProtocolProtos.HAServiceProtocolService
+            .newReflectiveBlockingService(haServiceProtocolXlator);
+
+    WritableRpcEngine.ensureInitialized();
+
+    String bindHost = haAdminServiceAddress.getHostName();
+
+    int serviceHandlerCount = conf.getInt(
+        YarnConfiguration.RM_HA_ADMIN_CLIENT_THREAD_COUNT,
+        YarnConfiguration.DEFAULT_RM_HA_ADMIN_CLIENT_THREAD_COUNT);
+
+    haAdminServer = new RPC.Builder(conf)
+        .setProtocol(HAServiceProtocolPB.class)
+        .setInstance(haPbService)
+        .setBindAddress(bindHost)
+        .setPort(haAdminServiceAddress.getPort())
+        .setNumHandlers(serviceHandlerCount)
+        .setVerbose(false)
+        .build();
+
+    // Enable service authorization?
+    if (conf.getBoolean(
+        CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION, false)) {
+      haAdminServer.refreshServiceAcl(conf, new RMPolicyProvider());
+    }
+
+    haAdminServer.start();
+    conf.updateConnectAddr(YarnConfiguration.RM_HA_ADMIN_ADDRESS,
+        haAdminServer.getListenerAddress());
+  }
+
+  private void stopHAAdminServer() throws Exception {
+    if (haAdminServer != null) {
+      haAdminServer.stop();
+      haAdminServer.join();
+      haAdminServer = null;
+    }
+  }
+
-  public synchronized void monitorHealth() throws HealthCheckFailedException {
+  public synchronized void monitorHealth()
+      throws IOException {
+    checkAccess("monitorHealth");
-  public synchronized void transitionToActive(StateChangeRequestInfo reqInfo) {
+  public synchronized void transitionToActive(StateChangeRequestInfo reqInfo)
+      throws IOException {
+    UserGroupInformation user = checkAccess("transitionToActive");
+      RMAuditLogger.logSuccess(user.getShortUserName(),
+          "transitionToActive", "RMHAProtocolService");
-      LOG.error("Error when transitioning to Active mode", e);
-      throw new YarnRuntimeException(e);
+      RMAuditLogger.logFailure(user.getShortUserName(), "transitionToActive",
+          adminAcl.toString(), "RMHAProtocolService",
+          "Exception transitioning to active");
+      throw new ServiceFailedException(
+          "Error when transitioning to Active mode", e);
-  public synchronized void transitionToStandby(StateChangeRequestInfo reqInfo) {
+  public synchronized void transitionToStandby(StateChangeRequestInfo reqInfo)
+      throws IOException {
+    UserGroupInformation user = checkAccess("transitionToStandby");
+      RMAuditLogger.logSuccess(user.getShortUserName(),
+          "transitionToStandby", "RMHAProtocolService");
-      LOG.error("Error when transitioning to Standby mode", e);
-      throw new YarnRuntimeException(e);
+      RMAuditLogger.logFailure(user.getShortUserName(), "transitionToStandby",
+          adminAcl.toString(), "RMHAProtocolService",
+          "Exception transitioning to standby");
+      throw new ServiceFailedException(
+          "Error when transitioning to Standby mode", e);
+    checkAccess("getServiceState");
+
+  private UserGroupInformation checkAccess(String method) throws IOException {
+    return RMServerUtils.verifyAccess(adminAcl, method, LOG);
+  }

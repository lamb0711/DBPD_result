HDDS-801. Quasi close the container when close is not executed via Ratis.
Contributed by Nanda kumar.

-import com.google.common.base.Preconditions;
+import com.google.common.collect.Maps;
-import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos;
-import org.apache.hadoop.hdds.protocol.proto.HddsProtos.PipelineID;
-import org.apache.hadoop.hdds.protocol.proto.HddsProtos.ReplicationType;
-import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos;
+import org.apache.hadoop.hdds.protocol.datanode.proto
+    .ContainerProtos.ContainerType;
+import org.apache.hadoop.hdds.protocol.proto
+    .StorageContainerDatanodeProtocolProtos;
+import org.apache.hadoop.ozone.container.common.helpers.ContainerMetrics;
+import org.apache.hadoop.ozone.container.common.interfaces.Handler;
-import java.util.HashMap;
-import static org.apache.hadoop.ozone.OzoneConsts.INVALID_PORT;
-
-  public static final Logger LOG = LoggerFactory.getLogger(
+  private static final Logger LOG = LoggerFactory.getLogger(
-  private final DatanodeDetails dnDetails;
+  private final Map<ContainerType, Handler> handlers;
-  private final Map<ReplicationType, XceiverServerSpi> servers;
+  private final XceiverServerSpi writeChannel;
+  private final XceiverServerSpi readChannel;
+  private final ContainerController controller;
-    this.dnDetails = datanodeDetails;
-    hddsDispatcher = new HddsDispatcher(config, containerSet, volumeSet,
-        context);
-    servers = new HashMap<>();
-    servers.put(ReplicationType.STAND_ALONE,
-        new XceiverServerGrpc(datanodeDetails, config, hddsDispatcher,
-            createReplicationService()));
-    servers.put(ReplicationType.RATIS, XceiverServerRatis
-        .newXceiverServerRatis(datanodeDetails, config, hddsDispatcher,
-            context));
+    final ContainerMetrics metrics = ContainerMetrics.create(conf);
+    this.handlers = Maps.newHashMap();
+    for (ContainerType containerType : ContainerType.values()) {
+      handlers.put(containerType,
+          Handler.getHandlerForContainerType(
+              containerType, conf, context, containerSet, volumeSet, metrics));
+    }
+    this.hddsDispatcher = new HddsDispatcher(config, containerSet, volumeSet,
+        handlers, context, metrics);
+
+    /*
+     * ContainerController is the control plane
+     * XceiverServerRatis is the write channel
+     * XceiverServerGrpc is the read channel
+     */
+    this.controller = new ContainerController(containerSet, handlers);
+    this.writeChannel = XceiverServerRatis.newXceiverServerRatis(
+        datanodeDetails, config, hddsDispatcher, context);
+    this.readChannel = new XceiverServerGrpc(
+        datanodeDetails, config, hddsDispatcher, createReplicationService());
+
-        new OnDemandContainerReplicationSource(containerSet));
+        new OnDemandContainerReplicationSource(controller));
-  public void buildContainerSet() {
+  private void buildContainerSet() {
-      File hddsVolumeRootDir = volume.getHddsRootDir();
-    for (XceiverServerSpi serverinstance : servers.values()) {
-      serverinstance.start();
-    }
+    writeChannel.start();
+    readChannel.start();
-    for(XceiverServerSpi serverinstance: servers.values()) {
-      serverinstance.stop();
-    }
+    writeChannel.stop();
+    readChannel.stop();
-  public StorageContainerDatanodeProtocolProtos.ContainerReportsProto
-      getContainerReport() throws IOException {
-    return this.containerSet.getContainerReport();
-  }
-            PipelineReportsProto.newBuilder();
-    for (XceiverServerSpi serverInstance : servers.values()) {
-      pipelineReportsProto
-              .addAllPipelineReport(serverInstance.getPipelineReport());
-    }
+        PipelineReportsProto.newBuilder();
+    pipelineReportsProto.addAllPipelineReport(writeChannel.getPipelineReport());
-  /**
-   * Submit ContainerRequest.
-   * @param request
-   * @param replicationType
-   * @param pipelineID
-   */
-  public void submitContainerRequest(
-      ContainerProtos.ContainerCommandRequestProto request,
-      ReplicationType replicationType,
-      PipelineID pipelineID) throws IOException {
-    LOG.info("submitting {} request over {} server for container {}",
-        request.getCmdType(), replicationType, request.getContainerID());
-    Preconditions.checkState(servers.containsKey(replicationType));
-    servers.get(replicationType).submitRequest(request, pipelineID);
+  public XceiverServerSpi getWriteChannel() {
+    return writeChannel;
-  private int getPortByType(ReplicationType replicationType) {
-    return servers.containsKey(replicationType) ?
-        servers.get(replicationType).getIPCPort() : INVALID_PORT;
+  public XceiverServerSpi getReadChannel() {
+    return readChannel;
-  /**
-   * Returns the container servers IPC port.
-   *
-   * @return Container servers IPC port.
-   */
-  public int getContainerServerPort() {
-    return getPortByType(ReplicationType.STAND_ALONE);
-  }
-
-  /**
-   * Returns the Ratis container Server IPC port.
-   *
-   * @return Ratis port.
-   */
-  public int getRatisContainerServerPort() {
-    return getPortByType(ReplicationType.RATIS);
+  public ContainerController getController() {
+    return controller;
-  @VisibleForTesting
-  public XceiverServerSpi getServer(ReplicationType replicationType) {
-    return servers.get(replicationType);
-  }
-

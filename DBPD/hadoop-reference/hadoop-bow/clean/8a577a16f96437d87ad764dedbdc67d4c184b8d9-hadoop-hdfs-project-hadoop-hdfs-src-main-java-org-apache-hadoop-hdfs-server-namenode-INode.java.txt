HDFS-4150.  Update the inode in the block map when a snapshotted file or a snapshot file is deleted. Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1406763 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import org.apache.hadoop.hdfs.server.blockmanagement.BlockCollection;
-   *          INode. These blocks later should be removed from the blocksMap.
+   *          INode. These blocks later should be removed/updated in the
+   *          blocksMap.
-  public static class BlocksMapUpdateInfo {
-    /**
-     * The list of blocks that need to be removed from blocksMap
-     */
-    private List<Block> toDeleteList;
-    
-    public BlocksMapUpdateInfo(List<Block> toDeleteList) {
-      this.toDeleteList = toDeleteList == null ? new ArrayList<Block>()
-          : toDeleteList;
-    }
+  public static class BlocksMapUpdateInfo implements
+      Iterable<Map.Entry<Block, BlocksMapINodeUpdateEntry>> {
+    private final Map<Block, BlocksMapINodeUpdateEntry> updateMap;
-      toDeleteList = new ArrayList<Block>();
+      updateMap = new HashMap<Block, BlocksMapINodeUpdateEntry>();
-     * @return The list of blocks that need to be removed from blocksMap
-     */
-    public List<Block> getToDeleteList() {
-      return toDeleteList;
-    }
-    
-    /**
-     * Add a to-be-deleted block into the
-     * {@link BlocksMapUpdateInfo#toDeleteList}
+     * Add a to-be-deleted block. This block should belongs to a file without
+     * snapshots. We thus only need to put a block-null pair into the updateMap.
+     * 
-        toDeleteList.add(toDelete);
+        updateMap.put(toDelete, null);
-     * Clear {@link BlocksMapUpdateInfo#toDeleteList}
+     * Add a given block, as well as its old and new BlockCollection
+     * information, into the updateMap.
+     * 
+     * @param toUpdateBlock
+     *          The given block
+     * @param entry
+     *          The BlocksMapINodeUpdateEntry instance containing both the
+     *          original BlockCollection of the given block and the new
+     *          BlockCollection of the given block for updating the blocksMap.
+     *          The new BlockCollection should be the INode of one of the
+     *          corresponding file's snapshot.
+     */
+    public void addUpdateBlock(Block toUpdateBlock,
+        BlocksMapINodeUpdateEntry entry) {
+      updateMap.put(toUpdateBlock, entry);
+    }
+
+    /**
+     * Clear {@link BlocksMapUpdateInfo#updateMap}
-      toDeleteList.clear();
+      updateMap.clear();
+    }
+
+    @Override
+    public Iterator<Map.Entry<Block, BlocksMapINodeUpdateEntry>> iterator() {
+      return updateMap.entrySet().iterator();
+    }
+  }
+  
+  /**
+   * When deleting a file with snapshot, we cannot directly remove its record
+   * from blocksMap. Instead, we should consider replacing the original record
+   * in blocksMap with INode of snapshot.
+   */
+  public static class BlocksMapINodeUpdateEntry {
+    /**
+     * The BlockCollection of the file to be deleted
+     */
+    private final BlockCollection toDelete;
+    /**
+     * The BlockCollection of the to-be-deleted file's snapshot
+     */
+    private final BlockCollection toReplace;
+
+    public BlocksMapINodeUpdateEntry(BlockCollection toDelete,
+        BlockCollection toReplace) {
+      this.toDelete = toDelete;
+      this.toReplace = toReplace;
+    }
+
+    public BlockCollection getToDelete() {
+      return toDelete;
+    }
+
+    public BlockCollection getToReplace() {
+      return toReplace;

YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)

+import java.util.Collection;
-public class TempQueuePerPartition {
+public class TempQueuePerPartition extends AbstractPreemptionEntity {
-  final String queueName;
-  final Resource pending;
-  private final Resource current;
-  private final Resource reserved;
-  // Following fields are setted and used by candidate selection policies
-  Resource idealAssigned;
-  Resource toBePreempted;
+  // Following fields are settled and used by candidate selection policies
-  private Resource actuallyToBePreempted;
+  private Collection<TempAppPerPartition> apps;
-    this.queueName = queueName;
-    this.current = current;
+    super(queueName, current, Resource.newInstance(0, 0), reserved,
+        Resource.newInstance(0, 0));
-    this.idealAssigned = Resource.newInstance(0, 0);
-    this.actuallyToBePreempted = Resource.newInstance(0, 0);
-    this.toBePreempted = Resource.newInstance(0, 0);
+    this.apps = new ArrayList<>();
-    this.reserved = reserved;
-   * @param q the child queue to add to this queue
+   *
+   * @param q
+   *          the child queue to add to this queue
-  public ArrayList<TempQueuePerPartition> getChildren(){
+  public ArrayList<TempQueuePerPartition> getChildren() {
-  public Resource getUsed() {
-    return current;
-  }
-
-    // remain = avail - min(avail, (max - assigned), (current + pending - assigned))
+    // remain = avail - min(avail, (max - assigned), (current + pending -
+    // assigned))
-        absMaxCapIdealAssignedDelta, Resources.min(rc, clusterResource, avail,
-            Resources
-                /*
-                 * When we're using FifoPreemptionSelector
-                 * (considerReservedResource = false).
-                 *
-                 * We should deduct reserved resource to avoid excessive preemption:
-                 *
-                 * For example, if an under-utilized queue has used = reserved = 20.
-                 * Preemption policy will try to preempt 20 containers
-                 * (which is not satisfied) from different hosts.
-                 *
-                 * In FifoPreemptionSelector, there's no guarantee that preempted
-                 * resource can be used by pending request, so policy will preempt
-                 * resources repeatly.
-                 */
-                .subtract(Resources.add(
-                    (considersReservedResource ? getUsed() :
-                      getUsedDeductReservd()),
-                    pending), idealAssigned)));
+        absMaxCapIdealAssignedDelta,
+        Resources.min(rc, clusterResource, avail, Resources
+            /*
+             * When we're using FifoPreemptionSelector (considerReservedResource
+             * = false).
+             *
+             * We should deduct reserved resource to avoid excessive preemption:
+             *
+             * For example, if an under-utilized queue has used = reserved = 20.
+             * Preemption policy will try to preempt 20 containers (which is not
+             * satisfied) from different hosts.
+             *
+             * In FifoPreemptionSelector, there's no guarantee that preempted
+             * resource can be used by pending request, so policy will preempt
+             * resources repeatly.
+             */
+            .subtract(
+                Resources.add((considersReservedResource
+                    ? getUsed()
+                    : getUsedDeductReservd()), pending),
+                idealAssigned)));
-    Resource extra = Resources.subtract(getUsed(),
-        getGuaranteed());
+    Resource extra = Resources.subtract(getUsed(), getGuaranteed());
-    sb.append(" NAME: " + queueName)
-        .append(" CUR: ").append(current)
-        .append(" PEN: ").append(pending)
-        .append(" RESERVED: ").append(reserved)
-        .append(" GAR: ").append(getGuaranteed())
-        .append(" NORM: ").append(normalizedGuarantee)
-        .append(" IDEAL_ASSIGNED: ").append(idealAssigned)
-        .append(" IDEAL_PREEMPT: ").append(toBePreempted)
-        .append(" ACTUAL_PREEMPT: ").append(actuallyToBePreempted)
+    sb.append(" NAME: " + queueName).append(" CUR: ").append(current)
+        .append(" PEN: ").append(pending).append(" RESERVED: ").append(reserved)
+        .append(" GAR: ").append(getGuaranteed()).append(" NORM: ")
+        .append(normalizedGuarantee).append(" IDEAL_ASSIGNED: ")
+        .append(idealAssigned).append(" IDEAL_PREEMPT: ").append(toBePreempted)
+        .append(" ACTUAL_PREEMPT: ").append(getActuallyToBePreempted())
-        .append(" PREEMPTABLE: ").append(preemptableExtra)
-        .append("\n");
+        .append(" PREEMPTABLE: ").append(preemptableExtra).append("\n");
-    Resource usedDeductKillable = Resources.subtract(
-        getUsed(), killable);
+    Resource usedDeductKillable = Resources.subtract(getUsed(), killable);
-    // guaranteed and total. We should avoid preempt from a queue if it is already
+    // guaranteed and total. We should avoid preempt from a queue if it is
+    // already
-          Resources.subtract(usedDeductKillable, minimumQueueResource), scalingFactor);
+          Resources.subtract(usedDeductKillable, minimumQueueResource),
+          scalingFactor);
-  public Resource getActuallyToBePreempted() {
-    return actuallyToBePreempted;
-  }
-
-  public void setActuallyToBePreempted(Resource res) {
-    this.actuallyToBePreempted = res;
-  }
-
-    if (Resources.greaterThan(rc, cluster, actuallyToBePreempted, toBeDeduct)) {
-      Resources.subtractFrom(actuallyToBePreempted, toBeDeduct);
+    if (Resources.greaterThan(rc, cluster, getActuallyToBePreempted(),
+        toBeDeduct)) {
+      Resources.subtractFrom(getActuallyToBePreempted(), toBeDeduct);
-    actuallyToBePreempted = Resources.max(rc, cluster, actuallyToBePreempted,
-        Resources.none());
+    setActuallyToBePreempted(Resources.max(rc, cluster,
+        getActuallyToBePreempted(), Resources.none()));
-    sb.append(queueName).append(", ")
-        .append(current.getMemorySize()).append(", ")
-        .append(current.getVirtualCores()).append(", ")
+    sb.append(queueName).append(", ").append(current.getMemorySize())
+        .append(", ").append(current.getVirtualCores()).append(", ")
-        .append(toBePreempted.getVirtualCores() ).append(", ")
-        .append(actuallyToBePreempted.getMemorySize()).append(", ")
-        .append(actuallyToBePreempted.getVirtualCores());
+        .append(toBePreempted.getVirtualCores()).append(", ")
+        .append(getActuallyToBePreempted().getMemorySize()).append(", ")
+        .append(getActuallyToBePreempted().getVirtualCores());
+  }
+
+  public void addAllApps(Collection<TempAppPerPartition> orderedApps) {
+    this.apps = orderedApps;
+  }
+
+  public Collection<TempAppPerPartition> getApps() {
+    return apps;

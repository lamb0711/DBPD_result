YARN-4081. Add support for multiple resource types in the Resource class. (Varun Vasudev via wangda)

+import org.apache.hadoop.yarn.api.protocolrecords.ResourceTypes;
+import org.apache.hadoop.yarn.api.records.ResourceInformation;
+import org.apache.hadoop.yarn.exceptions.ResourceNotFoundException;
+import org.apache.hadoop.yarn.exceptions.YarnException;
+import org.apache.hadoop.yarn.proto.YarnProtos.ResourceInformationProto;
+import org.apache.hadoop.yarn.util.UnitsConversionUtil;
+
+import java.util.*;
+  private Map<String, ResourceInformation> resources;
+
+
+    this.resources = null;
+    initResources();
-  
+
+    mergeLocalToProto();
-    return (int) getMemorySize();
+    return (int) this.getMemorySize();
-    ResourceProtoOrBuilder p = viaProto ? proto : builder;
-    return p.getMemory();
+    try {
+      ResourceInformation ri =
+          this.getResourceInformation(ResourceInformation.MEMORY.getName());
+      return (int) UnitsConversionUtil
+          .convert(ri.getUnits(), "M", ri.getValue()).longValue();
+    } catch (YarnException ye) {
+      // memory should always be present
+      initResourcesMap();
+      return 0;
+    }
-    maybeInitBuilder();
-    builder.setMemory(memory);
+    setResourceInformation(ResourceInformation.MEMORY_MB.getName(),
+        ResourceInformation.newInstance(ResourceInformation.MEMORY_MB.getName(),
+            ResourceInformation.MEMORY_MB.getUnits(), memory));
+
-    ResourceProtoOrBuilder p = viaProto ? proto : builder;
-    return p.getVirtualCores();
+    try {
+      return (int) this.getResourceValue(ResourceInformation.VCORES.getName())
+          .longValue();
+    } catch (YarnException ye) {
+      // vcores should always be present
+      initResourcesMap();
+      return 0;
+    }
+    try {
+      setResourceValue(ResourceInformation.VCORES.getName(),
+          Long.valueOf(vCores));
+    } catch (ResourceNotFoundException re) {
+      this.setResourceInformation(ResourceInformation.VCORES.getName(),
+          ResourceInformation.newInstance(ResourceInformation.VCORES.getName(),
+              (long) vCores));
+    }
+  }
+
+  private void initResources() {
+    if (this.resources != null) {
+      return;
+    }
+    ResourceProtoOrBuilder p = viaProto ? proto : builder;
+    initResourcesMap();
+    for (ResourceInformationProto entry : p.getResourceValueMapList()) {
+      ResourceTypes type =
+          entry.hasType() ? ProtoUtils.convertFromProtoFormat(entry.getType()) :
+              ResourceTypes.COUNTABLE;
+      String units = entry.hasUnits() ? entry.getUnits() : "";
+      Long value = entry.hasValue() ? entry.getValue() : 0L;
+      ResourceInformation ri =
+          ResourceInformation.newInstance(entry.getKey(), units, value, type);
+      resources.put(ri.getName(), ri);
+    }
+    if(this.getMemory() != p.getMemory()) {
+      setMemorySize(p.getMemory());
+    }
+    if(this.getVirtualCores() != p.getVirtualCores()) {
+      setVirtualCores(p.getVirtualCores());
+    }
+  }
+
+  @Override
+  public void setResources(Map<String, ResourceInformation> resources) {
-    builder.setVirtualCores(vCores);
+    if (resources == null || resources.isEmpty()) {
+      builder.clearResourceValueMap();
+    } else {
+      for (Map.Entry<String, ResourceInformation> entry : resources.entrySet()) {
+        if (!entry.getKey().equals(entry.getValue().getName())) {
+          entry.getValue().setName(entry.getKey());
+        }
+      }
+    }
+    this.resources = resources;
+  }
+
+  @Override
+  public void setResourceInformation(String resource,
+      ResourceInformation resourceInformation) {
+    maybeInitBuilder();
+    if (resource == null || resourceInformation == null) {
+      throw new IllegalArgumentException(
+          "resource and/or resourceInformation cannot be null");
+    }
+    if (!resource.equals(resourceInformation.getName())) {
+      resourceInformation.setName(resource);
+    }
+    initResourcesMap();
+    resources.put(resource, resourceInformation);
+  }
+
+  @Override
+  public void setResourceValue(String resource, Long value)
+      throws ResourceNotFoundException {
+    maybeInitBuilder();
+    if (resource == null) {
+      throw new IllegalArgumentException("resource type object cannot be null");
+    }
+    if (resources == null || (!resources.containsKey(resource))) {
+      throw new ResourceNotFoundException(
+          "Resource " + resource + " not found");
+    }
+    ResourceInformation ri = resources.get(resource);
+    ri.setValue(value);
+    resources.put(resource, ri);
+  }
+
+  @Override
+  public Map<String, ResourceInformation> getResources() {
+    initResources();
+    return Collections.unmodifiableMap(this.resources);
+  }
+
+  @Override
+  public ResourceInformation getResourceInformation(String resource)
+      throws YarnException {
+    initResources();
+    if (this.resources.containsKey(resource)) {
+      return this.resources.get(resource);
+    }
+    throw new ResourceNotFoundException("Could not find entry for " + resource);
+  }
+
+  @Override
+  public Long getResourceValue(String resource) throws YarnException {
+    initResources();
+    if (this.resources.containsKey(resource)) {
+      return this.resources.get(resource).getValue();
+    }
+    throw new ResourceNotFoundException("Could not find entry for " + resource);
+  }
+
+  private void initResourcesMap() {
+    if (resources == null) {
+      resources = new HashMap<>();
+    }
+    ResourceInformation ri;
+    if (!resources.containsKey(ResourceInformation.MEMORY.getName())) {
+      ri = ResourceInformation
+          .newInstance(ResourceInformation.MEMORY_MB.getName(),
+              ResourceInformation.MEMORY_MB.getUnits());
+      this.resources.put(ResourceInformation.MEMORY.getName(), ri);
+    }
+    if (!resources.containsKey(ResourceInformation.VCORES.getName())) {
+      ri =
+          ResourceInformation.newInstance(ResourceInformation.VCORES.getName());
+      this.resources.put(ResourceInformation.VCORES.getName(), ri);
+    }
+  }
+
+  synchronized private void mergeLocalToBuilder() {
+    builder.clearResourceValueMap();
+    if (resources != null && !resources.isEmpty()) {
+      for (Map.Entry<String, ResourceInformation> entry : resources.entrySet()) {
+        ResourceInformationProto.Builder e = ResourceInformationProto.newBuilder();
+        e.setKey(entry.getKey());
+        e.setUnits(entry.getValue().getUnits());
+        e.setType(
+            ProtoUtils.converToProtoFormat(entry.getValue().getResourceType()));
+        e.setValue(entry.getValue().getValue());
+        builder.addResourceValueMap(e);
+      }
+    }
+    builder.setMemory(this.getMemory());
+    builder.setVirtualCores(this.getVirtualCores());
+  }
+
+  private void mergeLocalToProto() {
+    if (viaProto) {
+      maybeInitBuilder();
+    }
+    mergeLocalToBuilder();
+    proto = builder.build();
+    viaProto = true;

YARN-4524. Cleanup AppSchedulingInfo. (Karthik Kambatla via wangda)

(cherry picked from commit 05fa852d7567b7590d6b53bbf925f8f424736514)

+import java.util.Comparator;
-import org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttemptState;
+  private static final Comparator COMPARATOR =
+      new org.apache.hadoop.yarn.server.resourcemanager.resource.Priority.Comparator();
+  private static final int EPOCH_BIT_SHIFT = 40;
+
+  private final ApplicationId applicationId;
-  final ApplicationId applicationId;
-  private String queueName;
-  Queue queue;
-  final String user;
-  // TODO making containerIdCounter long
-  private final int EPOCH_BIT_SHIFT = 40;
+  private final String user;
-  final Set<Priority> priorities = new TreeSet<Priority>(
-      new org.apache.hadoop.yarn.server.resourcemanager.resource.Priority.Comparator());
-  final Map<Priority, Map<String, ResourceRequest>> resourceRequestMap =
-      new ConcurrentHashMap<Priority, Map<String, ResourceRequest>>();
-  final Map<NodeId, Map<Priority, Map<ContainerId, 
-      SchedContainerChangeRequest>>> increaseRequestMap =
-      new ConcurrentHashMap<>();
-  private Set<String> userBlacklist = new HashSet<>();
-  private Set<String> amBlacklist = new HashSet<>();
-
-  //private final ApplicationStore store;
+  private Queue queue;
-  
-  /* Allocated by scheduler */
-  boolean pending = true; // for app metrics
-  
+  private boolean pending = true; // whether accepted/allocated by scheduler
- 
+
+  private final Set<String> amBlacklist = new HashSet<>();
+  private Set<String> userBlacklist = new HashSet<>();
+
+  final Set<Priority> priorities = new TreeSet<>(COMPARATOR);
+  final Map<Priority, Map<String, ResourceRequest>> resourceRequestMap =
+      new ConcurrentHashMap<>();
+  final Map<NodeId, Map<Priority, Map<ContainerId,
+      SchedContainerChangeRequest>>> containerIncreaseRequestMap =
+      new ConcurrentHashMap<>();
+
-    this.queueName = queue.getQueueName();
-  public String getQueueName() {
-    return queueName;
-  }
-
+  public long getNewContainerId() {
+    return this.containerIdCounter.incrementAndGet();
+  }
+
+  public synchronized String getQueueName() {
+    return queue.getQueueName();
+  }
+
-  public long getNewContainerId() {
-    return this.containerIdCounter.incrementAndGet();
-  }
-  
-  public boolean hasIncreaseRequest(NodeId nodeId) {
+  public synchronized boolean hasIncreaseRequest(NodeId nodeId) {
-        increaseRequestMap.get(nodeId);
-    if (null == requestsOnNode) {
-      return false;
-    }
-    return requestsOnNode.size() > 0;
+        containerIncreaseRequestMap.get(nodeId);
+    return requestsOnNode == null ? false : requestsOnNode.size() > 0;
-  public Map<ContainerId, SchedContainerChangeRequest>
+  public synchronized Map<ContainerId, SchedContainerChangeRequest>
-        increaseRequestMap.get(nodeId);
-    if (null == requestsOnNode) {
-      return null;
-    }
-
-    return requestsOnNode.get(priority);
+        containerIncreaseRequestMap.get(nodeId);
+    return requestsOnNode == null ? null : requestsOnNode.get(priority);
+  /**
+   * return true if any of the existing increase requests are updated,
+   *        false if none of them are updated
+   */
-          increaseRequestMap.get(nodeId);
+          containerIncreaseRequestMap.get(nodeId);
-        increaseRequestMap.put(nodeId, requestsOnNode);
+        containerIncreaseRequestMap.put(nodeId, requestsOnNode);
-          // New target capacity is as same as what we have, just ignore the new
-          // one
+          // increase request hasn't changed
-        // remove the old one
+        // remove the old one, as we will use the new one going forward
-      if (Resources.equals(r.getTargetCapacity(), r.getRMContainer().getAllocatedResource())) {
+      if (Resources.equals(r.getTargetCapacity(),
+          r.getRMContainer().getAllocatedResource())) {
-          LOG.debug("Trying to increase/decrease container, "
-              + "target capacity = previous capacity = " + prevChangeRequest
-              + " for container=" + r.getContainerId()
-              + ". Will ignore this increase request");
+          LOG.debug("Trying to increase container " + r.getContainerId()
+              + ", target capacity = previous capacity = " + prevChangeRequest
+              + ". Will ignore this increase request.");
-  // insert increase request and add missing hierarchy if missing
+  /**
+   * Insert increase request, adding any missing items in the data-structure
+   * hierarchy.
+   */
-        increaseRequestMap.get(nodeId);
+        containerIncreaseRequestMap.get(nodeId);
-      requestsOnNode =
-          new HashMap<Priority, Map<ContainerId, SchedContainerChangeRequest>>();
-      increaseRequestMap.put(nodeId, requestsOnNode);
+      requestsOnNode = new HashMap<>();
+      containerIncreaseRequestMap.put(nodeId, requestsOnNode);
-      requestsOnNodeWithPriority =
-          new TreeMap<ContainerId, SchedContainerChangeRequest>();
+      requestsOnNodeWithPriority = new TreeMap<>();
-        increaseRequestMap.get(nodeId);
+        containerIncreaseRequestMap.get(nodeId);
-      increaseRequestMap.remove(nodeId);
+      containerIncreaseRequestMap.remove(nodeId);
-        increaseRequestMap.get(nodeId);
+        containerIncreaseRequestMap.get(nodeId);
-    if (null == requestsOnNodeWithPriority) {
-      return null;
-    }
-
-    return requestsOnNodeWithPriority.get(containerId);
+    return requestsOnNodeWithPriority == null ? null
+        : requestsOnNodeWithPriority.get(containerId);
-   * @param recoverPreemptedRequest recover Resource Request on preemption
-   * @return true if any resource was updated, false else
+   * @param recoverPreemptedRequest recover ResourceRequest on preemption
+   * @return true if any resource was updated, false otherwise
-  synchronized public boolean updateResourceRequests(
+  public synchronized boolean updateResourceRequests(
-    QueueMetrics metrics = queue.getMetrics();
-    
+    // Flag to track if any incoming requests update "ANY" requests
-      boolean updatePendingResources = false;
-      ResourceRequest lastRequest = null;
-      if (resourceName.equals(ResourceRequest.ANY)) {
-        if (LOG.isDebugEnabled()) {
-          LOG.debug("update:" + " application=" + applicationId + " request="
-              + request);
-        }
-        updatePendingResources = true;
-        anyResourcesUpdated = true;
-        
-        // Premature optimization?
-        // Assumes that we won't see more than one priority request updated
-        // in one call, reasonable assumption... however, it's totally safe
-        // to activate same application more than once.
-        // Thus we don't need another loop ala the one in decrementOutstanding()  
-        // which is needed during deactivate.
-        if (request.getNumContainers() > 0) {
-          activeUsersManager.activateApplication(user, applicationId);
-        }
-        ResourceRequest previousAnyRequest =
-            getResourceRequest(priority, resourceName);
-
-        // When there is change in ANY request label expression, we should
-        // update label for all resource requests already added of same
-        // priority as ANY resource request.
-        if ((null == previousAnyRequest)
-            || isRequestLabelChanged(previousAnyRequest, request)) {
-          Map<String, ResourceRequest> resourceRequest =
-              getResourceRequests(priority);
-          if (resourceRequest != null) {
-            for (ResourceRequest r : resourceRequest.values()) {
-              if (!r.getResourceName().equals(ResourceRequest.ANY)) {
-                r.setNodeLabelExpression(request.getNodeLabelExpression());
-              }
-            }
-          }
-        }
-      } else {
-        ResourceRequest anyRequest =
-            getResourceRequest(priority, ResourceRequest.ANY);
-        if (anyRequest != null) {
-          request.setNodeLabelExpression(anyRequest.getNodeLabelExpression());
-        }
-      }
+      // Update node labels if required
+      updateNodeLabels(request);
-
-        asks = new ConcurrentHashMap<String, ResourceRequest>();
+        asks = new ConcurrentHashMap<>();
-      lastRequest = asks.get(resourceName);
+      // Increment number of containers if recovering preempted resources
+      ResourceRequest lastRequest = asks.get(resourceName);
-        // Increment the number of containers to 1, as it is recovering a
-        // single container.
+      // Update asks
-      if (updatePendingResources) {
-        
-        // Similarly, deactivate application?
-        if (request.getNumContainers() <= 0) {
-          LOG.info("checking for deactivate of application :"
-              + this.applicationId);
-          checkForDeactivation();
+
+      if (resourceName.equals(ResourceRequest.ANY)) {
+        anyResourcesUpdated = true;
+
+        // Activate application. Metrics activation is done here.
+        // TODO: Shouldn't we activate even if numContainers = 0?
+        if (request.getNumContainers() > 0) {
+          activeUsersManager.activateApplication(user, applicationId);
-        
-        int lastRequestContainers = lastRequest != null ? lastRequest
-            .getNumContainers() : 0;
-        Resource lastRequestCapability = lastRequest != null ? lastRequest
-            .getCapability() : Resources.none();
-        metrics.incrPendingResources(user, request.getNumContainers(),
-            request.getCapability());
-        metrics.decrPendingResources(user, lastRequestContainers,
-            lastRequestCapability);
-        
-        // update queue:
-        Resource increasedResource =
-            Resources.multiply(request.getCapability(),
-                request.getNumContainers());
-        queue.incPendingResource(request.getNodeLabelExpression(),
-            increasedResource);
-        appResourceUsage.incPending(request.getNodeLabelExpression(),
-            increasedResource);
-        if (lastRequest != null) {
-          Resource decreasedResource =
-              Resources.multiply(lastRequestCapability, lastRequestContainers);
-          queue.decPendingResource(lastRequest.getNodeLabelExpression(),
-              decreasedResource);
-          appResourceUsage.decPending(lastRequest.getNodeLabelExpression(),
-              decreasedResource);
-        }
+
+        // Update pendingResources
+        updatePendingResources(lastRequest, request, queue.getMetrics());
-  private boolean isRequestLabelChanged(ResourceRequest requestOne,
+  private void updatePendingResources(ResourceRequest lastRequest,
+      ResourceRequest request, QueueMetrics metrics) {
+    if (request.getNumContainers() <= 0) {
+      LOG.info("checking for deactivate of application :"
+          + this.applicationId);
+      checkForDeactivation();
+    }
+
+    int lastRequestContainers =
+        (lastRequest != null) ? lastRequest.getNumContainers() : 0;
+    Resource lastRequestCapability =
+        lastRequest != null ? lastRequest.getCapability() : Resources.none();
+    metrics.incrPendingResources(user,
+        request.getNumContainers(), request.getCapability());
+    metrics.decrPendingResources(user,
+        lastRequestContainers, lastRequestCapability);
+
+    // update queue:
+    Resource increasedResource =
+        Resources.multiply(request.getCapability(), request.getNumContainers());
+    queue.incPendingResource(request.getNodeLabelExpression(),
+        increasedResource);
+    appResourceUsage.incPending(request.getNodeLabelExpression(),
+        increasedResource);
+    if (lastRequest != null) {
+      Resource decreasedResource =
+          Resources.multiply(lastRequestCapability, lastRequestContainers);
+      queue.decPendingResource(lastRequest.getNodeLabelExpression(),
+          decreasedResource);
+      appResourceUsage.decPending(lastRequest.getNodeLabelExpression(),
+          decreasedResource);
+    }
+  }
+
+  private void updateNodeLabels(ResourceRequest request) {
+    Priority priority = request.getPriority();
+    String resourceName = request.getResourceName();
+    if (resourceName.equals(ResourceRequest.ANY)) {
+      ResourceRequest previousAnyRequest =
+          getResourceRequest(priority, resourceName);
+
+      // When there is change in ANY request label expression, we should
+      // update label for all resource requests already added of same
+      // priority as ANY resource request.
+      if ((null == previousAnyRequest)
+          || hasRequestLabelChanged(previousAnyRequest, request)) {
+        Map<String, ResourceRequest> resourceRequest =
+            getResourceRequests(priority);
+        if (resourceRequest != null) {
+          for (ResourceRequest r : resourceRequest.values()) {
+            if (!r.getResourceName().equals(ResourceRequest.ANY)) {
+              r.setNodeLabelExpression(request.getNodeLabelExpression());
+            }
+          }
+        }
+      }
+    } else {
+      ResourceRequest anyRequest =
+          getResourceRequest(priority, ResourceRequest.ANY);
+      if (anyRequest != null) {
+        request.setNodeLabelExpression(anyRequest.getNodeLabelExpression());
+      }
+    }
+  }
+
+  private boolean hasRequestLabelChanged(ResourceRequest requestOne,
-  synchronized public Collection<Priority> getPriorities() {
+  public synchronized Collection<Priority> getPriorities() {
-  synchronized public Map<String, ResourceRequest> getResourceRequests(
+  public synchronized Map<String, ResourceRequest> getResourceRequests(
-  public List<ResourceRequest> getAllResourceRequests() {
-    List<ResourceRequest> ret = new ArrayList<ResourceRequest>();
+  public synchronized List<ResourceRequest> getAllResourceRequests() {
+    List<ResourceRequest> ret = new ArrayList<>();
-  synchronized public ResourceRequest getResourceRequest(Priority priority,
+  public synchronized ResourceRequest getResourceRequest(Priority priority,
-  
+
-   * 
-   * @param type
-   *          the type of the node
-   * @param node
-   *          the nodeinfo of the node
-   * @param priority
-   *          the priority of the request.
-   * @param request
-   *          the request
-   * @param container
-   *          the containers allocated.
-  synchronized public List<ResourceRequest> allocate(NodeType type,
+  public synchronized List<ResourceRequest> allocate(NodeType type,
-      Container container) {
-    List<ResourceRequest> resourceRequests = new ArrayList<ResourceRequest>();
+      Container containerAllocated) {
+    List<ResourceRequest> resourceRequests = new ArrayList<>();
-      allocateNodeLocal(node, priority, request, container, resourceRequests);
+      allocateNodeLocal(node, priority, request, resourceRequests);
-      allocateRackLocal(node, priority, request, container, resourceRequests);
+      allocateRackLocal(node, priority, request, resourceRequests);
-      allocateOffSwitch(node, priority, request, container, resourceRequests);
+      allocateOffSwitch(request, resourceRequests);
-          + " container=" + container.getId()
-          + " host=" + container.getNodeId().toString()
+          + " container=" + containerAllocated.getId()
+          + " host=" + containerAllocated.getNodeId().toString()
-   * 
-   * @param allocatedContainers
-   *          resources allocated to the application
-  synchronized private void allocateNodeLocal(SchedulerNode node,
-      Priority priority, ResourceRequest nodeLocalRequest, Container container,
+  private synchronized void allocateNodeLocal(SchedulerNode node,
+      Priority priority, ResourceRequest nodeLocalRequest,
-   * 
-   * @param allocatedContainers
-   *          resources allocated to the application
-  synchronized private void allocateRackLocal(SchedulerNode node,
-      Priority priority, ResourceRequest rackLocalRequest, Container container,
+  private synchronized void allocateRackLocal(SchedulerNode node,
+      Priority priority, ResourceRequest rackLocalRequest,
-   * 
-   * @param allocatedContainers
-   *          resources allocated to the application
-  synchronized private void allocateOffSwitch(SchedulerNode node,
-      Priority priority, ResourceRequest offSwitchRequest, Container container,
-      List<ResourceRequest> resourceRequests) {
+  private synchronized void allocateOffSwitch(
+      ResourceRequest offSwitchRequest, List<ResourceRequest> resourceRequests) {
-  synchronized private void decrementOutstanding(
+  private synchronized void decrementOutstanding(
-  synchronized private void checkForDeactivation() {
+  private synchronized void checkForDeactivation() {
-      deactivate = increaseRequestMap.isEmpty();
+      deactivate = containerIncreaseRequestMap.isEmpty();
-  synchronized public void move(Queue newQueue) {
+  public synchronized void move(Queue newQueue) {
-    this.queueName = newQueue.getQueueName();
-  synchronized public void stop(RMAppAttemptState rmAppAttemptFinalState) {
+  public synchronized void stop() {
-    //    this.priorities = appInfo.getPriorities();
-    //    this.requests = appInfo.getRequests();
-    // Should cleanup this to avoid sharing between instances and can
-    // then remove getBlacklist as well.

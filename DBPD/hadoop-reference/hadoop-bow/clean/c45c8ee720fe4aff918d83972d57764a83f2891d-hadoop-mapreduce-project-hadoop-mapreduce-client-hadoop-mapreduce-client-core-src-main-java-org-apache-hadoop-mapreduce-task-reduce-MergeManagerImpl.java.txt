Complete commit of prior merge.

The previous merge accidentally only committed the hdfs project instead of common and MR
as well.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1463203 13f79535-47bb-0310-9956-ffa450edef68

-        compressAwarePath = new CompressAwarePath(outputPath,
-            writer.getRawLength());
+        compressAwarePath = new CompressAwarePath(outputPath,
+            writer.getRawLength(), writer.getCompressedLength());
-      super(manager, Integer.MAX_VALUE, exceptionReporter);
+      super(manager, ioSortFactor, exceptionReporter);
-        compressAwarePath = new CompressAwarePath(outputPath,
-            writer.getRawLength());
+        compressAwarePath = new CompressAwarePath(outputPath,
+            writer.getRawLength(), writer.getCompressedLength());
-        final Writer<K,V> writer = new Writer<K,V>(job, fs, outputPath,
+        Writer<K,V> writer = new Writer<K,V>(job, fs, outputPath,
-          // add to list of final disk outputs.
+          writer.close();
-              writer.getRawLength()));
+              writer.getRawLength(), writer.getCompressedLength()));
+          writer = null;
+          // add to list of final disk outputs.
-          job, fs, keyClass, valueClass, diskSegments,
+          job, fs, keyClass, valueClass, codec, diskSegments,
+    private long compressedSize;
-    public CompressAwarePath(Path path, long rawDataLength) {
+    public CompressAwarePath(Path path, long rawDataLength, long compressSize) {
+      this.compressedSize = compressSize;
-    
+
+    public long getCompressedSize() {
+      return compressedSize;
+    }
+
-    
+
+
+    @Override
+    public int compareTo(Object obj) {
+      if(obj instanceof CompressAwarePath) {
+        CompressAwarePath compPath = (CompressAwarePath) obj;
+        if(this.compressedSize < compPath.getCompressedSize()) {
+          return -1;
+        } else if (this.getCompressedSize() > compPath.getCompressedSize()) {
+          return 1;
+        }
+        // Not returning 0 here so that objects with the same size (but
+        // different paths) are still added to the TreeSet.
+      }
+      return super.compareTo(obj);
+    }

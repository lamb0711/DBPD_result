YARN-4766. NM should not aggregate logs older than the retention policy (haibochen via rkanter)

+import com.google.protobuf.ByteString;
+import org.apache.hadoop.io.DataOutputBuffer;
+import org.apache.hadoop.yarn.api.records.impl.pb.ApplicationIdPBImpl;
+import org.apache.hadoop.yarn.api.records.impl.pb.LogAggregationContextPBImpl;
+import org.apache.hadoop.yarn.api.records.impl.pb.ProtoUtils;
+import org.apache.hadoop.yarn.proto.YarnProtos;
+import org.apache.hadoop.yarn.proto.YarnServerNodemanagerRecoveryProtos.ContainerManagerApplicationProto;
+import org.apache.hadoop.yarn.server.nodemanager.recovery.NMStateStoreService;
-
-  public ApplicationImpl(Dispatcher dispatcher, String user, ApplicationId appId,
-      Credentials credentials, Context context) {
+  /**
+   * The timestamp when the log aggregation has started for this application.
+   * Used to determine the age of application log files during log aggregation.
+   * When logAggregationRentention policy is enabled, log files older than
+   * the retention policy will not be uploaded but scheduled for deletion.
+   */
+  private long applicationLogInitedTimestamp = -1;
+  private final NMStateStoreService appStateStore;
+
+  public ApplicationImpl(Dispatcher dispatcher, String user,
+      ApplicationId appId, Credentials credentials,
+      Context context, long recoveredLogInitedTime) {
+    this.appStateStore = context.getNMStateStore();
+    setAppLogInitedTimestamp(recoveredLogInitedTime);
+  }
+
+  public ApplicationImpl(Dispatcher dispatcher, String user,
+      ApplicationId appId, Credentials credentials, Context context) {
+    this(dispatcher, user, appId, credentials, context, -1);
-              app.logAggregationContext));
+              app.logAggregationContext, app.applicationLogInitedTimestamp));
+      app.setAppLogInitedTimestamp(event.getTimestamp());
+      try {
+        app.appStateStore.storeApplication(app.appId, buildAppProto(app));
+      } catch (Exception ex) {
+        LOG.warn("failed to update application state in state store", ex);
+      }
+  @VisibleForTesting
+  void setAppLogInitedTimestamp(long appLogInitedTimestamp) {
+    this.applicationLogInitedTimestamp = appLogInitedTimestamp;
+  }
+
+  static ContainerManagerApplicationProto buildAppProto(ApplicationImpl app)
+      throws IOException {
+    ContainerManagerApplicationProto.Builder builder =
+        ContainerManagerApplicationProto.newBuilder();
+    builder.setId(((ApplicationIdPBImpl) app.appId).getProto());
+    builder.setUser(app.getUser());
+
+    if (app.logAggregationContext != null) {
+      builder.setLogAggregationContext((
+          (LogAggregationContextPBImpl)app.logAggregationContext).getProto());
+    }
+
+    builder.clearCredentials();
+    if (app.credentials != null) {
+      DataOutputBuffer dob = new DataOutputBuffer();
+      app.credentials.writeTokenStorageToStream(dob);
+      builder.setCredentials(ByteString.copyFrom(dob.getData()));
+    }
+
+    builder.clearAcls();
+    if (app.applicationACLs != null) {
+      for (Map.Entry<ApplicationAccessType, String> acl :  app
+          .applicationACLs.entrySet()) {
+        YarnProtos.ApplicationACLMapProto p = YarnProtos
+            .ApplicationACLMapProto.newBuilder()
+            .setAccessType(ProtoUtils.convertToProtoFormat(acl.getKey()))
+            .setAcl(acl.getValue())
+            .build();
+        builder.addAcls(p);
+      }
+    }
+
+    builder.setAppLogAggregationInitedTime(app.applicationLogInitedTimestamp);
+
+    return builder.build();
+  }
+

YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.
YARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.

+import java.util.HashSet;
+import org.apache.commons.lang.StringUtils;
+import org.apache.hadoop.yarn.nodelabels.CommonNodeLabelsManager;
+import org.apache.hadoop.yarn.server.resourcemanager.nodelabels.RMNodeLabelsManager;
-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.QueueMetrics;
-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerUtils;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerUtils;
-import org.apache.hadoop.yarn.util.resource.ResourceCalculator;
+import com.google.common.collect.Sets;
-public class LeafQueue implements CSQueue {
+public class LeafQueue extends AbstractCSQueue {
-  private final String queueName;
-  private CSQueue parent;
-  private float capacity;
-  private float absoluteCapacity;
-  private float maximumCapacity;
-  private float absoluteMaxCapacity;
-  
-  private Resource usedResources = Resources.createResource(0, 0);
-  private float usedCapacity = 0.0f;
-  private volatile int numContainers;
-  private final Resource minimumAllocation;
-  private final Resource maximumAllocation;
-  
-  private final QueueMetrics metrics;
-
-  private QueueInfo queueInfo; 
-
-  private QueueState state;
-
-  private Map<QueueACL, AccessControlList> acls = 
-    new HashMap<QueueACL, AccessControlList>();
-  
-  private final ResourceCalculator resourceCalculator;
-  
-  private boolean reservationsContinueLooking;
+
+  // cache last cluster resource to compute actual capacity
+  private Resource lastClusterResource = Resources.none();
-      String queueName, CSQueue parent, CSQueue old) {
+      String queueName, CSQueue parent, CSQueue old) throws IOException {
+    super(cs, queueName, parent, old);
-    this.queueName = queueName;
-    this.parent = parent;
-    
-    this.resourceCalculator = cs.getResourceCalculator();
-    // must be after parent and queueName are initialized
-    this.metrics = old != null ? old.getMetrics() :
-        QueueMetrics.forQueue(getQueuePath(), parent,
-			      cs.getConfiguration().getEnableUserMetrics(),
-			      cs.getConf());
-    this.minimumAllocation = cs.getMinimumResourceCapability();
-    this.maximumAllocation = cs.getMaximumResourceCapability();
-    int maxApplications = cs.getConfiguration().getMaximumApplicationsPerQueue(getQueuePath());
+    int maxApplications =
+        cs.getConfiguration().getMaximumApplicationsPerQueue(getQueuePath());
-    int maxActiveApplicationsPerUser = 
-        CSQueueUtils.computeMaxActiveApplicationsPerUser(maxActiveAppsUsingAbsCap, userLimit, 
-            userLimitFactor);
+    int maxActiveApplicationsPerUser =
+        CSQueueUtils.computeMaxActiveApplicationsPerUser(
+            maxActiveAppsUsingAbsCap, userLimit, userLimitFactor);
-    this.queueInfo = recordFactory.newRecordInstance(QueueInfo.class);
-    this.queueInfo.setQueueName(queueName);
-    setupQueueConfigs(
-        cs.getClusterResource(),
-        capacity, absoluteCapacity, 
-        maximumCapacity, absoluteMaxCapacity, 
-        userLimit, userLimitFactor, 
+    setupQueueConfigs(cs.getClusterResource(), capacity, absoluteCapacity,
+        maximumCapacity, absoluteMaxCapacity, userLimit, userLimitFactor,
-        maxActiveApplications, maxActiveApplicationsPerUser, state, acls, 
-        cs.getConfiguration().getNodeLocalityDelay(), 
+        maxActiveApplications, maxActiveApplicationsPerUser, state, acls, cs
+            .getConfiguration().getNodeLocalityDelay(), accessibleLabels,
+        defaultLabelExpression, this.capacitiyByNodeLabels,
+        this.maxCapacityByNodeLabels,
-
+  
-      boolean continueLooking)
-  {
+      Set<String> labels, String defaultLabelExpression,
+      Map<String, Float> capacitieByLabel,
+      Map<String, Float> maximumCapacitiesByLabel, 
+      boolean revervationContinueLooking) throws IOException {
+    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,
+        maximumCapacity, absoluteMaxCapacity, state, acls, labels,
+        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,
+        revervationContinueLooking);
-    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);
+    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,
+        absoluteMaxCapacity);
-    this.capacity = capacity; 
-    this.maximumCapacity = maximumCapacity;
-    this.absoluteMaxCapacity = absoluteMaxCapacity;
-
-    
-    this.state = state;
-    this.acls = acls;
-
-    this.queueInfo.setCapacity(this.capacity);
-    this.queueInfo.setMaximumCapacity(this.maximumCapacity);
-    this.queueInfo.setQueueState(this.state);
+    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,
+        this.defaultLabelExpression)) {
+      throw new IOException("Invalid default label expression of "
+          + " queue="
+          + queueInfo.getQueueName()
+          + " doesn't have permission to access all labels "
+          + "in default label expression. labelExpression of resource request="
+          + (this.defaultLabelExpression == null ? ""
+              : this.defaultLabelExpression)
+          + ". Queue labels="
+          + (queueInfo.getAccessibleNodeLabels() == null ? "" : StringUtils.join(queueInfo
+              .getAccessibleNodeLabels().iterator(), ',')));
+    }
-    this.reservationsContinueLooking = continueLooking;
-    
-    // Update metrics
-    CSQueueUtils.updateQueueStatistics(
-        resourceCalculator, this, getParent(), clusterResource, 
-        minimumAllocation);
+
+    StringBuilder labelStrBuilder = new StringBuilder(); 
+    if (labels != null) {
+      for (String s : labels) {
+        labelStrBuilder.append(s);
+        labelStrBuilder.append(",");
+      }
+    }
+        "nodeLocalityDelay = " + nodeLocalityDelay + "\n" +
+        "labels=" + labelStrBuilder.toString() + "\n" +
-  
-  @Override
-  public synchronized float getCapacity() {
-    return capacity;
-  }
-
-  @Override
-  public synchronized float getAbsoluteCapacity() {
-    return absoluteCapacity;
-  }
-
-  @Override
-  public synchronized float getMaximumCapacity() {
-    return maximumCapacity;
-  }
-
-  @Override
-  public synchronized float getAbsoluteMaximumCapacity() {
-    return absoluteMaxCapacity;
-  }
-
-  @Override
-  public synchronized float getAbsoluteUsedCapacity() {
-    return absoluteUsedCapacity;
-  }
-
-  @Override
-  public synchronized CSQueue getParent() {
-    return parent;
-  }
-  
-  @Override
-  public synchronized void setParent(CSQueue newParentQueue) {
-    this.parent = (ParentQueue)newParentQueue;
-  }
-  
-  @Override
-  public String getQueueName() {
-    return queueName;
-  }
-  public Resource getMinimumAllocation() {
-    return minimumAllocation;
-  }
-
-  /**
-   * Used only by tests.
-   */
-  @Private
-  public Resource getMaximumAllocation() {
-    return maximumAllocation;
-  }
-
-  /**
-   * Used only by tests.
-   */
-  @Private
-  public synchronized float getUsedCapacity() {
-    return usedCapacity;
-  }
-
-  @Override
-  public synchronized Resource getUsedResources() {
-    return usedResources;
-  }
-
-  @Override
-
-  @Override
-  public synchronized void setUsedCapacity(float usedCapacity) {
-    this.usedCapacity = usedCapacity;
-  }
-
-  @Override
-  public synchronized void setAbsoluteUsedCapacity(float absUsedCapacity) {
-    this.absoluteUsedCapacity = absUsedCapacity;
-  }
-
-  /**
-   * Set maximum capacity - used only for testing.
-   * @param maximumCapacity new max capacity
-   */
-  synchronized void setMaxCapacity(float maximumCapacity) {
-    // Sanity check
-    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);
-    float absMaxCapacity = 
-        CSQueueUtils.computeAbsoluteMaximumCapacity(
-            maximumCapacity, getParent());
-    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absoluteCapacity, absMaxCapacity);
-    
-    this.maximumCapacity = maximumCapacity;
-    this.absoluteMaxCapacity = absMaxCapacity;
-  }
-  @Private
-  boolean getReservationContinueLooking() {
-    return reservationsContinueLooking;
-  }
-  
+  
+  @VisibleForTesting
+  public synchronized void setNodeLabelManager(RMNodeLabelsManager mgr) {
+    this.labelManager = mgr;
+  }
+        newlyParsedLeafQueue.accessibleLabels,
+        newlyParsedLeafQueue.defaultLabelExpression,
+        newlyParsedLeafQueue.capacitiyByNodeLabels,
+        newlyParsedLeafQueue.maxCapacityByNodeLabels,
-  public boolean hasAccess(QueueACL acl, UserGroupInformation user) {
-    // Check if the leaf-queue allows access
-    synchronized (this) {
-      if (acls.get(acl).isUserAllowed(user)) {
-        return true;
-      }
-    }
-
-    // Check if parent-queue allows access
-    return getParent().hasAccess(acl, user);
-  }
-
-  @Override
-  private synchronized void addApplicationAttempt(FiCaSchedulerApp application, User user) {
+  private synchronized void addApplicationAttempt(FiCaSchedulerApp application,
+      User user) {
-  public synchronized void removeApplicationAttempt(FiCaSchedulerApp application, User user) {
+  public synchronized void removeApplicationAttempt(
+      FiCaSchedulerApp application, User user) {
+  private static Set<String> getRequestLabelSetByExpression(
+      String labelExpression) {
+    Set<String> labels = new HashSet<String>();
+    if (null == labelExpression) {
+      return labels;
+    }
+    for (String l : labelExpression.split("&&")) {
+      if (l.trim().isEmpty()) {
+        continue;
+      }
+      labels.add(l.trim());
+    }
+    return labels;
+  }
+  
+    // if our queue cannot access this node, just return
+    if (!SchedulerUtils.checkQueueAccessToNode(accessibleLabels,
+        labelManager.getLabelsOnNode(node.getNodeID()))) {
+      return NULL_ASSIGNMENT;
+    }
+    
+          
+          Set<String> requestedNodeLabels =
+              getRequestLabelSetByExpression(anyRequest
+                  .getNodeLabelExpression());
-                  required);          
+                  required, requestedNodeLabels);          
-          if (!assignToQueue(clusterResource, required, application, true)) {
+          if (!canAssignToThisQueue(clusterResource, required,
+              labelManager.getLabelsOnNode(node.getNodeID()), application, true)) {
-              application, true)) {
+              application, true, requestedNodeLabels)) {
-            allocateResource(clusterResource, application, assigned);
+            allocateResource(clusterResource, application, assigned,
+                labelManager.getLabelsOnNode(node.getNodeID()));
-	  computeUserLimit(application, clusterResource, required, user));
+	  computeUserLimit(application, clusterResource, required, user, null));
-        Resources.subtract(userLimit, user.getConsumedResources()),
+        Resources.subtract(userLimit, user.getTotalConsumedResources()),
-
-  @Private
-  protected synchronized boolean assignToQueue(Resource clusterResource, 
-      Resource required, FiCaSchedulerApp application, 
+  synchronized boolean canAssignToThisQueue(Resource clusterResource,
+      Resource required, Set<String> nodeLabels, FiCaSchedulerApp application, 
-
-    Resource potentialTotalResource = Resources.add(usedResources, required);
-    // Check how of the cluster's absolute capacity we are currently using...
-    float potentialNewCapacity = Resources.divide(resourceCalculator,
-        clusterResource, potentialTotalResource, clusterResource);
-    if (potentialNewCapacity > absoluteMaxCapacity) {
+    // Get label of this queue can access, it's (nodeLabel AND queueLabel)
+    Set<String> labelCanAccess;
+    if (null == nodeLabels || nodeLabels.isEmpty()) {
+      labelCanAccess = new HashSet<String>();
+      // Any queue can always access any node without label
+      labelCanAccess.add(RMNodeLabelsManager.NO_LABEL);
+    } else {
+      labelCanAccess = new HashSet<String>(Sets.intersection(accessibleLabels, nodeLabels));
+    }
+    
+    boolean canAssign = true;
+    for (String label : labelCanAccess) {
+      if (!usedResourcesByNodeLabels.containsKey(label)) {
+        usedResourcesByNodeLabels.put(label, Resources.createResource(0));
+      }
+      
+      Resource potentialTotalCapacity =
+          Resources.add(usedResourcesByNodeLabels.get(label), required);
+      
+      float potentialNewCapacity =
+          Resources.divide(resourceCalculator, clusterResource,
+              potentialTotalCapacity,
+              labelManager.getResourceByLabel(label, clusterResource));
-      if (this.reservationsContinueLooking && checkReservations) {
-
+      // TODO, now only consider reservation cases when the node has no label
+      if (this.reservationsContinueLooking && checkReservations
+          && label.equals(RMNodeLabelsManager.NO_LABEL)) {
-            Resources.subtract(potentialTotalResource,
-                application.getCurrentReservation()),
-             clusterResource);
+            Resources.subtract(potentialTotalCapacity,
+               application.getCurrentReservation()),
+            labelManager.getResourceByLabel(label, clusterResource));
-
+      
+      // Otherwise, if any of the label of this node beyond queue limit, we
+      // cannot allocate on this node. Consider a small epsilon here.
+      if (potentialNewCapacity > getAbsoluteMaximumCapacityByNodeLabel(label) + 1e-4) {
+        canAssign = false;
+        break;
+      }
+
-            + " usedResources: " + usedResources
+            + "Check assign to queue, label=" + label
+            + " usedResources: " + usedResourcesByNodeLabels.get(label)
-              usedResources, clusterResource) + " required " + required
+                usedResourcesByNodeLabels.get(label),
+                labelManager.getResourceByLabel(label, clusterResource))
-      return false;
-    return true;
+    
+    return canAssign;
-
-
-  Resource computeUserLimitAndSetHeadroom(
-      FiCaSchedulerApp application, Resource clusterResource, Resource required) {
-    
+  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,
+      Resource clusterResource, Resource required, Set<String> requestedLabels) {
-    
-    Resource userLimit =                          // User limit
-        computeUserLimit(application, clusterResource, required, queueUser);
+    // Compute user limit respect requested labels,
+    // TODO, need consider headroom respect labels also
+    Resource userLimit =
+        computeUserLimit(application, clusterResource, required,
+            queueUser, requestedLabels);
-    Resource headroom = getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);
+    Resource headroom =
+        getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);
-          " consumed=" + queueUser.getConsumedResources() + 
+          " consumed=" + queueUser.getTotalConsumedResources() + 
-  private Resource computeUserLimit(FiCaSchedulerApp application, 
-      Resource clusterResource, Resource required, User user) {
+  private Resource computeUserLimit(FiCaSchedulerApp application,
+      Resource clusterResource, Resource required, User user,
+      Set<String> requestedLabels) {
+    Resource queueCapacity = Resource.newInstance(0, 0);
+    if (requestedLabels != null && !requestedLabels.isEmpty()) {
+      // if we have multiple labels to request, we will choose to use the first
+      // label
+      String firstLabel = requestedLabels.iterator().next();
+      queueCapacity =
+          Resources
+              .max(resourceCalculator, clusterResource, queueCapacity,
+                  Resources.multiplyAndNormalizeUp(resourceCalculator,
+                      labelManager.getResourceByLabel(firstLabel,
+                          clusterResource),
+                      getAbsoluteCapacityByNodeLabel(firstLabel),
+                      minimumAllocation));
+    } else {
+      // else there's no label on request, just to use absolute capacity as
+      // capacity for nodes without label
+      queueCapacity =
+          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager
+                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),
+              absoluteCapacity, minimumAllocation);
+    }
-    final Resource queueCapacity =
+    queueCapacity =
-            Resources.multiplyAndNormalizeUp(
-                resourceCalculator, 
-                clusterResource, 
-                absoluteCapacity, 
-                minimumAllocation), 
+            queueCapacity, 
-          " consumed: " + user.getConsumedResources() + 
+          " consumed: " + user.getTotalConsumedResources() + 
-      boolean checkReservations) {
-
+      boolean checkReservations, Set<String> requestLabels) {
+    
+    String label = CommonNodeLabelsManager.NO_LABEL;
+    if (requestLabels != null && !requestLabels.isEmpty()) {
+      label = requestLabels.iterator().next();
+    }
-    if (Resources.greaterThan(resourceCalculator, clusterResource,
-        user.getConsumedResources(), limit)) {
-
+    if (Resources
+        .greaterThan(resourceCalculator, clusterResource,
+            user.getConsumedResourceByLabel(label),
+            limit)) {
-            Resources.subtract(user.getConsumedResources(),
+            Resources.subtract(user.getTotalConsumedResources(),
-                + user.getConsumedResources() + " reserved: "
+                + user.getTotalConsumedResources() + " reserved: "
-            + user.getConsumedResources() + " limit: " + limit);
+            + user.getTotalConsumedResources() + " limit: " + limit);
-  boolean needContainers(FiCaSchedulerApp application, Priority priority, Resource required) {
+  boolean needContainers(FiCaSchedulerApp application, Priority priority,
+      Resource required) {
-  private CSAssignment assignContainersOnNode(Resource clusterResource, 
-      FiCaSchedulerNode node, FiCaSchedulerApp application, 
-      Priority priority, RMContainer reservedContainer, boolean needToUnreserve) {
-
+  private CSAssignment assignContainersOnNode(Resource clusterResource,
+      FiCaSchedulerNode node, FiCaSchedulerApp application, Priority priority,
+      RMContainer reservedContainer, boolean needToUnreserve) {
-        clusterResource, capability);
+        clusterResource, capability, null);
-    // Check queue max-capacity limit
-    if (!assignToQueue(clusterResource, capability, application, false)) {
+    // Check queue max-capacity limit,
+    // TODO: Consider reservation on labels
+    if (!canAssignToThisQueue(clusterResource, capability, null, application, false)) {
-        application, false)) {
+        application, false, null)) {
+    
+    // check if the resource request can access the label
+    if (!SchedulerUtils.checkNodeLabelExpression(
+        labelManager.getLabelsOnNode(node.getNodeID()),
+        request.getNodeLabelExpression())) {
+      // this is a reserved container, but we cannot allocate it now according
+      // to label not match. This can be caused by node label changed
+      // We should un-reserve this container.
+      if (rmContainer != null) {
+        unreserve(application, priority, node, rmContainer);
+      }
+      return Resources.none();
+    }
+    
-          releaseResource(clusterResource,
-              application, container.getResource());
+          releaseResource(clusterResource, application,
+              container.getResource(),
+              labelManager.getLabelsOnNode(node.getNodeID()));
-  synchronized void allocateResource(Resource clusterResource, 
-      SchedulerApplicationAttempt application, Resource resource) {
-    // Update queue metrics
-    Resources.addTo(usedResources, resource);
-    CSQueueUtils.updateQueueStatistics(
-        resourceCalculator, this, getParent(), clusterResource, minimumAllocation);
-    ++numContainers;
-
+  synchronized void allocateResource(Resource clusterResource,
+      SchedulerApplicationAttempt application, Resource resource,
+      Set<String> nodeLabels) {
+    super.allocateResource(clusterResource, resource, nodeLabels);
+    
-    user.assignContainer(resource);
+    user.assignContainer(resource, nodeLabels);
+    // Note this is a bit unconventional since it gets the object and modifies
+    // it here, rather then using set routine
+    Resources.subtractFrom(application.getHeadroom(), resource); // headroom
-          " user-resources=" + user.getConsumedResources()
+          " user-resources=" + user.getTotalConsumedResources()
-      FiCaSchedulerApp application, Resource resource) {
-    // Update queue metrics
-    Resources.subtractFrom(usedResources, resource);
-    CSQueueUtils.updateQueueStatistics(
-        resourceCalculator, this, getParent(), clusterResource, 
-        minimumAllocation);
-    --numContainers;
-
+      FiCaSchedulerApp application, Resource resource, Set<String> nodeLabels) {
+    super.releaseResource(clusterResource, resource, nodeLabels);
+    
-    user.releaseContainer(resource);
+    user.releaseContainer(resource, nodeLabels);
-        " user=" + userName + " user-resources=" + user.getConsumedResources());
+        " user=" + userName + " user-resources=" + user.getTotalConsumedResources());
+    lastClusterResource = clusterResource;
+    
-            Resources.none());
+            Resources.none(), null);
-  
-  @Override
-  public QueueMetrics getMetrics() {
-    return metrics;
-  }
+    Map<String, Resource> consumedByLabel = new HashMap<String, Resource>();
-    public Resource getConsumedResources() {
+    public Resource getTotalConsumedResources() {
+    
+    public Resource getConsumedResourceByLabel(String label) {
+      Resource r = consumedByLabel.get(label);
+      if (null != r) {
+        return r;
+      }
+      return Resources.none();
+    }
-    public synchronized void assignContainer(Resource resource) {
+    public synchronized void assignContainer(Resource resource,
+        Set<String> nodeLabels) {
+      
+      if (nodeLabels == null || nodeLabels.isEmpty()) {
+        if (!consumedByLabel.containsKey(RMNodeLabelsManager.NO_LABEL)) {
+          consumedByLabel.put(RMNodeLabelsManager.NO_LABEL,
+              Resources.createResource(0));
+        }
+        Resources.addTo(consumedByLabel.get(RMNodeLabelsManager.NO_LABEL),
+            resource);
+      } else {
+        for (String label : nodeLabels) {
+          if (!consumedByLabel.containsKey(label)) {
+            consumedByLabel.put(label, Resources.createResource(0));
+          }
+          Resources.addTo(consumedByLabel.get(label), resource);
+        }
+      }
-    public synchronized void releaseContainer(Resource resource) {
+    public synchronized void releaseContainer(Resource resource, Set<String> nodeLabels) {
+      
+      // Update usedResources by labels
+      if (nodeLabels == null || nodeLabels.isEmpty()) {
+        if (!consumedByLabel.containsKey(RMNodeLabelsManager.NO_LABEL)) {
+          consumedByLabel.put(RMNodeLabelsManager.NO_LABEL,
+              Resources.createResource(0));
+        }
+        Resources.subtractFrom(
+            consumedByLabel.get(RMNodeLabelsManager.NO_LABEL), resource);
+      } else {
+        for (String label : nodeLabels) {
+          if (!consumedByLabel.containsKey(label)) {
+            consumedByLabel.put(label, Resources.createResource(0));
+          }
+          Resources.subtractFrom(consumedByLabel.get(label), resource);
+        }
+      }
-        .getResource());
+          .getResource(), labelManager.getLabelsOnNode(rmContainer
+          .getContainer().getNodeId()));
-          .getResource());
+          .getResource(), labelManager.getLabelsOnNode(rmContainer
+          .getContainer().getNodeId()));
-          .getResource());
+          .getResource(), labelManager.getLabelsOnNode(rmContainer.getContainer()
+          .getNodeId()));
+  @Override
+  public float getAbsActualCapacity() {
+    if (Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,
+        lastClusterResource, Resources.none())) {
+      return absoluteCapacity;
+    }
+
+    Resource resourceRespectLabels =
+        labelManager == null ? lastClusterResource : labelManager
+            .getQueueResource(queueName, accessibleLabels, lastClusterResource);
+    float absActualCapacity =
+        Resources.divide(resourceCalculator, lastClusterResource,
+            resourceRespectLabels, lastClusterResource);
+    
+    return absActualCapacity > absoluteCapacity ? absoluteCapacity
+        : absActualCapacity;
+  }
+  

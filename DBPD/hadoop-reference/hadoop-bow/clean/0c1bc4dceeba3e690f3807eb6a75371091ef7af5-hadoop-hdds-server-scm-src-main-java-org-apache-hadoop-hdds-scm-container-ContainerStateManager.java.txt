HDDS-981. Block allocation should involve pipeline selection and then container selection.
Contributed by Lokesh Jain.

+import org.apache.hadoop.hdds.scm.pipeline.PipelineID;
+  private final int numContainerPerOwnerInPipeline;
+    this.numContainerPerOwnerInPipeline = configuration
+        .getInt(ScmConfigKeys.OZONE_SCM_PIPELINE_OWNER_CONTAINER_COUNT,
+            ScmConfigKeys.OZONE_SCM_PIPELINE_OWNER_CONTAINER_COUNT_DEFAULT);
+      // TODO: #CLUTIL remove creation logic when all replication types and
+      // factors are handled by pipeline creator job.
+    return allocateContainer(pipelineManager, owner, pipeline);
+  }
-    Preconditions.checkNotNull(pipeline, "Pipeline type=%s/"
-        + "replication=%s couldn't be found for the new container. "
-        + "Do you have enough nodes?", type, replicationFactor);
+  /**
+   * Allocates a new container based on the type, replication etc.
+   *
+   * @param pipelineManager   - Pipeline Manager class.
+   * @param owner             - Owner of the container.
+   * @param pipeline          - Pipeline to which the container needs to be
+   *                          allocated.
+   * @return ContainerWithPipeline
+   * @throws IOException on Failure.
+   */
+  ContainerInfo allocateContainer(
+      final PipelineManager pipelineManager, final String owner,
+      Pipeline pipeline) throws IOException {
+    Preconditions.checkNotNull(pipeline,
+        "Pipeline couldn't be found for the new container. "
+            + "Do you have enough nodes?");
-        .setReplicationFactor(replicationFactor)
+        .setReplicationFactor(pipeline.getFactor())
-   * @param size - Space needed in the Container.
-   * @param owner - Owner of the container - A specific nameservice.
-   * @param type - Replication Type {StandAlone, Ratis}
-   * @param factor - Replication Factor {ONE, THREE}
-   * @param state - State of the Container-- {Open, Allocated etc.}
+   * @param size            - Space needed in the Container.
+   * @param owner           - Owner of the container - A specific nameservice.
+   * @param pipelineManager - Pipeline Manager
+   * @param pipeline        - Pipeline from which container needs to be matched
-  ContainerInfo getMatchingContainer(final long size,
-      String owner, ReplicationType type, ReplicationFactor factor,
-      LifeCycleState state) {
+  ContainerInfo getMatchingContainer(final long size, String owner,
+      PipelineManager pipelineManager, Pipeline pipeline) throws IOException {
-    // Find containers that match the query spec, if no match return null.
-    final NavigableSet<ContainerID> matchingSet =
-        containers.getMatchingContainerIDs(state, owner, factor, type);
-    if (matchingSet == null || matchingSet.size() == 0) {
+    NavigableSet<ContainerID> containerIDs =
+        pipelineManager.getContainersInPipeline(pipeline.getId());
+    if (containerIDs == null) {
+      LOG.error("Container list is null for pipeline=", pipeline.getId());
+      return null;
+    }
+
+    getContainers(containerIDs, owner);
+    if (containerIDs.size() < numContainerPerOwnerInPipeline) {
+      synchronized (pipeline) {
+        // TODO: #CLUTIL Maybe we can add selection logic inside synchronized
+        // as well
+        containerIDs = getContainers(
+            pipelineManager.getContainersInPipeline(pipeline.getId()), owner);
+        if (containerIDs.size() < numContainerPerOwnerInPipeline) {
+          ContainerInfo containerInfo =
+              allocateContainer(pipelineManager, owner, pipeline);
+          lastUsedMap.put(new ContainerState(owner, pipeline.getId()),
+              containerInfo.containerID());
+          return containerInfo;
+        }
+      }
+    }
+
+    ContainerInfo containerInfo =
+        getMatchingContainer(size, owner, pipeline.getId(), containerIDs);
+    if (containerInfo == null) {
+      synchronized (pipeline) {
+        containerInfo =
+            allocateContainer(pipelineManager, owner, pipeline);
+        lastUsedMap.put(new ContainerState(owner, pipeline.getId()),
+            containerInfo.containerID());
+      }
+    }
+    // TODO: #CLUTIL cleanup entries in lastUsedMap
+    return containerInfo;
+  }
+
+  /**
+   * Return a container matching the attributes specified.
+   *
+   * @param size         - Space needed in the Container.
+   * @param owner        - Owner of the container - A specific nameservice.
+   * @param pipelineID   - ID of the pipeline
+   * @param containerIDs - Set of containerIDs to choose from
+   * @return ContainerInfo, null if there is no match found.
+   */
+  ContainerInfo getMatchingContainer(final long size, String owner,
+      PipelineID pipelineID, NavigableSet<ContainerID> containerIDs) {
+    if (containerIDs.isEmpty()) {
-    final ContainerState key = new ContainerState(owner, type, factor);
-    final ContainerID lastID = lastUsedMap
-        .getOrDefault(key, matchingSet.first());
+    final ContainerState key = new ContainerState(owner, pipelineID);
+    final ContainerID lastID =
+        lastUsedMap.getOrDefault(key, containerIDs.first());
-    NavigableSet<ContainerID> resultSet = matchingSet.tailSet(lastID, false);
+    NavigableSet<ContainerID> resultSet = containerIDs.tailSet(lastID, false);
-      resultSet = matchingSet;
+      resultSet = containerIDs;
-        findContainerWithSpace(size, resultSet, owner);
+        findContainerWithSpace(size, resultSet, owner, pipelineID);
-      resultSet = matchingSet.headSet(lastID, true);
-      selectedContainer = findContainerWithSpace(size, resultSet, owner);
+      resultSet = containerIDs.headSet(lastID, true);
+      selectedContainer =
+          findContainerWithSpace(size, resultSet, owner, pipelineID);
-    return selectedContainer;
+    return selectedContainer;
-      final NavigableSet<ContainerID> searchSet, final String owner) {
+      final NavigableSet<ContainerID> searchSet, final String owner,
+      final PipelineID pipelineID) {
-          final ContainerState key = new ContainerState(owner,
-              containerInfo.getReplicationType(),
-              containerInfo.getReplicationFactor());
+          final ContainerState key = new ContainerState(owner, pipelineID);
+  private NavigableSet<ContainerID> getContainers(
+      NavigableSet<ContainerID> containerIDs, String owner) {
+    for (ContainerID cid : containerIDs) {
+      try {
+        if (!getContainer(cid).getOwner().equals(owner)) {
+          containerIDs.remove(cid);
+        }
+      } catch (ContainerNotFoundException e) {
+        LOG.error("Could not find container info for container id={} {}", cid,
+            e);
+        containerIDs.remove(cid);
+      }
+    }
+    return containerIDs;
+  }
+

YARN-6232. Update resource usage and preempted resource calculations to take into account all resource types. Contributed by Varun Vasudev.

+import java.util.HashMap;
+import java.util.Map;
+import org.apache.commons.lang.time.DateUtils;
+import org.apache.hadoop.yarn.api.records.ResourceInformation;
-  private AtomicLong finishedMemorySeconds = new AtomicLong(0);
-  private AtomicLong finishedVcoreSeconds = new AtomicLong(0);
-  private AtomicLong preemptedMemorySeconds = new AtomicLong(0);
-  private AtomicLong preemptedVcoreSeconds = new AtomicLong(0);
+  private Map<String, AtomicLong> resourceUsageMap = new HashMap<>();
+  private Map<String, AtomicLong> preemptedResourceMap = new HashMap<>();
-    return preemptedMemorySeconds.get();
+    return preemptedResourceMap.get(ResourceInformation.MEMORY_MB.getName())
+        .get();
-    return preemptedVcoreSeconds.get();
+    return preemptedResourceMap.get(ResourceInformation.VCORES.getName()).get();
+  }
+
+  public Map<String, Long> getPreemptedResourceSecondsMap() {
+    return convertAtomicLongMaptoLongMap(preemptedResourceMap);
-    long memorySeconds = finishedMemorySeconds.get();
-    long vcoreSeconds = finishedVcoreSeconds.get();
+    Map<String, Long> resourcesUsed =
+        convertAtomicLongMaptoLongMap(resourceUsageMap);
-    if (null != rmApp) {
-      RMAppAttempt currentAttempt = rmApp.getCurrentAppAttempt();
+    if (rmApp != null) {
+      RMAppAttempt currentAttempt = rmContext.getRMApps().get(attemptId.getApplicationId()).getCurrentAppAttempt();
-        ApplicationResourceUsageReport appResUsageReport = rmContext
-                .getScheduler().getAppResourceUsageReport(attemptId);
+        ApplicationResourceUsageReport appResUsageReport =
+            rmContext.getScheduler().getAppResourceUsageReport(attemptId);
-          memorySeconds += appResUsageReport.getMemorySeconds();
-          vcoreSeconds += appResUsageReport.getVcoreSeconds();
+          Map<String, Long> tmp = appResUsageReport.getResourceSecondsMap();
+          for (Map.Entry<String, Long> entry : tmp.entrySet()) {
+            if (resourcesUsed.containsKey(entry.getKey())) {
+              Long value = resourcesUsed.get(entry.getKey());
+              value += entry.getValue();
+              resourcesUsed.put(entry.getKey(), value);
+            } else{
+              resourcesUsed.put(entry.getKey(), entry.getValue());
+            }
+          }
-    return new AggregateAppResourceUsage(memorySeconds, vcoreSeconds);
+    return new AggregateAppResourceUsage(resourcesUsed);
-  public void updateAggregateAppResourceUsage(long finishedMemorySeconds,
-                                        long finishedVcoreSeconds) {
-    this.finishedMemorySeconds.addAndGet(finishedMemorySeconds);
-    this.finishedVcoreSeconds.addAndGet(finishedVcoreSeconds);
+  public void updateAggregateAppResourceUsage(Resource allocated,
+      long deltaUsedMillis) {
+    updateUsageMap(allocated, deltaUsedMillis, resourceUsageMap);
+  }
+
+  public void updateAggregatePreemptedAppResourceUsage(Resource allocated,
+      long deltaUsedMillis) {
+    updateUsageMap(allocated, deltaUsedMillis, preemptedResourceMap);
+  }
+
+  public void updateAggregateAppResourceUsage(
+      Map<String, Long> resourceSecondsMap) {
+    updateUsageMap(resourceSecondsMap, resourceUsageMap);
-      long preemptedMemorySeconds, long preemptedVcoreSeconds) {
-    this.preemptedMemorySeconds.addAndGet(preemptedMemorySeconds);
-    this.preemptedVcoreSeconds.addAndGet(preemptedVcoreSeconds);
+      Map<String, Long> preemptedResourceSecondsMap) {
+    updateUsageMap(preemptedResourceSecondsMap, preemptedResourceMap);
+  }
+
+  private void updateUsageMap(Resource allocated, long deltaUsedMillis,
+      Map<String, AtomicLong> targetMap) {
+    for (Map.Entry<String, ResourceInformation> entry : allocated.getResources()
+        .entrySet()) {
+      AtomicLong resourceUsed;
+      if (!targetMap.containsKey(entry.getKey())) {
+        resourceUsed = new AtomicLong(0);
+        targetMap.put(entry.getKey(), resourceUsed);
+
+      }
+      resourceUsed = targetMap.get(entry.getKey());
+      resourceUsed.addAndGet((entry.getValue().getValue() * deltaUsedMillis)
+          / DateUtils.MILLIS_PER_SECOND);
+    }
+  }
+
+  private void updateUsageMap(Map<String, Long> sourceMap,
+      Map<String, AtomicLong> targetMap) {
+    for (Map.Entry<String, Long> entry : sourceMap.entrySet()) {
+      AtomicLong resourceUsed;
+      if (!targetMap.containsKey(entry.getKey())) {
+        resourceUsed = new AtomicLong(0);
+        targetMap.put(entry.getKey(), resourceUsed);
+
+      }
+      resourceUsed = targetMap.get(entry.getKey());
+      resourceUsed.set(entry.getValue());
+    }
+  }
+
+  private Map<String, Long> convertAtomicLongMaptoLongMap(
+      Map<String, AtomicLong> source) {
+    Map<String, Long> ret = new HashMap<>();
+    for (Map.Entry<String, AtomicLong> entry : source.entrySet()) {
+      ret.put(entry.getKey(), entry.getValue().get());
+    }
+    return ret;

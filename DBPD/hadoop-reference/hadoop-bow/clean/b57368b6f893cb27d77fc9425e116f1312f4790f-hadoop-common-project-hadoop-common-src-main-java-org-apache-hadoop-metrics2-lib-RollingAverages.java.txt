HDFS-11194. Maintain aggregated peer performance metrics on NameNode.

+import java.util.HashMap;
+
+import javax.annotation.Nullable;
+
+
+  @Nullable
+
-   * @param windowSize
-   *          The number of seconds of each window for which sub set of samples
-   *          are gathered to compute the rolling average, A.K.A. roll over
-   *          interval.
+   * @param windowSizeMs
+   *          The number of milliseconds of each window for which subset
+   *          of samples are gathered to compute the rolling average, A.K.A.
+   *          roll over interval.
-      final int windowSize,
+      final long windowSizeMs,
-    avgInfoNameTemplate = "%s" + "RollingAvg"+ uvName;
+    avgInfoNameTemplate = "[%s]" + "RollingAvg"+ uvName;
-        windowSize, windowSize, TimeUnit.SECONDS);
+        windowSizeMs, windowSizeMs, TimeUnit.MILLISECONDS);
-   * @param windowSize
+   * @param windowSizeMs
-      final int windowSize,
+      final long windowSizeMs,
-    this(windowSize, numWindows, "Time");
+    this(windowSizeMs, numWindows, "Time");
-  private void rollOverAvgs() {
+  private synchronized void rollOverAvgs() {
+
+  /**
+   * Retrieve a map of metric name -> (aggregate).
+   * Filter out entries that don't have at least minSamples.
+   *
+   * @return a map of peer DataNode Id to the average latency to that
+   *         node seen over the measurement period.
+   */
+  public synchronized Map<String, Double> getStats(long minSamples) {
+    final Map<String, Double> stats = new HashMap<>();
+
+    for (final Entry<String, LinkedBlockingDeque<SumAndCount>> entry
+        : averages.entrySet()) {
+      final String name = entry.getKey();
+      double totalSum = 0;
+      long totalCount = 0;
+
+      for (final SumAndCount sumAndCount : entry.getValue()) {
+        totalCount += sumAndCount.getCount();
+        totalSum += sumAndCount.getSum();
+      }
+
+      if (totalCount > minSamples) {
+        stats.put(name, totalSum / totalCount);
+      }
+    }
+    return stats;
+  }

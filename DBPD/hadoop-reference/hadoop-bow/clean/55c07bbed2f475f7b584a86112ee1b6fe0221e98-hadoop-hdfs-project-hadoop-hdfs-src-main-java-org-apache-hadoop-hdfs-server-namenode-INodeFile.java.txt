HDFS-11382. Persist Erasure Coding Policy ID in a new optional field in INodeFile in FSImage. Contributed by Manoj Govindassamy.

+  /**
+   * Erasure Coded striped blocks have replication factor of 1.
+   */
+  public static final short DEFAULT_REPL_FOR_STRIPED_BLOCKS = 1;
+
-
-      long layoutRedundancy = BLOCK_LAYOUT_AND_REDUNDANCY.BITS.retrieve(header);
-      return (short) (layoutRedundancy & MAX_REDUNDANCY);
+      if (isStriped(header)) {
+        return DEFAULT_REPL_FOR_STRIPED_BLOCKS;
+      } else {
+        long layoutRedundancy =
+            BLOCK_LAYOUT_AND_REDUNDANCY.BITS.retrieve(header);
+        return (short) (layoutRedundancy & MAX_REDUNDANCY);
+      }
-      long layoutRedundancy = BLOCK_LAYOUT_AND_REDUNDANCY.BITS.retrieve(header);
-      return (layoutRedundancy & BLOCK_TYPE_MASK) != 0;
+      return getBlockType(header) == STRIPED;
-    static long toLong(long preferredBlockSize, short replication,
-        BlockType blockType, byte storagePolicyID) {
-      Preconditions.checkArgument(replication >= 0 &&
-          replication <= MAX_REDUNDANCY);
+    /**
+     * Construct block layout redundancy based on the given BlockType,
+     * replication factor and EC PolicyID.
+     */
+    static long getBlockLayoutRedundancy(final BlockType blockType,
+        final Short replication, final Byte erasureCodingPolicyID) {
+      long layoutRedundancy = 0;
+      if (blockType == STRIPED) {
+        Preconditions.checkArgument(replication == null &&
+            erasureCodingPolicyID != null);
+        Preconditions.checkArgument(
+            ErasureCodingPolicyManager.getPolicyByPolicyID(
+                erasureCodingPolicyID) != null);
+        layoutRedundancy |= BLOCK_TYPE_MASK_STRIPED;
+        // Following bitwise OR with signed byte erasureCodingPolicyID is safe
+        // as the PolicyID can never be in negative.
+        layoutRedundancy |= erasureCodingPolicyID;
+      } else {
+        Preconditions.checkArgument(replication != null &&
+            erasureCodingPolicyID == null);
+        Preconditions.checkArgument(replication >= 0 &&
+            replication <= MAX_REDUNDANCY);
+        layoutRedundancy |= replication;
+      }
+      return layoutRedundancy;
+    }
+
+    static long toLong(long preferredBlockSize, long layoutRedundancy,
+        byte storagePolicyID) {
-      // For erasure coded files, replication is used to store ec policy id
-      // TODO: this is hacky. Add some utility to generate the layoutRedundancy
-      long layoutRedundancy = 0;
-      if (blockType == STRIPED) {
-        layoutRedundancy |= BLOCK_TYPE_MASK_STRIPED;
-      }
-      layoutRedundancy |= replication;
-    this(id, name, permissions, mtime, atime, blklist, replication,
+    this(id, name, permissions, mtime, atime, blklist, replication, null,
-      long atime, BlockInfo[] blklist, short replication,
+      long atime, BlockInfo[] blklist, Short replication, Byte ecPolicyID,
-    header = HeaderFormat.toLong(preferredBlockSize, replication, blockType,
+    final long layoutRedundancy = HeaderFormat.getBlockLayoutRedundancy(
+        blockType, replication, ecPolicyID);
+    header = HeaderFormat.toLong(preferredBlockSize, layoutRedundancy,
+    if (isStriped()) {
+      return DEFAULT_REPL_FOR_STRIPED_BLOCKS;
+    }

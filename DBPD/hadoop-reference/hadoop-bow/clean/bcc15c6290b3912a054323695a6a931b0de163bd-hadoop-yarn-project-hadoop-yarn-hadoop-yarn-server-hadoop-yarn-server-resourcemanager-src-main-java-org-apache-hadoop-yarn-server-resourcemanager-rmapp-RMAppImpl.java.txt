YARN-5611. Provide an API to update lifetime of an application. Contributed by Rohith Sharma K S

+  private static final EnumSet<RMAppState> COMPLETED_APP_STATES =
+      EnumSet.of(RMAppState.FINISHED, RMAppState.FINISHING, RMAppState.FAILED,
+          RMAppState.KILLED, RMAppState.FINAL_SAVING, RMAppState.KILLING);
+  private Map<ApplicationTimeoutType, Long> applicationTimeouts =
+      new HashMap<ApplicationTimeoutType, Long>();
+    this.applicationTimeouts = appState.getApplicationTimeouts();
-      long applicationLifetime =
-          app.getApplicationLifetime(ApplicationTimeoutType.LIFETIME);
-      if (applicationLifetime > 0) {
+      for (Map.Entry<ApplicationTimeoutType, Long> timeout :
+        app.applicationTimeouts.entrySet()) {
-            ApplicationTimeoutType.LIFETIME, app.submitTime,
-            applicationLifetime * 1000);
+            timeout.getKey(), timeout.getValue());
+          long remainingTime = timeout.getValue() - app.systemClock.getTime();
-              + " is registered for timeout monitor, type="
-              + ApplicationTimeoutType.LIFETIME + " value="
-              + applicationLifetime + " seconds");
+              + " is registered for timeout monitor, type=" + timeout.getKey()
+              + " remaining timeout="
+              + (remainingTime > 0 ? remainingTime / 1000 : 0) + " seconds");
+        // calculate next timeout value
+        Long newTimeout =
+            Long.valueOf(app.submitTime + (applicationLifetime * 1000));
-            ApplicationTimeoutType.LIFETIME, app.submitTime,
-            applicationLifetime * 1000);
-        LOG.debug("Application " + app.applicationId
+            ApplicationTimeoutType.LIFETIME, newTimeout);
+
+        // update applicationTimeouts with new absolute value.
+        app.applicationTimeouts.put(ApplicationTimeoutType.LIFETIME,
+            newTimeout);
+
+        LOG.info("Application " + app.applicationId
+    appState.setApplicationTimeouts(this.applicationTimeouts);
-}
+
+  @Override
+  public Map<ApplicationTimeoutType, Long> getApplicationTimeouts() {
+    this.readLock.lock();
+    try {
+      return new HashMap(this.applicationTimeouts);
+    } finally {
+      this.readLock.unlock();
+    }
+  }
+
+  public void updateApplicationTimeout(
+      Map<ApplicationTimeoutType, Long> updateTimeout) {
+    this.writeLock.lock();
+    try {
+      if (COMPLETED_APP_STATES.contains(getState())) {
+        return;
+      }
+      // update monitoring service
+      this.rmContext.getRMAppLifetimeMonitor()
+          .updateApplicationTimeouts(getApplicationId(), updateTimeout);
+      this.applicationTimeouts.putAll(updateTimeout);
+
+    } finally {
+      this.writeLock.unlock();
+    }
+  }
+}

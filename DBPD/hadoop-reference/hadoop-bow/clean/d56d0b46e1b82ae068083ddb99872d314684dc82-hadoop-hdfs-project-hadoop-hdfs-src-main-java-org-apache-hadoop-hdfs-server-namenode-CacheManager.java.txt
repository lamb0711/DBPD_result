commit correct version of HDFS-5121

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520090 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Iterator;
+import java.util.Map;
-import java.util.Map.Entry;
-import org.apache.hadoop.hdfs.protocol.AlreadyBeingCreatedException;
+import org.apache.hadoop.fs.permission.FsAction;
+import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.InvalidPoolError;
+import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.PoolWritePermissionDeniedError;
+import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.UnexpectedAddPathCacheDirectiveException;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.InvalidPoolNameError;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.UnexpectedAddPathCacheDirectiveException;
-import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.PoolWritePermissionDeniedError;
-import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.UnexpectedRemovePathCacheEntryException;
+import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.UnexpectedRemovePathCacheEntryException;
-  private final TreeMap<String, CachePool> cachePools =
+  private final TreeMap<String, CachePool> cachePoolsByName =
+   * Cache pools, sorted by ID
+   */
+  private final TreeMap<Long, CachePool> cachePoolsById =
+      new TreeMap<Long, CachePool>();
+
+  /**
+  /**
+   * The pool ID to use for a new pool.
+   */
+  private long nextPoolId;
+
+    cachePoolsByName.clear();
+    cachePoolsById.clear();
+    nextPoolId = 1;
-      throw new IOException("no more available IDs");
+      throw new IOException("no more available entry IDs");
+  synchronized long getNextPoolId() throws IOException {
+    if (nextPoolId == Long.MAX_VALUE) {
+      throw new IOException("no more available pool IDs");
+    }
+    return nextPoolId++;
+  }
+
-        PathCacheDirective directive, FSPermissionChecker pc) {
-    CachePool pool = cachePools.get(directive.getPool());
+        FSPermissionChecker pc, PathCacheDirective directive) {
+    CachePool pool = cachePoolsById.get(directive.getPoolId());
-          new InvalidPoolNameError(directive));
+          new InvalidPoolError(directive));
-    if (!pc.checkWritePermission(pool.getOwnerName(),
-        pool.getGroupName(), pool.getMode())) {
+    if (!pc.checkPermission(pool, FsAction.WRITE)) {
-      List<PathCacheDirective> directives, FSPermissionChecker pc) {
+      FSPermissionChecker pc, List<PathCacheDirective> directives) {
-      results.add(addDirective(directive, pc));
+      results.add(addDirective(pc, directive));
-  private synchronized Fallible<Long> removeEntry(long entryId,
-        FSPermissionChecker pc) {
+  private synchronized Fallible<Long> removeEntry(FSPermissionChecker pc,
+        long entryId) {
-    CachePool pool = cachePools.get(existing.getDirective().getPool());
+    CachePool pool = cachePoolsById.get(existing.getDirective().getPoolId());
-    if (!pc.isSuperUser()) {
-      if (!pc.checkWritePermission(pool.getOwnerName(),
-          pool.getGroupName(), pool.getMode())) {
-        LOG.info("removeEntry " + entryId + ": write permission denied to " +
-            "pool " + pool + " for entry " + existing);
-        return new Fallible<Long>(
-            new RemovePermissionDeniedException(entryId));
-      }
+    if (!pc.checkPermission(pool, FsAction.WRITE)) {
+      LOG.info("removeEntry " + entryId + ": write permission denied to " +
+          "pool " + pool + " for entry " + existing);
+      return new Fallible<Long>(
+          new RemovePermissionDeniedException(entryId));
-    
+
-  public synchronized List<Fallible<Long>> removeEntries(List<Long> entryIds,
-      FSPermissionChecker pc) {
+  public synchronized List<Fallible<Long>> removeEntries(FSPermissionChecker pc,
+      List<Long> entryIds) {
-      results.add(removeEntry(entryId, pc));
+      results.add(removeEntry(pc, entryId));
-  public synchronized List<PathCacheEntry> listPathCacheEntries(long prevId,
-      String pool, int maxReplies) {
+  public synchronized List<PathCacheEntry> listPathCacheEntries(
+      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {
-    ArrayList<PathCacheEntry> replies =
-        new ArrayList<PathCacheEntry>(Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));
+    ArrayList<PathCacheEntry> replies = new ArrayList<PathCacheEntry>(
+        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));
-    for (Entry<Long, PathCacheEntry> cur : tailMap.entrySet()) {
+    for (PathCacheEntry entry : tailMap.values()) {
-      if (pool.isEmpty() || cur.getValue().getDirective().
-            getPool().equals(pool)) {
-        replies.add(cur.getValue());
-        numReplies++;
+      long entryPoolId = entry.getDirective().getPoolId();
+      if (poolId == null || poolId <= 0 || entryPoolId == poolId) {
+        if (pc.checkPermission(
+            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {
+          replies.add(entry);
+          numReplies++;
+        }
+  synchronized CachePool getCachePool(long id) {
+    return cachePoolsById.get(id);
+  }
+
+   * @return created CachePool
-  public synchronized void addCachePool(CachePoolInfo info)
+  public synchronized CachePool addCachePool(CachePoolInfo info)
-    if (poolName.isEmpty()) {
+    if (poolName == null || poolName.isEmpty()) {
-    CachePool pool = cachePools.get(poolName);
-    if (pool != null) {
+    if (cachePoolsByName.containsKey(poolName)) {
-    CachePool cachePool = new CachePool(poolName,
+    CachePool cachePool = new CachePool(getNextPoolId(), poolName,
-    cachePools.put(poolName, cachePool);
+    cachePoolsById.put(cachePool.getId(), cachePool);
+    cachePoolsByName.put(poolName, cachePool);
+    return cachePool;
-  public synchronized void modifyCachePool(CachePoolInfo info)
+  public synchronized void modifyCachePool(long poolId, CachePoolInfo info)
-    String poolName = info.getPoolName();
-    if (poolName.isEmpty()) {
-      throw new IOException("invalid empty cache pool name");
+    if (poolId <= 0) {
+      throw new IOException("invalid pool id " + poolId);
-    CachePool pool = cachePools.get(poolName);
-    if (pool == null) {
-      throw new IOException("cache pool " + poolName + " does not exist.");
+    if (!cachePoolsById.containsKey(poolId)) {
+      throw new IOException("cache pool id " + poolId + " does not exist.");
+    CachePool pool = cachePoolsById.get(poolId);
+    // Remove the old CachePoolInfo
+    removeCachePool(poolId);
+    // Build up the new CachePoolInfo
+    CachePoolInfo.Builder newInfo = CachePoolInfo.newBuilder(pool.getInfo());
+    if (info.getPoolName() != null) {
+      newInfo.setPoolName(info.getPoolName());
+      bld.append(prefix).
+      append("set name to ").append(info.getOwnerName());
+      prefix = "; ";
+    }
-      pool.setOwnerName(info.getOwnerName());
+      newInfo.setOwnerName(info.getOwnerName());
-      pool.setGroupName(info.getGroupName());
+      newInfo.setGroupName(info.getGroupName());
-      pool.setMode(info.getMode());
+      newInfo.setMode(info.getMode());
-        append(String.format("set mode to 0%3o", info.getMode()));
+        append(String.format("set mode to ", info.getMode()));
-      pool.setWeight(info.getWeight());
+      newInfo.setWeight(info.getWeight());
+    } else {
+      pool.setInfo(newInfo.build());
-    LOG.info("modified " + poolName + "; " + bld.toString());
+    // Put the newly modified info back in
+    cachePoolsById.put(poolId, pool);
+    cachePoolsByName.put(info.getPoolName(), pool);
+    LOG.info("modified pool id " + pool.getId()
+        + " (" + pool.getInfo().getPoolName() + "); "
+        + bld.toString());
-   * @param poolName
-   *          The name for the cache pool to remove.
+   * @param poolId
+   *          The id of the cache pool to remove.
-  public synchronized void removeCachePool(String poolName)
-      throws IOException {
-    CachePool pool = cachePools.remove(poolName);
-    if (pool == null) {
-      throw new IOException("can't remove nonexistent cache pool " + poolName);
+  public synchronized void removeCachePool(long poolId) throws IOException {
+    if (!cachePoolsById.containsKey(poolId)) {
+      throw new IOException("can't remove nonexistent cache pool id " + poolId);
+    // Remove all the entries associated with the pool
+    Iterator<Map.Entry<Long, PathCacheEntry>> it =
+        entriesById.entrySet().iterator();
+    while (it.hasNext()) {
+      Map.Entry<Long, PathCacheEntry> entry = it.next();
+      if (entry.getValue().getDirective().getPoolId() == poolId) {
+        it.remove();
+        entriesByDirective.remove(entry.getValue().getDirective());
+      }
+    }
+    // Remove the pool
+    CachePool pool = cachePoolsById.remove(poolId);
+    cachePoolsByName.remove(pool.getInfo().getPoolName());
-  public synchronized List<CachePoolInfo>
-      listCachePools(FSPermissionChecker pc, String prevKey,
-          int maxRepliesPerRequest) {
+  public synchronized List<CachePool> listCachePools(Long prevKey,
+      int maxRepliesPerRequest) {
-    ArrayList<CachePoolInfo> results = 
-        new ArrayList<CachePoolInfo>(Math.min(MAX_PREALLOCATED_REPLIES,
+    ArrayList<CachePool> results = 
+        new ArrayList<CachePool>(Math.min(MAX_PREALLOCATED_REPLIES,
-    SortedMap<String, CachePool> tailMap = cachePools.tailMap(prevKey, false);
-    for (Entry<String, CachePool> cur : tailMap.entrySet()) {
-      results.add(cur.getValue().getInfo(pc));
+    SortedMap<Long, CachePool> tailMap =
+        cachePoolsById.tailMap(prevKey, false);
+    for (CachePool pool : tailMap.values()) {
+      results.add(pool);

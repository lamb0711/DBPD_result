YARN-6871. Add additional deSelects params in RMWebServices#getAppReport. Contributed by Tanuj Nayak.

-  protected AppTimeoutsInfo timeouts = new AppTimeoutsInfo();
+  private AppTimeoutsInfo timeouts;
-      amNodeLabelExpression = (unmanagedApplication) ? null
-          : app.getAMResourceRequests().get(0).getNodeLabelExpression();
+      /*
+       * When the deSelects parameter contains "amNodeLabelExpression", objects
+       * pertaining to the amNodeLabelExpression are not returned. By default,
+       * this is not skipped. (YARN-6871)
+       */
+      if(!deSelects.contains(DeSelectType.AM_NODE_LABEL_EXPRESSION)) {
+        amNodeLabelExpression = (unmanagedApplication) ?
+            null :
+            app.getAMResourceRequests().get(0).getNodeLabelExpression();
+      }
+      /*
+       * When the deSelects parameter contains "appNodeLabelExpression", objects
+       * pertaining to the appNodeLabelExpression are not returned. By default,
+       * this is not skipped. (YARN-6871)
+       */
+      if (!deSelects.contains(DeSelectType.APP_NODE_LABEL_EXPRESSION)) {
+        appNodeLabelExpression =
+            app.getApplicationSubmissionContext().getNodeLabelExpression();
+      }
+      /*
+       * When the deSelects parameter contains "amNodeLabelExpression", objects
+       * pertaining to the amNodeLabelExpression are not returned. By default,
+       * this is not skipped. (YARN-6871)
+       */
+      if (!deSelects.contains(DeSelectType.AM_NODE_LABEL_EXPRESSION)) {
+        amNodeLabelExpression = (unmanagedApplication) ?
+            null :
+            app.getAMResourceRequests().get(0).getNodeLabelExpression();
+      }
+      /*
+       * When the deSelects parameter contains "resourceInfo", ResourceInfo
+       * objects are not returned. Default behavior is no skipping. (YARN-6871)
+       */
-      ResourceScheduler scheduler = rm.getRMContext().getScheduler();
-      if (scheduler instanceof CapacityScheduler) {
-        RMAppAttempt attempt = app.getCurrentAppAttempt();
-        if (null != attempt) {
-          FiCaSchedulerApp ficaAppAttempt = ((CapacityScheduler) scheduler)
-              .getApplicationAttempt(attempt.getAppAttemptId());
-          resourceInfo = null != ficaAppAttempt
-              ? new ResourcesInfo(ficaAppAttempt.getSchedulingResourceUsage())
-              : null;
-        }
-      }
-
-      Map<ApplicationTimeoutType, Long> applicationTimeouts =
-          app.getApplicationTimeouts();
-      if (applicationTimeouts.isEmpty()) {
-        // If application is not set timeout, lifetime should be sent as default
-        // with expiryTime=UNLIMITED and remainingTime=-1
-        AppTimeoutInfo timeoutInfo = new AppTimeoutInfo();
-        timeoutInfo.setTimeoutType(ApplicationTimeoutType.LIFETIME);
-        timeouts.add(timeoutInfo);
-      } else {
-        for (Map.Entry<ApplicationTimeoutType, Long> entry : app
-            .getApplicationTimeouts().entrySet()) {
-          AppTimeoutInfo timeout = new AppTimeoutInfo();
-          timeout.setTimeoutType(entry.getKey());
-          long timeoutInMillis = entry.getValue().longValue();
-          timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));
-          if (app.isAppInCompletedStates()) {
-            timeout.setRemainingTime(0);
-          } else {
-            timeout.setRemainingTime(Math
-                .max((timeoutInMillis - System.currentTimeMillis()) / 1000, 0));
+      if (!deSelects.contains(DeSelectType.RESOURCE_INFO)) {
+        ResourceScheduler scheduler = rm.getRMContext().getScheduler();
+        if (scheduler instanceof CapacityScheduler) {
+          RMAppAttempt attempt = app.getCurrentAppAttempt();
+          if (null != attempt) {
+            FiCaSchedulerApp ficaAppAttempt = ((CapacityScheduler) scheduler)
+                .getApplicationAttempt(attempt.getAppAttemptId());
+            resourceInfo = null != ficaAppAttempt ?
+                new ResourcesInfo(ficaAppAttempt.getSchedulingResourceUsage()) :
+                null;
-          timeouts.add(timeout);
+      /*
+       * When the deSelects parameter contains "appTimeouts", objects pertaining
+       * to app timeouts are not returned. By default, this is not skipped.
+       * (YARN-6871)
+       */
+      if (!deSelects.contains(DeSelectType.TIMEOUTS)) {
+        Map<ApplicationTimeoutType, Long> applicationTimeouts =
+            app.getApplicationTimeouts();
+        if (applicationTimeouts.isEmpty()) {
+          // If application is not set timeout, lifetime should be sent
+          // as default with expiryTime=UNLIMITED and remainingTime=-1
+          AppTimeoutInfo timeoutInfo = new AppTimeoutInfo();
+          timeoutInfo.setTimeoutType(ApplicationTimeoutType.LIFETIME);
+          timeouts = new AppTimeoutsInfo();
+          timeouts.add(timeoutInfo);
+        } else {
+          for (Map.Entry<ApplicationTimeoutType, Long> entry : app
+              .getApplicationTimeouts().entrySet()) {
+            AppTimeoutInfo timeout = new AppTimeoutInfo();
+            timeout.setTimeoutType(entry.getKey());
+            long timeoutInMillis = entry.getValue().longValue();
+            timeout.setExpiryTime(Times.formatISO8601(timeoutInMillis));
+            if (app.isAppInCompletedStates()) {
+              timeout.setRemainingTime(0);
+            } else {
+              timeout.setRemainingTime(Math.max(
+                  (timeoutInMillis - System.currentTimeMillis()) / 1000, 0));
+            }
+            timeouts.add(timeout);
+          }
+        }
+      }

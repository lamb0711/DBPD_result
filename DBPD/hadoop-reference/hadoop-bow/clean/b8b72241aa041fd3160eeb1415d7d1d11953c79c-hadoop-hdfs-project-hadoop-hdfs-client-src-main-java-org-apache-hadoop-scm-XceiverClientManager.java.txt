HDFS-11036. Ozone: reuse Xceiver connection. Contributed by Chen Liang.

+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.RemovalListener;
+import com.google.common.cache.RemovalNotification;
+import static org.apache.hadoop.scm.ScmConfigKeys.SCM_CONTAINER_CLIENT_STALE_THRESHOLD_DEFAULT;
+import static org.apache.hadoop.scm.ScmConfigKeys.SCM_CONTAINER_CLIENT_STALE_THRESHOLD_KEY;
+
- * This class may evolve to implement efficient lifecycle management policies by
- * caching container location information and pooling connected client instances
- * for reuse without needing to reestablish a socket connection.  The current
- * implementation simply allocates and closes a new instance every time.
+ *
+ * This class caches connection to container for reuse purpose, such that
+ * accessing same container frequently will be through the same connection
+ * without reestablishing connection. But the connection will be closed if
+ * not being used for a period of time.
+  private Cache<String, XceiverClientWithAccessInfo> openClient;
+  private final long staleThresholdMs;
+    this.staleThresholdMs = conf.getTimeDuration(
+        SCM_CONTAINER_CLIENT_STALE_THRESHOLD_KEY,
+        SCM_CONTAINER_CLIENT_STALE_THRESHOLD_DEFAULT, TimeUnit.MILLISECONDS);
+    this.openClient = CacheBuilder.newBuilder()
+        .expireAfterAccess(this.staleThresholdMs, TimeUnit.MILLISECONDS)
+        .removalListener(
+            new RemovalListener<String, XceiverClientWithAccessInfo>() {
+            @Override
+            public void onRemoval(
+                RemovalNotification<String, XceiverClientWithAccessInfo>
+                  removalNotification) {
+              // If the reference count is not 0, this xceiver client should not
+              // be evicted, add it back to the cache.
+              XceiverClientWithAccessInfo info = removalNotification.getValue();
+              if (info.hasRefence()) {
+                synchronized (XceiverClientManager.this.openClient) {
+                  XceiverClientManager.this
+                      .openClient.put(removalNotification.getKey(), info);
+                }
+              }
+            }
+          }).build();
+   * If there is already a cached XceiverClient, simply return the cached
+   * otherwise create a new one.
+   *
-    XceiverClient xceiverClient = new XceiverClient(pipeline, conf);
-    try {
-      xceiverClient.connect();
-    } catch (Exception e) {
-      throw new IOException("Exception connecting XceiverClient.", e);
+    String containerName = pipeline.getContainerName();
+    XceiverClientWithAccessInfo info = openClient.getIfPresent(containerName);
+
+    if (info != null) {
+      // we do have this connection, add reference and return
+      info.incrementReference();
+      return info.getXceiverClient();
+    } else {
+      // connection not found, create new, add reference and return
+      XceiverClient xceiverClient = new XceiverClient(pipeline, conf);
+      try {
+        xceiverClient.connect();
+      } catch (Exception e) {
+        throw new IOException("Exception connecting XceiverClient.", e);
+      }
+      info = new XceiverClientWithAccessInfo(xceiverClient);
+      info.incrementReference();
+      synchronized (openClient) {
+        openClient.put(containerName, info);
+      }
+      return xceiverClient;
-    return xceiverClient;
-    xceiverClient.close();
+    String containerName = xceiverClient.getPipeline().getContainerName();
+    XceiverClientWithAccessInfo info;
+    synchronized (openClient) {
+      info = openClient.getIfPresent(containerName);
+    }
+    Preconditions.checkNotNull(info);
+    info.decrementReference();
+  }
+
+  /**
+   * A helper class for caching and cleaning XceiverClient. Three parameters:
+   * - the actual XceiverClient object
+   * - a time stamp representing the most recent access (acquire or release)
+   * - a reference count, +1 when acquire, -1 when release
+   */
+  private static class XceiverClientWithAccessInfo {
+    final private XceiverClient xceiverClient;
+    final private AtomicInteger referenceCount;
+
+    XceiverClientWithAccessInfo(XceiverClient xceiverClient) {
+      this.xceiverClient = xceiverClient;
+      this.referenceCount = new AtomicInteger(0);
+    }
+
+    void incrementReference() {
+      this.referenceCount.incrementAndGet();
+    }
+
+    void decrementReference() {
+      this.referenceCount.decrementAndGet();
+    }
+
+    boolean hasRefence() {
+      return this.referenceCount.get() != 0;
+    }
+
+    XceiverClient getXceiverClient() {
+      return xceiverClient;
+    }

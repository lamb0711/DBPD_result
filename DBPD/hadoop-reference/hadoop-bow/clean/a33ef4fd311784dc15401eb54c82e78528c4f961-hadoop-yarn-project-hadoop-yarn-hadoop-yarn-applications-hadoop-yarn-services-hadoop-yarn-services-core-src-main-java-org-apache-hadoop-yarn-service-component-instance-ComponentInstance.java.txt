YARN-8867. Added resource localization status to YARN service status call.
           Contributed by Chandni Singh

+import org.apache.hadoop.yarn.api.records.LocalizationState;
+import org.apache.hadoop.yarn.service.api.records.LocalizationStatus;
+import org.apache.hadoop.yarn.service.provider.ProviderService;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+  private ProviderService.ResolvedLaunchParams resolvedParams;
+  private ScheduledFuture lclizationRetrieverFuture;
+      compInstance.initializeLocalizationStatusRetriever(
+          event.getContainerId());
+
+      instance.initializeLocalizationStatusRetriever(event.getContainerId());
+    try {
+      List<org.apache.hadoop.yarn.api.records.LocalizationStatus>
+          statusesFromNM = scheduler.getNmClient().getClient()
+          .getLocalizationStatuses(container.getId(), container.getNodeId());
+      if (statusesFromNM != null && !statusesFromNM.isEmpty()) {
+        updateLocalizationStatuses(statusesFromNM);
+      }
+    } catch (YarnException | IOException e) {
+      LOG.warn("{} failure getting localization statuses", container.getId(),
+          e);
+    }
+      compInstance.cancelLclRetriever();
+    cancelLclRetriever();
-    scheduler.getContainerLaunchService()
+    Future<ProviderService.ResolvedLaunchParams> launchParamsFuture =
+        scheduler.getContainerLaunchService()
+    updateResolvedLaunchParams(launchParamsFuture);
+  @VisibleForTesting
+  void updateLocalizationStatuses(
+      List<org.apache.hadoop.yarn.api.records.LocalizationStatus> statuses) {
+    Map<String, String> resourcesCpy = new HashMap<>();
+    try {
+      readLock.lock();
+      if (resolvedParams == null || resolvedParams.didLaunchFail() ||
+          resolvedParams.getResolvedRsrcPaths() == null ||
+          resolvedParams.getResolvedRsrcPaths().isEmpty()) {
+        cancelLclRetriever();
+        return;
+      }
+      resourcesCpy.putAll(resolvedParams.getResolvedRsrcPaths());
+    } finally {
+      readLock.unlock();
+    }
+    boolean allCompleted = true;
+    Map<String, LocalizationStatus> fromNM = new HashMap<>();
+    statuses.forEach(statusFromNM -> {
+      LocalizationStatus lstatus = new LocalizationStatus()
+          .destFile(statusFromNM.getResourceKey())
+          .diagnostics(statusFromNM.getDiagnostics())
+          .state(statusFromNM.getLocalizationState());
+      fromNM.put(statusFromNM.getResourceKey(), lstatus);
+    });
+
+    for (String resourceKey : resourcesCpy.keySet()) {
+      LocalizationStatus lstatus = fromNM.get(resourceKey);
+      if (lstatus == null ||
+          lstatus.getState().equals(LocalizationState.PENDING)) {
+        allCompleted = false;
+        break;
+      }
+    }
+
+    List<LocalizationStatus> statusList = new ArrayList<>();
+    statusList.addAll(fromNM.values());
+    this.containerSpec.setLocalizationStatuses(statusList);
+    if (allCompleted) {
+      cancelLclRetriever();
+    }
+  }
+
+  public void updateResolvedLaunchParams(
+      Future<ProviderService.ResolvedLaunchParams> future) {
+    try {
+      writeLock.lock();
+      this.resolvedParams = future.get();
+    } catch (InterruptedException | ExecutionException e) {
+      LOG.error("{} updating resolved params", getCompInstanceId(), e);
+    } finally {
+      writeLock.unlock();
+    }
+  }
+
+    cancelLclRetriever();
+  private static class LocalizationStatusRetriever implements Runnable {
+    private ContainerId containerId;
+    private NodeId nodeId;
+    private NMClient nmClient;
+    private ComponentInstance instance;
+
+    LocalizationStatusRetriever(ServiceScheduler scheduler,
+        ContainerId containerId, ComponentInstance instance) {
+      this.nmClient = scheduler.getNmClient().getClient();
+      this.containerId = containerId;
+      this.instance = instance;
+      this.nodeId = instance.getNodeId();
+    }
+
+    @Override
+    public void run() {
+      List<org.apache.hadoop.yarn.api.records.LocalizationStatus>
+          statusesFromNM = null;
+      try {
+        statusesFromNM = nmClient.getLocalizationStatuses(containerId,
+            nodeId);
+      } catch (YarnException | IOException e) {
+        LOG.error("{} Failed to get localization statuses for {} {} ",
+            instance.compInstanceId, nodeId, containerId, e);
+      }
+      if (statusesFromNM != null && !statusesFromNM.isEmpty()) {
+        instance.updateLocalizationStatuses(statusesFromNM);
+      }
+    }
+  }
+
+  private void initializeLocalizationStatusRetriever(
+      ContainerId containerId) {
+    LOG.info("{} retrieve localization statuses", compInstanceId);
+    lclizationRetrieverFuture = scheduler.executorService.scheduleAtFixedRate(
+        new LocalizationStatusRetriever(scheduler, containerId, this),
+        0, 1, TimeUnit.SECONDS
+    );
+  }
+
+  private void cancelLclRetriever() {
+    if (lclizationRetrieverFuture != null &&
+        !lclizationRetrieverFuture.isDone()) {
+      LOG.info("{} cancelling localization retriever", compInstanceId);
+      lclizationRetrieverFuture.cancel(true);
+    }
+  }
+
+  @VisibleForTesting
+  boolean isLclRetrieverActive() {
+    return lclizationRetrieverFuture != null &&
+        !lclizationRetrieverFuture.isCancelled()
+         && !lclizationRetrieverFuture.isDone();
+  }
+

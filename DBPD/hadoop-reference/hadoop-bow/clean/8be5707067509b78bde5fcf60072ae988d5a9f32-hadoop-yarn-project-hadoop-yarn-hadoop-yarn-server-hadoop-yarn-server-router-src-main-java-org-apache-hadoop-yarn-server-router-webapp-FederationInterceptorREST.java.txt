YARN-7276. Federation Router Web Service fixes. Contributed by Inigo Goiri.

+import java.security.Principal;
+import java.util.concurrent.CompletionService;
+import javax.servlet.http.HttpServletRequestWrapper;
+import javax.ws.rs.core.HttpHeaders;
+import org.apache.hadoop.yarn.server.federation.resolver.SubClusterResolver;
-    rand = new Random(System.currentTimeMillis());
+    rand = new Random();
-      policyFacade = new RouterPolicyFacade(conf, federationFacade,
-          this.federationFacade.getSubClusterResolver(), null);
+      SubClusterResolver subClusterResolver =
+          this.federationFacade.getSubClusterResolver();
+      policyFacade = new RouterPolicyFacade(
+          conf, federationFacade, subClusterResolver, null);
-      LOG.error(e.getMessage());
+      throw new YarnRuntimeException(e);
-    numSubmitRetries =
-        conf.getInt(YarnConfiguration.ROUTER_CLIENTRM_SUBMIT_RETRY,
-            YarnConfiguration.DEFAULT_ROUTER_CLIENTRM_SUBMIT_RETRY);
+    numSubmitRetries = conf.getInt(
+        YarnConfiguration.ROUTER_CLIENTRM_SUBMIT_RETRY,
+        YarnConfiguration.DEFAULT_ROUTER_CLIENTRM_SUBMIT_RETRY);
-    interceptors = new HashMap<SubClusterId, DefaultRequestInterceptorREST>();
+    interceptors = new HashMap<>();
-    threadpool = HadoopExecutors.newCachedThreadPool(new ThreadFactoryBuilder()
-        .setNameFormat("FederationInterceptorREST #%d").build());
+    threadpool = HadoopExecutors.newCachedThreadPool(
+        new ThreadFactoryBuilder()
+            .setNameFormat("FederationInterceptorREST #%d")
+            .build());
-    returnPartialReport =
-        conf.getBoolean(YarnConfiguration.ROUTER_WEBAPP_PARTIAL_RESULTS_ENABLED,
-            YarnConfiguration.DEFAULT_ROUTER_WEBAPP_PARTIAL_RESULTS_ENABLED);
+    returnPartialReport = conf.getBoolean(
+        YarnConfiguration.ROUTER_WEBAPP_PARTIAL_RESULTS_ENABLED,
+        YarnConfiguration.DEFAULT_ROUTER_WEBAPP_PARTIAL_RESULTS_ENABLED);
-    FederationPolicyUtils.validateSubClusterAvailability(list,
-        blackListSubClusters);
+    FederationPolicyUtils.validateSubClusterAvailability(
+        list, blackListSubClusters);
-      LOG.error("The interceptor for SubCluster " + subClusterId
-          + " does not exist in the cache.");
+      LOG.error(
+          "The interceptor for SubCluster {} does not exist in the cache.",
+          subClusterId);
-    String interceptorClassName =
-        conf.get(YarnConfiguration.ROUTER_WEBAPP_DEFAULT_INTERCEPTOR_CLASS,
-            YarnConfiguration.DEFAULT_ROUTER_WEBAPP_DEFAULT_INTERCEPTOR_CLASS);
+    String interceptorClassName = conf.get(
+        YarnConfiguration.ROUTER_WEBAPP_DEFAULT_INTERCEPTOR_CLASS,
+        YarnConfiguration.DEFAULT_ROUTER_WEBAPP_DEFAULT_INTERCEPTOR_CLASS);
-    interceptorInstance.setWebAppAddress(webAppAddress);
+    interceptorInstance.setWebAppAddress("http://" + webAppAddress);
-      LOG.debug(
-          "getNewApplication try #" + i + " on SubCluster " + subClusterId);
+      LOG.debug("getNewApplication try #{} on SubCluster {}", i, subClusterId);
-        LOG.warn("Unable to create a new ApplicationId in SubCluster "
-            + subClusterId.getId(), e);
+        LOG.warn("Unable to create a new ApplicationId in SubCluster {}",
+            subClusterId.getId(), e);
-      if (response != null && response.getStatus() == 200) {
+      if (response != null &&
+          response.getStatus() == HttpServletResponse.SC_OK) {
-    return Response.status(Status.INTERNAL_SERVER_ERROR).entity(errMsg).build();
+    return Response
+        .status(Status.INTERNAL_SERVER_ERROR)
+        .entity(errMsg)
+        .build();
-      return Response.status(Status.BAD_REQUEST).entity(errMsg).build();
+      return Response
+          .status(Status.BAD_REQUEST)
+          .entity(errMsg)
+          .build();
-      return Response.status(Status.BAD_REQUEST).entity(e.getLocalizedMessage())
+      return Response
+          .status(Status.BAD_REQUEST)
+          .entity(e.getLocalizedMessage())
-        return Response.status(Status.SERVICE_UNAVAILABLE)
-            .entity(e.getLocalizedMessage()).build();
+        return Response
+            .status(Status.SERVICE_UNAVAILABLE)
+            .entity(e.getLocalizedMessage())
+            .build();
-      LOG.info("submitApplication appId" + applicationId + " try #" + i
-          + " on SubCluster " + subClusterId);
+      LOG.info("submitApplication appId {} try #{} on SubCluster {}",
+          applicationId, i, subClusterId);
-          return Response.status(Status.SERVICE_UNAVAILABLE)
-              .entity(errMsg + " " + e.getLocalizedMessage()).build();
+          return Response
+              .status(Status.SERVICE_UNAVAILABLE)
+              .entity(errMsg + " " + e.getLocalizedMessage())
+              .build();
-            return Response.status(Status.SERVICE_UNAVAILABLE)
-                .entity(e1.getLocalizedMessage()).build();
+            return Response
+                .status(Status.SERVICE_UNAVAILABLE)
+                .entity(e1.getLocalizedMessage())
+                .build();
-            LOG.info("Application " + applicationId
-                + " already submitted on SubCluster " + subClusterId);
+            LOG.info("Application {} already submitted on SubCluster {}",
+                applicationId, subClusterId);
-            return Response.status(Status.SERVICE_UNAVAILABLE).entity(errMsg)
+            return Response
+                .status(Status.SERVICE_UNAVAILABLE)
+                .entity(errMsg)
-        return Response.status(Status.SERVICE_UNAVAILABLE)
-            .entity(e.getLocalizedMessage()).build();
+        return Response
+            .status(Status.SERVICE_UNAVAILABLE)
+            .entity(e.getLocalizedMessage())
+            .build();
-        LOG.warn("Unable to submit the application " + applicationId
-            + "to SubCluster " + subClusterId.getId(), e);
+        LOG.warn("Unable to submit the application {} to SubCluster {}",
+            applicationId, subClusterId.getId(), e);
-      if (response != null && response.getStatus() == 202) {
-        LOG.info("Application " + context.getApplicationName() + " with appId "
-            + applicationId + " submitted on " + subClusterId);
+      if (response != null &&
+          response.getStatus() == HttpServletResponse.SC_ACCEPTED) {
+        LOG.info("Application {} with appId {} submitted on {}",
+            context.getApplicationName(), applicationId, subClusterId);
-    return Response.status(Status.SERVICE_UNAVAILABLE).entity(errMsg).build();
+    return Response
+        .status(Status.SERVICE_UNAVAILABLE)
+        .entity(errMsg)
+        .build();
-    AppInfo response = getOrCreateInterceptorForSubCluster(subClusterId,
-        subClusterInfo.getRMWebServiceAddress()).getApp(hsr, appId,
-            unselectedFields);
+    DefaultRequestInterceptorREST interceptor =
+        getOrCreateInterceptorForSubCluster(
+            subClusterId, subClusterInfo.getRMWebServiceAddress());
+    AppInfo response = interceptor.getApp(hsr, appId, unselectedFields);
-      return Response.status(Status.BAD_REQUEST).entity(e.getLocalizedMessage())
+      return Response
+          .status(Status.BAD_REQUEST)
+          .entity(e.getLocalizedMessage())
-      return Response.status(Status.BAD_REQUEST).entity(e.getLocalizedMessage())
+      return Response
+          .status(Status.BAD_REQUEST)
+          .entity(e.getLocalizedMessage())
-
-    ExecutorCompletionService<AppsInfo> compSvc =
-        new ExecutorCompletionService<AppsInfo>(this.threadpool);
+    CompletionService<AppsInfo> compSvc =
+        new ExecutorCompletionService<>(this.threadpool);
+      // HttpServletRequest does not work with ExecutorCompletionService.
+      // Create a duplicate hsr.
+      final HttpServletRequest hsrCopy = clone(hsr);
-              getOrCreateInterceptorForSubCluster(info.getSubClusterId(),
-                  info.getClientRMServiceAddress());
-          AppsInfo rmApps = interceptor.getApps(hsr, stateQuery, statesQuery,
-              finalStatusQuery, userQuery, queueQuery, count, startedBegin,
-              startedEnd, finishBegin, finishEnd, applicationTypes,
-              applicationTags, unselectedFields);
+              getOrCreateInterceptorForSubCluster(
+                  info.getSubClusterId(), info.getRMWebServiceAddress());
+          AppsInfo rmApps = interceptor.getApps(hsrCopy, stateQuery,
+              statesQuery, finalStatusQuery, userQuery, queueQuery, count,
+              startedBegin, startedEnd, finishBegin, finishEnd,
+              applicationTypes, applicationTags, unselectedFields);
-            LOG.error("Subcluster " + info.getSubClusterId()
-                + " failed to return appReport.");
+            LOG.error("Subcluster {} failed to return appReport.",
+                info.getSubClusterId());
-
-    for (int i = 0; i < subClustersActive.values().size(); i++) {
+    for (int i = 0; i < subClustersActive.size(); i++) {
-        LOG.warn("Failed to get application report ", e);
+        LOG.warn("Failed to get application report", e);
+    return RouterWebServiceUtil.mergeAppsInfo(
+        apps.getApps(), returnPartialReport);
+  }
-    return RouterWebServiceUtil.mergeAppsInfo(apps.getApps(),
-        returnPartialReport);
+  /**
+   * Get a copy of a HTTP request. This is for thread safety.
+   * @param hsr HTTP servlet request to copy.
+   * @return Copy of the HTTP request.
+   */
+  private HttpServletRequestWrapper clone(final HttpServletRequest hsr) {
+    if (hsr == null) {
+      return null;
+    }
+    return new HttpServletRequestWrapper(hsr) {
+        public Map<String, String[]> getParameterMap() {
+          return hsr.getParameterMap();
+        }
+        public String getPathInfo() {
+          return hsr.getPathInfo();
+        }
+        public String getRemoteUser() {
+          return hsr.getRemoteUser();
+        }
+        public Principal getUserPrincipal() {
+          return hsr.getUserPrincipal();
+        }
+        public String getHeader(String value) {
+          // we override only Accept
+          if (value.equals(HttpHeaders.ACCEPT)) {
+            return RouterWebServiceUtil.getMediaTypeFromHttpServletRequest(
+                hsr, AppsInfo.class);
+          }
+          return null;
+        }
+      };
-
-    ExecutorCompletionService<NodeInfo> compSvc =
+    CompletionService<NodeInfo> compSvc =
-              getOrCreateInterceptorForSubCluster(info.getSubClusterId(),
-                  info.getClientRMServiceAddress());
+              getOrCreateInterceptorForSubCluster(
+                  info.getSubClusterId(), info.getRMWebServiceAddress());
-            LOG.error("Subcluster " + info.getSubClusterId()
-                + " failed to return nodeInfo.");
+            LOG.error("Subcluster {} failed to return nodeInfo.",
+                info.getSubClusterId());
-    for (int i = 0; i < subClustersActive.values().size(); i++) {
+    for (int i = 0; i < subClustersActive.size(); i++) {
-          if (nodeInfo == null || nodeInfo.getLastHealthUpdate() < nodeResponse
-              .getLastHealthUpdate()) {
+          if (nodeInfo == null || nodeInfo.getLastHealthUpdate() <
+              nodeResponse.getLastHealthUpdate()) {
-      LOG.error(e.getMessage());
+      LOG.error("Cannot get nodes: {}", e.getMessage());
-
-    ExecutorCompletionService<NodesInfo> compSvc =
+    CompletionService<NodesInfo> compSvc =
-              getOrCreateInterceptorForSubCluster(info.getSubClusterId(),
-                  info.getClientRMServiceAddress());
+              getOrCreateInterceptorForSubCluster(
+                  info.getSubClusterId(), info.getRMWebServiceAddress());
-            LOG.error("Subcluster " + info.getSubClusterId()
-                + " failed to return nodesInfo.");
+            LOG.error("Subcluster {} failed to return nodesInfo.",
+                info.getSubClusterId());
-    for (int i = 0; i < subClustersActive.values().size(); i++) {
+    for (int i = 0; i < subClustersActive.size(); i++) {
-
-    ExecutorCompletionService<ClusterMetricsInfo> compSvc =
+    CompletionService<ClusterMetricsInfo> compSvc =
-              getOrCreateInterceptorForSubCluster(info.getSubClusterId(),
-                  info.getClientRMServiceAddress());
+              getOrCreateInterceptorForSubCluster(
+                  info.getSubClusterId(), info.getRMWebServiceAddress());
-            LOG.error("Subcluster " + info.getSubClusterId()
-                + " failed to return Cluster Metrics.");
+            LOG.error("Subcluster {} failed to return Cluster Metrics.",
+                info.getSubClusterId());
-    for (int i = 0; i < subClustersActive.values().size(); i++) {
+    for (int i = 0; i < subClustersActive.size(); i++) {

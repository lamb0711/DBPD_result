HADOOP-11614. Remove httpclient dependency from hadoop-openstack. Contributed by Akira Ajisaka, Brahma Reddy Battula, and Steve Loughran.

-import org.apache.commons.httpclient.DefaultHttpMethodRetryHandler;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpHost;
-import org.apache.commons.httpclient.HttpMethod;
-import org.apache.commons.httpclient.HttpMethodBase;
-import org.apache.commons.httpclient.HttpStatus;
-import org.apache.commons.httpclient.methods.DeleteMethod;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.HeadMethod;
-import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.methods.PutMethod;
-import org.apache.commons.httpclient.methods.StringRequestEntity;
-import org.apache.commons.httpclient.params.HttpConnectionParams;
-import org.apache.commons.httpclient.params.HttpMethodParams;
+import org.apache.hadoop.fs.swift.util.HttpResponseUtils;
+import org.apache.http.Header;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.config.RequestConfig;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpHead;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpRequestBase;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.config.SocketConfig;
+import org.apache.http.entity.ContentType;
+import org.apache.http.entity.InputStreamEntity;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.message.BasicHeader;
-import org.apache.http.conn.params.ConnRoutePNames;
-import static org.apache.commons.httpclient.HttpStatus.*;
+import static org.apache.http.HttpStatus.*;
- * This implements the client-side of the Swift REST API
+ * This implements the client-side of the Swift REST API.
-          new Header(SwiftProtocolConstants.X_NEWEST, "true");
+           new BasicHeader(SwiftProtocolConstants.X_NEWEST, "true");
-   * the authentication endpoint as supplied in the configuration
+   * the authentication endpoint as supplied in the configuration.
-   * tenant name
+   * tenant name.
-   * username name
+   * username name.
-   * user password
+   * user password.
-   * user api key
+   * user api key.
-   * The authentication request used to authenticate with Swift
+   * The authentication request used to authenticate with Swift.
-   * authRequest one is not applicable
+   * authRequest one is not applicable.
-    /**
-   * The container this client is working with
+  /**
+   * The container this client is working with.
-   * Access token (Secret)
+   * Access token (Secret).
-   * Endpoint for swift operations, obtained after authentication
+   * Endpoint for swift operations, obtained after authentication.
-   * The name of the service provider
+   * The name of the service provider.
-   * Number of times to retry a connection
+   * Number of times to retry a connection.
-   * How long (in milliseconds) should a connection be attempted
+   * How long (in milliseconds) should a connection be attempted.
-   * How long (in milliseconds) should a connection be attempted
+   * How long (in milliseconds) should a connection be attempted.
-   * How long (in milliseconds) between bulk operations
+   * How long (in milliseconds) between bulk operations.
-  * the name of a proxy host (can be null, in which case there is no proxy)
+  * the name of a proxy host (can be null, in which case there is no proxy).
-   * The port of a proxy. This is ignored if {@link #proxyHost} is null
+   * The port of a proxy. This is ignored if {@link #proxyHost} is null.
-   * token for Swift communication
+   * token for Swift communication.
-   * Base class for all Swift REST operations
+   * Base class for all Swift REST operations.
-   * @param <M> method
+   * @param <M> request
-  private static abstract class HttpMethodProcessor<M extends HttpMethod, R> {
-    public final M createMethod(String uri) throws IOException {
-      final M method = doCreateMethod(uri);
-      setup(method);
-      return method;
+  private static abstract class HttpRequestProcessor
+      <M extends HttpUriRequest, R> {
+    public final M createRequest(String uri) throws IOException {
+      final M req = doCreateRequest(uri);
+      setup(req);
+      return req;
-     * Override it to return some result after method is executed.
+     * Override it to return some result after request is executed.
-    public abstract R extractResult(M method) throws IOException;
+    public abstract R extractResult(M req, HttpResponse resp)
+        throws IOException;
-     * Factory method to create a REST method against the given URI
+     * Factory method to create a REST method against the given URI.
-    protected abstract M doCreateMethod(String uri);
+    protected abstract M doCreateRequest(String uri) throws IOException;
-     * Override port to set up the method before it is executed.
+     * Override port to set up the request before it is executed.
-    protected void setup(M method) throws IOException {
+    protected void setup(M req) throws IOException {
-     * Override point: what are the status codes that this operation supports
+     * Override point: what are the status codes that this operation supports?
-  private static abstract class GetMethodProcessor<R> extends HttpMethodProcessor<GetMethod, R> {
+  private static abstract class GetRequestProcessor<R>
+      extends HttpRequestProcessor<HttpGet, R> {
-    protected final GetMethod doCreateMethod(String uri) {
-      return new GetMethod(uri);
+    protected final HttpGet doCreateRequest(String uri) {
+      return new HttpGet(uri);
+    }
+  }
+
+  private static abstract class PostRequestProcessor<R>
+      extends HttpRequestProcessor<HttpPost, R> {
+    @Override
+    protected final HttpPost doCreateRequest(String uri) {
+      return new HttpPost(uri);
-  private static class AuthPostMethod extends PostMethod {
-
-
-    private AuthPostMethod(String uri) {
+  private static final class AuthPostRequest extends HttpPost {
+    private AuthPostRequest(String uri) {
-   * Generate an auth message
+   * Generate an auth message.
-  private static abstract class AuthMethodProcessor<R> extends
-                                                       HttpMethodProcessor<AuthPostMethod, R> {
+  private static abstract class AuthRequestProcessor<R>
+      extends HttpRequestProcessor<AuthPostRequest, R> {
-    protected final AuthPostMethod doCreateMethod(String uri) {
-      return new AuthPostMethod(uri);
+    protected final AuthPostRequest doCreateRequest(String uri) {
+      return new AuthPostRequest(uri);
-  private static abstract class PutMethodProcessor<R> extends HttpMethodProcessor<PutMethod, R> {
+  private static abstract class PutRequestProcessor<R>
+      extends HttpRequestProcessor<HttpPut, R> {
-    protected final PutMethod doCreateMethod(String uri) {
-      return new PutMethod(uri);
+    protected final HttpPut doCreateRequest(String uri) {
+      return new HttpPut(uri);
-     * Override point: what are the status codes that this operation supports
+     * Override point: what are the status codes that this operation supports?
-   * Create operation
+   * Create operation.
-   * @param <R>
+   * @param <R> result type
-  private static abstract class CopyMethodProcessor<R> extends HttpMethodProcessor<CopyMethod, R> {
+  private static abstract class CopyRequestProcessor<R>
+      extends HttpRequestProcessor<CopyRequest, R> {
-    protected final CopyMethod doCreateMethod(String uri) {
-      return new CopyMethod(uri);
+    protected final CopyRequest doCreateRequest(String uri)
+        throws SwiftException {
+      CopyRequest copy = new CopyRequest();
+      try {
+        copy.setURI(new URI(uri));
+      } catch (URISyntaxException e) {
+        throw new SwiftException("Failed to create URI from: " + uri);
+      }
+      return copy;
-     * The only allowed status code is 201:created
+     * The only allowed status code is 201:created.
-   * Delete operation
+   * Delete operation.
-  private static abstract class DeleteMethodProcessor<R> extends HttpMethodProcessor<DeleteMethod, R> {
+  private static abstract class DeleteRequestProcessor<R>
+      extends HttpRequestProcessor<HttpDelete, R> {
-    protected final DeleteMethod doCreateMethod(String uri) {
-      return new DeleteMethod(uri);
+    protected final HttpDelete doCreateRequest(String uri) {
+      return new HttpDelete(uri);
-  private static abstract class HeadMethodProcessor<R> extends HttpMethodProcessor<HeadMethod, R> {
+  private static abstract class HeadRequestProcessor<R>
+      extends HttpRequestProcessor<HttpHead, R> {
-    protected final HeadMethod doCreateMethod(String uri) {
-      return new HeadMethod(uri);
+    protected final HttpHead doCreateRequest(String uri) {
+      return new HttpHead(uri);
-   * Get a mandatory configuration option
+   * Get a mandatory configuration option.
-                   new Header(HEADER_RANGE, range),
+                   new BasicHeader(HEADER_RANGE, range),
-   * Returns object length
+   * Returns object length.
-    return perform("getContentLength", uri, new HeadMethodProcessor<Long>() {
+    return perform("getContentLength", uri, new HeadRequestProcessor<Long>() {
-      public Long extractResult(HeadMethod method) throws IOException {
-        return method.getResponseContentLength();
+      public Long extractResult(HttpHead req, HttpResponse resp)
+          throws IOException {
+        return HttpResponseUtils.getContentLength(resp);
-      protected void setup(HeadMethod method) throws IOException {
-        super.setup(method);
-        method.addRequestHeader(NEWEST);
+      protected void setup(HttpHead req) throws IOException {
+        super.setup(req);
+        req.addHeader(NEWEST);
-   * Get the length of the remote object
+   * Get the length of the remote object.
-   * Returns object location as byte[]
+   * Returns object location as byte[].
-              new GetMethodProcessor<byte[]>() {
-                @Override
-                protected int[] getAllowedStatusCodes() {
-                  return new int[]{
-                    SC_OK,
-                    SC_FORBIDDEN,
-                    SC_NO_CONTENT
-                  };
-                }
+          new GetRequestProcessor<byte[]>() {
+            @Override
+            protected int[] getAllowedStatusCodes() {
+              return new int[]{
+                  SC_OK,
+                  SC_FORBIDDEN,
+                  SC_NO_CONTENT
+              };
+            }
-                @Override
-                public byte[] extractResult(GetMethod method) throws
-                        IOException {
+            @Override
+            public byte[] extractResult(HttpGet req, HttpResponse resp) throws
+                IOException {
-                  //TODO: remove SC_NO_CONTENT if it depends on Swift versions
-                  if (method.getStatusCode() == SC_NOT_FOUND
-                      || method.getStatusCode() == SC_FORBIDDEN ||
-                          method.getStatusCode() == SC_NO_CONTENT ||
-                          method.getResponseBodyAsStream() == null) {
-                    return null;
-                  }
-                  final InputStream responseBodyAsStream = method.getResponseBodyAsStream();
-                  final byte[] locationData = new byte[1024];
+              //TODO: remove SC_NO_CONTENT if it depends on Swift versions
+              int statusCode = resp.getStatusLine().getStatusCode();
+              if (statusCode == SC_NOT_FOUND
+                  || statusCode == SC_FORBIDDEN
+                  || statusCode == SC_NO_CONTENT
+                  || resp.getEntity().getContent() == null) {
+                return null;
+              }
+              final InputStream responseBodyAsStream =
+                  resp.getEntity().getContent();
+              final byte[] locationData = new byte[1024];
-                  return responseBodyAsStream.read(locationData) > 0 ? locationData : null;
-                }
+              return responseBodyAsStream.read(locationData) > 0 ?
+                  locationData : null;
+            }
-                @Override
-                     protected void setup(GetMethod method)
-                       throws SwiftInternalStateException {
-                  setHeaders(method, requestHeaders);
-                }
-              });
+            @Override
+            protected void setup(HttpGet req)
+                throws SwiftInternalStateException {
+              setHeaders(req, requestHeaders);
+            }
+          });
-   * Create the URI needed to query the location of an object
+   * Create the URI needed to query the location of an object.
-   * Find objects under a prefix
+   * Find objects under a prefix.
-                                    final Header... requestHeaders) throws IOException {
+                          final Header... requestHeaders) throws IOException {
-    return perform("findObjectsByPrefix", uri, new GetMethodProcessor<byte[]>() {
-      @Override
-      public byte[] extractResult(GetMethod method) throws IOException {
-        if (method.getStatusCode() == SC_NOT_FOUND) {
-          //no result
-          throw new FileNotFoundException("Not found " + method.getURI());
-        }
-        return method.getResponseBody();
-      }
+    return perform("findObjectsByPrefix", uri,
+        new GetRequestProcessor<byte[]>() {
+          @Override
+          public byte[] extractResult(HttpGet req, HttpResponse resp)
+              throws IOException {
+            if (resp.getStatusLine().getStatusCode() == SC_NOT_FOUND) {
+              //no result
+              throw new FileNotFoundException("Not found " + req.getURI());
+            }
+            return HttpResponseUtils.getResponseBody(resp);
+          }
-      @Override
-      protected int[] getAllowedStatusCodes() {
-        return new int[]{
+          @Override
+          protected int[] getAllowedStatusCodes() {
+            return new int[]{
-        };
-      }
+            };
+          }
-      @Override
-      protected void setup(GetMethod method) throws
-                     SwiftInternalStateException {
-        setHeaders(method, requestHeaders);
-      }
-    });
+          @Override
+          protected void setup(HttpGet req) throws SwiftInternalStateException {
+            setHeaders(req, requestHeaders);
+          }
+        });
-   * Find objects in a directory
+   * Find objects in a directory.
-   * Find objects in a location
+   * Find objects in a location.
-  private byte[] findObjects(String location, final Header[] requestHeaders) throws
-          IOException {
+  private byte[] findObjects(String location, final Header[] requestHeaders)
+      throws IOException {
-    return perform("findObjects", uri, new GetMethodProcessor<byte[]>() {
-      @Override
-      public byte[] extractResult(GetMethod method) throws IOException {
-        if (method.getStatusCode() == SC_NOT_FOUND) {
-          //no result
-          throw new FileNotFoundException("Not found " + method.getURI());
-        }
-        return method.getResponseBody();
-      }
+    return perform("findObjects", uri,
+        new GetRequestProcessor<byte[]>() {
+          @Override
+          public byte[] extractResult(HttpGet req, HttpResponse resp)
+              throws IOException {
+            if (resp.getStatusLine().getStatusCode() == SC_NOT_FOUND) {
+              //no result
+              throw new FileNotFoundException("Not found " + req.getURI());
+            }
+            return HttpResponseUtils.getResponseBody(resp);
+          }
-      @Override
-      protected int[] getAllowedStatusCodes() {
-        return new int[]{
+          @Override
+          protected int[] getAllowedStatusCodes() {
+            return new int[]{
-        };
-      }
+            };
+          }
-      @Override
-      protected void setup(GetMethod method)
-        throws SwiftInternalStateException {
-        setHeaders(method, requestHeaders);
-      }
-    });
+          @Override
+          protected void setup(HttpGet req) throws SwiftInternalStateException {
+            setHeaders(req, requestHeaders);
+          }
+        });
-    return perform("copy", pathToURI(src), new CopyMethodProcessor<Boolean>() {
-      @Override
-      public Boolean extractResult(CopyMethod method) throws IOException {
-        return method.getStatusCode() != SC_NOT_FOUND;
-      }
+    return perform("copy", pathToURI(src),
+        new CopyRequestProcessor<Boolean>() {
+          @Override
+          public Boolean extractResult(CopyRequest req, HttpResponse resp)
+              throws IOException {
+            return resp.getStatusLine().getStatusCode() != SC_NOT_FOUND;
+          }
-      @Override
-      protected void setup(CopyMethod method) throws
-                     SwiftInternalStateException {
-        setHeaders(method, headers);
-        method.addRequestHeader(HEADER_DESTINATION, dst.toUriPath());
-      }
-    });
+          @Override
+          protected void setup(CopyRequest req) throws
+              SwiftInternalStateException {
+            setHeaders(req, headers);
+            req.addHeader(HEADER_DESTINATION, dst.toUriPath());
+          }
+        });
-      perform("upload", pathToURI(path), new PutMethodProcessor<byte[]>() {
+      perform("upload", pathToURI(path), new PutRequestProcessor<byte[]>() {
-        public byte[] extractResult(PutMethod method) throws IOException {
-          return method.getResponseBody();
+        public byte[] extractResult(HttpPut req, HttpResponse resp)
+            throws IOException {
+          return HttpResponseUtils.getResponseBody(resp);
-        protected void setup(PutMethod method) throws
+        protected void setup(HttpPut req) throws
-          method.setRequestEntity(new InputStreamRequestEntity(data, length));
-          setHeaders(method, requestHeaders);
+          req.setEntity(new InputStreamEntity(data, length));
+          setHeaders(req, requestHeaders);
-    return perform("", pathToURI(path), new DeleteMethodProcessor<Boolean>() {
+    return perform("", pathToURI(path), new DeleteRequestProcessor<Boolean>() {
-      public Boolean extractResult(DeleteMethod method) throws IOException {
-        return method.getStatusCode() == SC_NO_CONTENT;
+      public Boolean extractResult(HttpDelete req, HttpResponse resp)
+          throws IOException {
+        return resp.getStatusLine().getStatusCode() == SC_NO_CONTENT;
-      protected void setup(DeleteMethod method) throws
+      protected void setup(HttpDelete req) throws
-        setHeaders(method, requestHeaders);
+        setHeaders(req, requestHeaders);
-   * Issue a head request
+   * Issue a head request.
-    return perform(reason, pathToURI(path), new HeadMethodProcessor<Header[]>() {
-      @Override
-      public Header[] extractResult(HeadMethod method) throws IOException {
-        if (method.getStatusCode() == SC_NOT_FOUND) {
-          throw new FileNotFoundException("Not Found " + method.getURI());
-        }
+    return perform(reason, pathToURI(path),
+        new HeadRequestProcessor<Header[]>() {
+          @Override
+          public Header[] extractResult(HttpHead req, HttpResponse resp)
+              throws IOException {
+            if (resp.getStatusLine().getStatusCode() == SC_NOT_FOUND) {
+              throw new FileNotFoundException("Not Found " + req.getURI());
+            }
+            return resp.getAllHeaders();
+          }
-        return method.getResponseHeaders();
-      }
-
-      @Override
-      protected void setup(HeadMethod method) throws
-                    SwiftInternalStateException {
-        setHeaders(method, requestHeaders);
-      }
-    });
+          @Override
+          protected void setup(HttpHead req) throws
+              SwiftInternalStateException {
+            setHeaders(req, requestHeaders);
+          }
+        });
-   * Issue a put request
+   * Issue a put request.
-    return perform(pathToURI(path), new PutMethodProcessor<Integer>() {
+    return perform(pathToURI(path), new PutRequestProcessor<Integer>() {
-      public Integer extractResult(PutMethod method) throws IOException {
-        return method.getStatusCode();
+      public Integer extractResult(HttpPut req, HttpResponse resp)
+          throws IOException {
+        return resp.getStatusLine().getStatusCode();
-      protected void setup(PutMethod method) throws
+      protected void setup(HttpPut req) throws
-        setHeaders(method, requestHeaders);
+        setHeaders(req, requestHeaders);
-   * Authenticate to Openstack Keystone
+   * Authenticate to Openstack Keystone.
-  private class AuthenticationPost extends AuthMethodProcessor<AccessToken> {
+  private final class AuthenticationPost extends
+      AuthRequestProcessor<AccessToken> {
-    protected void setup(AuthPostMethod method) throws IOException {
-
-      method.setRequestEntity(getAuthenticationRequst(authenticationRequest));
+    protected void setup(AuthPostRequest req) throws IOException {
+      req.setEntity(getAuthenticationRequst(authenticationRequest));
-    public AccessToken extractResult(AuthPostMethod method) throws IOException {
+    public AccessToken extractResult(AuthPostRequest req, HttpResponse resp)
+        throws IOException {
-      if (method.getStatusCode() == SC_BAD_REQUEST) {
+      if (resp.getStatusLine().getStatusCode() == SC_BAD_REQUEST) {
-          authenticationRequest.toString(), "POST", authUri, method);
+       authenticationRequest.toString(), "POST", authUri, resp);
-        JSONUtil.toObject(method.getResponseBodyAsString(),
-                          AuthenticationWrapper.class).getAccess();
+          JSONUtil.toObject(HttpResponseUtils.getResponseBodyAsString(resp),
+                            AuthenticationWrapper.class).getAccess();
-  private StringRequestEntity getAuthenticationRequst(AuthenticationRequest authenticationRequest)
-    throws IOException {
+  private StringEntity getAuthenticationRequst(
+      AuthenticationRequest authenticationRequest) throws IOException {
-    return toJsonEntity(data);
+    return new StringEntity(data, ContentType.create("application/json",
+        "UTF-8"));
-   * Create a container -if it already exists, do nothing
+   * Create a container -if it already exists, do nothing.
-   * fields are missing
+   * fields are missing.
-  private <M extends HttpMethod, R> R perform(URI uri,
-                      HttpMethodProcessor<M, R> processor)
+  private <M extends HttpRequestBase, R> R perform(URI uri,
+                      HttpRequestProcessor<M, R> processor)
-  private <M extends HttpMethod, R> R perform(String reason,
-                                              URI uri,
-                                              HttpMethodProcessor<M, R> processor)
+  private <M extends HttpRequestBase, R> R perform(String reason, URI uri,
+      HttpRequestProcessor<M, R> processor)
-    final M method = processor.createMethod(uri.toString());
-
+    final M req = processor.createRequest(uri.toString());
+    req.addHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);
-    HttpMethodParams methodParams = method.getParams();
-    methodParams.setParameter(HttpMethodParams.RETRY_HANDLER,
-            new DefaultHttpMethodRetryHandler(
-                    retryCount, false));
-    methodParams.setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,
-                                 connectTimeout);
-    methodParams.setSoTimeout(socketTimeout);
-    method.addRequestHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);
+    HttpClientBuilder clientBuilder = HttpClientBuilder.create();
+    clientBuilder.setRetryHandler(
+        new DefaultHttpRequestRetryHandler(retryCount, false));
+    RequestConfig.Builder requestConfigBuilder =
+        RequestConfig.custom().setConnectTimeout(connectTimeout);
+    if (proxyHost != null) {
+      requestConfigBuilder.setProxy(new HttpHost(proxyHost, proxyPort));
+    }
+    clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
+    clientBuilder.setDefaultSocketConfig(
+        SocketConfig.custom().setSoTimeout(socketTimeout).build());
+    HttpResponse resp;
+      // client should not be closed in this method because
+      // the connection can be used later
+      CloseableHttpClient client = clientBuilder.build();
-        statusCode = exec(method);
+        resp = exec(client, req);
+        statusCode = checkNotNull(resp.getStatusLine().getStatusCode());
-        throw ExceptionDiags.wrapException(uri.toString(), method.getName(), e);
+        throw ExceptionDiags.wrapException(uri.toString(), req.getMethod(), e);
-              allowedStatusCodes);
+          allowedStatusCodes);
-        IOException ioe = buildException(uri, method, statusCode);
+        IOException ioe = buildException(uri, req, resp, statusCode);
-      R r = processor.extractResult(method);
+      R r = processor.extractResult(req, resp);
-      method.releaseConnection();
+      req.releaseConnection();
-      durationStats.add(method.getName()+" " + reason, duration, success);
+      durationStats.add(req.getMethod() + " " + reason, duration, success);
-   * @param method operation that failed
+   * @param resp operation that failed
-  private <M extends HttpMethod> IOException buildException(URI uri,
-                                                            M method,
-                                                            int statusCode) {
+  private <M extends HttpUriRequest> IOException buildException(
+      URI uri, M req, HttpResponse resp, int statusCode) {
-            method.getName(),
+            req.getMethod(),
-            method.getStatusLine()
+            resp.getStatusLine()
-      case SC_NOT_FOUND:
-        fault = new FileNotFoundException("Operation " + method.getName()
-                + " on " + uri);
-        break;
+    case SC_NOT_FOUND:
+      fault = new FileNotFoundException("Operation " + req.getMethod()
+          + " on " + uri);
+      break;
-      case SC_BAD_REQUEST:
-        //bad HTTP request
-        fault =  new SwiftBadRequestException(
-          "Bad request against " + uri,
-          method.getName(),
+    case SC_BAD_REQUEST:
+      //bad HTTP request
+      fault =  new SwiftBadRequestException("Bad request against " + uri,
+          req.getMethod(), uri, resp);
+      break;
+
+    case SC_REQUESTED_RANGE_NOT_SATISFIABLE:
+      //out of range
+      StringBuilder errorText = new StringBuilder(
+          resp.getStatusLine().getReasonPhrase());
+      //get the requested length
+      Header requestContentLen = req.getFirstHeader(HEADER_CONTENT_LENGTH);
+      if (requestContentLen != null) {
+        errorText.append(" requested ").append(requestContentLen.getValue());
+      }
+      //and the result
+      Header availableContentRange = resp.getFirstHeader(HEADER_CONTENT_RANGE);
+
+      if (availableContentRange != null) {
+        errorText.append(" available ")
+            .append(availableContentRange.getValue());
+      }
+      fault = new EOFException(errorText.toString());
+      break;
+
+    case SC_UNAUTHORIZED:
+      //auth failure; should only happen on the second attempt
+      fault  = new SwiftAuthenticationFailedException(
+          "Operation not authorized- current access token =" + getToken(),
+          req.getMethod(),
-          method);
-        break;
+          resp);
+      break;
-      case SC_REQUESTED_RANGE_NOT_SATISFIABLE:
-        //out of range
-        StringBuilder errorText = new StringBuilder(method.getStatusText());
-        //get the requested length
-        Header requestContentLen = method.getRequestHeader(HEADER_CONTENT_LENGTH);
-        if (requestContentLen!=null) {
-          errorText.append(" requested ").append(requestContentLen.getValue());
-        }
-        //and the result
-        Header availableContentRange = method.getResponseHeader(
-          HEADER_CONTENT_RANGE);
-        if (availableContentRange != null) {
-          errorText.append(" available ").append(availableContentRange.getValue());
-        }
-        fault = new EOFException(errorText.toString());
-        break;
+    case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:
+    case SwiftProtocolConstants.SC_THROTTLED_498:
+      //response code that may mean the client is being throttled
+      fault  = new SwiftThrottledRequestException(
+          "Client is being throttled: too many requests",
+          req.getMethod(),
+          uri,
+          resp);
+      break;
-      case SC_UNAUTHORIZED:
-        //auth failure; should only happen on the second attempt
-        fault  = new SwiftAuthenticationFailedException(
-                        "Operation not authorized- current access token ="
-                            + getToken(),
-                        method.getName(),
-                        uri,
-                        method);
-        break;
-
-      case SwiftProtocolConstants.SC_TOO_MANY_REQUESTS_429:
-      case SwiftProtocolConstants.SC_THROTTLED_498:
-        //response code that may mean the client is being throttled
-        fault  = new SwiftThrottledRequestException(
-                        "Client is being throttled: too many requests",
-                        method.getName(),
-                        uri,
-                        method);
-        break;
-
-      default:
-        //return a generic invalid HTTP response
-        fault = new SwiftInvalidResponseException(
-                errorMessage,
-                method.getName(),
-                uri,
-                method);
+    default:
+      //return a generic invalid HTTP response
+      fault = new SwiftInvalidResponseException(
+          errorMessage,
+          req.getMethod(),
+          uri,
+          resp);
-   * Exec a GET request and return the input stream of the response
+   * Exec a GET request and return the input stream of the response.
-    return perform("", uri, new GetMethodProcessor<HttpBodyContent>() {
+    return perform("", uri, new GetRequestProcessor<HttpBodyContent>() {
-      public HttpBodyContent extractResult(GetMethod method) throws IOException {
-        return
-          new HttpBodyContent(
-            new HttpInputStreamWithRelease(uri, method), method.getResponseContentLength()
-          );
+      public HttpBodyContent extractResult(HttpGet req, HttpResponse resp)
+          throws IOException {
+        return new HttpBodyContent(
+            new HttpInputStreamWithRelease(uri, req, resp),
+            HttpResponseUtils.getContentLength(resp));
-      protected void setup(GetMethod method) throws
+      protected void setup(HttpGet req) throws
-        setHeaders(method, requestHeaders);
+        setHeaders(req, requestHeaders);
-   * Create an instance against a specific FS URI,
+   * Create an instance against a specific FS URI.
-   * Convert the (JSON) data to a string request as UTF-8
-   *
-   * @param data data
-   * @return the data
-   * @throws SwiftException if for some very unexpected reason it's impossible
-   * to convert the data to UTF-8.
-   */
-  private static StringRequestEntity toJsonEntity(String data) throws
-          SwiftException {
-    StringRequestEntity entity;
-    try {
-      entity = new StringRequestEntity(data, "application/json", "UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new SwiftException("Could not encode data as UTF-8", e);
-    }
-    return entity;
-  }
-
-  /**
-   * Add the headers to the method, and the auth token (which must be set
+   * Add the headers to the method, and the auth token (which must be set).
-  private void setHeaders(HttpMethodBase method, Header[] requestHeaders)
+  private void setHeaders(HttpUriRequest method, Header[] requestHeaders)
-      for (Header header : requestHeaders) {
-        method.addRequestHeader(header);
-      }
+    for (Header header : requestHeaders) {
+      method.addHeader(header);
+    }
-   * Set the auth key header of the method to the token ID supplied
+   * Set the auth key header of the method to the token ID supplied.
-  private void setAuthToken(HttpMethodBase method, AccessToken accessToken)
+  private void setAuthToken(HttpUriRequest method, AccessToken accessToken)
-    method.addRequestHeader(HEADER_AUTH_KEY, accessToken.getId());
+    method.addHeader(HEADER_AUTH_KEY, accessToken.getId());
-   * Execute a method in a new HttpClient instance.
-   * If the auth failed, authenticate then retry the method.
+   * Execute a method in a new HttpClient instance. If the auth failed,
+   * authenticate then retry the method.
-   * @param method method to exec
-   * @param <M> Method type
+   * @param req request to exec
+   * @param client client to use
+   * @param <M> Request type
-  private <M extends HttpMethod> int exec(M method) throws IOException {
-    final HttpClient client = new HttpClient();
-    if (proxyHost != null) {
-      client.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,
-              new HttpHost(proxyHost, proxyPort));
-    }
-
-    int statusCode = execWithDebugOutput(method, client);
-
+  private <M extends HttpUriRequest> HttpResponse exec(HttpClient client, M req)
+      throws IOException {
+    HttpResponse resp = execWithDebugOutput(req, client);
+    int statusCode = resp.getStatusLine().getStatusCode();
-            && method instanceof AuthPostMethod
+        && req instanceof AuthPostRequest
-        LOG.debug("Operation failed with status " + method.getStatusCode() +
-                 " attempting keystone auth");
+        LOG.debug("Operation failed with status " + statusCode
+            + " attempting keystone auth");
-      final AuthPostMethod authentication = (AuthPostMethod) method;
+      final AuthPostRequest authentication = (AuthPostRequest) req;
-      authentication.setRequestEntity(getAuthenticationRequst(keystoneAuthRequest));
-      statusCode = execWithDebugOutput(method, client);
+      authentication.setEntity(getAuthenticationRequst(keystoneAuthRequest));
+      resp = execWithDebugOutput(req, client);
-      if (method instanceof AuthPostMethod) {
+      if (req instanceof AuthPostRequest) {
-                                                       method);
+                                                       resp);
-      statusCode = execWithDebugOutput(method, client);
+      resp = execWithDebugOutput(req, client);
-    return statusCode;
+    return resp;
-   * Execute the request with the request and response logged at debug level
-   * @param method method to execute
+   * Execute the request with the request and response logged at debug level.
+   * @param req request to execute
-  private <M extends HttpMethod> int execWithDebugOutput(M method,
-                                                         HttpClient client) throws
-          IOException {
+  private <M extends HttpUriRequest> HttpResponse execWithDebugOutput(M req,
+      HttpClient client) throws IOException {
-              method.getName() + " " + method.getURI() + "\n");
-      for (Header header : method.getRequestHeaders()) {
+              req.getMethod() + " " + req.getURI() + "\n");
+      for (Header header : req.getAllHeaders()) {
-    int statusCode = client.executeMethod(method);
+    HttpResponse resp = client.execute(req);
-      LOG.debug("Status code = " + statusCode);
+      LOG.debug("Status code = " + resp.getStatusLine().getStatusCode());
-    return statusCode;
+    return resp;
-   * @return true iff status is an element of [expected]
+   * @return true if status is an element of [expected]
-   * -that is, can you query for the location of partitions
+   * -that is, can you query for the location of partitions?
-   * Get the partition size in KB
+   * Get the partition size in KB.
-   * Get the buffer size in KB
+   * Get the buffer size in KB.
-   * Get the current operation statistics
+   * Get the current operation statistics.

HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.CachedBlock;
+import org.apache.hadoop.util.IntrusiveCollection;
+   * A list of CachedBlock objects on this datanode.
+   */
+  public static class CachedBlocksList extends IntrusiveCollection<CachedBlock> {
+    public enum Type {
+      PENDING_CACHED,
+      CACHED,
+      PENDING_UNCACHED
+    }
+
+    private final DatanodeDescriptor datanode;
+
+    private final Type type;
+
+    CachedBlocksList(DatanodeDescriptor datanode, Type type) {
+      this.datanode = datanode;
+      this.type = type;
+    }
+
+    public DatanodeDescriptor getDatanode() {
+      return datanode;
+    }
+
+    public Type getType() {
+      return type;
+    }
+  }
+
+  /**
+   * The blocks which we want to cache on this DataNode.
+   */
+  private final CachedBlocksList pendingCached = 
+      new CachedBlocksList(this, CachedBlocksList.Type.PENDING_CACHED);
+
+  /**
+   * The blocks which we know are cached on this datanode.
+   * This list is updated by periodic cache reports.
+   */
+  private final CachedBlocksList cached = 
+      new CachedBlocksList(this, CachedBlocksList.Type.CACHED);
+
+  /**
+   * The blocks which we want to uncache on this DataNode.
+   */
+  private final CachedBlocksList pendingUncached = 
+      new CachedBlocksList(this, CachedBlocksList.Type.PENDING_UNCACHED);
+
+  public CachedBlocksList getPendingCached() {
+    return pendingCached;
+  }
+
+  public CachedBlocksList getCached() {
+    return cached;
+  }
+
+  public CachedBlocksList getPendingUncached() {
+    return pendingUncached;
+  }
+
+  /**
-  /**
-   * Head of the list of cached blocks on the datanode
-   */
-  private volatile BlockInfo cachedBlockList = null;
-  /**
-   * Number of cached blocks on the datanode
-   */
-  private int numCachedBlocks = 0;
-
-  /** A queue of blocks to be cached by this datanode */
-  private BlockQueue<Block> cacheBlocks = new BlockQueue<Block>();
-  /** A set of blocks to be uncached by this datanode */
-  private LightWeightHashSet<Block> blocksToUncache =
-      new LightWeightHashSet<Block>();
-
-   * Add block to the list of cached blocks on the data-node.
-   * @return true if block was successfully added, false if already present
-   */
-  public boolean addCachedBlock(BlockInfo b) {
-    if (!b.addNode(this))
-      return false;
-    // add to the head of the data-node list
-    cachedBlockList = b.listInsert(cachedBlockList, this);
-    numCachedBlocks++;
-    return true;
-  }
-
-  /**
-   * Remove block from the list of cached blocks on the data-node.
-   * @return true if block was successfully removed, false if not present
-   */
-  public boolean removeCachedBlock(BlockInfo b) {
-    cachedBlockList = b.listRemove(cachedBlockList, this);
-    if (b.removeNode(this)) {
-      numCachedBlocks--;
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  /**
-   * Move block to the head of the list of cached blocks on the data-node.
-   * @return the index of the head of the blockList
-   */
-  int moveCachedBlockToHead(BlockInfo b, int curIndex, int headIndex) {
-    cachedBlockList = b.moveBlockToHead(cachedBlockList, this, curIndex,
-        headIndex);
-    return curIndex;
-  }
-
-  /**
-  @VisibleForTesting
-  protected BlockInfo getCachedHead() {
-    return cachedBlockList;
-  }
-
-    this.cachedBlockList = null;
-    this.blocksToUncache.clear();
+    // pendingCached, cached, and pendingUncached are protected by the
+    // FSN lock.
+    this.pendingCached.clear();
+    this.cached.clear();
+    this.pendingUncached.clear();
-    synchronized(blocksToUncache) {
-      this.blocksToUncache.clear();
-      this.cacheBlocks.clear();
-    }
+    // pendingCached, cached, and pendingUncached are protected by the
+    // FSN lock.
+    this.pendingCached.clear();
+    this.cached.clear();
+    this.pendingUncached.clear();
-  public int numCachedBlocks() {
-    return numCachedBlocks;
-  }
-
-  public Iterator<BlockInfo> getCachedBlockIterator() {
-    return new BlockIterator(this.cachedBlockList, this);
-  }
-
-   * Store block caching work.
-   */
-  void addBlockToBeCached(Block block) {
-    assert(block != null);
-    cacheBlocks.offer(block);
-  }
-
-  /**
-   * Store block uncaching work.
-   */
-  void addBlocksToBeUncached(List<Block> blocklist) {
-    assert(blocklist != null && blocklist.size() > 0);
-    synchronized (blocksToUncache) {
-      for (Block blk : blocklist) {
-        blocksToUncache.add(blk);
-      }
-    }
-  }
-
-  /**
-   * The number of pending cache work items
-   */
-  int getNumberOfBlocksToBeCached() {
-    return cacheBlocks.size();
-  }
-
-  /**
-  /**
-   * The number of pending uncache work items
-   */
-  int getNumberOfBlocksToBeUncached() {
-    synchronized (blocksToUncache) {
-      return blocksToUncache.size();
-    }
-  }
-
-  public List<Block> getCacheBlocks() {
-    return cacheBlocks.poll(cacheBlocks.size());
-  }
-
-   * Remove up to the maximum number of blocks to be uncached
-   */
-  public Block[] getInvalidateCacheBlocks() {
-    synchronized (blocksToUncache) {
-      Block[] deleteList = blocksToUncache.pollToArray(
-          new Block[blocksToUncache.size()]);
-      return deleteList.length == 0 ? null : deleteList;
-    }
-  }
-
-  /**

YARN-7900. [AMRMProxy] AMRMClientRelayer for stateful FederationInterceptor. (Botong Huang via asuresh)

-package org.apache.hadoop.yarn.server.utils;
+package org.apache.hadoop.yarn.client;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
-import org.apache.hadoop.yarn.client.ClientRMProxy;
+import org.apache.hadoop.yarn.api.records.Container;
+import org.apache.hadoop.yarn.api.records.SchedulingRequest;
+
+  public static void addToOutstandingSchedulingRequests(
+      Collection<SchedulingRequest> requests,
+      Map<Set<String>, List<SchedulingRequest>> outstandingSchedRequests) {
+    for (SchedulingRequest req : requests) {
+      List<SchedulingRequest> schedulingRequests = outstandingSchedRequests
+          .computeIfAbsent(req.getAllocationTags(), x -> new LinkedList<>());
+      SchedulingRequest matchingReq = null;
+      for (SchedulingRequest schedReq : schedulingRequests) {
+        if (isMatchingSchedulingRequests(req, schedReq)) {
+          matchingReq = schedReq;
+          break;
+        }
+      }
+      if (matchingReq != null) {
+        matchingReq.getResourceSizing()
+            .setNumAllocations(req.getResourceSizing().getNumAllocations());
+      } else {
+        schedulingRequests.add(req);
+      }
+    }
+  }
+
+  public static boolean isMatchingSchedulingRequests(
+      SchedulingRequest schedReq1, SchedulingRequest schedReq2) {
+    return schedReq1.getPriority().equals(schedReq2.getPriority()) &&
+        schedReq1.getExecutionType().getExecutionType().equals(
+            schedReq1.getExecutionType().getExecutionType()) &&
+        schedReq1.getAllocationRequestId() ==
+            schedReq2.getAllocationRequestId();
+  }
+
+  public static void removeFromOutstandingSchedulingRequests(
+      Collection<Container> containers,
+      Map<Set<String>, List<SchedulingRequest>> outstandingSchedRequests) {
+    if (containers == null || containers.isEmpty()) {
+      return;
+    }
+    for (Container container : containers) {
+      if (container.getAllocationTags() != null
+          && !container.getAllocationTags().isEmpty()) {
+        List<SchedulingRequest> schedReqs =
+            outstandingSchedRequests.get(container.getAllocationTags());
+        if (schedReqs != null && !schedReqs.isEmpty()) {
+          Iterator<SchedulingRequest> iter = schedReqs.iterator();
+          while (iter.hasNext()) {
+            SchedulingRequest schedReq = iter.next();
+            if (schedReq.getPriority().equals(container.getPriority())
+                && schedReq.getAllocationRequestId() == container
+                    .getAllocationRequestId()) {
+              int numAllocations =
+                  schedReq.getResourceSizing().getNumAllocations();
+              numAllocations--;
+              if (numAllocations == 0) {
+                iter.remove();
+              } else {
+                schedReq.getResourceSizing().setNumAllocations(numAllocations);
+              }
+            }
+          }
+        }
+      }
+    }
+  }

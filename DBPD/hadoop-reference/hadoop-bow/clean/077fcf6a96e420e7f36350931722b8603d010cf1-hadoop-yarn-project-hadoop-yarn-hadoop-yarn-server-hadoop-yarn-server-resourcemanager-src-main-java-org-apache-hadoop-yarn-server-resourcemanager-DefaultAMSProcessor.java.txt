YARN-6777. Support for ApplicationMasterService processing chain of interceptors. (asuresh)

+import org.apache.hadoop.yarn.ams.ApplicationMasterServiceContext;
-class DefaultAMSProcessor implements ApplicationMasterServiceProcessor {
+/**
+ * This is the default Application Master Service processor. It has be the
+ * last processor in the @{@link AMSProcessingChain}.
+ */
+final class DefaultAMSProcessor implements ApplicationMasterServiceProcessor {
-  private final RMContext rmContext;
-  private final YarnScheduler scheduler;
+  private RMContext rmContext;
-  DefaultAMSProcessor(RMContext rmContext, YarnScheduler scheduler) {
-    this.rmContext = rmContext;
-    this.scheduler = scheduler;
+  @Override
+  public void init(ApplicationMasterServiceContext amsContext,
+      ApplicationMasterServiceProcessor nextProcessor) {
+    this.rmContext = (RMContext)amsContext;
-  public RegisterApplicationMasterResponse registerApplicationMaster(
+  @Override
+  public void registerApplicationMaster(
-      RegisterApplicationMasterRequest request) throws IOException {
+      RegisterApplicationMasterRequest request,
+      RegisterApplicationMasterResponse response) throws IOException {
-    RegisterApplicationMasterResponse response = recordFactory
-        .newRecordInstance(RegisterApplicationMasterResponse.class);
-    return response;
-  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,
-      AllocateRequest request) throws YarnException {
+  @Override
+  public void allocate(ApplicationAttemptId appAttemptId,
+      AllocateRequest request, AllocateResponse response) throws YarnException {
-    AllocateResponse allocateResponse =
-        recordFactory.newRecordInstance(AllocateResponse.class);
-      allocateResponse.setNMTokens(allocation.getNMTokens());
+      response.setNMTokens(allocation.getNMTokens());
-        allocateResponse, updateErrors);
+        response, updateErrors);
-    handleNodeUpdates(app, allocateResponse);
+    handleNodeUpdates(app, response);
-        allocateResponse, allocation.getContainers());
+        response, allocation.getContainers());
-    allocateResponse.setCompletedContainersStatuses(appAttempt
+    response.setCompletedContainersStatuses(appAttempt
-    allocateResponse.setAvailableResources(allocation.getResourceLimit());
+    response.setAvailableResources(allocation.getResourceLimit());
-    addToContainerUpdates(allocateResponse, allocation,
+    addToContainerUpdates(response, allocation,
-    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());
+    response.setNumClusterNodes(getScheduler().getNumClusterNodes());
-      allocateResponse.setCollectorAddr(
+      response.setCollectorAddr(
-    allocateResponse
-        .setPreemptionMessage(generatePreemptionMessage(allocation));
+    response.setPreemptionMessage(generatePreemptionMessage(allocation));
-    allocateResponse.setApplicationPriority(app
+    response.setApplicationPriority(app
-    return allocateResponse;
-  public FinishApplicationMasterResponse finishApplicationMaster(
+  @Override
+  public void finishApplicationMaster(
-      FinishApplicationMasterRequest request) {
+      FinishApplicationMasterRequest request,
+      FinishApplicationMasterResponse response) {
-    FinishApplicationMasterResponse response =
-        FinishApplicationMasterResponse.newInstance(
+    response.setIsUnregistered(
-    return response;
-    return scheduler;
+    return rmContext.getScheduler();

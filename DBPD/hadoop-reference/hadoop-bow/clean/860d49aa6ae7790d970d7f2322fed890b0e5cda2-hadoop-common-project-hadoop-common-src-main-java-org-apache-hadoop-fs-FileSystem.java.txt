HADOOP-13605. Clean up FileSystem javadocs, logging; improve diagnostics on FS load. Contributed by Steve Loughran

-/**
+/*
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
- * File System should be written to use a FileSystem object.  The
- * Hadoop DFS is a multi-machine system that appears as a single
- * disk.  It's useful because of its fault tolerance and potentially
- * very large capacity.
- * 
+ * File System should be written to use a FileSystem object or its
+ * successor, {@link FileContext}.
+ *
- * implementation is DistributedFileSystem.
+ * implementation is DistributedFileSystem. There are other implementations
+ * for object stores and (outside the Apache Hadoop codebase),
+ * third party filesystems.
+ * <p>
+ * Notes
+ * <ol>
+ * <li>The behaviour of the filesystem is
+ * <a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/filesystem/filesystem.html">
+ * specified in the Hadoop documentation. </a>
+ * However, the normative specification of the behavior of this class is
+ * actually HDFS: if HDFS does not behave the way these Javadocs or
+ * the specification in the Hadoop documentations define, assume that
+ * the documentation is incorrect.
+ * </li>
+ * <li>The term {@code FileSystem} refers to an instance of this class.</li>
+ * <li>The acronym "FS" is used as an abbreviation of FileSystem.</li>
+ * <li>The term {@code filesystem} refers to the distributed/local filesystem
+ * itself, rather than the class used to interact with it.</li>
+ * <li>The term "file" refers to a file in the remote filesystem,
+ * rather than instances of {@code java.io.File}.</li>
+ * </ol>
+@SuppressWarnings("DeprecatedIsStillUsed")
-  public static final String FS_DEFAULT_NAME_KEY = 
+  public static final String FS_DEFAULT_NAME_KEY =
-  public static final String DEFAULT_FS = 
+  public static final String DEFAULT_FS =
+  /**
+   * This log is widely used in the org.apache.hadoop.fs code and tests,
+   * so must be considered something to only be changed with care.
+   */
+  @InterfaceAudience.Private
-   * Priority of the FileSystem shutdown hook.
+   * The SLF4J logger to use in logging within the FileSystem class itself.
+   */
+  private static final Logger LOGGER =
+      LoggerFactory.getLogger(FileSystem.class);
+
+  /**
+   * Priority of the FileSystem shutdown hook: {@value}.
+  /**
+   * Prefix for trash directory: {@value}.
+   */
-  /** FileSystem cache */
+  /** FileSystem cache. */
-  /** Recording statistics per a FileSystem class */
-  private static final Map<Class<? extends FileSystem>, Statistics> 
-    statisticsTable =
-      new IdentityHashMap<Class<? extends FileSystem>, Statistics>();
-  
+  /** Recording statistics per a FileSystem class. */
+  private static final Map<Class<? extends FileSystem>, Statistics>
+      statisticsTable = new IdentityHashMap<>();
+
-   * A cache of files that should be deleted when filesystem is closed
+   * A cache of files that should be deleted when the FileSystem is closed
-  private Set<Path> deleteOnExit = new TreeSet<Path>();
-  
+  private final Set<Path> deleteOnExit = new TreeSet<>();
+
+  /**
+   * Should symbolic links be resolved by {@link FileSystemLinkResolver}.
+   * Set to the value of
+   * {@link CommonConfigurationKeysPublic#FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY}
+   */
-   * This method adds a file system for testing so that we can find it later. It
-   * is only for testing.
+   * This method adds a FileSystem instance to the cache so that it can
+   * be retrieved later. It is only for testing.
-   * @param fs the file system to store
-   * @throws IOException
+   * @param fs the FileSystem to store
+   * @throws IOException if the current user cannot be determined.
+  @VisibleForTesting
-   * Get a filesystem instance based on the uri, the passed
-   * configuration and the user
+   * Get a FileSystem instance based on the uri, the passed in
+   * configuration and the user.
-   * @throws IOException
-   * @throws InterruptedException
+   * @throws IOException failure to load
+   * @throws InterruptedException If the {@code UGI.doAs()} call was
+   * somehow interrupted.
-   * Returns the configured filesystem implementation.
+   * Returns the configured FileSystem implementation.
-  
-  /** Get the default filesystem URI from a configuration.
+
+  /**
+   * Get the default FileSystem URI from a configuration.
-  /** Set the default filesystem URI in a configuration.
+  /**
+   * Set the default FileSystem URI in a configuration.
-  /** Set the default filesystem URI in a configuration.
+  /** Set the default FileSystem URI in a configuration.
-  /** Called after a new FileSystem instance is constructed.
-   * @param name a uri whose authority section names the host, port, etc.
+  /**
+   * Initialize a FileSystem.
+   *
+   * Called after the new FileSystem instance is constructed, and before it
+   * is ready for use.
+   *
+   * FileSystem implementations overriding this method MUST forward it to
+   * their superclass, though the order in which it is done, and whether
+   * to alter the configuration before the invocation are options of the
+   * subclass.
+   * @param name a URI whose authority section names the host, port, etc.
+   * @throws IOException on any failure to initialize this instance.
+   * @throws IllegalArgumentException if the URI is considered invalid.
-        CommonConfigurationKeys.FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY,
-        CommonConfigurationKeys.FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_DEFAULT);
+        CommonConfigurationKeysPublic.FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY,
+        CommonConfigurationKeysPublic.FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_DEFAULT);
-   * Return the protocol scheme for the FileSystem.
-   * <p/>
+   * Return the protocol scheme for this FileSystem.
+   * <p>
-   * @return the protocol scheme for the FileSystem.
+   * @return the protocol scheme for this FileSystem.
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default).
-    throw new UnsupportedOperationException("Not implemented by the " + getClass().getSimpleName() + " FileSystem implementation");
+    throw new UnsupportedOperationException("Not implemented by the "
+        + getClass().getSimpleName() + " FileSystem implementation");
-  /** Returns a URI whose scheme and authority identify this FileSystem.*/
+  /**
+   * Returns a URI which identifies this FileSystem.
+   *
+   * @return the URI of this filesystem.
+   */
-  
+
-   * 
+   *
-  
+
-   * 
-   * This is filesystem-dependent, but may for example consist of
+   *
+   * This is implementation-dependent, and may for example consist of
-   * 
+   *
-   * not specified and if the filesystem has a default port.
+   * not specified and if {@link #getDefaultPort()} returns a
+   * default port.
-    
+
-  
+
-   * Get the default port for this file system.
+   * Get the default port for this FileSystem.
-    // Uses the default file system if not fully qualified
+    // Uses the default FileSystem if not fully qualified
-   * Get a canonical service name for this file system.  The token cache is
-   * the only user of the canonical service name, and uses it to lookup this
-   * filesystem's service tokens.
-   * If file system provides a token of its own then it must have a canonical
-   * name, otherwise canonical name can be null.
-   * 
-   * Default Impl: If the file system has child file systems 
-   * (such as an embedded file system) then it is assumed that the fs has no
+   * Get a canonical service name for this FileSystem.
+   * The token cache is the only user of the canonical service name,
+   * and uses it to lookup this FileSystem's service tokens.
+   * If the file system provides a token of its own then it must have a
+   * canonical name, otherwise the canonical name can be null.
+   *
+   * Default implementation: If the FileSystem has child file systems
+   * (such as an embedded file system) then it is assumed that the FS has no
-   * 
+   *
-   * @see SecurityUtil#buildDTServiceName(URI, int) 
+   * @see SecurityUtil#buildDTServiceName(URI, int)
-  /** @deprecated call #getUri() instead.*/
+  /** @deprecated call {@link #getUri()} instead.*/
-  /** @deprecated call #get(URI,Configuration) instead. */
+  /** @deprecated call {@link #get(URI, Configuration)} instead. */
-  
+
-   * for old-format names. */ 
+   * for old-format names.
+   */
-      LOG.warn("\"local\" is a deprecated filesystem name."
+      LOGGER.warn("\"local\" is a deprecated filesystem name."
-      LOG.warn("\""+name+"\" is a deprecated filesystem name."
+      LOGGER.warn("\""+name+"\" is a deprecated filesystem name."
-   * Get the local file system.
-   * @param conf the configuration to configure the file system with
+   * Get the local FileSystem.
+   * @param conf the configuration to configure the FileSystem with
+   * if it is newly instantiated.
+   * @throws IOException if somehow the local FS cannot be instantiated.
-  /** Returns the FileSystem for this URI's scheme and authority.  The scheme
-   * of the URI determines a configuration property name,
-   * <tt>fs.<i>scheme</i>.class</tt> whose value names the FileSystem class.
-   * The entire URI is passed to the FileSystem instance's initialize method.
+  /**
+   * Get a FileSystem for this URI's scheme and authority.
+   * <ol>
+   * <li>
+   *   If the configuration has the property
+   *   {@code "fs.$SCHEME.impl.disable.cache"} set to true,
+   *   a new instance will be created, initialized with the supplied URI and
+   *   configuration, then returned without being cached.
+   * </li>
+   * <li>
+   *   If the there is a cached FS instance matching the same URI, it will
+   *   be returned.
+   * </li>
+   * <li>
+   *   Otherwise: a new FS instance will be created, initialized with the
+   *   configuration and URI, cached and returned to the caller.
+   * </li>
+   * </ol>
+   * @throws IOException if the FileSystem cannot be instantiated.
-    
+      LOGGER.debug("Bypassing cache to create filesystem {}", uri);
-   * Returns the FileSystem for this URI's scheme and authority and the 
-   * passed user. Internally invokes {@link #newInstance(URI, Configuration)}
+   * Returns the FileSystem for this URI's scheme and authority and the
+   * given user. Internally invokes {@link #newInstance(URI, Configuration)}
-   * @throws IOException
-   * @throws InterruptedException
+   * @throws IOException if the FileSystem cannot be instantiated.
+   * @throws InterruptedException If the {@code UGI.doAs()} call was
+   *         somehow interrupted.
-        return newInstance(uri,conf); 
+        return newInstance(uri, conf);
-  /** Returns the FileSystem for this URI's scheme and authority.  The scheme
-   * of the URI determines a configuration property name,
-   * <tt>fs.<i>scheme</i>.class</tt> whose value names the FileSystem class.
+
+  /**
+   * Returns the FileSystem for this URI's scheme and authority.
+   * @param uri FS URI
+   * @param config configuration to use
+   * @return the new FS instance
+   * @throws IOException FS creation or initialization failure.
-  public static FileSystem newInstance(URI uri, Configuration conf) throws IOException {
+  public static FileSystem newInstance(URI uri, Configuration config)
+      throws IOException {
-      return newInstance(conf);
+      return newInstance(config);
-      URI defaultUri = getDefaultUri(conf);
+      URI defaultUri = getDefaultUri(config);
-        return newInstance(defaultUri, conf);              // return default
+        return newInstance(defaultUri, config);              // return default
-    return CACHE.getUnique(uri, conf);
+    return CACHE.getUnique(uri, config);
-  /** Returns a unique configured filesystem implementation.
+  /**
+   * Returns a unique configured FileSystem implementation for the default
+   * filesystem of the supplied configuration.
+   * @return the new FS instance
+   * @throws IOException FS creation or initialization failure.
-   * Get a unique local file system object
-   * @param conf the configuration to configure the file system with
-   * @return a LocalFileSystem
-   * This always returns a new FileSystem object.
+   * Get a unique local FileSystem object.
+   * @param conf the configuration to configure the FileSystem with
+   * @return a new LocalFileSystem object.
+   * @throws IOException FS creation or initialization failure.
-   * Close all cached filesystems. Be sure those filesystems are not
-   * used anymore.
-   * 
-   * @throws IOException
+   * Close all cached FileSystem instances. After this operation, they
+   * may not be used in any operations.
+   *
+   * @throws IOException a problem arose closing one or more filesystem.
-   * Close all cached filesystems for a given UGI. Be sure those filesystems 
-   * are not used anymore.
+   * Close all cached FileSystem instances for a given UGI.
+   * Be sure those filesystems are not used anymore.
-   * @throws IOException
+   * @throws IOException a problem arose closing one or more filesystem.
-  public static void closeAllForUGI(UserGroupInformation ugi) 
+  public static void closeAllForUGI(UserGroupInformation ugi)
-  /** 
-   * Make sure that a path specifies a FileSystem.
-   * @param path to use
+  /**
+   * Qualify a path to one which uses this FileSystem and, if relative,
+   * made absolute.
+   * @param path to qualify.
+   * @return this path if it contains a scheme and authority and is absolute, or
+   * a new path that includes a path and authority and is fully qualified
+   * @see Path#makeQualified(URI, Path)
+   * @throws IllegalArgumentException if the path has a schema/URI different
+   * from this FileSystem.
-    
+
-   * Get a new delegation token for this file system.
+   * Get a new delegation token for this FileSystem.
-   * 
+   *
-   * @return a new delegation token
-   * @throws IOException
+   * @return a new delegation token or null if the FS does not support tokens.
+   * @throws IOException on any problem obtaining a token
-  
+
-   * already present in the given Credentials.  Existing tokens will neither
+   * already present in the given Credentials. Existing tokens will neither
-   * 
-   * Default Impl: works for simple fs with its own token
-   * and also for an embedded fs whose tokens are those of its
-   * children file system (i.e. the embedded fs has not tokens of its
-   * own).
-   * 
+   *
+   * Default Impl: works for simple FS with its own token
+   * and also for an embedded FS whose tokens are those of its
+   * child FileSystems (i.e. the embedded FS has no tokens of its own).
+   *
-   * @throws IOException
+   * @throws IOException problems obtaining a token
-    final List<Token<?>> tokens = new ArrayList<Token<?>>();
+    final List<Token<?>> tokens = new ArrayList<>();
-  
+
-   * Recursively obtain the tokens for this FileSystem and all descended
-   * FileSystems as determined by getChildFileSystems().
+   * Recursively obtain the tokens for this FileSystem and all descendant
+   * FileSystems as determined by {@link #getChildFileSystems()}.
-   * @throws IOException
+   * @throws IOException problems obtaining a token
-   * has multiple child FileSystems, then it should return a unique list
+   * has multiple child FileSystems, then it must return a unique list
-   * 
-   * @return FileSystems used by this FileSystem
+   *
+   * @return FileSystems that are direct children of this FileSystem,
+   *         or null for "no children"
-  
-  /** create a file with the provided permission
+
+  /**
+   * Create a file with the provided permission.
+   *
-   * 
-   * It is implemented using two RPCs. It is understood that it is inefficient,
+   *
+   * The HDFS implementation is implemented using two RPCs.
+   * It is understood that it is inefficient,
-   * 
-   * @param fs file system handle
+   *
+   * @param fs FileSystem
-   * @throws IOException
+   * @throws IOException IO failure
-  /** create a directory with the provided permission
+  /**
+   * Create a directory with the provided permission.
-   * 
+   *
-   * 
-   * @param fs file system handle
+   *
+   * @param fs FileSystem handle
-   * @throws IOException
+   * @throws IOException A problem creating the directories.
-  throws IOException {
+      throws IOException {
-  /** 
+  /**
+   *
+   * The base implementation performs case insensitive equality checks
+   * of the URIs' schemes and authorities. Subclasses may implement slightly
+   * different checks.
+   * @throws IllegalArgumentException if the path is not considered to be
+   * part of this FileSystem.
+   *
-    throw new IllegalArgumentException("Wrong FS: "+path+
-                                       ", expected: "+this.getUri());
+    throw new IllegalArgumentException("Wrong FS: " + path +
+                                       ", expected: " + this.getUri());
-   * Return an array containing hostnames, offset and size of 
-   * portions of the given file.  For a nonexistent 
-   * file or regions, null will be returned.
+   * Return an array containing hostnames, offset and size of
+   * portions of the given file.  For nonexistent
+   * file or regions, {@code null} is returned.
-   * This call is most helpful with DFS, where it returns 
-   * hostnames of machines that contain the given file.
+   * <pre>
+   *   if f == null :
+   *     result = null
+   *   elif f.getLen() <= start:
+   *     result = []
+   *   else result = [ locations(FS, b) for b in blocks(FS, p, s, s+l)]
+   * </pre>
+   * This call is most helpful with and distributed filesystem
+   * where the hostnames of machines that contain blocks of the given file
+   * can be determined.
-   * The FileSystem will simply return an elt containing 'localhost'.
+   * The default implementation returns an array containing one element:
+   * <pre>
+   * BlockLocation( { "localhost:50010" },  { "localhost" }, 0, file.getLen())
+   * </pre>>
+   * @throws IOException IO failure
-  public BlockLocation[] getFileBlockLocations(FileStatus file, 
+  public BlockLocation[] getFileBlockLocations(FileStatus file,
- 
-   * Return an array containing hostnames, offset and size of 
-   * portions of the given file.  For a nonexistent 
-   * file or regions, null will be returned.
+   * Return an array containing hostnames, offset and size of
+   * portions of the given file.  For a nonexistent
+   * file or regions, {@code null} is returned.
-   * This call is most helpful with DFS, where it returns 
-   * hostnames of machines that contain the given file.
+   * This call is most helpful with location-aware distributed
+   * filesystems, where it returns hostnames of machines that
+   * contain the given file.
-   * The FileSystem will simply return an elt containing 'localhost'.
+   * A FileSystem will normally return the equivalent result
+   * of passing the {@code FileStatus} of the path to
+   * {@link #getFileBlockLocations(FileStatus, long, long)}
+   * @throws FileNotFoundException when the path does not exist
+   * @throws IOException IO failure
-  public BlockLocation[] getFileBlockLocations(Path p, 
+  public BlockLocation[] getFileBlockLocations(Path p,
-  
+
-   * Return a set of server default configuration values
+   * Return a set of server default configuration values.
-   * @throws IOException
+   * @throws IOException IO failure
-    Configuration conf = getConf();
-    // CRC32 is chosen as default as it is available in all 
+    Configuration config = getConf();
+    // CRC32 is chosen as default as it is available in all
-    return new FsServerDefaults(getDefaultBlockSize(), 
-        conf.getInt("io.bytes.per.checksum", 512), 
-        64 * 1024, 
+    return new FsServerDefaults(getDefaultBlockSize(),
+        config.getInt("io.bytes.per.checksum", 512),
+        64 * 1024,
-        conf.getInt(IO_FILE_BUFFER_SIZE_KEY, IO_FILE_BUFFER_SIZE_DEFAULT),
+        config.getInt(IO_FILE_BUFFER_SIZE_KEY, IO_FILE_BUFFER_SIZE_DEFAULT),
-   * Return a set of server default configuration values
+   * Return a set of server default configuration values.
-   * @throws IOException
+   * @throws IOException IO failure
-   * Return the fully-qualified path of path f resolving the path
-   * through any symlinks or mount point
+   * Return the fully-qualified path of path, resolving the path
+   * through any symlinks or mount point.
-   * @return fully qualified path 
-   * @throws FileNotFoundException
+   * @return fully qualified path
+   * @throws FileNotFoundException if the path is not present
+   * @throws IOException for any other error
+   * @throws IOException IO failure
-    
+
+   * @throws IOException IO failure
+   * @throws IOException IO failure
+   * @throws IOException IO failure
-    return create(f, overwrite, 
+    return create(f, overwrite,
+   * @throws IOException IO failure
-  public FSDataOutputStream create(Path f, Progressable progress) 
+  public FSDataOutputStream create(Path f, Progressable progress)
-    return create(f, true, 
+    return create(f, true,
+   * @throws IOException IO failure
-    return create(f, true, 
+    return create(f, true,
+   * @throws IOException IO failure
-  public FSDataOutputStream create(Path f, short replication, 
+  public FSDataOutputStream create(Path f, short replication,
-    return create(f, true, 
+    return create(f, true,
-    
+
-   * @param f the file name to create
-   * @param overwrite if a file with this name already exists, then if true,
+   * @param f the file to create
+   * @param overwrite if a path with this name already exists, then if true,
+   * @throws IOException IO failure
-  public FSDataOutputStream create(Path f, 
+  public FSDataOutputStream create(Path f,
-    return create(f, overwrite, bufferSize, 
+    return create(f, overwrite, bufferSize,
-    
+
-   * Create an FSDataOutputStream at the indicated Path with write-progress
-   * reporting.
+   * Create an {@link FSDataOutputStream} at the indicated Path
+   * with write-progress reporting.
+   *
+   * The frequency of callbacks is implementation-specific; it may be "none".
+   * @throws IOException IO failure
-  public FSDataOutputStream create(Path f, 
+  public FSDataOutputStream create(Path f,
-    return create(f, overwrite, bufferSize, 
+    return create(f, overwrite, bufferSize,
-    
-    
+
+
-   * @param replication required block replication for the file. 
+   * @param replication required block replication for the file.
+   * @throws IOException IO failure
-  public FSDataOutputStream create(Path f, 
-                                   boolean overwrite,
-                                   int bufferSize,
-                                   short replication,
-                                   long blockSize
-                                   ) throws IOException {
+  public FSDataOutputStream create(Path f,
+      boolean overwrite,
+      int bufferSize,
+      short replication,
+      long blockSize) throws IOException {
-   * @param replication required block replication for the file. 
+   * @param replication required block replication for the file.
+   * @throws IOException IO failure
-   * @throws IOException
+   * @throws IOException IO failure
-  
+
-   * @throws IOException
+   * @throws IOException IO failure
-  
+
-   * checksum option
+   * checksum option.
-   * @throws IOException
+   * @throws IOException IO failure
-    return create(f, permission, flags.contains(CreateFlag.OVERWRITE), 
+    return create(f, permission, flags.contains(CreateFlag.OVERWRITE),
-  /*.
+  /**
-   * the permission
-   * with umask before calling this method.
+   * the permission with umask before calling this method.
+   * @throws IOException IO failure
-     FsPermission absolutePermission, EnumSet<CreateFlag> flag, int bufferSize,
-     short replication, long blockSize, Progressable progress,
-     ChecksumOpt checksumOpt) throws IOException {
+      FsPermission absolutePermission,
+      EnumSet<CreateFlag> flag,
+      int bufferSize,
+      short replication,
+      long blockSize,
+      Progressable progress,
+      ChecksumOpt checksumOpt) throws IOException {
-    
-    // Default impl  assumes that permissions do not matter and 
+
+    // Default impl  assumes that permissions do not matter and
-    
+
-  
+
+   * @param f path
+   * @param absolutePermission permissions
+   * @return true if the directory was actually created.
+   * @throws IOException IO failure
+   * @see #mkdirs(Path, FsPermission)
-    // Default impl is to assume that permissions do not matter and hence
-    // calling the regular mkdirs is good enough.
-    // FSs that implement permissions should override this.
-  protected void primitiveMkdir(Path f, FsPermission absolutePermission, 
+  protected void primitiveMkdir(Path f, FsPermission absolutePermission,
-    
+
-   * @throws IOException
+   * @throws IOException IO failure
-   * @throws IOException
+   * @throws IOException IO failure
-    * @throws IOException
+    * @throws IOException IO failure
-   *
+   * <i>Important: the default implementation is not atomic</i>
+   * @throws IOException IO failure
-   * Same as append(f, getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,
-   *     IO_FILE_BUFFER_SIZE_DEFAULT), null)
+   * Same as
+   * {@code append(f, getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,
+   *     IO_FILE_BUFFER_SIZE_DEFAULT), null)}
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default).
+
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default).
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default).
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default).
-    throw new UnsupportedOperationException("Not implemented by the " + 
+    throw new UnsupportedOperationException("Not implemented by the " +
-   * Get replication.
-   * 
-   * @deprecated Use getFileStatus() instead
+   * Get the replication factor.
+   *
+   * @deprecated Use {@link #getFileStatus(Path)} instead
-   * @throws IOException
-   */ 
+   * @throws FileNotFoundException if the path does not resolve.
+   * @throws IOException an IO failure
+   */
-   * Set replication for an existing file.
-   * 
+   * Set the replication for an existing file.
+   * If a filesystem does not support replication, it will always
+   * return true: the check for a file existing may be bypassed.
+   * This is the default behavior.
-   * @return true if successful;
-   *         false if file does not exist or is a directory
+   * @return true if successful, or the feature in unsupported;
+   *         false if replication is supported but the file does not exist,
+   *         or is a directory
-   * Renames Path src to Path dst.  Can take place on local fs
-   * or remote DFS.
+   * Renames Path src to Path dst.
-   * <li>Fails if src is a file and dst is a directory.
-   * <li>Fails if src is a directory and dst is a file.
-   * <li>Fails if the parent of dst does not exist or is a file.
+   *   <li>Fails if src is a file and dst is a directory.</li>
+   *   <li>Fails if src is a directory and dst is a file.</li>
+   *   <li>Fails if the parent of dst does not exist or is a file.</li>
-   * This method is deprecated since it is a temporary method added to 
-   * support the transition from FileSystem to FileContext for user 
+   * This method is deprecated since it is a temporary method added to
+   * support the transition from FileSystem to FileContext for user
-   * 
+   *
+   * @throws FileNotFoundException src path does not exist, or the parent
+   * path of dst does not exist.
+   * @throws FileAlreadyExistsException dest path exists and is a file
+   * @throws ParentNotDirectoryException if the parent path of dest is not
+   * a directory
-   * <li>Fails if path is a directory.
-   * <li>Fails if path does not exist.
-   * <li>Fails if path is not closed.
-   * <li>Fails if new size is greater than current size.
+   *   <li>Fails if path is a directory.</li>
+   *   <li>Fails if path does not exist.</li>
+   *   <li>Fails if path is not closed.</li>
+   *   <li>Fails if new size is greater than current size.</li>
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default).
-  
+
-   * Delete a file 
+   * Delete a file/directory.
-  
+
-   * @param recursive if path is a directory and set to 
+   * @param recursive if path is a directory and set to
-   * case of a file the recursive can be set to either true or false. 
-   * @return  true if delete is successful else false. 
-   * @throws IOException
+   * case of a file the recursive can be set to either true or false.
+   * @return  true if delete is successful else false.
+   * @throws IOException IO failure
-   * Mark a path to be deleted when FileSystem is closed.
-   * When the JVM shuts down,
-   * all FileSystem objects will be closed automatically.
-   * Then,
-   * the marked path will be deleted as a result of closing the FileSystem.
+   * Mark a path to be deleted when its FileSystem is closed.
+   * When the JVM shuts down cleanly, all cached FileSystem objects will be
+   * closed automatically â€”these the marked paths will be deleted as a result.
-   * The path has to exist in the file system.
-   * 
+   * If a FileSystem instance is not cached, i.e. has been created with
+   * {@link #createFileSystem(URI, Configuration)}, then the paths will
+   * be deleted in when {@link #close()} is called on that instance.
+   *
+   * The path must exist in the filesystem at the time of the method call;
+   * it does not have to exist at the time of JVM shutdown.
+   *
+   * Notes
+   * <ol>
+   *   <li>Clean shutdown of the JVM cannot be guaranteed.</li>
+   *   <li>The time to shut down a FileSystem will depends on the number of
+   *   files to delete. For filesystems where the cost of checking
+   *   for the existence of a file/directory and the actual delete operation
+   *   (for example: object stores) is high, the time to shutdown the JVM can be
+   *   significantly extended by over-use of this feature.</li>
+   *   <li>Connectivity problems with a remote filesystem may delay shutdown
+   *   further, and may cause the files to not be deleted.</li>
+   * </ol>
-   * @throws IOException
+   * @throws IOException IO failure
-  
+
-   * Cancel the deletion of the path when the FileSystem is closed
+   * Cancel the scheduled deletion of the path when the FileSystem is closed.
+   * @return true if the path was found in the delete-on-exit list.
-   * Delete all files that were marked as delete-on-exit. This recursively
-   * deletes all files in the specified paths.
+   * Delete all paths that were marked as delete-on-exit. This recursively
+   * deletes all files and directories in the specified paths.
+   *
+   * The time to process this operation is {@code O(paths)}, with the actual
+   * time dependent on the time for existence and deletion operations to
+   * complete, successfully or not.
-          LOG.info("Ignoring failure to deleteOnExit for path " + path);
+          LOGGER.info("Ignoring failure to deleteOnExit for path {}", path);
-  
-  /** Check if exists.
-   * @param f source file
+
+  /** Check if a path exists.
+   * @param f source path
+   * @return true if the path exists
+   * @throws IOException IO failure
-   * Note: Avoid using this method. Instead reuse the FileStatus 
+   * Note: Avoid using this method. Instead reuse the FileStatus
+   * @throws IOException IO failure
-   * Note: Avoid using this method. Instead reuse the FileStatus 
-   * returned by getFileStatus() or listStatus() methods.
+   * Note: Avoid using this method. Instead reuse the FileStatus
+   * returned by {@link #getFileStatus(Path)} or listStatus() methods.
+   * @throws IOException IO failure
-  
-  /** The number of bytes in a file. */
-  /** @deprecated Use getFileStatus() instead */
+
+  /**
+   * The number of bytes in a file.
+   * @return the number of bytes; 0 for a directory
+   * @deprecated Use {@link #getFileStatus(Path)} instead.
+   * @throws FileNotFoundException if the path does not resolve
+   * @throws IOException IO failure
+   */
-    
+
-  * @param f path to use
-  */
+   * @param f path to use
+   * @throws FileNotFoundException if the path does not resolve
+   * @throws IOException IO failure
+   */
+   * @return the quota usage
+   * @throws IOException IO failure
-  final private static PathFilter DEFAULT_FILTER = new PathFilter() {
-    @Override
-    public boolean accept(Path file) {
-      return true;
-    }
-  };
-    
+  /**
+   * The default filter accepts all paths.
+   */
+  private static final PathFilter DEFAULT_FILTER = new PathFilter() {
+      @Override
+      public boolean accept(Path file) {
+        return true;
+      }
+    };
+
-  public abstract FileStatus[] listStatus(Path f) throws IOException;
+  public abstract FileStatus[] listStatus(Path f) throws FileNotFoundException,
+                                                         IOException;
-  /*
+  /**
+   * @throws FileNotFoundException when the path does not exist
+   * @throws IOException see specific implementation
+   * List corrupted file blocks.
-   * @throws IOException
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default).
+   * @throws IOException IO failure
-                                            " does not support" +
-                                            " listCorruptFileBlocks");
+        " does not support listCorruptFileBlocks");
-   * 
+   *
-   * @throws FileNotFoundException when the path does not exist;
-   *         IOException see specific implementation   
+   * @throws FileNotFoundException when the path does not exist
+   * @throws IOException see specific implementation
-  public FileStatus[] listStatus(Path f, PathFilter filter) 
+  public FileStatus[] listStatus(Path f, PathFilter filter)
-    ArrayList<FileStatus> results = new ArrayList<FileStatus>();
+    ArrayList<FileStatus> results = new ArrayList<>();
-   * 
+   *
-   * @throws FileNotFoundException when the path does not exist;
-   *         IOException see specific implementation
+   * @throws FileNotFoundException when the path does not exist
+   * @throws IOException see specific implementation
-   * 
+   *
-   * @throws FileNotFoundException when the path does not exist;
-   *         IOException see specific implementation
+   * @throws FileNotFoundException when the path does not exist
+   * @throws IOException see specific implementation
-   * 
+   *
-   *    
+   *
-   * @throws IOException
+   * @throws IOException IO failure
-  
+
-   * Return an array of FileStatus objects whose path names match
+   * Return an array of {@link FileStatus} objects whose path names match
-   * 
+   *
-  
+
-   * a directory. 
+   * a directory.
-   * 
+   *
-   * 
+   *
-   * @return an iterator that traverses statuses of the files/directories 
+   * @return an iterator that traverses statuses of the files/directories
-   * Listing a directory
+   * List a directory.
-   * @return an iterator that traverses statuses of the files/directories 
+   * @return an iterator that traverses statuses of the files/directories
-   * while consuming the entries. Each file system implementation should
+   * while consuming the entries. Each FileSystem implementation should
-   * possible. 
+   * possible.
+   *
+   * @throws FileNotFoundException if <code>p</code> does not exist
+   * @throws IOException if any I/O error occurred
-   * 
-   * If the path is a directory, 
+   * <pre>
+   * If the path is a directory,
-   * 
+   * </pre>
-   *         IOException see specific implementation
+   * @throws IOException see specific implementation
-      private Stack<RemoteIterator<LocatedFileStatus>> itors = 
-        new Stack<RemoteIterator<LocatedFileStatus>>();
+      private Stack<RemoteIterator<LocatedFileStatus>> itors = new Stack<>();
-     
+
-        } 
+        }
-  
-  /** Return the current user's home directory in this filesystem.
-   * The default implementation returns "/user/$USER/".
+
+  /** Return the current user's home directory in this FileSystem.
+   * The default implementation returns {@code "/user/$USER/"}.
-   * Set the current working directory for the given file system. All relative
+   * Set the current working directory for the given FileSystem. All relative
-   * 
+   *
-    
+
-   * Get the current working directory for the given file system
+   * Get the current working directory for the given FileSystem
-  
-  
+
-   * Note: with the new FilesContext class, getWorkingDirectory()
-   * will be removed. 
-   * The working directory is implemented in FilesContext.
-   * 
-   * Some file systems like LocalFileSystem have an initial workingDir
+   * Note: with the new FileContext class, getWorkingDirectory()
+   * will be removed.
+   * The working directory is implemented in FileContext.
+   *
+   * Some FileSystems like LocalFileSystem have an initial workingDir
-   * 
+   *
+   * @param f path
+   * @return true if the directory was created
+   * @throws IOException IO failure
-   * directories. Has the semantics of Unix 'mkdir -p'.
+   * directories. Has roughly the semantics of Unix @{code mkdir -p}.
+   * @throws IOException IO failure
-   * The src file is on the local disk.  Add it to FS at
+   * The src file is on the local disk.  Add it to filesystem at
+   * @throws IOException IO failure
-   * The src files is on the local disk.  Add it to FS at
+   * The src files is on the local disk.  Add it to filesystem at
-   * @param srcs path
+   * @param srcs source paths
+   * @throws IOException IO failure
-   * The src file is on the local disk.  Add it to FS at
+   * The src file is on the local disk.  Add it to the filesystem at
-   * @param src path
+   * @param src local path
+   * @throws IOException IO failure
-   * The src file is on the local disk.  Add it to FS at
+   * The src file is on the local disk.  Add it to the filesystem at
-  
+
-   * The src files are on the local disk.  Add it to FS at
+   * The src files are on the local disk.  Add it to the filesystem at
+   * @throws IOException IO failure
-  public void copyFromLocalFile(boolean delSrc, boolean overwrite, 
+  public void copyFromLocalFile(boolean delSrc, boolean overwrite,
-  
+
-   * The src file is on the local disk.  Add it to FS at
+   * The src file is on the local disk.  Add it to the filesystem at
+   * @throws IOException IO failure
-  public void copyFromLocalFile(boolean delSrc, boolean overwrite, 
+  public void copyFromLocalFile(boolean delSrc, boolean overwrite,
-    
+
-   * The src file is under FS, and the dst is on the local disk.
-   * Copy it from FS control to the local dst name.
-   * @param src path
-   * @param dst path
+   * Copy it a file from the remote filesystem to the local one.
+   * @param src path src file in the remote filesystem
+   * @param dst path local destination
+   * @throws IOException IO failure
-    
+
-   * The src file is under FS, and the dst is on the local disk.
-   * Copy it from FS control to the local dst name.
-   * Remove the source afterwards
-   * @param src path
-   * @param dst path
+   * Copy a file to the local filesystem, then delete it from the
+   * remote filesystem (if successfully copied).
+   * @param src path src file in the remote filesystem
+   * @param dst path local destination
+   * @throws IOException IO failure
-   * The src file is under FS, and the dst is on the local disk.
-   * Copy it from FS control to the local dst name.
+   * Copy it a file from a remote filesystem to the local one.
-   * @param src path
-   * @param dst path
-   */   
+   * @param src path src file in the remote filesystem
+   * @param dst path local destination
+   * @throws IOException IO failure
+   */
-  
-    /**
-   * The src file is under FS, and the dst is on the local disk. Copy it from FS
-   * control to the local dst name. delSrc indicates if the src will be removed
+
+  /**
+   * The src file is under this filesystem, and the dst is on the local disk.
+   * Copy it from the remote filesystem to the local dst name.
+   * delSrc indicates if the src will be removed
-   * as local file system or not. RawLocalFileSystem is non crc file system.So,
-   * It will not create any crc files at local.
-   * 
+   * as the local file system or not. RawLocalFileSystem is non checksumming,
+   * So, It will not create any crc files at local.
+   *
-   * 
-   * @throws IOException
-   *           - if any IO error
+   *
+   * @throws IOException for any IO error
-   * Returns a local File that the user can write output to.  The caller
-   * provides both the eventual FS target name and the local working
-   * file.  If the FS is local, we write directly into the target.  If
-   * the FS is remote, we write into the tmp local area.
+   * Returns a local file that the user can write output to.  The caller
+   * provides both the eventual target name in this FileSystem
+   * and the local working file path.
+   * If this FileSystem is local, we write directly into the target.  If
+   * the FileSystem is not local, we write into the tmp local area.
+   * @throws IOException IO failure
-   * Called when we're all done writing to the target.  A local FS will
-   * do nothing, because we've written to exactly the right place.  A remote
-   * FS will copy the contents of tmpLocalFile to the correct target at
+   * Called when we're all done writing to the target.
+   * A local FS will do nothing, because we've written to exactly the
+   * right place.
+   * A remote FS will copy the contents of tmpLocalFile to the correct target at
+   * @throws IOException IO failure
-   * No more filesystem operations are needed.  Will
-   * release any held locks.
+   * Close this FileSystem instance.
+   * Will release any held locks, delete all files queued for deletion
+   * through calls to {@link #deleteOnExit(Path)}, and remove this FS instance
+   * from the cache, if cached.
+   *
+   * After this operation, the outcome of any method call on this FileSystem
+   * instance, or any input/output stream created by it is <i>undefined</i>.
+   * @throws IOException IO failure
-  /** Return the total size of all files in the filesystem. */
+  /**
+   * Return the total size of all files in the filesystem.
+   * @throws IOException IO failure
+   */
-  /** Return the total size of all files from a specified path. */
+  /**
+   * Return the total size of all files from a specified path.
+   * @throws IOException IO failure
+   */
+   * @deprecated Use {@link #getFileStatus(Path)} instead
+   * @throws FileNotFoundException if the path is not present
+   * @throws IOException IO failure
-  /** @deprecated Use getFileStatus() instead */
-   * be split into to minimize i/o time.
+   * be split into to minimize I/O time.
-    
-  /** Return the number of bytes that large input files should be optimally
-   * be split into to minimize i/o time.  The given path will be used to
+
+  /**
+   * Return the number of bytes that large input files should be optimally
+   * be split into to minimize I/O time.  The given path will be used to
+   * @return the replication; the default value is "1".
-   * Get the default replication for a path.   The given path will be used to
-   * locate the actual filesystem.  The full path does not have to exist.
+   * Get the default replication for a path.
+   * The given path will be used to locate the actual FileSystem to query.
+   * The full path does not have to exist.
-   * @return default replication for the path's filesystem 
+   * @return default replication for the path's filesystem
-  
+
-   * @throws FileNotFoundException when the path does not exist;
-   *         IOException see specific implementation
+   * @throws FileNotFoundException when the path does not exist
+   * @throws IOException see specific implementation
-   * <p/>
-   * The default implementation of this method calls {@link #getFileStatus(Path)}
+   * <p>
+   * The default implementation calls {@link #getFileStatus(Path)}
-   * Note that the getFileStatus call will be subject to authorization checks.
+   *
+   * Note that the {@link #getFileStatus(Path)} call will be subject to
+   * authorization checks.
+   * @throws AccessControlException if access is denied
-      throws IOException {
+      throws AccessControlException, IOException {
-   * See {@link FileContext#fixRelativePart}
+   * See {@link FileContext#fixRelativePart}.
-   * See {@link FileContext#createSymlink(Path, Path, boolean)}
+   * See {@link FileContext#createSymlink(Path, Path, boolean)}.
-      ParentNotDirectoryException, UnsupportedFileSystemException, 
+      ParentNotDirectoryException, UnsupportedFileSystemException,
-   * See {@link FileContext#getFileLinkStatus(Path)}
+   * See {@link FileContext#getFileLinkStatus(Path)}.
+   * @throws FileNotFoundException when the path does not exist
+   * @throws IOException see specific implementation
-   * See {@link AbstractFileSystem#supportsSymlinks()}
+   * See {@link AbstractFileSystem#supportsSymlinks()}.
-   * See {@link FileContext#getLinkTarget(Path)}
+   * See {@link FileContext#getLinkTarget(Path)}.
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * See {@link AbstractFileSystem#getLinkTarget(Path)}
+   * See {@link AbstractFileSystem#getLinkTarget(Path)}.
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * Get the checksum of a file.
+   * Get the checksum of a file, if the FS supports checksums.
+   * @throws IOException IO failure
-   * @return The file checksum.
+   * @return The file checksum or null if checksums are not supported.
+   * @throws IOException IO failure
-   * Set the verify checksum flag. This is only applicable if the 
-   * corresponding FileSystem supports checksum. By default doesn't do anything.
+   * Set the verify checksum flag. This is only applicable if the
+   * corresponding filesystem supports checksums.
+   * By default doesn't do anything.
-   * Set the write checksum flag. This is only applicable if the 
-   * corresponding FileSystem supports checksum. By default doesn't do anything.
-   * @param writeChecksum Write checsum flag
+   * Set the write checksum flag. This is only applicable if the
+   * corresponding filesystem supports checksums.
+   * By default doesn't do anything.
+   * @param writeChecksum Write checksum flag
-   * file system. If the file system has multiple partitions, the
+   * filesystem. If the filesystem has multiple partitions, the
-   * 
+   *
-   * file system. If the file system has multiple partitions, the
+   * filesystem. If the filesystem has multiple partitions, the
-   * the default partition. 
+   * the default partition.
+   * @throws IOException IO failure
+   * @throws IOException IO failure
-   * Set access time of a file
+   * Set access time of a file.
-   *              The number of milliseconds since Jan 1, 1970. 
+   *              The number of milliseconds since Jan 1, 1970.
-   *              The number of milliseconds since Jan 1, 1970. 
+   *              The number of milliseconds since Jan 1, 1970.
+   * @throws IOException IO failure
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
-   * Create a snapshot
+   * Create a snapshot.
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
-  
+
-   * Rename a snapshot
+   * Rename a snapshot.
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-  
+
-   * Delete a snapshot of a directory
+   * Delete a snapshot of a directory.
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-  
+
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * @param aclSpec List<AclEntry> describing entries to remove
+   * @param aclSpec List describing entries to remove
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * @param aclSpec List<AclEntry> describing modifications, must include entries
+   * @param aclSpec List describing modifications, which must include entries
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * <p/>
+   * <p>
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * <p/>
+   * <p>
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * <p/>
+   * <p>
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * <p/>
+   * <p>
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * <p/>
+   * <p>
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * <p/>
+   * <p>
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * <p/>
+   * <p>
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * @throws IOException
+   * @throws IOException IO failure
+   * @throws UnsupportedOperationException if the operation is unsupported
+   *         (default outcome).
-   * @return the default implementation returns "/user/$USER/.Trash".
+   * @return the default implementation returns {@code /user/$USER/.Trash}
-   *         /user/$USER/.Trash exists.
+   *         {@code /user/$USER/.Trash} exists.
-      LOG.warn("Cannot get all trash roots", e);
+      LOGGER.warn("Cannot get all trash roots", e);
+  /**
+   * Filesystems listed as services.
+   */
-    SERVICE_FILE_SYSTEMS = new HashMap<String, Class<? extends FileSystem>>();
+      SERVICE_FILE_SYSTEMS = new HashMap<>();
+  /**
+   * Load the filesystem declarations from service resources.
+   * This is a synchronized operation.
+   */
+    LOGGER.debug("Loading filesystems");
-          FileSystem fs = null;
+          FileSystem fs;
+              if (LOGGER.isDebugEnabled()) {
+                LOGGER.debug("{}:// = {} from {}",
+                    fs.getScheme(), fs.getClass(),
+                    ClassUtil.findContainingJar(fs.getClass()));
+              }
-              LOG.warn("Cannot load: " + fs + " from " +
-                  ClassUtil.findContainingJar(fs.getClass()), e);
+              LOGGER.warn("Cannot load: {} from {}", fs,
+                  ClassUtil.findContainingJar(fs.getClass()));
+              LOGGER.info("Full exception loading: {}", fs, e);
+  /**
+   * Get the FileSystem implementation class of a filesystem.
+   * This triggers a scan and load of all FileSystem implementations listed as
+   * services and discovered via the {@link ServiceLoader}
+   * @param scheme URL scheme of FS
+   * @param conf configuration: can be null, in which case the check for
+   * a filesystem binding declaration in the configuration is skipped.
+   * @return the filesystem
+   * @throws UnsupportedFileSystemException if there was no known implementation
+   *         for the scheme.
+   * @throws IOException if the filesystem could not be loaded
+   */
+    LOGGER.debug("Looking for FS supporting {}", scheme);
-      clazz = (Class<? extends FileSystem>) conf.getClass("fs." + scheme + ".impl", null);
+      String property = "fs." + scheme + ".impl";
+      LOGGER.debug("looking for configuration option {}", property);
+      clazz = (Class<? extends FileSystem>) conf.getClass(
+          property, null);
+    } else {
+      LOGGER.debug("No configuration: skipping check for fs.{}.impl", scheme);
+      LOGGER.debug("Looking in service filesystems for implementation class");
+    } else {
+      LOGGER.debug("Filesystem {} defined in configuration option", scheme);
-      throw new IOException("No FileSystem for scheme: " + scheme);
+      throw new UnsupportedFileSystemException("No FileSystem for scheme "
+          + "\"" + scheme + "\"");
+    LOGGER.debug("FS for {} is {}", scheme, clazz);
-  private static FileSystem createFileSystem(URI uri, Configuration conf
-      ) throws IOException {
+  /**
+   * Create and initialize a new instance of a FileSystem.
+   * @param uri URI containing the FS schema and FS details
+   * @param conf configuration to use to look for the FS instance declaration
+   * and to pass to the {@link FileSystem#initialize(URI, Configuration)}.
+   * @return the initialized filesystem.
+   * @throws IOException problems loading or initializing the FileSystem
+   */
+  private static FileSystem createFileSystem(URI uri, Configuration conf)
+      throws IOException {
-    TraceScope scope = tracer.newScope("FileSystem#createFileSystem");
-    scope.addKVAnnotation("scheme", uri.getScheme());
-    try {
+    try(TraceScope scope = tracer.newScope("FileSystem#createFileSystem")) {
+      scope.addKVAnnotation("scheme", uri.getScheme());
-    } finally {
-      scope.close();
-  /** Caching FileSystem objects */
+  /** Caching FileSystem objects. */
-    private final Map<Key, FileSystem> map = new HashMap<Key, FileSystem>();
-    private final Set<Key> toAutoClose = new HashSet<Key>();
+    private final Map<Key, FileSystem> map = new HashMap<>();
+    private final Set<Key> toAutoClose = new HashSet<>();
-    /** A variable that makes all objects in the cache unique */
+    /** A variable that makes all objects in the cache unique. */
-    /** The objects inserted into the cache using this method are all unique */
+    /** The objects inserted into the cache using this method are all unique. */
-    private FileSystem getInternal(URI uri, Configuration conf, Key key) throws IOException{
+    /**
+     * Get the FS instance if the key maps to an instance, creating and
+     * initializing the FS if it is not found.
+     * If this is the first entry in the map and the JVM is not shutting down,
+     * this registers a shutdown hook to close filesystems, and adds this
+     * FS to the {@code toAutoClose} set if {@code "fs.automatic.close"}
+     * is set in the configuration (default: true).
+     * @param uri filesystem URI
+     * @param conf configuration
+     * @param key key to store/retrieve this FileSystem in the cache
+     * @return a cached or newly instantiated FileSystem.
+     * @throws IOException
+     */
+    private FileSystem getInternal(URI uri, Configuration conf, Key key)
+        throws IOException{
-        
+
+    /**
+     * Close all FileSystems in the cache, whether they are marked for
+     * automatic closing or not.
+     * @throws IOException a problem arose closing one or more FileSystem.
+     */
+     * @throws IOException a problem arose closing one or more FileSystem.
-      List<IOException> exceptions = new ArrayList<IOException>();
+      List<IOException> exceptions = new ArrayList<>();
-      List<Key> keys = new ArrayList<Key>();
+      List<Key> keys = new ArrayList<>();
-          LOG.info("FileSystem.Cache.closeAll() threw an exception:\n" + e);
+          LOGGER.info("FileSystem.Cache.closeAll() threw an exception:\n" + e);
-      List<FileSystem> targetFSList = new ArrayList<FileSystem>();
-      //Make a pass over the list and collect the filesystems to close
+      List<FileSystem> targetFSList = new ArrayList<>(map.entrySet().size());
+      //Make a pass over the list and collect the FileSystems to close
-          targetFSList.add(fs);   
+          targetFSList.add(fs);
-      List<IOException> exceptions = new ArrayList<IOException>();
+      List<IOException> exceptions = new ArrayList<>();
-        
+
-        return a == b || (a != null && a.equals(b));        
+        return a == b || (a != null && a.equals(b));
-        if (obj != null && obj instanceof Key) {
+        if (obj instanceof Key) {
-        return false;        
+        return false;
-        return "("+ugi.toString() + ")@" + scheme + "://" + authority;        
+        return "("+ugi.toString() + ")@" + scheme + "://" + authority;
-  
+
-   * 
-   * Since there is only one of these objects per FileSystem, there will 
+   *
+   * Since there is only one of these objects per FileSystem, there will
-   * 
-   * Each thread writes to its own thread-local area of memory.  This removes 
+   *
+   * Each thread writes to its own thread-local area of memory.  This removes
-   * statistics, the reader thread totals up the contents of all of the 
+   * statistics, the reader thread totals up the contents of all of the
-     * 
+     *
-      
+
-      
+
-      
+
-      
+
-      
+
+    @SuppressWarnings("ThreadLocalNotStaticFinal")
-      STATS_DATA_REF_QUEUE = new ReferenceQueue<Thread>();
+      STATS_DATA_REF_QUEUE = new ReferenceQueue<>();
-      this.threadData = new ThreadLocal<StatisticsData>();
-      this.allData = new HashSet<StatisticsDataReference>();
+      this.threadData = new ThreadLocal<>();
+      this.allData = new HashSet<>();
-     * 
+     *
-      this.threadData = new ThreadLocal<StatisticsData>();
-      this.allData = new HashSet<StatisticsDataReference>();
+      this.threadData = new ThreadLocal<>();
+      this.allData = new HashSet<>();
-    private class StatisticsDataReference extends WeakReference<Thread> {
+    private final class StatisticsDataReference extends WeakReference<Thread> {
-      public StatisticsDataReference(StatisticsData data, Thread thread) {
+      private StatisticsDataReference(StatisticsData data, Thread thread) {
-            LOG.warn("Cleaner thread interrupted, will stop", ie);
+            LOGGER.warn("Cleaner thread interrupted, will stop", ie);
-            LOG.warn("Exception in the cleaner thread but it will continue to "
-                + "run", th);
+            LOGGER.warn("Exception in the cleaner thread but it will" +
+                " continue to run", th);
-     * Increment the bytes read in the statistics
+     * Increment the bytes read in the statistics.
-    
+
-     * Increment the bytes written in the statistics
+     * Increment the bytes written in the statistics.
-    
+
-     * Increment the number of read operations
+     * Increment the number of read operations.
-     * Increment the number of large read operations
+     * Increment the number of large read operations.
-     * Increment the number of write operations
+     * Increment the number of write operations.
-     * Finally, at the end, we will call aggregate to get the final total. 
+     * Finally, at the end, we will call aggregate to get the final total.
-     * Get the total number of bytes read
+     * Get the total number of bytes read.
-    
+
-     * Get the total number of bytes written
+     * Get the total number of bytes written.
-    
+
-     * Get the number of file system read operations such as list files
+     * Get the number of file system read operations such as list files.
-     * under a large directory
+     * under a large directory.
-     * Get the number of file system write operations such as create, append 
+     * Get the number of file system write operations such as create, append
-     * Get all statistics data
+     * Get all statistics data.
-    
+
-  
+
-    Map<String, Statistics> result = new HashMap<String, Statistics>();
+    Map<String, Statistics> result = new HashMap<>();
-    return new ArrayList<Statistics>(statisticsTable.values());
+    return new ArrayList<>(statisticsTable.values());
-  
+
-   * Get the statistics for a particular file system
+   * Get the statistics for a particular file system.
-  
+
-   * Reset all statistics for all file systems
+   * Reset all statistics for all file systems.
-   * Print all statistics for all file systems
+   * Print all statistics for all file systems to {@code System.out}
-    for (Map.Entry<Class<? extends FileSystem>, Statistics> pair: 
+    for (Map.Entry<Class<? extends FileSystem>, Statistics> pair:
-      System.out.println("  FileSystem " + pair.getKey().getName() + 
+      System.out.println("  FileSystem " + pair.getKey().getName() +
-  private static Configuration conf = null;
-

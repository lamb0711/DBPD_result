HDFS-2693. Fix synchronization issues around state transition. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1221582 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.NameNode.OperationCategory;
+import org.apache.hadoop.ipc.StandbyException;
+  
+  void checkOperation(OperationCategory op) throws StandbyException {
+    haContext.checkOperation(op);
+  }
+  
-  FsServerDefaults getServerDefaults() {
+  FsServerDefaults getServerDefaults() throws StandbyException {
+    checkOperation(OperationCategory.READ);
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
-
-      // if the namenode is in safemode, then do not update access time
-      if (isInSafeMode()) {
-        doAccessTime = false;
-      }
-
+        checkOperation(OperationCategory.READ);
+
+        // if the namenode is in safemode, then do not update access time
+        if (isInSafeMode()) {
+          doAccessTime = false;
+        }
+
+      checkOperation(OperationCategory.WRITE);
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.READ);
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+      checkOperation(OperationCategory.WRITE);
+      checkOperation(OperationCategory.WRITE);
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+   * @throws StandbyException 
-    throws AccessControlException, UnresolvedLinkException {
+    throws AccessControlException, UnresolvedLinkException,
+           StandbyException {
+      checkOperation(OperationCategory.READ);
+
+      checkOperation(OperationCategory.WRITE);
+
-      FileNotFoundException, UnresolvedLinkException {
+      FileNotFoundException, UnresolvedLinkException, StandbyException {
+      checkOperation(OperationCategory.READ);
+
+      checkOperation(OperationCategory.WRITE);
+      checkOperation(OperationCategory.WRITE);
+      checkOperation(OperationCategory.WRITE);
+      if (haContext.getState().equals(NameNode.STANDBY_STATE)) {
+        // TODO(HA) we'll never get here, since we check for WRITE operation above!
+        if (isGenStampInFuture(newgenerationstamp)) {
+          LOG.info("Required GS=" + newgenerationstamp
+              + ", Queuing commitBlockSynchronization message");
+          getPendingDataNodeMessages().queueMessage(
+              new PendingDataNodeMessages.CommitBlockSynchronizationMessage(
+                  lastblock, newgenerationstamp, newlength, closeFile, deleteblock,
+                  newtargets, newgenerationstamp));
+          return;
+        }
+      }
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.READ);
+
+      checkOperation(OperationCategory.CHECKPOINT);
+
+      checkOperation(OperationCategory.CHECKPOINT);
+
+   * Client is reporting some bad block locations.
+   */
+  void reportBadBlocks(LocatedBlock[] blocks) throws IOException {
+    writeLock();
+    try {
+      checkOperation(OperationCategory.WRITE);
+      
+      NameNode.stateChangeLog.info("*DIR* NameNode.reportBadBlocks");
+      for (int i = 0; i < blocks.length; i++) {
+        ExtendedBlock blk = blocks[i].getBlock();
+        DatanodeInfo[] nodes = blocks[i].getLocations();
+        for (int j = 0; j < nodes.length; j++) {
+          DatanodeInfo dn = nodes[j];
+          blockManager.findAndMarkBlockAsCorrupt(blk, dn);
+        }
+      }
+    } finally {
+      writeUnlock();
+    }
+  }
+
+  /**
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.READ);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+      checkOperation(OperationCategory.WRITE);
+
+  
+  @VisibleForTesting
+  void setFsLockForTests(ReentrantReadWriteLock lock) {
+    this.fsLock = lock;
+  }
+  
+  @VisibleForTesting
+  ReentrantReadWriteLock getFsLockForTests() {
+    return fsLock;
+  }

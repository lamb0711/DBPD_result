HADOOP-13529. Do some code refactoring. Contributed by Genmao Yu.

-import com.aliyun.oss.ClientException;
-import com.aliyun.oss.common.auth.CredentialsProvider;
-import com.aliyun.oss.common.auth.DefaultCredentialProvider;
-import com.aliyun.oss.common.auth.DefaultCredentials;
-import java.io.ByteArrayInputStream;
-import org.apache.commons.lang.StringUtils;
-import org.apache.hadoop.fs.aliyun.oss.AliyunOSSUtils.UserInfo;
-import org.apache.hadoop.security.ProviderUtils;
-import com.aliyun.oss.ClientConfiguration;
-import com.aliyun.oss.OSSClient;
-import com.aliyun.oss.OSSException;
-import com.aliyun.oss.common.comm.Protocol;
-import com.aliyun.oss.model.AbortMultipartUploadRequest;
-import com.aliyun.oss.model.CannedAccessControlList;
-import com.aliyun.oss.model.CompleteMultipartUploadRequest;
-import com.aliyun.oss.model.CompleteMultipartUploadResult;
-import com.aliyun.oss.model.CopyObjectResult;
-import com.aliyun.oss.model.DeleteObjectsRequest;
-import com.aliyun.oss.model.InitiateMultipartUploadRequest;
-import com.aliyun.oss.model.InitiateMultipartUploadResult;
-import com.aliyun.oss.model.ListObjectsRequest;
-import com.aliyun.oss.model.PartETag;
-import com.aliyun.oss.model.UploadPartCopyRequest;
-import com.aliyun.oss.model.UploadPartCopyResult;
+
-  private OSSClient ossClient;
-  private String bucketName;
-  private long uploadPartSize;
-  private long multipartThreshold;
+  private AliyunOSSFileSystemStore store;
-  private String serverSideEncryptionAlgorithm;
-      if (ossClient != null) {
-        ossClient.shutdown();
-      }
+      store.close();
-        ossClient, bucketName, key, progress, statistics,
-        serverSideEncryptionAlgorithm), (Statistics)(null));
+        store, key, progress, statistics), (Statistics)(null));
-    FileStatus status;
-      status = getFileStatus(path);
+      return innerDelete(getFileStatus(path), recursive);
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Couldn't delete " + path + ": Does not exist!");
-      }
+      LOG.debug("Couldn't delete {} - does not exist", path);
+  }
-    String key = pathToKey(status.getPath());
+  /**
+   * Delete an object. See {@link #delete(Path, boolean)}.
+   *
+   * @param status fileStatus object
+   * @param recursive if path is a directory and set to
+   * true, the directory is deleted else throws an exception. In
+   * case of a file the recursive can be set to either true or false.
+   * @return  true if delete is successful else false.
+   * @throws IOException due to inability to delete a directory or file.
+   */
+  private boolean innerDelete(FileStatus status, boolean recursive)
+      throws IOException {
+    Path f = status.getPath();
+    String key = pathToKey(f);
-          throw new IOException("Cannot remove directory" + path +
+          throw new IOException("Cannot remove directory " + f +
-          ossClient.deleteObject(bucketName, key);
-          statistics.incrementWriteOps(1);
+          store.deleteObject(key);
-        ListObjectsRequest listRequest = new ListObjectsRequest(bucketName);
-        listRequest.setPrefix(key);
-        listRequest.setMaxKeys(maxKeys);
-
-        while (true) {
-          ObjectListing objects = ossClient.listObjects(listRequest);
-          statistics.incrementReadOps(1);
-          List<String> keysToDelete = new ArrayList<String>();
-          for (OSSObjectSummary objectSummary : objects.getObjectSummaries()) {
-            keysToDelete.add(objectSummary.getKey());
-          }
-          DeleteObjectsRequest deleteRequest =
-              new DeleteObjectsRequest(bucketName);
-          deleteRequest.setKeys(keysToDelete);
-          ossClient.deleteObjects(deleteRequest);
-          statistics.incrementWriteOps(1);
-          if (objects.isTruncated()) {
-            listRequest.setMarker(objects.getNextMarker());
-          } else {
-            break;
-          }
-        }
+        store.deleteDirs(key);
-      ossClient.deleteObject(bucketName, key);
-      statistics.incrementWriteOps(1);
+      store.deleteObject(key);
-    //TODO: optimize logic here
+
+    createFakeDirectoryIfNecessary(f);
+    return true;
+  }
+
+  private void createFakeDirectoryIfNecessary(Path f) throws IOException {
-      Path pPath = status.getPath().getParent();
+      Path pPath = f.getParent();
-      if (pStatus.isDirectory()) {
-        return true;
-      } else {
+      if (pStatus.isFile()) {
-      return mkdir(bucketName, pathToKey(status.getPath().getParent()));
+      mkdir(pathToKey(f.getParent()));
-    ObjectMetadata meta = getObjectMetadata(key);
+    ObjectMetadata meta = store.getObjectMetadata(key);
-      meta = getObjectMetadata(key);
+      meta = store.getObjectMetadata(key);
-      // Case: dir + "/" + file
-      ListObjectsRequest listRequest = new ListObjectsRequest(bucketName);
-      listRequest.setPrefix(key);
-      listRequest.setDelimiter("/");
-      listRequest.setMaxKeys(1);
-
-      ObjectListing listing = ossClient.listObjects(listRequest);
-      statistics.incrementReadOps(1);
+      ObjectListing listing = store.listObjects(key, 1, "/", null);
-  /**
-   * Return object metadata given object key.
-   *
-   * @param key object key
-   * @return return null if key does not exist
-   */
-  private ObjectMetadata getObjectMetadata(String key) {
-    try {
-      return ossClient.getObjectMetadata(bucketName, key);
-    } catch (OSSException osse) {
-      return null;
-    } finally {
-      statistics.incrementReadOps(1);
-    }
-  }
-
-   *
-    workingDir =
-        new Path("/user",
-            System.getProperty("user.name")).makeQualified(uri, null);
+    workingDir = new Path("/user",
+        System.getProperty("user.name")).makeQualified(uri, null);
-    bucketName = name.getHost();
-
-    ClientConfiguration clientConf = new ClientConfiguration();
-    clientConf.setMaxConnections(conf.getInt(MAXIMUM_CONNECTIONS_KEY,
-        MAXIMUM_CONNECTIONS_DEFAULT));
-    boolean secureConnections = conf.getBoolean(SECURE_CONNECTIONS_KEY,
-        SECURE_CONNECTIONS_DEFAULT);
-    clientConf.setProtocol(secureConnections ? Protocol.HTTPS : Protocol.HTTP);
-    clientConf.setMaxErrorRetry(conf.getInt(MAX_ERROR_RETRIES_KEY,
-        MAX_ERROR_RETRIES_DEFAULT));
-    clientConf.setConnectionTimeout(conf.getInt(ESTABLISH_TIMEOUT_KEY,
-        ESTABLISH_TIMEOUT_DEFAULT));
-    clientConf.setSocketTimeout(conf.getInt(SOCKET_TIMEOUT_KEY,
-        SOCKET_TIMEOUT_DEFAULT));
-
-    String proxyHost = conf.getTrimmed(PROXY_HOST_KEY, "");
-    int proxyPort = conf.getInt(PROXY_PORT_KEY, -1);
-    if (!proxyHost.isEmpty()) {
-      clientConf.setProxyHost(proxyHost);
-      if (proxyPort >= 0) {
-        clientConf.setProxyPort(proxyPort);
-      } else {
-        if (secureConnections) {
-          LOG.warn("Proxy host set without port. Using HTTPS default 443");
-          clientConf.setProxyPort(443);
-        } else {
-          LOG.warn("Proxy host set without port. Using HTTP default 80");
-          clientConf.setProxyPort(80);
-        }
-      }
-      String proxyUsername = conf.getTrimmed(PROXY_USERNAME_KEY);
-      String proxyPassword = conf.getTrimmed(PROXY_PASSWORD_KEY);
-      if ((proxyUsername == null) != (proxyPassword == null)) {
-        String msg = "Proxy error: " + PROXY_USERNAME_KEY + " or " +
-            PROXY_PASSWORD_KEY + " set without the other.";
-        LOG.error(msg);
-        throw new IllegalArgumentException(msg);
-      }
-      clientConf.setProxyUsername(proxyUsername);
-      clientConf.setProxyPassword(proxyPassword);
-      clientConf.setProxyDomain(conf.getTrimmed(PROXY_DOMAIN_KEY));
-      clientConf.setProxyWorkstation(conf.getTrimmed(PROXY_WORKSTATION_KEY));
-    } else if (proxyPort >= 0) {
-      String msg = "Proxy error: " + PROXY_PORT_KEY + " set without " +
-          PROXY_HOST_KEY;
-      LOG.error(msg);
-      throw new IllegalArgumentException(msg);
-    }
-
-    String endPoint = conf.getTrimmed(ENDPOINT_KEY, "");
-    ossClient =
-        new OSSClient(endPoint, getCredentialsProvider(name, conf), clientConf);
-
+    store = new AliyunOSSFileSystemStore();
+    store.initialize(name, conf, statistics);
-    uploadPartSize = conf.getLong(MULTIPART_UPLOAD_SIZE_KEY,
-        MULTIPART_UPLOAD_SIZE_DEFAULT);
-    multipartThreshold = conf.getLong(MIN_MULTIPART_UPLOAD_THRESHOLD_KEY,
-        MIN_MULTIPART_UPLOAD_THRESHOLD_DEFAULT);
-
-    if (uploadPartSize < 5 * 1024 * 1024) {
-      LOG.warn(MULTIPART_UPLOAD_SIZE_KEY + " must be at least 5 MB");
-      uploadPartSize = 5 * 1024 * 1024;
-    }
-
-    if (multipartThreshold < 5 * 1024 * 1024) {
-      LOG.warn(MIN_MULTIPART_UPLOAD_THRESHOLD_KEY + " must be at least 5 MB");
-      multipartThreshold = 5 * 1024 * 1024;
-    }
-
-    if (multipartThreshold > 1024 * 1024 * 1024) {
-      LOG.warn(MIN_MULTIPART_UPLOAD_THRESHOLD_KEY + " must be less than 1 GB");
-      multipartThreshold = 1024 * 1024 * 1024;
-    }
-
-    String cannedACLName = conf.get(CANNED_ACL_KEY, CANNED_ACL_DEFAULT);
-    if (!cannedACLName.isEmpty()) {
-      CannedAccessControlList cannedACL =
-          CannedAccessControlList.valueOf(cannedACLName);
-      ossClient.setBucketAcl(bucketName, cannedACL);
-    }
-
-    serverSideEncryptionAlgorithm =
-        conf.get(SERVER_SIDE_ENCRYPTION_ALGORITHM_KEY, "");
-
-   * Create the default credential provider, or load in one explicitly
-   * identified in the configuration.
-   * @param name the uri of the file system
-   * @param conf configuration
-   * @return a credential provider
-   * @throws IOException on any problem. Class construction issues may be
-   * nested inside the IOE.
-   */
-  private CredentialsProvider getCredentialsProvider(URI name,
-      Configuration conf) throws IOException {
-    CredentialsProvider credentials;
-
-    String className = conf.getTrimmed(ALIYUN_OSS_CREDENTIALS_PROVIDER_KEY);
-    if (StringUtils.isEmpty(className)) {
-      Configuration newConf =
-          ProviderUtils.excludeIncompatibleCredentialProviders(conf,
-              AliyunOSSFileSystem.class);
-      String accessKey =
-          AliyunOSSUtils.getPassword(newConf, ACCESS_KEY,
-              UserInfo.EMPTY.getUser());
-      String secretKey =
-          AliyunOSSUtils.getPassword(newConf, SECRET_KEY,
-              UserInfo.EMPTY.getPassword());
-      credentials =
-          new DefaultCredentialProvider(
-              new DefaultCredentials(accessKey, secretKey));
-
-    } else {
-      try {
-        LOG.debug("Credential provider class is:" + className);
-        Class<?> credClass = Class.forName(className);
-        try {
-          credentials =
-              (CredentialsProvider)credClass.getDeclaredConstructor(
-                  URI.class, Configuration.class).newInstance(this.uri, conf);
-        } catch (NoSuchMethodException | SecurityException e) {
-          credentials =
-              (CredentialsProvider)credClass.getDeclaredConstructor()
-              .newInstance();
-        }
-      } catch (ClassNotFoundException e) {
-        throw new IOException(className + " not found.", e);
-      } catch (NoSuchMethodException | SecurityException e) {
-        throw new IOException(String.format("%s constructor exception.  A " +
-            "class specified in %s must provide an accessible constructor " +
-            "accepting URI and Configuration, or an accessible default " +
-            "constructor.", className, ALIYUN_OSS_CREDENTIALS_PROVIDER_KEY), e);
-      } catch (ReflectiveOperationException | IllegalArgumentException e) {
-        throw new IOException(className + " instantiation exception.", e);
-      }
-    }
-
-    return credentials;
-  }
-
-  /**
-   * Turns a path (relative or otherwise) into an OSS key.
+   * Turn a path (relative or otherwise) into an OSS key.
-   * @param path the path of the file
-   * @return the key of the object that represent the file
+   * @param path the path of the file.
+   * @return the key of the object that represents the file.
-      ListObjectsRequest listObjectsRequest =
-          new ListObjectsRequest(bucketName);
-      listObjectsRequest.setPrefix(key);
-      listObjectsRequest.setDelimiter("/");
-      listObjectsRequest.setMaxKeys(maxKeys);
-
+      ObjectListing objects = store.listObjects(key, maxKeys, "/", null);
-        ObjectListing objects = ossClient.listObjects(listObjectsRequest);
-          listObjectsRequest.setMarker(objects.getNextMarker());
+          objects = store.listObjects(key, maxKeys, "/",
+              objects.getNextMarker());
-   * @param bucket the bucket this directory belongs to
-   * @return true if directory successfully created
+   * @return true if directory is successfully created
-  private boolean mkdir(final String bucket, final String key)
-      throws IOException {
+  private boolean mkdir(final String key) throws IOException {
-    ObjectMetadata dirMeta = new ObjectMetadata();
-    byte[] buffer = new byte[0];
-    ByteArrayInputStream in = new ByteArrayInputStream(buffer);
-    dirMeta.setContentLength(0);
-    try {
-      ossClient.putObject(bucket, dirName, in, dirMeta);
-      return true;
-    } finally {
-      in.close();
-    }
+    store.storeEmptyFile(dirName);
+    return true;
-      return mkdir(bucketName, key);
+      return mkdir(key);
-   * @param path the path to be checked
+   * @param path the path to be checked.
-    return new FSDataInputStream(new AliyunOSSInputStream(getConf(), ossClient,
-        bucketName, pathToKey(path), fileStatus.getLen(), statistics));
+    return new FSDataInputStream(new AliyunOSSInputStream(getConf(), store,
+        pathToKey(path), fileStatus.getLen(), statistics));
-    if (srcPath.equals(dstPath)) {
-      return true;
-    } else {
-      return delete(srcPath, true);
-    }
+
+    return srcPath.equals(dstPath) || delete(srcPath, true);
-   * (the caller should make sure srcPath is a file and dstPath is valid.)
+   * (the caller should make sure srcPath is a file and dstPath is valid)
-   * @param srcPath source path
-   * @param dstPath destination path
-   * @return true if successfully copied
+   * @param srcPath source path.
+   * @param dstPath destination path.
+   * @return true if file is successfully copied.
-    return copyFile(srcKey, dstKey);
-  }
-
-  /**
-   * Copy an object from source key to destination key.
-   *
-   * @param srcKey source key
-   * @param dstKey destination key
-   * @return true if successfully copied
-   */
-  private boolean copyFile(String srcKey, String dstKey) {
-    ObjectMetadata objectMeta =
-        ossClient.getObjectMetadata(bucketName, srcKey);
-    long dataLen = objectMeta.getContentLength();
-    if (dataLen <= multipartThreshold) {
-      return singleCopy(srcKey, dstKey);
-    } else {
-      return multipartCopy(srcKey, dataLen, dstKey);
-    }
-  }
-
-  /**
-   * Use single copy to copy an oss object.
-   *
-   * @param srcKey source key
-   * @param dstKey destination key
-   * @return true if successfully copied
-   * (the caller should make sure srcPath is a file and dstPath is valid)
-   */
-  private boolean singleCopy(String srcKey, String dstKey) {
-    CopyObjectResult copyResult =
-        ossClient.copyObject(bucketName, srcKey, bucketName, dstKey);
-    LOG.debug(copyResult.getETag());
-    return true;
-  }
-
-  /**
-   * Use multipart copy to copy an oss object.
-   * (the caller should make sure srcPath is a file and dstPath is valid)
-   *
-   * @param srcKey source key
-   * @param dataLen data size of the object to copy
-   * @param dstKey destination key
-   * @return true if successfully copied, or false if upload is aborted
-   */
-  private boolean multipartCopy(String srcKey, long dataLen, String dstKey) {
-    int partNum = (int)(dataLen / uploadPartSize);
-    if (dataLen % uploadPartSize != 0) {
-      partNum++;
-    }
-    InitiateMultipartUploadRequest initiateMultipartUploadRequest =
-        new InitiateMultipartUploadRequest(bucketName, dstKey);
-    ObjectMetadata meta = new ObjectMetadata();
-    if (!serverSideEncryptionAlgorithm.isEmpty()) {
-      meta.setServerSideEncryption(serverSideEncryptionAlgorithm);
-    }
-    initiateMultipartUploadRequest.setObjectMetadata(meta);
-    InitiateMultipartUploadResult initiateMultipartUploadResult =
-        ossClient.initiateMultipartUpload(initiateMultipartUploadRequest);
-    String uploadId = initiateMultipartUploadResult.getUploadId();
-    List<PartETag> partETags = new ArrayList<PartETag>();
-    try {
-      for (int i = 0; i < partNum; i++) {
-        long skipBytes = uploadPartSize * i;
-        long size = (uploadPartSize < dataLen - skipBytes) ?
-            uploadPartSize : dataLen - skipBytes;
-        UploadPartCopyRequest partCopyRequest = new UploadPartCopyRequest();
-        partCopyRequest.setSourceBucketName(bucketName);
-        partCopyRequest.setSourceKey(srcKey);
-        partCopyRequest.setBucketName(bucketName);
-        partCopyRequest.setKey(dstKey);
-        partCopyRequest.setUploadId(uploadId);
-        partCopyRequest.setPartSize(size);
-        partCopyRequest.setBeginIndex(skipBytes);
-        partCopyRequest.setPartNumber(i + 1);
-        UploadPartCopyResult partCopyResult =
-            ossClient.uploadPartCopy(partCopyRequest);
-        statistics.incrementWriteOps(1);
-        partETags.add(partCopyResult.getPartETag());
-      }
-      CompleteMultipartUploadRequest completeMultipartUploadRequest =
-          new CompleteMultipartUploadRequest(bucketName, dstKey,
-          uploadId, partETags);
-      CompleteMultipartUploadResult completeMultipartUploadResult =
-          ossClient.completeMultipartUpload(completeMultipartUploadRequest);
-      LOG.debug(completeMultipartUploadResult.getETag());
-      return true;
-    } catch (OSSException | ClientException e) {
-      AbortMultipartUploadRequest abortMultipartUploadRequest =
-          new AbortMultipartUploadRequest(bucketName, dstKey, uploadId);
-      ossClient.abortMultipartUpload(abortMultipartUploadRequest);
-      return false;
-    }
+    return store.copyFile(srcKey, dstKey);
-   * @param srcPath source path
-   * @param dstPath destination path
-   * @return true if successfully copied
+   * @param srcPath source path.
+   * @param dstPath destination path.
+   * @return true if directory is successfully copied.
-    ListObjectsRequest listObjectsRequest = new ListObjectsRequest(bucketName);
-    listObjectsRequest.setPrefix(srcKey);
-    listObjectsRequest.setMaxKeys(maxKeys);
-
-    ObjectListing objects = ossClient.listObjects(listObjectsRequest);
+    ObjectListing objects = store.listObjects(srcKey, maxKeys, null, null);
-        copyFile(objectSummary.getKey(), newKey);
+        store.copyFile(objectSummary.getKey(), newKey);
-        listObjectsRequest.setMarker(objects.getNextMarker());
+        objects = store.listObjects(srcKey, maxKeys, null,
+            objects.getNextMarker());
+  public AliyunOSSFileSystemStore getStore() {
+    return store;
+  }

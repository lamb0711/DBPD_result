HDFS-2273.  Refactor BlockManager.recentInvalidateSets to a new class.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1160475 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashSet;
-  private volatile long pendingDeletionBlocksCount = 0L;
-    return pendingDeletionBlocksCount;
+    return invalidateBlocks.numBlocks();
-  //
-  // Keeps a Collection for every named machine containing
-  // blocks that have recently been invalidated and are thought to live
-  // on the machine in question.
-  // Mapping: StorageID -> ArrayList<Block>
-  //
-  private final Map<String, Collection<Block>> recentInvalidateSets =
-    new TreeMap<String, Collection<Block>>();
+  /** Blocks to be invalidated. */
+  private final InvalidateBlocks invalidateBlocks;
+    invalidateBlocks = new InvalidateBlocks(datanodeManager);
+  /** Dump meta data to out. */
+    assert namesystem.hasWriteLock();
-    dumpRecentInvalidateSets(out);
+    invalidateBlocks.dump(out);
-      removeFromInvalidates(datanodeId, oldBlock);
+      invalidateBlocks.remove(datanodeId, oldBlock);
-      if( ! belongsToInvalidates(storageID, block)) {
+      if(!invalidateBlocks.contains(storageID, block)) {
-    removeFromInvalidates(node.getStorageID());
-  }
-  
-  private void removeFromInvalidates(String storageID, Block block) {
-    synchronized(recentInvalidateSets) {
-      Collection<Block> v = recentInvalidateSets.get(storageID);
-      if (v != null && v.remove(block)) {
-        pendingDeletionBlocksCount--;
-        if (v.isEmpty()) {
-          recentInvalidateSets.remove(storageID);
-        }
-      }
-    }
-  }
-
-  boolean belongsToInvalidates(String storageID, Block block) {
-    Collection<Block> invalidateSet;
-    synchronized(recentInvalidateSets) {
-      invalidateSet = recentInvalidateSets.get(storageID);
-      return invalidateSet != null && invalidateSet.contains(block);
-    }
-  }
-
-  /**
-   * Adds block to list of blocks which will be invalidated on specified
-   * datanode
-   *
-   * @param b block
-   * @param dn datanode
-   * @param log true to create an entry in the log 
-   */
-  private void addToInvalidates(Block b, DatanodeInfo dn, boolean log) {
-    synchronized(recentInvalidateSets) {
-      Collection<Block> invalidateSet = recentInvalidateSets
-          .get(dn.getStorageID());
-      if (invalidateSet == null) {
-        invalidateSet = new HashSet<Block>();
-        recentInvalidateSets.put(dn.getStorageID(), invalidateSet);
-      }
-      if (invalidateSet.add(b)) {
-        pendingDeletionBlocksCount++;
-        if (log) {
-          NameNode.stateChangeLog.info("BLOCK* addToInvalidates: "
-              + b + " to " + dn.getName());
-        }
-      }
-    }
+    invalidateBlocks.remove(node.getStorageID());
-   *
-   * @param b block
-   * @param dn datanode
-  void addToInvalidates(Block b, DatanodeInfo dn) {
-    addToInvalidates(b, dn, true);
+  void addToInvalidates(final Block block, final DatanodeInfo datanode) {
+    invalidateBlocks.add(block, datanode, true);
-      addToInvalidates(b, node, false);
+      invalidateBlocks.add(b, node, false);
-   * dumps the contents of recentInvalidateSets
-   */
-  private void dumpRecentInvalidateSets(PrintWriter out) {
-    assert namesystem.hasWriteLock();
-    int size;
-    synchronized(recentInvalidateSets) {
-      size = recentInvalidateSets.values().size();
-    }
-    out.println("Metasave: Blocks " + pendingDeletionBlocksCount 
-        + " waiting deletion from " + size + " datanodes.");
-    if (size == 0) {
-      return;
-    }
-    synchronized(recentInvalidateSets) {
-      for(Map.Entry<String,Collection<Block>> entry : recentInvalidateSets.entrySet()) {
-        Collection<Block> blocks = entry.getValue();
-        if (blocks.size() > 0) {
-          out.println(datanodeManager.getDatanode(entry.getKey()).getName() + blocks);
-        }
-      }
-    }
-  }
-
-  /**
-    int numOfNodes;
-    ArrayList<String> keyArray;
+    final List<String> nodes = invalidateBlocks.getStorageIDs();
+    Collections.shuffle(nodes);
-    synchronized(recentInvalidateSets) {
-      numOfNodes = recentInvalidateSets.size();
-      // get an array of the keys
-      keyArray = new ArrayList<String>(recentInvalidateSets.keySet());
-    }
-
-    nodesToProcess = Math.min(numOfNodes, nodesToProcess);
-
-    // randomly pick up <i>nodesToProcess</i> nodes
-    // and put them at [0, nodesToProcess)
-    int remainingNodes = numOfNodes - nodesToProcess;
-    if (nodesToProcess < remainingNodes) {
-      for(int i=0; i<nodesToProcess; i++) {
-        int keyIndex = DFSUtil.getRandom().nextInt(numOfNodes-i)+i;
-        Collections.swap(keyArray, keyIndex, i); // swap to front
-      }
-    } else {
-      for(int i=0; i<remainingNodes; i++) {
-        int keyIndex = DFSUtil.getRandom().nextInt(numOfNodes-i);
-        Collections.swap(keyArray, keyIndex, numOfNodes-i-1); // swap to end
-      }
-    }
+    nodesToProcess = Math.min(nodes.size(), nodesToProcess);
-      blockCnt += invalidateWorkForOneNode(keyArray.get(nodeCnt));
+      blockCnt += invalidateWorkForOneNode(nodes.get(nodeCnt));
-    if(belongsToInvalidates(dn.getStorageID(), block)) {
+    if(invalidateBlocks.contains(dn.getStorageID(), block)) {
-    return blocksMap.size() - (int)pendingDeletionBlocksCount;
+    return blocksMap.size() - (int)invalidateBlocks.numBlocks();
-  /** Remove a datanode from the invalidatesSet */
-  private void removeFromInvalidates(String storageID) {
-    Collection<Block> blocks;
-    synchronized(recentInvalidateSets) {
-      blocks = recentInvalidateSets.remove(storageID);
-    }
-    if (blocks != null) {
-      pendingDeletionBlocksCount -= blocks.size();
-    }
-  }
-      final DatanodeDescriptor dn = datanodeManager.getDatanode(nodeId);
-      if (dn == null) {
-        removeFromInvalidates(nodeId);
-        return 0;
-      }
-
-      Collection<Block> invalidateSet;
-      ArrayList<Block> blocksToInvalidate;
-      synchronized(recentInvalidateSets) {
-        invalidateSet = recentInvalidateSets.get(nodeId);
-        if (invalidateSet == null)
-          return 0;
-
-        blocksToInvalidate = new ArrayList<Block>(
-          getDatanodeManager().blockInvalidateLimit);
-
-        // # blocks that can be sent in one message is limited
-        Iterator<Block> it = invalidateSet.iterator();
-        for (int blkCount = 0; blkCount < getDatanodeManager().blockInvalidateLimit
-            && it.hasNext(); blkCount++) {
-          blocksToInvalidate.add(it.next());
-          it.remove();
-        }
-
-        // If we send everything in this message, remove this node entry
-        if (!it.hasNext()) {
-          removeFromInvalidates(nodeId);
-        }
-
-        dn.addBlocksToBeInvalidated(blocksToInvalidate);
-
-        if (NameNode.stateChangeLog.isInfoEnabled()) {
-          StringBuilder blockList = new StringBuilder();
-          for (Block blk : blocksToInvalidate) {
-            blockList.append(' ');
-            blockList.append(blk);
-          }
-          NameNode.stateChangeLog.info("BLOCK* ask " + dn.getName()
-              + " to delete " + blockList);
-        }
-        pendingDeletionBlocksCount -= blocksToInvalidate.size();
-        return blocksToInvalidate.size();
-      }
+      return invalidateBlocks.invalidateWork(nodeId);

HDFS-10999. Introduce separate stats for Replicated and Erasure Coded Blocks apart from the current Aggregated stats. (Manoj Govindassamy via lei)

+import org.apache.hadoop.hdfs.protocol.BlocksStats;
+import org.apache.hadoop.hdfs.protocol.ECBlockGroupsStats;
+import org.apache.hadoop.hdfs.server.namenode.metrics.ECBlockGroupsStatsMBean;
+import org.apache.hadoop.hdfs.server.namenode.metrics.ReplicatedBlocksStatsMBean;
-  NameNodeMXBean {
+    NameNodeMXBean, ReplicatedBlocksStatsMBean, ECBlockGroupsStatsMBean {
-    stats[ClientProtocol.GET_STATS_UNDER_REPLICATED_IDX] = getUnderReplicatedBlocks();
-    stats[ClientProtocol.GET_STATS_CORRUPT_BLOCKS_IDX] = getCorruptReplicaBlocks();
-    stats[ClientProtocol.GET_STATS_MISSING_BLOCKS_IDX] = getMissingBlocksCount();
+    stats[ClientProtocol.GET_STATS_LOW_REDUNDANCY_IDX] =
+        getLowRedundancyBlocks();
+    stats[ClientProtocol.GET_STATS_CORRUPT_BLOCKS_IDX] =
+        getCorruptReplicaBlocks();
+    stats[ClientProtocol.GET_STATS_MISSING_BLOCKS_IDX] =
+        getMissingBlocksCount();
+  /**
+   * Get statistics pertaining to blocks of type {@link BlockType#CONTIGUOUS}
+   * in the filesystem.
+   * <p>
+   * @see ClientProtocol#getBlocksStats()
+   */
+  BlocksStats getBlocksStats() {
+    return new BlocksStats(getLowRedundancyBlocksStat(),
+        getCorruptBlocksStat(), getMissingBlocksStat(),
+        getMissingReplicationOneBlocksStat(), getBlocksBytesInFutureStat(),
+        getPendingDeletionBlocksStat());
+  }
+
+  /**
+   * Get statistics pertaining to blocks of type {@link BlockType#STRIPED}
+   * in the filesystem.
+   * <p>
+   * @see ClientProtocol#getECBlockGroupsStats()
+   */
+  ECBlockGroupsStats getECBlockGroupsStats() {
+    return new ECBlockGroupsStats(getLowRedundancyECBlockGroupsStat(),
+        getCorruptECBlockGroupsStat(), getMissingECBlockGroupsStat(),
+        getECBlocksBytesInFutureStat(), getPendingDeletionECBlockGroupsStat());
+  }
+
+  /**
+   * Get aggregated count of all blocks pending to be reconstructed.
+   */
+  @Deprecated
+  /**
+   * Get aggregated count of all blocks pending to be reconstructed.
+   */
+  public long getPendingReconstructionBlocks() {
+    return blockManager.getPendingReconstructionBlocksCount();
+  }
+
+  /**
+   * Get aggregated count of all blocks with low redundancy.
+   * @deprecated - Use {@link #getLowRedundancyBlocks()} instead.
+   */
+  @Override // FSNamesystemMBean
+  @Metric
+  @Deprecated
-    return blockManager.getUnderReplicatedBlocksCount();
+    return blockManager.getLowRedundancyBlocksCount();
+  }
+
+  /**
+   * Get aggregated count of all blocks with low redundancy.
+   */
+  @Override // FSNamesystemMBean
+  @Metric
+  public long getLowRedundancyBlocks() {
+    return blockManager.getLowRedundancyBlocksCount();
+  @Override // ReplicatedBlocksMBean
+  @Metric({"LowRedundancyReplicatedBlocks",
+      "Number of low redundancy replicated blocks"})
+  public long getLowRedundancyBlocksStat() {
+    return blockManager.getLowRedundancyBlocksStat();
+  }
+
+  @Override // ReplicatedBlocksMBean
+  @Metric({"CorruptReplicatedBlocks", "Number of corrupted replicated blocks"})
+  public long getCorruptBlocksStat() {
+    return blockManager.getCorruptBlocksStat();
+  }
+
+  @Override // ReplicatedBlocksMBean
+  @Metric({"MissingReplicatedBlocks", "Number of missing replicated blocks"})
+  public long getMissingBlocksStat() {
+    return blockManager.getMissingBlocksStat();
+  }
+
+  @Override // ReplicatedBlocksMBean
+  @Metric({"MissingReplicatedOneBlocks", "Number of missing replicated blocks" +
+      " with replication factor 1"})
+  public long getMissingReplicationOneBlocksStat() {
+    return blockManager.getMissingReplicationOneBlocksStat();
+  }
+
+  @Override // ReplicatedBlocksMBean
+  @Metric({"BytesReplicatedFutureBlocks", "Total bytes in replicated blocks " +
+      "with future generation stamp"})
+  public long getBlocksBytesInFutureStat() {
+    return blockManager.getBytesInFutureReplicatedBlocksStat();
+  }
+
+  @Override // ReplicatedBlocksMBean
+  @Metric({"PendingDeletionReplicatedBlocks", "Number of replicated blocks " +
+      "that are pending deletion"})
+  public long getPendingDeletionBlocksStat() {
+    return blockManager.getPendingDeletionBlocksStat();
+  }
+
+  @Override // ECBlockGroupsStatsMBean
+  @Metric({"LowRedundancyECBlockGroups", "Number of erasure coded block " +
+      "groups with low redundancy"})
+  public long getLowRedundancyECBlockGroupsStat() {
+    return blockManager.getLowRedundancyECBlockGroupsStat();
+  }
+
+  @Override // ECBlockGroupsStatsMBean
+  @Metric({"CorruptECBlockGroups", "Number of erasure coded block groups that" +
+      " are corrupt"})
+  public long getCorruptECBlockGroupsStat() {
+    return blockManager.getCorruptECBlockGroupsStat();
+  }
+
+  @Override // ECBlockGroupsStatsMBean
+  @Metric({"MissingECBlockGroups", "Number of erasure coded block groups that" +
+      " are missing"})
+  public long getMissingECBlockGroupsStat() {
+    return blockManager.getMissingECBlockGroupsStat();
+  }
+
+  @Override // ECBlockGroupsStatsMBean
+  @Metric({"BytesFutureECBlockGroups", "Total bytes in erasure coded block " +
+      "groups with future generation stamp"})
+  public long getECBlocksBytesInFutureStat() {
+    return blockManager.getBytesInFutureStripedBlocksStat();
+  }
+
+  @Override // ECBlockGroupsStatsMBean
+  @Metric({"PendingDeletionECBlockGroups", "Number of erasure coded block " +
+      "groups that are pending deletion"})
+  public long getPendingDeletionECBlockGroupsStat() {
+    return blockManager.getPendingDeletionECBlockGroupsStat();
+  }
+
-  private ObjectName mbeanName;
-  private ObjectName mxbeanName;
+  private ObjectName namesystemMBeanName, replicatedBlocksMBeanName,
+      ecBlockGroupsMBeanName, namenodeMXBeanName;
-   * Register the FSNamesystem MBean using the name
+   * Register following MBeans with their respective names.
+   * FSNamesystemMBean:
+   * ReplicatedBlocksStatsMBean:
+   *        "hadoop:service=NameNode,name=ReplicatedBlocksState"
+   * ECBlockGroupsStatsMBean:
+   *        "hadoop:service=NameNode,name=ECBlockGroupsState"
-      StandardMBean bean = new StandardMBean(this, FSNamesystemMBean.class);
-      mbeanName = MBeans.register("NameNode", "FSNamesystemState", bean);
+      StandardMBean namesystemBean = new StandardMBean(
+          this, FSNamesystemMBean.class);
+      StandardMBean replicaBean = new StandardMBean(
+          this, ReplicatedBlocksStatsMBean.class);
+      StandardMBean ecBean = new StandardMBean(
+          this, ECBlockGroupsStatsMBean.class);
+      namesystemMBeanName = MBeans.register(
+          "NameNode", "FSNamesystemState", namesystemBean);
+      replicatedBlocksMBeanName = MBeans.register(
+          "NameNode", "ReplicatedBlocksState", replicaBean);
+      ecBlockGroupsMBeanName = MBeans.register(
+          "NameNode", "ECBlockGroupsState", ecBean);
-
-    LOG.info("Registered FSNamesystemState MBean");
+    LOG.info("Registered FSNamesystemState, ReplicatedBlocksState and " +
+        "ECBlockGroupsState MBeans.");
-   * shutdown FSNamesystem
+   * Shutdown FSNamesystem.
-    if (mbeanName != null) {
-      MBeans.unregister(mbeanName);
-      mbeanName = null;
+    if (namesystemMBeanName != null) {
+      MBeans.unregister(namesystemMBeanName);
+      namesystemMBeanName = null;
-    if (mxbeanName != null) {
-      MBeans.unregister(mxbeanName);
-      mxbeanName = null;
+    if (replicatedBlocksMBeanName != null) {
+      MBeans.unregister(replicatedBlocksMBeanName);
+      replicatedBlocksMBeanName = null;
+    }
+    if (ecBlockGroupsMBeanName != null) {
+      MBeans.unregister(ecBlockGroupsMBeanName);
+      ecBlockGroupsMBeanName = null;
+    }
+    if (namenodeMXBeanName != null) {
+      MBeans.unregister(namenodeMXBeanName);
+      namenodeMXBeanName = null;
+
-   * Register NameNodeMXBean
+   * Register NameNodeMXBean.
-    mxbeanName = MBeans.register("NameNode", "NameNodeInfo", this);
+    namenodeMXBeanName = MBeans.register("NameNode", "NameNodeInfo", this);

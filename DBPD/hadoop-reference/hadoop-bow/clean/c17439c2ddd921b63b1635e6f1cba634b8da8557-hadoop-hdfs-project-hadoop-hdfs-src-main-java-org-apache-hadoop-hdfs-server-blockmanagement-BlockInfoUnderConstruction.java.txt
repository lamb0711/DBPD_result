HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.

+import com.google.common.base.Preconditions;
+import org.apache.hadoop.hdfs.server.common.HdfsServerConstants;
-public class BlockInfoContiguousUnderConstruction extends BlockInfoContiguous {
+public abstract class BlockInfoUnderConstruction extends BlockInfo {
-  private BlockUCState blockUCState;
+  protected BlockUCState blockUCState;
-  private List<ReplicaUnderConstruction> replicas;
+  protected List<ReplicaUnderConstruction> replicas;
-  private Block truncateBlock;
+  protected Block truncateBlock;
-   * The GS, the length and the state of the replica is as reported by 
+   * The GS, the length and the state of the replica is as reported by
-    
+
-  public BlockInfoContiguousUnderConstruction(Block blk, short replication) {
+  public BlockInfoUnderConstruction(Block blk, short replication) {
-  public BlockInfoContiguousUnderConstruction(Block blk, short replication,
+  public BlockInfoUnderConstruction(Block blk, short replication,
-    assert getBlockUCState() != BlockUCState.COMPLETE :
-      "BlockInfoUnderConstruction cannot be in COMPLETE state";
+    Preconditions.checkState(getBlockUCState() != BlockUCState.COMPLETE,
+        "BlockInfoUnderConstruction cannot be in COMPLETE state");
-  /**
-   * Convert an under construction block to a complete block.
-   * 
-   * @return BlockInfo - a complete block.
-   * @throws IOException if the state of the block 
-   * (the generation stamp and the length) has not been committed by 
-   * the client or it does not have at least a minimal number of replicas 
-   * reported from data-nodes. 
-   */
-  BlockInfo convertToCompleteBlock() throws IOException {
-    assert getBlockUCState() != BlockUCState.COMPLETE :
-      "Trying to convert a COMPLETE block";
-    return new BlockInfoContiguous(this);
-  }
-
-  /** Set expected locations */
-  public void setExpectedLocations(DatanodeStorageInfo[] targets) {
-    int numLocations = targets == null ? 0 : targets.length;
-    this.replicas = new ArrayList<ReplicaUnderConstruction>(numLocations);
-    for(int i = 0; i < numLocations; i++)
-      replicas.add(
-        new ReplicaUnderConstruction(this, targets[i], ReplicaState.RBW));
-  }
+  /** Set expected locations. */
+  public abstract void setExpectedLocations(DatanodeStorageInfo[] targets);
-    for(int i = 0; i < numLocations; i++)
+    for(int i = 0; i < numLocations; i++) {
+    }
-  /** Get the number of expected locations */
+  /** Get the number of expected locations. */
-  /** Get block recovery ID */
+  /** Get block recovery ID. */
-  /** Get recover block */
-  public Block getTruncateBlock() {
-    return truncateBlock;
-  }
+  /** Get recover block. */
+  public abstract Block getTruncateBlock();
-  public void setTruncateBlock(Block recoveryBlock) {
-    this.truncateBlock = recoveryBlock;
-  }
+  public abstract void setTruncateBlock(Block recoveryBlock);
-    if (replicas == null)
+    if (replicas == null) {
+    }
-   * @param block - contains client reported block length and generation 
+   * @param block - contains client reported block length and generation
-    if(getBlockId() != block.getBlockId())
+    if(getBlockId() != block.getBlockId()) {
+    }
-      NameNode.blockStateChangeLog.warn("BLOCK*"
-        + " BlockInfoUnderConstruction.initLeaseRecovery:"
-        + " No blocks found, lease removed.");
+      NameNode.blockStateChangeLog.warn("BLOCK* " +
+          "BlockInfoUnderConstruction.initLeaseRecovery: " +
+          "No blocks found, lease removed.");
-            (allLiveReplicasTriedAsPrimary && replicas.get(i).getChosenAsPrimary());
+            (allLiveReplicasTriedAsPrimary &&
+                replicas.get(i).getChosenAsPrimary());
-      if (!(replicas.get(i).isAlive() && !replicas.get(i).getChosenAsPrimary())) {
+      if (!(replicas.get(i).isAlive() &&
+          !replicas.get(i).getChosenAsPrimary())) {
-      primary.getExpectedStorageLocation().getDatanodeDescriptor().addBlockToBeRecovered(this);
+      primary.getExpectedStorageLocation().
+          getDatanodeDescriptor().addBlockToBeRecovered(this);
+  /**
+   * Convert an under construction block to a complete block.
+   *
+   * @return a complete block.
+   * @throws IOException
+   *           if the state of the block (the generation stamp and the length)
+   *           has not been committed by the client or it does not have at
+   *           least a minimal number of replicas reported from data-nodes.
+   */
+  public abstract BlockInfo convertToCompleteBlock();
+
+  @Override
+  BlockInfoUnderConstruction convertCompleteBlockToUC
+      (HdfsServerConstants.BlockUCState s, DatanodeStorageInfo[] targets) {
+    BlockManager.LOG.error("convertCompleteBlockToUC should only be applied " +
+        "on complete blocks.");
+    return null;
+  }
+

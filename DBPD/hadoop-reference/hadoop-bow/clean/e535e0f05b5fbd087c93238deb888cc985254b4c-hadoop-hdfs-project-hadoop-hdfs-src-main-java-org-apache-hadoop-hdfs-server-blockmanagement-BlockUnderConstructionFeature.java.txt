HDFS-8801. Convert BlockInfoUnderConstruction as a feature. Contributed by Jing Zhao.

-import java.io.IOException;
-public class BlockInfoContiguousUnderConstruction extends BlockInfoContiguous {
+public class BlockUnderConstructionFeature {
-   * The GS, the length and the state of the replica is as reported by 
+   * The GS, the length and the state of the replica is as reported by
-  static class ReplicaUnderConstruction extends Block {
+  static class ReplicaUnderConstruction {
+    private long generationStamp;
-    ReplicaUnderConstruction(Block block,
-                             DatanodeStorageInfo target,
-                             ReplicaState state) {
-      super(block);
+    ReplicaUnderConstruction(long generationStamp, DatanodeStorageInfo target,
+        ReplicaState state) {
+      this.generationStamp = generationStamp;
+    long getGenerationStamp() {
+      return this.generationStamp;
+    }
+
+    void setGenerationStamp(long generationStamp) {
+      this.generationStamp = generationStamp;
+    }
+
-    private DatanodeStorageInfo getExpectedStorageLocation() {
+    DatanodeStorageInfo getExpectedStorageLocation() {
-    @Override // Block
-    public int hashCode() {
-      return super.hashCode();
-    }
-
-    @Override // Block
-    public boolean equals(Object obj) {
-      // Sufficient to rely on super's implementation
-      return (this == obj) || super.equals(obj);
-    }
-
-      final StringBuilder b = new StringBuilder(50);
-      appendStringTo(b);
+      final StringBuilder b = new StringBuilder(50)
+          .append("ReplicaUC[")
+          .append(expectedLocation)
+          .append("|")
+          .append(state)
+          .append("]");
-    
-    @Override
-    public void appendStringTo(StringBuilder sb) {
-      sb.append("ReplicaUC[")
-        .append(expectedLocation)
-        .append("|")
-        .append(state)
-        .append("]");
-    }
-  }
-
-  /**
-   * Create block and set its state to
-   * {@link BlockUCState#UNDER_CONSTRUCTION}.
-   */
-  public BlockInfoContiguousUnderConstruction(Block blk, short replication) {
-    this(blk, replication, BlockUCState.UNDER_CONSTRUCTION, null);
-  public BlockInfoContiguousUnderConstruction(Block blk, short replication,
-      BlockUCState state, DatanodeStorageInfo[] targets) {
-    super(blk, replication);
+  public BlockUnderConstructionFeature(Block block, BlockUCState state,
+      DatanodeStorageInfo[] targets) {
-    setExpectedLocations(targets);
-  }
-
-  /**
-   * Convert an under construction block to a complete block.
-   * 
-   * @return BlockInfo - a complete block.
-   * @throws IOException if the state of the block 
-   * (the generation stamp and the length) has not been committed by 
-   * the client or it does not have at least a minimal number of replicas 
-   * reported from data-nodes. 
-   */
-  BlockInfo convertToCompleteBlock() throws IOException {
-    assert getBlockUCState() != BlockUCState.COMPLETE :
-      "Trying to convert a COMPLETE block";
-    return new BlockInfoContiguous(this);
+    setExpectedLocations(block.getGenerationStamp(), targets);
-  public void setExpectedLocations(DatanodeStorageInfo[] targets) {
+  public void setExpectedLocations(long generationStamp,
+      DatanodeStorageInfo[] targets) {
-    this.replicas = new ArrayList<ReplicaUnderConstruction>(numLocations);
-    for(int i = 0; i < numLocations; i++)
-      replicas.add(
-        new ReplicaUnderConstruction(this, targets[i], ReplicaState.RBW));
+    this.replicas = new ArrayList<>(numLocations);
+    for(int i = 0; i < numLocations; i++) {
+      replicas.add(new ReplicaUnderConstruction(generationStamp, targets[i],
+          ReplicaState.RBW));
+    }
-    for(int i = 0; i < numLocations; i++)
+    for (int i = 0; i < numLocations; i++) {
+    }
-  @Override // BlockInfo
-   * Process the recorded replicas. When about to commit or finish the
-   * pipeline recovery sort out bad replicas.
-   * @param genStamp  The final generation stamp for the block.
+   * Set {@link #blockUCState} to {@link BlockUCState#COMMITTED}.
-  public void setGenerationStampAndVerifyReplicas(long genStamp) {
-    // Set the generation stamp for the block.
-    setGenerationStamp(genStamp);
-    if (replicas == null)
-      return;
-
-    // Remove the replicas with wrong gen stamp.
-    // The replica list is unchanged.
-    for (ReplicaUnderConstruction r : replicas) {
-      if (genStamp != r.getGenerationStamp()) {
-        r.getExpectedStorageLocation().removeBlock(this);
-        NameNode.blockStateChangeLog.debug("BLOCK* Removing stale replica "
-            + "from location: {}", r.getExpectedStorageLocation());
-      }
-    }
+  void commit() {
+    blockUCState = BlockUCState.COMMITTED;
-  /**
-   * Commit block's length and generation stamp as reported by the client.
-   * Set block state to {@link BlockUCState#COMMITTED}.
-   * @param block - contains client reported block length and generation 
-   * @throws IOException if block ids are inconsistent.
-   */
-  void commitBlock(Block block) throws IOException {
-    if(getBlockId() != block.getBlockId())
-      throw new IOException("Trying to commit inconsistent block: id = "
-          + block.getBlockId() + ", expected id = " + getBlockId());
-    blockUCState = BlockUCState.COMMITTED;
-    this.set(getBlockId(), block.getNumBytes(), block.getGenerationStamp());
-    // Sort out invalid replicas.
-    setGenerationStampAndVerifyReplicas(block.getGenerationStamp());
+  List<ReplicaUnderConstruction> getStaleReplicas(long genStamp) {
+    List<ReplicaUnderConstruction> staleReplicas = new ArrayList<>();
+    if (replicas != null) {
+      // Remove replicas with wrong gen stamp. The replica list is unchanged.
+      for (ReplicaUnderConstruction r : replicas) {
+        if (genStamp != r.getGenerationStamp()) {
+          staleReplicas.add(r);
+        }
+      }
+    }
+    return staleReplicas;
-  public void initializeBlockRecovery(long recoveryId) {
+  public void initializeBlockRecovery(BlockInfo block, long recoveryId) {
-    for (int i = 0; i < replicas.size(); i++) {
+    for (ReplicaUnderConstruction replica : replicas) {
-      if (replicas.get(i).isAlive()) {
-        allLiveReplicasTriedAsPrimary =
-            (allLiveReplicasTriedAsPrimary && replicas.get(i).getChosenAsPrimary());
+      if (replica.isAlive()) {
+        allLiveReplicasTriedAsPrimary = allLiveReplicasTriedAsPrimary
+            && replica.getChosenAsPrimary();
-      for (int i = 0; i < replicas.size(); i++) {
-        replicas.get(i).setChosenAsPrimary(false);
+      for (ReplicaUnderConstruction replica : replicas) {
+        replica.setChosenAsPrimary(false);
-      primary.getExpectedStorageLocation().getDatanodeDescriptor().addBlockToBeRecovered(this);
+      primary.getExpectedStorageLocation().getDatanodeDescriptor()
+          .addBlockToBeRecovered(block);
-  void addReplicaIfNotPresent(DatanodeStorageInfo storage,
-                     Block block,
-                     ReplicaState rState) {
+  void addReplicaIfNotPresent(DatanodeStorageInfo storage, Block block,
+      ReplicaState rState) {
-      if(expectedLocation == storage) {
+      if (expectedLocation == storage) {
-
-    replicas.add(new ReplicaUnderConstruction(block, storage, rState));
-  }
-
-  @Override // BlockInfo
-  // BlockInfoUnderConstruction participates in maps the same way as BlockInfo
-  public int hashCode() {
-    return super.hashCode();
-  }
-
-  @Override // BlockInfo
-  public boolean equals(Object obj) {
-    // Sufficient to rely on super's implementation
-    return (this == obj) || super.equals(obj);
+    replicas.add(new ReplicaUnderConstruction(block.getGenerationStamp(), storage, rState));
-    appendStringTo(b);
+    appendUCParts(b);
-  @Override
-  public void appendStringTo(StringBuilder sb) {
-    super.appendStringTo(sb);
-    appendUCParts(sb);
-  }
-
-      .append(", truncateBlock=" + truncateBlock)
+      .append(", truncateBlock=").append(truncateBlock)
-        iter.next().appendStringTo(sb);
+        sb.append(iter.next());
-          iter.next().appendStringTo(sb);
+          sb.append(iter.next());

YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)

+import java.util.TreeSet;
+import org.apache.hadoop.yarn.server.resourcemanager.reservation.RLESparseResourceAllocation.RLEOperator;
+  private Map<String, RLESparseResourceAllocation> userActiveReservationCount =
+      new HashMap<String, RLESparseResourceAllocation>();
+
+
+    RLESparseResourceAllocation resCount = userActiveReservationCount.get(user);
+    if (resCount == null) {
+      resCount = new RLESparseResourceAllocation(resCalc);
+      userActiveReservationCount.put(user, resCount);
+    }
+
+    long earliestActive = Long.MAX_VALUE;
+    long latestActive = Long.MIN_VALUE;
+
+      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),
+          ZERO_RESOURCE)) {
+        earliestActive = Math.min(earliestActive, r.getKey().getStartTime());
+        latestActive = Math.max(latestActive, r.getKey().getEndTime());
+      }
+    resCount.addInterval(new ReservationInterval(earliestActive, latestActive),
+        Resource.newInstance(1, 1));
+
+    long earliestActive = Long.MAX_VALUE;
+    long latestActive = Long.MIN_VALUE;
+      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),
+          ZERO_RESOURCE)) {
+        earliestActive = Math.min(earliestActive, r.getKey().getStartTime());
+        latestActive = Math.max(latestActive, r.getKey().getEndTime());
+      }
+
+    RLESparseResourceAllocation resCount = userActiveReservationCount.get(user);
+    resCount.removeInterval(new ReservationInterval(earliestActive,
+        latestActive), Resource.newInstance(1, 1));
+    if (resCount.isEmpty()) {
+      userActiveReservationCount.remove(user);
+    }
-            new HashSet<ReservationAllocation>();
-        for (Set<InMemoryReservationAllocation> reservationEntries : currentReservations
-            .values()) {
+            new TreeSet<ReservationAllocation>();
+        for (Set<InMemoryReservationAllocation> reservationEntries :
+            currentReservations.values()) {
-  public Resource getConsumptionForUser(String user, long t) {
+  public RLESparseResourceAllocation getReservationCountForUserOverTime(
+      String user, long start, long end) {
+    readLock.lock();
+    try {
+      RLESparseResourceAllocation userResAlloc =
+          userActiveReservationCount.get(user);
+
+      if (userResAlloc != null) {
+        return userResAlloc.getRangeOverlapping(start, end);
+      } else {
+        return new RLESparseResourceAllocation(resCalc);
+      }
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  @Override
+  public RLESparseResourceAllocation getConsumptionForUserOverTime(String user,
+      long start, long end) {
+
-        return userResAlloc.getCapacityAtTime(t);
+        return userResAlloc.getRangeOverlapping(start, end);
-        return Resources.clone(ZERO_RESOURCE);
+        return new RLESparseResourceAllocation(resCalc);
+  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,
+      ReservationId oldId, long start, long end) throws PlanningException {
+    readLock.lock();
+    try {
+      // create RLE of totCapacity
+      TreeMap<Long, Resource> totAvailable = new TreeMap<Long, Resource>();
+      totAvailable.put(start, Resources.clone(totalCapacity));
+      RLESparseResourceAllocation totRLEAvail =
+          new RLESparseResourceAllocation(totAvailable, resCalc);
+
+      // subtract used from available
+      RLESparseResourceAllocation netAvailable;
+
+      netAvailable =
+          RLESparseResourceAllocation.merge(resCalc,
+              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,
+              RLEOperator.subtractTestNonNegative, start, end);
+
+      // add back in old reservation used resources if any
+      ReservationAllocation old = reservationTable.get(oldId);
+      if (old != null) {
+        netAvailable =
+            RLESparseResourceAllocation.merge(resCalc,
+                Resources.clone(totalCapacity), netAvailable,
+                old.getResourcesOverTime(), RLEOperator.add, start, end);
+      }
+      // lower it if this is needed by the sharing policy
+      netAvailable =
+          getSharingPolicy().availableResources(netAvailable, this, user,
+              oldId, start, end);
+      return netAvailable;
+    } finally {
+      readLock.unlock();
+    }
+  }
+
+  @Override
+  @Override
+  public Set<ReservationAllocation> getReservationByUserAtTime(String user,
+      long t) {
+    readLock.lock();
+    try {
+      Set<ReservationAllocation> resSet = new HashSet<ReservationAllocation>();
+      for (ReservationAllocation ra : getReservationsAtTime(t)) {
+        String resUser = ra.getUser();
+        if (resUser != null && resUser.equals(user)) {
+          resSet.add(ra);
+        }
+      }
+      return resSet;
+    } finally {
+      readLock.unlock();
+    }
+  }

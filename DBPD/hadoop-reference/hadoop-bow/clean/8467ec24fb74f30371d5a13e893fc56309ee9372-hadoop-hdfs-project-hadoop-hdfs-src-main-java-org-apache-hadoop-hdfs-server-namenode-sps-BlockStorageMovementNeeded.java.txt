HDFS-13110: [SPS]: Reduce the number of APIs in NamenodeProtocol used by external satisfier. Contributed by Rakesh R.

+ *
+ * @param <T>
+ *          is identifier of inode or full path name of inode. Internal sps will
+ *          use the file inodeId for the block movement. External sps will use
+ *          file string path representation for the block movement.
-public class BlockStorageMovementNeeded {
+public class BlockStorageMovementNeeded<T> {
-  private final Queue<ItemInfo> storageMovementNeeded =
-      new LinkedList<ItemInfo>();
+  private final Queue<ItemInfo<T>> storageMovementNeeded =
+      new LinkedList<ItemInfo<T>>();
-   * Map of startId and number of child's. Number of child's indicate the
+   * Map of startPath and number of child's. Number of child's indicate the
-  private final Map<Long, DirPendingWorkInfo> pendingWorkForDirectory =
-      new HashMap<Long, DirPendingWorkInfo>();
+  private final Map<T, DirPendingWorkInfo> pendingWorkForDirectory =
+      new HashMap<>();
-  private final Map<Long, StoragePolicySatisfyPathStatusInfo> spsStatus =
+  private final Map<T, StoragePolicySatisfyPathStatusInfo> spsStatus =
-  private final Context ctxt;
+  private final Context<T> ctxt;
-  private FileIdCollector fileIDCollector;
+  private FileCollector<T> fileCollector;
-  public BlockStorageMovementNeeded(Context context,
-      FileIdCollector fileIDCollector) {
+  public BlockStorageMovementNeeded(Context<T> context,
+      FileCollector<T> fileCollector) {
-    this.fileIDCollector = fileIDCollector;
+    this.fileCollector = fileCollector;
-  public synchronized void add(ItemInfo trackInfo) {
-    spsStatus.put(trackInfo.getStartId(),
+  public synchronized void add(ItemInfo<T> trackInfo) {
+    spsStatus.put(trackInfo.getFile(),
-   * @param startId
-   *          - start id
+   * @param startPath
+   *          - start path
-  public synchronized void addAll(long startId, List<ItemInfo> itemInfoList,
+  public synchronized void addAll(T startPath, List<ItemInfo<T>> itemInfoList,
-    updatePendingDirScanStats(startId, itemInfoList.size(), scanCompleted);
+    updatePendingDirScanStats(startPath, itemInfoList.size(), scanCompleted);
-  public synchronized void add(ItemInfo itemInfo, boolean scanCompleted) {
+  public synchronized void add(ItemInfo<T> itemInfo, boolean scanCompleted) {
-    if (itemInfo.getStartId() == itemInfo.getFileId()) {
+    if (itemInfo.getStartPath() == itemInfo.getFile()) {
-    updatePendingDirScanStats(itemInfo.getStartId(), 1, scanCompleted);
+    updatePendingDirScanStats(itemInfo.getFile(), 1, scanCompleted);
-  private void updatePendingDirScanStats(long startId, int numScannedFiles,
+  private void updatePendingDirScanStats(T startPath, int numScannedFiles,
-    DirPendingWorkInfo pendingWork = pendingWorkForDirectory.get(startId);
+    DirPendingWorkInfo pendingWork = pendingWorkForDirectory.get(startPath);
-      pendingWorkForDirectory.put(startId, pendingWork);
+      pendingWorkForDirectory.put(startPath, pendingWork);
-   * Gets the block collection id for which storage movements check necessary
+   * Gets the satisfier files for which block storage movements check necessary
-   * @return block collection ID
+   * @return satisfier files
-  public synchronized ItemInfo get() {
+  public synchronized ItemInfo<T> get() {
-  public synchronized void removeItemTrackInfo(ItemInfo trackInfo,
+  public synchronized void removeItemTrackInfo(ItemInfo<T> trackInfo,
-      long startId = trackInfo.getStartId();
+      T startId = trackInfo.getStartPath();
-      ctxt.removeSPSHint(trackInfo.getFileId());
-      updateStatus(trackInfo.getStartId(), isSuccess);
+      ctxt.removeSPSHint(trackInfo.getFile());
+      updateStatus(trackInfo.getFile(), isSuccess);
-  public synchronized void clearQueue(long trackId) {
+  public synchronized void clearQueue(T trackId) {
-    Iterator<ItemInfo> iterator = storageMovementNeeded.iterator();
+    Iterator<ItemInfo<T>> iterator = storageMovementNeeded.iterator();
-      ItemInfo next = iterator.next();
-      if (next.getStartId() == trackId) {
+      ItemInfo<T> next = iterator.next();
+      if (next.getFile() == trackId) {
-  private void updateStatus(long startId, boolean isSuccess){
+  private void updateStatus(T startId, boolean isSuccess){
-    Long trackId;
-    while ((trackId = ctxt.getNextSPSPathId()) != null) {
+    T trackId;
+    while ((trackId = ctxt.getNextSPSPath()) != null) {
-    ItemInfo itemInfo;
+    ItemInfo<T> itemInfo;
-          ctxt.removeSPSHint(itemInfo.getFileId());
+          ctxt.removeSPSHint(itemInfo.getFile());
-                + itemInfo.getFileId(), ie);
+                + itemInfo.getFile(), ie);
-      Long startINodeId = null;
+      T startINode = null;
-            if (startINodeId == null) {
-              startINodeId = ctxt.getNextSPSPathId();
+            if (startINode == null) {
+              startINode = ctxt.getNextSPSPath();
-            if (startINodeId == null) {
+            if (startINode == null) {
-              spsStatus.put(startINodeId,
+              spsStatus.put(startINode,
-              fileIDCollector.scanAndCollectFileIds(startINodeId);
+              fileCollector.scanAndCollectFiles(startINode);
-                  pendingWorkForDirectory.get(startINodeId);
+                  pendingWorkForDirectory.get(startINode);
-                ctxt.removeSPSHint(startINodeId);
-                pendingWorkForDirectory.remove(startINodeId);
-                updateStatus(startINodeId, true);
+                ctxt.removeSPSHint(startINode);
+                pendingWorkForDirectory.remove(startINode);
+                updateStatus(startINode, true);
-            startINodeId = null; // Current inode id successfully scanned.
+            startINode = null; // Current inode successfully scanned.
-      for (Iterator<Entry<Long, StoragePolicySatisfyPathStatusInfo>> it =
-          spsStatus.entrySet().iterator(); it.hasNext();) {
-        Entry<Long, StoragePolicySatisfyPathStatusInfo> entry = it.next();
+      for (Iterator<Entry<T, StoragePolicySatisfyPathStatusInfo>> it = spsStatus
+          .entrySet().iterator(); it.hasNext();) {
+        Entry<T, StoragePolicySatisfyPathStatusInfo> entry = it.next();
-  public void markScanCompletedForDir(Long inodeId) {
-    DirPendingWorkInfo pendingWork = pendingWorkForDirectory.get(inodeId);
+  public void markScanCompletedForDir(T inode) {
+    DirPendingWorkInfo pendingWork = pendingWorkForDirectory.get(inode);

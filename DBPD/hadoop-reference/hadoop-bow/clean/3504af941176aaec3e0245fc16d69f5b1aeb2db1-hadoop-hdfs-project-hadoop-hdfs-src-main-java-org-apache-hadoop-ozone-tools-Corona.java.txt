HDFS-12537. Ozone: Reduce key creation overhead in Corona. Contributed by Lokesh Jain.

+import com.fasterxml.jackson.annotation.JsonAutoDetect;
+import com.fasterxml.jackson.annotation.PropertyAccessor;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import org.apache.commons.lang.ArrayUtils;
+import org.apache.commons.lang.time.DurationFormatUtils;
+import org.apache.hadoop.ozone.OzoneConsts;
+import org.apache.hadoop.ozone.client.*;
-import org.apache.hadoop.ozone.client.ObjectStore;
-import org.apache.hadoop.ozone.client.OzoneBucket;
-import org.apache.hadoop.ozone.client.OzoneClient;
-import org.apache.hadoop.ozone.client.OzoneClientFactory;
-import org.apache.hadoop.ozone.client.OzoneVolume;
+import org.apache.hadoop.util.*;
-import org.apache.hadoop.util.GenericOptionsParser;
-import org.apache.hadoop.util.Tool;
-import org.apache.hadoop.util.ToolRunner;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
-import java.util.Arrays;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+
+  private static final String JSON_WRITE_DIRECTORY = "jsonDir";
+  private static final String DURATION_FORMAT = "HH:mm:ss,SSS";
+  private String jsonDir;
+  private byte[] keyValue = null;
+  private long jobStartTime;
+  private List<Double> threadThroughput;
+    jobStartTime = System.currentTimeMillis();
+
+    threadThroughput = Collections.synchronizedList(new ArrayList<Double>());
+
+    keyValue =
+        DFSUtil.string2Bytes(RandomStringUtils.randomAscii(keySize - 36));
+
+
+    OptionBuilder.withDescription("directory where json is created");
+    OptionBuilder.hasArg();
+    Option optJsonDir = OptionBuilder.create(JSON_WRITE_DIRECTORY);
+
+    options.addOption(optJsonDir);
-    mode = cmdLine.hasOption(MODE) ?
-        cmdLine.getOptionValue(MODE) : MODE_DEFAULT;
+    mode = cmdLine.getOptionValue(MODE, MODE_DEFAULT);
-    source = cmdLine.hasOption(SOURCE) ?
-        cmdLine.getOptionValue(SOURCE) : SOURCE_DEFAULT;
+    source = cmdLine.getOptionValue(SOURCE, SOURCE_DEFAULT);
-    numOfThreads = cmdLine.hasOption(NUM_OF_THREADS) ?
-        cmdLine.getOptionValue(NUM_OF_THREADS) : NUM_OF_THREADS_DEFAULT;
+    numOfThreads =
+        cmdLine.getOptionValue(NUM_OF_THREADS, NUM_OF_THREADS_DEFAULT);
-    numOfVolumes = cmdLine.hasOption(NUM_OF_VOLUMES) ?
-        cmdLine.getOptionValue(NUM_OF_VOLUMES) : NUM_OF_VOLUMES_DEFAULT;
+    jsonDir = cmdLine.getOptionValue(JSON_WRITE_DIRECTORY);
-    numOfBuckets = cmdLine.hasOption(NUM_OF_BUCKETS) ?
-        cmdLine.getOptionValue(NUM_OF_BUCKETS) : NUM_OF_BUCKETS_DEFAULT;
+    numOfVolumes =
+        cmdLine.getOptionValue(NUM_OF_VOLUMES, NUM_OF_VOLUMES_DEFAULT);
-    numOfKeys = cmdLine.hasOption(NUM_OF_KEYS) ?
-        cmdLine.getOptionValue(NUM_OF_KEYS) : NUM_OF_KEYS_DEFAULT;
+    numOfBuckets =
+        cmdLine.getOptionValue(NUM_OF_BUCKETS, NUM_OF_BUCKETS_DEFAULT);
+
+    numOfKeys = cmdLine.getOptionValue(NUM_OF_KEYS, NUM_OF_KEYS_DEFAULT);
+    if (keySize < 1024) {
+      throw new IllegalArgumentException(
+          "keySize can not be less than 1024 bytes");
+    }
+
-    replicationFactor = useRatis ?
-        Integer.parseInt(cmdLine.getOptionValue(RATIS)) : 0;
+    replicationFactor =
+        useRatis ? Integer.parseInt(cmdLine.getOptionValue(RATIS)) : 0;
+    System.out.println("-jsonDir                        "
+        + "directory where json is created.");
-    String execTime = String.format("%02d:%02d:%02d",
-        TimeUnit.NANOSECONDS.toHours(endTime),
-        TimeUnit.NANOSECONDS.toMinutes(endTime) -
-            TimeUnit.HOURS.toMinutes(
-                TimeUnit.NANOSECONDS.toHours(endTime)),
-        TimeUnit.NANOSECONDS.toSeconds(endTime) -
-            TimeUnit.MINUTES.toSeconds(
-                TimeUnit.NANOSECONDS.toMinutes(endTime)));
+    String execTime = DurationFormatUtils
+        .formatDuration(TimeUnit.NANOSECONDS.toMillis(endTime),
+            DURATION_FORMAT);
+    String prettyTotalVolumeTime = DurationFormatUtils
+        .formatDuration(TimeUnit.NANOSECONDS.toMillis(volumeCreationTime.get()),
+            DURATION_FORMAT);
+    String prettyTotalBucketTime = DurationFormatUtils
+        .formatDuration(TimeUnit.NANOSECONDS.toMillis(bucketCreationTime.get()),
+            DURATION_FORMAT);
+    String prettyTotalKeyCreationTime = DurationFormatUtils
+        .formatDuration(TimeUnit.NANOSECONDS.toMillis(keyCreationTime.get()),
+            DURATION_FORMAT);
+    String prettyTotalKeyWriteTime = DurationFormatUtils
+        .formatDuration(TimeUnit.NANOSECONDS.toMillis(keyWriteTime.get()),
+            DURATION_FORMAT);
-    long volumeTime = volumeCreationTime.longValue();
-    String prettyVolumeTime = String.format("%02d:%02d:%02d:%02d",
-        TimeUnit.NANOSECONDS.toHours(volumeTime),
-        TimeUnit.NANOSECONDS.toMinutes(volumeTime) -
-            TimeUnit.HOURS.toMinutes(
-                TimeUnit.NANOSECONDS.toHours(volumeTime)),
-        TimeUnit.NANOSECONDS.toSeconds(volumeTime) -
-            TimeUnit.MINUTES.toSeconds(
-                TimeUnit.NANOSECONDS.toMinutes(volumeTime)),
-        TimeUnit.NANOSECONDS.toMillis(volumeTime) -
-            TimeUnit.SECONDS.toMillis(
-                TimeUnit.NANOSECONDS.toSeconds(volumeTime)));
+    long volumeTime =
+        TimeUnit.NANOSECONDS.toMillis(volumeCreationTime.get()) / threadCount;
+    String prettyAverageVolumeTime =
+        DurationFormatUtils.formatDuration(volumeTime, DURATION_FORMAT);
-    long bucketTime = bucketCreationTime.longValue() / threadCount;
-    String prettyBucketTime = String.format("%02d:%02d:%02d:%02d",
-        TimeUnit.NANOSECONDS.toHours(bucketTime),
-        TimeUnit.NANOSECONDS.toMinutes(bucketTime) -
-            TimeUnit.HOURS.toMinutes(
-                TimeUnit.NANOSECONDS.toHours(bucketTime)),
-        TimeUnit.NANOSECONDS.toSeconds(bucketTime) -
-            TimeUnit.MINUTES.toSeconds(
-                TimeUnit.NANOSECONDS.toMinutes(bucketTime)),
-        TimeUnit.NANOSECONDS.toMillis(bucketTime) -
-            TimeUnit.SECONDS.toMillis(
-                TimeUnit.NANOSECONDS.toSeconds(bucketTime)));
+    long bucketTime =
+        TimeUnit.NANOSECONDS.toMillis(bucketCreationTime.get()) / threadCount;
+    String prettyAverageBucketTime =
+        DurationFormatUtils.formatDuration(bucketTime, DURATION_FORMAT);
-    long totalKeyCreationTime = keyCreationTime.longValue() / threadCount;
-    String prettyKeyCreationTime = String.format("%02d:%02d:%02d:%02d",
-        TimeUnit.NANOSECONDS.toHours(totalKeyCreationTime),
-        TimeUnit.NANOSECONDS.toMinutes(totalKeyCreationTime) -
-            TimeUnit.HOURS.toMinutes(
-                TimeUnit.NANOSECONDS.toHours(totalKeyCreationTime)),
-        TimeUnit.NANOSECONDS.toSeconds(totalKeyCreationTime) -
-            TimeUnit.MINUTES.toSeconds(
-                TimeUnit.NANOSECONDS.toMinutes(totalKeyCreationTime)),
-        TimeUnit.NANOSECONDS.toMillis(totalKeyCreationTime) -
-            TimeUnit.SECONDS.toMillis(
-                TimeUnit.NANOSECONDS.toSeconds(totalKeyCreationTime)));
+    long averageKeyCreationTime =
+        TimeUnit.NANOSECONDS.toMillis(keyCreationTime.get()) / threadCount;
+    String prettyAverageKeyCreationTime = DurationFormatUtils
+        .formatDuration(averageKeyCreationTime, DURATION_FORMAT);
-    long totalKeyWriteTime = keyWriteTime.longValue() / threadCount;
-    String prettyKeyWriteTime = String.format("%02d:%02d:%02d:%02d",
-        TimeUnit.NANOSECONDS.toHours(totalKeyWriteTime),
-        TimeUnit.NANOSECONDS.toMinutes(totalKeyWriteTime) -
-            TimeUnit.HOURS.toMinutes(
-                TimeUnit.NANOSECONDS.toHours(totalKeyWriteTime)),
-        TimeUnit.NANOSECONDS.toSeconds(totalKeyWriteTime) -
-            TimeUnit.MINUTES.toSeconds(
-                TimeUnit.NANOSECONDS.toMinutes(totalKeyWriteTime)),
-        TimeUnit.NANOSECONDS.toMillis(totalKeyWriteTime) -
-            TimeUnit.SECONDS.toMillis(
-                TimeUnit.NANOSECONDS.toSeconds(totalKeyWriteTime)));
+    long averageKeyWriteTime =
+        TimeUnit.NANOSECONDS.toMillis(keyWriteTime.get()) / threadCount;
+    String prettyAverageKeyWriteTime = DurationFormatUtils
+        .formatDuration(averageKeyWriteTime, DURATION_FORMAT);
+    out.println("Git Base Revision: " + VersionInfo.getRevision());
-    out.println("Time spent in volume creation: " + prettyVolumeTime);
-    out.println("Time spent in bucket creation: " + prettyBucketTime);
-    out.println("Time spent in key creation: " + prettyKeyCreationTime);
-    out.println("Time spent in writing keys: " + prettyKeyWriteTime);
+    out.println("Time spent in volume creation: " + prettyTotalVolumeTime);
+    out.println("Time spent in bucket creation: " + prettyTotalBucketTime);
+    out.println("Time spent in key creation: " + prettyTotalKeyCreationTime);
+    out.println("Time spent in key write: " + prettyTotalKeyWriteTime);
+    out.println(
+        "Average Time spent in volume creation: " + prettyAverageVolumeTime);
+    out.println(
+        "Average Time spent in bucket creation: " + prettyAverageBucketTime);
+    out.println(
+        "Average Time spent in key creation: " + prettyAverageKeyCreationTime);
+    out.println(
+        "Average Time spent in key write: " + prettyAverageKeyWriteTime);
+
+    if (jsonDir != null) {
+      CoronaJobInfo jobInfo = new CoronaJobInfo()
+          .setExecTime(execTime)
+          .setGitBaseRevision(VersionInfo.getRevision())
+          .setAverageVolumeCreationTime(prettyAverageVolumeTime)
+          .setAverageBucketCreationTime(prettyAverageBucketTime)
+          .setAverageKeyCreationTime(prettyAverageKeyCreationTime)
+          .setAverageKeyWriteTime(prettyAverageKeyWriteTime)
+          .setTotalVolumeCreationTime(prettyTotalVolumeTime)
+          .setTotalBucketCreationTime(prettyTotalBucketTime)
+          .setTotalKeyCreationTime(prettyTotalKeyCreationTime)
+          .setTotalKeyWriteTime(prettyTotalKeyWriteTime);
+      String jsonName =
+          new SimpleDateFormat("yyyyMMddHHmmss").format(Time.now()) + ".json";
+      String jsonPath = jsonDir + "/" + jsonName;
+      FileOutputStream os = null;
+      try {
+        os = new FileOutputStream(jsonPath);
+        ObjectMapper mapper = new ObjectMapper();
+        mapper.setVisibility(PropertyAccessor.FIELD,
+            JsonAutoDetect.Visibility.ANY);
+        ObjectWriter writer = mapper.writerWithDefaultPrettyPrinter();
+        writer.writeValue(os, jobInfo);
+      } catch (FileNotFoundException e) {
+        out.println("Json File could not be created for the path: " + jsonPath);
+        out.println(e);
+      } catch (IOException e) {
+        out.println("Json object could not be created");
+        out.println(e);
+      } finally {
+        try {
+          if (os != null) {
+            os.close();
+          }
+        } catch (IOException e) {
+          LOG.warn("Could not close the output stream for json", e);
+        }
+      }
+    }
+   * Returns the length of the common key value initialized.
+   * @return key value length initialized.
+   */
+  @VisibleForTesting
+  long getKeyValueLength(){
+    return keyValue.length;
+  }
+
+  /**
-
+
+      Long threadKeyWriteTime = 0L;
-            byte[] value = DFSUtil.string2Bytes(
-                RandomStringUtils.randomAscii(keySize));
+            byte[] randomValue =
+                DFSUtil.string2Bytes(UUID.randomUUID().toString());
-              OzoneOutputStream os = bucket.createKey(key, value.length,
-                  type, factor);
+              OzoneOutputStream os =
+                  bucket.createKey(key, keySize, type, factor);
-              os.write(value);
+              os.write(keyValue);
+              os.write(randomValue);
-              keyWriteTime.getAndAdd(System.nanoTime() - keyWriteStart);
-              totalBytesWritten.getAndAdd(value.length);
+              threadKeyWriteTime += System.nanoTime() - keyWriteStart;
+              totalBytesWritten.getAndAdd(keySize);
+                byte[] value = ArrayUtils.addAll(keyValue, randomValue);
+
+      keyWriteTime.getAndAdd(threadKeyWriteTime);
+      boolean success = threadThroughput.add(
+          (totalBuckets * totalKeys * keySize * 1.0) / TimeUnit.NANOSECONDS
+              .toSeconds(threadKeyWriteTime));
+      if (!success) {
+        LOG.warn("Throughput could not be added for thread id: {}",
+            Thread.currentThread().getId());
+      }
+
+  }
+
+  private final class CoronaJobInfo {
+
+    private String gitBaseRevision;
+    private String jobStartTime;
+    private String numOfVolumes;
+    private String numOfBuckets;
+    private String numOfKeys;
+    private String numOfThreads;
+    private String mode;
+    private String totalBucketCreationTime;
+    private String totalVolumeCreationTime;
+    private String totalKeyCreationTime;
+    private String totalKeyWriteTime;
+    private String averageBucketCreationTime;
+    private String averageVolumeCreationTime;
+    private String averageKeyCreationTime;
+    private String averageKeyWriteTime;
+    private String dataWritten;
+    private String execTime;
+
+    private int keySize;
+
+    private String[] threadThroughputPerSecond;
+    private String minThreadThroughputPerSecond;
+    private String maxThreadThroughputPerSecond;
+    private String totalThroughputPerSecond;
+
+    private CoronaJobInfo() {
+      this.numOfVolumes = Corona.this.numOfVolumes;
+      this.numOfBuckets = Corona.this.numOfBuckets;
+      this.numOfKeys = Corona.this.numOfKeys;
+      this.numOfThreads = Corona.this.numOfThreads;
+      this.keySize = Corona.this.keySize;
+      this.mode = Corona.this.mode;
+      this.jobStartTime = Time.formatTime(Corona.this.jobStartTime);
+
+      long totalBytes =
+          Long.parseLong(numOfVolumes) * Long.parseLong(numOfBuckets) * Long
+              .parseLong(numOfKeys) * keySize;
+      this.dataWritten = getInStorageUnits((double) totalBytes);
+
+      threadThroughputPerSecond = new String[Integer.parseInt(numOfThreads)];
+      double minThreadThroughput = Double.MAX_VALUE, maxThreadThroughput = 0.0,
+          totalThroughput = 0.0;
+      int i = 0;
+      for (Double throughput : Corona.this.threadThroughput) {
+        minThreadThroughput = min(throughput, minThreadThroughput);
+        maxThreadThroughput = max(throughput, maxThreadThroughput);
+        totalThroughput += throughput;
+        threadThroughputPerSecond[i++] = getInStorageUnits(throughput);
+      }
+      minThreadThroughputPerSecond = getInStorageUnits(minThreadThroughput);
+      maxThreadThroughputPerSecond = getInStorageUnits(maxThreadThroughput);
+      totalThroughputPerSecond = getInStorageUnits(totalThroughput);
+    }
+
+    private String getInStorageUnits(Double value) {
+      double size;
+      OzoneQuota.Units unit;
+      if ((long) (value / OzoneConsts.KB) == 0) {
+        size = value / OzoneConsts.KB;
+        unit = OzoneQuota.Units.KB;
+      } else if ((long) (value / OzoneConsts.MB) == 0) {
+        size = value / OzoneConsts.MB;
+        unit = OzoneQuota.Units.MB;
+      } else if ((long) (value / OzoneConsts.GB) == 0) {
+        size = value / OzoneConsts.GB;
+        unit = OzoneQuota.Units.GB;
+      } else if ((long) (value / OzoneConsts.TB) == 0) {
+        size = value / OzoneConsts.TB;
+        unit = OzoneQuota.Units.TB;
+      } else {
+        size = value;
+        unit = OzoneQuota.Units.BYTES;
+      }
+      return size + " " + unit;
+    }
+
+    public CoronaJobInfo setGitBaseRevision(String gitBaseRevisionVal) {
+      gitBaseRevision = gitBaseRevisionVal;
+      return this;
+    }
+
+    public CoronaJobInfo setTotalBucketCreationTime(
+        String totalBucketCreationTimeVal) {
+      totalBucketCreationTime = totalBucketCreationTimeVal;
+      return this;
+    }
+
+    public CoronaJobInfo setTotalVolumeCreationTime(
+        String totalVolumeCreationTimeVal) {
+      totalVolumeCreationTime = totalVolumeCreationTimeVal;
+      return this;
+    }
+
+    public CoronaJobInfo setTotalKeyCreationTime(
+        String totalKeyCreationTimeVal) {
+      totalKeyCreationTime = totalKeyCreationTimeVal;
+      return this;
+    }
+
+    public CoronaJobInfo setTotalKeyWriteTime(String totalKeyWriteTimeVal) {
+      totalKeyWriteTime = totalKeyWriteTimeVal;
+      return this;
+    }
+
+    public CoronaJobInfo setAverageBucketCreationTime(
+        String averageBucketCreationTimeVal) {
+      averageBucketCreationTime = averageBucketCreationTimeVal;
+      return this;
+    }
+
+    public CoronaJobInfo setAverageVolumeCreationTime(
+        String averageVolumeCreationTimeVal) {
+      averageVolumeCreationTime = averageVolumeCreationTimeVal;
+      return this;
+    }
+
+    public CoronaJobInfo setAverageKeyCreationTime(
+        String averageKeyCreationTimeVal) {
+      averageKeyCreationTime = averageKeyCreationTimeVal;
+      return this;
+    }
+
+    public CoronaJobInfo setAverageKeyWriteTime(
+        String averageKeyWriteTimeVal) {
+      averageKeyWriteTime = averageKeyWriteTimeVal;
+      return this;
+    }
+
+    public CoronaJobInfo setExecTime(String execTimeVal) {
+      execTime = execTimeVal;
+      return this;
+    }
+
+    public String getJobStartTime() {
+      return jobStartTime;
+    }
+
+    public String getNumOfVolumes() {
+      return numOfVolumes;
+    }
+
+    public String getNumOfBuckets() {
+      return numOfBuckets;
+    }
+
+    public String getNumOfKeys() {
+      return numOfKeys;
+    }
+
+    public String getNumOfThreads() {
+      return numOfThreads;
+    }
+
+    public String getMode() {
+      return mode;
+    }
+
+    public String getTotalBucketCreationTime() {
+      return totalBucketCreationTime;
+    }
+
+    public String getTotalVolumeCreationTime() {
+      return totalVolumeCreationTime;
+    }
+
+    public String getTotalKeyCreationTime() {
+      return totalKeyCreationTime;
+    }
+
+    public String getAverageBucketCreationTime() {
+      return averageBucketCreationTime;
+    }
+
+    public String getTotalKeyWriteTime() {
+      return totalKeyWriteTime;
+    }
+
+    public String getAverageKeyWriteTime() {
+      return averageKeyWriteTime;
+    }
+
+    public String getAverageVolumeCreationTime() {
+      return averageVolumeCreationTime;
+    }
+
+    public String getAverageKeyCreationTime() {
+      return averageKeyCreationTime;
+    }
+
+    public String getExecTime() {
+      return execTime;
+    }
+
+    public int getKeySize() {
+      return keySize;
+    }
+
+    public String getGitBaseRevision() {
+      return gitBaseRevision;
+    }
+
+    public String getMinThreadThroughputPerSecond() {
+      return minThreadThroughputPerSecond;
+    }
+
+    public String getMaxThreadThroughputPerSecond() {
+      return maxThreadThroughputPerSecond;
+    }
+
+    public String getDataWritten() {
+      return dataWritten;
+    }
+
+    public String getTotalThroughput() {
+      return totalThroughputPerSecond;
+    }
+

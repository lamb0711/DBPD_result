HDDS-98. Adding Ozone Manager Audit Log. Contributed by Dinesh Chitlangia.

+import org.apache.hadoop.ipc.Server;
+import org.apache.hadoop.ozone.OzoneConsts;
+import org.apache.hadoop.ozone.audit.AuditAction;
+import org.apache.hadoop.ozone.audit.AuditEventStatus;
+import org.apache.hadoop.ozone.audit.AuditLogger;
+import org.apache.hadoop.ozone.audit.AuditLoggerType;
+import org.apache.hadoop.ozone.audit.AuditMessage;
+import org.apache.hadoop.ozone.audit.OMAction;
+import org.apache.logging.log4j.Level;
+import java.util.LinkedHashMap;
+  private static final AuditLogger AUDIT =
+      new AuditLogger(AuditLoggerType.OMLOGGER);
+
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.CREATE_VOLUME,
+          (args == null) ? null : args.toAuditMap()));
+      AUDIT.logWriteFailure(Level.ERROR,
+          buildAuditMessageForFailure(OMAction.CREATE_VOLUME,
+              (args == null) ? null : args.toAuditMap()), ex);
+    Map<String, String> auditMap = buildAuditMap(volume);
+    auditMap.put(OzoneConsts.OWNER, owner);
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.SET_OWNER,
+          auditMap));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.SET_OWNER,
+          auditMap), ex);
+    Map<String, String> auditMap = buildAuditMap(volume);
+    auditMap.put(OzoneConsts.QUOTA, String.valueOf(quota));
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.SET_QUOTA,
+          auditMap));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.SET_QUOTA,
+          auditMap), ex);
+    boolean auditSuccess = true;
+    Map<String, String> auditMap = buildAuditMap(volume);
+    auditMap.put(OzoneConsts.USER_ACL,
+        (userAcl == null) ? null : userAcl.getName());
+      auditSuccess = false;
+      AUDIT.logReadFailure(buildAuditMessageForFailure(
+          OMAction.CHECK_VOLUME_ACCESS, auditMap), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logReadSuccess(buildAuditMessageForSuccess(
+            OMAction.CHECK_VOLUME_ACCESS, auditMap));
+      }
+    boolean auditSuccess = true;
+    Map<String, String> auditMap = buildAuditMap(volume);
+      auditSuccess = false;
+      AUDIT.logReadFailure(buildAuditMessageForFailure(OMAction.READ_VOLUME,
+          auditMap), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logReadSuccess(buildAuditMessageForSuccess(OMAction.READ_VOLUME,
+            auditMap));
+      }
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.DELETE_VOLUME,
+          buildAuditMap(volume)));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.DELETE_VOLUME,
+          buildAuditMap(volume)), ex);
+    boolean auditSuccess = true;
+    Map<String, String> auditMap = new LinkedHashMap<>();
+    auditMap.put(OzoneConsts.PREV_KEY, prevKey);
+    auditMap.put(OzoneConsts.PREFIX, prefix);
+    auditMap.put(OzoneConsts.MAX_KEYS, String.valueOf(maxKeys));
+    auditMap.put(OzoneConsts.USERNAME, userName);
+      auditSuccess = false;
+      AUDIT.logReadFailure(buildAuditMessageForFailure(OMAction.LIST_VOLUMES,
+          auditMap), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logReadSuccess(buildAuditMessageForSuccess(OMAction.LIST_VOLUMES,
+            auditMap));
+      }
+    boolean auditSuccess = true;
+    Map<String, String> auditMap = new LinkedHashMap<>();
+    auditMap.put(OzoneConsts.PREV_KEY, prevKey);
+    auditMap.put(OzoneConsts.PREFIX, prefix);
+    auditMap.put(OzoneConsts.MAX_KEYS, String.valueOf(maxKeys));
+    auditMap.put(OzoneConsts.USERNAME, null);
+      auditSuccess = false;
+      AUDIT.logReadFailure(buildAuditMessageForFailure(OMAction.LIST_VOLUMES,
+          auditMap), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logReadSuccess(buildAuditMessageForSuccess(OMAction.LIST_VOLUMES,
+            auditMap));
+      }
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.CREATE_BUCKET,
+          (bucketInfo == null) ? null : bucketInfo.toAuditMap()));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.CREATE_BUCKET,
+          (bucketInfo == null) ? null : bucketInfo.toAuditMap()), ex);
+    boolean auditSuccess = true;
+    Map<String, String> auditMap = buildAuditMap(volumeName);
+    auditMap.put(OzoneConsts.START_KEY, startKey);
+    auditMap.put(OzoneConsts.PREFIX, prefix);
+    auditMap.put(OzoneConsts.MAX_NUM_OF_BUCKETS,
+        String.valueOf(maxNumOfBuckets));
+      auditSuccess = false;
+      AUDIT.logReadFailure(buildAuditMessageForFailure(OMAction.LIST_BUCKETS,
+          auditMap), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logReadSuccess(buildAuditMessageForSuccess(OMAction.LIST_BUCKETS,
+            auditMap));
+      }
+    boolean auditSuccess = true;
+    Map<String, String> auditMap = buildAuditMap(volume);
+    auditMap.put(OzoneConsts.BUCKET, bucket);
+      auditSuccess = false;
+      AUDIT.logReadFailure(buildAuditMessageForFailure(OMAction.READ_BUCKET,
+          auditMap), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logReadSuccess(buildAuditMessageForSuccess(OMAction.READ_BUCKET,
+            auditMap));
+      }
+    boolean auditSuccess = true;
+      auditSuccess = false;
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.ALLOCATE_KEY,
+          (args == null) ? null : args.toAuditMap()), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logWriteSuccess(buildAuditMessageForSuccess(
+            OMAction.ALLOCATE_KEY, (args == null) ? null : args.toAuditMap()));
+      }
+    Map<String, String> auditMap = (args == null) ? new LinkedHashMap<>() :
+        args.toAuditMap();
+    auditMap.put(OzoneConsts.CLIENT_ID, String.valueOf(clientID));
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.COMMIT_KEY,
+          auditMap));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.COMMIT_KEY,
+          auditMap), ex);
+    boolean auditSuccess = true;
+    Map<String, String> auditMap = (args == null) ? new LinkedHashMap<>() :
+        args.toAuditMap();
+    auditMap.put(OzoneConsts.CLIENT_ID, String.valueOf(clientID));
+      auditSuccess = false;
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.ALLOCATE_BLOCK,
+          auditMap), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logWriteSuccess(buildAuditMessageForSuccess(
+            OMAction.ALLOCATE_BLOCK, auditMap));
+      }
+    boolean auditSuccess = true;
+      auditSuccess = false;
+      AUDIT.logReadFailure(buildAuditMessageForFailure(OMAction.READ_KEY,
+          (args == null) ? null : args.toAuditMap()), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logReadSuccess(buildAuditMessageForSuccess(OMAction.READ_KEY,
+            (args == null) ? null : args.toAuditMap()));
+      }
+    Map<String, String> auditMap = (args == null) ? new LinkedHashMap<>() :
+        args.toAuditMap();
+    auditMap.put(OzoneConsts.TO_KEY_NAME, toKeyName);
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.RENAME_KEY,
+          auditMap));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.RENAME_KEY,
+          auditMap), e);
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.DELETE_KEY,
+          (args == null) ? null : args.toAuditMap()));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.DELETE_KEY,
+          (args == null) ? null : args.toAuditMap()), ex);
+    boolean auditSuccess = true;
+    Map<String, String> auditMap = buildAuditMap(volumeName);
+    auditMap.put(OzoneConsts.BUCKET, bucketName);
+    auditMap.put(OzoneConsts.START_KEY, startKey);
+    auditMap.put(OzoneConsts.MAX_KEYS, String.valueOf(maxKeys));
+    auditMap.put(OzoneConsts.KEY_PREFIX, keyPrefix);
+      auditSuccess = false;
+      AUDIT.logReadFailure(buildAuditMessageForFailure(OMAction.LIST_KEYS,
+          auditMap), ex);
+    } finally {
+      if(auditSuccess){
+        AUDIT.logReadSuccess(buildAuditMessageForSuccess(OMAction.LIST_KEYS,
+            auditMap));
+      }
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.UPDATE_BUCKET,
+          (args == null) ? null : args.toAuditMap()));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.UPDATE_BUCKET,
+          (args == null) ? null : args.toAuditMap()), ex);
+    Map<String, String> auditMap = buildAuditMap(volume);
+    auditMap.put(OzoneConsts.BUCKET, bucket);
+      AUDIT.logWriteSuccess(buildAuditMessageForSuccess(OMAction.DELETE_BUCKET,
+          auditMap));
+      AUDIT.logWriteFailure(buildAuditMessageForFailure(OMAction.DELETE_BUCKET,
+          auditMap), ex);
+  private Map<String, String> buildAuditMap(String volume){
+    Map<String, String> auditMap = new LinkedHashMap<>();
+    auditMap.put(OzoneConsts.VOLUME, volume);
+    return auditMap;
+  }
+
+  // TODO: Temporary method until AuditMessage is simplified
+  private AuditMessage buildAuditMessageForSuccess(AuditAction op,
+      Map<String, String> auditMap) {
+    return new AuditMessage(
+      (Server.getRemoteUser() == null) ? null :
+              Server.getRemoteUser().getUserName(),
+      (Server.getRemoteIp() == null) ? null :
+          Server.getRemoteIp().getHostAddress(), op.toString(), auditMap,
+      AuditEventStatus.SUCCESS.toString());
+  }
+
+  // TODO: Temporary method until AuditMessage is simplified
+  private AuditMessage buildAuditMessageForFailure(AuditAction op,
+      Map<String, String> auditMap) {
+    return new AuditMessage(
+      (Server.getRemoteUser() == null) ? null :
+              Server.getRemoteUser().getUserName(),
+      (Server.getRemoteIp() == null) ? null :
+          Server.getRemoteIp().getHostAddress(), op.toString(), auditMap,
+      AuditEventStatus.FAILURE.toString());
+  }
+

Reverting the previous merge r1416603 which committed some extra changes

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1416712 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.ha.HAServiceProtocol.HAServiceState;
+import org.apache.hadoop.hdfs.server.namenode.ha.ActiveState;
-import org.apache.hadoop.hdfs.server.namenode.snapshot.INodeDirectorySnapshottable;
-import org.apache.hadoop.hdfs.server.namenode.snapshot.Snapshot;
-        + " blocks = " + (totalInodes + totalBlocks)
-        + " total filesystem objects");
+        + " blocks = " + (totalInodes + totalBlocks) + " total");
-      
-      final INodesInPath inodesInPath = dir.getINodesInPath(src);
-      final INode myFile = inodesInPath.getINode(0);
+      final INode myFile = dir.getINode(src);
-        return prepareFileForWrite(src, f, holder, clientMachine, clientNode,
-            true, inodesInPath.getLatestSnapshot());
+        return prepareFileForWrite(
+            src, f, holder, clientMachine, clientNode, true);
-      boolean writeToEditLog, Snapshot latestSnapshot) throws IOException {
+      boolean writeToEditLog) throws IOException {
-    dir.replaceNode(src, file, cons, latestSnapshot);
+    dir.replaceNode(src, file, cons);
-      final INodeFileUnderConstruction pendingFile = checkLease(
-          src, clientName, dir.getINode(src));
+      INodeFileUnderConstruction pendingFile = checkLease(src, clientName);
-      final INodeFileUnderConstruction file = checkLease(
-          src, clientName, dir.getINode(src));
+      final INodeFileUnderConstruction file = checkLease(src, clientName);
-      final INodesInPath inodesInPath = checkLease(src, holder);
-      final INodeFileUnderConstruction file
-          = (INodeFileUnderConstruction)inodesInPath.getINode(0); 
+      INodeFileUnderConstruction file = checkLease(src, holder);
-  /** make sure that we still have the lease on this file. */
-  private INodesInPath checkLease(String src, String holder) 
+  // make sure that we still have the lease on this file.
+  private INodeFileUnderConstruction checkLease(String src, String holder) 
-    final INodesInPath inodesInPath = dir.getINodesInPath(src);
-    checkLease(src, holder, inodesInPath.getINode(0));
-    return inodesInPath;
+    return checkLease(src, holder, dir.getINode(src));
-    final INodesInPath inodesInPath;
-    final INodeFileUnderConstruction pendingFile;
+    INodeFileUnderConstruction pendingFile;
-      inodesInPath = checkLease(src, holder);
-      pendingFile = (INodeFileUnderConstruction)inodesInPath.getINode(0); 
+      pendingFile = checkLease(src, holder);
-    finalizeINodeFileUnderConstruction(src, pendingFile,
-        inodesInPath.getLatestSnapshot());
+    finalizeINodeFileUnderConstruction(src, pendingFile);
-      //NOTE: yes, this is bad!  it's assuming much lower level behavior
-      //      of rewriting the dst
+    HdfsFileStatus dinfo = dir.getFileInfo(dst, false);
+      unprotectedChangeLease(src, dst, dinfo);     // update lease with new filename
+    HdfsFileStatus dinfo = dir.getFileInfo(dst, false);
+    unprotectedChangeLease(src, dst, dinfo); // update lease with new filename
-      final INodeFileUnderConstruction pendingFile  = checkLease(
-          src, clientName, dir.getINode(src));
+      INodeFileUnderConstruction pendingFile  = checkLease(src, clientName);
-    final INodesInPath inodesInPath = dir.getINodesInPath(src);
-        = INodeFileUnderConstruction.valueOf(inodesInPath.getINode(0), src);
+        = INodeFileUnderConstruction.valueOf(dir.getINode(src), src);
-      finalizeINodeFileUnderConstruction(src, pendingFile,
-          inodesInPath.getLatestSnapshot());
+      finalizeINodeFileUnderConstruction(src, pendingFile);
-        finalizeINodeFileUnderConstruction(src, pendingFile,
-            inodesInPath.getLatestSnapshot());
+        finalizeINodeFileUnderConstruction(src, pendingFile);
-      INodeFileUnderConstruction pendingFile, Snapshot latestSnapshot) 
+      INodeFileUnderConstruction pendingFile) 
-    dir.replaceNode(src, pendingFile, newFile, latestSnapshot);
+    dir.replaceNode(src, pendingFile, newFile);
-        finalizeINodeFileUnderConstruction(src, pendingFile,
-            INodeDirectorySnapshottable.findLatestSnapshot(pendingFile));
+        finalizeINodeFileUnderConstruction(src, pendingFile);
-    if (state.getServiceState() == HAServiceState.ACTIVE) {
+    if (state instanceof ActiveState) {
-    } else if (state.getServiceState() == HAServiceState.STANDBY) {
+    } else if (state instanceof StandbyState) {
-  void unprotectedChangeLease(String src, String dst) {
+  void unprotectedChangeLease(String src, String dst, HdfsFileStatus dinfo) {
+    String overwrite;
+    String replaceBy;
-    leaseManager.changeLease(src, dst);
+
+    boolean destinationExisted = true;
+    if (dinfo == null) {
+      destinationExisted = false;
+    }
+
+    if (destinationExisted && dinfo.isDir()) {
+      Path spath = new Path(src);
+      Path parent = spath.getParent();
+      if (parent.isRoot()) {
+        overwrite = parent.toString();
+      } else {
+        overwrite = parent.toString() + Path.SEPARATOR;
+      }
+      replaceBy = dst + Path.SEPARATOR;
+    } else {
+      overwrite = src;
+      replaceBy = dst;
+    }
+
+    leaseManager.changeLease(src, dst, overwrite, replaceBy);
-      Map<String, INodeFileUnderConstruction> nodes =
-          leaseManager.getINodesUnderConstruction();
-      out.writeInt(nodes.size()); // write the size    
-      for (Map.Entry<String, INodeFileUnderConstruction> entry
-           : nodes.entrySet()) {
-        FSImageSerialization.writeINodeUnderConstruction(
-            out, entry.getValue(), entry.getKey());
+      out.writeInt(leaseManager.countPath()); // write the size
+
+      for (Lease lease : leaseManager.getSortedLeases()) {
+        for(String path : lease.getPaths()) {
+          // verify that path exists in namespace
+          final INodeFileUnderConstruction cons;
+          try {
+            cons = INodeFileUnderConstruction.valueOf(dir.getINode(path), path);
+          } catch (UnresolvedLinkException e) {
+            throw new AssertionError("Lease files should reside on this FS");
+          }
+          FSImageSerialization.writeINodeUnderConstruction(out, cons, path);
+        }

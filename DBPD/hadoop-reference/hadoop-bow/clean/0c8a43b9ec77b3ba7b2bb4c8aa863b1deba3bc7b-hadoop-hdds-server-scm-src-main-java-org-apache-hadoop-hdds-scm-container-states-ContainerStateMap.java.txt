HDDS-429. StorageContainerManager lock optimization.
Contributed by Nanda Kumar.

-import org.apache.hadoop.util.AutoCloseableLock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
-  private final AutoCloseableLock autoLock;
+  private final ReadWriteLock lock;
-    autoLock = new AutoCloseableLock();
+    lock = new ReentrantReadWriteLock();
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.writeLock().lock();
+    try {
+    } finally {
+      lock.writeLock().unlock();
-    ContainerID id = new ContainerID(containerID);
-    return containerMap.get(id);
+    lock.readLock().lock();
+    try {
+      ContainerID id = new ContainerID(containerID);
+      return containerMap.get(id);
+    } finally {
+      lock.readLock().unlock();
+    }
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.readLock().lock();
+    try {
+    } finally {
+      lock.readLock().unlock();
-    // Take lock to avoid race condition around insertion.
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.writeLock().lock();
+    try {
+    } finally {
+      lock.writeLock().unlock();
-    // Take lock to avoid race condition.
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.writeLock().lock();
+    try {
+    } finally {
+      lock.writeLock().unlock();
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.readLock().lock();
+    try {
+    } finally {
+      lock.readLock().unlock();
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.writeLock().lock();
+    try {
+    } finally {
+      lock.writeLock().unlock();
-    try (AutoCloseableLock lock = autoLock.acquire()) {
-      currentInfo = containerMap.get(id);
+    lock.writeLock().lock();
+    try {
+      try {
+        currentInfo = containerMap.get(id);
-      if (currentInfo == null) {
-        throw new
-            SCMException("No such container.", FAILED_TO_FIND_CONTAINER);
+        if (currentInfo == null) {
+          throw new
+              SCMException("No such container.", FAILED_TO_FIND_CONTAINER);
+        }
+        // We are updating two places before this update is done, these can
+        // fail independently, since the code needs to handle it.
+
+        // We update the attribute map, if that fails it will throw an
+        // exception, so no issues, if we are successful, we keep track of the
+        // fact that we have updated the lifecycle state in the map, and update
+        // the container state. If this second update fails, we will attempt to
+        // roll back the earlier change we did. If the rollback fails, we can
+        // be in an inconsistent state,
+
+        info.setState(newState);
+        containerMap.put(id, info);
+        lifeCycleStateMap.update(currentState, newState, id);
+        LOG.trace("Updated the container {} to new state. Old = {}, new = " +
+            "{}", id, currentState, newState);
+      } catch (SCMException ex) {
+        LOG.error("Unable to update the container state. {}", ex);
+        // we need to revert the change in this attribute since we are not
+        // able to update the hash table.
+        LOG.info("Reverting the update to lifecycle state. Moving back to " +
+                "old state. Old = {}, Attempted state = {}", currentState,
+            newState);
+
+        containerMap.put(id, currentInfo);
+
+        // if this line throws, the state map can be in an inconsistent
+        // state, since we will have modified the attribute by the
+        // container state will not in sync since we were not able to put
+        // that into the hash table.
+        lifeCycleStateMap.update(newState, currentState, id);
+
+        throw new SCMException("Updating the container map failed.", ex,
+            FAILED_TO_CHANGE_CONTAINER_STATE);
-      // We are updating two places before this update is done, these can
-      // fail independently, since the code needs to handle it.
-
-      // We update the attribute map, if that fails it will throw an exception,
-      // so no issues, if we are successful, we keep track of the fact that we
-      // have updated the lifecycle state in the map, and update the container
-      // state. If this second update fails, we will attempt to roll back the
-      // earlier change we did. If the rollback fails, we can be in an
-      // inconsistent state,
-
-      info.setState(newState);
-      containerMap.put(id, info);
-      lifeCycleStateMap.update(currentState, newState, id);
-      LOG.trace("Updated the container {} to new state. Old = {}, new = " +
-          "{}", id, currentState, newState);
-    } catch (SCMException ex) {
-      LOG.error("Unable to update the container state. {}", ex);
-      // we need to revert the change in this attribute since we are not
-      // able to update the hash table.
-      LOG.info("Reverting the update to lifecycle state. Moving back to " +
-              "old state. Old = {}, Attempted state = {}", currentState,
-          newState);
-
-      containerMap.put(id, currentInfo);
-
-      // if this line throws, the state map can be in an inconsistent
-      // state, since we will have modified the attribute by the
-      // container state will not in sync since we were not able to put
-      // that into the hash table.
-      lifeCycleStateMap.update(newState, currentState, id);
-
-      throw new SCMException("Updating the container map failed.", ex,
-          FAILED_TO_CHANGE_CONTAINER_STATE);
-    }
-    // In case the container is set to closed state, it needs to be removed from
-    // the pipeline Map.
-    if (!info.isContainerOpen()) {
-      openPipelineMap.remove(info.getPipelineID(), id);
+      // In case the container is set to closed state, it needs to be removed
+      // from the pipeline Map.
+      if (!info.isContainerOpen()) {
+        openPipelineMap.remove(info.getPipelineID(), id);
+      }
+    } finally {
+      lock.writeLock().unlock();
-
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.readLock().lock();
+    try {
+    } finally {
+      lock.readLock().unlock();
-
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.readLock().lock();
+    try {
+    } finally {
+      lock.readLock().unlock();
-
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.readLock().lock();
+    try {
+    } finally {
+      lock.readLock().unlock();
-
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.readLock().lock();
+    try {
+    } finally {
+      lock.readLock().unlock();
-  NavigableSet<ContainerID> getContainerIDsByState(LifeCycleState state) {
+  public NavigableSet<ContainerID> getContainerIDsByState(
+      LifeCycleState state) {
-
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.readLock().lock();
+    try {
+    } finally {
+      lock.readLock().unlock();
-    try (AutoCloseableLock lock = autoLock.acquire()) {
+    lock.readLock().lock();
+    try {
+    } finally {
+      lock.readLock().unlock();

HDFS-4446. Support file snapshots with diff lists.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1443825 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.hdfs.server.namenode.INodeFile;
-
-import com.google.common.base.Preconditions;
+import org.apache.hadoop.hdfs.server.namenode.INodeFile;
+  /**
+   * The difference of an {@link INodeFile} between two snapshots.
+   */
+  static class FileDiff extends AbstractINodeDiff<INodeFile, FileDiff> {
+    /** The file size at snapshot creation time. */
+    final long fileSize;
+
+    FileDiff(Snapshot snapshot, INodeFile file) {
+      super(snapshot, null, null);
+      fileSize = file.computeFileSize(true, null);
+    }
+
+    @Override
+    INodeFile createSnapshotCopyOfCurrentINode(INodeFile currentINode) {
+      final INodeFile copy = new INodeFile(currentINode);
+      copy.setBlocks(null);
+      return copy;
+    }
+
+    @Override
+    void combinePosteriorAndCollectBlocks(INodeFile currentINode,
+        FileDiff posterior, BlocksMapUpdateInfo collectedBlocks) {
+      Util.collectBlocksAndClear((FileWithSnapshot)currentINode, collectedBlocks);
+    }
+    
+    @Override
+    public String toString() {
+      return super.toString() + " fileSize=" + fileSize + ", rep="
+          + (snapshotINode == null? "?": snapshotINode.getFileReplication());
+    }
+  }
+
-  
-  /** Utility methods for the classes which implement the interface. */
-  static class Util {
+  /** Is the current file deleted? */
+  public boolean isCurrentFileDeleted();
+
+  /** Are the current file and all snapshot copies deleted? */
+  public boolean isEverythingDeleted();
+
+  /** @return the max file replication in the inode and its snapshot copies. */
+  public short getMaxFileReplication();
+  
+  /** @return the max file size in the inode and its snapshot copies. */
+  public long computeMaxFileSize();
+
+  /** Utility methods for the classes which implement the interface. */
+  public static class Util {
+    /** @return the max file replication of the file in the diff list. */
+    static <N extends INodeFile, D extends AbstractINodeDiff<N, D>>
+        short getMaxFileReplication(short max,
+              final AbstractINodeDiffList<N, D> diffs) {
+      for(AbstractINodeDiff<N, D> d : diffs) {
+        if (d.snapshotINode != null) {
+          final short replication = d.snapshotINode.getFileReplication();
+          if (replication > max) {
+            max = replication;
+          }
+        }
+      }
+      return max;
+    }
+
-      short max = file.asINodeFile().getFileReplication();
+      short max = file.getMaxFileReplication();
-        final short replication = i.asINodeFile().getFileReplication();
+        final short replication = i.getMaxFileReplication();
-     * Remove the current inode from the circular linked list.
-     * any other inode, collect them and update the block list.
+     * any inode, collect them and update the block list.
-    static int collectSubtreeBlocksAndClear(final FileWithSnapshot file,
+    static void collectBlocksAndClear(final FileWithSnapshot file,
-      Preconditions.checkState(next != file, "this is the only remaining inode.");
-      // There are other inode(s) using the blocks.
-      // Compute max file size excluding this and find the last inode.
-      long max = next.asINodeFile().computeFileSize(true);
-      short maxReplication = next.asINodeFile().getFileReplication();
-      FileWithSnapshot last = next;
-      for(FileWithSnapshot i = next.getNext(); i != file; i = i.getNext()) {
-        final long size = i.asINodeFile().computeFileSize(true);
-        if (size > max) {
-          max = size;
+      // find max file size, max replication and the last inode.
+      long maxFileSize = file.computeMaxFileSize();
+      short maxReplication = file.getMaxFileReplication();
+      FileWithSnapshot last = null;
+      if (next != null && next != file) {
+        for(FileWithSnapshot i = next; i != file; i = i.getNext()) {
+          final long size = i.computeMaxFileSize();
+          if (size > maxFileSize) {
+            maxFileSize = size;
+          }
+          final short rep = i.getMaxFileReplication();
+          if (rep > maxReplication) {
+            maxReplication = rep;
+          }
+          last = i;
-        final short rep = i.asINodeFile().getFileReplication();
-        if (rep > maxReplication) {
-          maxReplication = rep;
-        }
-        last = i;
-      collectBlocksBeyondMaxAndClear(file, max, info);
-      
-      // remove this from the circular linked list.
-      last.setNext(next);
-      // Set the replication of the current INode to the max of all the other
-      // linked INodes, so that in case the current INode is retrieved from the
-      // blocksMap before it is removed or updated, the correct replication
-      // number can be retrieved.
-      file.asINodeFile().setFileReplication(maxReplication, null);
-      file.setNext(null);
-      // clear parent
-      file.asINodeFile().setParent(null);
-      return 1;
+      collectBlocksBeyondMax(file, maxFileSize, info);
+
+      if (file.isEverythingDeleted()) {
+        // Set the replication of the current INode to the max of all the other
+        // linked INodes, so that in case the current INode is retrieved from the
+        // blocksMap before it is removed or updated, the correct replication
+        // number can be retrieved.
+        if (maxReplication > 0) {
+          file.asINodeFile().setFileReplication(maxReplication, null);
+        }
+
+        // remove the file from the circular linked list.
+        if (last != null) {
+          last.setNext(next);
+        }
+        file.setNext(null);
+
+        file.asINodeFile().setBlocks(null);
+      }
-    static void collectBlocksBeyondMaxAndClear(final FileWithSnapshot file,
-            final long max, final BlocksMapUpdateInfo info) {
+    private static void collectBlocksBeyondMax(final FileWithSnapshot file,
+        final long max, final BlocksMapUpdateInfo collectedBlocks) {
-        // Replace the INode for all the remaining blocks in blocksMap
+        // collect update blocks
-        final BlocksMapINodeUpdateEntry entry = new BlocksMapINodeUpdateEntry(
-            file.asINodeFile(), next.asINodeFile());
-        if (info != null) {
+        if (next != null && next != file && file.isEverythingDeleted() && collectedBlocks != null) {
+          final BlocksMapINodeUpdateEntry entry = new BlocksMapINodeUpdateEntry(
+              file.asINodeFile(), next.asINodeFile());
-            info.addUpdateBlock(oldBlocks[i], entry);
+            collectedBlocks.addUpdateBlock(oldBlocks[i], entry);
-          for(FileWithSnapshot i = next; i != file; i = i.getNext()) {
+          
+          // set new blocks
+          file.asINodeFile().setBlocks(newBlocks);
+          for(FileWithSnapshot i = next; i != null && i != file; i = i.getNext()) {
-          if (info != null) {
+          if (collectedBlocks != null) {
-              info.addDeleteBlock(oldBlocks[n]);
+              collectedBlocks.addDeleteBlock(oldBlocks[n]);
-        file.asINodeFile().setBlocks(null);
+    
+    static String circularListString(final FileWithSnapshot file) {
+      final StringBuilder b = new StringBuilder("* -> ")
+          .append(file.asINodeFile().getObjectString());
+      FileWithSnapshot n = file.getNext();
+      for(; n != null && n != file; n = n.getNext()) {
+        b.append(" -> ").append(n.asINodeFile().getObjectString());
+      }
+      return b.append(n == null? " -> null": " -> *").toString();
+    }

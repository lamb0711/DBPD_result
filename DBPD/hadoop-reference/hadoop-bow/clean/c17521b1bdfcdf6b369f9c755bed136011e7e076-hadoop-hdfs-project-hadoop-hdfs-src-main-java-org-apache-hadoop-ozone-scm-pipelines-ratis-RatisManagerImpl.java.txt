HDFS-12387. Ozone: Support Ratis as a first class replication mechanism. Contributed by Anu Engineer.

-
+import com.google.common.base.Preconditions;
-import org.apache.hadoop.ozone.scm.container.placement.algorithms
-    .ContainerPlacementPolicy;
+import org.apache.hadoop.ozone.scm.container.placement.algorithms.ContainerPlacementPolicy;
+import org.apache.hadoop.ozone.scm.pipelines.PipelineSelector;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.apache.hadoop.ozone.protocol.proto.OzoneProtos.LifeCycleState.ALLOCATED;
+import static org.apache.hadoop.ozone.protocol.proto.OzoneProtos.LifeCycleState.OPEN;
+
+ *
+ * TODO : Introduce a state machine.
+  private final Set<DatanodeID> ratisMembers;
+  private final List<Pipeline> activePipelines;
+  private final AtomicInteger pipelineIndex;
+  private static final String PREFIX = "Ratis-";
+   *
+    ratisMembers = new HashSet<>();
+    activePipelines = new LinkedList<>();
+    pipelineIndex = new AtomicInteger(0);
+   * <p>
+   * TODO: Evaulate if we really need this lock. Right now favoring safety over
+   * speed.
-  public Pipeline getPipeline(String containerName,
+  public synchronized Pipeline getPipeline(String containerName,
+    /**
+     * In the ratis world, we have a very simple policy.
+     *
+     * 1. Try to create a pipeline if there are enough free nodes.
+     *
+     * 2. This allows all nodes to part of a pipeline quickly.
+     *
+     * 3. if there are not enough free nodes, return pipelines in a
+     * round-robin fashion.
+     *
+     * TODO: Might have to come up with a better algorithm than this.
+     * Create a new placement policy that returns pipelines in round robin
+     * fashion.
+     */
+    Pipeline pipeline = null;
+    List<DatanodeID> newNodes = allocatePipelineNodes(replicationFactor);
+    if (newNodes != null) {
+      Preconditions.checkState(newNodes.size() ==
+          getReplicationCount(replicationFactor), "Replication factor " +
+          "does not match the expected node count.");
+      pipeline = allocateRatisPipeline(newNodes, containerName);
+    } else {
+      pipeline = findOpenPipeline();
+    }
+    if (pipeline == null) {
+      LOG.error("Get pipeline call failed. We are not able to find free nodes" +
+          " or operational pipeline.");
+    }
+    return pipeline;
+  }
+
+  /**
+   * Find a pipeline that is operational.
+   *
+   * @return - Pipeline or null
+   */
+  Pipeline findOpenPipeline() {
+    Pipeline pipeline = null;
+    final int sentinal = -1;
+    if (activePipelines.size() == 0) {
+      LOG.error("No Operational pipelines found. Returning null.");
+      return pipeline;
+    }
+    int startIndex = getNextIndex();
+    int nextIndex = sentinal;
+    for (; startIndex != nextIndex; nextIndex = getNextIndex()) {
+      // Just walk the list in a circular way.
+      Pipeline temp =
+          activePipelines.get(nextIndex != sentinal ? nextIndex : startIndex);
+      // if we find an operational pipeline just return that.
+      if (temp.getLifeCycleState() == OPEN) {
+        pipeline = temp;
+        break;
+      }
+    }
+    return pipeline;
+  }
+
+  /**
+   * Allocate a new Ratis pipeline from the existing nodes.
+   *
+   * @param nodes - list of Nodes.
+   * @param containerName - container Name
+   * @return - Pipeline.
+   */
+  Pipeline allocateRatisPipeline(List<DatanodeID> nodes, String containerName) {
+    Preconditions.checkNotNull(nodes);
+    Pipeline pipeline = PipelineSelector.newPipelineFromNodes(nodes);
+    if (pipeline != null) {
+      // Start all pipeline names with "Ratis", easy to grep the logs.
+      String pipelineName = PREFIX +
+          UUID.randomUUID().toString().substring(PREFIX.length());
+      pipeline.setType(OzoneProtos.ReplicationType.RATIS);
+      pipeline.setLifeCycleState(ALLOCATED);
+      pipeline.setPipelineName(pipelineName);
+      pipeline.setContainerName(containerName);
+      LOG.info("Creating new ratis pipeline: {}", pipeline.toString());
+      activePipelines.add(pipeline);
+    }
+    return pipeline;
+  }
+
+  /**
+   * gets the next index of in the pipelines to get.
+   *
+   * @return index in the link list to get.
+   */
+  private int getNextIndex() {
+    return pipelineIndex.incrementAndGet() % activePipelines.size();
+  }
+
+  /**
+   * Allocates a set of new nodes for the Ratis pipeline.
+   *
+   * @param replicationFactor - One or Three
+   * @return List of Datanodes.
+   */
+  private List<DatanodeID> allocatePipelineNodes(OzoneProtos.ReplicationFactor
+      replicationFactor) {
+    List<DatanodeID> newNodesList = new LinkedList<>();
+    List<DatanodeID> datanodes =
+        nodeManager.getNodes(OzoneProtos.NodeState.HEALTHY);
+    int count = getReplicationCount(replicationFactor);
+    //TODO: Add Raft State to the Nodes, so we can query and skip nodes from
+    // data from datanode instead of maintaining a set.
+    for (DatanodeID datanode : datanodes) {
+      if (!ratisMembers.contains(datanode)) {
+        newNodesList.add(datanode);
+        if (newNodesList.size() == count) {
+          LOG.info("Allocating a new pipeline of size: {}", count);
+          return newNodesList;
+        }
+      }
+    }
+  private int getReplicationCount(OzoneProtos.ReplicationFactor factor) {
+    switch (factor) {
+    case ONE:
+      return 1;
+    case THREE:
+      return 3;
+    default:
+      throw new IllegalArgumentException("Unexpected replication count");
+    }
+  }
+

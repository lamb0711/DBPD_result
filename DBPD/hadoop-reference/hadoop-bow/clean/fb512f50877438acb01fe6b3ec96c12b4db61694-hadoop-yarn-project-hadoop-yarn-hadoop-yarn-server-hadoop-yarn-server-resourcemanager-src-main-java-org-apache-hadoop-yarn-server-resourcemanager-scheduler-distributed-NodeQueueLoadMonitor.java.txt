YARN-9697. Efficient allocation of Opportunistic containers. Contributed by Abhishek Modi.

+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import static org.apache.hadoop.yarn.conf.YarnConfiguration.DEFAULT_OPP_CONTAINER_ALLOCATION_NODES_NUMBER_USED;
+
-  final static Logger LOG = LoggerFactory.
+  private final static Logger LOG = LoggerFactory.
+  private int numNodesForAnyAllocation =
+      DEFAULT_OPP_CONTAINER_ALLOCATION_NODES_NUMBER_USED;
+
-      return (this == QUEUE_LENGTH) ? c.queueLength : c.queueWaitTime;
+      return (this == QUEUE_LENGTH) ?
+          c.queueLength.get() : c.queueWaitTime.get();
+    }
+
+    /**
+     * Increment the metric by a delta if it is below the threshold.
+     * @param c ClusterNode
+     * @param incrementSize increment size
+     * @return true if the metric was below threshold and was incremented.
+     */
+    public boolean compareAndIncrement(ClusterNode c, int incrementSize) {
+      if(this == QUEUE_LENGTH) {
+        int ret = c.queueLength.addAndGet(incrementSize);
+        if (ret <= c.queueCapacity) {
+          return true;
+        }
+        c.queueLength.addAndGet(-incrementSize);
+        return false;
+      }
+      // for queue wait time, we don't have any threshold.
+      return true;
-    int queueLength = 0;
-    int queueWaitTime = -1;
-    double timestamp;
+    private AtomicInteger queueLength = new AtomicInteger(0);
+    private AtomicInteger queueWaitTime = new AtomicInteger(-1);
+    private long timestamp;
-      this.queueLength = qLength;
+      this.queueLength.set(qLength);
-      this.queueWaitTime = wTime;
+      this.queueWaitTime.set(wTime);
-          this.queueLength >= this.queueCapacity;
+          this.queueLength.get() >= this.queueCapacity;
+  private final Map<String, RMNode> nodeByHostName =
+      new ConcurrentHashMap<>();
+  private final Map<String, Set<NodeId>> nodeIdsByRack =
+      new ConcurrentHashMap<>();
-      LoadComparator comparator) {
+      LoadComparator comparator, int numNodes) {
+    numNodesForAnyAllocation = numNodes;
+  public void stop() {
+    if (scheduledExecutor != null) {
+      scheduledExecutor.shutdown();
+    }
+  }
+
-    LOG.debug("Node added event from: {}", rmNode.getNode().getName());
-
+    this.nodeByHostName.put(rmNode.getHostName(), rmNode);
+    addIntoNodeIdsByRack(rmNode);
-    LOG.debug("Node delete event for: {}", removedRMNode.getNode().getName());
+    LOG.info("Node delete event for: {}", removedRMNode.getNode().getName());
+    this.nodeByHostName.remove(removedRMNode.getHostName());
+    removeFromNodeIdsByRack(removedRMNode);
+  public RMNode selectLocalNode(String hostName, Set<String> blacklist) {
+    if (blacklist.contains(hostName)) {
+      return null;
+    }
+    RMNode node = nodeByHostName.get(hostName);
+    if (node != null) {
+      ClusterNode clusterNode = clusterNodes.get(node.getNodeID());
+      if (comparator.compareAndIncrement(clusterNode, 1)) {
+        return node;
+      }
+    }
+    return null;
+  }
+
+  public RMNode selectRackLocalNode(String rackName, Set<String> blacklist) {
+    Set<NodeId> nodesOnRack = nodeIdsByRack.get(rackName);
+    if (nodesOnRack != null) {
+      for (NodeId nodeId : nodesOnRack) {
+        if (!blacklist.contains(nodeId.getHost())) {
+          ClusterNode node = clusterNodes.get(nodeId);
+          if (node != null && comparator.compareAndIncrement(node, 1)) {
+            return nodeByHostName.get(nodeId.getHost());
+          }
+        }
+      }
+    }
+    return null;
+  }
+
+  public RMNode selectAnyNode(Set<String> blacklist) {
+    List<NodeId> nodeIds = selectLeastLoadedNodes(numNodesForAnyAllocation);
+    int size = nodeIds.size();
+    if (size <= 0) {
+      return null;
+    }
+    Random rand = new Random();
+    int startIndex = rand.nextInt(size);
+    for (int i = 0; i < size; ++i) {
+      int index = i + startIndex;
+      index %= size;
+      NodeId nodeId = nodeIds.get(index);
+      if (nodeId != null && !blacklist.contains(nodeId.getHost())) {
+        ClusterNode node = clusterNodes.get(nodeId);
+        if (node != null && comparator.compareAndIncrement(node, 1)) {
+          return nodeByHostName.get(nodeId.getHost());
+        }
+      }
+    }
+    return null;
+  }
+
+  private void removeFromNodeIdsByRack(RMNode removedNode) {
+    nodeIdsByRack.computeIfPresent(removedNode.getRackName(),
+        (k, v) -> v).remove(removedNode.getNodeID());
+  }
+
+  private void addIntoNodeIdsByRack(RMNode addedNode) {
+    nodeIdsByRack.compute(addedNode.getRackName(), (k, v) -> v == null ?
+        ConcurrentHashMap.newKeySet() : v).add(addedNode.getNodeID());
+  }
+

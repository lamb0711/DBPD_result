HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes. Contributed by Colin Patrick McCabe.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430507 13f79535-47bb-0310-9956-ffa450edef68

-import java.net.Socket;
-import java.nio.channels.ReadableByteChannel;
+import org.apache.hadoop.hdfs.protocol.DatanodeID;
-import org.apache.hadoop.hdfs.protocol.datatransfer.IOStreamPair;
+import org.apache.hadoop.hdfs.net.Peer;
-import org.apache.hadoop.hdfs.security.token.block.DataEncryptionKey;
-import org.apache.hadoop.hdfs.security.token.block.BlockTokenIdentifier;
-import org.apache.hadoop.net.SocketInputWrapper;
-import org.apache.hadoop.security.token.Token;
+import com.google.common.annotations.VisibleForTesting;
+
-  
-  Socket dnSock;
-  // for now just sending the status code (e.g. checksumOk) after the read.
-  private IOStreamPair ioStreams;
-  private final ReadableByteChannel in;
+  private final DatanodeID datanodeID;
+  private final Peer peer;
+  @VisibleForTesting
+  public Peer getPeer() {
+    return peer;
+  }
+  
-    packetReceiver.receiveNextPacket(in);
+    packetReceiver.receiveNextPacket(peer.getInputStreamChannel());
-    packetReceiver.receiveNextPacket(in);
+    packetReceiver.receiveNextPacket(peer.getInputStreamChannel());
-      DataChecksum checksum, long firstChunkOffset, ReadableByteChannel in) {
+      DataChecksum checksum, long firstChunkOffset) {
-    this.dnSock = params.getSocket();
-    this.ioStreams = params.getIoStreamPair();
-    this.in = in;
+    this.datanodeID = params.getDatanodeID();
+    this.peer = params.getPeer();
-  public synchronized void close() throws IOException {
+  public synchronized void close(PeerCache peerCache) throws IOException {
-    if (dnSock != null) {
-      dnSock.close();
+    if (peerCache != null && sentStatusCode) {
+      peerCache.put(datanodeID, peer);
+    } else {
+      peer.close();
-  
-  /**
-   * Take the socket used to talk to the DN.
-   */
-  @Override
-  public Socket takeSocket() {
-    assert hasSentStatusCode() :
-      "BlockReader shouldn't give back sockets mid-read";
-    Socket res = dnSock;
-    dnSock = null;
-    return res;
-  }
-
-  /**
-   * Whether the BlockReader has reached the end of its input stream
-   * and successfully sent a status code back to the datanode.
-   */
-  @Override
-  public boolean hasSentStatusCode() {
-    return sentStatusCode;
-  }
-    assert !sentStatusCode : "already sent status code to " + dnSock;
+    assert !sentStatusCode : "already sent status code to " + peer;
-      writeReadResult(ioStreams.out, statusCode);
+      writeReadResult(peer.getOutputStream(), statusCode);
-               dnSock.getInetAddress() + ": " + e.getMessage());
+               peer.getRemoteAddressString() + ": " + e.getMessage());
-    IOStreamPair ioStreams = params.getIoStreamPair();
-    ReadableByteChannel ch;
-    if (ioStreams.in instanceof SocketInputWrapper) {
-      ch = ((SocketInputWrapper)ioStreams.in).getReadableByteChannel();
-    } else {
-      ch = (ReadableByteChannel) ioStreams.in;
-    }
-    
-          ioStreams.out));
+          params.getPeer().getOutputStream()));
-    DataInputStream in = new DataInputStream(ioStreams.in);
+    DataInputStream in = new DataInputStream(params.getPeer().getInputStream());
-    checkSuccess(status, params.getSocket(), params.getBlock(),
-        params.getFile());
+    checkSuccess(status, params.getPeer(), params.getBlock(), params.getFile());
-    return new RemoteBlockReader2(params, checksum, firstChunkOffset, ch);
+    return new RemoteBlockReader2(params, checksum, firstChunkOffset);
-      BlockOpResponseProto status, Socket sock,
+      BlockOpResponseProto status, Peer peer,
-                + sock.getLocalSocketAddress() + ", remote="
-                + sock.getRemoteSocketAddress() + ", for file " + file
+                + peer.getLocalAddressString() + ", remote="
+                + peer.getRemoteAddressString() + ", for file " + file
-            + sock.getLocalSocketAddress() + ", remote="
-            + sock.getRemoteSocketAddress() + ", for file " + file
+            + peer.getLocalAddressString() + ", remote="
+            + peer.getRemoteAddressString() + ", for file " + file
-
-  @Override
-  public IOStreamPair getStreams() {
-    return ioStreams;
-  }

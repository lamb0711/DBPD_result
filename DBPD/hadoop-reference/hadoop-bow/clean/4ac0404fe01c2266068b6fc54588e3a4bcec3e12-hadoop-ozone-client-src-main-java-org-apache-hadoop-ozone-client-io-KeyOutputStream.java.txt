HDDS-959. KeyOutputStream should handle retry failures. Contributed by Lokesh Jain.

+import org.apache.hadoop.hdds.scm.pipeline.Pipeline;
-import org.apache.hadoop.hdds.scm.XceiverClientSpi;
+import org.apache.ratis.protocol.AlreadyClosedException;
-  /**
-   * For testing purpose only. Not building output stream from blocks, but
-   * taking from externally.
-   *
-   * @param outputStream
-   * @param length
-   */
-  @VisibleForTesting
-  public void addStream(OutputStream outputStream, long length) {
-    streamEntries.add(
-        new BlockOutputStreamEntry(outputStream, length, checksum));
-  }
-
-    XceiverClientSpi xceiverClient =
-        xceiverClientManager.acquireClient(containerWithPipeline.getPipeline());
-        keyArgs.getKeyName(), xceiverClientManager, xceiverClient, requestID,
-        chunkSize, subKeyInfo.getLength(), streamBufferFlushSize,
-        streamBufferMaxSize, watchTimeout, bufferList, checksum));
+        keyArgs.getKeyName(), xceiverClientManager,
+        containerWithPipeline.getPipeline(), requestID, chunkSize,
+        subKeyInfo.getLength(), streamBufferFlushSize, streamBufferMaxSize,
+        watchTimeout, bufferList, checksum));
-        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)) {
+        boolean retryFailure = checkForRetryFailure(ioe);
+        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)
+            || retryFailure) {
-          handleException(current, currentStreamIndex);
+          handleException(current, currentStreamIndex, retryFailure);
+   * @param retryFailure if true the xceiverClient needs to be invalidated in
+   *                     the client cache.
-      int streamIndex) throws IOException {
+      int streamIndex, boolean retryFailure) throws IOException {
-    streamEntry.cleanup();
+    streamEntry.cleanup(retryFailure);
-      return checkIfContainerNotOpenOrRaftRetryFailureException(ioe) || Optional
+      return checkForException(ioe, ContainerNotOpenException.class) || Optional
-  private boolean checkIfContainerNotOpenOrRaftRetryFailureException(
-      IOException ioe) {
+  /**
+   * Checks if the provided exception signifies retry failure in ratis client.
+   * In case of retry failure, ratis client throws RaftRetryFailureException
+   * and all succeeding operations are failed with AlreadyClosedException.
+   */
+  private boolean checkForRetryFailure(IOException ioe) {
+    return checkForException(ioe, RaftRetryFailureException.class,
+        AlreadyClosedException.class);
+  }
+
+  private boolean checkForException(IOException ioe, Class... classes) {
-      if (t instanceof ContainerNotOpenException
-          || t instanceof RaftRetryFailureException) {
-        return true;
+      for (Class cls : classes) {
+        if (cls.isInstance(t)) {
+          return true;
+        }
-        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)) {
+        boolean retryFailure = checkForRetryFailure(ioe);
+        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)
+            || retryFailure) {
-          handleException(entry, streamIndex);
+          handleException(entry, streamIndex, retryFailure);
-    private final XceiverClientSpi xceiverClient;
+    private final Pipeline pipeline;
-        XceiverClientSpi xceiverClient, String requestId, int chunkSize,
+        Pipeline pipeline, String requestId, int chunkSize,
-      this.xceiverClient = xceiverClient;
+      this.pipeline = pipeline;
-    /**
-     * For testing purpose, taking a some random created stream instance.
-     * @param  outputStream a existing writable output stream
-     * @param  length the length of data to write to the stream
-     */
-    BlockOutputStreamEntry(OutputStream outputStream, long length,
-        Checksum checksum) {
-      this.outputStream = outputStream;
-      this.blockID = null;
-      this.key = null;
-      this.xceiverClientManager = null;
-      this.xceiverClient = null;
-      this.requestId = null;
-      this.chunkSize = -1;
-
-      this.length = length;
-      this.currentPosition = 0;
-      streamBufferFlushSize = 0;
-      streamBufferMaxSize = 0;
-      bufferList = null;
-      watchTimeout = 0;
-      this.checksum = checksum;
-    }
-
-    private void checkStream() {
+    /**
+     * BlockOutputStream is initialized in this function. This makes sure that
+     * xceiverClient initialization is not done during preallocation and only
+     * done when data is written.
+     * @throws IOException if xceiverClient initialization fails
+     */
+    private void checkStream() throws IOException {
-                xceiverClient, requestId, chunkSize, streamBufferFlushSize,
+                pipeline, requestId, chunkSize, streamBufferFlushSize,
-    void cleanup() {
+    void cleanup(boolean invalidateClient) throws IOException {
-        out.cleanup();
+        out.cleanup(invalidateClient);

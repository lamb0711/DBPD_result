HDFS-9857. Erasure Coding: Rename replication-based names in BlockManager to more generic [part-1]. Contributed by Rakesh R.

- * Keep prioritized queues of under replicated blocks.
- * Blocks have replication priority, with priority {@link #QUEUE_HIGHEST_PRIORITY}
- * indicating the highest priority.
+ * Keep prioritized queues of low redundant blocks.
+ * Blocks have redundancy priority, with priority
+ * {@link #QUEUE_HIGHEST_PRIORITY} indicating the highest priority.
- *   <li>{@link #QUEUE_HIGHEST_PRIORITY}: the blocks that must be replicated
+ *   <li>{@link #QUEUE_HIGHEST_PRIORITY}: the blocks that should be redundant
- *   <li>{@link #QUEUE_VERY_UNDER_REPLICATED}: blocks that are very
+ *   <li>{@link #QUEUE_VERY_LOW_REDUNDANCY}: blocks that are very
- *   <li>{@link #QUEUE_UNDER_REPLICATED}: blocks that are also under
+ *   <li>{@link #QUEUE_LOW_REDUNDANCY}: blocks that are also under
- *   they do not need to go into the {@link #QUEUE_VERY_UNDER_REPLICATED}
+ *   they do not need to go into the {@link #QUEUE_VERY_LOW_REDUNDANCY}
-class UnderReplicatedBlocks implements Iterable<BlockInfo> {
+class LowRedundancyBlocks implements Iterable<BlockInfo> {
-  static final int QUEUE_VERY_UNDER_REPLICATED = 1;
-  /** The queue for "normally" under-replicated blocks: {@value} */
-  static final int QUEUE_UNDER_REPLICATED = 2;
+  static final int QUEUE_VERY_LOW_REDUNDANCY = 1;
+  /**
+   * The queue for "normally" without sufficient redundancy blocks : {@value}.
+   */
+  static final int QUEUE_LOW_REDUNDANCY = 2;
-  UnderReplicatedBlocks() {
+  LowRedundancyBlocks() {
-  /** Return the total number of under replication blocks */
+  /** Return the total number of insufficient redundancy blocks. */
-  /** Return the number of under replication blocks excluding corrupt blocks */
-  synchronized int getUnderReplicatedBlockCount() {
+  /**
+   * Return the number of insufficiently redundant blocks excluding corrupt
+   * blocks.
+   */
+  synchronized int getLowRedundancyBlockCount() {
-  /** Check if a block is in the neededReplication queue */
+  /** Check if a block is in the neededReconstruction queue. */
-      //there is less than a third as many blocks as requested;
-      //this is considered very under-replicated
-      return QUEUE_VERY_UNDER_REPLICATED;
+      //can only afford one replica loss
+      //this is considered very insufficiently redundant blocks.
+      return QUEUE_VERY_LOW_REDUNDANCY;
-      //add to the normal queue for under replicated blocks
-      return QUEUE_UNDER_REPLICATED;
+      //add to the normal queue for insufficiently redundant blocks
+      return QUEUE_LOW_REDUNDANCY;
-      // there is less than a third as many blocks as requested;
-      // this is considered very under-replicated
-      return QUEUE_VERY_UNDER_REPLICATED;
+      // can only afford one replica loss
+      // this is considered very insufficiently redundant blocks.
+      return QUEUE_VERY_LOW_REDUNDANCY;
-      // add to the normal queue for under replicated blocks
-      return QUEUE_UNDER_REPLICATED;
+      // add to the normal queue for insufficiently redundant blocks.
+      return QUEUE_LOW_REDUNDANCY;
-  /** add a block to a under replication queue according to its priority
-   * @param block a under replication block
+  /**
+   * Add a block to insufficiently redundant queue according to its priority.
+   *
+   * @param block a low redundancy block
-          "BLOCK* NameSystem.UnderReplicationBlock.add: {}"
-              + " has only {} replicas and need {} replicas so is added to" +
-              " neededReplications at priority level {}", block, curReplicas,
-          expectedReplicas, priLevel);
+          "BLOCK* NameSystem.LowRedundancyBlock.add: {}"
+              + " has only {} replicas and need {} replicas so is added to"
+              + " neededReconstructions at priority level {}",
+          block, curReplicas, expectedReplicas, priLevel);
-  /** remove a block from a under replication queue */
+  /** Remove a block from a low redundancy queue. */
-   * Remove a block from the under replication queues.
+   * Remove a block from the low redundancy queues.
-   * @return true if the block was found and removed from one of the priority queues
+   * @return true if the block was found and removed from one of the priority
+   *         queues
-        "BLOCK* NameSystem.UnderReplicationBlock.remove: Removing block {}" +
-            " from priority queue {}", block, priLevel);
+          "BLOCK* NameSystem.LowRedundancyBlock.remove: Removing block {}"
+              + " from priority queue {}",
+          block, priLevel);
-              "BLOCK* NameSystem.UnderReplicationBlock.remove: Removing block" +
+              "BLOCK* NameSystem.LowRedundancyBlock.remove: Removing block" +
-   * @param block a under replicated block
+   * @param block a low redundancy block
-   * @param expectedReplicasDelta the change in the expected replica count from before
+   * @param expectedReplicasDelta the change in the expected replica count
+   *        from before
-      NameNode.stateChangeLog.debug("UnderReplicationBlocks.update " + 
+      NameNode.stateChangeLog.debug("LowRedundancyBlocks.update " +
-          "BLOCK* NameSystem.UnderReplicationBlock.update: {} has only {} " +
-              "replicas and needs {} replicas so is added to " +
-              "neededReplications at priority level {}", block, curReplicas,
-          curExpectedReplicas, curPri);
+          "BLOCK* NameSystem.LowRedundancyBlock.update: {} has only {} "
+              + "replicas and needs {} replicas so is added to "
+              + "neededReconstructions at priority level {}",
+          block, curReplicas, curExpectedReplicas, curPri);
-  
+
-   * Get a list of block lists to be replicated. The index of block lists
-   * represents its replication priority. Iterates each block list in priority
-   * order beginning with the highest priority list. Iterators use a bookmark to
-   * resume where the previous iteration stopped. Returns when the block count
-   * is met or iteration reaches the end of the lowest priority list, in which
-   * case bookmarks for each block list are reset to the heads of their
-   * respective lists.
+   * Get a list of block lists without sufficient redundancy. The index of
+   * block lists represents its replication priority. Iterates each block list
+   * in priority order beginning with the highest priority list. Iterators use
+   * a bookmark to resume where the previous iteration stopped. Returns when
+   * the block count is met or iteration reaches the end of the lowest priority
+   * list, in which case bookmarks for each block list are reset to the heads
+   * of their respective lists.
-   * @param blocksToProcess - number of blocks to fetch from underReplicated
+   * @param blocksToProcess - number of blocks to fetch from low redundancy
-   * @return Return a list of block lists to be replicated. The block list index
-   *         represents its replication priority.
+   * @return Return a list of block lists to be replicated. The block list
+   *         index represents its redundancy priority.
-  synchronized List<List<BlockInfo>> chooseUnderReplicatedBlocks(
+  synchronized List<List<BlockInfo>> chooseLowRedundancyBlocks(
-    final List<List<BlockInfo>> blocksToReplicate = new ArrayList<>(LEVEL);
-    
+    final List<List<BlockInfo>> blocksToReconstruct = new ArrayList<>(LEVEL);
+
-      // Go through all blocks that need replications with current priority.
-      // Set the iterator to the first unprocessed block at this priority level.
+      // Go through all blocks that need reconstructions with current priority.
+      // Set the iterator to the first unprocessed block at this priority level
-      blocksToReplicate.add(blocks);
+      blocksToReconstruct.add(blocks);
-    return blocksToReplicate;
+    return blocksToReconstruct;
-  /** returns an iterator of all blocks in a given priority queue */
+  /** Returns an iterator of all blocks in a given priority queue. */
-  /** return an iterator of all the under replication blocks */
+  /** Return an iterator of all the low redundancy blocks. */
-}
+}

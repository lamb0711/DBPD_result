HDFS-12518. Re-encryption should handle task cancellation and progress better.

+import java.util.HashMap;
-import java.util.concurrent.ConcurrentHashMap;
-  private final Map<Long, ZoneSubmissionTracker> submissions =
-      new ConcurrentHashMap<>();
+  private final Map<Long, ZoneSubmissionTracker> submissions = new HashMap<>();
-    for (ZoneSubmissionTracker zst : submissions.values()) {
-      zst.cancelAllTasks();
+    synchronized (this) {
+      for (ZoneSubmissionTracker zst : submissions.values()) {
+        zst.cancelAllTasks();
+      }
-    ZoneSubmissionTracker zst = submissions.get(zoneId);
-    if (zst != null) {
-      zst.cancelAllTasks();
-    }
+    removeZoneTrackerStopTasks(zoneId);
-    ZoneSubmissionTracker zst = submissions.get(zoneId);
-    if (zst != null) {
-      zst.cancelAllTasks();
-    }
-    submissions.remove(zoneId);
+    removeZoneTrackerStopTasks(zoneId);
+  synchronized private void removeZoneTrackerStopTasks(final long zoneId) {
+    final ZoneSubmissionTracker zst = submissions.get(zoneId);
+    if (zst != null) {
+      zst.cancelAllTasks();
+      submissions.remove(zoneId);
+    }
+  }
+
-    dir.hasReadLock();
+    assert dir.hasReadLock();
-   * get the tracker without holding the FSDirectory lock. This is only used for
-   * testing, when updater checks about pausing.
+   * Get the tracker without holding the FSDirectory lock.
+   * The submissions object is protected by object lock.
-  ZoneSubmissionTracker unprotectedGetTracker(final long zoneId) {
+  synchronized ZoneSubmissionTracker unprotectedGetTracker(final long zoneId) {
-  void addDummyTracker(final long zoneId) {
+  void addDummyTracker(final long zoneId, ZoneSubmissionTracker zst) {
-    assert !submissions.containsKey(zoneId);
-    final ZoneSubmissionTracker zst = new ZoneSubmissionTracker();
+    if (zst == null) {
+      zst = new ZoneSubmissionTracker();
+    }
-    Future future = batchService.submit(
+    final Future future = batchService.submit(
-    submissions.put(zoneId, zst);
+    synchronized (this) {
+      submissions.put(zoneId, zst);
+    }
+        getReencryptionStatus().markZoneStarted(zoneId);
+        resetSubmissionTracker(zoneId);
-      getReencryptionStatus().markZoneStarted(zoneId);
+  /**
+   * Reset the zone submission tracker for re-encryption.
+   * @param zoneId
+   */
+  synchronized private void resetSubmissionTracker(final long zoneId) {
+    ZoneSubmissionTracker zst = submissions.get(zoneId);
+    if (zst == null) {
+      zst = new ZoneSubmissionTracker();
+      submissions.put(zoneId, zst);
+    } else {
+      zst.reset();
+    }
+  }
+
-    // This also removes the zone from reencryptionStatus
-    submissions.remove(zoneId);
+    synchronized (this) {
+      submissions.remove(zoneId);
+    }
-    ZoneSubmissionTracker zst = submissions.get(zoneId);
-    if (zst == null) {
-      zst = new ZoneSubmissionTracker();
-      submissions.put(zoneId, zst);
+    ZoneSubmissionTracker zst;
+    synchronized (this) {
+      zst = submissions.get(zoneId);
+      if (zst == null) {
+        zst = new ZoneSubmissionTracker();
+        submissions.put(zoneId, zst);
+      }
-    int totalTasks = 0;
-    for (ZoneSubmissionTracker zst : submissions.values()) {
-      totalTasks += zst.getTasks().size();
-    }
-    if (totalTasks >= maxTasksPiled) {
+    int numTasks = numTasksSubmitted();
+    if (numTasks >= maxTasksPiled) {
-          + " re-encryption updater is {}", totalTasks);
-      while (totalTasks >= maxTasksPiled) {
+          + " re-encryption updater is {}", numTasks);
+      while (numTasks >= maxTasksPiled) {
-        totalTasks = 0;
-        for (ZoneSubmissionTracker zst : submissions.values()) {
-          totalTasks += zst.getTasks().size();
-        }
+        numTasks = numTasksSubmitted();
+  private synchronized int numTasksSubmitted() {
+    int ret = 0;
+    for (ZoneSubmissionTracker zst : submissions.values()) {
+      ret += zst.getTasks().size();
+    }
+    return ret;
+  }
+
-    dir.hasReadLock();
+    assert dir.hasReadLock();

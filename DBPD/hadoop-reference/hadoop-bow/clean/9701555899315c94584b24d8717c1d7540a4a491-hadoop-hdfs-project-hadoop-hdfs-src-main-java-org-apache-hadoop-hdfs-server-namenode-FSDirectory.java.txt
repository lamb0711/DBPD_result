HDFS-4534. Add INodeReference in order to support rename with snapshots.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1458164 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.snapshot.INodeDirectoryWithSnapshot;
-    INode srcChild = null;
-    byte[] srcChildName = null;
+    final INode srcChild = srcIIP.getLastINode();
+    final byte[] srcChildName = srcChild.getLocalNameBytes();
-      srcChild = removeLastINode(srcIIP);
-      if (srcChild == null) {
+      final int removedSrc = removeLastINode(srcIIP);
+      if (removedSrc == -1) {
-      srcChildName = srcChild.getLocalNameBytes();
-        srcChild = null;
+
+        if (srcIIP.getLatestSnapshot() != null) {
+          createReferences4Rename(srcChild, srcChildName,
+              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),
+              dstParent.asDirectory());
+        }
-      if (!added && srcChild != null) {
+      if (!added) {
-    final INode dstParent = dstIIP.getINode(-2);
+    INode dstParent = dstIIP.getINode(-2);
-    INode removedSrc = removeLastINode(srcIIP);
-    if (removedSrc == null) {
+
+    boolean undoRemoveSrc = true;
+    final int removedSrc = removeLastINode(srcIIP);
+    if (removedSrc == -1) {
-    final byte[] srcChildName = removedSrc.getLocalNameBytes();
-    byte[] dstChildName = null;
+    final INode srcChild = srcIIP.getLastINode();
+    final byte[] srcChildName = srcChild.getLocalNameBytes();
+
+    boolean undoRemoveDst = false;
-        removedDst = removeLastINode(dstIIP);
-        dstChildName = removedDst.getLocalNameBytes();
+        if (removeLastINode(dstIIP) != -1) {
+          removedDst = dstIIP.getLastINode();
+          undoRemoveDst = true;
+        }
+      srcChild.setLocalName(dstIIP.getLastLocalName());
-      removedSrc.setLocalName(dstIIP.getLastLocalName());
-      if (addLastINodeNoQuotaCheck(dstIIP, removedSrc)) {
-        removedSrc = null;
+      if (addLastINodeNoQuotaCheck(dstIIP, srcChild)) {
+        undoRemoveSrc = false;
+        dstParent = dstIIP.getINode(-2);
-          INode rmdst = removedDst;
-          removedDst = null;
+          undoRemoveDst = false;
-          filesDeleted = rmdst.cleanSubtree(null, dstIIP.getLatestSnapshot(),
-              collectedBlocks).get(Quota.NAMESPACE);
+          filesDeleted = removedDst.cleanSubtree(null,
+              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);
+        if (srcIIP.getLatestSnapshot() != null) {
+          createReferences4Rename(srcChild, srcChildName,
+              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),
+              dstParent.asDirectory());
+        }
+
-      if (removedSrc != null) {
+      if (undoRemoveSrc) {
-        removedSrc.setLocalName(srcChildName);
-        addLastINodeNoQuotaCheck(srcIIP, removedSrc);
+        srcChild.setLocalName(srcChildName);
+        addLastINodeNoQuotaCheck(srcIIP, srcChild);
-      if (removedDst != null) {
+      if (undoRemoveDst) {
-        removedDst.setLocalName(dstChildName);
+  /** The renamed inode is also in a snapshot, create references */
+  private static void createReferences4Rename(final INode srcChild,
+      final byte[] srcChildName, final INodeDirectoryWithSnapshot srcParent,
+      final INodeDirectory dstParent) {
+    final INodeReference.WithCount ref;
+    if (srcChild.isReference()) {
+      ref = (INodeReference.WithCount)srcChild.asReference().getReferredINode();
+    } else {
+      ref = dstParent.asDirectory().replaceChild4Reference(srcChild);
+    }
+    srcParent.replaceRemovedChild4Reference(srcChild, ref, srcChildName);
+  }
-    removeLastINode(iip);
+    final int removed = removeLastINode(iip);
+    if (removed == -1) {
+      return -1;
+    }
+    if (removed == 0) {
+      return 0;
+    }
+    oldnode.clear();
+    } else {
+      // update parent node
+      iip.setINode(pos - 1, child.getParent());
-   * @return the removed node; null if the removal fails.
+   * @return -1 for failing to remove;
+   *          0 for removing a reference;
+   *          1 for removing a non-reference inode. 
-  private INode removeLastINode(final INodesInPath inodesInPath)
+  private int removeLastINode(final INodesInPath iip)
-    final Snapshot latestSnapshot = inodesInPath.getLatestSnapshot();
-    final INode[] inodes = inodesInPath.getINodes();
-    final int pos = inodes.length - 1;
-    final INodeDirectory parent = inodes[pos-1].asDirectory();
-    final boolean removed = parent.removeChild(inodes[pos], latestSnapshot);
-    if (removed && latestSnapshot == null) {
-      inodesInPath.setINode(pos - 1, inodes[pos].getParent());
-      final Quota.Counts counts = inodes[pos].computeQuotaUsage();
-      updateCountNoQuotaCheck(inodesInPath, pos,
-          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));
+    final Snapshot latestSnapshot = iip.getLatestSnapshot();
+    final INode last = iip.getLastINode();
+    final INodeDirectory parent = iip.getINode(-2).asDirectory();
+    if (!parent.removeChild(last, latestSnapshot)) {
+      return -1;
-    return removed? inodes[pos]: null;
+
+    if (parent != last.getParent()) {
+      // parent is changed
+      iip.setINode(-2, last.getParent());
+    }
+    
+    if (latestSnapshot == null) {
+      final Quota.Counts counts = last.computeQuotaUsage();
+      updateCountNoQuotaCheck(iip, iip.getINodes().length - 1,
+          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));
+
+      if (INodeReference.tryRemoveReference(last) > 0) {
+        return 0;
+      }
+    }
+    return 1;

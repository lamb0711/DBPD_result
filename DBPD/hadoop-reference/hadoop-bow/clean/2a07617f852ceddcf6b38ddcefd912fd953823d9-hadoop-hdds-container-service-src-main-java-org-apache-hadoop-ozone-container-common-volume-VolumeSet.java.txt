HDDS-354. VolumeInfo.getScmUsed throws NPE. Contributed by Hanisha Koneru.

-import org.apache.hadoop.ozone.OzoneConfigKeys;
-import org.apache.hadoop.ozone.container.common.interfaces.VolumeChoosingPolicy;
-import org.apache.hadoop.util.AutoCloseableLock;
-import org.apache.hadoop.util.InstrumentedLock;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
-   * Lock to synchronize changes to the VolumeSet. Any update to
-   * {@link VolumeSet#volumeMap}, {@link VolumeSet#failedVolumeMap}, or
-   * {@link VolumeSet#volumeStateMap} should be done after acquiring this lock.
+   * A Reentrant Read Write Lock to synchronize volume operations in VolumeSet.
+   * Any update to {@link VolumeSet#volumeMap},
+   * {@link VolumeSet#failedVolumeMap}, or {@link VolumeSet#volumeStateMap}
+   * should be done after acquiring the write lock.
-  private final AutoCloseableLock volumeSetLock;
+  private final ReentrantReadWriteLock volumeSetRWLock;
-    this.volumeSetLock = new AutoCloseableLock(
-        new InstrumentedLock(getClass().getName(), LOG,
-            new ReentrantLock(true),
-            conf.getTimeDuration(
-                OzoneConfigKeys.HDDS_WRITE_LOCK_REPORTING_THRESHOLD_MS_KEY,
-                OzoneConfigKeys.HDDS_WRITE_LOCK_REPORTING_THRESHOLD_MS_DEFAULT,
-                TimeUnit.MILLISECONDS),
-            conf.getTimeDuration(
-                OzoneConfigKeys.HDDS_LOCK_SUPPRESS_WARNING_INTERVAL_MS_KEY,
-                OzoneConfigKeys.HDDS_LOCK_SUPPRESS_WARNING_INTERVAL_MS_DEAFULT,
-                TimeUnit.MILLISECONDS)));
+    this.volumeSetRWLock = new ReentrantReadWriteLock();
-  public void acquireLock() {
-    volumeSetLock.acquire();
+  /**
+   * Acquire Volume Set Read lock.
+   */
+  public void readLock() {
+    volumeSetRWLock.readLock().lock();
-  public void releaseLock() {
-    volumeSetLock.release();
+  /**
+   * Release Volume Set Read lock.
+   */
+  public void readUnlock() {
+    volumeSetRWLock.readLock().unlock();
+  /**
+   * Acquire Volume Set Write lock.
+   */
+  public void writeLock() {
+    volumeSetRWLock.writeLock().lock();
+  }
+
+  /**
+   * Release Volume Set Write lock.
+   */
+  public void writeUnlock() {
+    volumeSetRWLock.writeLock().unlock();
+  }
+
+
-    try (AutoCloseableLock lock = volumeSetLock.acquire()) {
+    this.writeLock();
+    try {
+    } finally {
+      this.writeUnlock();
-    try (AutoCloseableLock lock = volumeSetLock.acquire()) {
+    this.writeLock();
+    try {
+    } finally {
+      this.writeUnlock();
-    try (AutoCloseableLock lock = volumeSetLock.acquire()) {
+    this.writeLock();
+    try {
+    } finally {
+      this.writeUnlock();
-  public HddsVolume chooseVolume(long containerSize,
-      VolumeChoosingPolicy choosingPolicy) throws IOException {
-    return choosingPolicy.chooseVolume(getVolumesList(), containerSize);
-  }
-
-    StorageLocationReport[] reports = new StorageLocationReport[volumeMap
-        .size() + failedVolumeMap.size()];
-    int counter = 0;
-    HddsVolume hddsVolume;
-    for (Map.Entry<String, HddsVolume> entry : volumeMap.entrySet()) {
-      hddsVolume = entry.getValue();
-      VolumeInfo volumeInfo = hddsVolume.getVolumeInfo();
-      long scmUsed = 0;
-      long remaining = 0;
-      failed = false;
-      try {
-        scmUsed = volumeInfo.getScmUsed();
-        remaining = volumeInfo.getAvailable();
-      } catch (IOException ex) {
-        LOG.warn("Failed to get scmUsed and remaining for container " +
-            "storage location {}", volumeInfo.getRootDir());
-        // reset scmUsed and remaining if df/du failed.
-        scmUsed = 0;
-        remaining = 0;
-        failed = true;
-      }
+    this.readLock();
+    try {
+      StorageLocationReport[] reports = new StorageLocationReport[volumeMap
+          .size() + failedVolumeMap.size()];
+      int counter = 0;
+      HddsVolume hddsVolume;
+      for (Map.Entry<String, HddsVolume> entry : volumeMap.entrySet()) {
+        hddsVolume = entry.getValue();
+        VolumeInfo volumeInfo = hddsVolume.getVolumeInfo();
+        long scmUsed = 0;
+        long remaining = 0;
+        failed = false;
+        try {
+          scmUsed = volumeInfo.getScmUsed();
+          remaining = volumeInfo.getAvailable();
+        } catch (IOException ex) {
+          LOG.warn("Failed to get scmUsed and remaining for container " +
+              "storage location {}", volumeInfo.getRootDir());
+          // reset scmUsed and remaining if df/du failed.
+          scmUsed = 0;
+          remaining = 0;
+          failed = true;
+        }
-      StorageLocationReport.Builder builder =
-          StorageLocationReport.newBuilder();
-      builder.setStorageLocation(volumeInfo.getRootDir())
-          .setId(hddsVolume.getStorageID())
-          .setFailed(failed)
-          .setCapacity(hddsVolume.getCapacity())
-          .setRemaining(remaining)
-          .setScmUsed(scmUsed)
-          .setStorageType(hddsVolume.getStorageType());
-      StorageLocationReport r = builder.build();
-      reports[counter++] = r;
+        StorageLocationReport.Builder builder =
+            StorageLocationReport.newBuilder();
+        builder.setStorageLocation(volumeInfo.getRootDir())
+            .setId(hddsVolume.getStorageID())
+            .setFailed(failed)
+            .setCapacity(hddsVolume.getCapacity())
+            .setRemaining(remaining)
+            .setScmUsed(scmUsed)
+            .setStorageType(hddsVolume.getStorageType());
+        StorageLocationReport r = builder.build();
+        reports[counter++] = r;
+      }
+      for (Map.Entry<String, HddsVolume> entry : failedVolumeMap.entrySet()) {
+        hddsVolume = entry.getValue();
+        StorageLocationReport.Builder builder = StorageLocationReport
+            .newBuilder();
+        builder.setStorageLocation(hddsVolume.getHddsRootDir()
+            .getAbsolutePath()).setId(hddsVolume.getStorageID()).setFailed(true)
+            .setCapacity(0).setRemaining(0).setScmUsed(0).setStorageType(
+            hddsVolume.getStorageType());
+        StorageLocationReport r = builder.build();
+        reports[counter++] = r;
+      }
+      NodeReportProto.Builder nrb = NodeReportProto.newBuilder();
+      for (int i = 0; i < reports.length; i++) {
+        nrb.addStorageReport(reports[i].getProtoBufMessage());
+      }
+      return nrb.build();
+    } finally {
+      this.readUnlock();
-    for (Map.Entry<String, HddsVolume> entry : failedVolumeMap.entrySet()) {
-      hddsVolume = entry.getValue();
-      StorageLocationReport.Builder builder = StorageLocationReport
-          .newBuilder();
-      builder.setStorageLocation(hddsVolume.getHddsRootDir()
-          .getAbsolutePath()).setId(hddsVolume.getStorageID()).setFailed(true)
-          .setCapacity(0).setRemaining(0).setScmUsed(0).setStorageType(
-              hddsVolume.getStorageType());
-      StorageLocationReport r = builder.build();
-      reports[counter++] = r;
-    }
-    NodeReportProto.Builder nrb = NodeReportProto.newBuilder();
-    for (int i = 0; i < reports.length; i++) {
-      nrb.addStorageReport(reports[i].getProtoBufMessage());
-    }
-    return nrb.build();

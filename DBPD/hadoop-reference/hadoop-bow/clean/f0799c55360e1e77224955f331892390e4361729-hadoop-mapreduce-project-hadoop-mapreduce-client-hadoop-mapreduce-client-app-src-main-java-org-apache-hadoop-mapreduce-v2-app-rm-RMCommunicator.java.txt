MAPREDUCE-5562. Fixed MR App Master to perform pending tasks like staging-dir cleanup, sending job-end notification correctly when unregister with RM fails. Contributed by Zhijie Shen.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529682 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.mapreduce.MRConfig;
+import org.apache.hadoop.mapreduce.v2.app.MRAppMaster.RunningAppContext;
+import org.apache.hadoop.yarn.exceptions.YarnException;
+import com.google.common.annotations.VisibleForTesting;
+
-      FinalApplicationStatus finishState = FinalApplicationStatus.UNDEFINED;
-      JobImpl jobImpl = (JobImpl)job;
-      if (jobImpl.getInternalState() == JobStateInternal.SUCCEEDED) {
-        finishState = FinalApplicationStatus.SUCCEEDED;
-      } else if (jobImpl.getInternalState() == JobStateInternal.KILLED
-          || (jobImpl.getInternalState() == JobStateInternal.RUNNING && isSignalled)) {
-        finishState = FinalApplicationStatus.KILLED;
-      } else if (jobImpl.getInternalState() == JobStateInternal.FAILED
-          || jobImpl.getInternalState() == JobStateInternal.ERROR) {
-        finishState = FinalApplicationStatus.FAILED;
-      }
-      StringBuffer sb = new StringBuffer();
-      for (String s : job.getDiagnostics()) {
-        sb.append(s).append("\n");
-      }
-      LOG.info("Setting job diagnostics to " + sb.toString());
-
-      String historyUrl =
-          MRWebAppUtil.getApplicationWebURLOnJHSWithScheme(getConfig(),
-              context.getApplicationID());
-      LOG.info("History url is " + historyUrl);
-      FinishApplicationMasterRequest request =
-          FinishApplicationMasterRequest.newInstance(finishState,
-            sb.toString(), historyUrl);
-      while (true) {
-        FinishApplicationMasterResponse response =
-            scheduler.finishApplicationMaster(request);
-        if (response.getIsUnregistered()) {
-          break;
-        }
-        LOG.info("Waiting for application to be successfully unregistered.");
-        Thread.sleep(rmPollInterval);
-      }
+      doUnregistration();
+      // if unregistration failed, isLastAMRetry needs to be recalculated
+      // to see whether AM really has the chance to retry
+      RunningAppContext raContext = (RunningAppContext) context;
+      raContext.computeIsLastAMRetry();
+    }
+  }
+
+  @VisibleForTesting
+  protected void doUnregistration()
+      throws YarnException, IOException, InterruptedException {
+    FinalApplicationStatus finishState = FinalApplicationStatus.UNDEFINED;
+    JobImpl jobImpl = (JobImpl)job;
+    if (jobImpl.getInternalState() == JobStateInternal.SUCCEEDED) {
+      finishState = FinalApplicationStatus.SUCCEEDED;
+    } else if (jobImpl.getInternalState() == JobStateInternal.KILLED
+        || (jobImpl.getInternalState() == JobStateInternal.RUNNING && isSignalled)) {
+      finishState = FinalApplicationStatus.KILLED;
+    } else if (jobImpl.getInternalState() == JobStateInternal.FAILED
+        || jobImpl.getInternalState() == JobStateInternal.ERROR) {
+      finishState = FinalApplicationStatus.FAILED;
+    }
+    StringBuffer sb = new StringBuffer();
+    for (String s : job.getDiagnostics()) {
+      sb.append(s).append("\n");
+    }
+    LOG.info("Setting job diagnostics to " + sb.toString());
+
+    String historyUrl =
+        MRWebAppUtil.getApplicationWebURLOnJHSWithScheme(getConfig(),
+            context.getApplicationID());
+    LOG.info("History url is " + historyUrl);
+    FinishApplicationMasterRequest request =
+        FinishApplicationMasterRequest.newInstance(finishState,
+          sb.toString(), historyUrl);
+    while (true) {
+      FinishApplicationMasterResponse response =
+          scheduler.finishApplicationMaster(request);
+      if (response.getIsUnregistered()) {
+        // When excepting ClientService, other services are already stopped,
+        // it is safe to let clients know the final states. ClientService
+        // should wait for some time so clients have enough time to know the
+        // final states.
+        RunningAppContext raContext = (RunningAppContext) context;
+        raContext.markSuccessfulUnregistration();
+        break;
+      }
+      LOG.info("Waiting for application to be successfully unregistered.");
+      Thread.sleep(rmPollInterval);
-      @SuppressWarnings("unchecked")

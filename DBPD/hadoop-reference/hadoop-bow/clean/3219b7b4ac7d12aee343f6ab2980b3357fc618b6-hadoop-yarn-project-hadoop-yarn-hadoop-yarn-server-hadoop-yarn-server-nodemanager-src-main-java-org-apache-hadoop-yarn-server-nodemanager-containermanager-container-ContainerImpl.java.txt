YARN-4597. Introduce ContainerScheduler and a SCHEDULED state to NodeManager container lifecycle. (asuresh)

+import org.apache.hadoop.yarn.server.nodemanager.containermanager.scheduler.ContainerSchedulerEvent;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.scheduler.ContainerSchedulerEventType;
+  private volatile boolean isMarkeForKilling = false;
-            ContainerState.LOCALIZED,
+            ContainerState.SCHEDULED,
-        EnumSet.of(ContainerState.LOCALIZING, ContainerState.LOCALIZED),
+        EnumSet.of(ContainerState.LOCALIZING, ContainerState.SCHEDULED),
-        new KillDuringLocalizationTransition())
+        new KillBeforeRunningTransition())
-    // From LOCALIZED State
-    .addTransition(ContainerState.LOCALIZED, ContainerState.RUNNING,
+    // From SCHEDULED State
+    .addTransition(ContainerState.SCHEDULED, ContainerState.RUNNING,
-    .addTransition(ContainerState.LOCALIZED, ContainerState.EXITED_WITH_FAILURE,
+    .addTransition(ContainerState.SCHEDULED, ContainerState.EXITED_WITH_FAILURE,
-    .addTransition(ContainerState.LOCALIZED, ContainerState.LOCALIZED,
+    .addTransition(ContainerState.SCHEDULED, ContainerState.SCHEDULED,
-    .addTransition(ContainerState.LOCALIZED, ContainerState.KILLING,
-        ContainerEventType.KILL_CONTAINER, new KillTransition())
+    .addTransition(ContainerState.SCHEDULED, ContainerState.KILLING,
+        ContainerEventType.KILL_CONTAINER,
+        new KillBeforeRunningTransition())
-            ContainerState.LOCALIZED,
+            ContainerState.SCHEDULED,
-        ContainerState.LOCALIZED,
+        ContainerState.SCHEDULED,
-    case LOCALIZED:
+    case SCHEDULED:
+      return org.apache.hadoop.yarn.api.records.ContainerState.SCHEDULED;
+    case REINITIALIZING:
-      if (ContainerState.LOCALIZED == getContainerState()
+      if (ContainerState.SCHEDULED == getContainerState()
+    // Tell the scheduler the container is Done
+    eventHandler.handle(new ContainerSchedulerEvent(this,
+        ContainerSchedulerEventType.CONTAINER_COMPLETED));
-  private void sendLaunchEvent() {
+  @Override
+  public void sendLaunchEvent() {
+  private void sendScheduleEvent() {
+    dispatcher.getEventHandler().handle(
+        new ContainerSchedulerEvent(this,
+            ContainerSchedulerEventType.SCHEDULE_CONTAINER)
+    );
+  }
+
+  @SuppressWarnings("unchecked") // dispatcher not typed
+  @Override
+  public void sendKillEvent(int exitStatus, String description) {
+    this.isMarkeForKilling = true;
+    dispatcher.getEventHandler().handle(
+        new ContainerKillEvent(containerId, exitStatus, description));
+  }
+
+  @SuppressWarnings("unchecked") // dispatcher not typed
-   * and enters LOCALIZED state directly.
+   * and enters SCHEDULED state directly.
-        container.sendLaunchEvent();
+        container.sendScheduleEvent();
-        return ContainerState.LOCALIZED;
+        return ContainerState.SCHEDULED;
-      container.sendLaunchEvent();
+      container.sendScheduleEvent();
-      return ContainerState.LOCALIZED;
+      return ContainerState.SCHEDULED;
-   * Transition from LOCALIZED state to RUNNING state upon receiving
+   * Transition from SCHEDULED state to RUNNING state upon receiving
-        return ContainerState.LOCALIZED;
+        return ContainerState.SCHEDULED;
-   * Transition to LOCALIZED and wait for RE-LAUNCH
+   * Transition to SCHEDULED and wait for RE-LAUNCH
-
-      container.sendLaunchEvent();
+      container.isMarkeForKilling = false;
+      container.sendScheduleEvent();
-  static class KillDuringLocalizationTransition implements
+  static class KillBeforeRunningTransition implements
-   * - LOCALIZED -> KILLING.
+   * - SCHEDULED -> KILLING.
-            + oldState + "], eventType: [" + event.getType() + "]", e);
+            + oldState + "], eventType: [" + event.getType() + "]," +
+            " container: [" + containerID + "]", e);
+  public boolean isMarkedForKilling() {
+    return this.isMarkeForKilling;
+  }
+
+  @Override

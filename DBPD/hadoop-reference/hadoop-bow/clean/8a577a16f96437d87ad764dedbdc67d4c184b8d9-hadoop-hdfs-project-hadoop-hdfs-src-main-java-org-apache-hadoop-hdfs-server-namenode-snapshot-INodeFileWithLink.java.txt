HDFS-4150.  Update the inode in the block map when a snapshotted file or a snapshot file is deleted. Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1406763 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.List;
-
-import org.apache.hadoop.hdfs.protocol.Block;
-    for(INodeFileWithLink i = next; i != this; i = i.getNext()) {
+    // i may be null since next will be set to null when the INode is deleted
+    for(INodeFileWithLink i = next; i != this && i != null; i = i.getNext()) {
-  protected int collectSubtreeBlocksAndClear(List<Block> v) {
+  protected int collectSubtreeBlocksAndClear(BlocksMapUpdateInfo info) {
-      //this is the only remaining inode.
-      super.collectSubtreeBlocksAndClear(v);
+      // this is the only remaining inode.
+      super.collectSubtreeBlocksAndClear(info);
-      //There are other inode(s) using the blocks.
-      //Compute max file size excluding this and find the last inode. 
+      // There are other inode(s) using the blocks.
+      // Compute max file size excluding this and find the last inode. 
+      short maxReplication = next.getFileReplication();
+        final short rep = i.getFileReplication();
+        if (rep > maxReplication) {
+          maxReplication = rep;
+        }
-      collectBlocksBeyondMaxAndClear(max, v);
+      collectBlocksBeyondMaxAndClear(max, info);
-      //remove this from the circular linked list.
+      // remove this from the circular linked list.
+      // Set the replication of the current INode to the max of all the other
+      // linked INodes, so that in case the current INode is retrieved from the
+      // blocksMap before it is removed or updated, the correct replication
+      // number can be retrieved.
+      this.setFileReplication(maxReplication);
-      //clear parent
+      // clear parent
-  private void collectBlocksBeyondMaxAndClear(final long max, final List<Block> v) {
+  private void collectBlocksBeyondMaxAndClear(final long max,
+      final BlocksMapUpdateInfo info) {
-      //starting from block n, the data is beyond max.
+      // Replace the INode for all the remaining blocks in blocksMap
+      BlocksMapINodeUpdateEntry entry = new BlocksMapINodeUpdateEntry(this,
+          next);
+      if (info != null) {
+        for (int i = 0; i < n; i++) {
+          info.addUpdateBlock(oldBlocks[i], entry);
+        }
+      }
+      
+      // starting from block n, the data is beyond max.
-        //resize the array.  
+        // resize the array.  
-        //collect the blocks beyond max.  
-        if (v != null) {
+        // collect the blocks beyond max.  
+        if (info != null) {
-            v.add(oldBlocks[n]);
+            info.addDeleteBlock(oldBlocks[n]);

HDFS-4103. Support O(1) snapshot creation.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1424782 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.common.base.Preconditions;
-  static public INodeDirectorySnapshottable newInstance(
-      final INodeDirectory dir, final int snapshotQuota) {
-    return new INodeDirectorySnapshottable(dir, snapshotQuota);
-  }
+  /** Limit the number of snapshot per snapshottable directory. */
+  static final int SNAPSHOT_LIMIT = 1 << 16;
-  /** Snapshots of this directory in ascending order of snapshot id. */
-  private final List<Snapshot> snapshots = new ArrayList<Snapshot>();
-  /** Snapshots of this directory in ascending order of snapshot names. */
-  private final List<Snapshot> snapshotsByNames = new ArrayList<Snapshot>();
-  
-   * @return {@link #snapshots}
+   * Snapshots of this directory in ascending order of snapshot names.
+   * Note that snapshots in ascending order of snapshot id are stored in
+   * {@link INodeDirectoryWithSnapshot}.diffs (a private field).
-  @VisibleForTesting
-  List<Snapshot> getSnapshots() {
-    return snapshots;
-  }
+  private final List<Snapshot> snapshotsByNames = new ArrayList<Snapshot>();
-  private int snapshotQuota;
+  private int snapshotQuota = SNAPSHOT_LIMIT;
-  private INodeDirectorySnapshottable(INodeDirectory dir,
-      final int snapshotQuota) {
-    super(dir, true);
-    setSnapshotQuota(snapshotQuota);
+  public INodeDirectorySnapshottable(INodeDirectory dir) {
+    super(dir, true, null);
+  /** @return the number of existing snapshots. */
-    return snapshots.size();
+    return getSnapshotsByNames().size();
-      INodeDirectoryWithSnapshot ssRoot = snapshot.getRoot();
+      final INodeDirectory ssRoot = snapshot.getRoot();
-  /** @return the last snapshot. */
-  public Snapshot getLastSnapshot() {
-    final int n = snapshots.size();
-    return n == 0? null: snapshots.get(n - 1);
-  }
-
-    if (snapshots.size() + 1 > snapshotQuota) {
+    final int n = getNumSnapshots();
+    if (n + 1 > snapshotQuota) {
-          + snapshots.size() + " snapshot(s) and the snapshot quota is "
+          + n + " snapshot(s) and the snapshot quota is "
-    snapshots.add(s);
+    addSnapshotDiff(s, this, true);
-    s.getRoot().updateModificationTime(timestamp);
-    updateModificationTime(timestamp);
+    s.getRoot().updateModificationTime(timestamp, null);
+    updateModificationTime(timestamp, null);
-  
+
+  /**
+   * Replace itself with {@link INodeDirectoryWithSnapshot} or
+   * {@link INodeDirectory} depending on the latest snapshot.
+   */
+  void replaceSelf(final Snapshot latest) {
+    if (latest == null) {
+      Preconditions.checkState(getLastSnapshot() == null,
+          "latest == null but getLastSnapshot() != null, this=%s", this);
+      replaceSelf4INodeDirectory();
+    } else {
+      replaceSelf4INodeDirectoryWithSnapshot(latest).recordModification(latest);
+    }
+  }
+
-  public void dumpTreeRecursively(PrintWriter out, StringBuilder prefix) {
-    super.dumpTreeRecursively(out, prefix);
+  public void dumpTreeRecursively(PrintWriter out, StringBuilder prefix,
+      Snapshot snapshot) {
+    super.dumpTreeRecursively(out, prefix, snapshot);
-    out.print(prefix);
-    out.print(snapshots.size());
-    out.print(snapshots.size() <= 1 ? " snapshot of " : " snapshots of ");
-    out.println(getLocalName());
-
-    dumpTreeRecursively(out, prefix, new Iterable<INodeDirectoryWithSnapshot>() {
-      @Override
-      public Iterator<INodeDirectoryWithSnapshot> iterator() {
-        return new Iterator<INodeDirectoryWithSnapshot>() {
-          final Iterator<Snapshot> i = snapshots.iterator();
-
-          @Override
-          public boolean hasNext() {
-            return i.hasNext();
-          }
-
-          @Override
-          public INodeDirectoryWithSnapshot next() {
-            return i.next().getRoot();
-          }
-
-          @Override
-          public void remove() {
-            throw new UnsupportedOperationException();
-          }
-        };
+    try {
+    if (snapshot == null) {
+      out.println();
+      out.print(prefix);
+      int n = 0;
+      for(SnapshotDiff diff : getSnapshotDiffs()) {
+        if (diff.isSnapshotRoot()) {
+          n++;
+        }
-    });
+      out.print(n);
+      out.print(n <= 1 ? " snapshot of " : " snapshots of ");
+      final String name = getLocalName();
+      out.println(name.isEmpty()? "/": name);
+
+      dumpTreeRecursively(out, prefix, new Iterable<Pair<? extends INode, Snapshot>>() {
+        @Override
+        public Iterator<Pair<? extends INode, Snapshot>> iterator() {
+          return new Iterator<Pair<? extends INode, Snapshot>>() {
+            final Iterator<SnapshotDiff> i = getSnapshotDiffs().iterator();
+            private SnapshotDiff next = findNext();
+  
+            private SnapshotDiff findNext() {
+              for(; i.hasNext(); ) {
+                final SnapshotDiff diff = i.next();
+                if (diff.isSnapshotRoot()) {
+                  return diff;
+                }
+              }
+              return null;
+            }
+
+            @Override
+            public boolean hasNext() {
+              return next != null;
+            }
+  
+            @Override
+            public Pair<INodeDirectory, Snapshot> next() {
+              final Snapshot s = next.snapshot;
+              final Pair<INodeDirectory, Snapshot> pair =
+                  new Pair<INodeDirectory, Snapshot>(s.getRoot(), s);
+              next = findNext();
+              return pair;
+            }
+  
+            @Override
+            public void remove() {
+              throw new UnsupportedOperationException();
+            }
+          };
+        }
+      });
+    }
+    } catch(Exception e) {
+      throw new RuntimeException("this=" + this, e);
+    }

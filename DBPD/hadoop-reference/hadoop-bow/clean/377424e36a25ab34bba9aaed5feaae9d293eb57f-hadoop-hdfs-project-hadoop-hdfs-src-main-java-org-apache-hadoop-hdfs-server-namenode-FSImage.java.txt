HDFS-5966. Fix rollback of rolling upgrade in NameNode HA setup.  Contributed by jing9


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1569885 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.hadoop.hdfs.server.common.HdfsServerConstants.RollingUpgradeStartupOption;
-    final boolean rollingRollback = startOpt == StartupOption.ROLLINGUPGRADE
-        && startOpt.getRollingUpgradeStartupOption() == 
-           RollingUpgradeStartupOption.ROLLBACK;
+    final boolean rollingRollback = StartupOption
+        .isRollingUpgradeRollback(startOpt);
-    renameCheckpoint(ckptId, NameNodeFile.IMAGE_ROLLBACK, NameNodeFile.IMAGE);
+    renameCheckpoint(ckptId, NameNodeFile.IMAGE_ROLLBACK, NameNodeFile.IMAGE,
+        true);
+    String nameserviceId = DFSUtil.getNamenodeNameServiceId(conf);
+    if (HAUtil.isHAEnabled(conf, nameserviceId)) {
+      // close the editlog since it is currently open for write
+      this.editLog.close();
+      // reopen the editlog for read
+      this.editLog.initSharedJournalsForRead();
+    }
-    } else if (HAUtil.isHAEnabled(conf, nameserviceId) &&
-        startOpt == StartupOption.UPGRADE) {
-      // This NN is HA, but we're doing an upgrade so init the edit log for
-      // write.
+    } else if (HAUtil.isHAEnabled(conf, nameserviceId)
+        && (startOpt == StartupOption.UPGRADE || StartupOption
+            .isRollingUpgradeRollback(startOpt))) {
+      // This NN is HA, but we're doing an upgrade or a rollback of rolling
+      // upgrade so init the edit log for write.
-      long sharedLogCTime = editLog.getSharedLogCTime();
-      if (this.storage.getCTime() < sharedLogCTime) {
-        throw new IOException("It looks like the shared log is already " +
-            "being upgraded but this NN has not been upgraded yet. You " +
-            "should restart this NameNode with the '" +
-            StartupOption.BOOTSTRAPSTANDBY.getName() + "' option to bring " +
-            "this NN in sync with the other.");
+      if (startOpt == StartupOption.UPGRADE) {
+        long sharedLogCTime = editLog.getSharedLogCTime();
+        if (this.storage.getCTime() < sharedLogCTime) {
+          throw new IOException("It looks like the shared log is already " +
+              "being upgraded but this NN has not been upgraded yet. You " +
+              "should restart this NameNode with the '" +
+              StartupOption.BOOTSTRAPSTANDBY.getName() + "' option to bring " +
+              "this NN in sync with the other.");
+        }
-        boolean rollingRollback = startOpt == StartupOption.ROLLINGUPGRADE && 
-            startOpt.getRollingUpgradeStartupOption() == 
-            RollingUpgradeStartupOption.ROLLBACK;
+        boolean rollingRollback = StartupOption
+            .isRollingUpgradeRollback(startOpt);
-      renameCheckpoint(txid, NameNodeFile.IMAGE_NEW, nnf);
+      renameCheckpoint(txid, NameNodeFile.IMAGE_NEW, nnf, false);
-      NameNodeFile toNnf) throws IOException {
+      NameNodeFile toNnf, boolean renameMD5) throws IOException {
-        renameImageFileInDir(sd, fromNnf, toNnf, txid);
+        renameImageFileInDir(sd, fromNnf, toNnf, txid, renameMD5);
-  private void renameImageFileInDir(StorageDirectory sd,
-      NameNodeFile fromNnf, NameNodeFile toNnf, long txid) throws IOException {
+  private void renameImageFileInDir(StorageDirectory sd, NameNodeFile fromNnf,
+      NameNodeFile toNnf, long txid, boolean renameMD5) throws IOException {
-    }    
+    }
+    if (renameMD5) {
+      MD5FileUtils.renameMD5File(fromFile, toFile);
+    }
-    renameCheckpoint(txid, NameNodeFile.IMAGE_NEW, NameNodeFile.IMAGE);
+    renameCheckpoint(txid, NameNodeFile.IMAGE_NEW, NameNodeFile.IMAGE, false);

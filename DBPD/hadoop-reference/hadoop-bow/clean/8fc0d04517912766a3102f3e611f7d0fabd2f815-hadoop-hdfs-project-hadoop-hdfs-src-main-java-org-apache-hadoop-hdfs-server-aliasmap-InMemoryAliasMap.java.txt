HDFS-14001. [PROVIDED Storage] bootstrapStandby should manage the InMemoryAliasMap. Contributed by Virajith Jalaparti.

+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
+import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;
+import org.apache.hadoop.fs.FileUtil;
+import org.apache.hadoop.hdfs.server.namenode.ImageServlet;
+import org.apache.hadoop.hdfs.server.namenode.TransferFsImage;
+import org.apache.hadoop.hdfs.util.DataTransferThrottler;
+import org.apache.hadoop.io.IOUtils;
+import org.iq80.leveldb.ReadOptions;
+import org.iq80.leveldb.Snapshot;
+import javax.servlet.http.HttpServletResponse;
+import java.io.BufferedOutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.net.URI;
+  private static final String SNAPSHOT_COPY_DIR = "aliasmap_snapshot";
+  private static final String TAR_NAME = "aliasmap.tar.gz";
+  private final URI aliasMapURI;
-  @VisibleForTesting
-  static String createPathErrorMessage(String directory) {
-    return new StringBuilder()
-        .append("Configured directory '")
-        .append(directory)
-        .append("' doesn't exist")
-        .toString();
-  }
-
-    LOG.info("Attempting to load InMemoryAliasMap from \"{}\"", directory);
+    if (directory == null) {
+      throw new IOException("InMemoryAliasMap location is null");
+    }
-      String error = createPathErrorMessage(directory);
-      throw new IOException(error);
+      LOG.warn("InMemoryAliasMap location {} is missing. Creating it.",
+          levelDBpath);
+      if(!levelDBpath.mkdirs()) {
+        throw new IOException(
+            "Unable to create missing aliasmap location: " + levelDBpath);
+      }
-    InMemoryAliasMap aliasMap = new InMemoryAliasMap(levelDb, blockPoolID);
+    InMemoryAliasMap aliasMap =  new InMemoryAliasMap(levelDBpath.toURI(),
+        levelDb, blockPoolID);
-  InMemoryAliasMap(DB levelDb, String blockPoolID) {
+  InMemoryAliasMap(URI aliasMapURI, DB levelDb, String blockPoolID) {
+    this.aliasMapURI = aliasMapURI;
+   * Transfer this aliasmap for bootstrapping standby Namenodes. The map is
+   * transferred as a tar.gz archive. This archive needs to be extracted on the
+   * standby Namenode.
+   *
+   * @param response http response.
+   * @param conf configuration to use.
+   * @param aliasMap aliasmap to transfer.
+   * @throws IOException
+   */
+  public static void transferForBootstrap(HttpServletResponse response,
+      Configuration conf, InMemoryAliasMap aliasMap) throws IOException {
+    File aliasMapSnapshot = null;
+    File compressedAliasMap = null;
+    try {
+      aliasMapSnapshot = createSnapshot(aliasMap);
+      // compress the snapshot that is associated with the
+      // block pool id of the aliasmap.
+      compressedAliasMap = getCompressedAliasMap(
+          new File(aliasMapSnapshot, aliasMap.blockPoolID));
+      try (FileInputStream fis = new FileInputStream(compressedAliasMap)) {
+        ImageServlet.setVerificationHeadersForGet(response, compressedAliasMap);
+        ImageServlet.setFileNameHeaders(response, compressedAliasMap);
+        // send file
+        DataTransferThrottler throttler =
+            ImageServlet.getThrottlerForBootstrapStandby(conf);
+        TransferFsImage.copyFileToStream(response.getOutputStream(),
+            compressedAliasMap, fis, throttler);
+      }
+    } finally {
+      // cleanup the temporary snapshot and compressed files.
+      StringBuilder errMessage = new StringBuilder();
+      if (compressedAliasMap != null
+          && !FileUtil.fullyDelete(compressedAliasMap)) {
+        errMessage.append("Failed to fully delete compressed aliasmap ")
+            .append(compressedAliasMap.getAbsolutePath()).append("\n");
+      }
+      if (aliasMapSnapshot != null && !FileUtil.fullyDelete(aliasMapSnapshot)) {
+        errMessage.append("Failed to fully delete the aliasmap snapshot ")
+            .append(aliasMapSnapshot.getAbsolutePath()).append("\n");
+      }
+      if (errMessage.length() > 0) {
+        throw new IOException(errMessage.toString());
+      }
+    }
+  }
+
+  /**
+   * Create a new LevelDB store which is a snapshot copy of the original
+   * aliasmap.
+   *
+   * @param aliasMap original aliasmap.
+   * @return the {@link File} where the snapshot is created.
+   * @throws IOException
+   */
+  static File createSnapshot(InMemoryAliasMap aliasMap) throws IOException {
+    File originalAliasMapDir = new File(aliasMap.aliasMapURI);
+    String bpid = originalAliasMapDir.getName();
+    File snapshotDir =
+        new File(originalAliasMapDir.getParent(), SNAPSHOT_COPY_DIR);
+    File newLevelDBDir = new File(snapshotDir, bpid);
+    if (!newLevelDBDir.mkdirs()) {
+      throw new IOException(
+          "Unable to create aliasmap snapshot directory " + newLevelDBDir);
+    }
+    // get a snapshot for the original DB.
+    DB originalDB = aliasMap.levelDb;
+    try (Snapshot snapshot = originalDB.getSnapshot()) {
+      // create a new DB for the snapshot and copy all K,V pairs.
+      Options options = new Options();
+      options.createIfMissing(true);
+      try (DB snapshotDB = JniDBFactory.factory.open(newLevelDBDir, options)) {
+        try (DBIterator iterator =
+            originalDB.iterator(new ReadOptions().snapshot(snapshot))) {
+          iterator.seekToFirst();
+          while (iterator.hasNext()) {
+            Map.Entry<byte[], byte[]> entry = iterator.next();
+            snapshotDB.put(entry.getKey(), entry.getValue());
+          }
+        }
+      }
+    }
+
+    return snapshotDir;
+  }
+
+  /**
+   * Compress the given aliasmap directory as tar.gz.
+   *
+   * @return a reference to the compressed aliasmap.
+   * @throws IOException
+   */
+  private static File getCompressedAliasMap(File aliasMapDir)
+      throws IOException {
+    File outCompressedFile = new File(aliasMapDir.getParent(), TAR_NAME);
+    BufferedOutputStream bOut = null;
+    GzipCompressorOutputStream gzOut = null;
+    TarArchiveOutputStream tOut = null;
+    try {
+      bOut = new BufferedOutputStream(new FileOutputStream(outCompressedFile));
+      gzOut = new GzipCompressorOutputStream(bOut);
+      tOut = new TarArchiveOutputStream(gzOut);
+      addFileToTarGzRecursively(tOut, aliasMapDir, "", new Configuration());
+    } finally {
+      if (tOut != null) {
+        tOut.finish();
+      }
+      IOUtils.cleanupWithLogger(null, tOut, gzOut, bOut);
+    }
+    return outCompressedFile;
+  }
+
+  /**
+   * Add all contents of the given file to the archive.
+   *
+   * @param tOut archive to use.
+   * @param file file to archive.
+   * @param prefix path prefix.
+   * @throws IOException
+   */
+  private static void addFileToTarGzRecursively(TarArchiveOutputStream tOut,
+      File file, String prefix, Configuration conf) throws IOException {
+    String entryName = prefix + file.getName();
+    TarArchiveEntry tarEntry = new TarArchiveEntry(file, entryName);
+    tOut.putArchiveEntry(tarEntry);
+
+    LOG.debug("Adding entry {} to alias map archive", entryName);
+    if (file.isFile()) {
+      try (FileInputStream in = new FileInputStream(file)) {
+        IOUtils.copyBytes(in, tOut, conf, false);
+      }
+      tOut.closeArchiveEntry();
+    } else {
+      tOut.closeArchiveEntry();
+      File[] children = file.listFiles();
+      if (children != null) {
+        for (File child : children) {
+          // skip the LOCK file
+          if (!child.getName().equals("LOCK")) {
+            addFileToTarGzRecursively(tOut, child, entryName + "/", conf);
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Extract the aliasmap archive to complete the bootstrap process. This method
+   * has to be called after the aliasmap archive is transfered from the primary
+   * Namenode.
+   *
+   * @param aliasMap location of the aliasmap.
+   * @throws IOException
+   */
+  public static void completeBootstrapTransfer(File aliasMap)
+      throws IOException {
+    File tarname = new File(aliasMap, TAR_NAME);
+    if (!tarname.exists()) {
+      throw new IOException(
+          "Aliasmap archive (" + tarname + ") does not exist");
+    }
+    try {
+      FileUtil.unTar(tarname, aliasMap);
+    } finally {
+      // delete the archive.
+      if(!FileUtil.fullyDelete(tarname)) {
+        LOG.warn("Failed to fully delete aliasmap archive: " + tarname);
+      }
+    }
+  }
+
+  /**

YARN-6877. Create an abstract log reader for extendability. Contributed by Xuan Gong.

-import java.io.DataInputStream;
-import java.io.EOFException;
-import java.util.ArrayList;
-import java.util.List;
-import org.apache.commons.math3.util.Pair;
-import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.fs.FileStatus;
-import org.apache.hadoop.fs.HarFs;
-import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.fs.RemoteIterator;
-import org.apache.hadoop.yarn.api.records.ApplicationId;
-import org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogKey;
-import org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogReader;
-import org.apache.hadoop.yarn.util.Times;
-   * Return a list of {@link ContainerLogMeta} for a container
-   * from Remote FileSystem.
-   *
-   * @param conf the configuration
-   * @param appId the applicationId
-   * @param containerIdStr the containerId
-   * @param nodeId the nodeId
-   * @param appOwner the application owner
-   * @return a list of {@link ContainerLogMeta}
-   * @throws IOException if there is no available log file
-   */
-  public static List<ContainerLogMeta> getContainerLogMetaFromRemoteFS(
-      Configuration conf, ApplicationId appId, String containerIdStr,
-      String nodeId, String appOwner) throws IOException {
-    List<ContainerLogMeta> containersLogMeta = new ArrayList<>();
-    boolean getAllContainers = (containerIdStr == null);
-    String nodeIdStr = (nodeId == null) ? null
-        : LogAggregationUtils.getNodeString(nodeId);
-    RemoteIterator<FileStatus> nodeFiles = LogAggregationUtils
-        .getRemoteNodeFileDir(conf, appId, appOwner);
-    if (nodeFiles == null) {
-      throw new IOException("There is no available log fils for "
-          + "application:" + appId);
-    }
-    while (nodeFiles.hasNext()) {
-      FileStatus thisNodeFile = nodeFiles.next();
-      if (nodeIdStr != null) {
-        if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {
-          continue;
-        }
-      }
-      if (!thisNodeFile.getPath().getName()
-          .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {
-        AggregatedLogFormat.LogReader reader =
-            new AggregatedLogFormat.LogReader(conf,
-            thisNodeFile.getPath());
-        try {
-          DataInputStream valueStream;
-          LogKey key = new LogKey();
-          valueStream = reader.next(key);
-          while (valueStream != null) {
-            if (getAllContainers || (key.toString().equals(containerIdStr))) {
-              ContainerLogMeta containerLogMeta = new ContainerLogMeta(
-                  key.toString(), thisNodeFile.getPath().getName());
-              while (true) {
-                try {
-                  Pair<String, String> logMeta =
-                      LogReader.readContainerMetaDataAndSkipData(
-                          valueStream);
-                  containerLogMeta.addLogMeta(
-                      logMeta.getFirst(),
-                      logMeta.getSecond(),
-                      Times.format(thisNodeFile.getModificationTime()));
-                } catch (EOFException eof) {
-                  break;
-                }
-              }
-              containersLogMeta.add(containerLogMeta);
-              if (!getAllContainers) {
-                break;
-              }
-            }
-            // Next container
-            key = new LogKey();
-            valueStream = reader.next(key);
-          }
-        } finally {
-          reader.close();
-        }
-      }
-    }
-    return containersLogMeta;
-  }
-
-  /**
-  public static boolean outputAggregatedContainerLog(Configuration conf,
-      ApplicationId appId, String appOwner,
-      String containerId, String nodeId,
-      String logFileName, long outputSize, OutputStream os,
-      byte[] buf) throws IOException {
-    boolean findLogs = false;
-    RemoteIterator<FileStatus> nodeFiles = LogAggregationUtils
-        .getRemoteNodeFileDir(conf, appId, appOwner);
-    while (nodeFiles != null && nodeFiles.hasNext()) {
-      final FileStatus thisNodeFile = nodeFiles.next();
-      String nodeName = thisNodeFile.getPath().getName();
-      if (nodeName.equals(appId + ".har")) {
-        Path p = new Path("har:///"
-            + thisNodeFile.getPath().toUri().getRawPath());
-        nodeFiles = HarFs.get(p.toUri(), conf).listStatusIterator(p);
-        continue;
-      }
-      if ((nodeId == null || nodeName.contains(LogAggregationUtils
-          .getNodeString(nodeId))) && !nodeName.endsWith(
-              LogAggregationUtils.TMP_FILE_SUFFIX)) {
-        AggregatedLogFormat.LogReader reader = null;
-        try {
-          reader = new AggregatedLogFormat.LogReader(conf,
-              thisNodeFile.getPath());
-          DataInputStream valueStream;
-          LogKey key = new LogKey();
-          valueStream = reader.next(key);
-          while (valueStream != null && !key.toString()
-              .equals(containerId)) {
-            // Next container
-            key = new LogKey();
-            valueStream = reader.next(key);
-          }
-          if (valueStream == null) {
-            continue;
-          }
-          while (true) {
-            try {
-              String fileType = valueStream.readUTF();
-              String fileLengthStr = valueStream.readUTF();
-              long fileLength = Long.parseLong(fileLengthStr);
-              if (fileType.equalsIgnoreCase(logFileName)) {
-                LogToolUtils.outputContainerLog(containerId,
-                    nodeId, fileType, fileLength, outputSize,
-                    Times.format(thisNodeFile.getModificationTime()),
-                    valueStream, os, buf,
-                    ContainerLogAggregationType.AGGREGATED);
-                StringBuilder sb = new StringBuilder();
-                String endOfFile = "End of LogType:" + fileType;
-                sb.append("\n" + endOfFile + "\n");
-                sb.append(StringUtils.repeat("*", endOfFile.length() + 50)
-                    + "\n\n");
-                byte[] b = sb.toString().getBytes(Charset.forName("UTF-8"));
-                os.write(b, 0, b.length);
-                findLogs = true;
-              } else {
-                long totalSkipped = 0;
-                long currSkipped = 0;
-                while (currSkipped != -1 && totalSkipped < fileLength) {
-                  currSkipped = valueStream.skip(
-                      fileLength - totalSkipped);
-                  totalSkipped += currSkipped;
-                }
-              }
-            } catch (EOFException eof) {
-              break;
-            }
-          }
-        } finally {
-          if (reader != null) {
-            reader.close();
-          }
-        }
-      }
-    }
-    os.flush();
-    return findLogs;
-  }

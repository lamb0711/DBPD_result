HDFS-8058. Erasure coding: use BlockInfo[] for both striped and contiguous blocks in INodeFile. Contributed by Zhe Zhang and Yi Liu.

-import org.apache.hadoop.hdfs.server.blockmanagement.BlockInfoContiguousUnderConstruction;
-import org.apache.hadoop.hdfs.server.blockmanagement.BlockInfoStripedUnderConstruction;
-   * [4-bit storagePolicyID][12-bit replication][48-bit preferredBlockSize]
+   * [4-bit storagePolicyID][1-bit isStriped]
+   * [11-bit replication][48-bit preferredBlockSize]
-    REPLICATION(PREFERRED_BLOCK_SIZE.BITS, 12, 0),
-    STORAGE_POLICY_ID(REPLICATION.BITS, BlockStoragePolicySuite.ID_BIT_LENGTH,
+    REPLICATION(PREFERRED_BLOCK_SIZE.BITS, 11, 0),
+    IS_STRIPED(REPLICATION.BITS, 1, 0),
+    STORAGE_POLICY_ID(IS_STRIPED.BITS, BlockStoragePolicySuite.ID_BIT_LENGTH,
+    static boolean isStriped(long header) {
+      long isStriped = IS_STRIPED.BITS.retrieve(header);
+      Preconditions.checkState(isStriped == 0 || isStriped == 1);
+      return isStriped == 1;
+    }
+
-        byte storagePolicyID) {
+        boolean isStriped, byte storagePolicyID) {
-      h = REPLICATION.BITS.combine(replication, h);
+      // Replication factor for striped files is zero
+      if (isStriped) {
+        h = REPLICATION.BITS.combine(0L, h);
+        h = IS_STRIPED.BITS.combine(1L, h);
+      } else {
+        h = REPLICATION.BITS.combine(replication, h);
+        h = IS_STRIPED.BITS.combine(0L, h);
+      }
-  private BlockInfoContiguous[] blocks;
+  private BlockInfo[] blocks;
-            long atime, BlockInfoContiguous[] blklist, short replication,
+            long atime, BlockInfo[] blklist, short replication,
-         preferredBlockSize, (byte) 0);
+        preferredBlockSize, (byte) 0, false);
-      long atime, BlockInfoContiguous[] blklist, short replication,
-      long preferredBlockSize, byte storagePolicyID) {
+      long atime, BlockInfo[] blklist, short replication,
+      long preferredBlockSize, byte storagePolicyID, boolean isStriped) {
-    header = HeaderFormat.toLong(preferredBlockSize, replication, storagePolicyID);
-    this.blocks = blklist;
+    header = HeaderFormat.toLong(preferredBlockSize, replication, isStriped,
+        storagePolicyID);
+    if (blklist != null && blklist.length > 0) {
+      for (BlockInfo b : blklist) {
+        Preconditions.checkArgument(b.isStriped() == isStriped);
+      }
+    }
+    setBlocks(blklist);
-  /* Start of StripedBlock Feature */
-
-  public final FileWithStripedBlocksFeature getStripedBlocksFeature() {
-    return getFeature(FileWithStripedBlocksFeature.class);
-  }
-
-  public FileWithStripedBlocksFeature addStripedBlocksFeature() {
-    assert blocks == null || blocks.length == 0:
-        "The file contains contiguous blocks";
-    assert !isStriped();
-    this.setFileReplication((short) 0);
-    FileWithStripedBlocksFeature sb = new FileWithStripedBlocksFeature();
-    addFeature(sb);
-    return sb;
-  }
-
-  /** Used to make sure there is no contiguous block related info */
-  private boolean hasNoContiguousBlock() {
-    return (blocks == null || blocks.length == 0) && getFileReplication() == 0;
-  }
-
-      assertAllBlocksComplete(getBlocks());
+      assertAllBlocksComplete();
-  private void assertAllBlocksComplete(BlockInfo[] blks) {
-    if (blks == null) {
+  private void assertAllBlocksComplete() {
+    if (blocks == null) {
-    for (int i = 0; i < blks.length; i++) {
-      Preconditions.checkState(blks[i].isComplete(), "Failed to finalize"
+    for (int i = 0; i < blocks.length; i++) {
+      Preconditions.checkState(blocks[i].isComplete(), "Failed to finalize"
-          getClass().getSimpleName(), this, i, Arrays.asList(blks));
+          getClass().getSimpleName(), this, i, Arrays.asList(blocks));
-  /**
-   * Instead of adding a new block, this function is usually used while loading
-   * fsimage or converting the last block to UC/Complete.
-   */
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      assert !blk.isStriped();
-      this.blocks[index] = (BlockInfoContiguous) blk;
-    } else {
-      assert blk.isStriped();
-      assert hasNoContiguousBlock();
-      sb.setBlock(index, (BlockInfoStriped) blk);
-    }
+    Preconditions.checkArgument(blk.isStriped() == this.isStriped());
+    this.blocks[index] = blk;
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      assert !lastBlock.isStriped();
-      ucBlock = ((BlockInfoContiguous) lastBlock)
+    if (isStriped()) {
+      Preconditions.checkState(lastBlock.isStriped());
+      ucBlock = ((BlockInfoStriped) lastBlock)
-      assert hasNoContiguousBlock();
-      assert lastBlock.isStriped();
-      ucBlock = ((BlockInfoStriped) lastBlock)
+      Preconditions.checkState(!lastBlock.isStriped());
+      ucBlock = ((BlockInfoContiguous) lastBlock)
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      if (blocks == null || blocks.length == 0) {
-        return null;
-      }
-      int size_1 = blocks.length - 1;
-      if (!blocks[size_1].equals(oldblock)) {
-        return null;
-      }
-
-      BlockInfoContiguousUnderConstruction uc =
-          (BlockInfoContiguousUnderConstruction)blocks[size_1];
-      //copy to a new list
-      BlockInfoContiguous[] newlist = new BlockInfoContiguous[size_1];
-      System.arraycopy(blocks, 0, newlist, 0, size_1);
-      setContiguousBlocks(newlist);
-      return uc;
-    } else {
-      assert hasNoContiguousBlock();
-      return sb.removeLastBlock(oldblock);
+    if (blocks == null || blocks.length == 0) {
+      return null;
+    int size_1 = blocks.length - 1;
+    if (!blocks[size_1].equals(oldblock)) {
+      return null;
+    }
+
+    BlockInfoUnderConstruction uc =
+        (BlockInfoUnderConstruction)blocks[size_1];
+    //copy to a new list
+    BlockInfo[] newlist = new BlockInfo[size_1];
+    System.arraycopy(blocks, 0, newlist, 0, size_1);
+    setBlocks(newlist);
+    return uc;
-  // TODO striped
+  // TODO properly handle striped files
+
+  /**
+   * @return true if the file is in the striping layout.
+   */
+  @VisibleForTesting
+  @Override
+  public boolean isStriped() {
+    return HeaderFormat.isStriped(header);
+  }
+
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb != null) {
-      assert hasNoContiguousBlock();
-      return sb.getBlocks();
-    } else {
-      return this.blocks;
-    }
-  }
-
-  /** Used by snapshot diff */
-  public BlockInfoContiguous[] getContiguousBlocks() {
-  private void updateBlockCollection() {
-    if (blocks != null && blocks.length > 0) {
-      for(BlockInfoContiguous b : blocks) {
+  void updateBlockCollection() {
+    if (blocks != null) {
+      for(BlockInfo b : blocks) {
-    } else {
-      FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-      if (sb != null) {
-        sb.updateBlockCollection(this);
-      }
+      Preconditions.checkState(f.isStriped() == this.isStriped());
-    BlockInfoContiguous[] newlist =
-        new BlockInfoContiguous[size + totalAddedBlocks];
+    BlockInfo[] newlist =
+        new BlockInfo[size + totalAddedBlocks];
-    setContiguousBlocks(newlist);
+    setBlocks(newlist);
-   * add a contiguous block to the block list
+   * add a block to the block list
-  private void addContiguousBlock(BlockInfoContiguous newblock) {
+  void addBlock(BlockInfo newblock) {
+    Preconditions.checkArgument(newblock.isStriped() == this.isStriped());
-      this.setContiguousBlocks(new BlockInfoContiguous[]{newblock});
+      this.setBlocks(new BlockInfo[]{newblock});
-      BlockInfoContiguous[] newlist = new BlockInfoContiguous[size + 1];
+      BlockInfo[] newlist = new BlockInfo[size + 1];
-      this.setContiguousBlocks(newlist);
-    }
-  }
-
-  /** add a striped or contiguous block */
-  void addBlock(BlockInfo newblock) {
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      assert !newblock.isStriped();
-      addContiguousBlock((BlockInfoContiguous) newblock);
-    } else {
-      assert newblock.isStriped();
-      assert hasNoContiguousBlock();
-      sb.addBlock((BlockInfoStriped) newblock);
+      this.setBlocks(newlist);
-  public void setContiguousBlocks(BlockInfoContiguous[] blocks) {
+  private void setBlocks(BlockInfo[] blocks) {
+  public void clearBlocks() {
+    setBlocks(null);
+  }
+
-    BlockInfo[] blks = getBlocks();
-    if (blks != null && reclaimContext.collectedBlocks != null) {
-      for (BlockInfo blk : blks) {
+    if (blocks != null && reclaimContext.collectedBlocks != null) {
+      for (BlockInfo blk : blocks) {
-    setContiguousBlocks(null);
-
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb != null) {
-      sb.clear();
-    }
+    clearBlocks();
-    
+
-                                    boolean usePreferredBlockSize4LastUcBlock) {
-    BlockInfo[] blockInfos = getBlocks();
-    // In case of contiguous blocks
-    if (blockInfos == null || blockInfos.length == 0) {
+      boolean usePreferredBlockSize4LastUcBlock) {
+    if (blocks == null || blocks.length == 0) {
-    final int last = blockInfos.length - 1;
+    final int last = blocks.length - 1;
-    long size = blockInfos[last].getNumBytes();
-    if (blockInfos[last] instanceof BlockInfoContiguousUnderConstruction) {
-      if (!includesLastUcBlock) {
-        size = 0;
-      } else if (usePreferredBlockSize4LastUcBlock) {
-        size = getPreferredBlockSize();
-      }
-    } else if (blockInfos[last] instanceof BlockInfoStripedUnderConstruction) {
-      if (!includesLastUcBlock) {
-        size = 0;
-      } else if (usePreferredBlockSize4LastUcBlock) {
-        BlockInfoStripedUnderConstruction blockInfoStripedUC
-            = (BlockInfoStripedUnderConstruction) blockInfos[last];
-        size = getPreferredBlockSize() * blockInfoStripedUC.getDataBlockNum();
-      }
+    BlockInfo lastBlk = blocks[last];
+    long size = lastBlk.getNumBytes();
+    if (lastBlk instanceof BlockInfoUnderConstruction) {
+       if (!includesLastUcBlock) {
+         size = 0;
+       } else if (usePreferredBlockSize4LastUcBlock) {
+         size = isStriped()?
+             getPreferredBlockSize() *
+                 ((BlockInfoStriped)lastBlk).getDataBlockNum() :
+             getPreferredBlockSize();
+       }
-      size += blockInfos[i].getNumBytes();
+      size += blocks[i].getNumBytes();
-      return storagespaceConsumedWithStriped();
+      return storagespaceConsumedStriped();
-      return storagespaceConsumedWithReplication(bsp);
+      return storagespaceConsumedContiguous(bsp);
-  public final QuotaCounts storagespaceConsumedWithStriped() {
+  public final QuotaCounts storagespaceConsumedStriped() {
-    BlockInfo[] blockInfos = getBlocks();
-    if (blockInfos == null || blockInfos.length == 0) {
+    if (blocks == null || blocks.length == 0) {
-    long size;
-    final int last = blockInfos.length - 1;
-    if (blockInfos[last] instanceof BlockInfoStripedUnderConstruction) {
-      BlockInfoStripedUnderConstruction blockInfoStripedUC
-          =(BlockInfoStripedUnderConstruction)blockInfos[last];
-      size = getPreferredBlockSize() * blockInfoStripedUC.getTotalBlockNum();
-    } else {
-      // In case of last block is complete
-      BlockInfoStriped blockInfoStriped = (BlockInfoStriped)blockInfos[last];
-      size = blockInfoStriped.spaceConsumed();
+    for (BlockInfo b : blocks) {
+      Preconditions.checkState(b.isStriped());
+      long blockSize = b.isComplete() ?
+          ((BlockInfoStriped)b).spaceConsumed() : getPreferredBlockSize() *
+          ((BlockInfoStriped)b).getTotalBlockNum();
+      counts.addStorageSpace(blockSize);
-    for (int i = 0; i < last; i++) {
-      BlockInfoStriped blockInfoStriped = (BlockInfoStriped)blockInfos[i];
-      size += blockInfoStriped.spaceConsumed();
-    }
-
-    counts.addStorageSpace(size);
-  public final QuotaCounts storagespaceConsumedWithReplication(
+  public final QuotaCounts storagespaceConsumedContiguous(
-        BlockInfoContiguous[] diffBlocks = diff.getBlocks();
+        BlockInfo[] diffBlocks = diff.getBlocks();
-    BlockInfo[] blks = getBlocks();
-    return (blks == null || blks.length <= 1) ?
-        null : blks[blks.length - 2];
+    if (blocks == null || blocks.length <= 1) {
+      return null;
+    }
+    return blocks[blocks.length - 2];
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      return blocks == null || blocks.length == 0 ?
-          null : blocks[blocks.length - 1];
-    } else {
-      assert hasNoContiguousBlock();
-      return sb.getLastBlock();
-    }
+    return blocks == null || blocks.length == 0? null: blocks[blocks.length-1];
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      return blocks == null ? 0 : blocks.length;
-    } else {
-      assert hasNoContiguousBlock();
-      return sb.numBlocks();
-    }
+    return blocks == null ? 0 : blocks.length;
-    BlockInfo[] blks = getBlocks();
-    out.print(blks == null || blks.length == 0? null: blks[0]);
+    out.print(blocks == null || blocks.length == 0? null: blocks[0]);
-    FileWithStripedBlocksFeature sb = getStripedBlocksFeature();
-    if (sb == null) {
-      truncateContiguousBlocks(n);
-    } else {
-      sb.truncateStripedBlocks(n);
-    }
-  }
-
-  private void truncateContiguousBlocks(int n) {
-    final BlockInfoContiguous[] newBlocks;
+    final BlockInfo[] newBlocks;
-      newBlocks = BlockInfoContiguous.EMPTY_ARRAY;
+      newBlocks = BlockInfo.EMPTY_ARRAY;
-      newBlocks = new BlockInfoContiguous[n];
-      System.arraycopy(blocks, 0, newBlocks, 0, n);
+      newBlocks = new BlockInfo[n];
+      System.arraycopy(getBlocks(), 0, newBlocks, 0, n);
-    setContiguousBlocks(newBlocks);
+    setBlocks(newBlocks);
-  public void collectBlocksBeyondSnapshot(BlockInfoContiguous[] snapshotBlocks,
+  public void collectBlocksBeyondSnapshot(BlockInfo[] snapshotBlocks,
-    BlockInfoContiguous[] oldBlocks = this.blocks;
-    if (snapshotBlocks == null || oldBlocks == null)
+    Preconditions.checkState(!isStriped());
+    BlockInfo[] oldBlocks = getBlocks();
+    if(snapshotBlocks == null || oldBlocks == null)
-    truncateContiguousBlocks(n);
+    truncateBlocksTo(n);
-    BlockInfoContiguous[] snapshotBlocks =
+    BlockInfo[] snapshotBlocks =
-  boolean isBlockInLatestSnapshot(BlockInfoContiguous block) {
+  boolean isBlockInLatestSnapshot(BlockInfo block) {
-    BlockInfoContiguous[] snapshotBlocks = getDiffs()
+    BlockInfo[] snapshotBlocks = getDiffs()
-
-  /**
-   * @return true if the file is in the striping layout.
-   */
-  @VisibleForTesting
-  @Override
-  public boolean isStriped() {
-    return getStripedBlocksFeature() != null;
-  }

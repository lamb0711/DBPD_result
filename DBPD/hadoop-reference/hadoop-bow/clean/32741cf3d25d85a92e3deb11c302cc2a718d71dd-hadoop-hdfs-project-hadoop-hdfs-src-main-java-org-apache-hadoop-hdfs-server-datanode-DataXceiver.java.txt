Revert "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)" (jenkins didn't run yet)

This reverts commit 5aa892ed486d42ae6b94c4866b92cd2b382ea640.

-import static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.ShortCircuitFdResponse.USE_RECEIPT_VERIFICATION;
-import static org.apache.hadoop.hdfs.protocol.proto.DataTransferProtos.ShortCircuitFdResponse.DO_NOT_USE_RECEIPT_VERIFICATION;
-      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)
-        throws IOException {
+      SlotId slotId, int maxVersion) throws IOException {
-    SlotId registeredSlotId = null;
-    boolean success = false;
-      try {
-        if (peer.getDomainSocket() == null) {
-          throw new IOException("You cannot pass file descriptors over " +
-              "anything but a UNIX domain socket.");
-        }
-        if (slotId != null) {
-          boolean isCached = datanode.data.
-              isCached(blk.getBlockPoolId(), blk.getBlockId());
-          datanode.shortCircuitRegistry.registerSlot(
-              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);
-          registeredSlotId = slotId;
-        }
-        fis = datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);
-        Preconditions.checkState(fis != null);
-        bld.setStatus(SUCCESS);
-        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);
-      } catch (ShortCircuitFdsVersionException e) {
-        bld.setStatus(ERROR_UNSUPPORTED);
-        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);
-        bld.setMessage(e.getMessage());
-      } catch (ShortCircuitFdsUnsupportedException e) {
-        bld.setStatus(ERROR_UNSUPPORTED);
-        bld.setMessage(e.getMessage());
-      } catch (InvalidToken e) {
-        bld.setStatus(ERROR_ACCESS_TOKEN);
-        bld.setMessage(e.getMessage());
-      } catch (IOException e) {
-        bld.setStatus(ERROR);
-        bld.setMessage(e.getMessage());
+      if (peer.getDomainSocket() == null) {
+        throw new IOException("You cannot pass file descriptors over " +
+            "anything but a UNIX domain socket.");
+      if (slotId != null) {
+        boolean isCached = datanode.data.
+            isCached(blk.getBlockPoolId(), blk.getBlockId());
+        datanode.shortCircuitRegistry.registerSlot(
+            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);
+      }
+      try {
+        fis = datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);
+      } finally {
+        if ((fis == null) && (slotId != null)) {
+          datanode.shortCircuitRegistry.unregisterSlot(slotId);
+        }
+      }
+      bld.setStatus(SUCCESS);
+      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);
+    } catch (ShortCircuitFdsVersionException e) {
+      bld.setStatus(ERROR_UNSUPPORTED);
+      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);
+      bld.setMessage(e.getMessage());
+    } catch (ShortCircuitFdsUnsupportedException e) {
+      bld.setStatus(ERROR_UNSUPPORTED);
+      bld.setMessage(e.getMessage());
+    } catch (InvalidToken e) {
+      bld.setStatus(ERROR_ACCESS_TOKEN);
+      bld.setMessage(e.getMessage());
+    } catch (IOException e) {
+      bld.setStatus(ERROR);
+      bld.setMessage(e.getMessage());
+    }
+    try {
-        byte buf[] = new byte[1];
-        if (supportsReceiptVerification) {
-          buf[0] = (byte)USE_RECEIPT_VERIFICATION.getNumber();
-        } else {
-          buf[0] = (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();
-        }
-        DomainSocket sock = peer.getDomainSocket();
-        sock.sendFileDescriptors(fds, buf, 0, buf.length);
-        if (supportsReceiptVerification) {
-          LOG.trace("Reading receipt verification byte for " + slotId);
-          int val = sock.getInputStream().read();
-          if (val < 0) {
-            throw new EOFException();
-          }
-        } else {
-          LOG.trace("Receipt verification is not enabled on the DataNode.  " +
-                    "Not verifying " + slotId);
-        }
-        success = true;
+        byte buf[] = new byte[] { (byte)0 };
+        peer.getDomainSocket().
+          sendFileDescriptors(fds, buf, 0, buf.length);
-      if ((!success) && (registeredSlotId != null)) {
-        LOG.info("Unregistering " + registeredSlotId + " because the " +
-            "requestShortCircuitFdsForRead operation failed.");
-        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);
-      }
-            blk.getBlockId(), dnR.getDatanodeUuid(), success));
+            blk.getBlockId(), dnR.getDatanodeUuid(), (fis != null)
+          ));

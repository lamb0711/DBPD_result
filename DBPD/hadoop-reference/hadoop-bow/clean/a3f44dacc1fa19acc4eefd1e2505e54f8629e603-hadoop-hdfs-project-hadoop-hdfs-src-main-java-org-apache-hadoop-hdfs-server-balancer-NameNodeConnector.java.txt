HDFS-13183. Standby NameNode process getBlocks request to reduce Active load. Contributed by Xiaoqiao He.

Signed-off-by: Wei-Chiu Chuang <weichiu@apache.org>

+import java.util.HashMap;
+import org.apache.hadoop.ha.HAServiceProtocol;
+import org.apache.hadoop.hdfs.HAUtil;
+import org.apache.hadoop.hdfs.protocol.ClientProtocol;
+import org.apache.hadoop.ipc.RPC;
+import org.apache.hadoop.security.UserGroupInformation;
+  public static List<NameNodeConnector> newNameNodeConnectors(
+      Collection<URI> namenodes, Collection<String> nsIds, String name,
+      Path idPath, Configuration conf, int maxIdleIterations)
+      throws IOException {
+    final List<NameNodeConnector> connectors = new ArrayList<NameNodeConnector>(
+        namenodes.size());
+    Map<URI, String> uriToNsId = new HashMap<>();
+    if (nsIds != null) {
+      for (URI uri : namenodes) {
+        for (String nsId : nsIds) {
+          if (uri.getAuthority().equals(nsId)) {
+            uriToNsId.put(uri, nsId);
+          }
+        }
+      }
+    }
+    for (URI uri : namenodes) {
+      String nsId = uriToNsId.get(uri);
+      NameNodeConnector nnc = new NameNodeConnector(name, uri, nsId, idPath,
+          null, conf, maxIdleIterations);
+      nnc.getKeyManager().startBlockKeyUpdater();
+      connectors.add(nnc);
+    }
+    return connectors;
+  }
+
+  /**
+   * If set balancerShouldRequestStandby true, Balancer will getBlocks from
+   * Standby NameNode only and it can reduce the performance impact of Active
+   * NameNode, especially in a busy HA mode cluster.
+   */
+  private boolean balancerShouldRequestStandby;
+  private NamenodeProtocol standbyNameNode;
+    this.balancerShouldRequestStandby = conf.getBoolean(
+        DFSConfigKeys.DFS_HA_ALLOW_STALE_READ_KEY,
+        DFSConfigKeys.DFS_HA_ALLOW_STALE_READ_DEFAULT);
+    this.standbyNameNode = null;
+
+  public NameNodeConnector(String name, URI nameNodeUri, String nsId,
+                           Path idPath, List<Path> targetPaths,
+                           Configuration conf, int maxNotChangedIterations)
+      throws IOException {
+    this(name, nameNodeUri, idPath, targetPaths, conf, maxNotChangedIterations);
+    if (nsId != null && HAUtil.isHAEnabled(conf, nsId)) {
+      List<ClientProtocol> namenodes =
+          HAUtil.getProxiesForAllNameNodesInNameservice(conf, nsId);
+      for (ClientProtocol proxy : namenodes) {
+        try {
+          if (proxy.getHAServiceState().equals(
+              HAServiceProtocol.HAServiceState.STANDBY)) {
+            this.standbyNameNode = NameNodeProxies.createNonHAProxy(
+                conf, RPC.getServerAddress(proxy), NamenodeProtocol.class,
+                UserGroupInformation.getCurrentUser(), false).getProxy();
+            break;
+          }
+        } catch (Exception e) {
+          //Ignore the exception while connecting to a namenode.
+          LOG.debug("Error while connecting to namenode", e);
+        }
+      }
+    }
+  }
+
+    boolean isRequestStandby = true;
+    try {
+      if (balancerShouldRequestStandby && standbyNameNode != null) {
+        return standbyNameNode.getBlocks(datanode, size, minBlockSize);
+      } else {
+        isRequestStandby = false;
+      }
+    } catch (Exception e) {
+      LOG.warn("Request #getBlocks to Standby NameNode but meet exception, " +
+          "will fallback to normal way", e);
+      isRequestStandby = false;
+    } finally {
+      if (isRequestStandby) {
+        LOG.info("Request #getBlocks to Standby NameNode success.");
+      }
+    }

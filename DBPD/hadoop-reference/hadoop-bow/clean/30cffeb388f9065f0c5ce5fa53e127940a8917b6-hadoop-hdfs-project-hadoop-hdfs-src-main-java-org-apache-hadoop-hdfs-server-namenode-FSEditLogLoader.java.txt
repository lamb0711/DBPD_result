HDFS-3023. Optimize entries in edits log for persistBlocks call. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1295356 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.namenode.FSEditLogOp.BlockListUpdatingOp;
+import org.apache.hadoop.hdfs.server.namenode.FSEditLogOp.UpdateBlocksOp;
+      
+      // Update the salient file attributes.
+      newFile.setAccessTime(addCloseOp.atime);
+      newFile.setModificationTimeForce(addCloseOp.mtime);
+    case OP_UPDATE_BLOCKS: {
+      UpdateBlocksOp updateOp = (UpdateBlocksOp)op;
+      if (FSNamesystem.LOG.isDebugEnabled()) {
+        FSNamesystem.LOG.debug(op.opCode + ": " + updateOp.path +
+            " numblocks : " + updateOp.blocks.length);
+      }
+      INodeFile oldFile = getINodeFile(fsDir, updateOp.path);
+      if (oldFile == null) {
+        throw new IOException(
+            "Operation trying to update blocks in non-existent file " +
+            updateOp.path);
+      }
+      
+      // Update in-memory data structures
+      updateBlocks(fsDir, updateOp, oldFile);
+      break;
+    }
+      
-  private void updateBlocks(FSDirectory fsDir, AddCloseOp addCloseOp,
+  private void updateBlocks(FSDirectory fsDir, BlockListUpdatingOp op,
-    
-    // Update the salient file attributes.
-    file.setAccessTime(addCloseOp.atime);
-    file.setModificationTimeForce(addCloseOp.mtime);
-    
+    Block[] newBlocks = op.getBlocks();
+    String path = op.getPath();
-    boolean isGenStampUpdate = oldBlocks.length == addCloseOp.blocks.length;
+    boolean isGenStampUpdate = oldBlocks.length == newBlocks.length;
-    for (int i = 0; i < oldBlocks.length && i < addCloseOp.blocks.length; i++) {
+    for (int i = 0; i < oldBlocks.length && i < newBlocks.length; i++) {
-      Block newBlock = addCloseOp.blocks[i];
+      Block newBlock = newBlocks[i];
-      boolean isLastBlock = i == addCloseOp.blocks.length - 1;
+      boolean isLastBlock = i == newBlocks.length - 1;
-            " as block # " + i + "/" + addCloseOp.blocks.length + " of " +
-            addCloseOp.path);
+            " as block # " + i + "/" + newBlocks.length + " of " +
+            path);
-          (!isLastBlock || addCloseOp.opCode == FSEditLogOpCodes.OP_CLOSE)) {
+          (!isLastBlock || op.shouldCompleteLastBlock())) {
-    if (addCloseOp.blocks.length < oldBlocks.length) {
+    if (newBlocks.length < oldBlocks.length) {
-            addCloseOp.path + " which is not under construction.");
+            path + " which is not under construction.");
-      if (addCloseOp.blocks.length != oldBlocks.length - 1) {
+      if (newBlocks.length != oldBlocks.length - 1) {
-            + addCloseOp.path);
+            + path);
-      fsDir.unprotectedRemoveBlock(addCloseOp.path,
+      fsDir.unprotectedRemoveBlock(path,
-    } else if (addCloseOp.blocks.length > oldBlocks.length) {
+    } else if (newBlocks.length > oldBlocks.length) {
-      for (int i = oldBlocks.length; i < addCloseOp.blocks.length; i++) {
-        Block newBlock = addCloseOp.blocks[i];
+      for (int i = oldBlocks.length; i < newBlocks.length; i++) {
+        Block newBlock = newBlocks[i];
-        if (addCloseOp.opCode == FSEditLogOpCodes.OP_ADD){
+        if (!op.shouldCompleteLastBlock()) {
+          // TODO: shouldn't this only be true for the last block?
+          // what about an old-version fsync() where fsync isn't called
+          // until several blocks in?

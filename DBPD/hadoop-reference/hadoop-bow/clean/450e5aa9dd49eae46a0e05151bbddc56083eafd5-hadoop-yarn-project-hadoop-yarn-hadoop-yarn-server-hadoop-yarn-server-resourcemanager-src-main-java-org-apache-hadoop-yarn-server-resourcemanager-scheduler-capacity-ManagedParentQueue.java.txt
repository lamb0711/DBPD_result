YARN-10154. Addendum Patch which fixes below bugs

1. RM fails to start when LeafQueueTemplate max capacity is not specified.
2. Job stuck in ACCEPTED state with DominantResourceCalculator as Queue
   Capacity is set to NaN during RM startup with clusterResource is zero.

Reviewed by Sunil G and Manikandan R.

-      for (String label : queueCapacities.getExistingNodeLabels()) {
-        queueCapacities.setCapacity(label,
-            this.csContext.getResourceCalculator().divide(
-                this.csContext.getClusterResource(),
-                this.csContext.getConfiguration().getMinimumResourceRequirement(
-                    label,
-                    this.csContext.getConfiguration()
-                        .getAutoCreatedQueueTemplateConfPrefix(getQueuePath()),
-                    resourceTypes),
-                getQueueResourceQuotas().getConfiguredMinResource(label)));
-
-        queueCapacities.setMaximumCapacity(label,
-            this.csContext.getResourceCalculator().divide(
-                this.csContext.getClusterResource(),
-                this.csContext.getConfiguration().getMaximumResourceRequirement(
-                    label,
-                    this.csContext.getConfiguration()
-                        .getAutoCreatedQueueTemplateConfPrefix(getQueuePath()),
-                    resourceTypes),
-                getQueueResourceQuotas().getConfiguredMaxResource(label)));
-
-        queueCapacities.setAbsoluteCapacity(label,
-            queueCapacities.getCapacity(label)
-                * getQueueCapacities().getAbsoluteCapacity(label));
-
-        queueCapacities.setAbsoluteMaximumCapacity(label,
-            queueCapacities.getMaximumCapacity(label)
-                * getQueueCapacities().getAbsoluteMaximumCapacity(label));
-      }
+      updateQueueCapacities(queueCapacities);
+  private void updateQueueCapacities(QueueCapacities queueCapacities) {
+    for (String label : queueCapacities.getExistingNodeLabels()) {
+      queueCapacities.setCapacity(label,
+          this.csContext.getResourceCalculator().divide(
+              this.csContext.getClusterResource(),
+              this.csContext.getConfiguration().getMinimumResourceRequirement(
+                  label,
+                  this.csContext.getConfiguration()
+                      .getAutoCreatedQueueTemplateConfPrefix(getQueuePath()),
+                  resourceTypes),
+              getQueueResourceQuotas().getConfiguredMinResource(label)));
+
+      Resource childMaxResource = this.csContext.getConfiguration()
+          .getMaximumResourceRequirement(label,
+              this.csContext.getConfiguration()
+                  .getAutoCreatedQueueTemplateConfPrefix(getQueuePath()),
+              resourceTypes);
+      Resource parentMaxRes = getQueueResourceQuotas()
+          .getConfiguredMaxResource(label);
+
+      Resource effMaxResource = Resources.min(
+          this.csContext.getResourceCalculator(),
+          this.csContext.getClusterResource(),
+          childMaxResource.equals(Resources.none()) ? parentMaxRes
+              : childMaxResource,
+          parentMaxRes);
+
+      queueCapacities.setMaximumCapacity(
+          label, this.csContext.getResourceCalculator().divide(
+               this.csContext.getClusterResource(),
+               effMaxResource,
+               getQueueResourceQuotas().getConfiguredMaxResource(label)));
+
+      queueCapacities.setAbsoluteCapacity(
+          label, queueCapacities.getCapacity(label)
+          * getQueueCapacities().getAbsoluteCapacity(label));
+
+      queueCapacities.setAbsoluteMaximumCapacity(label,
+          queueCapacities.getMaximumCapacity(label)
+          * getQueueCapacities().getAbsoluteMaximumCapacity(label));
+    }
+  }
+
+
+      /* Below is to avoid Setting Queue Capacity to NaN when ClusterResource
+         is zero during RM Startup with DominantResourceCalculator */
+      if (this.capacityConfigType.equals(
+          CapacityConfigType.ABSOLUTE_RESOURCE)) {
+        QueueCapacities queueCapacities =
+            getLeafQueueTemplate().getQueueCapacities();
+        updateQueueCapacities(queueCapacities);
+      }
+

YARN-1512. Enhanced CapacityScheduler to be able to decouple scheduling from node-heartbeats. Contributed by Arun C Murthy.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1578722 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collection;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicBoolean;
+  private boolean scheduleAsynchronously;
+  private AsyncScheduleThread asyncSchedulerThread;
+  
+  /**
+   * EXPERT
+   */
+  private long asyncScheduleInterval;
+  private static final String ASYNC_SCHEDULER_INTERVAL =
+      CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_PREFIX
+          + ".scheduling-interval-ms";
+  private static final long DEFAULT_ASYNC_SCHEDULER_INTERVAL = 5;
+  
+      scheduleAsynchronously = this.conf.getScheduleAynschronously();
+      asyncScheduleInterval = 
+          this.conf.getLong(ASYNC_SCHEDULER_INTERVAL, 
+              DEFAULT_ASYNC_SCHEDULER_INTERVAL);
+      if (scheduleAsynchronously) {
+        asyncSchedulerThread = new AsyncScheduleThread(this);
+        asyncSchedulerThread.start();
+      }
+      
-          "maximumAllocation=<" + getMaximumResourceCapability() + ">");
+          "maximumAllocation=<" + getMaximumResourceCapability() + ">, " +
+          "asynchronousScheduling=" + scheduleAsynchronously + ", " +
+          "asyncScheduleInterval=" + asyncScheduleInterval + "ms");
+      
+  
+  long getAsyncScheduleInterval() {
+    return asyncScheduleInterval;
+  }
+  private final static Random random = new Random(System.currentTimeMillis());
+  
+  /**
+   * Schedule on all nodes by starting at a random point.
+   * @param cs
+   */
+  static void schedule(CapacityScheduler cs) {
+    // First randomize the start point
+    int current = 0;
+    Collection<FiCaSchedulerNode> nodes = cs.getAllNodes().values();
+    int start = random.nextInt(nodes.size());
+    for (FiCaSchedulerNode node : nodes) {
+      if (current++ >= start) {
+        cs.allocateContainersToNode(node);
+      }
+    }
+    // Now, just get everyone to be safe
+    for (FiCaSchedulerNode node : nodes) {
+      cs.allocateContainersToNode(node);
+    }
+    try {
+      Thread.sleep(cs.getAsyncScheduleInterval());
+    } catch (InterruptedException e) {}
+  }
+  
+  static class AsyncScheduleThread extends Thread {
+
+    private final CapacityScheduler cs;
+    private AtomicBoolean runSchedules = new AtomicBoolean(false);
+
+    public AsyncScheduleThread(CapacityScheduler cs) {
+      this.cs = cs;
+      setDaemon(true);
+    }
+
+    @Override
+    public void run() {
+      while (true) {
+        if (!runSchedules.get()) {
+          try {
+            Thread.sleep(100);
+          } catch (InterruptedException ie) {}
+        } else {
+          schedule(cs);
+        }
+      }
+    }
+
+    public void beginSchedule() {
+      runSchedules.set(true);
+    }
+
+    public void suspendSchedule() {
+      runSchedules.set(false);
+    }
+
+  }
+  
+  }
+
+  private synchronized void allocateContainersToNode(FiCaSchedulerNode node) {
-          reservedApplication.getApplicationId() + " on node: " + nm);
+          reservedApplication.getApplicationId() + " on node: " + 
+          node.getNodeID());
-      root.assignContainers(clusterResource, node);
+      if (Resources.greaterThanOrEqual(calculator, getClusterResources(),
+          node.getAvailableResource(), minimumAllocation)) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Trying to schedule on node: " + node.getNodeName() +
+              ", available: " + node.getAvailableResource());
+        }
+        root.assignContainers(clusterResource, node);
+      }
-      LOG.info("Skipping scheduling since node " + nm + 
+      LOG.info("Skipping scheduling since node " + node.getNodeID() + 
-      nodeUpdate(nodeUpdatedEvent.getRMNode());
+      RMNode node = nodeUpdatedEvent.getRMNode();
+      nodeUpdate(node);
+      if (!scheduleAsynchronously) {
+        allocateContainersToNode(getNode(node.getNodeID()));
+      }
+
+    if (scheduleAsynchronously && numNodeManagers == 1) {
+      asyncSchedulerThread.beginSchedule();
+    }
+    if (scheduleAsynchronously && numNodeManagers == 0) {
+      asyncSchedulerThread.suspendSchedule();
+    }
+    
-
+  
+  @Lock(Lock.NoLock.class)
+  Map<NodeId, FiCaSchedulerNode> getAllNodes() {
+    return nodes;
+  }
+  

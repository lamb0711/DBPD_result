HDDS-733. Create container if not exist, as part of chunk write.
Contributed by Lokesh Jain.

-      1. First we check if there are containers in ALLOCATED state, that is
-         SCM has allocated them in the SCM namespace but the corresponding
-         container has not been created in the Datanode yet. If we have any in
-         that state, we will return that to the client, which allows client to
-         finish creating those containers. This is a sort of greedy algorithm,
-         our primary purpose is to get as many containers as possible.
+      1. We try to find containers in open state.
-      2. If there are no allocated containers -- Then we find a Open container
-         that matches that pattern.
-
-      3. If both of them fail, the we will pre-allocate a bunch of containers
-         in SCM and try again.
+      2. If there are no containers in open state, then we will pre-allocate a
+      bunch of containers in SCM and try again.
-    // This is to optimize performance, if the below condition is evaluated
-    // to false, then we can be sure that there are no containers in
-    // ALLOCATED state.
-    // This can result in false positive, but it will never be false negative.
-    // How can this result in false positive? We check if there are any
-    // containers in ALLOCATED state, this check doesn't care about the
-    // USER of the containers. So there might be cases where a different
-    // USER has few containers in ALLOCATED state, which will result in
-    // false positive.
-    if (!containerManager.getContainers(HddsProtos.LifeCycleState.ALLOCATED)
-        .isEmpty()) {
-      // Since the above check can result in false positive, we have to do
-      // the actual check and find out if there are containers in ALLOCATED
-      // state matching our criteria.
-      synchronized (this) {
-        // Using containers from ALLOCATED state should be done within
-        // synchronized block (or) write lock. Since we already hold a
-        // read lock, we will end up in deadlock situation if we take
-        // write lock here.
-        containerWithPipeline = containerManager
-            .getMatchingContainerWithPipeline(size, owner, type, factor,
-                HddsProtos.LifeCycleState.ALLOCATED);
-        if (containerWithPipeline != null) {
-          containerManager.updateContainerState(
-              containerWithPipeline.getContainerInfo().containerID(),
-              HddsProtos.LifeCycleEvent.CREATE);
-          return newBlock(containerWithPipeline,
-              HddsProtos.LifeCycleState.ALLOCATED);
-        }
-      }
-    }
-
-    // Since we found no allocated containers that match our criteria, let us
-    if (containerWithPipeline != null) {
-      return newBlock(containerWithPipeline, HddsProtos.LifeCycleState.OPEN);
-    }
-    // We found neither ALLOCATED or OPEN Containers. This generally means
+    // We did not find OPEN Containers. This generally means
-    // Even though we have already checked the containers in ALLOCATED
+    // Even though we have already checked the containers in OPEN
-    synchronized (this) {
-      if (!containerManager.getContainers(HddsProtos.LifeCycleState.ALLOCATED)
-          .isEmpty()) {
-        containerWithPipeline = containerManager
-            .getMatchingContainerWithPipeline(size, owner, type, factor,
-                HddsProtos.LifeCycleState.ALLOCATED);
-      }
-      if (containerWithPipeline == null) {
-        preAllocateContainers(containerProvisionBatchSize,
-            type, factor, owner);
-        containerWithPipeline = containerManager
-            .getMatchingContainerWithPipeline(size, owner, type, factor,
-                HddsProtos.LifeCycleState.ALLOCATED);
-      }
+    if (containerWithPipeline == null) {
+      synchronized (this) {
+        if (!containerManager.getContainers(HddsProtos.LifeCycleState.OPEN)
+            .isEmpty()) {
+          containerWithPipeline = containerManager
+              .getMatchingContainerWithPipeline(size, owner, type, factor,
+                  HddsProtos.LifeCycleState.OPEN);
+        }
-      if (containerWithPipeline != null) {
-        containerManager.updateContainerState(
-            containerWithPipeline.getContainerInfo().containerID(),
-            HddsProtos.LifeCycleEvent.CREATE);
-        return newBlock(containerWithPipeline,
-            HddsProtos.LifeCycleState.ALLOCATED);
+        if (containerWithPipeline == null) {
+          preAllocateContainers(containerProvisionBatchSize, type, factor,
+              owner);
+          containerWithPipeline = containerManager
+              .getMatchingContainerWithPipeline(size, owner, type, factor,
+                  HddsProtos.LifeCycleState.OPEN);
+        }
+
+    if (containerWithPipeline != null) {
+      return newBlock(containerWithPipeline, HddsProtos.LifeCycleState.OPEN);
+    }
+
-    boolean createContainer = (state == HddsProtos.LifeCycleState.ALLOCATED);
-
-            .setPipeline(containerWithPipeline.getPipeline())
-            .setShouldCreateContainer(createContainer);
+            .setPipeline(containerWithPipeline.getPipeline());

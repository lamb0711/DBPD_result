YARN-4026. Refactored ContainerAllocator to accept a list of priorites rather than a single priority. Contributed by Wangda Tan

+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CSAssignment;
-  @Override
-    return ContainerAllocation.QUEUE_SKIPPED;
+    return ContainerAllocation.APP_SKIPPED;
-    ContainerAllocation assigned;
+    ContainerAllocation allocation;
-      assigned =
+      allocation =
-          assigned.getResourceToBeAllocated(), Resources.none())) {
-        assigned.requestNodeType = requestType;
-        return assigned;
+          allocation.getResourceToBeAllocated(), Resources.none())) {
+        allocation.requestNodeType = requestType;
+        return allocation;
-      assigned =
+      allocation =
-          assigned.getResourceToBeAllocated(), Resources.none())) {
-        assigned.requestNodeType = requestType;
-        return assigned;
+          allocation.getResourceToBeAllocated(), Resources.none())) {
+        allocation.requestNodeType = requestType;
+        return allocation;
-      assigned =
+      allocation =
-      assigned.requestNodeType = requestType;
+      allocation.requestNodeType = requestType;
+      
+      // When a returned allocation is LOCALITY_SKIPPED, since we're in
+      // off-switch request now, we will skip this app w.r.t priorities 
+      if (allocation.state == AllocationState.LOCALITY_SKIPPED) {
+        allocation.state = AllocationState.APP_SKIPPED;
+      }
-      return assigned;
+      return allocation;
-          AllocationState.QUEUE_SKIPPED);
+          AllocationState.LOCALITY_SKIPPED);
-      return ContainerAllocation.QUEUE_SKIPPED;
+      // Skip this locality request
+      return ContainerAllocation.LOCALITY_SKIPPED;
-            return ContainerAllocation.QUEUE_SKIPPED;
+            // Skip the locality request
+            return ContainerAllocation.LOCALITY_SKIPPED;
-      // if we are allowed to allocate but this node doesn't have space, reserve it or
-      // if this was an already a reserved container, reserve it again
+      // if we are allowed to allocate but this node doesn't have space, reserve
+      // it or if this was an already a reserved container, reserve it again
-          // reservationsContinueLooking is set. Make sure we didn't need to unreserve
-          // one.
+          // reservationsContinueLooking is set. Make sure we didn't need to
+          // unreserve one.
-            return ContainerAllocation.QUEUE_SKIPPED;
+            // Skip the locality request
+            return ContainerAllocation.LOCALITY_SKIPPED;          
-      return ContainerAllocation.QUEUE_SKIPPED;
+      // Skip the locality request
+      return ContainerAllocation.LOCALITY_SKIPPED;    
-              null, AllocationState.QUEUE_SKIPPED);
-      ret.state = AllocationState.APP_SKIPPED;
+              null, AllocationState.APP_SKIPPED);
-  @Override
-      return ContainerAllocation.QUEUE_SKIPPED;
+      return ContainerAllocation.APP_SKIPPED;
+  
+  private ContainerAllocation allocate(Resource clusterResource,
+      FiCaSchedulerNode node, SchedulingMode schedulingMode,
+      ResourceLimits resourceLimits, Priority priority,
+      RMContainer reservedContainer) {
+    ContainerAllocation result =
+        preAllocation(clusterResource, node, schedulingMode, resourceLimits,
+            priority, reservedContainer);
+
+    if (AllocationState.ALLOCATED == result.state
+        || AllocationState.RESERVED == result.state) {
+      result =
+          doAllocation(result, clusterResource, node, schedulingMode, priority,
+              reservedContainer);
+    }
+
+    return result;
+  }
+  
+  @Override
+  public CSAssignment assignContainers(Resource clusterResource,
+      FiCaSchedulerNode node, SchedulingMode schedulingMode,
+      ResourceLimits resourceLimits,
+      RMContainer reservedContainer) {
+    if (reservedContainer == null) {
+      // Check if application needs more resource, skip if it doesn't need more.
+      if (!application.hasPendingResourceRequest(rc,
+          node.getPartition(), clusterResource, schedulingMode)) {
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Skip app_attempt=" + application.getApplicationAttemptId()
+              + ", because it doesn't need more resource, schedulingMode="
+              + schedulingMode.name() + " node-label=" + node.getPartition());
+        }
+        return CSAssignment.SKIP_ASSIGNMENT;
+      }
+      
+      // Schedule in priority order
+      for (Priority priority : application.getPriorities()) {
+        ContainerAllocation result =
+            allocate(clusterResource, node, schedulingMode, resourceLimits,
+                priority, null);
+
+        AllocationState allocationState = result.getAllocationState();
+        if (allocationState == AllocationState.PRIORITY_SKIPPED) {
+          continue;
+        }
+        return getCSAssignmentFromAllocateResult(clusterResource, result,
+            null);
+      }
+
+      // We will reach here if we skipped all priorities of the app, so we will
+      // skip the app.
+      return CSAssignment.SKIP_ASSIGNMENT;
+    } else {
+      ContainerAllocation result =
+          allocate(clusterResource, node, schedulingMode, resourceLimits,
+              reservedContainer.getReservedPriority(), reservedContainer);
+      return getCSAssignmentFromAllocateResult(clusterResource, result,
+          reservedContainer);
+    }
+  }

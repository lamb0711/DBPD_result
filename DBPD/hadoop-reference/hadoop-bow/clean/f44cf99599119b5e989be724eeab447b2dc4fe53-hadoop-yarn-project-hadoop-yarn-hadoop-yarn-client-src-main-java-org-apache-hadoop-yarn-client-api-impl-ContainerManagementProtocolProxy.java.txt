YARN-2314. Disable ContainerManagementProtocolProxy cache by default to prevent creating thousands of threads in a large cluster. Contributed by Jason Lowe

+import java.util.Collections;
+import java.util.Map;
+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;
-  private final LinkedHashMap<String, ContainerManagementProtocolProxyData> cmProxy;
+  private final Map<String, ContainerManagementProtocolProxyData> cmProxy;
-    if (maxConnectedNMs < 1) {
+    if (maxConnectedNMs < 0) {
-              + " (" + maxConnectedNMs + ") can not be less than 1.");
+              + " (" + maxConnectedNMs + ") can not be less than 0.");
-    cmProxy =
-        new LinkedHashMap<String, ContainerManagementProtocolProxyData>();
+    if (maxConnectedNMs > 0) {
+      cmProxy =
+          new LinkedHashMap<String, ContainerManagementProtocolProxyData>();
+    } else {
+      cmProxy = Collections.emptyMap();
+      // Connections are not being cached so ensure connections close quickly
+      // to avoid creating thousands of RPC client threads on large clusters.
+      conf.setInt(
+          CommonConfigurationKeysPublic.IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY,
+          0);
+    }
-      if (cmProxy.size() > maxConnectedNMs) {
-        // Number of existing proxy exceed the limit.
-        String cmAddr = cmProxy.keySet().iterator().next();
-        removeProxy(cmProxy.get(cmAddr));
+      if (maxConnectedNMs > 0) {
+        addProxyToCache(containerManagerBindAddr, proxy);
-      
-      cmProxy.put(containerManagerBindAddr, proxy);
+
+  private void addProxyToCache(String containerManagerBindAddr,
+      ContainerManagementProtocolProxyData proxy) {
+    while (cmProxy.size() >= maxConnectedNMs) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Cleaning up the proxy cache, size=" + cmProxy.size()
+            + " max=" + maxConnectedNMs);
+      }
+      boolean removedProxy = false;
+      for (ContainerManagementProtocolProxyData otherProxy : cmProxy.values()) {
+        removedProxy = removeProxy(otherProxy);
+        if (removedProxy) {
+          break;
+        }
+      }
+      if (!removedProxy) {
+        // all of the proxies are currently in use and already scheduled
+        // for removal, so we need to wait until at least one of them closes
+        try {
+          this.wait();
+        } catch (InterruptedException e) {
+          e.printStackTrace();
+        }
+      }
+    }
+
+    if (maxConnectedNMs > 0) {
+      cmProxy.put(containerManagerBindAddr, proxy);
+    }
+  }
-    ContainerManagementProtocolProxyData proxy =
-        cmProxy.remove(containerManagerBindAddr);
-    cmProxy.put(containerManagerBindAddr, proxy);
+    if (maxConnectedNMs > 0) {
+      ContainerManagementProtocolProxyData proxy =
+          cmProxy.remove(containerManagerBindAddr);
+      cmProxy.put(containerManagerBindAddr, proxy);
+    }
+    tryCloseProxy(proxy);
+  }
+
+  private boolean tryCloseProxy(
+      ContainerManagementProtocolProxyData proxy) {
+      return true;
+    return false;
-  private synchronized void removeProxy(
+  private synchronized boolean removeProxy(
-      mayBeCloseProxy(proxy);
+      return tryCloseProxy(proxy);
+    return false;

svn merge -c -1430507 . for reverting HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430662 13f79535-47bb-0310-9956-ffa450edef68

+import java.net.Socket;
+import java.nio.channels.ReadableByteChannel;
-import org.apache.hadoop.hdfs.protocol.DatanodeID;
-import org.apache.hadoop.hdfs.net.Peer;
+import org.apache.hadoop.hdfs.protocol.datatransfer.IOStreamPair;
+import org.apache.hadoop.hdfs.security.token.block.DataEncryptionKey;
+import org.apache.hadoop.hdfs.security.token.block.BlockTokenIdentifier;
+import org.apache.hadoop.net.SocketInputWrapper;
+import org.apache.hadoop.security.token.Token;
-import com.google.common.annotations.VisibleForTesting;
-
-  private final DatanodeID datanodeID;
-  private final Peer peer;
+  
+  Socket dnSock;
+  // for now just sending the status code (e.g. checksumOk) after the read.
+  private IOStreamPair ioStreams;
+  private final ReadableByteChannel in;
-  @VisibleForTesting
-  public Peer getPeer() {
-    return peer;
-  }
-  
-    packetReceiver.receiveNextPacket(peer.getInputStreamChannel());
+    packetReceiver.receiveNextPacket(in);
-    packetReceiver.receiveNextPacket(peer.getInputStreamChannel());
+    packetReceiver.receiveNextPacket(in);
-      DataChecksum checksum, long firstChunkOffset) {
+      DataChecksum checksum, long firstChunkOffset, ReadableByteChannel in) {
-    this.datanodeID = params.getDatanodeID();
-    this.peer = params.getPeer();
+    this.dnSock = params.getSocket();
+    this.ioStreams = params.getIoStreamPair();
+    this.in = in;
-  public synchronized void close(PeerCache peerCache) throws IOException {
+  public synchronized void close() throws IOException {
-    if (peerCache != null && sentStatusCode) {
-      peerCache.put(datanodeID, peer);
-    } else {
-      peer.close();
+    if (dnSock != null) {
+      dnSock.close();
+  
+  /**
+   * Take the socket used to talk to the DN.
+   */
+  @Override
+  public Socket takeSocket() {
+    assert hasSentStatusCode() :
+      "BlockReader shouldn't give back sockets mid-read";
+    Socket res = dnSock;
+    dnSock = null;
+    return res;
+  }
+
+  /**
+   * Whether the BlockReader has reached the end of its input stream
+   * and successfully sent a status code back to the datanode.
+   */
+  @Override
+  public boolean hasSentStatusCode() {
+    return sentStatusCode;
+  }
-    assert !sentStatusCode : "already sent status code to " + peer;
+    assert !sentStatusCode : "already sent status code to " + dnSock;
-      writeReadResult(peer.getOutputStream(), statusCode);
+      writeReadResult(ioStreams.out, statusCode);
-               peer.getRemoteAddressString() + ": " + e.getMessage());
+               dnSock.getInetAddress() + ": " + e.getMessage());
+    IOStreamPair ioStreams = params.getIoStreamPair();
+    ReadableByteChannel ch;
+    if (ioStreams.in instanceof SocketInputWrapper) {
+      ch = ((SocketInputWrapper)ioStreams.in).getReadableByteChannel();
+    } else {
+      ch = (ReadableByteChannel) ioStreams.in;
+    }
+    
-          params.getPeer().getOutputStream()));
+          ioStreams.out));
-    DataInputStream in = new DataInputStream(params.getPeer().getInputStream());
+    DataInputStream in = new DataInputStream(ioStreams.in);
-    checkSuccess(status, params.getPeer(), params.getBlock(), params.getFile());
+    checkSuccess(status, params.getSocket(), params.getBlock(),
+        params.getFile());
-    return new RemoteBlockReader2(params, checksum, firstChunkOffset);
+    return new RemoteBlockReader2(params, checksum, firstChunkOffset, ch);
-      BlockOpResponseProto status, Peer peer,
+      BlockOpResponseProto status, Socket sock,
-                + peer.getLocalAddressString() + ", remote="
-                + peer.getRemoteAddressString() + ", for file " + file
+                + sock.getLocalSocketAddress() + ", remote="
+                + sock.getRemoteSocketAddress() + ", for file " + file
-            + peer.getLocalAddressString() + ", remote="
-            + peer.getRemoteAddressString() + ", for file " + file
+            + sock.getLocalSocketAddress() + ", remote="
+            + sock.getRemoteSocketAddress() + ", for file " + file
+
+  @Override
+  public IOStreamPair getStreams() {
+    return ioStreams;
+  }

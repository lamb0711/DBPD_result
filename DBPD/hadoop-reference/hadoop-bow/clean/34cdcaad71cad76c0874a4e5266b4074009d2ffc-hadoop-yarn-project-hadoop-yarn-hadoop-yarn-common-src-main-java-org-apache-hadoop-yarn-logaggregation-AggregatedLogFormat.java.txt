YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.

+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.regex.Pattern;
+import org.apache.hadoop.yarn.api.records.LogAggregationContext;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+
+    private final LogAggregationContext logAggregationContext;
+    private Set<File> uploadedFiles = new HashSet<File>();
+    private final Set<String> alreadyUploadedLogFiles;
+    private Set<String> allExistingFileMeta = new HashSet<String>();
+      this(rootLogDirs, containerId, user, null, new HashSet<String>());
+    }
+
+    public LogValue(List<String> rootLogDirs, ContainerId containerId,
+        String user, LogAggregationContext logAggregationContext,
+        Set<String> alreadyUploadedLogFiles) {
+      this.logAggregationContext = logAggregationContext;
+      this.alreadyUploadedLogFiles = alreadyUploadedLogFiles;
-    public void write(DataOutputStream out) throws IOException {
+    private Set<File> getPendingLogFilesToUploadForThisContainer() {
+      Set<File> pendingUploadFiles = new HashSet<File>();
-        // Write out log files in lexical order
-        File[] logFiles = containerLogDir.listFiles();
-        Arrays.sort(logFiles);
-        for (File logFile : logFiles) {
+        pendingUploadFiles
+          .addAll(getPendingLogFilesToUpload(containerLogDir));
+      }
+      return pendingUploadFiles;
+    }
-          final long fileLength = logFile.length();
+    public void write(DataOutputStream out, Set<File> pendingUploadFiles)
+        throws IOException {
+      List<File> fileList = new ArrayList<File>(pendingUploadFiles);
+      Collections.sort(fileList);
-          // Write the logFile Type
-          out.writeUTF(logFile.getName());
+      for (File logFile : fileList) {
+        final long fileLength = logFile.length();
+        // Write the logFile Type
+        out.writeUTF(logFile.getName());
-          // Write the log length as UTF so that it is printable
-          out.writeUTF(String.valueOf(fileLength));
+        // Write the log length as UTF so that it is printable
+        out.writeUTF(String.valueOf(fileLength));
-          // Write the log itself
-          FileInputStream in = null;
-          try {
-            in = SecureIOUtils.openForRead(logFile, getUser(), null);
-            byte[] buf = new byte[65535];
-            int len = 0;
-            long bytesLeft = fileLength;
-            while ((len = in.read(buf)) != -1) {
-              //If buffer contents within fileLength, write
-              if (len < bytesLeft) {
-                out.write(buf, 0, len);
-                bytesLeft-=len;
-              }
-              //else only write contents within fileLength, then exit early
-              else {
-                out.write(buf, 0, (int)bytesLeft);
-                break;
-              }
+        // Write the log itself
+        FileInputStream in = null;
+        try {
+          in = SecureIOUtils.openForRead(logFile, getUser(), null);
+          byte[] buf = new byte[65535];
+          int len = 0;
+          long bytesLeft = fileLength;
+          while ((len = in.read(buf)) != -1) {
+            //If buffer contents within fileLength, write
+            if (len < bytesLeft) {
+              out.write(buf, 0, len);
+              bytesLeft-=len;
-            long newLength = logFile.length();
-            if(fileLength < newLength) {
-              LOG.warn("Aggregated logs truncated by approximately "+
-                  (newLength-fileLength) +" bytes.");
+            //else only write contents within fileLength, then exit early
+            else {
+              out.write(buf, 0, (int)bytesLeft);
+              break;
-          } catch (IOException e) {
-            String message = "Error aggregating log file. Log file : "
-                + logFile.getAbsolutePath() + e.getMessage(); 
-            LOG.error(message, e);
-            out.write(message.getBytes());
-          } finally {
-            if (in != null) {
-              in.close();
-            }
+          }
+          long newLength = logFile.length();
+          if(fileLength < newLength) {
+            LOG.warn("Aggregated logs truncated by approximately "+
+                (newLength-fileLength) +" bytes.");
+          }
+          this.uploadedFiles.add(logFile);
+        } catch (IOException e) {
+          String message = "Error aggregating log file. Log file : "
+              + logFile.getAbsolutePath() + e.getMessage();
+          LOG.error(message, e);
+          out.write(message.getBytes());
+        } finally {
+          if (in != null) {
+            in.close();
-    
+
+
+    private Set<File> getPendingLogFilesToUpload(File containerLogDir) {
+      Set<File> candidates =
+          new HashSet<File>(Arrays.asList(containerLogDir.listFiles()));
+      for (File logFile : candidates) {
+        this.allExistingFileMeta.add(getLogFileMetaData(logFile));
+      }
+
+      if (this.logAggregationContext != null && candidates.size() > 0) {
+        if (this.logAggregationContext.getIncludePattern() != null
+            && !this.logAggregationContext.getIncludePattern().isEmpty()) {
+          filterFiles(this.logAggregationContext.getIncludePattern(),
+              candidates, false);
+        }
+
+        if (this.logAggregationContext.getExcludePattern() != null
+            && !this.logAggregationContext.getExcludePattern().isEmpty()) {
+          filterFiles(this.logAggregationContext.getExcludePattern(),
+              candidates, true);
+        }
+
+        Iterable<File> mask =
+            Iterables.filter(candidates, new Predicate<File>() {
+              @Override
+              public boolean apply(File next) {
+                return !alreadyUploadedLogFiles
+                  .contains(getLogFileMetaData(next));
+              }
+            });
+        candidates = Sets.newHashSet(mask);
+      }
+      return candidates;
+    }
+
+    private void filterFiles(String pattern, Set<File> candidates,
+        boolean exclusion) {
+      Pattern filterPattern =
+          Pattern.compile(pattern);
+      for (Iterator<File> candidatesItr = candidates.iterator(); candidatesItr
+          .hasNext();) {
+        File candidate = candidatesItr.next();
+        boolean match = filterPattern.matcher(candidate.getName()).find();
+        if ((!match && !exclusion) || (match && exclusion)) {
+          candidatesItr.remove();
+        }
+      }
+    }
+
+    public Set<Path> getCurrentUpLoadedFilesPath() {
+      Set<Path> path = new HashSet<Path>();
+      for (File file : this.uploadedFiles) {
+        path.add(new Path(file.getAbsolutePath()));
+      }
+      return path;
+    }
+
+    public Set<String> getCurrentUpLoadedFileMeta() {
+      Set<String> info = new HashSet<String>();
+      for (File file : this.uploadedFiles) {
+        info.add(getLogFileMetaData(file));
+      }
+      return info;
+    }
+
+    public Set<String> getAllExistingFilesMeta() {
+      return this.allExistingFileMeta;
+    }
+
+    private String getLogFileMetaData(File file) {
+      return containerId.toString() + "_" + file.getName() + "_"
+          + file.lastModified();
+    }
+    private FileContext fc;
-                FileContext fc = FileContext.getFileContext(conf);
+                fc = FileContext.getFileContext(conf);
+      Set<File> pendingUploadFiles =
+          logValue.getPendingLogFilesToUploadForThisContainer();
+      if (pendingUploadFiles.size() == 0) {
+        return;
+      }
-      logValue.write(out);
+      logValue.write(out, pendingUploadFiles);
-      try {
-        this.fsDataOStream.close();
-      } catch (IOException e) {
-        LOG.warn("Exception closing output-stream", e);
-      }
+      IOUtils.closeStream(fsDataOStream);

HDFS-2395. Add a root element in the JSON responses of webhdfs.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1179169 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.util.StringUtils;
-  private static class ThreadLocalMap extends ThreadLocal<Map<String, Object>> {
-    @Override
-    protected Map<String, Object> initialValue() {
-      return new TreeMap<String, Object>();
-    }
-
-    @Override
-    public Map<String, Object> get() {
-      final Map<String, Object> m = super.get();
-      m.clear();
-      return m;
-    }
-  }
-
-  private static final ThreadLocalMap jsonMap = new ThreadLocalMap();
-  private static final ThreadLocalMap tokenMap = new ThreadLocalMap();
-  private static final ThreadLocalMap datanodeInfoMap = new ThreadLocalMap();
-  private static final ThreadLocalMap extendedBlockMap = new ThreadLocalMap();
-  private static final ThreadLocalMap locatedBlockMap = new ThreadLocalMap();
-
+  private static final Object[] EMPTY_OBJECT_ARRAY = {};
+    return toJsonString(Token.class, toJsonMap(token));
+  }
+
+  private static Map<String, Object> toJsonMap(
+      final Token<? extends TokenIdentifier> token) throws IOException {
-    final Map<String, Object> m = tokenMap.get();
+    final Map<String, Object> m = new TreeMap<String, Object>();
-    return JSON.toString(m);
+    return m;
-      final Map<?, ?> m) throws IOException {
+      final Map<?, ?> json) throws IOException {
+    final Map<?, ?> m = (Map<?, ?>)json.get(Token.class.getSimpleName());
-  public static Token<BlockTokenIdentifier> toBlockToken(
+  private static Token<BlockTokenIdentifier> toBlockToken(
-    final Map<String, Object> m = jsonMap.get();
+    final Map<String, Object> m = new TreeMap<String, Object>();
-    return JSON.toString(m);
+    return toJsonString(RemoteException.class, m);
-  public static RemoteException toRemoteException(final Map<String, Object> m) {
+  public static RemoteException toRemoteException(final Map<?, ?> json) {
+    final Map<?, ?> m = (Map<?, ?>)json.get(RemoteException.class.getSimpleName());
+  private static String toJsonString(final Class<?> clazz, final Object value) {
+    return toJsonString(clazz.getSimpleName(), value);
+  }
+
-  public static String toJsonString(final Object key, final Object value) {
-    final Map<String, Object> m = jsonMap.get();
-    m.put(key instanceof String ? (String) key : key.toString(), value);
+  public static String toJsonString(final String key, final Object value) {
+    final Map<String, Object> m = new TreeMap<String, Object>();
+    m.put(key, value);
-  public static String toString(final FsPermission permission) {
+  private static String toString(final FsPermission permission) {
-  public static FsPermission toFsPermission(final String s) {
+  private static FsPermission toFsPermission(final String s) {
-      final Map<String, Object> m = jsonMap.get();
+      final Map<String, Object> m = new TreeMap<String, Object>();
-      return JSON.toString(m);
+      return toJsonString(HdfsFileStatus.class, m);
-  @SuppressWarnings("unchecked")
-  static Map<String, Object> parse(String jsonString) {
-    return (Map<String, Object>) JSON.parse(jsonString);
-  }
-
-  public static HdfsFileStatus toFileStatus(final Map<String, Object> m) {
-    if (m == null) {
+  public static HdfsFileStatus toFileStatus(final Map<?, ?> json) {
+    if (json == null) {
+    final Map<?, ?> m = (Map<?, ?>)json.get(HdfsFileStatus.class.getSimpleName());
-  /** Convert a LocatedBlock to a Json string. */
-  public static String toJsonString(final ExtendedBlock extendedblock) {
+  /** Convert an ExtendedBlock to a Json map. */
+  private static Map<String, Object> toJsonMap(final ExtendedBlock extendedblock) {
-    final Map<String, Object> m = extendedBlockMap.get();
+    final Map<String, Object> m = new TreeMap<String, Object>();
-    return JSON.toString(m);
+    return m;
-  public static ExtendedBlock toExtendedBlock(final Map<?, ?> m) {
+  private static ExtendedBlock toExtendedBlock(final Map<?, ?> m) {
-  /** Convert a DatanodeInfo to a Json string. */
-  public static String toJsonString(final DatanodeInfo datanodeinfo) {
+  /** Convert a DatanodeInfo to a Json map. */
+  private static Map<String, Object> toJsonMap(final DatanodeInfo datanodeinfo) {
-    final Map<String, Object> m = datanodeInfoMap.get();
+    final Map<String, Object> m = new TreeMap<String, Object>();
-    return JSON.toString(m);
+    return m;
-  public static DatanodeInfo toDatanodeInfo(final Map<?, ?> m) {
+  private static DatanodeInfo toDatanodeInfo(final Map<?, ?> m) {
-  /** Convert a DatanodeInfo[] to a Json string. */
-  public static String toJsonString(final DatanodeInfo[] array
-      ) throws IOException {
+  /** Convert a DatanodeInfo[] to a Json array. */
+  private static Object[] toJsonArray(final DatanodeInfo[] array) {
-      return "[]";
+      return EMPTY_OBJECT_ARRAY;
-      final StringBuilder b = new StringBuilder().append('[').append(
-          toJsonString(array[0]));
-      for(int i = 1; i < array.length; i++) {
-        b.append(", ").append(toJsonString(array[i]));
+      final Object[] a = new Object[array.length];
+      for(int i = 0; i < array.length; i++) {
+        a[i] = toJsonMap(array[i]);
-      return b.append(']').toString();
+      return a;
-  public static DatanodeInfo[] toDatanodeInfoArray(final Object[] objects) {
+  private static DatanodeInfo[] toDatanodeInfoArray(final Object[] objects) {
-        array[i] = (DatanodeInfo)toDatanodeInfo((Map<?, ?>) objects[i]);
+        array[i] = toDatanodeInfo((Map<?, ?>) objects[i]);
-  /** Convert a LocatedBlock to a Json string. */
-  public static String toJsonString(final LocatedBlock locatedblock
+  /** Convert a LocatedBlock to a Json map. */
+  private static Map<String, Object> toJsonMap(final LocatedBlock locatedblock
-    final Map<String, Object> m = locatedBlockMap.get();
-    m.put("blockToken", toJsonString(locatedblock.getBlockToken()));
+    final Map<String, Object> m = new TreeMap<String, Object>();
+    m.put("blockToken", toJsonMap(locatedblock.getBlockToken()));
-    m.put("block", toJsonString(locatedblock.getBlock()));
-
-    m.put("locations", toJsonString(locatedblock.getLocations()));
-    return JSON.toString(m);
+    m.put("block", toJsonMap(locatedblock.getBlock()));
+    m.put("locations", toJsonArray(locatedblock.getLocations()));
+    return m;
-  public static LocatedBlock toLocatedBlock(final Map<?, ?> m) throws IOException {
+  private static LocatedBlock toLocatedBlock(final Map<?, ?> m) throws IOException {
-    final ExtendedBlock b = toExtendedBlock((Map<?, ?>)JSON.parse((String)m.get("block")));
+    final ExtendedBlock b = toExtendedBlock((Map<?, ?>)m.get("block"));
-        (Object[])JSON.parse((String)m.get("locations")));
+        (Object[])m.get("locations"));
-    locatedblock.setBlockToken(toBlockToken((Map<?, ?>)JSON.parse((String)m.get("blockToken"))));
+    locatedblock.setBlockToken(toBlockToken((Map<?, ?>)m.get("blockToken")));
-  /** Convert a LocatedBlock[] to a Json string. */
-  public static String toJsonString(final List<LocatedBlock> array
+  /** Convert a LocatedBlock[] to a Json array. */
+  private static Object[] toJsonArray(final List<LocatedBlock> array
-      return "[]";
+      return EMPTY_OBJECT_ARRAY;
-      final StringBuilder b = new StringBuilder().append('[').append(
-          toJsonString(array.get(0)));
-      for(int i = 1; i < array.size(); i++) {
-        b.append(",\n  ").append(toJsonString(array.get(i)));
+      final Object[] a = new Object[array.size()];
+      for(int i = 0; i < array.size(); i++) {
+        a[i] = toJsonMap(array.get(0));
-      return b.append(']').toString();
+      return a;
-  /** Convert an Object[] to a List of LocatedBlock. 
-   * @throws IOException */
-  public static List<LocatedBlock> toLocatedBlockList(final Object[] objects
+  /** Convert an Object[] to a List of LocatedBlock. */
+  private static List<LocatedBlock> toLocatedBlockList(final Object[] objects
-        list.add((LocatedBlock)toLocatedBlock((Map<?, ?>)objects[i]));
+        list.add(toLocatedBlock((Map<?, ?>)objects[i]));
-    final Map<String, Object> m = jsonMap.get();
+    final Map<String, Object> m = new TreeMap<String, Object>();
-    m.put("locatedBlocks", toJsonString(locatedblocks.getLocatedBlocks()));
-    m.put("lastLocatedBlock", toJsonString(locatedblocks.getLastLocatedBlock()));
+    m.put("locatedBlocks", toJsonArray(locatedblocks.getLocatedBlocks()));
+    m.put("lastLocatedBlock", toJsonMap(locatedblocks.getLastLocatedBlock()));
-    return JSON.toString(m);
+    return toJsonString(LocatedBlocks.class, m);
-  public static LocatedBlocks toLocatedBlocks(final Map<String, Object> m
+  public static LocatedBlocks toLocatedBlocks(final Map<?, ?> json
-    if (m == null) {
+    if (json == null) {
-    
+
+    final Map<?, ?> m = (Map<?, ?>)json.get(LocatedBlocks.class.getSimpleName());
-        (Object[])JSON.parse((String) m.get("locatedBlocks")));
+        (Object[])m.get("locatedBlocks"));
-        (Map<?, ?>)JSON.parse((String)m.get("lastLocatedBlock")));
+        (Map<?, ?>)m.get("lastLocatedBlock"));
-  public static String toJsonString(final ContentSummary contentsummary
-      ) throws IOException {
+  public static String toJsonString(final ContentSummary contentsummary) {
-    final Map<String, Object> m = jsonMap.get();
+    final Map<String, Object> m = new TreeMap<String, Object>();
-    return JSON.toString(m);
+    return toJsonString(ContentSummary.class, m);
-  public static ContentSummary toContentSummary(final Map<String, Object> m
-      ) throws IOException {
-    if (m == null) {
+  public static ContentSummary toContentSummary(final Map<?, ?> json) {
+    if (json == null) {
+    final Map<?, ?> m = (Map<?, ?>)json.get(ContentSummary.class.getSimpleName());
-  public static String toJsonString(final MD5MD5CRC32FileChecksum checksum
-      ) throws IOException {
+  public static String toJsonString(final MD5MD5CRC32FileChecksum checksum) {
-    final Map<String, Object> m = jsonMap.get();
-    final byte[] bytes = checksum.getBytes();
-    final DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));
-    final int bytesPerCRC = in.readInt();
-    final long crcPerBlock = in.readLong();
-    final MD5Hash md5 = MD5Hash.read(in);
-    m.put("bytesPerCRC", bytesPerCRC);
-    m.put("crcPerBlock", crcPerBlock);
-    m.put("md5", "" + md5);
-    return JSON.toString(m);
+    final Map<String, Object> m = new TreeMap<String, Object>();
+    m.put("algorithm", checksum.getAlgorithmName());
+    m.put("length", checksum.getLength());
+    m.put("bytes", StringUtils.byteToHexString(checksum.getBytes()));
+    return toJsonString(MD5MD5CRC32FileChecksum.class, m);
-      final Map<String, Object> m) throws IOException {
-    if (m == null) {
+      final Map<?, ?> json) throws IOException {
+    if (json == null) {
-    final int bytesPerCRC = (int)(long)(Long)m.get("bytesPerCRC");
-    final long crcPerBlock = (Long)m.get("crcPerBlock");
-    final String md5 = (String)m.get("md5");
+    final Map<?, ?> m = (Map<?, ?>)json.get(
+        MD5MD5CRC32FileChecksum.class.getSimpleName());
+    final String algorithm = (String)m.get("algorithm");
+    final int length = (int)(long)(Long)m.get("length");
+    final byte[] bytes = StringUtils.hexStringToByte((String)m.get("bytes"));
-    return new MD5MD5CRC32FileChecksum(bytesPerCRC, crcPerBlock,
-        new MD5Hash(md5));
+    final DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));
+    final int bytesPerCRC = in.readInt();
+    final long crcPerBlock = in.readLong();
+    final MD5Hash md5 = MD5Hash.read(in);
+    final MD5MD5CRC32FileChecksum checksum = new MD5MD5CRC32FileChecksum(
+        bytesPerCRC, crcPerBlock, md5);
+
+    //check algorithm name
+    final String alg = "MD5-of-" + crcPerBlock + "MD5-of-" + bytesPerCRC + "CRC32";
+    if (!alg.equals(algorithm)) {
+      throw new IOException("Algorithm not matched: algorithm=" + algorithm
+          + ", crcPerBlock=" + crcPerBlock
+          + ", bytesPerCRC=" + bytesPerCRC);
+    }
+    //check length
+    if (length != checksum.getLength()) {
+      throw new IOException("Length not matched: length=" + length
+          + ", checksum.getLength()=" + checksum.getLength());
+    }
+
+    return checksum;

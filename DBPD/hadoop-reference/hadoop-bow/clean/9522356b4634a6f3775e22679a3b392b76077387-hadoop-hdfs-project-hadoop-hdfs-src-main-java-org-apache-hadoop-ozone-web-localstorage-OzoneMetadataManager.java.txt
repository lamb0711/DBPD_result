HDFS-12069. Ozone: Create a general abstraction for metadata store. Contributed by Weiwei Yang.

-import org.apache.hadoop.utils.LevelDBStore;
-import org.iq80.leveldb.DBException;
-import org.iq80.leveldb.DBIterator;
+import org.apache.hadoop.utils.MetadataStore;
+import org.apache.hadoop.utils.MetadataStoreBuilder;
-  private LevelDBStore userDB;
-  private LevelDBStore metadataDB;
+  private MetadataStore userDB;
+  private MetadataStore metadataDB;
-      userDB = new LevelDBStore(new File(storageRoot + USER_DB), true);
-      metadataDB = new LevelDBStore(new File(storageRoot + META_DB), true);
+      userDB = MetadataStoreBuilder.newBuilder()
+          .setDbFile(new File(storageRoot + USER_DB))
+          .setCreateIfMissing(true)
+          .build();
+      metadataDB = MetadataStoreBuilder.newBuilder()
+          .setDbFile(new File(storageRoot + META_DB))
+          .setCreateIfMissing(true)
+          .build();
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {
-  public ListVolumes listAllVolumes(ListArgs args) throws OzoneException,
-      IOException {
+  public ListVolumes listAllVolumes(ListArgs args)
+      throws OzoneException, IOException {
-    String prevKey = args.getPrevKey();
+    final String prevKey;
-    try (DBIterator iterator = this.userDB.getDB().iterator()) {
-      if (prevKey != null) {
-        // Format is username/volumeName
-
-        String[] volName = args.getPrevKey().split("/");
-        if (volName.length < 2) {
-          throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, args.getArgs());
-        }
-        seekToUser(iterator, volName[0]);
-        userName = new String(iterator.peekNext().getKey(), encoding);
-        prevKey = volName[1];
-      } else {
-        userName = getFirstUser(iterator);
-      }
-
-      if (userName == null || userName.isEmpty()) {
+    if (args.getPrevKey() != null) {
+      // Format is username/volumeName
+      String[] volName = args.getPrevKey().split("/");
+      if (volName.length < 2) {
-      ListVolumes returnSet = new ListVolumes();
-      int count = maxCount - returnSet.getVolumes().size();
+      byte[] userNameBytes = userDB.get(volName[0].getBytes(encoding));
+      userName = new String(userNameBytes, encoding);
+      prevKey = volName[1];
+    } else {
+      userName = new String(userDB.peekAround(0, null).getKey(), encoding);
+      prevKey = null;
+    }
-      // we need to iterate through users until we get maxcount volumes
-      // or no more volumes are left.
-      while (iterator.hasNext() && count > 0) {
+    if (userName == null || userName.isEmpty()) {
+      throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, args.getArgs());
+    }
-        userName = new String(iterator.next().getKey(), encoding);
-
-        byte[] volumeList = userDB.get(userName.getBytes(encoding));
+    ListVolumes returnSet = new ListVolumes();
+    // we need to iterate through users until we get maxcount volumes
+    // or no more volumes are left.
+    userDB.iterate(null, (key, value) -> {
+      int currentSize = returnSet.getVolumes().size();
+      if (currentSize < maxCount) {
+        String name = new String(key, encoding);
+        byte[] volumeList = userDB.get(name.getBytes(encoding));
-          throw ErrorTable.newError(ErrorTable.USER_NOT_FOUND, args.getArgs());
+          throw new IOException(
+              ErrorTable.newError(ErrorTable.USER_NOT_FOUND, args.getArgs()));
-
-        returnSet.getVolumes().addAll(getFilteredVolumes(
-            volumeList, prefix, prevKey, count).getVolumes());
-        count = maxCount - returnSet.getVolumes().size();
+        returnSet.getVolumes().addAll(
+            getFilteredVolumes(volumeList, prefix, prevKey,
+                maxCount - currentSize).getVolumes());
+        return true;
+      } else {
+        return false;
-      return returnSet;
-    }
-  }
+    });
-  /**
-   * Returns the first user name from the UserDB.
-   *
-   * @return - UserName.
-   * @throws IOException
-   */
-  String getFirstUser(DBIterator iterator) throws IOException {
-    iterator.seekToFirst();
-    if (iterator.hasNext()) {
-      return new String(iterator.peekNext().getKey(), encoding);
-    }
-    return null;
-  }
-
-  /**
-   * Reposition the DB cursor to the user name.
-   *
-   * @param iterator - Current Iterator.
-   * @param userName - userName to seek to
-   * @return - DBIterator.
-   * @throws IOException
-   */
-  DBIterator seekToUser(DBIterator iterator, String userName) throws
-      IOException {
-    iterator.seek(userName.getBytes(encoding));
-    return iterator;
+    return returnSet;
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {
-    } catch (IOException | DBException ex) {
+    } catch (IOException ex) {

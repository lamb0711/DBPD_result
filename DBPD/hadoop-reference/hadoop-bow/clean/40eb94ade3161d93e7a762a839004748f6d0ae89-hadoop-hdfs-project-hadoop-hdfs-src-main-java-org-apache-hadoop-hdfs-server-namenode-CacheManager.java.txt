HDFS-5053. NameNode should invoke DataNode APIs to coordinate caching. (Andrew Wang)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1523145 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Map.Entry;
-import java.util.Map.Entry;
-final class CacheManager {
+public final class CacheManager {
+   * Cache entries, sorted by path
+   */
+  private final TreeMap<String, List<PathBasedCacheEntry>> entriesByPath =
+      new TreeMap<String, List<PathBasedCacheEntry>>();
+
+  /**
-  CacheManager(FSDirectory dir, Configuration conf) {
+  final private FSNamesystem namesystem;
+  final private FSDirectory dir;
+
+  CacheManager(FSNamesystem namesystem, FSDirectory dir, Configuration conf) {
+    this.namesystem = namesystem;
+    this.dir = dir;
+    entriesByPath.clear();
-      LOG.info("addDirective " + directive + ": validation failed.");
+      LOG.info("addDirective " + directive + ": validation failed: "
+          + ioe.getClass().getName() + ": " + ioe.getMessage());
+
+    // Success!
+    // First, add it to the various maps
+    String path = directive.getPath();
+    List<PathBasedCacheEntry> entryList = entriesByPath.get(path);
+    if (entryList == null) {
+      entryList = new ArrayList<PathBasedCacheEntry>(1);
+      entriesByPath.put(path, entryList);
+    }
+    entryList.add(entry);
+
+    // Next, set the path as cached in the namesystem
+    try {
+      INode node = dir.getINode(directive.getPath());
+      if (node.isFile()) {
+        INodeFile file = node.asFile();
+        // TODO: adjustable cache replication factor
+        namesystem.setCacheReplicationInt(directive.getPath(),
+            file.getBlockReplication());
+      }
+    } catch (IOException ioe) {
+      LOG.info("addDirective " + directive +": failed to cache file: " +
+          ioe.getClass().getName() +": " + ioe.getMessage());
+      return new Fallible<PathBasedCacheEntry>(ioe);
+    }
+
+    // Remove the corresponding entry in entriesByPath.
+    String path = existing.getDirective().getPath();
+    List<PathBasedCacheEntry> entries = entriesByPath.get(path);
+    if (entries == null || !entries.remove(existing)) {
+      return new Fallible<Long>(
+          new UnexpectedRemovePathBasedCacheEntryException(entryId));
+    }
+    if (entries.size() == 0) {
+      entriesByPath.remove(path);
+    }
+
+    // Set the path as uncached in the namesystem
+    try {
+      INode node = dir.getINode(existing.getDirective().getPath());
+      if (node.isFile()) {
+        namesystem.setCacheReplicationInt(existing.getDirective().getPath(),
+            (short) 0);
+      }
+    } catch (IOException e) {
+      LOG.warn("removeEntry " + entryId + ": failure while setting cache"
+          + " replication factor", e);
+      return new Fallible<Long>(e);
+    }
+    LOG.info("removeEntry successful for PathCacheEntry id " + entryId);

Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1196458 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Map;
-import org.apache.avro.ipc.Server;
+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;
+import org.apache.hadoop.ipc.Server;
-import org.apache.hadoop.security.SecurityInfo;
-import org.apache.hadoop.security.authorize.AccessControlList;
+import org.apache.hadoop.security.authorize.PolicyProvider;
-import org.apache.hadoop.yarn.api.protocolrecords.KillApplicationRequest;
-import org.apache.hadoop.yarn.api.protocolrecords.KillApplicationResponse;
+import org.apache.hadoop.yarn.api.protocolrecords.KillApplicationRequest;
+import org.apache.hadoop.yarn.api.protocolrecords.KillApplicationResponse;
+import org.apache.hadoop.yarn.api.records.ApplicationAccessType;
+import org.apache.hadoop.yarn.api.records.Resource;
-import org.apache.hadoop.yarn.security.client.ClientRMSecurityInfo;
+import org.apache.hadoop.yarn.server.resourcemanager.resource.Resources;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerNodeReport;
+import org.apache.hadoop.yarn.server.resourcemanager.security.authorize.RMPolicyProvider;
+import org.apache.hadoop.yarn.server.security.ApplicationACLsManager;
-  private  ApplicationACLsManager aclsManager;
-  private Map<ApplicationACL, AccessControlList> applicationACLs;
+  private final ApplicationACLsManager applicationsACLsManager;
-      RMAppManager rmAppManager) {
+      RMAppManager rmAppManager, ApplicationACLsManager applicationACLsManager) {
+    this.applicationsACLsManager = applicationACLsManager;
-      NetUtils.createSocketAddr(clientServiceBindAddress);
-
-    this.aclsManager = new ApplicationACLsManager(conf);
-    this.applicationACLs = aclsManager.constructApplicationACLs(conf);
-
+      NetUtils.createSocketAddr(clientServiceBindAddress,
+        YarnConfiguration.DEFAULT_RM_PORT,
+        YarnConfiguration.RM_ADDRESS);
+    
+    // Enable service authorization?
+    if (conf.getBoolean(
+        CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION, 
+        false)) {
+      refreshServiceAcls(conf, new RMPolicyProvider());
+    }
+    
-   * @param appAttemptId
-   * @param appACL
+   * @param operationPerformed
+   * @param applicationId
-  private boolean checkAccess(UserGroupInformation callerUGI, String owner, ApplicationACL appACL) {
-      if (!UserGroupInformation.isSecurityEnabled()) {
-        return true;
-      }
-      AccessControlList applicationACL = applicationACLs.get(appACL);
-      return aclsManager.checkAccess(callerUGI, appACL, owner, applicationACL);
+  private boolean checkAccess(UserGroupInformation callerUGI, String owner,
+      ApplicationAccessType operationPerformed, ApplicationId applicationId) {
+    return applicationsACLsManager.checkAccess(callerUGI, operationPerformed,
+        owner, applicationId);
-  public ApplicationId getNewApplicationId() {
+  ApplicationId getNewApplicationId() {
-    RMApp application = rmContext.getRMApps().get(applicationId);
-    ApplicationReport report = (application == null) ? null : application
-        .createAndGetApplicationReport();
+
+    UserGroupInformation callerUGI;
+    try {
+      callerUGI = UserGroupInformation.getCurrentUser();
+    } catch (IOException ie) {
+      LOG.info("Error getting UGI ", ie);
+      throw RPCUtil.getRemoteException(ie);
+    }
+
+    RMApp application = this.rmContext.getRMApps().get(applicationId);
+    if (application == null) {
+      throw RPCUtil.getRemoteException("Trying to get information for an "
+          + "absent application " + applicationId);
+    }
+
+    if (!checkAccess(callerUGI, application.getUser(),
+        ApplicationAccessType.VIEW_APP, applicationId)) {
+      throw RPCUtil.getRemoteException(new AccessControlException("User "
+          + callerUGI.getShortUserName() + " cannot perform operation "
+          + ApplicationAccessType.VIEW_APP.name() + " on " + applicationId));
+    }
+
+    ApplicationReport report = application.createAndGetApplicationReport();
-      
+
-      
+
-      rmAppManager.handle(new RMAppManagerSubmitEvent(submissionContext));
+      rmAppManager.handle(new RMAppManagerSubmitEvent(submissionContext, System
+          .currentTimeMillis()));
-    // TODO: What if null
+    if (application == null) {
+      RMAuditLogger.logFailure(callerUGI.getUserName(),
+          AuditConstants.KILL_APP_REQUEST, "UNKNOWN", "ClientRMService",
+          "Trying to kill an absent application", applicationId);
+      throw RPCUtil
+          .getRemoteException("Trying to kill an absent application "
+              + applicationId);
+    }
+
-        ApplicationACL.MODIFY_APP)) {
-      RMAuditLogger.logFailure(callerUGI.getShortUserName(), 
-          AuditConstants.KILL_APP_REQUEST, 
-          "User doesn't have MODIFY_APP permissions", "ClientRMService",
+        ApplicationAccessType.MODIFY_APP, applicationId)) {
+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),
+          AuditConstants.KILL_APP_REQUEST,
+          "User doesn't have permissions to "
+              + ApplicationAccessType.MODIFY_APP.toString(), "ClientRMService",
-          + ApplicationACL.MODIFY_APP.name() + " on " + applicationId));
+          + ApplicationAccessType.MODIFY_APP.name() + " on " + applicationId));
+    UserGroupInformation callerUGI;
+    try {
+      callerUGI = UserGroupInformation.getCurrentUser();
+    } catch (IOException ie) {
+      LOG.info("Error getting UGI ", ie);
+      throw RPCUtil.getRemoteException(ie);
+    }
+
-      reports.add(application.createAndGetApplicationReport());
+      // Only give out the applications viewable by the user as
+      // ApplicationReport has confidential information like client-token, ACLs
+      // etc. Web UI displays all applications though as we filter and print
+      // only public information there.
+      if (checkAccess(callerUGI, application.getUser(),
+          ApplicationAccessType.VIEW_APP, application.getApplicationId())) {
+        reports.add(application.createAndGetApplicationReport());
+      }
-    org.apache.hadoop.yarn.server.resourcemanager.scheduler.SchedulerNodeReport schedulerNodeReport = scheduler
-        .getNodeReport(rmNode.getNodeID());
-    report.setUsed(schedulerNodeReport.getUsedResource());
-    report.setNumContainers(schedulerNodeReport.getNumContainers());
+    
+    SchedulerNodeReport schedulerNodeReport = 
+        scheduler.getNodeReport(rmNode.getNodeID());
+    Resource used = Resources.none();
+    int numContainers = 0;
+    if (schedulerNodeReport != null) {
+      used = schedulerNodeReport.getUsedResource();
+      numContainers = schedulerNodeReport.getNumContainers();
+    } 
+    report.setUsed(used);
+    report.setNumContainers(numContainers);
+
+  void refreshServiceAcls(Configuration configuration, 
+      PolicyProvider policyProvider) {
+    this.server.refreshServiceAcl(configuration, policyProvider);
+  }
+  
-        this.server.close();
+        this.server.stop();
+  

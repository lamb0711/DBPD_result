HDFS-1623. High Availability Framework for HDFS NN. Contributed by Todd Lipcon, Aaron T. Myers, Eli Collins, Uma Maheswara Rao G, Bikas Saha, Suresh Srinivas, Jitendra Nath Pandey, Hari Mankude, Brandon Li, Sanjay Radia, Mingjie Lai, and Gregory Chanan


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296534 13f79535-47bb-0310-9956-ffa450edef68

-                            BlockInfo[] blocks, 
+                            boolean underConstruction,
-    if (blocks == null)
-      newNode = new INodeDirectory(permissions, modificationTime);
-    else if(blocks.length == 0 || blocks[blocks.length-1].getBlockUCState()
-        == BlockUCState.UNDER_CONSTRUCTION) {
+    if (underConstruction) {
-          permissions, blocks.length, replication,
+          permissions, replication,
-      newNode = new INodeFile(permissions, blocks.length, replication,
+      newNode = new INodeFile(permissions, 0, replication,
-    writeLock();
+
-      try {
-        newNode = addNode(path, newNode, UNKNOWN_DISK_SPACE);
-        if(newNode != null && blocks != null) {
-          int nrBlocks = blocks.length;
-          // Add file->block mapping
-          INodeFile newF = (INodeFile)newNode;
-          for (int i = 0; i < nrBlocks; i++) {
-            newF.setBlock(i, getBlockManager().addINode(blocks[i], newF));
-          }
-        }
-      } catch (IOException e) {
-        return null;
-      }
-      return newNode;
-    } finally {
-      writeUnlock();
+      newNode = addNode(path, newNode, UNKNOWN_DISK_SPACE);
+    } catch (IOException e) {
+      return null;
-
-  }
-
-  /**
-   * Update files in-memory data structures with new block information.
-   * @throws IOException 
-   */
-  void updateFile(INodeFile file,
-                  String path,
-                  BlockInfo[] blocks, 
-                  long mtime,
-                  long atime) throws IOException {
-
-    // Update the salient file attributes.
-    file.setAccessTime(atime);
-    file.setModificationTimeForce(mtime);
-
-    // Update its block list
-    BlockInfo[] oldBlocks = file.getBlocks();
-
-    // Are we only updating the last block's gen stamp.
-    boolean isGenStampUpdate = oldBlocks.length == blocks.length;
-
-    // First, update blocks in common
-    BlockInfo oldBlock = null;
-    for (int i = 0; i < oldBlocks.length && i < blocks.length; i++) {
-      oldBlock = oldBlocks[i];
-      Block newBlock = blocks[i];
-
-      boolean isLastBlock = i == oldBlocks.length - 1;
-      if (oldBlock.getBlockId() != newBlock.getBlockId() ||
-          (oldBlock.getGenerationStamp() != newBlock.getGenerationStamp() && 
-              !(isGenStampUpdate && isLastBlock))) {
-        throw new IOException("Mismatched block IDs or generation stamps, " + 
-            "attempting to replace block " + oldBlock + " with " + newBlock +
-            " as block # " + i + "/" + blocks.length + " of " + path);
-      }
-
-      oldBlock.setNumBytes(newBlock.getNumBytes());
-      oldBlock.setGenerationStamp(newBlock.getGenerationStamp());
-    }
-
-    if (blocks.length < oldBlocks.length) {
-      // We're removing a block from the file, e.g. abandonBlock(...)
-      if (!file.isUnderConstruction()) {
-        throw new IOException("Trying to remove a block from file " +
-            path + " which is not under construction.");
-      }
-      if (blocks.length != oldBlocks.length - 1) {
-        throw new IOException("Trying to remove more than one block from file "
-            + path);
-      }
-      unprotectedRemoveBlock(path,
-          (INodeFileUnderConstruction)file, oldBlocks[oldBlocks.length - 1]);
-    } else if (blocks.length > oldBlocks.length) {
-      // We're adding blocks
-      // First complete last old Block
-      getBlockManager().completeBlock(file, oldBlocks.length-1, true);
-      // Add the new blocks
-      for (int i = oldBlocks.length; i < blocks.length; i++) {
-        // addBlock();
-        BlockInfo newBI = blocks[i];
-        getBlockManager().addINode(newBI, file);
-        file.addBlock(newBI);
-      }
-    }
+    return newNode;
-      fsImage.getEditLog().logOpenFile(path, file);
+      fsImage.getEditLog().logUpdateBlocks(path, file);
-
+  
-   * Remove a block to the file.
+   * Remove a block from the file.
-
+  

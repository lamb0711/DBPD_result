YARN-6634. [API] Refactor ResourceManager WebServices to make API explicit. (Giovanni Matteo Fumarola via curino)

-@Path("/ws/v1/cluster")
-public class RMWebServices extends WebServices {
+@Path(RMWSConsts.RM_WEB_SERVICE_PATH)
+public class RMWebServices extends WebServices implements RMWebServiceProtocol {
+
-  private static final String EMPTY = "";
-  private static final String ANY = "*";
+
-  private static RecordFactory recordFactory = RecordFactoryProvider
-      .getRecordFactory(null);
+  private static RecordFactory recordFactory =
+      RecordFactoryProvider.getRecordFactory(null);
+  // -------Default values of QueryParams for RMWebServiceProtocol--------
+
+  public static final String DEFAULT_QUEUE = "default";
+  public static final String DEFAULT_RESERVATION_ID = "";
+  public static final String DEFAULT_START_TIME = "0";
+  public static final String DEFAULT_END_TIME = "-1";
+  public static final String DEFAULT_INCLUDE_RESOURCE = "false";
+
-    String forwardedFor = hsr.getHeader("X-Forwarded-For");
+    String forwardedFor = hsr.getHeader(RMWSConsts.FORWARDED_FOR);
-              ApplicationAccessType.VIEW_APP, app.getUser(),
-              app.getApplicationId()) ||
-            this.rm.getQueueACLsManager().checkAccess(callerUGI,
+            ApplicationAccessType.VIEW_APP, app.getUser(),
+            app.getApplicationId())
+            || this.rm.getQueueACLsManager().checkAccess(callerUGI,
-    //clear content type
+    // clear content type
+  @Override
-  @Path("/info")
+  @Path(RMWSConsts.INFO)
+  @Override
-  @Path("/metrics")
+  @Path(RMWSConsts.METRICS)
+  @Override
-  @Path("/scheduler")
+  @Path(RMWSConsts.SCHEDULER)
+  @Override
-      sinfo =
-          new CapacitySchedulerInfo(root, cs);
+      sinfo = new CapacitySchedulerInfo(root, cs);
-  @Path("/scheduler/logs")
+  @Path(RMWSConsts.SCHEDULER_LOGS)
-  public String dumpSchedulerLogs(@FormParam("time") String time,
+  @Override
+  public String dumpSchedulerLogs(@FormParam(RMWSConsts.TIME) String time,
-  /**
-   * Returns all nodes in the cluster. If the states param is given, returns
-   * all nodes that are in the comma-separated list of states.
-   */
-  @Path("/nodes")
+  @Path(RMWSConsts.NODES)
-  public NodesInfo getNodes(@QueryParam("states") String states) {
+  @Override
+  public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {
-    
+
-        acceptedStates.add(
-            NodeState.valueOf(StringUtils.toUpperCase(stateStr)));
+        acceptedStates
+            .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));
-    
-    Collection<RMNode> rmNodes = RMServerUtils.queryRMNodes(
-        this.rm.getRMContext(), acceptedStates);
+
+    Collection<RMNode> rmNodes =
+        RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);
-      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)
+      if (EnumSet
+          .of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)
-        nodeInfo.setNodeHTTPAddress(EMPTY);
+        nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);
-    
+
-  @Path("/nodes/{nodeId}")
+  @Path(RMWSConsts.NODES_NODEID)
-  public NodeInfo getNode(@PathParam("nodeId") String nodeId) {
+  @Override
+  public NodeInfo getNode(@PathParam(RMWSConsts.NODEID) String nodeId) {
-      nodeInfo.setNodeHTTPAddress(EMPTY);
+      nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);
-  @Path("/apps")
+  @Path(RMWSConsts.APPS)
+  @Override
-      @QueryParam("state") String stateQuery,
-      @QueryParam("states") Set<String> statesQuery,
-      @QueryParam("finalStatus") String finalStatusQuery,
-      @QueryParam("user") String userQuery,
-      @QueryParam("queue") String queueQuery,
-      @QueryParam("limit") String count,
-      @QueryParam("startedTimeBegin") String startedBegin,
-      @QueryParam("startedTimeEnd") String startedEnd,
-      @QueryParam("finishedTimeBegin") String finishBegin,
-      @QueryParam("finishedTimeEnd") String finishEnd,
-      @QueryParam("applicationTypes") Set<String> applicationTypes,
-      @QueryParam("applicationTags") Set<String> applicationTags) {
+      @QueryParam(RMWSConsts.STATE) String stateQuery,
+      @QueryParam(RMWSConsts.STATES) Set<String> statesQuery,
+      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,
+      @QueryParam(RMWSConsts.USER) String userQuery,
+      @QueryParam(RMWSConsts.QUEUE) String queueQuery,
+      @QueryParam(RMWSConsts.LIMIT) String count,
+      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,
+      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,
+      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,
+      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,
+      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set<String> applicationTypes,
+      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set<String> applicationTags) {
-        throw new BadRequestException("startedTimeBegin must be greater than 0");
+        throw new BadRequestException(
+            "startedTimeBegin must be greater than 0");
-      appReports = rm.getClientRMService()
-          .getApplications(request, false).getApplicationList();
+      appReports = rm.getClientRMService().getApplications(request, false)
+          .getApplicationList();
-      AppInfo app = new AppInfo(rm, rmapp,
-          hasAccess(rmapp, hsr), WebAppUtils.getHttpSchemePrefix(conf));
+      AppInfo app = new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),
+          WebAppUtils.getHttpSchemePrefix(conf));
-  @Path("/scheduler/activities")
+  @Path(RMWSConsts.SCHEDULER_ACTIVITIES)
+  @Override
-      @QueryParam("nodeId") String nodeId) {
+      @QueryParam(RMWSConsts.NODEID) String nodeId) {
-            if ((portName.equals("") && node.getRMNode().getHostName().equals(
-                hostName)) || (!portName.equals("") && node.getRMNode()
-                .getHostName().equals(hostName) && String.valueOf(
-                node.getRMNode().getCommandPort()).equals(portName))) {
+            if ((portName.equals("")
+                && node.getRMNode().getHostName().equals(hostName))
+                || (!portName.equals("")
+                    && node.getRMNode().getHostName().equals(hostName)
+                    && String.valueOf(node.getRMNode().getCommandPort())
+                        .equals(portName))) {
-  @Path("/scheduler/app-activities")
+  @Path(RMWSConsts.SCHEDULER_APP_ACTIVITIES)
+  @Override
-      @QueryParam("appId") String appId, @QueryParam("maxTime") String time) {
+      @QueryParam(RMWSConsts.APP_ID) String appId,
+      @QueryParam(RMWSConsts.MAX_TIME) String time) {
-      if(appId == null) {
+      if (appId == null) {
-  @Path("/appstatistics")
+  @Path(RMWSConsts.APP_STATISTICS)
+  @Override
-      @QueryParam("states") Set<String> stateQueries,
-      @QueryParam("applicationTypes") Set<String> typeQueries) {
+      @QueryParam(RMWSConsts.STATES) Set<String> stateQueries,
+      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set<String> typeQueries) {
-      types.add(ANY);
+      types.add(RMWSConsts.ANY);
-      if (states.contains(
-          StringUtils.toLowerCase(state.toString()))) {
-        if (types.contains(ANY)) {
-          countApp(scoreboard, state, ANY);
+      if (states.contains(StringUtils.toLowerCase(state.toString()))) {
+        if (types.contains(RMWSConsts.ANY)) {
+          countApp(scoreboard, state, RMWSConsts.ANY);
-    for (Map.Entry<YarnApplicationState, Map<String, Long>> partScoreboard
-        : scoreboard.entrySet()) {
-      for (Map.Entry<String, Long> statEntry
-          : partScoreboard.getValue().entrySet()) {
+    for (Map.Entry<YarnApplicationState, Map<String, Long>> partScoreboard : scoreboard
+        .entrySet()) {
+      for (Map.Entry<String, Long> statEntry : partScoreboard.getValue()
+          .entrySet()) {
-     Set<String> states, Set<String> types) {
-    Map<YarnApplicationState, Map<String, Long>> scoreboard
-        = new HashMap<YarnApplicationState, Map<String, Long>>();
+      Set<String> states, Set<String> types) {
+    Map<YarnApplicationState, Map<String, Long>> scoreboard =
+        new HashMap<YarnApplicationState, Map<String, Long>>();
-  @Path("/apps/{appid}")
+  @Path(RMWSConsts.APPS_APPID)
+  @Override
-      @PathParam("appid") String appId) {
+      @PathParam(RMWSConsts.APPID) String appId) {
-  @Path("/apps/{appid}/appattempts")
+  @Path(RMWSConsts.APPS_APPID_APPATTEMPTS)
+  @Override
-      @PathParam("appid") String appId) {
+      @PathParam(RMWSConsts.APPID) String appId) {
-  @Path("/apps/{appid}/appattempts/{appattemptid}")
+  @Path(RMWSConsts.APPS_APPID_APPATTEMPTS_APPATTEMPTID)
-  public org.apache.hadoop.yarn.server.webapp.dao.AppAttemptInfo getAppAttempt(@Context HttpServletRequest req,
-      @Context HttpServletResponse res, @PathParam("appid") String appId,
-      @PathParam("appattemptid") String appAttemptId) {
+  public org.apache.hadoop.yarn.server.webapp.dao.AppAttemptInfo getAppAttempt(
+      @Context HttpServletRequest req, @Context HttpServletResponse res,
+      @PathParam(RMWSConsts.APPID) String appId,
+      @PathParam(RMWSConsts.APPATTEMPTID) String appAttemptId) {
-  @Path("/apps/{appid}/appattempts/{appattemptid}/containers")
+  @Path(RMWSConsts.APPS_APPID_APPATTEMPTS_APPATTEMPTID_CONTAINERS)
-      @Context HttpServletResponse res, @PathParam("appid") String appId,
-      @PathParam("appattemptid") String appAttemptId) {
+      @Context HttpServletResponse res,
+      @PathParam(RMWSConsts.APPID) String appId,
+      @PathParam(RMWSConsts.APPATTEMPTID) String appAttemptId) {
-      @Context HttpServletResponse res, @PathParam("appid") String appId,
-      @PathParam("appattemptid") String appAttemptId,
+      @Context HttpServletResponse res,
+      @PathParam(RMWSConsts.APPID) String appId,
+      @PathParam(RMWSConsts.APPATTEMPTID) String appAttemptId,
+  @Override
-      @PathParam("appid") String appId) throws AuthorizationException {
+      @PathParam(RMWSConsts.APPID) String appId) throws AuthorizationException {
-        "UNKNOWN", "RMWebService",
-        "Trying to get state of an absent application " + appId);
+          "UNKNOWN", "RMWebService",
+          "Trying to get state of an absent application " + appId);
-  @Path("/apps/{appid}/state")
+  @Path(RMWSConsts.APPS_APPID_STATE)
+  @Override
-      @Context HttpServletRequest hsr, @PathParam("appid") String appId)
-      throws AuthorizationException, YarnException, InterruptedException,
-      IOException {
+      @Context HttpServletRequest hsr,
+      @PathParam(RMWSConsts.APPID) String appId) throws AuthorizationException,
+      YarnException, InterruptedException, IOException {
-        "UNKNOWN", "RMWebService", "Trying to kill an absent application "
-            + appId);
+          "UNKNOWN", "RMWebService",
+          "Trying to kill an absent application " + appId);
-      if (targetState.getState().equals(YarnApplicationState.KILLED.toString())) {
+      if (targetState.getState()
+          .equals(YarnApplicationState.KILLED.toString())) {
-      throw new BadRequestException("Only '"
-          + YarnApplicationState.KILLED.toString()
-          + "' is allowed as a target state.");
+      throw new BadRequestException(
+          "Only '" + YarnApplicationState.KILLED.toString()
+              + "' is allowed as a target state.");
-  
+
-  @Path("/get-node-to-labels")
+  @Path(RMWSConsts.GET_NODE_TO_LABELS)
+  @Override
-    Map<NodeId, Set<NodeLabel>> nodeIdToLabels = rm.getRMContext()
-        .getNodeLabelManager().getNodeLabelsInfo();
+    Map<NodeId, Set<NodeLabel>> nodeIdToLabels =
+        rm.getRMContext().getNodeLabelManager().getNodeLabelsInfo();
-  @Path("/label-mappings")
+  @Path(RMWSConsts.LABEL_MAPPINGS)
+  @Override
-      @QueryParam("labels") Set<String> labels) throws IOException {
+      @QueryParam(RMWSConsts.LABELS) Set<String> labels) throws IOException {
-      ltsMap.put(new NodeLabelInfo(entry.getKey()), new NodeIDsInfo(
-          nodeIdStrList));
+      ltsMap.put(new NodeLabelInfo(entry.getKey()),
+          new NodeIDsInfo(nodeIdStrList));
-  @Path("/replace-node-to-labels")
+  @Path(RMWSConsts.REPLACE_NODE_TO_LABELS)
-  public Response replaceLabelsOnNodes(final NodeToLabelsEntryList newNodeToLabels,
+  @Override
+  public Response replaceLabelsOnNodes(
+      final NodeToLabelsEntryList newNodeToLabels,
-  @Path("/nodes/{nodeId}/replace-labels")
+  @Path(RMWSConsts.NODES_NODEID_REPLACE_LABELS)
+  @Override
-    NodeLabelsUtils.verifyCentralizedNodeLabelConfEnabled(
-        "replaceLabelsOnNode", isCentralizedNodeLabelConfiguration);
+    NodeLabelsUtils.verifyCentralizedNodeLabelConfEnabled("replaceLabelsOnNode",
+        isCentralizedNodeLabelConfiguration);
-      String msg =
-          "Unable to obtain user name, user not authenticated for"
-              + " post to ..." + operation;
+      String msg = "Unable to obtain user name, user not authenticated for"
+          + " post to ..." + operation;
-      String msg =
-          "User " + callerUGI.getShortUserName() + " not authorized"
-              + " for post to ..." + operation;
+      String msg = "User " + callerUGI.getShortUserName() + " not authorized"
+          + " for post to ..." + operation;
-  @Path("/get-node-labels")
+  @Path(RMWSConsts.GET_NODE_LABELS)
-  public NodeLabelsInfo getClusterNodeLabels(@Context HttpServletRequest hsr) 
-    throws IOException {
+  @Override
+  public NodeLabelsInfo getClusterNodeLabels(@Context HttpServletRequest hsr)
+      throws IOException {
-    List<NodeLabel> nodeLabels = rm.getRMContext().getNodeLabelManager()
-        .getClusterNodeLabels();
+    List<NodeLabel> nodeLabels =
+        rm.getRMContext().getNodeLabelManager().getClusterNodeLabels();
-  
+
-  @Path("/add-node-labels")
+  @Path(RMWSConsts.ADD_NODE_LABELS)
+  @Override
-      @Context HttpServletRequest hsr)
-      throws Exception {
+      @Context HttpServletRequest hsr) throws Exception {
-    
+
-        + " post to .../add-node-labels";
+          + " post to .../add-node-labels";
-        + " for post to .../add-node-labels ";
+          + " for post to .../add-node-labels ";
-    
+
-            
+
-  
+
-  @Path("/remove-node-labels")
+  @Path(RMWSConsts.REMOVE_NODE_LABELS)
+  @Override
-      @QueryParam("labels") Set<String> oldNodeLabels,
+      @QueryParam(RMWSConsts.LABELS) Set<String> oldNodeLabels,
-  
+
-  @Path("/nodes/{nodeId}/get-labels")
+  @Path(RMWSConsts.NODES_NODEID_GETLABELS)
+  @Override
-      @PathParam("nodeId") String nodeId) throws IOException {
+      @PathParam(RMWSConsts.NODEID) String nodeId) throws IOException {
-    List<NodeLabel> labels = new ArrayList<NodeLabel>(rm.getRMContext()
-        .getNodeLabelManager().getLabelsInfoByNode(nid));
+    List<NodeLabel> labels = new ArrayList<NodeLabel>(
+        rm.getRMContext().getNodeLabelManager().getLabelsInfoByNode(nid));
-      resp =
-          callerUGI
-            .doAs(new PrivilegedExceptionAction<KillApplicationResponse>() {
-              @Override
-              public KillApplicationResponse run() throws IOException,
-                  YarnException {
-                KillApplicationRequest req =
-                    KillApplicationRequest.newInstance(appid);
-                  if (diagnostic != null) {
-                    req.setDiagnostics(diagnostic);
-                  }
-                return rm.getClientRMService().forceKillApplication(req);
+      resp = callerUGI
+          .doAs(new PrivilegedExceptionAction<KillApplicationResponse>() {
+            @Override
+            public KillApplicationResponse run()
+                throws IOException, YarnException {
+              KillApplicationRequest req =
+                  KillApplicationRequest.newInstance(appid);
+              if (diagnostic != null) {
+                req.setDiagnostics(diagnostic);
-            });
+              return rm.getClientRMService().forceKillApplication(req);
+            }
+          });
-          String msg =
-              "Unauthorized attempt to kill appid " + appId
-                  + " by remote user " + userName;
+          String msg = "Unauthorized attempt to kill appid " + appId
+              + " by remote user " + userName;
-        "RMWebService", app.getApplicationId());
+          "RMWebService", app.getApplicationId());
-        .header(HttpHeaders.LOCATION, hsr.getRequestURL()).build();
+          .header(HttpHeaders.LOCATION, hsr.getRequestURL()).build();
-  @Path("/apps/{appid}/priority")
+  @Path(RMWSConsts.APPS_APPID_PRIORITY)
+  @Override
-      @PathParam("appid") String appId) throws AuthorizationException {
+      @PathParam(RMWSConsts.APPID) String appId) throws AuthorizationException {
-    ret.setPriority(
-        app.getApplicationPriority().getPriority());
+    ret.setPriority(app.getApplicationPriority().getPriority());
-  @Path("/apps/{appid}/priority")
+  @Path(RMWSConsts.APPS_APPID_PRIORITY)
+  @Override
-      @Context HttpServletRequest hsr, @PathParam("appid") String appId)
-      throws AuthorizationException, YarnException, InterruptedException,
-          IOException {
+      @Context HttpServletRequest hsr,
+      @PathParam(RMWSConsts.APPID) String appId) throws AuthorizationException,
+      YarnException, InterruptedException, IOException {
-          throws IOException, InterruptedException {
+      throws IOException, InterruptedException {
-    AppPriority ret = new AppPriority(
-        app.getApplicationPriority().getPriority());
+    AppPriority ret =
+        new AppPriority(app.getApplicationPriority().getPriority());
-  @Path("/apps/{appid}/queue")
+  @Path(RMWSConsts.APPS_APPID_QUEUE)
+  @Override
-      @PathParam("appid") String appId) throws AuthorizationException {
+      @PathParam(RMWSConsts.APPID) String appId) throws AuthorizationException {
-        "UNKNOWN", "RMWebService",
-        "Trying to get queue of an absent application " + appId);
+          "UNKNOWN", "RMWebService",
+          "Trying to get queue of an absent application " + appId);
-  @Path("/apps/{appid}/queue")
+  @Path(RMWSConsts.APPS_APPID_QUEUE)
+  @Override
-      @Context HttpServletRequest hsr, @PathParam("appid") String appId)
-      throws AuthorizationException, YarnException, InterruptedException,
-      IOException {
+      @Context HttpServletRequest hsr,
+      @PathParam(RMWSConsts.APPID) String appId) throws AuthorizationException,
+      YarnException, InterruptedException, IOException {
-        "UNKNOWN", "RMWebService", "Trying to move an absent application "
-            + appId);
+          "UNKNOWN", "RMWebService",
+          "Trying to move an absent application " + appId);
-      callerUGI
-        .doAs(new PrivilegedExceptionAction<Void>() {
-          @Override
-          public Void run() throws IOException,
-              YarnException {
-            MoveApplicationAcrossQueuesRequest req =
-                MoveApplicationAcrossQueuesRequest.newInstance(appid,
+      callerUGI.doAs(new PrivilegedExceptionAction<Void>() {
+        @Override
+        public Void run() throws IOException, YarnException {
+          MoveApplicationAcrossQueuesRequest req =
+              MoveApplicationAcrossQueuesRequest.newInstance(appid,
-            rm.getClientRMService().moveApplicationAcrossQueues(req);
-            return null;
-          }
-        });
+          rm.getClientRMService().moveApplicationAcrossQueues(req);
+          return null;
+        }
+      });
-          String msg =
-              "Unauthorized attempt to move appid " + appId
-                  + " by remote user " + userName;
+          String msg = "Unauthorized attempt to move appid " + appId
+              + " by remote user " + userName;
-            .build();
+              .build();
-          CommonConfigurationKeys.DEFAULT_HADOOP_HTTP_STATIC_USER);
+            CommonConfigurationKeys.DEFAULT_HADOOP_HTTP_STATIC_USER);
-  /**
-   * Generates a new ApplicationId which is then sent to the client
-   * 
-   * @param hsr
-   *          the servlet request
-   * @return Response containing the app id and the maximum resource
-   *         capabilities
-   * @throws AuthorizationException
-   * @throws IOException
-   * @throws InterruptedException
-   */
-  @Path("/apps/new-application")
+  @Path(RMWSConsts.APPS_NEW_APPLICATION)
+  @Override
-      throw new AuthorizationException("Unable to obtain user name, "
-          + "user not authenticated");
+      throw new AuthorizationException(
+          "Unable to obtain user name, " + "user not authenticated");
-  /**
-   * Function to submit an app to the RM
-   * 
-   * @param newApp
-   *          structure containing information to construct the
-   *          ApplicationSubmissionContext
-   * @param hsr
-   *          the servlet request
-   * @return Response containing the status code
-   * @throws AuthorizationException
-   * @throws IOException
-   * @throws InterruptedException
-   */
-  @Path("/apps")
+  @Path(RMWSConsts.APPS)
+  @Override
-      @Context HttpServletRequest hsr) throws AuthorizationException,
-      IOException, InterruptedException {
+      @Context HttpServletRequest hsr)
+      throws AuthorizationException, IOException, InterruptedException {
-      throw new AuthorizationException("Unable to obtain user name, "
-          + "user not authenticated");
+      throw new AuthorizationException(
+          "Unable to obtain user name, " + "user not authenticated");
-        .doAs(new PrivilegedExceptionAction<SubmitApplicationResponse>() {
-          @Override
-          public SubmitApplicationResponse run() throws IOException,
-              YarnException {
-            return rm.getClientRMService().submitApplication(req);
-          }
-        });
+          .doAs(new PrivilegedExceptionAction<SubmitApplicationResponse>() {
+            @Override
+            public SubmitApplicationResponse run()
+                throws IOException, YarnException {
+              return rm.getClientRMService().submitApplication(req);
+            }
+          });
-      .build();
+        .build();
-          new ResourceInfo(resp.getMaximumResourceCapability()));
+            new ResourceInfo(resp.getMaximumResourceCapability()));
-   * @param newApp
-   *          the information provided by the user
+   * @param newApp the information provided by the user
-    ApplicationSubmissionContext appContext =
-        ApplicationSubmissionContext.newInstance(appid,
-          newApp.getApplicationName(), newApp.getQueue(),
-          Priority.newInstance(newApp.getPriority()),
-          createContainerLaunchContext(newApp), newApp.getUnmanagedAM(),
-          newApp.getCancelTokensWhenComplete(), newApp.getMaxAppAttempts(),
-          createAppSubmissionContextResource(newApp),
-          newApp.getApplicationType(),
-          newApp.getKeepContainersAcrossApplicationAttempts(),
-          newApp.getAppNodeLabelExpression(),
-          newApp.getAMContainerNodeLabelExpression());
+    ApplicationSubmissionContext appContext = ApplicationSubmissionContext
+        .newInstance(appid, newApp.getApplicationName(), newApp.getQueue(),
+            Priority.newInstance(newApp.getPriority()),
+            createContainerLaunchContext(newApp), newApp.getUnmanagedAM(),
+            newApp.getCancelTokensWhenComplete(), newApp.getMaxAppAttempts(),
+            createAppSubmissionContextResource(newApp),
+            newApp.getApplicationType(),
+            newApp.getKeepContainersAcrossApplicationAttempts(),
+            newApp.getAppNodeLabelExpression(),
+            newApp.getAMContainerNodeLabelExpression());
-      appContext.setLogAggregationContext(createLogAggregationContext(
-          newApp.getLogAggregationContextInfo()));
+      appContext.setLogAggregationContext(
+          createLogAggregationContext(newApp.getLogAggregationContextInfo()));
-      ReservationId reservationId = ReservationId.parseReservationId(
-          reservationIdStr);
+      ReservationId reservationId =
+          ReservationId.parseReservationId(reservationIdStr);
-      YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES,
-      YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES)) {
+        YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES,
+        YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES)) {
-      YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,
-      YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB)) {
+        YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,
+        YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB)) {
-    Resource r =
-        Resource.newInstance(newApp.getResource().getMemorySize(), newApp
-          .getResource().getvCores());
+    Resource r = Resource.newInstance(newApp.getResource().getMemorySize(),
+        newApp.getResource().getvCores());
-   * @param newApp
-   *          the information provided by the user
+   * @param newApp the information provided by the user
-      ApplicationSubmissionContextInfo newApp) throws BadRequestException,
-      IOException {
+      ApplicationSubmissionContextInfo newApp)
+      throws BadRequestException, IOException {
-      .getContainerLaunchContextInfo().getAuxillaryServiceData().entrySet()) {
+        .getContainerLaunchContextInfo().getAuxillaryServiceData().entrySet()) {
-      .getContainerLaunchContextInfo().getResources().entrySet()) {
+        .getContainerLaunchContextInfo().getResources().entrySet()) {
-      LocalResource lr =
-          LocalResource.newInstance(
-              URL.fromURI(l.getUrl()), l.getType(),
-            l.getVisibility(), l.getSize(), l.getTimestamp());
+      LocalResource lr = LocalResource.newInstance(URL.fromURI(l.getUrl()),
+          l.getType(), l.getVisibility(), l.getSize(), l.getTimestamp());
-    Credentials cs =
-        createCredentials(newApp.getContainerLaunchContextInfo()
-          .getCredentials());
+    Credentials cs = createCredentials(
+        newApp.getContainerLaunchContextInfo().getCredentials());
-    ContainerLaunchContext ctx =
-        ContainerLaunchContext.newInstance(hlr, newApp
-          .getContainerLaunchContextInfo().getEnvironment(), newApp
-          .getContainerLaunchContextInfo().getCommands(), hmap, tokens, newApp
-          .getContainerLaunchContextInfo().getAcls());
+    ContainerLaunchContext ctx = ContainerLaunchContext.newInstance(hlr,
+        newApp.getContainerLaunchContextInfo().getEnvironment(),
+        newApp.getContainerLaunchContextInfo().getCommands(), hmap, tokens,
+        newApp.getContainerLaunchContextInfo().getAcls());
-   * @param credentials
-   *          the CredentialsInfo provided by the user.
+   * @param credentials the CredentialsInfo provided by the user.
-      for (Map.Entry<String, String> entry : credentials.getTokens().entrySet()) {
+      for (Map.Entry<String, String> entry : credentials.getTokens()
+          .entrySet()) {
-      for (Map.Entry<String, String> entry : credentials.getSecrets().entrySet()) {
+      for (Map.Entry<String, String> entry : credentials.getSecrets()
+          .entrySet()) {
-        "Could not parse credentials data; exception message = "
-            + ie.getMessage());
+          "Could not parse credentials data; exception message = "
+              + ie.getMessage());
-      String msg =
-          "Delegation token operations can only be carried out on a "
-              + "Kerberos authenticated channel. Expected auth type is "
-              + KerberosAuthenticationHandler.TYPE + ", got type " + authType;
+      String msg = "Delegation token operations can only be carried out on a "
+          + "Kerberos authenticated channel. Expected auth type is "
+          + KerberosAuthenticationHandler.TYPE + ", got type " + authType;
-    if (hsr
-      .getAttribute(DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE) != null) {
+    if (hsr.getAttribute(
+        DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE) != null) {
-  @Path("/delegation-token")
+  @Path(RMWSConsts.DELEGATION_TOKEN)
+  @Override
-  @Path("/delegation-token/expiration")
+  @Path(RMWSConsts.DELEGATION_TOKEN_EXPIRATION)
-  public Response
-      postDelegationTokenExpiration(@Context HttpServletRequest hsr)
-          throws AuthorizationException, IOException, InterruptedException,
-          Exception {
+  @Override
+  public Response postDelegationTokenExpiration(@Context HttpServletRequest hsr)
+      throws AuthorizationException, IOException, InterruptedException,
+      Exception {
-      resp =
-          callerUGI
-            .doAs(new PrivilegedExceptionAction<GetDelegationTokenResponse>() {
-              @Override
-              public GetDelegationTokenResponse run() throws IOException,
-                  YarnException {
-                GetDelegationTokenRequest createReq =
-                    GetDelegationTokenRequest.newInstance(renewer);
-                return rm.getClientRMService().getDelegationToken(createReq);
-              }
-            });
+      resp = callerUGI
+          .doAs(new PrivilegedExceptionAction<GetDelegationTokenResponse>() {
+            @Override
+            public GetDelegationTokenResponse run()
+                throws IOException, YarnException {
+              GetDelegationTokenRequest createReq =
+                  GetDelegationTokenRequest.newInstance(renewer);
+              return rm.getClientRMService().getDelegationToken(createReq);
+            }
+          });
-        new Token<RMDelegationTokenIdentifier>(resp.getRMDelegationToken()
-          .getIdentifier().array(), resp.getRMDelegationToken().getPassword()
-          .array(), new Text(resp.getRMDelegationToken().getKind()), new Text(
-          resp.getRMDelegationToken().getService()));
+        new Token<RMDelegationTokenIdentifier>(
+            resp.getRMDelegationToken().getIdentifier().array(),
+            resp.getRMDelegationToken().getPassword().array(),
+            new Text(resp.getRMDelegationToken().getKind()),
+            new Text(resp.getRMDelegationToken().getService()));
-    long currentExpiration =
-        rm.getRMContext().getRMDelegationTokenSecretManager()
-          .getRenewDate(identifier);
-    DelegationToken respToken =
-        new DelegationToken(tk.encodeToUrlString(), renewer, identifier
-          .getOwner().toString(), tk.getKind().toString(), currentExpiration,
-          identifier.getMaxDate());
+    long currentExpiration = rm.getRMContext()
+        .getRMDelegationTokenSecretManager().getRenewDate(identifier);
+    DelegationToken respToken = new DelegationToken(tk.encodeToUrlString(),
+        renewer, identifier.getOwner().toString(), tk.getKind().toString(),
+        currentExpiration, identifier.getMaxDate());
-    org.apache.hadoop.yarn.api.records.Token dToken =
-        BuilderUtils.newDelegationToken(token.getIdentifier(), token.getKind()
-          .toString(), token.getPassword(), token.getService().toString());
+    org.apache.hadoop.yarn.api.records.Token dToken = BuilderUtils
+        .newDelegationToken(token.getIdentifier(), token.getKind().toString(),
+            token.getPassword(), token.getService().toString());
-      resp =
-          callerUGI
-            .doAs(new PrivilegedExceptionAction<RenewDelegationTokenResponse>() {
-              @Override
-              public RenewDelegationTokenResponse run() throws IOException,
-                  YarnException {
-                return rm.getClientRMService().renewDelegationToken(req);
-              }
-            });
+      resp = callerUGI
+          .doAs(new PrivilegedExceptionAction<RenewDelegationTokenResponse>() {
+            @Override
+            public RenewDelegationTokenResponse run() throws YarnException {
+              return rm.getClientRMService().renewDelegationToken(req);
+            }
+          });
-        } else if (ue.getCause().getCause() instanceof org.apache.hadoop.security.AccessControlException) {
+        } else if (ue.getCause()
+            .getCause() instanceof org.apache.hadoop.security.AccessControlException) {
-            .entity(ue.getCause().getCause().getMessage()).build();
+              .entity(ue.getCause().getCause().getMessage()).build();
-  @Path("/delegation-token")
+  @Path(RMWSConsts.DELEGATION_TOKEN)
+  @Override
-    org.apache.hadoop.yarn.api.records.Token dToken =
-        BuilderUtils.newDelegationToken(token.getIdentifier(), token.getKind()
-          .toString(), token.getPassword(), token.getService().toString());
+    org.apache.hadoop.yarn.api.records.Token dToken = BuilderUtils
+        .newDelegationToken(token.getIdentifier(), token.getKind().toString(),
+            token.getPassword(), token.getService().toString());
-        .doAs(new PrivilegedExceptionAction<CancelDelegationTokenResponse>() {
-          @Override
-          public CancelDelegationTokenResponse run() throws IOException,
-              YarnException {
-            return rm.getClientRMService().cancelDelegationToken(req);
-          }
-        });
+          .doAs(new PrivilegedExceptionAction<CancelDelegationTokenResponse>() {
+            @Override
+            public CancelDelegationTokenResponse run()
+                throws IOException, YarnException {
+              return rm.getClientRMService().cancelDelegationToken(req);
+            }
+          });
-        } else if (ue.getCause().getCause() instanceof org.apache.hadoop.security.AccessControlException) {
+        } else if (ue.getCause()
+            .getCause() instanceof org.apache.hadoop.security.AccessControlException) {
-            .entity(ue.getCause().getCause().getMessage()).build();
+              .entity(ue.getCause().getCause().getMessage()).build();
-      String msg =
-          "Header '" + DELEGATION_TOKEN_HEADER
-              + "' containing encoded token not found";
+      String msg = "Header '" + DELEGATION_TOKEN_HEADER
+          + "' containing encoded token not found";
-  /**
-   * Generates a new ReservationId which is then sent to the client.
-   *
-   * @param hsr the servlet request
-   * @return Response containing the app id and the maximum resource
-   *         capabilities
-   * @throws AuthorizationException if the user is not authorized
-   *         to invoke this method.
-   * @throws IOException if creation fails.
-   * @throws InterruptedException if interrupted.
-   */
-  @Path("/reservation/new-reservation")
+  @Path(RMWSConsts.RESERVATION_NEW)
+  @Override
-    throws AuthorizationException, IOException, InterruptedException {
+      throws AuthorizationException, IOException, InterruptedException {
-      throw new AuthorizationException("Unable to obtain user name, "
-        + "user not authenticated");
+      throw new AuthorizationException(
+          "Unable to obtain user name, " + "user not authenticated");
-  /**
-   * Function to submit a Reservation to the RM.
-   *
-   * @param resContext provides information to construct the
-   *          ReservationSubmissionRequest
-   * @param hsr the servlet request
-   * @return Response containing the status code
-   * @throws AuthorizationException
-   * @throws IOException
-   * @throws InterruptedException
-   */
-  @Path("/reservation/submit")
+  @Path(RMWSConsts.RESERVATION_SUBMIT)
-  public Response submitReservation(
-      ReservationSubmissionRequestInfo resContext,
-      @Context HttpServletRequest hsr) throws AuthorizationException,
-      IOException, InterruptedException {
+  @Override
+  public Response submitReservation(ReservationSubmissionRequestInfo resContext,
+      @Context HttpServletRequest hsr)
+      throws AuthorizationException, IOException, InterruptedException {
-      throw new AuthorizationException("Unable to obtain user name, "
-          + "user not authenticated");
+      throw new AuthorizationException(
+          "Unable to obtain user name, " + "user not authenticated");
-              @Override
-              public ReservationSubmissionResponse run() throws IOException,
-                  YarnException {
-                return rm.getClientRMService().submitReservation(reservation);
-              }
+            @Override
+            public ReservationSubmissionResponse run()
+                throws IOException, YarnException {
+              return rm.getClientRMService().submitReservation(reservation);
+            }
-      ReservationRequest rr =
-          ReservationRequest.newInstance(capability, numContainers,
-              minConcurrency, duration);
+      ReservationRequest rr = ReservationRequest.newInstance(capability,
+          numContainers, minConcurrency, duration);
-    ReservationId reservationId = ReservationId.parseReservationId(resContext
-        .getReservationId());
-    ReservationSubmissionRequest request =
-        ReservationSubmissionRequest.newInstance(rDef, resContext.getQueue(),
-          reservationId);
+    ReservationId reservationId =
+        ReservationId.parseReservationId(resContext.getReservationId());
+    ReservationSubmissionRequest request = ReservationSubmissionRequest
+        .newInstance(rDef, resContext.getQueue(), reservationId);
-  /**
-   * Function to update a Reservation to the RM.
-   *
-   * @param resContext provides information to construct the
-   *          ReservationUpdateRequest
-   * @param hsr the servlet request
-   * @return Response containing the status code
-   * @throws AuthorizationException
-   * @throws IOException
-   * @throws InterruptedException
-   */
-  @Path("/reservation/update")
+  @Path(RMWSConsts.RESERVATION_UPDATE)
+  @Override
-      @Context HttpServletRequest hsr) throws AuthorizationException,
-      IOException, InterruptedException {
+      @Context HttpServletRequest hsr)
+      throws AuthorizationException, IOException, InterruptedException {
-      throw new AuthorizationException("Unable to obtain user name, "
-          + "user not authenticated");
+      throw new AuthorizationException(
+          "Unable to obtain user name, " + "user not authenticated");
-      resRespInfo =
-          callerUGI.doAs(
-              new PrivilegedExceptionAction<ReservationUpdateResponseInfo>() {
-                @Override
-                public ReservationUpdateResponseInfo run() throws IOException,
-                    YarnException {
-                  rm.getClientRMService().updateReservation(reservation);
-                  return new ReservationUpdateResponseInfo();
-                }
-              });
+      resRespInfo = callerUGI
+          .doAs(new PrivilegedExceptionAction<ReservationUpdateResponseInfo>() {
+            @Override
+            public ReservationUpdateResponseInfo run()
+                throws IOException, YarnException {
+              rm.getClientRMService().updateReservation(reservation);
+              return new ReservationUpdateResponseInfo();
+            }
+          });
-      ReservationRequest rr =
-          ReservationRequest.newInstance(capability, numContainers,
-              minConcurrency, duration);
+      ReservationRequest rr = ReservationRequest.newInstance(capability,
+          numContainers, minConcurrency, duration);
-    ReservationUpdateRequest request =
-        ReservationUpdateRequest.newInstance(rDef, ReservationId
-            .parseReservationId(resContext.getReservationId()));
+    ReservationUpdateRequest request = ReservationUpdateRequest.newInstance(
+        rDef, ReservationId.parseReservationId(resContext.getReservationId()));
-  /**
-   * Function to delete a Reservation to the RM.
-   *
-   * @param resContext provides information to construct
-   *          the ReservationDeleteRequest
-   * @param hsr the servlet request
-   * @return Response containing the status code
-   * @throws AuthorizationException when the user group information cannot be
-   *           retrieved.
-   * @throws IOException when a {@link ReservationDeleteRequest} cannot be
-   *           created from the {@link ReservationDeleteRequestInfo}. This
-   *           exception is also thrown on
-   *           {@code ClientRMService.deleteReservation} invokation failure.
-   * @throws InterruptedException if doAs action throws an InterruptedException.
-   */
-  @Path("/reservation/delete")
+  @Path(RMWSConsts.RESERVATION_DELETE)
+  @Override
-      @Context HttpServletRequest hsr) throws AuthorizationException,
-      IOException, InterruptedException {
+      @Context HttpServletRequest hsr)
+      throws AuthorizationException, IOException, InterruptedException {
-      throw new AuthorizationException("Unable to obtain user name, "
-          + "user not authenticated");
+      throw new AuthorizationException(
+          "Unable to obtain user name, " + "user not authenticated");
-      resRespInfo =
-          callerUGI.doAs(
-              new PrivilegedExceptionAction<ReservationDeleteResponseInfo>() {
-                @Override
-                public ReservationDeleteResponseInfo run() throws IOException,
-                    YarnException {
-                  rm.getClientRMService().deleteReservation(reservation);
-                  return new ReservationDeleteResponseInfo();
-                }
-              });
+      resRespInfo = callerUGI
+          .doAs(new PrivilegedExceptionAction<ReservationDeleteResponseInfo>() {
+            @Override
+            public ReservationDeleteResponseInfo run()
+                throws IOException, YarnException {
+              rm.getClientRMService().deleteReservation(reservation);
+              return new ReservationDeleteResponseInfo();
+            }
+          });
-    ReservationDeleteRequest request =
-        ReservationDeleteRequest.newInstance(ReservationId
-            .parseReservationId(resContext.getReservationId()));
+    ReservationDeleteRequest request = ReservationDeleteRequest.newInstance(
+        ReservationId.parseReservationId(resContext.getReservationId()));
-  /**
-   * Function to retrieve a list of all the reservations.
-   */
-  @Path("/reservation/list")
+  @Path(RMWSConsts.RESERVATION_LIST)
+  @Override
-          @QueryParam("queue") @DefaultValue("default") String queue,
-          @QueryParam("reservation-id") @DefaultValue("") String reservationId,
-          @QueryParam("start-time") @DefaultValue("0") long startTime,
-          @QueryParam("end-time") @DefaultValue("-1") long endTime,
-          @QueryParam("include-resource-allocations") @DefaultValue("false")
-          boolean includeResourceAllocations, @Context HttpServletRequest hsr)
-          throws Exception {
+      @QueryParam(RMWSConsts.QUEUE) @DefaultValue(DEFAULT_QUEUE) String queue,
+      @QueryParam(RMWSConsts.RESERVATION_ID) @DefaultValue(DEFAULT_RESERVATION_ID) String reservationId,
+      @QueryParam(RMWSConsts.START_TIME) @DefaultValue(DEFAULT_START_TIME) long startTime,
+      @QueryParam(RMWSConsts.END_TIME) @DefaultValue(DEFAULT_END_TIME) long endTime,
+      @QueryParam(RMWSConsts.INCLUDE_RESOURCE) @DefaultValue(DEFAULT_INCLUDE_RESOURCE) boolean includeResourceAllocations,
+      @Context HttpServletRequest hsr) throws Exception {
-          queue, reservationId, startTime, endTime, includeResourceAllocations);
+        queue, reservationId, startTime, endTime, includeResourceAllocations);
-      throw new AuthorizationException("Unable to obtain user name, "
-              + "user not authenticated");
+      throw new AuthorizationException(
+          "Unable to obtain user name, " + "user not authenticated");
-      resRespInfo = callerUGI.doAs(
-          new PrivilegedExceptionAction<ReservationListResponse>() {
+      resRespInfo = callerUGI
+          .doAs(new PrivilegedExceptionAction<ReservationListResponse>() {
-            public ReservationListResponse run() throws IOException,
-                    YarnException {
+            public ReservationListResponse run()
+                throws IOException, YarnException {
-    ReservationListInfo resResponse = new ReservationListInfo(resRespInfo,
-            includeResourceAllocations);
+    ReservationListInfo resResponse =
+        new ReservationListInfo(resRespInfo, includeResourceAllocations);
-  @Path("/apps/{appid}/timeouts/{type}")
+  @Path(RMWSConsts.APPS_TIMEOUTS_TYPE)
+  @Override
-      @PathParam("appid") String appId, @PathParam("type") String type)
-      throws AuthorizationException {
+      @PathParam(RMWSConsts.APPID) String appId,
+      @PathParam(RMWSConsts.TYPE) String type) throws AuthorizationException {
-  @Path("/apps/{appid}/timeouts")
+  @Path(RMWSConsts.APPS_TIMEOUTS)
+  @Override
-      @PathParam("appid") String appId) throws AuthorizationException {
+      @PathParam(RMWSConsts.APPID) String appId) throws AuthorizationException {
-  @Path("/apps/{appid}/timeout")
+  @Path(RMWSConsts.APPS_TIMEOUT)
+  @Override
-      @Context HttpServletRequest hsr, @PathParam("appid") String appId)
-      throws AuthorizationException, YarnException, InterruptedException,
-      IOException {
+      @Context HttpServletRequest hsr,
+      @PathParam(RMWSConsts.APPID) String appId) throws AuthorizationException,
+      YarnException, InterruptedException, IOException {
-          return Response.status(Status.BAD_REQUEST)
-              .entity(ye.getMessage()).build();
+          return Response.status(Status.BAD_REQUEST).entity(ye.getMessage())
+              .build();

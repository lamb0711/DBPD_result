YARN-1776. Fixed DelegationToken renewal to survive RM failover. Contributed by Zhijie Shen

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580154 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.fs.PathFilter;
-  private Path rmDTSecretManagerRoot;
+  @Private
+  @VisibleForTesting
+  Path rmDTSecretManagerRoot;
+        checkAndResumeUpdateOperation(appDir.getPath());
+  private void checkAndResumeUpdateOperation(Path path) throws Exception {
+    // Before loading the state information, check whether .new file exists.
+    // If it does, the prior updateFile is failed on half way. We need to
+    // complete replacing the old file first.
+    FileStatus[] newChildNodes =
+        fs.listStatus(path, new PathFilter() {
+      @Override
+      public boolean accept(Path path) {
+        return path.getName().endsWith(".new");
+      }
+    });
+    for(FileStatus newChildNodeStatus : newChildNodes) {
+      assert newChildNodeStatus.isFile();
+      String newChildNodeName = newChildNodeStatus.getPath().getName();
+      String childNodeName = newChildNodeName.substring(
+          0, newChildNodeName.length() - ".new".length());
+      Path childNodePath =
+          new Path(newChildNodeStatus.getPath().getParent(), childNodeName);
+      replaceFile(newChildNodeStatus.getPath(), childNodePath);
+    }
+  }
+    checkAndResumeUpdateOperation(rmDTSecretManagerRoot);
+    storeOrUpdateRMDelegationTokenAndSequenceNumberState(
+        identifier, renewDate,latestSequenceNumber, false);
+  }
+
+  @Override
+  public synchronized void removeRMDelegationTokenState(
+      RMDelegationTokenIdentifier identifier) throws Exception {
+    Path nodeCreatePath = getNodePath(rmDTSecretManagerRoot,
+      DELEGATION_TOKEN_PREFIX + identifier.getSequenceNumber());
+    LOG.info("Removing RMDelegationToken_" + identifier.getSequenceNumber());
+    deleteFile(nodeCreatePath);
+  }
+
+  @Override
+  protected void updateRMDelegationTokenAndSequenceNumberInternal(
+      RMDelegationTokenIdentifier rmDTIdentifier, Long renewDate,
+      int latestSequenceNumber) throws Exception {
+    storeOrUpdateRMDelegationTokenAndSequenceNumberState(
+        rmDTIdentifier, renewDate,latestSequenceNumber, true);
+  }
+
+  private void storeOrUpdateRMDelegationTokenAndSequenceNumberState(
+      RMDelegationTokenIdentifier identifier, Long renewDate,
+      int latestSequenceNumber, boolean isUpdate) throws Exception {
-    LOG.info("Storing RMDelegationToken_" + identifier.getSequenceNumber());
-    writeFile(nodeCreatePath, os.toByteArray());
+    if (isUpdate) {
+      LOG.info("Updating RMDelegationToken_" + identifier.getSequenceNumber());
+      updateFile(nodeCreatePath, os.toByteArray());
+    } else {
+      LOG.info("Storing RMDelegationToken_" + identifier.getSequenceNumber());
+      writeFile(nodeCreatePath, os.toByteArray());
+    }
-  public synchronized void removeRMDelegationTokenState(
-      RMDelegationTokenIdentifier identifier) throws Exception {
-    Path nodeCreatePath = getNodePath(rmDTSecretManagerRoot,
-      DELEGATION_TOKEN_PREFIX + identifier.getSequenceNumber());
-    LOG.info("Removing RMDelegationToken_" + identifier.getSequenceNumber());
-    deleteFile(nodeCreatePath);
-  }
-
-  @Override
+  /*
+   * In order to make this update atomic as a part of write we will first write
+   * data to .new file and then rename it. Here we are assuming that rename is
+   * atomic for underlying file system.
+   */
-    if (fs.exists(outputPath)) {
-      deleteFile(outputPath);
-    }
-    writeFile(outputPath, data);
+    Path newPath = new Path(outputPath.getParent(), outputPath.getName() + ".new");
+    // use writeFile to make sure .new file is created atomically
+    writeFile(newPath, data);
+    replaceFile(newPath, outputPath);
-  private boolean renameFile(Path src, Path dst) throws Exception {
+  protected void replaceFile(Path srcPath, Path dstPath) throws Exception {
+    if (fs.exists(dstPath)) {
+      deleteFile(dstPath);
+    }
+    fs.rename(srcPath, dstPath);
+  }
+
+  @Private
+  @VisibleForTesting
+  boolean renameFile(Path src, Path dst) throws Exception {
-  private Path getNodePath(Path root, String nodeName) {
+  @Private
+  @VisibleForTesting
+  Path getNodePath(Path root, String nodeName) {
+

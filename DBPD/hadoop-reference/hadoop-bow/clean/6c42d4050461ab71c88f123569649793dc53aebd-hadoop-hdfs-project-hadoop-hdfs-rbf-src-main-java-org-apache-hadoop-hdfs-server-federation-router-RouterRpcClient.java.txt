HDFS-14316. RBF: Support unavailable subclusters for mount points with multiple destinations. Contributed by Inigo Goiri.

+import static org.apache.hadoop.fs.CommonConfigurationKeysPublic.IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY;
+import static org.apache.hadoop.fs.CommonConfigurationKeysPublic.IPC_CLIENT_CONNECT_TIMEOUT_KEY;
+
+import java.net.ConnectException;
+import org.apache.hadoop.net.ConnectTimeoutException;
-    this.connectionManager = new ConnectionManager(conf);
+    Configuration clientConf = getClientConfiguration(conf);
+    this.connectionManager = new ConnectionManager(clientConf);
+   * Get the configuration for the RPC client. It takes the Router
+   * configuration and transforms it into regular RPC Client configuration.
+   * @param conf Input configuration.
+   * @return Configuration for the RPC client.
+   */
+  private Configuration getClientConfiguration(final Configuration conf) {
+    Configuration clientConf = new Configuration(conf);
+    int maxRetries = conf.getInt(
+        RBFConfigKeys.DFS_ROUTER_CLIENT_MAX_RETRIES_TIME_OUT,
+        RBFConfigKeys.DFS_ROUTER_CLIENT_MAX_RETRIES_TIME_OUT_DEFAULT);
+    if (maxRetries >= 0) {
+      clientConf.setInt(
+          IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY, maxRetries);
+    }
+    long connectTimeOut = conf.getTimeDuration(
+        RBFConfigKeys.DFS_ROUTER_CLIENT_CONNECT_TIMEOUT,
+        RBFConfigKeys.DFS_ROUTER_CLIENT_CONNECT_TIMEOUT_DEFAULT,
+        TimeUnit.MILLISECONDS);
+    if (connectTimeOut >= 0) {
+      clientConf.setLong(IPC_CLIENT_CONNECT_TIMEOUT_KEY, connectTimeOut);
+    }
+    return clientConf;
+  }
+
+  /**
-   * @throws IOException
+   * @throws ConnectException If it cannot connect to any Namenode.
+   * @throws StandbyException If all Namenodes are in Standby.
+   * @throws IOException If it cannot invoke the method.
-          throws IOException {
+          throws ConnectException, StandbyException, IOException {
-          " with params " + Arrays.toString(params) + " from "
+          " with params " + Arrays.deepToString(params) + " from "
+        } else if (ioe instanceof ConnectException ||
+            ioe instanceof ConnectTimeoutException) {
+          if (this.rpcMonitor != null) {
+            this.rpcMonitor.proxyOpFailureCommunicate();
+          }
+          failover = true;
-          LOG.error("Can not get available namenode for {} {} error: {}",
+          LOG.error("Cannot get available namenode for {} {} error: {}",
-        Arrays.toString(params);
+        Arrays.deepToString(params) + " in " + namenodes + " from " +
+        router.getRouterId();
+    int exConnect = 0;
-      String nsId = namenode.getNameserviceId();
-      String nnId = namenode.getNamenodeId();
+      String nnKey = namenode.getNamenodeKey();
-        LOG.error("{} {} at {} is in Standby: {}", nsId, nnId, addr,
-            ioe.getMessage());
+        LOG.error("{} at {} is in Standby: {}",
+            nnKey, addr, ioe.getMessage());
+      } else if (ioe instanceof ConnectException ||
+          ioe instanceof ConnectTimeoutException) {
+        exConnect++;
+        LOG.error("{} at {} cannot be reached: {}",
+            nnKey, addr, ioe.getMessage());
-        LOG.error("{} {} at {} error: \"{}\"",
-            nsId, nnId, addr, ioe.getMessage());
+        LOG.error("{} at {} error: \"{}\"", nnKey, addr, ioe.getMessage());
-    throw new StandbyException(msg);
+    if (exConnect == ioes.size()) {
+      throw new ConnectException(msg);
+    } else {
+      throw new StandbyException(msg);
+    }
+          } else if (ioe instanceof ConnectException ||
+              ioe instanceof ConnectTimeoutException) {
+            throw ioe;
-    } else if (locations.size() == 1) {
+    } else if (locations.size() == 1 && timeOutMs <= 0) {

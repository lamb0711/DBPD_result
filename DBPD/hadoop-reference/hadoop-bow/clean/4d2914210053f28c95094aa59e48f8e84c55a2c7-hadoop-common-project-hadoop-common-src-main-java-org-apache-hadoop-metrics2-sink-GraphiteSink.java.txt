HADOOP-11400. GraphiteSink does not reconnect to Graphite after 'broken pipe'
(Kamil Gorlo via raviprak)

-import java.io.IOException;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.io.Closeable;
-import java.net.Socket;
-
-import org.apache.hadoop.io.IOUtils;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.net.Socket;
+
-    private Writer writer = null;
-    private Socket socket = null;
+    private Graphite graphite = null;
-        String serverHost = conf.getString(SERVER_HOST_KEY);
-        Integer serverPort = Integer.parseInt(conf.getString(SERVER_PORT_KEY));
+        final String serverHost = conf.getString(SERVER_HOST_KEY);
+        final int serverPort = Integer.parseInt(conf.getString(SERVER_PORT_KEY));
-        try {
-            // Open an connection to Graphite server.
-            socket = new Socket(serverHost, serverPort);
-            writer = new OutputStreamWriter(
-                socket.getOutputStream(), Charsets.UTF_8);
-        } catch (Exception e) {
-            throw new MetricsException("Error creating connection, "
-                    + serverHost + ":" + serverPort, e);
-        }
+        graphite = new Graphite(serverHost, serverPort);
+        graphite.connect();
-            if(writer != null){
-              writer.write(lines.toString());
-            } else {
-              throw new MetricsException("Writer in GraphiteSink is null!");
-            }
+          graphite.write(lines.toString());
-            throw new MetricsException("Error sending metrics", e);
+          LOG.warn("Error sending metrics to Graphite", e);
+          try {
+            graphite.close();
+          } catch (Exception e1) {
+            throw new MetricsException("Error closing connection to Graphite", e1);
+          }
+      try {
+        graphite.flush();
+      } catch (Exception e) {
+        LOG.warn("Error flushing metrics to Graphite", e);
-            writer.flush();
-        } catch (Exception e) {
-            throw new MetricsException("Error flushing metrics", e);
+          graphite.close();
+        } catch (Exception e1) {
+          throw new MetricsException("Error closing connection to Graphite", e1);
+      }
-      try {
-        IOUtils.closeStream(writer);
-        writer = null;
-        LOG.info("writer in GraphiteSink is closed!");
-      } catch (Throwable e){
-        throw new MetricsException("Error closing writer", e);
-      } finally {
-        if (socket != null && !socket.isClosed()) {
-          socket.close();
-          socket = null;
-          LOG.info("socket in GraphiteSink is closed!");
+      graphite.close();
+    }
+
+    public static class Graphite {
+      private final static int MAX_CONNECTION_FAILURES = 5;
+
+      private String serverHost;
+      private int serverPort;
+      private Writer writer = null;
+      private Socket socket = null;
+      private int connectionFailures = 0;
+
+      public Graphite(String serverHost, int serverPort) {
+        this.serverHost = serverHost;
+        this.serverPort = serverPort;
+      }
+
+      public void connect() {
+        if (isConnected()) {
+          throw new MetricsException("Already connected to Graphite");
+        }
+        if (tooManyConnectionFailures()) {
+          // return silently (there was ERROR in logs when we reached limit for the first time)
+          return;
+        }
+        try {
+          // Open a connection to Graphite server.
+          socket = new Socket(serverHost, serverPort);
+          writer = new OutputStreamWriter(socket.getOutputStream(), Charsets.UTF_8);
+        } catch (Exception e) {
+          connectionFailures++;
+          if (tooManyConnectionFailures()) {
+            // first time when connection limit reached, report to logs
+            LOG.error("Too many connection failures, would not try to connect again.");
+          }
+          throw new MetricsException("Error creating connection, "
+              + serverHost + ":" + serverPort, e);
+
+      public void write(String msg) throws IOException {
+        if (!isConnected()) {
+          connect();
+        }
+        if (isConnected()) {
+          writer.write(msg);
+        }
+      }
+
+      public void flush() throws IOException {
+        if (isConnected()) {
+          writer.flush();
+        }
+      }
+
+      public boolean isConnected() {
+        return socket != null && socket.isConnected() && !socket.isClosed();
+      }
+
+      public void close() throws IOException {
+        try {
+          if (writer != null) {
+            writer.close();
+          }
+        } catch (IOException ex) {
+          if (socket != null) {
+            socket.close();
+          }
+        } finally {
+          socket = null;
+          writer = null;
+        }
+      }
+
+      private boolean tooManyConnectionFailures() {
+        return connectionFailures > MAX_CONNECTION_FAILURES;
+      }
+
+

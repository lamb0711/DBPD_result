YARN-9997. Code cleanup in ZKConfigurationStore. Contributed by Andras Gyori

-  private String znodeParentPath;
-
-  @VisibleForTesting
-  protected ZKCuratorManager zkManager;
+  private ZKCuratorManager zkManager;
+
+    String znodeParentPath = conf.get(
+        YarnConfiguration.RM_SCHEDCONF_STORE_ZK_PARENT_PATH,
+        YarnConfiguration.DEFAULT_RM_SCHEDCONF_STORE_ZK_PARENT_PATH);
+
-    this.znodeParentPath =
-        conf.get(YarnConfiguration.RM_SCHEDCONF_STORE_ZK_PARENT_PATH,
-            YarnConfiguration.DEFAULT_RM_SCHEDCONF_STORE_ZK_PARENT_PATH);
-    if (!zkManager.exists(logsPath)) {
-      zkManager.create(logsPath);
-      zkManager.setData(logsPath,
-          serializeObject(new LinkedList<LogMutation>()), -1);
+    if (createNewZkPath(logsPath)) {
+      setZkData(logsPath, new LinkedList<LogMutation>());
-    if (!zkManager.exists(confVersionPath)) {
-      zkManager.create(confVersionPath);
-      zkManager.setData(confVersionPath, String.valueOf(0), -1);
+    if (createNewZkPath(confVersionPath)) {
+      setZkData(confVersionPath, String.valueOf(0));
-    if (!zkManager.exists(confStorePath)) {
-      zkManager.create(confStorePath);
+    if (createNewZkPath(confStorePath)) {
-      zkManager.setData(confStorePath, serializeObject(mapSchedConf), -1);
+      setZkData(confStorePath, mapSchedConf);
-      zkManager.setData(confVersionPath, String.valueOf(configVersion), -1);
+      setZkData(confVersionPath, String.valueOf(configVersion));
-    return (LinkedList<LogMutation>)
-        deserializeObject(zkManager.getData(logsPath));
+    return unsafeCast(deserializeObject(getZkData(logsPath)));
-  // TODO: following version-related code is taken from ZKRMStateStore
-      byte[] data = zkManager.getData(zkVersionPath);
+      byte[] data = getZkData(zkVersionPath);
-      zkManager.safeSetData(zkVersionPath, data, -1, zkAcl, fencingNodePath);
+      safeSetZkData(zkVersionPath, data);
-      zkManager.safeCreate(zkVersionPath, data, zkAcl, CreateMode.PERSISTENT,
-          zkAcl, fencingNodePath);
+      safeCreateZkData(zkVersionPath, data);
-      byte[] storedLogs = zkManager.getData(logsPath);
+      byte[] storedLogs = getZkData(logsPath);
-        logs = (LinkedList<LogMutation>) deserializeObject(storedLogs);
+        logs = unsafeCast(deserializeObject(storedLogs));
-      zkManager.safeSetData(logsPath, serializeObject(logs), -1, zkAcl,
-              fencingNodePath);
+      safeSetZkData(logsPath, logs);
-      zkManager.safeSetData(confStorePath, serializeObject(mapConf), -1,
-          zkAcl, fencingNodePath);
+      safeSetZkData(confStorePath, mapConf);
-      zkManager.setData(confVersionPath, String.valueOf(configVersion), -1);
+      setZkData(confVersionPath, String.valueOf(configVersion));
-      serializedSchedConf = zkManager.getData(confStorePath);
+      serializedSchedConf = getZkData(confStorePath);
-          (HashMap<String, String>) deserializeObject(serializedSchedConf);
+          unsafeCast(deserializeObject(serializedSchedConf));
-    return Long.parseLong(zkManager.getStringData(confVersionPath));
+    String version = zkManager.getStringData(confVersionPath);
+    if (version == null) {
+      throw new IllegalStateException("Config version can not be properly " +
+          "serialized. Check Zookeeper config version path to locate " +
+          "the error!");
+    }
+
+    return Long.parseLong(version);
+  /**
+   * Creates a new path in Zookeeper only, if it does not already exist.
+   *
+   * @param path Value of the Zookeeper path
+   * @return <code>true</code>if the creation executed; <code>false</code>
+   * otherwise.
+   * @throws Exception
+   */
+  private boolean createNewZkPath(String path) throws Exception {
+    if (!zkManager.exists(path)) {
+      zkManager.create(path);
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  @VisibleForTesting
+  protected byte[] getZkData(String path) throws Exception {
+    return zkManager.getData(path);
+  }
+
+  @VisibleForTesting
+  protected void setZkData(String path, byte[] data) throws Exception {
+    zkManager.setData(path, data, -1);
+  }
+
+  private void setZkData(String path, Object data) throws Exception {
+    setZkData(path, serializeObject(data));
+  }
+
+  private void setZkData(String path, String data) throws Exception {
+    zkManager.setData(path, data, -1);
+  }
+
+  private void safeSetZkData(String path, byte[] data) throws Exception {
+    zkManager.safeSetData(path, data, -1, zkAcl, fencingNodePath);
+  }
+
+  private void safeSetZkData(String path, Object data) throws Exception {
+    safeSetZkData(path, serializeObject(data));
+  }
+
+  @VisibleForTesting
+  protected void safeCreateZkData(String path, byte[] data) throws Exception {
+    zkManager.safeCreate(path, data, zkAcl, CreateMode.PERSISTENT,
+        zkAcl, fencingNodePath);
+  }
+
+
+  /**
+   * Casts an object of type Object to type T. It is essential to emphasize,
+   * that it is an unsafe operation.
+   *
+   * @param o Object to be cast from
+   * @param <T> Type to cast to
+   * @return casted object of type T
+   * @throws ClassCastException
+   */
+  @SuppressWarnings("unchecked")
+  private static <T> T unsafeCast(Object o) throws ClassCastException {
+    return (T)o;
+  }

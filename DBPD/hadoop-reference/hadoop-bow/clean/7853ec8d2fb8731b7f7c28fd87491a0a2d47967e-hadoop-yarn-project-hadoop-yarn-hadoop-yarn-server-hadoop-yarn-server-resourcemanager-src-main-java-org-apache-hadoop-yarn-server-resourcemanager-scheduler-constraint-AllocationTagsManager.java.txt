YARN-8013. Support application tags when defining application namespaces for placement constraints. Contributed by Weiwei Yang.

-import com.google.common.collect.ImmutableSet;
+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMApp;
+import java.util.concurrent.ConcurrentMap;
-   * a given set of application IDs, the values are properly merged.
+   * the scope defined in the allocation tags, the values are properly merged.
-   * @param appIds a set of application IDs.
+   * @param allocationTags {@link AllocationTags}.
-  private TypeToCountedTags aggregateAllocationTags(Set<ApplicationId> appIds,
-      Map<ApplicationId, TypeToCountedTags> mapping) {
+  private TypeToCountedTags aggregateAllocationTags(
+      AllocationTags allocationTags,
+      Map<ApplicationId, TypeToCountedTags> mapping)
+      throws InvalidAllocationTagsQueryException {
+    // Based on the namespace type of the given allocation tags
+    TargetApplicationsNamespace namespace = allocationTags.getNamespace();
+    TargetApplications ta = new TargetApplications(
+        allocationTags.getCurrentApplicationId(), getApplicationIdToTags());
+    namespace.evaluate(ta);
+    Set<ApplicationId> appIds = namespace.getNamespaceScope();
-        mapping = aggregateAllocationTags(
-            tags.getNamespace().getNamespaceScope(),
-            perAppNodeMappings);
+        mapping = aggregateAllocationTags(tags, perAppNodeMappings);
-        mapping = aggregateAllocationTags(
-            tags.getNamespace().getNamespaceScope(),
-            perAppRackMappings);
+        mapping = aggregateAllocationTags(tags, perAppRackMappings);
-   * @return all application IDs in a set that currently visible by
-   * the allocation tags manager.
+   * @return all applications that is known to the
+   * {@link AllocationTagsManager}, along with their application tags.
+   * The result is a map, where key is an application ID, and value is the
+   * application-tags attached to this application. If there is no
+   * application-tag exists for the application, the value is an empty set.
-  public Set<ApplicationId> getAllApplicationIds() {
-    return ImmutableSet.copyOf(perAppNodeMappings.keySet());
+  private Map<ApplicationId, Set<String>> getApplicationIdToTags() {
+    Map<ApplicationId, Set<String>> result = new HashMap<>();
+    ConcurrentMap<ApplicationId, RMApp> allApps = rmContext.getRMApps();
+    if (allApps != null) {
+      for (Map.Entry<ApplicationId, RMApp> app : allApps.entrySet()) {
+        if (perAppNodeMappings.containsKey(app.getKey())) {
+          result.put(app.getKey(), app.getValue().getApplicationTags());
+        }
+      }
+    }
+    return result;

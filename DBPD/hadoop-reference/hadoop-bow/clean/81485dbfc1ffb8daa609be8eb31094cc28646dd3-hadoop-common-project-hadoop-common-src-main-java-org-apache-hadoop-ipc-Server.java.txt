Revert "HADOOP-13465. Design Server.Call to be extensible for unified call queue. Contributed by Daryn Sharp."

This reverts commit d288a0ba8364d81aacda9f4a21022eecb6dc4e22.

-    return (call != null ) ? call.getHostInetAddress() : null;
+    return (call != null && call.connection != null) ? call.connection
+        .getHostInetAddress() : null;
-
+  
-    return (call != null) ? call.getRemoteUser() : null;
+    return (call != null && call.connection != null) ? call.connection.user
+        : null;
-
+ 
-        String client = CurCall.get().toString();
+        String client = CurCall.get().connection.toString();
-  /** A generic call queued for handling. */
-  public static class Call implements Schedulable,
-  PrivilegedExceptionAction<Void> {
-    final int callId;            // the client's call id
-    final int retryCount;        // the retry count of the call
-    long timestamp;              // time received when response is null
-                                 // time served when response is not null
+  /** A call queued for handling. */
+  public static class Call implements Schedulable {
+    private final int callId;             // the client's call id
+    private final int retryCount;        // the retry count of the call
+    private final Writable rpcRequest;    // Serialized Rpc request from client
+    private final Connection connection;  // connection to client
+    private long timestamp;               // time received when response is null
+                                          // time served when response is not null
+    private ByteBuffer rpcResponse;       // the response for this call
-    final RPC.RpcKind rpcKind;
-    final byte[] clientId;
+    private final RPC.RpcKind rpcKind;
+    private final byte[] clientId;
-    Call(Call call) {
-      this(call.callId, call.retryCount, call.rpcKind, call.clientId,
-          call.traceScope, call.callerContext);
+    private Call(Call call) {
+      this(call.callId, call.retryCount, call.rpcRequest, call.connection,
+          call.rpcKind, call.clientId, call.traceScope, call.callerContext);
-    Call(int id, int retryCount, RPC.RpcKind kind, byte[] clientId) {
-      this(id, retryCount, kind, clientId, null, null);
+    public Call(int id, int retryCount, Writable param, 
+        Connection connection) {
+      this(id, retryCount, param, connection, RPC.RpcKind.RPC_BUILTIN,
+          RpcConstants.DUMMY_CLIENT_ID);
-    @VisibleForTesting // primarily TestNamenodeRetryCache
-    public Call(int id, int retryCount, Void ignore1, Void ignore2,
+    public Call(int id, int retryCount, Writable param, Connection connection,
-      this(id, retryCount, kind, clientId, null, null);
+      this(id, retryCount, param, connection, kind, clientId, null, null);
-    Call(int id, int retryCount, RPC.RpcKind kind, byte[] clientId,
-        TraceScope traceScope, CallerContext callerContext) {
+    public Call(int id, int retryCount, Writable param, Connection connection,
+        RPC.RpcKind kind, byte[] clientId, TraceScope traceScope,
+        CallerContext callerContext) {
+      this.rpcRequest = param;
+      this.connection = connection;
+      this.rpcResponse = null;
-
+    
-      return "Call#" + callId + " Retry#" + retryCount;
+      return rpcRequest + " from " + connection + " Call#" + callId + " Retry#"
+          + retryCount;
-    public Void run() throws Exception {
-      return null;
-    }
-    // should eventually be abstract but need to avoid breaking tests
-    public UserGroupInformation getRemoteUser() {
-      return null;
-    }
-    public InetAddress getHostInetAddress() {
-      return null;
-    }
-    public String getHostAddress() {
-      InetAddress addr = getHostInetAddress();
-      return (addr != null) ? addr.getHostAddress() : null;
+    public void setResponse(ByteBuffer response) {
+      this.rpcResponse = response;
-    public final void postponeResponse() {
+    public void postponeResponse() {
-    public final void sendResponse() throws IOException {
+    public void sendResponse() throws IOException {
-        doResponse(null);
+        connection.sendResponse(this);
-    public final void abortResponse(Throwable t) throws IOException {
+    public void abortResponse(Throwable t) throws IOException {
-        doResponse(t);
+        connection.abortResponse(this, t);
-    void doResponse(Throwable t) throws IOException {}
-
-      return getRemoteUser();
+      return connection.user;
-  /** A RPC extended call queued for handling. */
-  private class RpcCall extends Call {
-    final Connection connection;  // connection to client
-    final Writable rpcRequest;    // Serialized Rpc request from client
-    ByteBuffer rpcResponse;       // the response for this call
-
-    RpcCall(RpcCall call) {
-      super(call);
-      this.connection = call.connection;
-      this.rpcRequest = call.rpcRequest;
-    }
-
-    RpcCall(Connection connection, int id) {
-      this(connection, id, RpcConstants.INVALID_RETRY_COUNT);
-    }
-
-    RpcCall(Connection connection, int id, int retryCount) {
-      this(connection, id, retryCount, null,
-          RPC.RpcKind.RPC_BUILTIN, RpcConstants.DUMMY_CLIENT_ID,
-          null, null);
-    }
-
-    RpcCall(Connection connection, int id, int retryCount,
-        Writable param, RPC.RpcKind kind, byte[] clientId,
-        TraceScope traceScope, CallerContext context) {
-      super(id, retryCount, kind, clientId, traceScope, context);
-      this.connection = connection;
-      this.rpcRequest = param;
-    }
-
-    @Override
-    public UserGroupInformation getRemoteUser() {
-      return connection.user;
-    }
-
-    @Override
-    public InetAddress getHostInetAddress() {
-      return connection.getHostInetAddress();
-    }
-
-    @Override
-    public Void run() throws Exception {
-      if (!connection.channel.isOpen()) {
-        Server.LOG.info(Thread.currentThread().getName() + ": skipped " + this);
-        return null;
-      }
-      String errorClass = null;
-      String error = null;
-      RpcStatusProto returnStatus = RpcStatusProto.SUCCESS;
-      RpcErrorCodeProto detailedErr = null;
-      Writable value = null;
-
-      try {
-        value = call(
-            rpcKind, connection.protocolName, rpcRequest, timestamp);
-      } catch (Throwable e) {
-        if (e instanceof UndeclaredThrowableException) {
-          e = e.getCause();
-        }
-        logException(Server.LOG, e, this);
-        if (e instanceof RpcServerException) {
-          RpcServerException rse = ((RpcServerException)e);
-          returnStatus = rse.getRpcStatusProto();
-          detailedErr = rse.getRpcErrorCodeProto();
-        } else {
-          returnStatus = RpcStatusProto.ERROR;
-          detailedErr = RpcErrorCodeProto.ERROR_APPLICATION;
-        }
-        errorClass = e.getClass().getName();
-        error = StringUtils.stringifyException(e);
-        // Remove redundant error class name from the beginning of the
-        // stack trace
-        String exceptionHdr = errorClass + ": ";
-        if (error.startsWith(exceptionHdr)) {
-          error = error.substring(exceptionHdr.length());
-        }
-      }
-      setupResponse(this, returnStatus, detailedErr,
-          value, errorClass, error);
-      sendResponse();
-      return null;
-    }
-
-    void setResponse(ByteBuffer response) throws IOException {
-      this.rpcResponse = response;
-    }
-
-    @Override
-    void doResponse(Throwable t) throws IOException {
-      RpcCall call = this;
-      if (t != null) {
-        // clone the call to prevent a race with another thread stomping
-        // on the response while being sent.  the original call is
-        // effectively discarded since the wait count won't hit zero
-        call = new RpcCall(this);
-        setupResponse(call,
-            RpcStatusProto.FATAL, RpcErrorCodeProto.ERROR_RPC_SERVER,
-            null, t.getClass().getName(), StringUtils.stringifyException(t));
-      }
-      connection.sendResponse(this);
-    }
-
-    @Override
-    public String toString() {
-      return super.toString() + " " + rpcRequest + " from " + connection;
-    }
-  }
-
-          ArrayList<RpcCall> calls;
+          ArrayList<Call> calls;
-            calls = new ArrayList<RpcCall>(writeSelector.keys().size());
+            calls = new ArrayList<Call>(writeSelector.keys().size());
-              RpcCall call = (RpcCall)key.attachment();
+              Call call = (Call)key.attachment();
-
-          for (RpcCall call : calls) {
+          
+          for(Call call : calls) {
-      RpcCall call = (RpcCall)key.attachment();
+      Call call = (Call)key.attachment();
-    private void doPurge(RpcCall call, long now) {
-      LinkedList<RpcCall> responseQueue = call.connection.responseQueue;
+    private void doPurge(Call call, long now) {
+      LinkedList<Call> responseQueue = call.connection.responseQueue;
-        Iterator<RpcCall> iter = responseQueue.listIterator(0);
+        Iterator<Call> iter = responseQueue.listIterator(0);
-    private boolean processResponse(LinkedList<RpcCall> responseQueue,
+    private boolean processResponse(LinkedList<Call> responseQueue,
-      RpcCall call = null;
+      Call call = null;
-    void doRespond(RpcCall call) throws IOException {
+    void doRespond(Call call) throws IOException {
-    private LinkedList<RpcCall> responseQueue;
+    private LinkedList<Call> responseQueue;
-    private final RpcCall authFailedCall =
-        new RpcCall(this, AUTHORIZATION_FAILED_CALL_ID);
+    private final Call authFailedCall = new Call(AUTHORIZATION_FAILED_CALL_ID,
+        RpcConstants.INVALID_RETRY_COUNT, null, this);
-      this.responseQueue = new LinkedList<RpcCall>();
+      this.responseQueue = new LinkedList<Call>();
-      final RpcCall saslCall = new RpcCall(this, AuthProtocol.SASL.callId);
+      final Call saslCall = new Call(AuthProtocol.SASL.callId,
+          RpcConstants.INVALID_RETRY_COUNT, null, this);
-        RpcCall fakeCall = new RpcCall(this, -1);
+        Call fakeCall = new Call(-1, RpcConstants.INVALID_RETRY_COUNT, null,
+            this);
-        RpcCall fakeCall = new RpcCall(this, -1);
+        Call fakeCall = new Call(-1, RpcConstants.INVALID_RETRY_COUNT, null,
+            this);
-        RpcCall fakeCall = new RpcCall(this, 0);
+        Call fakeCall = new Call(0, RpcConstants.INVALID_RETRY_COUNT, null,
+            this);
-      RpcCall fakeCall = new RpcCall(this, 0);
+      Call fakeCall = new Call(0, RpcConstants.INVALID_RETRY_COUNT, null, this);
-        final RpcCall call = new RpcCall(this, callId, retry);
+        final Call call = new Call(callId, retry, null, this);
-      RpcCall call = new RpcCall(this, header.getCallId(),
-          header.getRetryCount(), rpcRequest,
-          ProtoUtil.convert(header.getRpcKind()),
+      Call call = new Call(header.getCallId(), header.getRetryCount(),
+          rpcRequest, this, ProtoUtil.convert(header.getRpcKind()),
-    private void sendResponse(RpcCall call) throws IOException {
+    private void sendResponse(Call call) throws IOException {
+    private void abortResponse(Call call, Throwable t) throws IOException {
+      // clone the call to prevent a race with the other thread stomping
+      // on the response while being sent.  the original call is
+      // effectively discarded since the wait count won't hit zero
+      call = new Call(call);
+      setupResponse(call,
+          RpcStatusProto.FATAL, RpcErrorCodeProto.ERROR_RPC_SERVER,
+          null, t.getClass().getName(), StringUtils.stringifyException(t));
+      call.sendResponse();
+    }
+
+          if (!call.connection.channel.isOpen()) {
+            LOG.info(Thread.currentThread().getName() + ": skipped " + call);
+            continue;
+          }
+          String errorClass = null;
+          String error = null;
+          RpcStatusProto returnStatus = RpcStatusProto.SUCCESS;
+          RpcErrorCodeProto detailedErr = null;
+          Writable value = null;
+
-          UserGroupInformation remoteUser = call.getRemoteUser();
-          if (remoteUser != null) {
-            remoteUser.doAs(call);
-          } else {
-            call.run();
+
+          try {
+            // Make the call as the user via Subject.doAs, thus associating
+            // the call with the Subject
+            if (call.connection.user == null) {
+              value = call(call.rpcKind, call.connection.protocolName, call.rpcRequest, 
+                           call.timestamp);
+            } else {
+              value = 
+                call.connection.user.doAs
+                  (new PrivilegedExceptionAction<Writable>() {
+                     @Override
+                     public Writable run() throws Exception {
+                       // make the call
+                       return call(call.rpcKind, call.connection.protocolName, 
+                                   call.rpcRequest, call.timestamp);
+
+                     }
+                   }
+                  );
+            }
+          } catch (Throwable e) {
+            if (e instanceof UndeclaredThrowableException) {
+              e = e.getCause();
+            }
+            logException(LOG, e, call);
+            if (e instanceof RpcServerException) {
+              RpcServerException rse = ((RpcServerException)e); 
+              returnStatus = rse.getRpcStatusProto();
+              detailedErr = rse.getRpcErrorCodeProto();
+            } else {
+              returnStatus = RpcStatusProto.ERROR;
+              detailedErr = RpcErrorCodeProto.ERROR_APPLICATION;
+            }
+            errorClass = e.getClass().getName();
+            error = StringUtils.stringifyException(e);
+            // Remove redundant error class name from the beginning of the stack trace
+            String exceptionHdr = errorClass + ": ";
+            if (error.startsWith(exceptionHdr)) {
+              error = error.substring(exceptionHdr.length());
+            }
+          }
+          CurCall.set(null);
+          synchronized (call.connection.responseQueue) {
+            setupResponse(call, returnStatus, detailedErr,
+                value, errorClass, error);
+            call.sendResponse();
-          CurCall.set(null);
-      RpcCall call, RpcStatusProto status, RpcErrorCodeProto erCode,
+      Call call, RpcStatusProto status, RpcErrorCodeProto erCode,
-  private void setupResponse(RpcCall call,
+  private void setupResponse(Call call,
-                             RpcCall call,
+                             Call call,
-  private void wrapWithSasl(RpcCall call) throws IOException {
+  private void wrapWithSasl(Call call) throws IOException {

HDFS-1974. Introduce active and standy states to the namenode. Contributed by Suresh Srinivas.



git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1156418 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.ha.HealthCheckFailedException;
+import org.apache.hadoop.ha.ServiceFailedException;
+import org.apache.hadoop.hdfs.server.namenode.ha.ActiveState;
+import org.apache.hadoop.hdfs.server.namenode.ha.HAState;
+import org.apache.hadoop.hdfs.server.namenode.ha.StandbyState;
+import org.apache.hadoop.hdfs.server.protocol.JournalProtocol;
+   * Categories of operations supported by the namenode.
+   */
+  public static enum OperationCategory {
+    /** Read operation that does not change the namespace state */
+    READ,
+    /** Write operation that changes the namespace state */
+    WRITE,
+    /** Operations related to checkpointing */
+    CHECKPOINT,
+    /** Operations related to {@link JournalProtocol} */
+    JOURNAL
+  }
+  
+  /**
+  public static final HAState ACTIVE_STATE = new ActiveState();
+  public static final HAState STANDBY_STATE = new StandbyState();
+  private HAState state;
+  private final boolean haEnabled;
+
+  
+    initializeGenericKeys(conf);
-    LOG.info(getRole() + " up at: " + rpcAddress);
-    if (serviceRPCAddress != null) {
-      LOG.info(getRole() + " service server is up at: " + serviceRPCAddress); 
-    }
+    LOG.info(getRole() + " up at: " + rpcAddress);
+    if (serviceRPCAddress != null) {
+      LOG.info(getRole() + " service server is up at: " + serviceRPCAddress); 
+    }
+    this.haEnabled = DFSUtil.isHAEnabled(conf);
+    this.state = !haEnabled ? ACTIVE_STATE : STANDBY_STATE;
-      initializeGenericKeys(conf);
+    checkOperation(OperationCategory.WRITE);
-    verifyRequest(registration);
-    if(!isRole(NamenodeRole.NAMENODE))
-      throw new IOException("Only an ACTIVE node can invoke endCheckpoint.");
+    checkOperation(OperationCategory.CHECKPOINT);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.READ);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+  @Override // ClientProtocol
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
-  @Override
+  @Override // ClientProtocol, DatanodeProtocol
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.READ);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
-      boolean needLocation)
-  throws IOException {
+      boolean needLocation) throws IOException {
+    checkOperation(OperationCategory.READ);
+    checkOperation(OperationCategory.READ);
+    checkOperation(OperationCategory.READ);
+    checkOperation(OperationCategory.READ);
+    // TODO:HA decide on OperationCategory for this
+    // TODO:HA decide on OperationCategory for this
+    // TODO:HA decide on OperationCategory for this
+    // TODO:HA decide on OperationCategory for this
+    // TODO:HA decide on OperationCategory for this
+    // TODO:HA decide on OperationCategory for this
-  @Override
+  @Override // NamenodeProtocol
+    // TODO:HA decide on OperationCategory for this
+    // TODO:HA decide on OperationCategory for this
+    // TODO:HA decide on OperationCategory for this
+    // TODO:HA decide on OperationCategory for this
+    checkOperation(OperationCategory.READ);
+  @Override // ClientProtocol
+    // TODO:HA decide on OperationCategory for this
+    checkOperation(OperationCategory.READ);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.WRITE);
+    checkOperation(OperationCategory.READ);
+  
+  @Override // HAServiceProtocol
+  public synchronized void monitorHealth() throws HealthCheckFailedException {
+    if (!haEnabled) {
+      return; // no-op, if HA is not eanbled
+    }
+    // TODO:HA implement health check
+    return;
+  }
+  
+  @Override // HAServiceProtocol
+  public synchronized void transitionToActive() throws ServiceFailedException {
+    if (!haEnabled) {
+      throw new ServiceFailedException("HA for namenode is not enabled");
+    }
+    state.setState(this, ACTIVE_STATE);
+  }
+  
+  @Override // HAServiceProtocol
+  public synchronized void transitionToStandby() throws ServiceFailedException {
+    if (!haEnabled) {
+      throw new ServiceFailedException("HA for namenode is not enabled");
+    }
+    state.setState(this, STANDBY_STATE);
+  }
+  
+  /** Check if an operation of given category is allowed */
+  protected synchronized void checkOperation(final OperationCategory op)
+      throws UnsupportedActionException {
+    state.checkOperation(this, op);
+  }
+  
+  public synchronized HAState getState() {
+    return state;
+  }
+  
+  public synchronized void setState(final HAState s) {
+    state = s;
+  }

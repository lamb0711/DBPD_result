YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)

Change-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b

+
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.event
+    .QueueManagementChangeEvent;
+import org.apache.hadoop.yarn.util.Clock;
+  protected Clock monotonicClock;
+
-      
+
+    case MANAGE_QUEUE:
+    {
+      QueueManagementChangeEvent queueManagementChangeEvent =
+          (QueueManagementChangeEvent) event;
+      ParentQueue parentQueue = queueManagementChangeEvent.getParentQueue();
+      try {
+        final List<QueueManagementChange> queueManagementChanges =
+            queueManagementChangeEvent.getQueueManagementChanges();
+        ((ManagedParentQueue) parentQueue)
+            .validateAndApplyQueueManagementChanges(queueManagementChanges);
+      } catch (SchedulerDynamicEditException sde) {
+        LOG.error("Queue Management Change event cannot be applied for "
+            + "parent queue : " + parentQueue.getQueueName(), sde);
+      } catch (IOException ioe) {
+        LOG.error("Queue Management Change event cannot be applied for "
+            + "parent queue : " + parentQueue.getQueueName(), ioe);
+      }
+    }
+    break;
-      if (!(q instanceof AutoCreatedLeafQueue)) {
+      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(
+          q.getClass()))) {
-                + ") is not a AutoCreatedLeafQueue");
+                + ") is not a AutoCreatedLeafQueue or ReservationQueue");
-      AutoCreatedLeafQueue disposableLeafQueue = (AutoCreatedLeafQueue) q;
+      AbstractAutoCreatedLeafQueue disposableLeafQueue =
+          (AbstractAutoCreatedLeafQueue) q;
-      LOG.info("Removal of AutoCreatedLeafQueue "
-          + queueName + " has succeeded");
+      LOG.info(
+          "Removal of AutoCreatedLeafQueue " + queueName + " has succeeded");
-      throws SchedulerDynamicEditException {
+      throws SchedulerDynamicEditException, IOException {
-      if (!(queue instanceof AutoCreatedLeafQueue)) {
+      if (queue == null) {
-            "Queue " + queue.getQueueName() + " is not a AutoCreatedLeafQueue");
+            "Queue specified is null. Should be an implementation of "
+                + "AbstractAutoCreatedLeafQueue");
+      } else if (!(AbstractAutoCreatedLeafQueue.class
+          .isAssignableFrom(queue.getClass()))) {
+        throw new SchedulerDynamicEditException(
+            "Queue is not an implementation of "
+                + "AbstractAutoCreatedLeafQueue : " + queue.getClass());
-      AutoCreatedLeafQueue newQueue = (AutoCreatedLeafQueue) queue;
+      AbstractAutoCreatedLeafQueue newQueue =
+          (AbstractAutoCreatedLeafQueue) queue;
-      if (newQueue.getParent() == null
-          || !(AbstractManagedParentQueue.class.
+      if (newQueue.getParent() == null || !(AbstractManagedParentQueue.class.
-            "ParentQueue for " + newQueue.getQueueName()
-                + " is not properly set"
+            "ParentQueue for " + newQueue + " is not properly set"
+
-      AbstractManagedParentQueue parent = (AbstractManagedParentQueue) queue
-          .getParent();
+      AbstractManagedParentQueue parent =
+          (AbstractManagedParentQueue) queue.getParent();
-      if (!(queue instanceof AutoCreatedLeafQueue)) {
+      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(
+          queue.getClass()))) {
-      if (parent == null
-          || !(AbstractManagedParentQueue.class.isAssignableFrom(
-              parent.getClass()))) {
+      if (parent == null || !(AbstractManagedParentQueue.class.isAssignableFrom(
+          parent.getClass()))) {
-      AutoCreatedLeafQueue newQueue = (AutoCreatedLeafQueue) queue;
+      AbstractAutoCreatedLeafQueue newQueue =
+          (AbstractAutoCreatedLeafQueue) queue;
+      parent.validateQueueEntitlementChange(newQueue, entitlement);
-      float sumChilds = parent.sumOfChildCapacities();
-      float newChildCap =
-          sumChilds - queue.getCapacity() + entitlement.getCapacity();
+      newQueue.setEntitlement(entitlement);
-      if (newChildCap >= 0 && newChildCap < 1.0f + CSQueueUtils.EPSILON) {
-        // note: epsilon checks here are not ok, as the epsilons might
-        // accumulate and become a problem in aggregate
-        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) == 0
-            && Math.abs(
-            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) == 0) {
-          return;
-        }
-        newQueue.setEntitlement(entitlement);
-      } else{
-        throw new SchedulerDynamicEditException(
-            "Sum of child queues should exceed 100% for auto creating parent "
-                + "queue : " + parent.getQueueName());
-      }
-      LOG.info(
-          "Set entitlement for AutoCreatedLeafQueue " + inQueue
-              + "  to " + queue.getCapacity() +
-              " request was (" + entitlement.getCapacity()
-              + ")");
+      LOG.info("Set entitlement for AutoCreatedLeafQueue " + inQueue + "  to "
+          + queue.getCapacity() + " request was (" + entitlement.getCapacity()
+          + ")");
-        //TODO - Set entitlement through capacity management policy

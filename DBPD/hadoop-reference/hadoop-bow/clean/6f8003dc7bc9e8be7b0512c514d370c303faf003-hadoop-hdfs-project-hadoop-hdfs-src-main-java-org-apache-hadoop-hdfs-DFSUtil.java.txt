HDFS-8185. Separate client related routines in HAUtil into a new class. Contributed by Haohui Mai.

-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_HA_NAMENODES_KEY_PREFIX;
-import static org.apache.hadoop.hdfs.DFSConfigKeys.DFS_NAMESERVICES;
-import java.util.Collections;
-import org.apache.hadoop.hdfs.web.SWebHdfsFileSystem;
-import org.apache.hadoop.hdfs.web.WebHdfsFileSystem;
-import com.google.common.collect.Maps;
-        NodeBase node = new NodeBase(xferAddrs[hCnt], 
+        NodeBase node = new NodeBase(xferAddrs[hCnt],
-   * Returns collection of nameservice Ids from the configuration.
-   * @param conf configuration
-   * @return collection of nameservice Ids, or null if not specified
-   */
-  public static Collection<String> getNameServiceIds(Configuration conf) {
-    return conf.getTrimmedStringCollection(DFS_NAMESERVICES);
-  }
-
-  /**
-   * @return <code>coll</code> if it is non-null and non-empty. Otherwise,
-   * returns a list with a single null value.
-   */
-  private static Collection<String> emptyAsSingletonNull(Collection<String> coll) {
-    if (coll == null || coll.isEmpty()) {
-      return Collections.singletonList(null);
-    } else {
-      return coll;
-    }
-  }
-  
-  /**
-   * Namenode HighAvailability related configuration.
-   * Returns collection of namenode Ids from the configuration. One logical id
-   * for each namenode in the in the HA setup.
-   * 
-   * @param conf configuration
-   * @param nsId the nameservice ID to look at, or null for non-federated 
-   * @return collection of namenode Ids
-   */
-  public static Collection<String> getNameNodeIds(Configuration conf, String nsId) {
-    String key = addSuffix(DFS_HA_NAMENODES_KEY_PREFIX, nsId);
-    return conf.getTrimmedStringCollection(key);
-  }
-  
-  /**
-   * Given a list of keys in the order of preference, returns a value
-   * for the key in the given order from the configuration.
-   * @param defaultValue default value to return, when key was not found
-   * @param keySuffix suffix to add to the key, if it is not null
-   * @param conf Configuration
-   * @param keys list of keys in the order of preference
-   * @return value of the key or default if a key was not found in configuration
-   */
-  private static String getConfValue(String defaultValue, String keySuffix,
-      Configuration conf, String... keys) {
-    String value = null;
-    for (String key : keys) {
-      key = addSuffix(key, keySuffix);
-      value = conf.get(key);
-      if (value != null) {
-        break;
-      }
-    }
-    if (value == null) {
-      value = defaultValue;
-    }
-    return value;
-  }
-  
-  /** Add non empty and non null suffix to a key */
-  private static String addSuffix(String key, String suffix) {
-    if (suffix == null || suffix.isEmpty()) {
-      return key;
-    }
-    assert !suffix.startsWith(".") :
-      "suffix '" + suffix + "' should not already have '.' prepended.";
-    return key + "." + suffix;
-  }
-  
-  /** Concatenate list of suffix strings '.' separated */
-  private static String concatSuffixes(String... suffixes) {
-    if (suffixes == null) {
-      return null;
-    }
-    return Joiner.on(".").skipNulls().join(suffixes);
-  }
-  
-  /**
-    String keySuffix = concatSuffixes(suffixes);
-    return addSuffix(key, keySuffix);
+    String keySuffix = DFSUtilClient.concatSuffixes(suffixes);
+    return DFSUtilClient.addSuffix(key, keySuffix);
-   * Returns the configured address for all NameNodes in the cluster.
-   * @param conf configuration
-   * @param defaultAddress default address to return in case key is not found.
-   * @param keys Set of keys to look for in the order of preference
-   * @return a map(nameserviceId to map(namenodeId to InetSocketAddress))
-   */
-  private static Map<String, Map<String, InetSocketAddress>>
-    getAddresses(Configuration conf, String defaultAddress, String... keys) {
-    Collection<String> nameserviceIds = getNameServiceIds(conf);
-    return getAddressesForNsIds(conf, nameserviceIds, defaultAddress, keys);
-  }
-
-  /**
-   * Returns the configured address for all NameNodes in the cluster.
-   * @param conf configuration
-   * @param nsIds
-   *@param defaultAddress default address to return in case key is not found.
-   * @param keys Set of keys to look for in the order of preference   @return a map(nameserviceId to map(namenodeId to InetSocketAddress))
-   */
-  private static Map<String, Map<String, InetSocketAddress>>
-    getAddressesForNsIds(Configuration conf, Collection<String> nsIds,
-                         String defaultAddress, String... keys) {
-    // Look for configurations of the form <key>[.<nameserviceId>][.<namenodeId>]
-    // across all of the configured nameservices and namenodes.
-    Map<String, Map<String, InetSocketAddress>> ret = Maps.newLinkedHashMap();
-    for (String nsId : emptyAsSingletonNull(nsIds)) {
-      Map<String, InetSocketAddress> isas =
-        getAddressesForNameserviceId(conf, nsId, defaultAddress, keys);
-      if (!isas.isEmpty()) {
-        ret.put(nsId, isas);
-      }
-    }
-    return ret;
-  }
-  
-  /**
-    return getAddressesForNameserviceId(conf, nsId, defaultValue,
-        DFS_NAMENODE_RPC_ADDRESS_KEY);
-  }
-
-  private static Map<String, InetSocketAddress> getAddressesForNameserviceId(
-      Configuration conf, String nsId, String defaultValue,
-      String... keys) {
-    Collection<String> nnIds = getNameNodeIds(conf, nsId);
-    Map<String, InetSocketAddress> ret = Maps.newHashMap();
-    for (String nnId : emptyAsSingletonNull(nnIds)) {
-      String suffix = concatSuffixes(nsId, nnId);
-      String address = getConfValue(defaultValue, suffix, conf, keys);
-      if (address != null) {
-        InetSocketAddress isa = NetUtils.createSocketAddr(address);
-        if (isa.isUnresolved()) {
-          LOG.warn("Namenode for " + nsId +
-                   " remains unresolved for ID " + nnId +
-                   ".  Check your hdfs-site.xml file to " +
-                   "ensure namenodes are configured properly.");
-        }
-        ret.put(nnId, isa);
-      }
-    }
-    return ret;
+    return DFSUtilClient.getAddressesForNameserviceId(conf, nsId, defaultValue,
+                                                      DFS_NAMENODE_RPC_ADDRESS_KEY);
-    for (String nsId : DFSUtil.getNameServiceIds(conf)) {
+    for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {
-        for (String nnId : DFSUtil.getNameNodeIds(conf, nsId)) {
+        for (String nnId : DFSUtilClient.getNameNodeIds(conf, nsId)) {
-    return getAddresses(conf, null, DFSConfigKeys.DFS_NAMENODE_RPC_ADDRESS_KEY);
-  }
-
-  /**
-   * Returns list of InetSocketAddress corresponding to HA NN HTTP addresses from
-   * the configuration.
-   *
-   * @return list of InetSocketAddresses
-   */
-  public static Map<String, Map<String, InetSocketAddress>> getHaNnWebHdfsAddresses(
-      Configuration conf, String scheme) {
-    if (WebHdfsFileSystem.SCHEME.equals(scheme)) {
-      return getAddresses(conf, null,
-          DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY);
-    } else if (SWebHdfsFileSystem.SCHEME.equals(scheme)) {
-      return getAddresses(conf, null,
-          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY);
-    } else {
-      throw new IllegalArgumentException("Unsupported scheme: " + scheme);
-    }
+    return DFSUtilClient.getAddresses(conf, null,
+                                      DFSConfigKeys.DFS_NAMENODE_RPC_ADDRESS_KEY);
-    Map<String, Map<String, InetSocketAddress>> addressList = getAddresses(conf,
-        null, DFS_NAMENODE_BACKUP_ADDRESS_KEY);
+    Map<String, Map<String, InetSocketAddress>> addressList = DFSUtilClient.getAddresses(
+        conf, null, DFS_NAMENODE_BACKUP_ADDRESS_KEY);
-    Map<String, Map<String, InetSocketAddress>> addressList = getAddresses(conf, null,
-        DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY);
+    Map<String, Map<String, InetSocketAddress>> addressList = DFSUtilClient.getAddresses(
+        conf, null, DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY);
-      getAddresses(conf, defaultAddress,
-        DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY, DFS_NAMENODE_RPC_ADDRESS_KEY);
+      DFSUtilClient.getAddresses(conf, defaultAddress,
+                                 DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY,
+                                 DFS_NAMENODE_RPC_ADDRESS_KEY);
-            getAddressesForNsIds(conf, parentNameServices, defaultAddress,
-                    DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY, DFS_NAMENODE_RPC_ADDRESS_KEY);
+            DFSUtilClient.getAddressesForNsIds(conf, parentNameServices,
+                                               defaultAddress,
+                                               DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY,
+                                               DFS_NAMENODE_RPC_ADDRESS_KEY);
-    for (String nsId : getNameServiceIds(conf)) {
+    for (String nsId : DFSUtilClient.getNameServiceIds(conf)) {
-          String addr = conf.get(concatSuffixes(key, nsId));
+          String addr = conf.get(DFSUtilClient.concatSuffixes(key, nsId));
-    Collection<String> nsIds = getNameServiceIds(conf);
+    Collection<String> nsIds = DFSUtilClient.getNameServiceIds(conf);
-    Collection<String> nsIds = getNameServiceIds(conf);
-    for (String nsId : emptyAsSingletonNull(nsIds)) {
+    Collection<String> nsIds = DFSUtilClient.getNameServiceIds(conf);
+    for (String nsId : DFSUtilClient.emptyAsSingletonNull(nsIds)) {
-      Collection<String> nnIds = getNameNodeIds(conf, nsId);
-      for (String nnId : emptyAsSingletonNull(nnIds)) {
+      Collection<String> nnIds = DFSUtilClient.getNameNodeIds(conf, nsId);
+      for (String nnId : DFSUtilClient.emptyAsSingletonNull(nnIds)) {
-    String serviceAddrKey = concatSuffixes(
+    String serviceAddrKey = DFSUtilClient.concatSuffixes(
-    String addrKey = concatSuffixes(
+    String addrKey = DFSUtilClient.concatSuffixes(
-    Collection<String> nsIds = getNameServiceIds(conf);
+    Collection<String> nsIds = DFSUtilClient.getNameServiceIds(conf);

HDFS-14454. RBF: getContentSummary() should allow non-existing folders. Contributed by Inigo Goiri.

-  @SuppressWarnings("unchecked")
+    final List<RemoteResult<T, R>> results = invokeConcurrent(
+        locations, method, standby, timeOutMs, clazz);
+
+    final Map<T, R> ret = new TreeMap<>();
+    for (final RemoteResult<T, R> result : results) {
+      // Response from all servers required, use this error.
+      if (requireResponse && result.hasException()) {
+        throw result.getException();
+      }
+      if (result.hasResult()) {
+        ret.put(result.getLocation(), result.getResult());
+      }
+    }
+
+    // Throw the exception for the first location if there are no results
+    if (ret.isEmpty()) {
+      final RemoteResult<T, R> result = results.get(0);
+      if (result.hasException()) {
+        throw result.getException();
+      }
+    }
+
+    return ret;
+  }
+
+  /**
+   * Invokes multiple concurrent proxy calls to different clients. Returns an
+   * array of results.
+   *
+   * Re-throws exceptions generated by the remote RPC call as either
+   * RemoteException or IOException.
+   *
+   * @param <T> The type of the remote location.
+   * @param <R> The type of the remote method return
+   * @param locations List of remote locations to call concurrently.
+   * @param method The remote method and parameters to invoke.
+   * @param standby If the requests should go to the standby namenodes too.
+   * @param timeOutMs Timeout for each individual call.
+   * @param clazz Type of the remote return type.
+   * @return Result of invoking the method per subcluster (list of results).
+   *         This includes the exception for each remote location.
+   * @throws IOException If there are errors invoking the method.
+   */
+  @SuppressWarnings("unchecked")
+  public <T extends RemoteLocationContext, R> List<RemoteResult<T, R>>
+      invokeConcurrent(final Collection<T> locations,
+          final RemoteMethod method, boolean standby, long timeOutMs,
+          Class<R> clazz) throws IOException {
-        Object result = invokeMethod(ugi, namenodes, proto, m, paramList);
-        return Collections.singletonMap(location, (R) result);
+        R result = (R) invokeMethod(ugi, namenodes, proto, m, paramList);
+        RemoteResult<T, R> remoteResult = new RemoteResult<>(location, result);
+        return Collections.singletonList(remoteResult);
-      Map<T, R> results = new TreeMap<>();
-      Map<T, IOException> exceptions = new TreeMap<>();
+      List<RemoteResult<T, R>> results = new ArrayList<>();
-          Object result = future.get();
-          results.put(location, (R) result);
+          R result = (R) future.get();
+          results.add(new RemoteResult<>(location, result));
-          exceptions.put(location, ioe);
+          results.add(new RemoteResult<>(location, ioe));
-          // Response from all servers required, use this error.
-          if (requireResponse) {
-            throw ioe;
-          }
-
-          exceptions.put(location, ioe);
-        }
-      }
-
-      // Throw the exception for the first location if there are no results
-      if (results.isEmpty()) {
-        T location = orderedLocations.get(0);
-        IOException ioe = exceptions.get(location);
-        if (ioe != null) {
-          throw ioe;
+          results.add(new RemoteResult<>(location, ioe));

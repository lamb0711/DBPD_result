HDFS-9835. OIV: add ReverseXML processor which reconstructs an fsimage from an XML file (cmccabe)

+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.TimeZone;
+import com.google.protobuf.ByteString;
+import org.apache.commons.codec.binary.Hex;
+import org.apache.hadoop.fs.permission.PermissionStatus;
+import org.apache.hadoop.hdfs.protocol.proto.XAttrProtos;
+import org.apache.hadoop.util.VersionInfo;
+
+import static org.apache.hadoop.hdfs.server.namenode.FSImageFormatPBINode.XATTR_NAMESPACE_MASK;
+import static org.apache.hadoop.hdfs.server.namenode.FSImageFormatPBINode.XATTR_NAMESPACE_OFFSET;
+import static org.apache.hadoop.hdfs.server.namenode.FSImageFormatPBINode.XATTR_NAMESPACE_EXT_MASK;
+import static org.apache.hadoop.hdfs.server.namenode.FSImageFormatPBINode.XATTR_NAMESPACE_EXT_OFFSET;
+import static org.apache.hadoop.hdfs.server.namenode.FSImageFormatPBINode.XATTR_NAME_OFFSET;
+import static org.apache.hadoop.hdfs.server.namenode.FSImageFormatPBINode.XATTR_NAME_MASK;
+  private final SimpleDateFormat isoDateFormat;
+  public static SimpleDateFormat createSimpleDateFormat() {
+    SimpleDateFormat format =
+      new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
+    format.setTimeZone(TimeZone.getTimeZone("UTC"));
+    return format;
+  }
+
+    this.isoDateFormat = createSimpleDateFormat();
+      out.print("<version>");
+      o("layoutVersion", summary.getLayoutVersion());
+      o("onDiskVersion", summary.getOndiskVersion());
+      // Output the version of OIV (which is not necessarily the version of
+      // the fsimage file).  This could be helpful in the case where a bug
+      // in OIV leads to information loss in the XML-- we can quickly tell
+      // if a specific fsimage XML file is affected by this bug.
+      o("oivRevision", VersionInfo.getRevision());
+      out.print("</version>\n");
+
+    o("numDirectives", s.getNumDirectives());
+    o("numPools", s.getNumPools());
-      o("millis", e.getMillis()).o("relatilve", e.getIsRelative());
+      o("millis", e.getMillis()).o("relative", e.getIsRelative());
+  private void dumpXattrs(INodeSection.XAttrFeatureProto xattrs) {
+    out.print("<xattrs>");
+    for (INodeSection.XAttrCompactProto xattr : xattrs.getXAttrsList()) {
+      out.print("<xattr>");
+      int encodedName = xattr.getName();
+      int ns = (XATTR_NAMESPACE_MASK & (encodedName >> XATTR_NAMESPACE_OFFSET)) |
+          ((XATTR_NAMESPACE_EXT_MASK & (encodedName >> XATTR_NAMESPACE_EXT_OFFSET)) << 2);
+      o("ns", XAttrProtos.XAttrProto.
+          XAttrNamespaceProto.valueOf(ns).toString());
+      o("name", stringTable[XATTR_NAME_MASK & (encodedName >> XATTR_NAME_OFFSET)]);
+      ByteString val = xattr.getValue();
+      if (val.isValidUtf8()) {
+        o("val", val.toStringUtf8());
+      } else {
+        o("valHex", Hex.encodeHexString(val.toByteArray()));
+      }
+      out.print("</xattr>");
+    }
+    out.print("</xattrs>");
+  }
+
+    if (d.hasXAttrs()) {
+      dumpXattrs(d.getXAttrs());
+    }
+    INodeSection.QuotaByStorageTypeFeatureProto typeQuotas =
+      d.getTypeQuotas();
+    if (typeQuotas != null) {
+      for (INodeSection.QuotaByStorageTypeEntryProto entry:
+            typeQuotas.getQuotasList()) {
+        out.print("<typeQuota>");
+        o("type", entry.getStorageType().toString());
+        o("quota", entry.getQuota());
+        out.print("</typeQuota>");
+      }
+    }
-        o("inode", id);
+        o("child", id);
-        o("inodereference-index", refId);
+        o("refChild", refId);
+    if (f.hasXAttrs()) {
+      dumpXattrs(f.getXAttrs());
+    }
+    if (f.hasStoragePolicyID()) {
+      o("storagePolicyId", f.getStoragePolicyID());
+    }
+    if (f.getIsStriped()) {
+      out.print("<isStriped/>");
+    }
+    o("numInodes", s.getNumInodes());
-      o("id", p.getId()).o("type", p.getType()).o("name",
-          p.getName().toStringUtf8());
-
-      if (p.hasFile()) {
-        dumpINodeFile(p.getFile());
-      } else if (p.hasDirectory()) {
-        dumpINodeDirectory(p.getDirectory());
-      } else if (p.hasSymlink()) {
-        dumpINodeSymlink(p.getSymlink());
-      }
-
+      dumpINodeFields(p);
+  private void dumpINodeFields(INodeSection.INode p) {
+    o("id", p.getId()).o("type", p.getType()).o("name",
+        p.getName().toStringUtf8());
+    if (p.hasFile()) {
+      dumpINodeFile(p.getFile());
+    } else if (p.hasDirectory()) {
+      dumpINodeDirectory(p.getDirectory());
+    } else if (p.hasSymlink()) {
+      dumpINodeSymlink(p.getSymlink());
+    }
+  }
+
-    out.print("<NameSection>\n");
+    out.print("<NameSection>");
+    o("namespaceId", s.getNamespaceId());
-    return FSImageFormatPBINode.Loader.loadPermission(permission, stringTable)
-        .toString();
+    PermissionStatus permStatus = FSImageFormatPBINode.Loader.
+        loadPermission(permission, stringTable);
+    return String.format("%s:%s:%04o", permStatus.getUserName(),
+        permStatus.getGroupName(), permStatus.getPermission().toExtendedShort());
+    int expectedNumDelegationKeys = s.getNumKeys();
+    int expectedNumTokens = s.getNumTokens();
-        s.getTokenSequenceNumber());
+        s.getTokenSequenceNumber()).
+        o("numDelegationKeys", expectedNumDelegationKeys).
+        o("numTokens", expectedNumTokens);
+    for (int i = 0; i < expectedNumDelegationKeys; i++) {
+      SecretManagerSection.DelegationKey dkey =
+          SecretManagerSection.DelegationKey.parseDelimitedFrom(is);
+      out.print("<delegationKey>");
+      o("id", dkey.getId());
+      o("key", Hex.encodeHexString(dkey.getKey().toByteArray()));
+      if (dkey.hasExpiryDate()) {
+        dumpDate("expiry", dkey.getExpiryDate());
+      }
+      out.print("</delegationKey>");
+    }
+    for (int i = 0; i < expectedNumTokens; i++) {
+      SecretManagerSection.PersistToken token =
+          SecretManagerSection.PersistToken.parseDelimitedFrom(is);
+      out.print("<token>");
+      if (token.hasVersion()) {
+        o("version", token.getVersion());
+      }
+      if (token.hasOwner()) {
+        o("owner", token.getOwner());
+      }
+      if (token.hasRenewer()) {
+        o("renewer", token.getRenewer());
+      }
+      if (token.hasRealUser()) {
+        o("realUser", token.getRealUser());
+      }
+      if (token.hasIssueDate()) {
+        dumpDate("issueDate", token.getIssueDate());
+      }
+      if (token.hasMaxDate()) {
+        dumpDate("maxDate", token.getMaxDate());
+      }
+      if (token.hasSequenceNumber()) {
+        o("sequenceNumber", token.getSequenceNumber());
+      }
+      if (token.hasMasterKeyId()) {
+        o("masterKeyId", token.getMasterKeyId());
+      }
+      if (token.hasExpiryDate()) {
+        dumpDate("expiryDate", token.getExpiryDate());
+      }
+      out.print("</token>");
+    }
+  private void dumpDate(String tag, long date) {
+    out.print("<" + tag + ">" +
+      isoDateFormat.format(new Date(date)) + "</" + tag + ">");
+  }
+
-      out.print("<diff>");
-      o("inodeid", e.getInodeId());
+      switch (e.getType()) {
+      case FILEDIFF:
+        out.print("<fileDiffEntry>");
+        break;
+      case DIRECTORYDIFF:
+        out.print("<dirDiffEntry>");
+        break;
+      default:
+        throw new IOException("unknown DiffEntry type " + e.getType());
+      }
+      o("inodeId", e.getInodeId());
+      o("count", e.getNumOfDiff());
-          out.print("<filediff>");
+          out.print("<fileDiff>");
-          out.print("</filediff>\n");
+          out.print("</fileDiff>\n");
-          out.print("<dirdiff>");
+          out.print("<dirDiff>");
-              .o("isSnapshotroot", d.getIsSnapshotRoot())
-              .o("name", d.getName().toStringUtf8());
-
+              .o("isSnapshotRoot", d.getIsSnapshotRoot())
+              .o("name", d.getName().toStringUtf8())
+              .o("createdListSize", d.getCreatedListSize());
+          for (long did : d.getDeletedINodeList()) {
+            o("deletedInode", did);
+          }
+          for (int dRefid : d.getDeletedINodeRefList()) {
+            o("deletedInoderef", dRefid);
+          }
-          for (long did : d.getDeletedINodeList()) {
-            out.print("<deleted>");
-            o("inode", did);
-            out.print("</deleted>\n");
-          }
-          for (int dRefid : d.getDeletedINodeRefList()) {
-            out.print("<deleted>");
-            o("inodereference-index", dRefid);
-            out.print("</deleted>\n");
-          }
-          out.print("</dirdiff>\n");
+          out.print("</dirDiff>\n");
-      }
+      }
-      out.print("</diff>");
+      switch (e.getType()) {
+      case FILEDIFF:
+        out.print("</fileDiffEntry>");
+        break;
+      case DIRECTORYDIFF:
+        out.print("</dirDiffEntry>");
+        break;
+      default:
+        throw new IOException("unknown DiffEntry type " + e.getType());
+      }
+    o("numSnapshots", s.getNumSnapshots());
-      o("snapshot", pbs.getSnapshotId());
+      out.print("<snapshot>");
+      o("id", pbs.getSnapshotId());
+      out.print("<root>");
+      dumpINodeFields(pbs.getRoot());
+      out.print("</root>");
+      out.print("</snapshot>");
+    if (v instanceof Boolean) {
+      // For booleans, the presence of the element indicates true, and its
+      // absence indicates false.
+      if ((Boolean)v != false) {
+        out.print("<" + e + "/>");
+      }
+      return this;
+    }

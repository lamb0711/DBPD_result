HDFS-4480. Eliminate the file snapshot circular linked list.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1444280 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+
-import org.apache.hadoop.hdfs.server.namenode.INode.BlocksMapINodeUpdateEntry;
+  /**
+   * A list of {@link FileDiff}.
+   */
+  static class FileDiffList extends AbstractINodeDiffList<INodeFile, FileDiff> {
+    final INodeFile currentINode;
+
+    FileDiffList(INodeFile currentINode, List<FileDiff> diffs) {
+      super(diffs);
+      this.currentINode = currentINode;
+    }
+
+    @Override
+    INodeFile getCurrentINode() {
+      return currentINode;
+    }
+
+    @Override
+    FileDiff addSnapshotDiff(Snapshot snapshot) {
+      return addLast(new FileDiff(snapshot, getCurrentINode()));
+    }
+  }
+
-  
-  /** @return the next element. */
-  public FileWithSnapshot getNext();
-  /** Set the next element. */
-  public void setNext(FileWithSnapshot next);
-  
-  /** Insert inode to the circular linked list, after the current node. */
-  public void insertAfter(FileWithSnapshot inode);
-  
-  /** Insert inode to the circular linked list, before the current node. */
-  public void insertBefore(FileWithSnapshot inode);
-  
-  /** Remove self from the circular list */
-  public void removeSelf();
+  /** @return the file diff list. */
+  public FileDiffList getFileDiffList();
-  /** Are the current file and all snapshot copies deleted? */
-  public boolean isEverythingDeleted();
-
-  /** @return the max file replication in the inode and its snapshot copies. */
-  public short getMaxFileReplication();
-  
-  /** @return the max file size in the inode and its snapshot copies. */
-  public long computeMaxFileSize();
-
-  public static class Util {
-    /** @return The previous node in the circular linked list */
-    static FileWithSnapshot getPrevious(FileWithSnapshot file) {
-      FileWithSnapshot previous = file.getNext();
-      while (previous.getNext() != file) {
-        previous = previous.getNext();
-      }
-      return previous;
-    }
-    
-    /** Replace the old file with the new file in the circular linked list. */
-    static void replace(FileWithSnapshot oldFile, FileWithSnapshot newFile) {
-      final FileWithSnapshot oldNext = oldFile.getNext();
-      if (oldNext == null) {
-        newFile.setNext(null);
-      } else {
-        if (oldNext != oldFile) {
-          newFile.setNext(oldNext);
-          getPrevious(oldFile).setNext(newFile);
-        }
-        oldFile.setNext(null);
-      }
-    }
-
-    /** @return the max file replication of the file in the diff list. */
-    static <N extends INodeFile, D extends AbstractINodeDiff<N, D>>
-        short getMaxFileReplication(short max,
-              final AbstractINodeDiffList<N, D> diffs) {
-      for(AbstractINodeDiff<N, D> d : diffs) {
+  static class Util {
+    /** 
+     * @return block replication, which is the max file replication among
+     *         the file and the diff list.
+     */
+    static short getBlockReplication(final FileWithSnapshot file) {
+      short max = file.isCurrentFileDeleted()? 0
+          : file.asINodeFile().getFileReplication();
+      for(FileDiff d : file.getFileDiffList().asList()) {
-     * @return the max file replication of the elements
-     *         in the circular linked list.
-     */
-    static short getBlockReplication(final FileWithSnapshot file) {
-      short max = file.getMaxFileReplication();
-      // i may be null since next will be set to null when the INode is deleted
-      for(FileWithSnapshot i = file.getNext();
-          i != file && i != null;
-          i = i.getNext()) {
-        final short replication = i.getMaxFileReplication();
-        if (replication > max) {
-          max = replication;
-        }
-      }
-      return max;
-    }
-
-    /**
-      final FileWithSnapshot next = file.getNext();
-
-      // find max file size, max replication and the last inode.
-      long maxFileSize = file.computeMaxFileSize();
-      short maxReplication = file.getMaxFileReplication();
-      FileWithSnapshot last = null;
-      if (next != null && next != file) {
-        for(FileWithSnapshot i = next; i != file; i = i.getNext()) {
-          final long size = i.computeMaxFileSize();
-          if (size > maxFileSize) {
-            maxFileSize = size;
-          }
-          final short rep = i.getMaxFileReplication();
-          if (rep > maxReplication) {
-            maxReplication = rep;
-          }
-          last = i;
-        }
+      // find max file size.
+      final long max;
+      if (file.isCurrentFileDeleted()) {
+        final FileDiff last = file.getFileDiffList().getLast();
+        max = last == null? 0: last.fileSize;
+      } else { 
+        max = file.asINodeFile().computeFileSize(true, null);
-      collectBlocksBeyondMax(file, maxFileSize, info);
+      collectBlocksBeyondMax(file, max, info);
-      if (file.isEverythingDeleted()) {
-        // Set the replication of the current INode to the max of all the other
-        // linked INodes, so that in case the current INode is retrieved from the
-        // blocksMap before it is removed or updated, the correct replication
-        // number can be retrieved.
-        if (maxReplication > 0) {
-          file.asINodeFile().setFileReplication(maxReplication, null);
-        }
-
-        // remove the file from the circular linked list.
-        if (last != null) {
-          last.setNext(next);
-        }
-        file.setNext(null);
-
+      // if everything is deleted, set blocks to null.
+      if (file.isCurrentFileDeleted()
+          && file.getFileDiffList().asList().isEmpty()) {
-
-        // collect update blocks
-        final FileWithSnapshot next = file.getNext();
-        if (next != null && next != file && file.isEverythingDeleted() && collectedBlocks != null) {
-          final BlocksMapINodeUpdateEntry entry = new BlocksMapINodeUpdateEntry(
-              file.asINodeFile(), next.asINodeFile());
-          for (int i = 0; i < n; i++) {
-            collectedBlocks.addUpdateBlock(oldBlocks[i], entry);
-          }
-        }
-          for(FileWithSnapshot i = next; i != null && i != file; i = i.getNext()) {
-            i.asINodeFile().setBlocks(newBlocks);
-          }
-    
-    static String circularListString(final FileWithSnapshot file) {
-      final StringBuilder b = new StringBuilder("* -> ")
-          .append(file.asINodeFile().getObjectString());
-      FileWithSnapshot n = file.getNext();
-      for(; n != null && n != file; n = n.getNext()) {
-        b.append(" -> ").append(n.asINodeFile().getObjectString());
-      }
-      return b.append(n == null? " -> null": " -> *").toString();
-    }

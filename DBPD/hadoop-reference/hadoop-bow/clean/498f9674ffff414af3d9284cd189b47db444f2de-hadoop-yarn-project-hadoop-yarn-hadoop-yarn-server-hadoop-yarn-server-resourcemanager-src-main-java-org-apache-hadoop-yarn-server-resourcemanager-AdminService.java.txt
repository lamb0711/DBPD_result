Merge r1550130 through r1555020 from trunk.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1555021 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
-import com.google.common.annotations.VisibleForTesting;
-import com.google.protobuf.BlockingService;
+import org.apache.hadoop.ipc.StandbyException;
-import org.apache.hadoop.yarn.conf.HAUtil;
+import org.apache.hadoop.yarn.api.records.NodeId;
+import org.apache.hadoop.yarn.api.records.ResourceOption;
-import org.apache.hadoop.yarn.exceptions.RMNotYetActiveException;
+import org.apache.hadoop.yarn.server.api.protocolrecords.UpdateNodeResourceRequest;
+import org.apache.hadoop.yarn.server.api.protocolrecords.UpdateNodeResourceResponse;
+import org.apache.hadoop.yarn.server.resourcemanager.rmnode.RMNode;
+import com.google.protobuf.BlockingService;
+
-  @VisibleForTesting
-  protected HAServiceProtocol.HAServiceState
-      haState = HAServiceProtocol.HAServiceState.INITIALIZING;
-  boolean haEnabled;
+  private String rmId;
-    haEnabled = HAUtil.isHAEnabled(conf);
-    if (haEnabled) {
-      HAUtil.verifyAndSetConfiguration(conf);
-      rm.setConf(conf);
-    }
-    rm.createAndInitActiveServices();
-
+    rmId = conf.get(YarnConfiguration.RM_HA_ID);
-    if (haEnabled) {
-      transitionToStandby(true);
-    } else {
-      transitionToActive();
-    }
-    transitionToStandby(false);
-    haState = HAServiceState.STOPPING;
-    if (haEnabled) {
+    if (rmContext.isHAEnabled()) {
-    return HAServiceState.ACTIVE == haState;
+    return HAServiceState.ACTIVE == rmContext.getHAServiceState();
+  }
+
+  private void throwStandbyException() throws StandbyException {
+    throw new StandbyException("ResourceManager " + rmId + " is not Active!");
-    if (haState == HAServiceProtocol.HAServiceState.ACTIVE && !rm.areActiveServicesRunning()) {
+    if (isRMActive() && !rm.areActiveServicesRunning()) {
-  synchronized void transitionToActive() throws Exception {
-    if (haState == HAServiceProtocol.HAServiceState.ACTIVE) {
-      LOG.info("Already in active state");
-      return;
-    }
-
-    LOG.info("Transitioning to active");
-    rm.startActiveServices();
-    haState = HAServiceProtocol.HAServiceState.ACTIVE;
-    LOG.info("Transitioned to active");
-  }
-
-  public synchronized void transitionToActive(HAServiceProtocol.StateChangeRequestInfo reqInfo)
-      throws IOException {
+  public synchronized void transitionToActive(
+      HAServiceProtocol.StateChangeRequestInfo reqInfo) throws IOException {
-      transitionToActive();
+      rm.transitionToActive();
-  synchronized void transitionToStandby(boolean initialize)
-      throws Exception {
-    if (haState == HAServiceProtocol.HAServiceState.STANDBY) {
-      LOG.info("Already in standby state");
-      return;
-    }
-
-    LOG.info("Transitioning to standby");
-    if (haState == HAServiceProtocol.HAServiceState.ACTIVE) {
-      rm.stopActiveServices();
-      if (initialize) {
-        rm.createAndInitActiveServices();
-      }
-    }
-    haState = HAServiceProtocol.HAServiceState.STANDBY;
-    LOG.info("Transitioned to standby");
-  }
-
-  public synchronized void transitionToStandby(HAServiceProtocol.StateChangeRequestInfo reqInfo)
-      throws IOException {
+  public synchronized void transitionToStandby(
+      HAServiceProtocol.StateChangeRequestInfo reqInfo) throws IOException {
-      transitionToStandby(true);
+      rm.transitionToStandby(true);
+    HAServiceState haState = rmContext.getHAServiceState();
-    if (haState == HAServiceProtocol.HAServiceState.ACTIVE || haState ==
-        HAServiceProtocol.HAServiceState.STANDBY) {
+    if (isRMActive() || haState == HAServiceProtocol.HAServiceState.STANDBY) {
-  }
+  } 
-      throws YarnException {
+      throws YarnException, StandbyException {
-      throw new RMNotYetActiveException();
+      throwStandbyException();
-      throws YarnException {
+      throws YarnException, StandbyException {
-      throw new RMNotYetActiveException();
+      throwStandbyException();
-      throws YarnException {
+      throws YarnException, StandbyException {
-      throw new RMNotYetActiveException();
+      throwStandbyException();
-      RefreshUserToGroupsMappingsRequest request) throws YarnException {
+      RefreshUserToGroupsMappingsRequest request)
+      throws YarnException, StandbyException {
-      throw new RMNotYetActiveException();
+      throwStandbyException();
+  
+  @Override
+  public UpdateNodeResourceResponse updateNodeResource(
+      UpdateNodeResourceRequest request) throws YarnException, IOException {
+    Map<NodeId, ResourceOption> nodeResourceMap = request.getNodeResourceMap();
+    Set<NodeId> nodeIds = nodeResourceMap.keySet();
+    // verify nodes are all valid first. 
+    // if any invalid nodes, throw exception instead of partially updating
+    // valid nodes.
+    for (NodeId nodeId : nodeIds) {
+      RMNode node = this.rmContext.getRMNodes().get(nodeId);
+      if (node == null) {
+        LOG.error("Resource update get failed on all nodes due to change "
+            + "resource on an unrecognized node: " + nodeId);
+        throw RPCUtil.getRemoteException(
+            "Resource update get failed on all nodes due to change resource "
+                + "on an unrecognized node: " + nodeId);
+      }
+    }
+    
+    // do resource update on each node.
+    // Notice: it is still possible to have invalid NodeIDs as nodes decommission
+    // may happen just at the same time. This time, only log and skip absent
+    // nodes without throwing any exceptions.
+    for (Map.Entry<NodeId, ResourceOption> entry : nodeResourceMap.entrySet()) {
+      ResourceOption newResourceOption = entry.getValue();
+      NodeId nodeId = entry.getKey();
+      RMNode node = this.rmContext.getRMNodes().get(nodeId);
+      if (node == null) {
+        LOG.warn("Resource update get failed on an unrecognized node: " + nodeId);
+      } else {
+        node.setResourceOption(newResourceOption);
+        LOG.info("Update resource successfully on node(" + node.getNodeID()
+            +") with resource(" + newResourceOption.toString() + ")");
+      }
+    }
+    UpdateNodeResourceResponse response = recordFactory.newRecordInstance(
+          UpdateNodeResourceResponse.class);
+      return response;
+  }
+  

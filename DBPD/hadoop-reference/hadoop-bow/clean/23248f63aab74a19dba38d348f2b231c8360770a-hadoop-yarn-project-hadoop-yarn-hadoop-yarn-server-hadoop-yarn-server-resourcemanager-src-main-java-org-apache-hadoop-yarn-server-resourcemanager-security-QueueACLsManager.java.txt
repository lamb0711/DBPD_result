getApplicationReport call may raise NPE for removed queues. (Jian He via wangda)

+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.yarn.api.records.ApplicationId;
+import org.apache.hadoop.yarn.server.resourcemanager.ResourceTrackerService;
+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMApp;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CSQueue;
+
+  private static final Log LOG = LogFactory.getLog(QueueACLsManager.class);
+
-      String queueName, ApplicationId appId, String appName) {
+      RMApp app) {
+
-      return authorizer.checkPermission(new AccessRequest(
-          ((CapacityScheduler) scheduler).getQueue(queueName)
-              .getPrivilegedEntity(), callerUGI,
-          SchedulerUtils.toAccessType(acl), appId.toString(), appName));
+      CSQueue queue = ((CapacityScheduler) scheduler).getQueue(app.getQueue());
+      if (queue == null) {
+        // Application exists but the associated queue does not exist.
+        // This may be due to queue is removed after RM restarts. Here, we choose
+        // to allow users to be able to view the apps for removed queue.
+        LOG.error("Queue " + app.getQueue() + " does not exist for " + app
+            .getApplicationId());
+        return true;
+      }
+
+      return authorizer.checkPermission(
+          new AccessRequest(queue.getPrivilegedEntity(), callerUGI,
+              SchedulerUtils.toAccessType(acl),
+              app.getApplicationId().toString(), app.getName()));
-      return scheduler.checkAccess(callerUGI, acl, queueName);
+      return scheduler.checkAccess(callerUGI, acl, app.getQueue());

MAPREDUCE-7150. Optimize collections used by MR JHS to reduce its memory. (Contributed by Misha Dmitriev)

-  private final Map<String, Object[]> map =
-    new ConcurrentSkipListMap<String, Object[]>();
+  // Initialized lazily, since in some situations millions of empty maps can
+  // waste a substantial (e.g. 4% as we observed) portion of the heap
+  private Map<String, Object[]> map;
+    if (map == null) {
+      map = new ConcurrentSkipListMap<>();
+    }
-  public int size() {
+  public synchronized int size() {
-    for (Object[] counters : map.values()) {
-      n += numSetCounters(counters);
+    if (map != null) {
+      for (Object[] counters : map.values()) {
+        n += numSetCounters(counters);
+      }
-  public void write(DataOutput out) throws IOException {
-    WritableUtils.writeVInt(out, map.size()); // #scheme
-    for (Map.Entry<String, Object[]> entry : map.entrySet()) {
-      WritableUtils.writeString(out, entry.getKey()); // scheme
-      // #counter for the above scheme
-      WritableUtils.writeVInt(out, numSetCounters(entry.getValue()));
-      for (Object counter : entry.getValue()) {
-        if (counter == null) continue;
-        @SuppressWarnings("unchecked")
-        FSCounter c = (FSCounter) ((Counter)counter).getUnderlyingCounter();
-        WritableUtils.writeVInt(out, c.key.ordinal());  // key
-        WritableUtils.writeVLong(out, c.getValue());    // value
+  public synchronized void write(DataOutput out) throws IOException {
+    if (map != null) {
+      WritableUtils.writeVInt(out, map.size()); // #scheme
+      for (Map.Entry<String, Object[]> entry : map.entrySet()) {
+        WritableUtils.writeString(out, entry.getKey()); // scheme
+        // #counter for the above scheme
+        WritableUtils.writeVInt(out, numSetCounters(entry.getValue()));
+        for (Object counter : entry.getValue()) {
+          if (counter == null) continue;
+          @SuppressWarnings("unchecked")
+          FSCounter c = (FSCounter) ((Counter) counter).getUnderlyingCounter();
+          WritableUtils.writeVInt(out, c.key.ordinal());  // key
+          WritableUtils.writeVLong(out, c.getValue());    // value
+        }
+    } else {
+      WritableUtils.writeVInt(out, 0);
-      Iterator<Object[]> it = map.values().iterator();
-      Object[] counters = it.hasNext() ? it.next() : null;
+      Iterator<Object[]> it = map != null ? map.values().iterator() : null;
+      Object[] counters = (it != null && it.hasNext()) ? it.next() : null;
-          counters = it.hasNext() ? it.next() : null;
+          counters = (it != null && it.hasNext()) ? it.next() : null;
-    for (Object[] counters : map.values()) {
-      if (counters != null) hash ^= Arrays.hashCode(counters);
+    if (map != null) {
+      for (Object[] counters : map.values()) {
+        if (counters != null) hash ^= Arrays.hashCode(counters);
+      }

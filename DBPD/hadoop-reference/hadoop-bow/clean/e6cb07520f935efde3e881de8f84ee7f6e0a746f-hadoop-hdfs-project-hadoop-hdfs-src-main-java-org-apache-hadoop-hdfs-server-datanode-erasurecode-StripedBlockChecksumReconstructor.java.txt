HDFS-10460. Recompute block checksum for a particular range less than file size on the fly by reconstructing missed block. Contributed by Rakesh R

+import java.util.Arrays;
+  private long requestedLen;
-      DataOutputBuffer checksumWriter) throws IOException {
+      DataOutputBuffer checksumWriter,
+      long requestedBlockLength) throws IOException {
+    this.requestedLen = requestedBlockLength;
-    while (getPositionInBlock() < getMaxTargetLength()) {
-      long remaining = getMaxTargetLength() - getPositionInBlock();
+    long maxTargetLength = getMaxTargetLength();
+    while (requestedLen > 0 && getPositionInBlock() < maxTargetLength) {
+      long remaining = maxTargetLength - getPositionInBlock();
-      getChecksum().calculateChunkedSums(targetBuffer.array(), 0,
-          targetBuffer.remaining(), checksumBuf, 0);
+      checksumDataLen += checksumWithTargetOutput(targetBuffer.array(),
+          toReconstructLen, digester);
-      // step4: updates the digest using the checksum array of bytes
-      digester.update(checksumBuf, 0, checksumBuf.length);
-      checksumDataLen += checksumBuf.length;
+      requestedLen -= toReconstructLen;
+  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,
+      MessageDigest digester) throws IOException {
+    long checksumDataLength = 0;
+    // Calculate partial block checksum. There are two cases.
+    // case-1) length of data bytes which is fraction of bytesPerCRC
+    // case-2) length of data bytes which is less than bytesPerCRC
+    if (requestedLen <= toReconstructLen) {
+      int remainingLen = (int) requestedLen;
+      outputData = Arrays.copyOf(targetBuffer.array(), remainingLen);
+
+      int partialLength = remainingLen % getChecksum().getBytesPerChecksum();
+
+      int checksumRemaining = (remainingLen
+          / getChecksum().getBytesPerChecksum())
+          * getChecksum().getChecksumSize();
+
+      int dataOffset = 0;
+
+      // case-1) length of data bytes which is fraction of bytesPerCRC
+      if (checksumRemaining > 0) {
+        remainingLen = remainingLen - partialLength;
+        checksumBuf = new byte[checksumRemaining];
+        getChecksum().calculateChunkedSums(outputData, dataOffset,
+            remainingLen, checksumBuf, 0);
+        digester.update(checksumBuf, 0, checksumBuf.length);
+        checksumDataLength = checksumBuf.length;
+        dataOffset = remainingLen;
+      }
+
+      // case-2) length of data bytes which is less than bytesPerCRC
+      if (partialLength > 0) {
+        byte[] partialCrc = new byte[getChecksum().getChecksumSize()];
+        getChecksum().update(outputData, dataOffset, partialLength);
+        getChecksum().writeValue(partialCrc, 0, true);
+        digester.update(partialCrc);
+        checksumDataLength += partialCrc.length;
+      }
+
+      clearBuffers();
+      // calculated checksum for the requested length, return checksum length.
+      return checksumDataLength;
+    }
+    getChecksum().calculateChunkedSums(outputData, 0,
+        outputData.length, checksumBuf, 0);
+
+    // updates digest using the checksum array of bytes
+    digester.update(checksumBuf, 0, checksumBuf.length);
+    return checksumBuf.length;
+  }
+

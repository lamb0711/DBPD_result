HDFS-12521. Ozone: SCM should read all Container info into memory when booting up. Contributed by Lokesh Jain.

+import com.google.common.annotations.VisibleForTesting;
+import java.util.List;
+import java.util.Arrays;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
-  private final Lock writeLock;
+  private final ReadWriteLock lock;
-  public ContainerStateManager(Configuration configuration, final long
-      cacheSize) throws IOException {
+  public ContainerStateManager(Configuration configuration,
+      Mapping containerMapping, final long cacheSize) throws IOException {
-    writeLock = new ReentrantLock();
+    lock = new ReentrantReadWriteLock();
-    initializeContainerMaps(containers);
+    initializeContainerMaps();
+    loadExistingContainers(containerMapping);
-  private void initializeContainerMaps(Map containerMaps) {
+  private void initializeContainerMaps() {
-    Preconditions.checkNotNull(containerMaps);
+    Preconditions.checkNotNull(containers);
-            containerMaps.put(key, queue);
+            containers.put(key, queue);
+  /**
+   * Load containers from the container store into the containerMaps.
+   *
+   * @param containerMapping -- Mapping object containing container store.
+   */
+  private void loadExistingContainers(Mapping containerMapping) {
+    try {
+      List<ContainerInfo> containerList =
+          containerMapping.listContainer(null, null, Integer.MAX_VALUE);
+      for (ContainerInfo container : containerList) {
+        ContainerKey key = new ContainerKey(container.getOwner(),
+            container.getPipeline().getType(),
+            container.getPipeline().getFactor(), container.getState());
+        BlockContainerInfo blockContainerInfo =
+            new BlockContainerInfo(container, 0);
+        ((PriorityQueue) containers.get(key)).add(blockContainerInfo);
+      }
+    } catch (IOException e) {
+      if (!e.getMessage().equals("No container exists in current db")) {
+        LOG.info("Could not list the containers", e);
+      }
+    }
+  }
+
-    writeLock.lock();
+    lock.writeLock().lock();
-      writeLock.unlock();
+      lock.writeLock().unlock();
-    writeLock.lock();
+    lock.writeLock().lock();
-      writeLock.unlock();
+      lock.writeLock().unlock();
-    writeLock.lock();
+    lock.writeLock().lock();
-        if (info.getAllocated() < this.containerSize + size) {
+        if (info.getAllocated() + size <= this.containerSize) {
-      writeLock.unlock();
+      lock.writeLock().unlock();
+    }
+    return null;
+  }
+
+  @VisibleForTesting
+  public List<BlockContainerInfo> getMatchingContainers(Owner owner,
+      ReplicationType type, ReplicationFactor factor, LifeCycleState state) {
+    ContainerKey key = new ContainerKey(owner, type, factor, state);
+    lock.readLock().lock();
+    try {
+      return Arrays.asList((BlockContainerInfo[]) containers.get(key)
+          .toArray(new BlockContainerInfo[0]));
+    } catch (Exception e) {
+      LOG.error("Could not get matching containers", e);
+    } finally {
+      lock.readLock().unlock();

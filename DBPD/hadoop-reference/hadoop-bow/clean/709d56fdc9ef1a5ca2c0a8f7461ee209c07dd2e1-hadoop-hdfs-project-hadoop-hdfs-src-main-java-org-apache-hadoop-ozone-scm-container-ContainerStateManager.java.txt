HDFS-12474. Ozone: SCM: Handling container report with key count and container usage. Contributed by Nanda kumar.

-import org.apache.hadoop.scm.container.common.helpers.BlockContainerInfo;
+import java.io.Closeable;
-import static org.apache.hadoop.ozone.scm.exceptions.SCMException.ResultCodes.FAILED_TO_CHANGE_CONTAINER_STATE;
+import static org.apache.hadoop.ozone.scm.exceptions
+    .SCMException.ResultCodes.FAILED_TO_CHANGE_CONTAINER_STATE;
-public class ContainerStateManager {
+public class ContainerStateManager implements Closeable {
-  private final Queue<BlockContainerInfo> containerCloseQueue;
-  private Map<ContainerKey, PriorityQueue<BlockContainerInfo>> containers;
+  private final Queue<ContainerInfo> containerCloseQueue;
+  private Map<ContainerKey, PriorityQueue<ContainerInfo>> containers;
-    containerCloseQueue = new ConcurrentLinkedQueue<BlockContainerInfo>();
+    containerCloseQueue = new ConcurrentLinkedQueue<>();
-            PriorityQueue<BlockContainerInfo> queue = new PriorityQueue<>();
+            PriorityQueue<ContainerInfo> queue = new PriorityQueue<>();
-        BlockContainerInfo blockContainerInfo =
-            new BlockContainerInfo(container, 0);
-        ((PriorityQueue) containers.get(key)).add(blockContainerInfo);
+        containers.get(key).add(container);
-    ContainerInfo info = new ContainerInfo.Builder()
+    ContainerInfo containerInfo = new ContainerInfo.Builder()
+        // This is bytes allocated for blocks inside container, not the
+        // container size
+        .setAllocatedBytes(0)
+        .setUsedBytes(0)
+        .setNumberOfKeys(0)
-    Preconditions.checkNotNull(info);
-    BlockContainerInfo blockInfo = new BlockContainerInfo(info, 0);
-    blockInfo.setLastUsed(Time.monotonicNow());
+    Preconditions.checkNotNull(containerInfo);
-          blockInfo.getState());
-      PriorityQueue<BlockContainerInfo> queue = containers.get(key);
+          containerInfo.getState());
+      PriorityQueue<ContainerInfo> queue = containers.get(key);
-      queue.add(blockInfo);
-      LOG.trace("New container allocated: {}", blockInfo);
+      queue.add(containerInfo);
+      LOG.trace("New container allocated: {}", containerInfo);
-    return info;
+    return containerInfo;
-   * @return New state of the container.
+   * @return Updated ContainerInfo.
-  public OzoneProtos.LifeCycleState updateContainerState(BlockContainerInfo
+  public ContainerInfo updateContainerState(ContainerInfo
-    LifeCycleState newState = null;
-    boolean shouldLease = false;
+    LifeCycleState newState;
-      if(newState == LifeCycleState.CREATING) {
-        // if we are moving into a Creating State, it is possible that clients
-        // could timeout therefore we need to use a lease.
-        shouldLease = true;
-      }
-      PriorityQueue<BlockContainerInfo> currentQueue = containers.get(oldKey);
+      PriorityQueue<ContainerInfo> currentQueue = containers.get(oldKey);
-      info.setState(newState);
-      PriorityQueue<BlockContainerInfo> nextQueue = containers.get(newKey);
+      PriorityQueue<ContainerInfo> nextQueue = containers.get(newKey);
-      info.setLastUsed(Time.monotonicNow());
-      nextQueue.add(info);
+      ContainerInfo containerInfo = new ContainerInfo.Builder()
+          .setContainerName(info.getContainerName())
+          .setState(newState)
+          .setPipeline(info.getPipeline())
+          .setAllocatedBytes(info.getAllocatedBytes())
+          .setUsedBytes(info.getUsedBytes())
+          .setNumberOfKeys(info.getNumberOfKeys())
+          .setStateEnterTime(Time.monotonicNow())
+          .setOwner(info.getOwner())
+          .build();
+      Preconditions.checkNotNull(containerInfo);
+      nextQueue.add(containerInfo);
-      return newState;
+      return containerInfo;
-   * @return BlockContainerInfo
+   * @return ContainerInfo
-  public BlockContainerInfo getMatchingContainer(final long size,
+  public ContainerInfo getMatchingContainer(final long size,
-      PriorityQueue<BlockContainerInfo> queue = containers.get(key);
+      PriorityQueue<ContainerInfo> queue = containers.get(key);
-      Iterator<BlockContainerInfo> iter = queue.iterator();
+      Iterator<ContainerInfo> iter = queue.iterator();
-        BlockContainerInfo info = iter.next();
-        if (info.canAllocate(size, this.containerSize)) {
+        ContainerInfo info = iter.next();
+        if (info.getAllocatedBytes() + size <= this.containerSize) {
-          info.addAllocated(size);
-          info.setLastUsed(Time.monotonicNow());
+          info.allocate(size);
+          info.updateLastUsedTime();
-        } else {
-          if (info.getState() != LifeCycleState.CLOSED) {
-            // We should close this container.
-            LOG.info("Moving {} to containerCloseQueue.", info.toString());
-            info.setState(LifeCycleState.CLOSED);
-            containerCloseQueue.add(info);
-            //TODO: Next JIRA will handle these containers to close.
-            //TODO: move container to right queue
-          }
-  public List<BlockContainerInfo> getMatchingContainers(Owner owner,
+  public List<ContainerInfo> getMatchingContainers(Owner owner,
-      return Arrays.asList((BlockContainerInfo[]) containers.get(key)
-          .toArray(new BlockContainerInfo[0]));
+      return Arrays.asList((ContainerInfo[]) containers.get(key)
+          .toArray(new ContainerInfo[0]));
+  @Override
+  public void close() throws IOException {
+    //TODO: update container metadata db with actual allocated bytes values.
+  }
+

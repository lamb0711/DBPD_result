YARN-9265. FPGA plugin fails to recognize Intel Processing Accelerator Card. Contributed by Peter Bacsko.

-import com.google.common.annotations.VisibleForTesting;
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import org.apache.hadoop.fs.FileUtil;
+import org.apache.hadoop.util.Shell.ShellCommandExecutor;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.resourceplugin.fpga.discovery.AoclOutputBasedDiscoveryStrategy;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.resourceplugin.fpga.discovery.FPGADiscoveryStrategy;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.resourceplugin.fpga.discovery.ScriptBasedFPGADiscoveryStrategy;
+import org.apache.hadoop.yarn.server.nodemanager.containermanager.resourceplugin.fpga.discovery.SettingsBasedFPGADiscoveryStrategy;
-import java.util.Iterator;
-import java.util.List;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Sets;
-
-  public static final Logger LOG = LoggerFactory.getLogger(
+  private static final Logger LOG = LoggerFactory.getLogger(
+  private Function<String, Optional<String>> scriptRunner = this::runScript;
+
-  private static final int MAX_EXEC_TIMEOUT_MS = 10 * 1000;
+  public static final int MAX_EXEC_TIMEOUT_MS = 10 * 1000;
-  public synchronized static FpgaDiscoverer setInstance(FpgaDiscoverer newInstance) {
+  void setScriptRunner(Function<String, Optional<String>> scriptRunner) {
+    this.scriptRunner = scriptRunner;
+  }
+
+  @VisibleForTesting
+  static void reset() {
+    instance = new FpgaDiscoverer();
+  }
+
+  @VisibleForTesting
+  public static FpgaDiscoverer setInstance(FpgaDiscoverer newInstance) {
-  public synchronized void setConf(Configuration conf) {
-    this.conf = conf;
+  public void setConf(Configuration configuration) {
+    this.conf = configuration;
-  public synchronized void setResourceHanderPlugin(AbstractFpgaVendorPlugin plugin) {
-    this.plugin = plugin;
+  public void setResourceHanderPlugin(AbstractFpgaVendorPlugin vendorPlugin) {
+    this.plugin = vendorPlugin;
-  public synchronized boolean diagnose() {
+  public boolean diagnose() {
-  public synchronized void initialize(Configuration conf) throws YarnException {
-    this.conf = conf;
-    this.plugin.initPlugin(conf);
+  public void initialize(Configuration config) throws YarnException {
+    this.conf = config;
+    this.plugin.initPlugin(config);
-  public synchronized List<FpgaResourceAllocator.FpgaDevice> discover() throws ResourceHandlerException {
+  public List<FpgaResourceAllocator.FpgaDevice> discover()
+      throws ResourceHandlerException {
-    // whatever static or auto discover, we always needs
-    // the vendor plugin to discover. For instance, IntelFpgaOpenclPlugin need to
-    // setup a mapping of <major:minor> to <aliasDevName>
-    list = this.plugin.discover(MAX_EXEC_TIMEOUT_MS);
-    if (0 == list.size()) {
-      throw new ResourceHandlerException("No FPGA devices detected!");
+
+    String availableDevices = conf.get(
+        YarnConfiguration.NM_FPGA_AVAILABLE_DEVICES);
+    String discoveryScript = conf.get(
+        YarnConfiguration.NM_FPGA_DEVICE_DISCOVERY_SCRIPT);
+
+    FPGADiscoveryStrategy discoveryStrategy;
+    if (availableDevices != null) {
+      discoveryStrategy =
+          new SettingsBasedFPGADiscoveryStrategy(
+              plugin.getFpgaType(), availableDevices);
+    } else if (discoveryScript != null) {
+      discoveryStrategy =
+          new ScriptBasedFPGADiscoveryStrategy(
+              plugin.getFpgaType(), scriptRunner, discoveryScript);
+    } else {
+      discoveryStrategy = new AoclOutputBasedDiscoveryStrategy(plugin);
-    currentFpgaInfo = list;
-    if (allowed.equalsIgnoreCase(
+
+    list = discoveryStrategy.discover();
+
+    if (allowed == null || allowed.equalsIgnoreCase(
-        return list;
+      return list;
-      String[] minors = allowed.split(",");
-      Iterator<FpgaResourceAllocator.FpgaDevice> iterator = list.iterator();
-      // remove the non-configured minor numbers
-      FpgaResourceAllocator.FpgaDevice t;
-      while (iterator.hasNext()) {
-        boolean valid = false;
-        t = iterator.next();
-        for (String minorNumber : minors) {
-          if (t.getMinor().toString().equals(minorNumber)) {
-            valid = true;
-            break;
-          }
-        }
-        if (!valid) {
-          iterator.remove();
-        }
-      }
+      Set<String> minors = Sets.newHashSet(allowed.split(","));
+
+      // Replace list with a filtered one
+      list = list
+        .stream()
+        .filter(dev -> minors.contains(dev.getMinor().toString()))
+        .collect(Collectors.toList());
+
-      if (list.size() != minors.length) {
+      if (list.size() != minors.size()) {
+
+    currentFpgaInfo = ImmutableList.copyOf(list);
+
+  private Optional<String> runScript(String path) {
+    if (path == null || path.trim().isEmpty()) {
+      LOG.error("Undefined script");
+      return Optional.empty();
+    }
+
+    File f = new File(path);
+    if (!f.exists()) {
+      LOG.error("Script does not exist");
+      return Optional.empty();
+    }
+
+    if (!FileUtil.canExecute(f)) {
+      LOG.error("Script is not executable");
+      return Optional.empty();
+    }
+
+    ShellCommandExecutor shell = new ShellCommandExecutor(
+        new String[] {path},
+        null,
+        null,
+        MAX_EXEC_TIMEOUT_MS);
+    try {
+      shell.execute();
+      String output = shell.getOutput();
+      return Optional.of(output);
+    } catch (IOException e) {
+      LOG.error("Cannot execute script", e);
+      return Optional.empty();
+    }
+  }

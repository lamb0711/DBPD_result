HDDS-1148. After allocating container, we are not adding to container DB.



+import org.apache.hadoop.hdds.scm.ScmConfigKeys;
+import java.util.NavigableSet;
+  private final int numContainerPerOwnerInPipeline;
+    this.numContainerPerOwnerInPipeline = conf
+        .getInt(ScmConfigKeys.OZONE_SCM_PIPELINE_OWNER_CONTAINER_COUNT,
+            ScmConfigKeys.OZONE_SCM_PIPELINE_OWNER_CONTAINER_COUNT_DEFAULT);
+
-      final ContainerInfo containerInfo; containerInfo = containerStateManager
-          .allocateContainer(pipelineManager, type, replicationFactor, owner);
-      try {
-        final byte[] containerIDBytes = Longs.toByteArray(
-            containerInfo.getContainerID());
-        containerStore.put(containerIDBytes,
-            containerInfo.getProtobuf().toByteArray());
-      } catch (IOException ex) {
-        // If adding to containerStore fails, we should remove the container
-        // from in-memory map.
-        try {
-          containerStateManager.removeContainer(containerInfo.containerID());
-        } catch (ContainerNotFoundException cnfe) {
-          // No need to worry much, everything is going as planned.
-        }
-        throw ex;
-      }
+      final ContainerInfo containerInfo =
+          containerStateManager.allocateContainer(pipelineManager, type,
+              replicationFactor, owner);
+      // Add container to DB.
+      addContainerToDB(containerInfo);
-      return containerStateManager
-          .getMatchingContainer(sizeRequired, owner, pipelineManager,
-              pipeline);
+      NavigableSet<ContainerID> containerIDs =
+          pipelineManager.getContainersInPipeline(pipeline.getId());
+
+      containerIDs = getContainersForOwner(containerIDs, owner);
+      if (containerIDs.size() < numContainerPerOwnerInPipeline) {
+        synchronized (pipeline) {
+          // TODO: #CLUTIL Maybe we can add selection logic inside synchronized
+          // as well
+          containerIDs = getContainersForOwner(
+              pipelineManager.getContainersInPipeline(pipeline.getId()), owner);
+          if (containerIDs.size() < numContainerPerOwnerInPipeline) {
+            ContainerInfo containerInfo =
+                containerStateManager.allocateContainer(pipelineManager, owner,
+                    pipeline);
+            // Add to DB
+            addContainerToDB(containerInfo);
+            containerStateManager.updateLastUsedMap(pipeline.getId(),
+                containerInfo.containerID(), owner);
+            return containerInfo;
+          }
+        }
+      }
+
+      ContainerInfo containerInfo =
+          containerStateManager.getMatchingContainer(sizeRequired, owner,
+              pipeline.getId(), containerIDs);
+      if (containerInfo == null) {
+        synchronized (pipeline) {
+          containerInfo =
+              containerStateManager.allocateContainer(pipelineManager, owner,
+                  pipeline);
+          // Add to DB
+          addContainerToDB(containerInfo);
+        }
+      }
+      containerStateManager.updateLastUsedMap(pipeline.getId(),
+          containerInfo.containerID(), owner);
+      // TODO: #CLUTIL cleanup entries in lastUsedMap
+      return containerInfo;
+   * Add newly allocated container to container DB.
+   * @param containerInfo
+   * @throws IOException
+   */
+  private void addContainerToDB(ContainerInfo containerInfo)
+      throws IOException {
+    try {
+      final byte[] containerIDBytes = Longs.toByteArray(
+          containerInfo.getContainerID());
+      containerStore.put(containerIDBytes,
+          containerInfo.getProtobuf().toByteArray());
+    } catch (IOException ex) {
+      // If adding to containerStore fails, we should remove the container
+      // from in-memory map.
+      try {
+        containerStateManager.removeContainer(containerInfo.containerID());
+      } catch (ContainerNotFoundException cnfe) {
+        // This should not happen, as we are removing after adding in to
+        // container state cmap.
+      }
+      throw ex;
+    }
+  }
+
+  /**
+   * Returns the container ID's matching with specified owner.
+   * @param containerIDs
+   * @param owner
+   * @return NavigableSet<ContainerID>
+   */
+  private NavigableSet<ContainerID> getContainersForOwner(
+      NavigableSet<ContainerID> containerIDs, String owner) {
+    for (ContainerID cid : containerIDs) {
+      try {
+        if (!getContainer(cid).getOwner().equals(owner)) {
+          containerIDs.remove(cid);
+        }
+      } catch (ContainerNotFoundException e) {
+        LOG.error("Could not find container info for container id={} {}", cid,
+            e);
+        containerIDs.remove(cid);
+      }
+    }
+    return containerIDs;
+  }
+
+
+
+  /**

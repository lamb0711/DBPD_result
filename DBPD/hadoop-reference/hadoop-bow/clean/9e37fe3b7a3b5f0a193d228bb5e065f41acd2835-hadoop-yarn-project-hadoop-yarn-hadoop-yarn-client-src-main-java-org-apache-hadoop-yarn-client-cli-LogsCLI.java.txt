YARN-4905. Improved "yarn logs" command-line to optionally show log metadata also. Contributed by Xuan Gong.

+import org.apache.hadoop.yarn.api.records.ContainerId;
+  private static final String SHOW_META_INFO = "show_meta_info";
+  private static final String LIST_NODES_OPTION = "list_nodes";
-    Options opts = new Options();
-    opts.addOption(HELP_CMD, false, "Displays help for all commands.");
-    Option appIdOpt =
-        new Option(APPLICATION_ID_OPTION, true, "ApplicationId (required)");
-    appIdOpt.setRequired(true);
-    opts.addOption(appIdOpt);
-    opts.addOption(CONTAINER_ID_OPTION, true, "ContainerId. "
-        + "By default, it will only print syslog if the application is runing."
-        + " Work with -logFiles to get other logs.");
-    opts.addOption(NODE_ADDRESS_OPTION, true, "NodeAddress in the format "
-      + "nodename:port");
-    opts.addOption(APP_OWNER_OPTION, true,
-      "AppOwner (assumed to be current user if not specified)");
-    Option amOption = new Option(AM_CONTAINER_OPTION, true, 
-      "Prints the AM Container logs for this application. "
-      + "Specify comma-separated value to get logs for related AM Container. "
-      + "For example, If we specify -am 1,2, we will get the logs for "
-      + "the first AM Container as well as the second AM Container. "
-      + "To get logs for all AM Containers, use -am ALL. "
-      + "To get logs for the latest AM Container, use -am -1. "
-      + "By default, it will only print out syslog. Work with -logFiles "
-      + "to get other logs");
-    amOption.setValueSeparator(',');
-    amOption.setArgs(Option.UNLIMITED_VALUES);
-    amOption.setArgName("AM Containers");
-    opts.addOption(amOption);
-    Option logFileOpt = new Option(CONTAINER_LOG_FILES, true,
-      "Work with -am/-containerId and specify comma-separated value "
-        + "to get specified container log files. Use \"ALL\" to fetch all the "
-        + "log files for the container.");
-    logFileOpt.setValueSeparator(',');
-    logFileOpt.setArgs(Option.UNLIMITED_VALUES);
-    logFileOpt.setArgName("Log File Name");
-    opts.addOption(logFileOpt);
+    Options opts = createCommandOpts();
-    opts.getOption(APPLICATION_ID_OPTION).setArgName("Application ID");
-    opts.getOption(CONTAINER_ID_OPTION).setArgName("Container ID");
-    opts.getOption(NODE_ADDRESS_OPTION).setArgName("Node Address");
-    opts.getOption(APP_OWNER_OPTION).setArgName("Application Owner");
-    opts.getOption(AM_CONTAINER_OPTION).setArgName("AM Containers");
-
-    Options printOpts = new Options();
-    printOpts.addOption(opts.getOption(HELP_CMD));
-    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));
-    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));
-    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));
-    printOpts.addOption(opts.getOption(AM_CONTAINER_OPTION));
-    printOpts.addOption(opts.getOption(CONTAINER_LOG_FILES));
+    Options printOpts = createPrintOpts(opts);
+    boolean showMetaInfo = false;
+    boolean nodesList = false;
+      showMetaInfo = commandLine.hasOption(SHOW_META_INFO);
+      nodesList = commandLine.hasOption(LIST_NODES_OPTION);
-        String[] amContainers = commandLine.getOptionValues(AM_CONTAINER_OPTION);
-        for (String am : amContainers) {
-          boolean errorInput = false;
-          if (!am.trim().equalsIgnoreCase("ALL")) {
-            try {
-              int id = Integer.parseInt(am.trim());
-              if (id != -1 && id <= 0) {
-                errorInput = true;
-              }
-            } catch (NumberFormatException ex) {
-              errorInput = true;
-            }
-            if (errorInput) {
-              System.err.println(
-                "Invalid input for option -am. Valid inputs are 'ALL', -1 "
-                + "and any other integer which is larger than 0.");
-              printHelpMessage(printOpts);
-              return -1;
-            }
-            amContainersList.add(am.trim());
-          } else {
-            amContainersList.add("ALL");
-            break;
-          }
+        try {
+          amContainersList = parseAMContainer(commandLine, printOpts);
+        } catch (NumberFormatException ex) {
+          System.err.println(ex.getMessage());
+          return -1;
-    boolean appStateKnown = true;
+    boolean appStateObtainedSuccessfully = true;
-        System.out.println("Logs are not avaiable right now.");
+        System.err.println("Logs are not avaiable right now.");
-      appStateKnown = false;
+      appStateObtainedSuccessfully = false;
+    if (showMetaInfo) {
+      return showMetaInfo(appState, appStateObtainedSuccessfully,
+          logCliHelper, appId, containerIdStr, nodeAddress, appOwner);
+    }
+
+    if (nodesList) {
+      return showNodeLists(appState, appStateObtainedSuccessfully,
+          logCliHelper, appId, appOwner);
+    }
-      // if we do not specify the value for CONTAINER_LOG_FILES option,
-      // we will only output syslog
-      if (logFiles == null || logFiles.length == 0) {
-        logFiles = new String[] { "syslog" };
-      }
-      // If the application is running, we will call the RM WebService
-      // to get the AppAttempts which includes the nodeHttpAddress
-      // and containerId for all the AM Containers.
-      // After that, we will call NodeManager webService to get the
-      // related logs
-      if (appState == YarnApplicationState.ACCEPTED
-          || appState == YarnApplicationState.RUNNING) {
-        return printAMContainerLogs(getConf(), appIdStr, amContainersList,
-          logFiles, logCliHelper, appOwner, false);
-      } else {
-        // If the application is in the final state, we will call RM webservice
-        // to get all AppAttempts information first. If we get nothing,
-        // we will try to call AHS webservice to get related AppAttempts
-        // which includes nodeAddress for the AM Containers.
-        // After that, we will use nodeAddress and containerId
-        // to get logs from HDFS directly.
-        if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,
-          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {
-          return printAMContainerLogs(getConf(), appIdStr, amContainersList,
-            logFiles, logCliHelper, appOwner, true);
-        } else {
-          System.out
-            .println(
-                "Can not get AMContainers logs for the application:" + appId);
-          System.out.println("This application:" + appId + " is finished."
-              + " Please enable the application history service. Or Using "
-              + "yarn logs -applicationId <appId> -containerId <containerId> "
-              + "--nodeAddress <nodeHttpAddress> to get the container logs");
-          return -1;
-        }
-      }
+      return fetchAMContainerLogs(logFiles, appState, appId, appOwner,
+          amContainersList, logCliHelper);
-      // if we provide the node address and the application is in the final
-      // state, we could directly get logs from HDFS.
-      if (nodeAddress != null && (!appStateKnown ||
-          isApplicationFinished(appState))) {
-        // if user specified "ALL" as the logFiles param, pass null
-        // to logCliHelper so that it fetches all the logs
-        List<String> logs;
-        if (logFiles == null) {
-          logs = null;
-        } else if (fetchAllLogFiles(logFiles)) {
-          logs = null;
-        } else {
-          logs = Arrays.asList(logFiles);
-        }
-        return logCliHelper.dumpAContainersLogsForALogType(appIdStr,
-            containerIdStr, nodeAddress, appOwner, logs);
+      ContainerId containerId = ContainerId.fromString(containerIdStr);
+      if (!containerId.getApplicationAttemptId().getApplicationId()
+          .equals(appId)) {
+        System.err.println("The Application:" + appId
+            + " does not have the container:" + containerId);
+        return -1;
-      String nodeHttpAddress = null;
-      String nodeId = null;
-      try {
-        // If the nodeAddress is not provided, we will try to get
-        // the ContainerReport. In the containerReport, we could get
-        // nodeAddress and nodeHttpAddress
-        ContainerReport report = getContainerReport(containerIdStr);
-        nodeHttpAddress =
-            report.getNodeHttpAddress().replaceFirst(
-              WebAppUtils.getHttpSchemePrefix(getConf()), "");
-        nodeId = report.getAssignedNode().toString();
-      } catch (IOException | YarnException ex) {
-        if (!appStateKnown || isApplicationFinished(appState)) {
-          String [] requestedLogFiles = logFiles;
-          if(fetchAllLogFiles(logFiles)) {
-            requestedLogFiles = null;
-          }
-          return printContainerLogsForFinishedApplicationWithoutNodeId(
-              appIdStr, containerIdStr, requestedLogFiles, logCliHelper,
-              appOwner);
-        } else if (!isApplicationFinished(appState)) {
-          System.err.println("Unable to get logs for this container:"
-              + containerIdStr + "for the application:" + appId);
-          System.out.println("The application: " + appId + " is still running, "
-              + "and we can not get Container report for the container: "
-              + containerIdStr +". Please try later or after the application "
-              + "finishes.");
-          return -1;
-        }
-      }
-      // If the application is not in the final state,
-      // we will provide the NodeHttpAddress and get the container logs
-      // by calling NodeManager webservice.
-      if (!isApplicationFinished(appState)) {
-        if (logFiles == null || logFiles.length == 0) {
-          logFiles = new String[] {"syslog"};
-        }
-        printContainerLogsFromRunningApplication(getConf(), appIdStr,
-            containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,
-            appOwner);
-      } else {
-        String[] requestedLogFiles = logFiles;
-        if(fetchAllLogFiles(logFiles)) {
-          requestedLogFiles = null;
-        }
-        // If the application is in the final state, we will directly
-        // get the container logs from HDFS.
-        printContainerLogsForFinishedApplication(appIdStr, containerIdStr,
-            nodeId, requestedLogFiles, logCliHelper, appOwner);
-      }
-      return resultCode;
+      return fetchContainerLogs(appState, appStateObtainedSuccessfully,
+          logFiles, appOwner, nodeAddress, containerId, logCliHelper);
-        System.out.println("Should at least provide ContainerId!");
+        System.err.println("Should at least provide ContainerId!");
-    formatter.printHelp("yarn logs -applicationId <application ID> [OPTIONS]", new Options());
+    formatter.printHelp("yarn logs -applicationId <application ID> [OPTIONS]",
+        new Options());
-  private List<JSONObject> getAMContainerInfoForAHSWebService(Configuration conf,
-      String appId) throws ClientHandlerException, UniformInterfaceException,
-      JSONException {
+  private List<JSONObject> getAMContainerInfoForAHSWebService(
+      Configuration conf, String appId) throws ClientHandlerException,
+      UniformInterfaceException, JSONException {
-        webResource.path("ws").path("v1").path("applicationhistory").path("apps")
-          .path(appId).path("appattempts").accept(MediaType.APPLICATION_JSON)
+        webResource.path("ws").path("v1").path("applicationhistory")
+          .path("apps").path(appId).path("appattempts")
+          .accept(MediaType.APPLICATION_JSON)
-          System.out.println("Unable to parse xml from webservice. Error:");
-          System.out.println(e.getMessage());
+          System.err.println("Unable to parse xml from webservice. Error:");
+          System.err.println(e.getMessage());
-      System.out.println("Unable to fetch log files list");
+      System.err.println("Unable to fetch log files list");
-      String appId, String containerIdStr, String nodeHttpAddress,
+      ContainerId containerId, String nodeHttpAddress,
-    String [] requestedLogFiles = logFiles;
+    String appId = containerId.getApplicationAttemptId()
+        .getApplicationId().toString();
+    String containerIdStr = containerId.toString();
+    String[] requestedLogFiles = logFiles;
-        System.out.println("Can not find the log file:" + logFile
+        System.err.println("Can not find the log file:" + logFile
-      nodeAddress, appOwner, logFiles != null ? Arrays.asList(logFiles) : null);
+        nodeAddress, appOwner, logFiles != null ? Arrays.asList(logFiles)
+        : null);
-          appOwner);
+            appOwner);
-            logFiles, logCliHelper, appOwner);
+              logFiles, logCliHelper, appOwner);
-              logFiles, logCliHelper, appOwner);
+                logFiles, logCliHelper, appOwner);
-          String [] requestedLogFilesList = null;
+          String[] requestedLogFilesList = null;
-            requestedLogFilesList, logCliHelper, appOwner);
+              requestedLogFilesList, logCliHelper, appOwner);
-        String [] requestedLogFiles = logFiles;
+        String[] requestedLogFiles = logFiles;
-        printContainerLogsFromRunningApplication(conf, appId, containerId,
-          nodeHttpAddress, nodeId, requestedLogFiles, logCliHelper, appOwner);
+        printContainerLogsFromRunningApplication(conf,
+            ContainerId.fromString(containerId), nodeHttpAddress, nodeId,
+            requestedLogFiles, logCliHelper, appOwner);
+  private int showMetaInfo(YarnApplicationState appState,
+      boolean appStateObtainedSuccessfully, LogCLIHelpers logCliHelper,
+      ApplicationId appId, String containerIdStr, String nodeAddress,
+      String appOwner) throws IOException {
+    if (!isApplicationFinished(appState) && appStateObtainedSuccessfully) {
+      System.err.println("The -show_meta_info command can be only used "
+          + "with finished applications");
+      return -1;
+    } else {
+      logCliHelper.printLogMetadata(appId, containerIdStr, nodeAddress,
+          appOwner, System.out, System.err);
+      return 0;
+    }
+  }
+
+  private int showNodeLists(YarnApplicationState appState,
+      boolean appStateObtainedSuccessfully, LogCLIHelpers logCliHelper,
+      ApplicationId appId, String appOwner) throws IOException {
+    if (!isApplicationFinished(appState) && appStateObtainedSuccessfully) {
+      System.err.println("The -list_nodes command can be only used with "
+          + "finished applications");
+      return -1;
+    } else {
+      logCliHelper.printNodesList(appId, appOwner, System.out, System.err);
+      return 0;
+    }
+  }
+
+  private Options createCommandOpts() {
+    Options opts = new Options();
+    opts.addOption(HELP_CMD, false, "Displays help for all commands.");
+    Option appIdOpt =
+        new Option(APPLICATION_ID_OPTION, true, "ApplicationId (required)");
+    appIdOpt.setRequired(true);
+    opts.addOption(appIdOpt);
+    opts.addOption(CONTAINER_ID_OPTION, true, "ContainerId. "
+        + "By default, it will only print syslog if the application is runing."
+        + " Work with -logFiles to get other logs.");
+    opts.addOption(NODE_ADDRESS_OPTION, true, "NodeAddress in the format "
+        + "nodename:port");
+    opts.addOption(APP_OWNER_OPTION, true,
+        "AppOwner (assumed to be current user if not specified)");
+    Option amOption = new Option(AM_CONTAINER_OPTION, true,
+        "Prints the AM Container logs for this application. "
+        + "Specify comma-separated value to get logs for related AM "
+        + "Container. For example, If we specify -am 1,2, we will get "
+        + "the logs for the first AM Container as well as the second "
+        + "AM Container. To get logs for all AM Containers, use -am ALL. "
+        + "To get logs for the latest AM Container, use -am -1. "
+        + "By default, it will only print out syslog. Work with -logFiles "
+        + "to get other logs");
+    amOption.setValueSeparator(',');
+    amOption.setArgs(Option.UNLIMITED_VALUES);
+    amOption.setArgName("AM Containers");
+    opts.addOption(amOption);
+    Option logFileOpt = new Option(CONTAINER_LOG_FILES, true,
+        "Work with -am/-containerId and specify comma-separated value "
+        + "to get specified container log files. Use \"ALL\" to fetch all the "
+        + "log files for the container.");
+    logFileOpt.setValueSeparator(',');
+    logFileOpt.setArgs(Option.UNLIMITED_VALUES);
+    logFileOpt.setArgName("Log File Name");
+    opts.addOption(logFileOpt);
+    opts.addOption(SHOW_META_INFO, false, "Show the log metadata, "
+        + "including log-file names, the size of the log files. "
+        + "You can combine this with --containerId to get log metadata for "
+        + "the specific container, or with --nodeAddress to get log metadata "
+        + "for all the containers on the specific NodeManager. "
+        + "Currently, this option can only be used for finished "
+        + "applications.");
+    opts.addOption(LIST_NODES_OPTION, false,
+        "Show the list of nodes that successfully aggregated logs. "
+        + "This option can only be used with finished applications.");
+    opts.getOption(APPLICATION_ID_OPTION).setArgName("Application ID");
+    opts.getOption(CONTAINER_ID_OPTION).setArgName("Container ID");
+    opts.getOption(NODE_ADDRESS_OPTION).setArgName("Node Address");
+    opts.getOption(APP_OWNER_OPTION).setArgName("Application Owner");
+    opts.getOption(AM_CONTAINER_OPTION).setArgName("AM Containers");
+    return opts;
+  }
+
+  private Options createPrintOpts(Options commandOpts) {
+    Options printOpts = new Options();
+    printOpts.addOption(commandOpts.getOption(HELP_CMD));
+    printOpts.addOption(commandOpts.getOption(CONTAINER_ID_OPTION));
+    printOpts.addOption(commandOpts.getOption(NODE_ADDRESS_OPTION));
+    printOpts.addOption(commandOpts.getOption(APP_OWNER_OPTION));
+    printOpts.addOption(commandOpts.getOption(AM_CONTAINER_OPTION));
+    printOpts.addOption(commandOpts.getOption(CONTAINER_LOG_FILES));
+    printOpts.addOption(commandOpts.getOption(SHOW_META_INFO));
+    printOpts.addOption(commandOpts.getOption(LIST_NODES_OPTION));
+    return printOpts;
+  }
+
+  private List<String> parseAMContainer(CommandLine commandLine,
+      Options printOpts) throws NumberFormatException {
+    List<String> amContainersList = new ArrayList<String>();
+    String[] amContainers = commandLine.getOptionValues(AM_CONTAINER_OPTION);
+    for (String am : amContainers) {
+      boolean errorInput = false;
+      if (!am.trim().equalsIgnoreCase("ALL")) {
+        try {
+          int id = Integer.parseInt(am.trim());
+          if (id != -1 && id <= 0) {
+            errorInput = true;
+          }
+        } catch (NumberFormatException ex) {
+          errorInput = true;
+        }
+        if (errorInput) {
+          String errMessage =
+              "Invalid input for option -am. Valid inputs are 'ALL', -1 "
+              + "and any other integer which is larger than 0.";
+          printHelpMessage(printOpts);
+          throw new NumberFormatException(errMessage);
+        }
+        amContainersList.add(am.trim());
+      } else {
+        amContainersList.add("ALL");
+        break;
+      }
+    }
+    return amContainersList;
+  }
+
+  private int fetchAMContainerLogs(String[] logFiles,
+      YarnApplicationState appState, ApplicationId appId,
+      String appOwner, List<String> amContainersList,
+      LogCLIHelpers logCliHelper) throws Exception {
+    // if we do not specify the value for CONTAINER_LOG_FILES option,
+    // we will only output syslog
+    if (logFiles == null || logFiles.length == 0) {
+      logFiles = new String[] {"syslog"};
+    }
+    // If the application is running, we will call the RM WebService
+    // to get the AppAttempts which includes the nodeHttpAddress
+    // and containerId for all the AM Containers.
+    // After that, we will call NodeManager webService to get the
+    // related logs
+    if (appState == YarnApplicationState.ACCEPTED
+        || appState == YarnApplicationState.RUNNING) {
+      return printAMContainerLogs(getConf(), appId.toString(), amContainersList,
+        logFiles, logCliHelper, appOwner, false);
+    } else {
+      // If the application is in the final state, we will call RM webservice
+      // to get all AppAttempts information first. If we get nothing,
+      // we will try to call AHS webservice to get related AppAttempts
+      // which includes nodeAddress for the AM Containers.
+      // After that, we will use nodeAddress and containerId
+      // to get logs from HDFS directly.
+      if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,
+          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {
+        return printAMContainerLogs(getConf(), appId.toString(),
+            amContainersList, logFiles, logCliHelper, appOwner, true);
+      } else {
+        System.err.println("Can not get AMContainers logs for "
+            + "the application:" + appId);
+        System.err.println("This application:" + appId + " is finished."
+            + " Please enable the application history service. Or Using "
+            + "yarn logs -applicationId <appId> -containerId <containerId> "
+            + "--nodeAddress <nodeHttpAddress> to get the container logs");
+        return -1;
+      }
+    }
+  }
+
+  private int fetchContainerLogs(YarnApplicationState appState,
+      boolean appStateObtainedSuccessfully, String[] logFiles,
+      String appOwner, String nodeAddress,
+      ContainerId containerId, LogCLIHelpers logCliHelper) throws IOException {
+    int resultCode = 0;
+    String appIdStr = containerId.getApplicationAttemptId()
+        .getApplicationId().toString();
+    String containerIdStr = containerId.toString();
+    // if we provide the node address and the application is in the final
+    // state, we could directly get logs from HDFS.
+    if (nodeAddress != null && (!appStateObtainedSuccessfully ||
+        isApplicationFinished(appState))) {
+      // if user specified "ALL" as the logFiles param, pass null
+      // to logCliHelper so that it fetches all the logs
+      List<String> logs;
+      if (logFiles == null) {
+        logs = null;
+      } else if (fetchAllLogFiles(logFiles)) {
+        logs = null;
+      } else {
+        logs = Arrays.asList(logFiles);
+      }
+      return logCliHelper.dumpAContainersLogsForALogType(appIdStr,
+          containerIdStr, nodeAddress, appOwner, logs);
+    }
+    String nodeHttpAddress = null;
+    String nodeId = null;
+    try {
+      // If the nodeAddress is not provided, we will try to get
+      // the ContainerReport. In the containerReport, we could get
+      // nodeAddress and nodeHttpAddress
+      ContainerReport report = getContainerReport(containerIdStr);
+      nodeHttpAddress =
+          report.getNodeHttpAddress().replaceFirst(
+            WebAppUtils.getHttpSchemePrefix(getConf()), "");
+      nodeId = report.getAssignedNode().toString();
+    } catch (IOException | YarnException ex) {
+      if (!appStateObtainedSuccessfully || isApplicationFinished(appState)) {
+        String[] requestedLogFiles = logFiles;
+        if(fetchAllLogFiles(logFiles)) {
+          requestedLogFiles = null;
+        }
+        return printContainerLogsForFinishedApplicationWithoutNodeId(
+            appIdStr, containerIdStr, requestedLogFiles, logCliHelper,
+            appOwner);
+      } else if (!isApplicationFinished(appState)) {
+        System.err.println("Unable to get logs for this container:"
+            + containerIdStr + "for the application:" + appIdStr);
+        System.err.println("The application: " + appIdStr
+            + " is still running, and we can not get Container report "
+            + "for the container: " + containerIdStr +". Please try later "
+            + "or after the application finishes.");
+        return -1;
+      }
+    }
+    // If the application is not in the final state,
+    // we will provide the NodeHttpAddress and get the container logs
+    // by calling NodeManager webservice.
+    if (!isApplicationFinished(appState)) {
+      if (logFiles == null || logFiles.length == 0) {
+        logFiles = new String[] {"syslog"};
+      }
+      printContainerLogsFromRunningApplication(getConf(), containerId,
+          nodeHttpAddress, nodeId, logFiles, logCliHelper, appOwner);
+    } else {
+      String[] requestedLogFiles = logFiles;
+      if(fetchAllLogFiles(logFiles)) {
+        requestedLogFiles = null;
+      }
+      // If the application is in the final state, we will directly
+      // get the container logs from HDFS.
+      printContainerLogsForFinishedApplication(appIdStr, containerIdStr,
+          nodeId, requestedLogFiles, logCliHelper, appOwner);
+    }
+    return resultCode;
+  }
+

HADOOP-16753. Refactor HAAdmin. Contributed by Xieming Li.

-import com.google.common.base.Preconditions;
-  
-  private static final String FORCEFENCE  = "forcefence";
-  private static final String FORCEACTIVE = "forceactive";
-  
+
+  protected static final String FORCEACTIVE = "forceactive";
+
-  private static final String FORCEMANUAL = "forcemanual";
+  protected static final String FORCEMANUAL = "forcemanual";
-      .put("-transitionToObserver",
-          new UsageInfo("<serviceId>",
-              "Transitions the service into Observer state"))
-    .put("-failover",
-        new UsageInfo("[--"+FORCEFENCE+"] [--"+FORCEACTIVE+"] <serviceId> <serviceId>",
-            "Failover from the first service to the second.\n" +
-            "Unconditionally fence services if the --"+FORCEFENCE+" option is used.\n" +
-            "Try to failover to the target service even if it is not ready if the " + 
-            "--" + FORCEACTIVE + " option is used."))
+  protected RequestSource getRequestSource() {
+    return requestSource;
+  }
+
+  protected void setRequestSource(RequestSource requestSource) {
+    this.requestSource = requestSource;
+  }
+
-  protected void printUsage(PrintStream errOut) {
-    errOut.println(getUsageString());
-    for (Map.Entry<String, UsageInfo> e : USAGE.entrySet()) {
+  protected void printUsage(PrintStream pStr,
+      Map<String, UsageInfo> helpEntries) {
+    pStr.println(getUsageString());
+    for (Map.Entry<String, UsageInfo> e : helpEntries.entrySet()) {
-      
+
-        errOut.println("    [" + cmd + "]");
+        pStr.println("    [" + cmd + "]");
-        errOut.println("    [" + cmd + " " + usage.args + "]");
+        pStr.println("    [" + cmd + " " + usage.args + "]");
-    errOut.println();
-    ToolRunner.printGenericCommandUsage(errOut);    
+    pStr.println();
+    ToolRunner.printGenericCommandUsage(pStr);
-  
-  private void printUsage(PrintStream errOut, String cmd) {
-    UsageInfo usage = USAGE.get(cmd);
+
+  protected void printUsage(PrintStream pStr) {
+    printUsage(pStr, USAGE);
+  }
+
+  protected void printUsage(PrintStream pStr, String cmd,
+      Map<String, UsageInfo> helpEntries) {
+    UsageInfo usage = helpEntries.get(cmd);
-      errOut.println(getUsageString() + " [" + cmd + "]");
+      pStr.println(getUsageString() + " [" + cmd + "]");
-      errOut.println(getUsageString() + " [" + cmd + " " + usage.args + "]");
+      pStr.println(getUsageString() + " [" + cmd + " " + usage.args + "]");
+  protected void printUsage(PrintStream pStr, String cmd) {
+    printUsage(pStr, cmd, USAGE);
+  }
+
-  private int transitionToObserver(final CommandLine cmd)
-      throws IOException, ServiceFailedException {
-    String[] argv = cmd.getArgs();
-    if (argv.length != 1) {
-      errOut.println("transitionToObserver: incorrect number of arguments");
-      printUsage(errOut, "-transitionToObserver");
-      return -1;
-    }
-
-    HAServiceTarget target = resolveTarget(argv[0]);
-    if (!checkSupportObserver(target)) {
-      return -1;
-    }
-    if (!checkManualStateManagementOK(target)) {
-      return -1;
-    }
-    HAServiceProtocol proto = target.getProxy(getConf(), 0);
-    HAServiceProtocolHelper.transitionToObserver(proto, createReqInfo());
-    return 0;
-  }
-
-  private boolean checkManualStateManagementOK(HAServiceTarget target) {
+  protected boolean checkManualStateManagementOK(HAServiceTarget target) {
-  /**
-   * Check if the target supports the Observer state.
-   * @param target the target to check
-   * @return true if the target support Observer state, false otherwise.
-   */
-  private boolean checkSupportObserver(HAServiceTarget target) {
-    if (target.supportObserver()) {
-      return true;
-    } else {
-      errOut.println(
-          "The target " + target + " doesn't support Observer state.");
-      return false;
-    }
-  }
-
-  private StateChangeRequestInfo createReqInfo() {
+  protected StateChangeRequestInfo createReqInfo() {
-  private int failover(CommandLine cmd)
-      throws IOException, ServiceFailedException {
-    boolean forceFence = cmd.hasOption(FORCEFENCE);
-    boolean forceActive = cmd.hasOption(FORCEACTIVE);
-
-    int numOpts = cmd.getOptions() == null ? 0 : cmd.getOptions().length;
-    final String[] args = cmd.getArgs();
-
-    if (numOpts > 3 || args.length != 2) {
-      errOut.println("failover: incorrect arguments");
-      printUsage(errOut, "-failover");
-      return -1;
-    }
-
-    HAServiceTarget fromNode = resolveTarget(args[0]);
-    HAServiceTarget toNode = resolveTarget(args[1]);
-    
-    // Check that auto-failover is consistently configured for both nodes.
-    Preconditions.checkState(
-        fromNode.isAutoFailoverEnabled() ==
-          toNode.isAutoFailoverEnabled(),
-          "Inconsistent auto-failover configs between %s and %s!",
-          fromNode, toNode);
-    
-    if (fromNode.isAutoFailoverEnabled()) {
-      if (forceFence || forceActive) {
-        // -forceActive doesn't make sense with auto-HA, since, if the node
-        // is not healthy, then its ZKFC will immediately quit the election
-        // again the next time a health check runs.
-        //
-        // -forceFence doesn't seem to have any real use cases with auto-HA
-        // so it isn't implemented.
-        errOut.println(FORCEFENCE + " and " + FORCEACTIVE + " flags not " +
-            "supported with auto-failover enabled.");
-        return -1;
-      }
-      try {
-        return gracefulFailoverThroughZKFCs(toNode);
-      } catch (UnsupportedOperationException e){
-        errOut.println("Failover command is not supported with " +
-            "auto-failover enabled: " + e.getLocalizedMessage());
-        return -1;
-      }
-    }
-    
-    FailoverController fc = new FailoverController(getConf(),
-        requestSource);
-    
-    try {
-      fc.failover(fromNode, toNode, forceFence, forceActive); 
-      out.println("Failover from "+args[0]+" to "+args[1]+" successful");
-    } catch (FailoverFailedException ffe) {
-      errOut.println("Failover failed: " + ffe.getLocalizedMessage());
-      return -1;
-    }
-    return 0;
-  }
-  
-
-   * 
+   *
-  private int gracefulFailoverThroughZKFCs(HAServiceTarget toNode)
+  protected int gracefulFailoverThroughZKFCs(HAServiceTarget toNode)
-  
-  protected int runCmd(String[] argv) throws Exception {
+
+  protected boolean checkParameterValidity(String[] argv,
+      Map<String, UsageInfo> helpEntries){
+
-      printUsage(errOut);
+      printUsage(errOut, helpEntries);
+      return false;
+    }
+
+    String cmd = argv[0];
+    if (!cmd.startsWith("-")) {
+      errOut.println("Bad command '" + cmd +
+          "': expected command starting with '-'");
+      printUsage(errOut, helpEntries);
+      return false;
+    }
+
+    if (!helpEntries.containsKey(cmd)) {
+      errOut.println(cmd.substring(1) + ": Unknown command");
+      printUsage(errOut, helpEntries);
+      return false;
+    }
+    return true;
+  }
+
+  protected boolean checkParameterValidity(String[] argv){
+    return checkParameterValidity(argv, USAGE);
+  }
+
+  protected int runCmd(String[] argv) throws Exception {
+    if (!checkParameterValidity(argv, USAGE)){
-
-    if (!cmd.startsWith("-")) {
-      errOut.println("Bad command '" + cmd + "': expected command starting with '-'");
-      printUsage(errOut);
-      return -1;
-    }
-    
-    if (!USAGE.containsKey(cmd)) {
-      errOut.println(cmd.substring(1) + ": Unknown command");
-      printUsage(errOut);
-      return -1;
-    }
-    
-
-    if ("-failover".equals(cmd)) {
-      addFailoverCliOpts(opts);
-    }
-        "-transitionToStandby".equals(cmd) ||
-        "-transitionToObserver".equals(cmd) ||
-        "-failover".equals(cmd)) {
+        "-transitionToStandby".equals(cmd)) {
-         
-    } else if ("-transitionToObserver".equals(cmd)) {
-      return transitionToObserver(cmdLine);
-    } else if ("-failover".equals(cmd)) {
-      return failover(cmdLine);
-  private boolean confirmForceManual() throws IOException {
+  protected boolean confirmForceManual() throws IOException {
-  /**
-   * Add CLI options which are specific to the failover command and no
-   * others.
-   */
-  private void addFailoverCliOpts(Options failoverOpts) {
-    failoverOpts.addOption(FORCEFENCE, false, "force fencing");
-    failoverOpts.addOption(FORCEACTIVE, false, "force failover");
-    // Don't add FORCEMANUAL, since that's added separately for all commands
-    // that change state.
-  }
+
-  
-  private CommandLine parseOpts(String cmdName, Options opts, String[] argv) {
+
+  protected CommandLine parseOpts(String cmdName, Options opts, String[] argv,
+      Map<String, UsageInfo> helpEntries) {
-      argv = Arrays.copyOfRange(argv, 1, argv.length); 
+      argv = Arrays.copyOfRange(argv, 1, argv.length);
-      printUsage(errOut, cmdName);
+      printUsage(errOut, cmdName, helpEntries);
-  private int help(String[] argv) {
+  protected CommandLine parseOpts(String cmdName, Options opts, String[] argv) {
+    return parseOpts(cmdName, opts, argv, USAGE);
+  }
+  protected int help(String[] argv) {
+    return help(argv, USAGE);
+  }
+
+  protected int help(String[] argv, Map<String, UsageInfo> helpEntries) {
-      printUsage(out);
+      printUsage(out, helpEntries);
-      printUsage(errOut, "-help");
+      printUsage(errOut, "-help", helpEntries);
-    UsageInfo usageInfo = USAGE.get(cmd);
+    UsageInfo usageInfo = helpEntries.get(cmd);
-      printUsage(errOut);
+      printUsage(errOut, helpEntries);
-    
+

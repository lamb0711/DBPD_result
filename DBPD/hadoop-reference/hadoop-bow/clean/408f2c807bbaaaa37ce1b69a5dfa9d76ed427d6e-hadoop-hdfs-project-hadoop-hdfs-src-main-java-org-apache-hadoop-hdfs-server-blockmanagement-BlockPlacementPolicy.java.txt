HDFS-9866. BlockManager#chooseExcessReplicasStriped may weaken rack fault tolerance. Contributed by Jing Zhao.

-   * Same as {@link #chooseTarget(String, int, Node, Set, long, List, StorageType)}
-   * with added parameter {@code favoredDatanodes}
-  abstract public BlockPlacementStatus verifyBlockPlacement(
+  public abstract BlockPlacementStatus verifyBlockPlacement(
-   * @param candidates
+   * @param availableReplicas
+   * @param delCandidates
+   *          Candidates for deletion. For normal replication, this set is the
+   *          same with availableReplicas. For striped blocks, this set is a
+   *          subset of availableReplicas.
-   *          The required number of replicas for this block
+   *          The expected number of replicas remaining in the delCandidates
-  abstract public List<DatanodeStorageInfo> chooseReplicasToDelete(
-      Collection<DatanodeStorageInfo> candidates, int expectedNumOfReplicas,
+  public abstract List<DatanodeStorageInfo> chooseReplicasToDelete(
+      Collection<DatanodeStorageInfo> availableReplicas,
+      Collection<DatanodeStorageInfo> delCandidates, int expectedNumOfReplicas,
+
-  abstract protected void initialize(Configuration conf,  FSClusterStats stats, 
+  protected abstract void initialize(Configuration conf,  FSClusterStats stats,
-  abstract public boolean isMovable(Collection<DatanodeInfo> candidates,
+  public abstract boolean isMovable(Collection<DatanodeInfo> candidates,
-    } else if (datanode instanceof DatanodeStorageInfo) {
-      return ((DatanodeStorageInfo)datanode).getDatanodeDescriptor();
-      return null;
+      return ((DatanodeStorageInfo)datanode).getDatanodeDescriptor();
-   * 
-   * @param storagesOrDataNodes DatanodeStorageInfo/DatanodeInfo to be split
+   *
+   * @param availableSet all the available DataNodes/storages of the block
+   * @param candidates DatanodeStorageInfo/DatanodeInfo to be split
-      final Iterable<T> storagesOrDataNodes,
+      final Iterable<T> availableSet,
+      final Collection<T> candidates,
-    for(T s: storagesOrDataNodes) {
+    for(T s: availableSet) {
-        storageList = new ArrayList<T>();
+        storageList = new ArrayList<>();
-    // split nodes into two sets
-    for(List<T> storageList : rackMap.values()) {
-      if (storageList.size() == 1) {
+    for (T candidate : candidates) {
+      final String rackName = getRack(getDatanodeInfo(candidate));
+      if (rackMap.get(rackName).size() == 1) {
-        exactlyOne.add(storageList.get(0));
+        exactlyOne.add(candidate);
-        moreThanOne.addAll(storageList);
+        moreThanOne.add(candidate);

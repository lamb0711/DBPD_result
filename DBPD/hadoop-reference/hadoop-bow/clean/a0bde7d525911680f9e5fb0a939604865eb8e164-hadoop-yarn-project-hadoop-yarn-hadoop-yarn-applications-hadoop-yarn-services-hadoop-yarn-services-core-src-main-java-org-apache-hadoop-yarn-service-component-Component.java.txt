YARN-7142. Support placement policy in yarn native services. (Gour Saha via wangda)

Change-Id: I166c67a7a34430627c17365f60bac75b6da1b434

+import org.apache.hadoop.yarn.api.records.ExecutionType;
+import org.apache.hadoop.yarn.api.records.ExecutionTypeRequest;
+import org.apache.hadoop.yarn.api.records.ResourceSizing;
+import org.apache.hadoop.yarn.api.records.SchedulingRequest;
+import org.apache.hadoop.yarn.api.resource.PlacementConstraint;
+import org.apache.hadoop.yarn.api.resource.PlacementConstraint.TargetExpression;
+import org.apache.hadoop.yarn.api.resource.PlacementConstraints;
+import org.apache.hadoop.yarn.api.resource.PlacementConstraints.PlacementTargets;
-import org.apache.hadoop.yarn.service.api.records.ResourceInformation;
-import org.apache.hadoop.yarn.service.component.instance.ComponentInstance;
-import org.apache.hadoop.yarn.service.component.instance.ComponentInstanceId;
-import org.apache.hadoop.yarn.service.ServiceScheduler;
-import org.apache.hadoop.yarn.service.api.records.ServiceState;
-import org.apache.hadoop.yarn.service.component.instance.ComponentInstanceEvent;
+import org.apache.hadoop.yarn.service.ServiceScheduler;
+import org.apache.hadoop.yarn.service.api.records.PlacementPolicy;
+import org.apache.hadoop.yarn.service.api.records.ResourceInformation;
+import org.apache.hadoop.yarn.service.api.records.ServiceState;
+import org.apache.hadoop.yarn.service.component.instance.ComponentInstance;
+import org.apache.hadoop.yarn.service.component.instance.ComponentInstanceEvent;
+import org.apache.hadoop.yarn.service.component.instance.ComponentInstanceId;
+import org.apache.hadoop.yarn.service.monitor.probe.MonitorUtils;
+import org.apache.hadoop.yarn.service.monitor.probe.Probe;
+import org.apache.hadoop.yarn.service.utils.ServiceUtils;
-import org.apache.hadoop.yarn.service.utils.ServiceUtils;
-import org.apache.hadoop.yarn.service.monitor.probe.MonitorUtils;
-import org.apache.hadoop.yarn.service.monitor.probe.Probe;
+import java.util.HashSet;
-import static org.apache.hadoop.yarn.service.component.instance.ComponentInstanceEventType.START;
-import static org.apache.hadoop.yarn.service.component.instance.ComponentInstanceEventType.STOP;
+import static org.apache.hadoop.yarn.service.component.instance.ComponentInstanceEventType.*;
+    LOG.info("[COMPONENT {}] Requesting for {} container(s)",
+        componentSpec.getName(), count);
-    for (int i = 0; i < count; i++) {
-      //TODO Once YARN-5468 is done, use that for anti-affinity
-      ContainerRequest request =
-          ContainerRequest.newBuilder().capability(resource).priority(priority)
-              .allocationRequestId(allocateId).relaxLocality(true).build();
-      amrmClient.addContainerRequest(request);
+    if (!scheduler.hasAtLeastOnePlacementConstraint()) {
+      for (int i = 0; i < count; i++) {
+        ContainerRequest request = ContainerRequest.newBuilder()
+            .capability(resource).priority(priority)
+            .allocationRequestId(allocateId).relaxLocality(true).build();
+        LOG.info("[COMPONENT {}] Submitting container request : {}",
+            componentSpec.getName(), request);
+        amrmClient.addContainerRequest(request);
+      }
+    } else {
+      // Schedule placement requests. Validation of non-null target tags and
+      // that they refer to existing component names are already done. So, no
+      // need to validate here.
+      PlacementPolicy placementPolicy = componentSpec.getPlacementPolicy();
+      Collection<SchedulingRequest> schedulingRequests = new HashSet<>();
+      // We prepare an AND-ed composite constraint to be the final composite
+      // constraint. If placement expressions are specified to create advanced
+      // composite constraints then this AND-ed composite constraint is not
+      // used.
+      PlacementConstraint finalConstraint = null;
+      for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint
+          yarnServiceConstraint : placementPolicy.getConstraints()) {
+        List<TargetExpression> targetExpressions = new ArrayList<>();
+        // Currently only intra-application allocation tags are supported.
+        if (!yarnServiceConstraint.getTargetTags().isEmpty()) {
+          targetExpressions.add(PlacementTargets.allocationTagToIntraApp(
+              yarnServiceConstraint.getTargetTags().toArray(new String[0])));
+        }
+        // Add all node attributes
+        for (Map.Entry<String, List<String>> attribute : yarnServiceConstraint
+            .getNodeAttributes().entrySet()) {
+          targetExpressions.add(PlacementTargets.nodeAttribute(
+              attribute.getKey(), attribute.getValue().toArray(new String[0])));
+        }
+        // Add all node partitions
+        if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {
+          targetExpressions
+              .add(PlacementTargets.nodePartition(yarnServiceConstraint
+                  .getNodePartitions().toArray(new String[0])));
+        }
+        PlacementConstraint constraint = null;
+        switch (yarnServiceConstraint.getType()) {
+        case AFFINITY:
+          constraint = PlacementConstraints
+              .targetIn(yarnServiceConstraint.getScope().getValue(),
+                  targetExpressions.toArray(new TargetExpression[0]))
+              .build();
+          break;
+        case ANTI_AFFINITY:
+          constraint = PlacementConstraints
+              .targetNotIn(yarnServiceConstraint.getScope().getValue(),
+                  targetExpressions.toArray(new TargetExpression[0]))
+              .build();
+          break;
+        case AFFINITY_WITH_CARDINALITY:
+          constraint = PlacementConstraints.targetCardinality(
+              yarnServiceConstraint.getScope().name().toLowerCase(),
+              yarnServiceConstraint.getMinCardinality() == null ? 0
+                  : yarnServiceConstraint.getMinCardinality().intValue(),
+              yarnServiceConstraint.getMaxCardinality() == null
+                  ? Integer.MAX_VALUE
+                  : yarnServiceConstraint.getMaxCardinality().intValue(),
+              targetExpressions.toArray(new TargetExpression[0])).build();
+          break;
+        }
+        // The default AND-ed final composite constraint
+        if (finalConstraint != null) {
+          finalConstraint = PlacementConstraints
+              .and(constraint.getConstraintExpr(),
+                  finalConstraint.getConstraintExpr())
+              .build();
+        } else {
+          finalConstraint = constraint;
+        }
+        LOG.debug("[COMPONENT {}] Placement constraint: {}",
+            componentSpec.getName(), constraint.getConstraintExpr().toString());
+      }
+      ResourceSizing resourceSizing = ResourceSizing.newInstance((int) count,
+          resource);
+      LOG.debug("[COMPONENT {}] Resource sizing: {}", componentSpec.getName(),
+          resourceSizing);
+      SchedulingRequest request = SchedulingRequest.newBuilder()
+          .priority(priority).allocationRequestId(allocateId)
+          .allocationTags(Collections.singleton(componentSpec.getName()))
+          .executionType(
+              ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))
+          .placementConstraintExpression(finalConstraint)
+          .resourceSizing(resourceSizing).build();
+      LOG.info("[COMPONENT {}] Submitting scheduling request: {}",
+          componentSpec.getName(), request);
+      schedulingRequests.add(request);
+      amrmClient.addSchedulingRequests(schedulingRequests);

YARN-7565. Yarn service pre-maturely releases the container after AM restart. Contributed by Chandni Singh

+import com.google.common.collect.Lists;
+import org.apache.hadoop.registry.client.binding.RegistryPathUtils;
+import org.apache.hadoop.registry.client.types.ServiceRecord;
+import org.apache.hadoop.registry.client.types.yarn.PersistencePolicies;
+import org.apache.hadoop.registry.client.types.yarn.YarnRegistryAttributes;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.concurrent.ConcurrentHashMap;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.when;
+  private static final Logger LOG =
+      LoggerFactory.getLogger(MockServiceAM.class);
+
+
+  private final List<Container> recoveredContainers =
+      Collections.synchronizedList(new LinkedList<>());
+
+  private final Map<String, ServiceRecord> registryComponents =
+      new ConcurrentHashMap<>();
+
+  private Map<ContainerId, ContainerStatus> containerStatuses =
+      new ConcurrentHashMap<>();
+
-    System.out.println("Service path: " + path);
+    LOG.info("Service path: {}", path);
+      @SuppressWarnings("SuspiciousMethodCalls")
-        return mock(YarnRegistryViewForProviders.class);
+        YarnRegistryViewForProviders yarnRegistryView = mock(
+            YarnRegistryViewForProviders.class);
+        if (!registryComponents.isEmpty()) {
+          try {
+            when(yarnRegistryView.listComponents())
+                .thenReturn(new LinkedList<>(registryComponents.keySet()));
+            when(yarnRegistryView.getComponent(anyString())).thenAnswer(
+                invocation ->
+                    registryComponents.get(invocation.getArguments()[0]));
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        }
+        return yarnRegistryView;
-                System.out.println("Allocating........ no containers");
+                LOG.info("Allocating........ no containers");
-                    System.out.println("Allocated container " + c.getId());
+                    LOG.info("Allocated container {} ", c.getId());
+            // add recovered containers if any
+            synchronized (recoveredContainers) {
+              if (!recoveredContainers.isEmpty()) {
+                List<Container> containersFromPrevAttempt = new LinkedList<>();
+                containersFromPrevAttempt.addAll(recoveredContainers);
+                recoveredContainers.clear();
+                builder.containersFromPreviousAttempt(
+                    containersFromPrevAttempt);
+              }
+            }
+
-        return AMRMClientAsync
-            .createAMRMClientAsync(client1, 1000,
+        return AMRMClientAsync.createAMRMClientAsync(client1, 1000,
+      @SuppressWarnings("SuspiciousMethodCalls")
-        nmClientAsync.setClient(mock(NMClient.class));
+        NMClient nmClient = mock(NMClient.class);
+        try {
+          when(nmClient.getContainerStatus(anyObject(), anyObject()))
+              .thenAnswer(invocation ->
+                  containerStatuses.get(invocation.getArguments()[0]));
+        } catch (YarnException | IOException e) {
+          throw new RuntimeException(e);
+        }
+        nmClientAsync.setClient(nmClient);
+  public void feedRegistryComponent(ContainerId containerId, String compName,
+      String compInstName) {
+    ServiceRecord record = new ServiceRecord();
+    record.set(YarnRegistryAttributes.YARN_ID, containerId.toString());
+    record.description = compInstName;
+    record.set(YarnRegistryAttributes.YARN_PERSISTENCE,
+        PersistencePolicies.CONTAINER);
+    record.set(YarnRegistryAttributes.YARN_IP, "localhost");
+    record.set(YarnRegistryAttributes.YARN_HOSTNAME, "localhost");
+    record.set(YarnRegistryAttributes.YARN_COMPONENT, compName);
+    registryComponents.put(RegistryPathUtils.encodeYarnID(
+        containerId.toString()), record);
+  }
+
+  /**
+   * Simulates a recovered container that is sent to the AM in the heartbeat
+   * response.
+   *
+   * @param containerId The ID for the container
+   * @param compName    The component to which the recovered container is fed.
+   */
+  public void feedRecoveredContainer(ContainerId containerId, String compName) {
+    Container container = createContainer(containerId, compName);
+    recoveredContainers.add(container);
+    addContainerStatus(container, ContainerState.RUNNING);
+  }
+
-    ApplicationId applicationId = ApplicationId.fromString(service.getId());
-    ContainerId containerId = ContainerId
-        .newContainerId(ApplicationAttemptId.newInstance(applicationId, 1), id);
-    NodeId nodeId = NodeId.newInstance("localhost", 1234);
-    Container container = Container
-        .newInstance(containerId, nodeId, "localhost",
-            Resource.newInstance(100, 1), Priority.newInstance(0), null);
-
-    long allocateId =
-        context.scheduler.getAllComponents().get(compName).getAllocateId();
-    container.setAllocationRequestId(allocateId);
+    ContainerId containerId = createContainerId(id);
+    Container container = createContainer(containerId, compName);
+    addContainerStatus(container, ContainerState.RUNNING);
-    ContainerStatus containerStatus = Records.newRecord(ContainerStatus.class);
-    containerStatus.setContainerId(containerId);
+    ContainerStatus status = Records.newRecord(ContainerStatus.class);
+    status.setContainerId(containerId);
-      failedContainers.add(containerStatus);
+      failedContainers.add(status);
+  public ContainerId createContainerId(int id) {
+    ApplicationId applicationId = ApplicationId.fromString(service.getId());
+    return ContainerId.newContainerId(
+        ApplicationAttemptId.newInstance(applicationId, 1), id);
+  }
+
+  private Container createContainer(ContainerId containerId, String compName) {
+    NodeId nodeId = NodeId.newInstance("localhost", 1234);
+    Container container = Container.newInstance(
+        containerId, nodeId, "localhost",
+        Resource.newInstance(100, 1),
+        Priority.newInstance(0), null);
+    long allocateId =
+        context.scheduler.getAllComponents().get(compName).getAllocateId();
+    container.setAllocationRequestId(allocateId);
+    return container;
+  }
+
+  private void addContainerStatus(Container container, ContainerState state) {
+    ContainerStatus status = ContainerStatus.newInstance(container.getId(),
+        state, "", 0);
+    status.setHost(container.getNodeId().getHost());
+    status.setIPs(Lists.newArrayList(container.getNodeId().getHost()));
+    containerStatuses.put(container.getId(), status);
+  }
+

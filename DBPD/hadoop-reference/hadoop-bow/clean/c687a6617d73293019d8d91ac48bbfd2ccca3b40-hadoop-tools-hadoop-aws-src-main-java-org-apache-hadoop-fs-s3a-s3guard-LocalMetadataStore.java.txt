HADOOP-15423. Merge fileCache and dirCache into ine single cache in LocalMetadataStore. Contributed by Gabor Bota.

-import java.util.Iterator;
- * This is a local, in-memory, implementation of MetadataStore.
+ * This is a local, in-memory implementation of MetadataStore.
- * Contains cache internally with time based eviction.
+ * Contains one cache internally with time based eviction.
-  public static final int DEFAULT_MAX_RECORDS = 128;
+  public static final int DEFAULT_MAX_RECORDS = 256;
-  /** Contains directories and files. */
-  private Cache<Path, PathMetadata> fileCache;
-
-  /** Contains directory listings. */
-  private Cache<Path, DirListingMetadata> dirCache;
+  /** Contains directory and file listings. */
+  private Cache<Path, LocalMetadataEntry> localCache;
-    fileCache = builder.build();
-    dirCache = builder.build();
+    localCache = builder.build();
-      deleteEntryByAncestor(path, dirCache, tombstone);
-      deleteEntryByAncestor(path, fileCache, tombstone);
+      deleteEntryByAncestor(path, localCache, tombstone);
-      PathMetadata m = fileCache.getIfPresent(path);
+      PathMetadata m = getFileMeta(path);
-    DirListingMetadata dirMeta = dirCache.getIfPresent(p);
-    return dirMeta.withoutTombstones().isEmpty();
+    DirListingMetadata dlm = getDirListingMeta(p);
+    return dlm.withoutTombstones().isEmpty();
-    DirListingMetadata listing = dirCache.getIfPresent(path);
+    DirListingMetadata listing = getDirListingMeta(path);
+    LOG.info("Move {} to {}", pathsToDelete, pathsToCreate);
-      fileCache.put(path, meta);
+      LocalMetadataEntry entry = localCache.getIfPresent(path);
+      if(entry == null){
+        entry = new LocalMetadataEntry(meta);
+      } else {
+        entry.setPathMetadata(meta);
+      }
-      if (status.isDirectory()) {
-        DirListingMetadata dir = dirCache.getIfPresent(path);
-        if (dir == null) {
-          dirCache.put(path, new DirListingMetadata(path, DirListingMetadata
-              .EMPTY_DIR, false));
-        }
+      // only create DirListingMetadata if the entry does not have one
+      if (status.isDirectory() && !entry.hasDirMeta()) {
+        DirListingMetadata dlm =
+            new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);
+        entry.setDirListingMetadata(dlm);
+      localCache.put(path, entry);
-        DirListingMetadata parent = dirCache.getIfPresent(parentPath);
-        if (parent == null) {
-        /* Track this new file's listing in parent.  Parent is not
-         * authoritative, since there may be other items in it we don't know
-         * about. */
-          parent = new DirListingMetadata(parentPath,
-              DirListingMetadata.EMPTY_DIR, false);
-          dirCache.put(parentPath, parent);
+        LocalMetadataEntry parentMeta = localCache.getIfPresent(parentPath);
+        DirListingMetadata parentDirMeta =
+            new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,
+                false);
+        parentDirMeta.put(status);
+
+        getDirListingMeta(parentPath);
+
+        if (parentMeta == null){
+          localCache.put(parentPath, new LocalMetadataEntry(parentDirMeta));
+        } else if (!parentMeta.hasDirMeta()) {
+          parentMeta.setDirListingMetadata(parentDirMeta);
+        } else {
+          parentMeta.getDirListingMeta().put(status);
-        parent.put(status);
-    dirCache.put(standardize(meta.getPath()), meta);
+    LocalMetadataEntry entry =
+        localCache.getIfPresent(standardize(meta.getPath()));
+    if(entry == null){
+      localCache.put(standardize(meta.getPath()), new LocalMetadataEntry(meta));
+    } else {
+      entry.setDirListingMetadata(meta);
+    }
-    if (dirCache != null) {
-      dirCache.invalidateAll();
+    if (localCache != null) {
+      localCache.invalidateAll();
-  public synchronized void prune(long modTime, String keyPrefix)
-      throws IOException {
-    Iterator<Map.Entry<Path, PathMetadata>> files =
-        fileCache.asMap().entrySet().iterator();
-    while (files.hasNext()) {
-      Map.Entry<Path, PathMetadata> entry = files.next();
-      if (expired(entry.getValue().getFileStatus(), modTime, keyPrefix)) {
-        files.remove();
-      }
-    }
-    Iterator<Map.Entry<Path, DirListingMetadata>> dirs =
-        dirCache.asMap().entrySet().iterator();
-    while (dirs.hasNext()) {
-      Map.Entry<Path, DirListingMetadata> entry = dirs.next();
-      Path path = entry.getKey();
-      DirListingMetadata metadata = entry.getValue();
-      Collection<PathMetadata> oldChildren = metadata.getListing();
-      Collection<PathMetadata> newChildren = new LinkedList<>();
+  public synchronized void prune(long modTime, String keyPrefix) {
+    // prune files
+    // filter path_metadata (files), filter expired, remove expired
+    localCache.asMap().entrySet().stream()
+        .filter(entry -> entry.getValue().hasPathMeta())
+        .filter(entry -> expired(
+            entry.getValue().getFileMeta().getFileStatus(), modTime, keyPrefix))
+        .forEach(entry -> localCache.invalidate(entry.getKey()));
-      for (PathMetadata child : oldChildren) {
-        FileStatus status = child.getFileStatus();
-        if (!expired(status, modTime, keyPrefix)) {
-          newChildren.add(child);
-        }
-      }
-      if (newChildren.size() != oldChildren.size()) {
-        dirCache.put(path, new DirListingMetadata(path, newChildren, false));
-        if (!path.isRoot()) {
-          DirListingMetadata parent = null;
-          parent = dirCache.getIfPresent(path.getParent());
-          if (parent != null) {
-            parent.setAuthoritative(false);
+
+    // prune dirs
+    // filter DIR_LISTING_METADATA, remove expired, remove authoritative bit
+    localCache.asMap().entrySet().stream()
+        .filter(entry -> entry.getValue().hasDirMeta())
+        .forEach(entry -> {
+          Path path = entry.getKey();
+          DirListingMetadata metadata = entry.getValue().getDirListingMeta();
+          Collection<PathMetadata> oldChildren = metadata.getListing();
+          Collection<PathMetadata> newChildren = new LinkedList<>();
+
+          for (PathMetadata child : oldChildren) {
+            FileStatus status = child.getFileStatus();
+            if (!expired(status, modTime, keyPrefix)) {
+              newChildren.add(child);
+            }
-        }
-      }
-    }
+          if (newChildren.size() != oldChildren.size()) {
+            DirListingMetadata dlm =
+                new DirListingMetadata(path, newChildren, false);
+            localCache.put(path, new LocalMetadataEntry(dlm));
+            if (!path.isRoot()) {
+              DirListingMetadata parent = getDirListingMeta(path.getParent());
+              if (parent != null) {
+                parent.setAuthoritative(false);
+              }
+            }
+          }
+        });
-  static <T> void deleteEntryByAncestor(Path ancestor, Cache<Path, T> cache,
-                                       boolean tombstone) {
-    for (Iterator<Map.Entry<Path, T>> it = cache.asMap().entrySet().iterator();
-         it.hasNext();) {
-      Map.Entry<Path, T> entry = it.next();
-      Path f = entry.getKey();
-      T meta = entry.getValue();
-      if (isAncestorOf(ancestor, f)) {
-        if (tombstone) {
-          if (meta instanceof PathMetadata) {
-            cache.put(f, (T) PathMetadata.tombstone(f));
-          } else if (meta instanceof DirListingMetadata) {
-            it.remove();
+  static void deleteEntryByAncestor(Path ancestor,
+      Cache<Path, LocalMetadataEntry> cache, boolean tombstone) {
+
+    cache.asMap().entrySet().stream()
+        .filter(entry -> isAncestorOf(ancestor, entry.getKey()))
+        .forEach(entry -> {
+          LocalMetadataEntry meta = entry.getValue();
+          Path path = entry.getKey();
+          if(meta.hasDirMeta()){
+            cache.invalidate(path);
+          } else if(tombstone && meta.hasPathMeta()){
+            meta.setPathMetadata(PathMetadata.tombstone(path));
-            throw new IllegalStateException("Unknown type in cache");
+            cache.invalidate(path);
-        } else {
-          it.remove();
-        }
-      }
-    }
+        });
-   * @return true iff 'ancestor' is ancestor dir in path 'f'.
+   * @return true if 'ancestor' is ancestor dir in path 'f'.
-
-    // Remove target file/dir
-    LOG.debug("delete file entry for {}", path);
-    if (tombstone) {
-      fileCache.put(path, PathMetadata.tombstone(path));
-    } else {
-      fileCache.invalidate(path);
+    LocalMetadataEntry entry = localCache.getIfPresent(path);
+    // If there's no entry, delete should silently succeed
+    // (based on MetadataStoreTestBase#testDeleteNonExisting)
+    if(entry == null){
+      LOG.warn("Delete: path {} is missing from cache.", path);
+      return;
-    // Update this and parent dir listing, if any
+    // Remove target file entry
+    LOG.debug("delete file entry for {}", path);
+    if(entry.hasPathMeta()){
+      if (tombstone) {
+        PathMetadata pmd = PathMetadata.tombstone(path);
+        entry.setPathMetadata(pmd);
+      } else {
+        entry.setPathMetadata(null);
+      }
+    }
-    /* If this path is a dir, remove its listing */
-    LOG.debug("removing listing of {}", path);
+    // If this path is a dir, remove its listing
+    if(entry.hasDirMeta()) {
+      LOG.debug("removing listing of {}", path);
+      entry.setDirListingMetadata(null);
+    }
-    dirCache.invalidate(path);
+    // If the entry is empty (contains no dirMeta or pathMeta) remove it from
+    // the cache.
+    if(!entry.hasDirMeta() && !entry.hasPathMeta()){
+      localCache.invalidate(entry);
+    }
-      DirListingMetadata dir = null;
-      dir = dirCache.getIfPresent(parent);
+      DirListingMetadata dir = getDirListingMeta(parent);
+
+  PathMetadata getFileMeta(Path p){
+    LocalMetadataEntry entry = localCache.getIfPresent(p);
+    if(entry != null && entry.hasPathMeta()){
+      return entry.getFileMeta();
+    } else {
+      return null;
+    }
+  }
+
+  DirListingMetadata getDirListingMeta(Path p){
+    LocalMetadataEntry entry = localCache.getIfPresent(p);
+    if(entry != null && entry.hasDirMeta()){
+      return entry.getDirListingMeta();
+    } else {
+      return null;
+    }
+  }
+

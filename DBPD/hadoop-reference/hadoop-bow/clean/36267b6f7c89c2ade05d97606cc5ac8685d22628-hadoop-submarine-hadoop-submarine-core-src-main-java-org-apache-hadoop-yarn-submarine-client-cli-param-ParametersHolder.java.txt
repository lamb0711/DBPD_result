SUBMARINE-52. [SUBMARINE-14] Generate Service spec + launch script for single-node PyTorch learning job. Contributed by Szilard Nemeth.

+import org.apache.commons.cli.ParseException;
+import org.apache.hadoop.yarn.submarine.client.cli.Command;
+import org.apache.hadoop.yarn.submarine.client.cli.param.runjob.PyTorchRunJobParameters;
+import org.apache.hadoop.yarn.submarine.client.cli.param.runjob.TensorFlowRunJobParameters;
+import org.apache.hadoop.yarn.submarine.client.cli.param.yaml.YamlParseException;
+import org.apache.hadoop.yarn.submarine.client.cli.runjob.Framework;
+import org.apache.hadoop.yarn.submarine.common.ClientContext;
+import java.io.IOException;
+import java.util.Set;
+import static org.apache.hadoop.yarn.submarine.client.cli.runjob.RunJobCli.YAML_PARSE_FAILED;
+
+  public static final String SUPPORTED_FRAMEWORKS_MESSAGE =
+      "TensorFlow and PyTorch are the only supported frameworks for now!";
+  public static final String SUPPORTED_COMMANDS_MESSAGE =
+      "'Show job' and 'run job' are the only supported commands for now!";
+
+
+
-  private final ImmutableSet onlyDefinedWithCliArgs = ImmutableSet.of(
+  private final ConfigType configType;
+  private Command command;
+  private final Set onlyDefinedWithCliArgs = ImmutableSet.of(
+  private final Framework framework;
+  private final BaseParameters parameters;
-      YamlConfigFile yamlConfig) {
+      YamlConfigFile yamlConfig, ConfigType configType, Command command)
+      throws ParseException, YarnException {
+    this.configType = configType;
+    this.command = command;
+    this.framework = determineFrameworkType();
+    this.ensureOnlyValidSectionsAreDefined(yamlConfig);
+    this.parameters = createParameters();
+  }
+
+  private BaseParameters createParameters() {
+    if (command == Command.RUN_JOB) {
+      if (framework == Framework.TENSORFLOW) {
+        return new TensorFlowRunJobParameters();
+      } else if (framework == Framework.PYTORCH) {
+        return new PyTorchRunJobParameters();
+      } else {
+        throw new UnsupportedOperationException(SUPPORTED_FRAMEWORKS_MESSAGE);
+      }
+    } else if (command == Command.SHOW_JOB) {
+      return new ShowJobParameters();
+    } else {
+      throw new UnsupportedOperationException(SUPPORTED_COMMANDS_MESSAGE);
+    }
+  }
+
+  private void ensureOnlyValidSectionsAreDefined(YamlConfigFile yamlConfig) {
+    if (isCommandRunJob() && isFrameworkPyTorch() &&
+        isPsSectionDefined(yamlConfig)) {
+      throw new YamlParseException(
+          "PS section should not be defined when PyTorch " +
+              "is the selected framework!");
+    }
+
+    if (isCommandRunJob() && isFrameworkPyTorch() &&
+        isTensorboardSectionDefined(yamlConfig)) {
+      throw new YamlParseException(
+          "TensorBoard section should not be defined when PyTorch " +
+              "is the selected framework!");
+    }
+  }
+
+  private boolean isCommandRunJob() {
+    return command == Command.RUN_JOB;
+  }
+
+  private boolean isFrameworkPyTorch() {
+    return framework == Framework.PYTORCH;
+  }
+
+  private boolean isPsSectionDefined(YamlConfigFile yamlConfig) {
+    return yamlConfig != null &&
+        yamlConfig.getRoles() != null &&
+        yamlConfig.getRoles().getPs() != null;
+  }
+
+  private boolean isTensorboardSectionDefined(YamlConfigFile yamlConfig) {
+    return yamlConfig != null &&
+        yamlConfig.getTensorBoard() != null;
+  }
+
+  private Framework determineFrameworkType()
+      throws ParseException, YarnException {
+    if (!isCommandRunJob()) {
+      return null;
+    }
+    String frameworkStr = getOptionValue(CliConstants.FRAMEWORK);
+    if (frameworkStr == null) {
+      LOG.info("Framework is not defined in config, falling back to " +
+          "TensorFlow as a default.");
+      return Framework.TENSORFLOW;
+    }
+    Framework framework = Framework.parseByValue(frameworkStr);
+    if (framework == null) {
+      if (getConfigType() == ConfigType.CLI) {
+        throw new ParseException("Failed to parse Framework type! "
+            + "Valid values are: " + Framework.getValues());
+      } else {
+        throw new YamlParseException(YAML_PARSE_FAILED +
+            ", framework should is defined, but it has an invalid value! " +
+            "Valid values are: " + Framework.getValues());
+      }
+    }
+    return framework;
+    yamlConfigs.put(CliConstants.FRAMEWORK,
+        yamlConfig.getSpec().getFramework());
-  public static ParametersHolder createWithCmdLine(CommandLine cli) {
-    return new ParametersHolder(cli, null);
+  public static ParametersHolder createWithCmdLine(CommandLine cli,
+      Command command) throws ParseException, YarnException {
+    return new ParametersHolder(cli, null, ConfigType.CLI, command);
-      YamlConfigFile yamlConfig) {
-    return new ParametersHolder(cli, yamlConfig);
+      YamlConfigFile yamlConfig, Command command) throws ParseException,
+      YarnException {
+    return new ParametersHolder(cli, yamlConfig, ConfigType.YAML, command);
-  String getOptionValue(String option) throws YarnException {
+  public String getOptionValue(String option) throws YarnException {
-  List<String> getOptionValues(String option) throws YarnException {
+  public List<String> getOptionValues(String option) throws YarnException {
-  boolean hasOption(String option) {
+  public boolean hasOption(String option) {
+
+  public ConfigType getConfigType() {
+    return configType;
+  }
+
+  public Framework getFramework() {
+    return framework;
+  }
+
+  public void updateParameters(ClientContext clientContext)
+      throws ParseException, YarnException, IOException {
+    parameters.updateParameters(this, clientContext);
+  }
+
+  public BaseParameters getParameters() {
+    return parameters;
+  }

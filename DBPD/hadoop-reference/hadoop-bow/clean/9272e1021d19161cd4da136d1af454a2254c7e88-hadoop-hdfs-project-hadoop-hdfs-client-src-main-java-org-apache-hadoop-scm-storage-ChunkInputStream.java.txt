HDFS-12636. Ozone: OzoneFileSystem: Implement seek functionality for rpc client. Contributed by Lokesh Jain.

+import java.io.EOFException;
+import java.util.Arrays;
+import org.apache.hadoop.fs.Seekable;
-public class ChunkInputStream extends InputStream {
+public class ChunkInputStream extends InputStream implements Seekable {
-  private int chunkOffset;
+  private int chunkIndex;
+  private long[] chunkOffset;
-  private int bufferOffset;
+  private int bufferIndex;
-    this.chunkOffset = 0;
+    this.chunkIndex = -1;
+    // chunkOffset[i] stores offset at which chunk i stores data in
+    // ChunkInputStream
+    this.chunkOffset = new long[this.chunks.size()];
+    initializeChunkOffset();
-    this.bufferOffset = 0;
+    this.bufferIndex = 0;
+  }
+
+  private void initializeChunkOffset() {
+    int tempOffset = 0;
+    for (int i = 0; i < chunks.size(); i++) {
+      chunkOffset[i] = tempOffset;
+      tempOffset += chunks.get(i).getLen();
+    }
-    return available == EOF ? EOF : buffers.get(bufferOffset).get();
+    return available == EOF ? EOF :
+        Byte.toUnsignedInt(buffers.get(bufferIndex).get());
-    buffers.get(bufferOffset).get(b, off, available);
+    buffers.get(bufferIndex).get(b, off, available);
-        readChunkFromContainer(0);
+        readChunkFromContainer();
-          buffers.get(bufferOffset).hasRemaining()) {
+          buffers.get(bufferIndex).hasRemaining()) {
-        ByteBuffer bb = buffers.get(bufferOffset);
+        ByteBuffer bb = buffers.get(bufferIndex);
-          !buffers.get(bufferOffset).hasRemaining() &&
-          bufferOffset < buffers.size() - 1) {
+          !buffers.get(bufferIndex).hasRemaining() &&
+          bufferIndex < buffers.size() - 1) {
-        ++bufferOffset;
-      } else if (chunkOffset < chunks.size() - 1) {
+        ++bufferIndex;
+      } else if (chunkIndex < chunks.size() - 1) {
-        readChunkFromContainer(chunkOffset + 1);
+        readChunkFromContainer();
-   * @param readChunkOffset offset in the chunk list of which chunk to read
-  private synchronized void readChunkFromContainer(int readChunkOffset)
-      throws IOException {
+  private synchronized void readChunkFromContainer() throws IOException {
+    // On every chunk read chunkIndex should be increased so as to read the
+    // next chunk
+    chunkIndex += 1;
-          chunks.get(readChunkOffset), key, traceID);
+          chunks.get(chunkIndex), key, traceID);
-    chunkOffset = readChunkOffset;
+    bufferIndex = 0;
+  }
+
+  @Override
+  public synchronized void seek(long pos) throws IOException {
+    if (pos < 0 || (chunks.size() == 0 && pos > 0)
+        || pos >= chunkOffset[chunks.size() - 1] + chunks.get(chunks.size() - 1)
+        .getLen()) {
+      throw new EOFException(
+          "EOF encountered pos: " + pos + " container key: " + key);
+    }
+    if (chunkIndex == -1) {
+      chunkIndex = Arrays.binarySearch(chunkOffset, pos);
+    } else if (pos < chunkOffset[chunkIndex]) {
+      chunkIndex = Arrays.binarySearch(chunkOffset, 0, chunkIndex, pos);
+    } else if (pos >= chunkOffset[chunkIndex] + chunks.get(chunkIndex)
+        .getLen()) {
+      chunkIndex =
+          Arrays.binarySearch(chunkOffset, chunkIndex + 1, chunks.size(), pos);
+    }
+    if (chunkIndex < 0) {
+      // Binary search returns -insertionPoint - 1  if element is not present
+      // in the array. insertionPoint is the point at which element would be
+      // inserted in the sorted array. We need to adjust the chunkIndex
+      // accordingly so that chunkIndex = insertionPoint - 1
+      chunkIndex = -chunkIndex -2;
+    }
+    // adjust chunkIndex so that readChunkFromContainer reads the correct chunk
+    chunkIndex -= 1;
+    readChunkFromContainer();
+    adjustBufferIndex(pos);
+  }
+
+  private void adjustBufferIndex(long pos) {
+    long tempOffest = chunkOffset[chunkIndex];
+    for (int i = 0; i < buffers.size(); i++) {
+      if (pos - tempOffest >= buffers.get(i).capacity()) {
+        tempOffest += buffers.get(i).capacity();
+      } else {
+        bufferIndex = i;
+        break;
+      }
+    }
+    buffers.get(bufferIndex).position((int) (pos - tempOffest));
+  }
+
+  @Override
+  public synchronized long getPos() throws IOException {
+    return chunkIndex == -1 ? 0 :
+        chunkOffset[chunkIndex] + buffers.get(bufferIndex).position();
+  }
+
+  @Override
+  public boolean seekToNewSource(long targetPos) throws IOException {
+    return false;

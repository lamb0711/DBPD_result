HADOOP-6900. Make the iterator returned by FileSystem#listLocatedStatus to throw IOException rather than RuntimeException when there is an IO error fetching the next file. Contributed by Hairong Kuang. 



git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@984301 13f79535-47bb-0310-9956-ffa450edef68

-   * @param filter path filter
-   * If any IO exception (for example the input directory gets deleted while
-   * listing is being executed), next() or hasNext() of the returned iterator
-   * may throw a RuntimeException with the IO exception as the cause.
-  public Iterator<LocatedFileStatus> listLocatedStatus(final Path f)
+  public RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f)
-  protected Iterator<LocatedFileStatus> listLocatedStatus(final Path f,
+  protected RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f,
-    return new Iterator<LocatedFileStatus>() {
+    return new RemoteIterator<LocatedFileStatus>() {
-      /**
-       *  {@inheritDoc}
-       *  @return {@inheritDog} 
-       *  @throws Runtimeexception if any IOException occurs during traversal;
-       *  the IOException is set as the cause of the RuntimeException
-       */
-      /**
-       *  {@inheritDoc}
-       *  @return {@inheritDoc} 
-       *  @throws Runtimeexception if any IOException occurs during traversal;
-       *  the IOException is set as the cause of the RuntimeException
-       *  @exception {@inheritDoc}
-       */
-      public LocatedFileStatus next() {
+      public LocatedFileStatus next() throws IOException {
-        try {
-          BlockLocation[] locs = result.isFile() ?
+        BlockLocation[] locs = result.isFile() ?
-          return new LocatedFileStatus(result, locs);
-        } catch (IOException ioe) {
-          throw (RuntimeException)new RuntimeException().initCause(ioe);
-        }
-      }
-      
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException("Remove is not supported");
+        return new LocatedFileStatus(result, locs);
-   * If any IO exception (for example a sub-directory gets deleted while
-   * listing is being executed), next() or hasNext() of the returned iterator
-   * may throw a RuntimeException with the IO exception as the cause.
-  public Iterator<LocatedFileStatus> listFiles(
+  public RemoteIterator<LocatedFileStatus> listFiles(
-    return new Iterator<LocatedFileStatus>() {
-      private Stack<Iterator<LocatedFileStatus>> itors = 
-        new Stack<Iterator<LocatedFileStatus>>();
-      Iterator<LocatedFileStatus> curItor = listLocatedStatus(f);
-      LocatedFileStatus curFile;
+    return new RemoteIterator<LocatedFileStatus>() {
+      private Stack<RemoteIterator<LocatedFileStatus>> itors = 
+        new Stack<RemoteIterator<LocatedFileStatus>>();
+      private RemoteIterator<LocatedFileStatus> curItor =
+        listLocatedStatus(f);
+      private LocatedFileStatus curFile;
-      /**
-       *  {@inheritDoc}
-       *  @return {@inheritDog} 
-       *  @throws Runtimeexception if any IOException occurs during traversal;
-       *  the IOException is set as the cause of the RuntimeException
-       */
-      public boolean hasNext() {
+      public boolean hasNext() throws IOException {
-       * If it is a directory, tranverse the directory if recursive is true;
+       * If it is a directory, traverse the directory if recursive is true;
-       * @throws RuntimeException if any io error occurs; the io exception
-       * is set as the cause of RuntimeException
+       * @throws IOException if any IO error occurs
-      private void handleFileStat(LocatedFileStatus stat) {
-        try {
-          if (stat.isFile()) { // file
-            curFile = stat;
-          } else if (recursive) { // directory
-            itors.push(curItor);
-            curItor = listLocatedStatus(stat.getPath());
-          }
-        } catch (IOException ioe) {
-          throw (RuntimeException)new RuntimeException().initCause(ioe);
+      private void handleFileStat(LocatedFileStatus stat) throws IOException {
+        if (stat.isFile()) { // file
+          curFile = stat;
+        } else if (recursive) { // directory
+          itors.push(curItor);
+          curItor = listLocatedStatus(stat.getPath());
-      /**
-       *  {@inheritDoc}
-       *  @return {@inheritDoc} 
-       *  @throws Runtimeexception if any IOException occurs during traversal;
-       *  the IOException is set as the cause of the RuntimeException
-       *  @exception {@inheritDoc}
-       */
-      public LocatedFileStatus next() {
+      public LocatedFileStatus next() throws IOException {
-
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException("Remove is not supported");
-      }

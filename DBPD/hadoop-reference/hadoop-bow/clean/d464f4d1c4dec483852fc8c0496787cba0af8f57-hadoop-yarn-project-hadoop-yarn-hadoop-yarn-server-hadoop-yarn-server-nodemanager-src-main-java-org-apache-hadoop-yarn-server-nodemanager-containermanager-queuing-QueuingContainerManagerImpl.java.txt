YARN-5049. Extend NMStateStore to save queued container information. (Konstantinos Karanasos via asuresh)

+import org.apache.hadoop.yarn.api.records.ContainerLaunchContext;
+import org.apache.hadoop.yarn.server.nodemanager.recovery.NMStateStoreService.RecoveredContainerState;
+import org.apache.hadoop.yarn.server.nodemanager.recovery.NMStateStoreService.RecoveredContainerStatus;
+      this.context.getNMStateStore().storeContainer(containerTokenIdentifier
+          .getContainerID(), request);
+      this.context.getNMStateStore().storeContainerQueued(
+          containerTokenIdentifier.getContainerID());
+
+        this.context.getNMStateStore().storeContainerKilled(containerID);
+  /**
+   * Recover running or queued container.
+   */
+  @Override
+  protected void recoverActiveContainer(
+      ContainerLaunchContext launchContext, ContainerTokenIdentifier token,
+      RecoveredContainerState rcs) throws IOException {
+    if (rcs.getStatus() ==
+        RecoveredContainerStatus.QUEUED && !rcs.getKilled()) {
+      LOG.info(token.getContainerID()
+          + "will be added to the queued containers.");
+
+      AllocatedContainerInfo allocatedContInfo = new AllocatedContainerInfo(
+          token, rcs.getStartRequest(), token.getExecutionType(),
+              token.getResource(), getConfig());
+
+      this.context.getQueuingContext().getQueuedContainers().put(
+          token.getContainerID(), token);
+
+      if (allocatedContInfo.getExecutionType() == ExecutionType.GUARANTEED) {
+        queuedGuaranteedContainers.add(allocatedContInfo);
+        // Kill running opportunistic containers to make space for
+        // guaranteed container.
+        killOpportunisticContainers(allocatedContInfo);
+      } else {
+        queuedOpportunisticContainers.add(allocatedContInfo);
+      }
+    } else {
+      super.recoverActiveContainer(launchContext, token, rcs);
+    }
+  }
+

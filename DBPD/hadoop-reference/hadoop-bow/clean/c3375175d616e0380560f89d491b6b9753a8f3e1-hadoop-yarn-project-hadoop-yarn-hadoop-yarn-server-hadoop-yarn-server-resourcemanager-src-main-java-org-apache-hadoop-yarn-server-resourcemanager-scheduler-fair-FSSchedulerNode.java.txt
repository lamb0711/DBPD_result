YARN-6432. FairScheduler: Reserve preempted resources for corresponding applications. (Miklos Szegedi via kasha)

+import com.google.common.annotations.VisibleForTesting;
+import org.apache.hadoop.yarn.api.records.ContainerId;
+import org.apache.hadoop.yarn.api.records.Resource;
+import org.apache.hadoop.yarn.util.resource.Resources;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
-
-  private final Set<RMContainer> containersForPreemption =
+  // Stores list of containers still to be preempted
+  @VisibleForTesting
+  final Set<RMContainer> containersForPreemption =
+  // Stores amount of resources preempted and reserved for each app
+  @VisibleForTesting
+  final Map<FSAppAttempt, Resource>
+      resourcesPreemptedForApp = new LinkedHashMap<>();
+  private final Map<ApplicationAttemptId, FSAppAttempt> appIdToAppMap =
+      new HashMap<>();
+  // Sum of resourcesPreemptedForApp values, total resources that are
+  // slated for preemption
+  private Resource totalResourcesPreempted = Resource.newInstance(0, 0);
+  /**
+   * Total amount of reserved resources including reservations and preempted
+   * containers.
+   * @return total resources reserved
+   */
+  Resource getTotalReserved() {
+    Resource totalReserved = Resources.clone(getReservedContainer() != null
+        ? getReservedContainer().getAllocatedResource()
+        : Resource.newInstance(0, 0));
+    Resources.addTo(totalReserved, totalResourcesPreempted);
+    return totalReserved;
+  }
+
+   * List reserved resources after preemption and assign them to the
+   * appropriate applications in a FIFO order.
+   * @return if any resources were allocated
+   */
+  @VisibleForTesting
+  synchronized LinkedHashMap<FSAppAttempt, Resource> getPreemptionList() {
+    cleanupPreemptionList();
+    return new LinkedHashMap<>(resourcesPreemptedForApp);
+  }
+
+  /**
+   * Remove apps that have their preemption requests fulfilled.
+   */
+  private synchronized void cleanupPreemptionList() {
+    Iterator<FSAppAttempt> iterator =
+        resourcesPreemptedForApp.keySet().iterator();
+    while (iterator.hasNext()) {
+      FSAppAttempt app = iterator.next();
+      if (app.isStopped() || !app.isStarved()) {
+        // App does not need more resources
+        Resources.subtractFrom(totalResourcesPreempted,
+            resourcesPreemptedForApp.get(app));
+        appIdToAppMap.remove(app.getApplicationAttemptId());
+        iterator.remove();
+      }
+    }
+  }
+
+  /**
-   * {@link #removeContainerForPreemption} to ensure we do not mark a
-   * container for preemption and never consider it again and avoid memory
-   * leaks.
+   * {@code releaseContainer} to ensure we do not mark a container for
+   * preemption and never consider it again and avoid memory leaks.
-  void addContainersForPreemption(Collection<RMContainer> containers) {
-    containersForPreemption.addAll(containers);
+  void addContainersForPreemption(Collection<RMContainer> containers,
+                                  FSAppAttempt app) {
+
+    appIdToAppMap.putIfAbsent(app.getApplicationAttemptId(), app);
+    resourcesPreemptedForApp.putIfAbsent(app, Resource.newInstance(0, 0));
+    Resource appReserved = resourcesPreemptedForApp.get(app);
+
+    for(RMContainer container : containers) {
+      containersForPreemption.add(container);
+      Resources.addTo(appReserved, container.getAllocatedResource());
+      Resources.addTo(totalResourcesPreempted,
+          container.getAllocatedResource());
+    }
-   * Remove container from the set of containers marked for preemption.
-   *
-   * @param container container to remove
+   * The Scheduler has allocated containers on this node to the given
+   * application.
+   * @param rmContainer Allocated container
+   * @param launchedOnNode True if the container has been launched
-  void removeContainerForPreemption(RMContainer container) {
-    containersForPreemption.remove(container);
+  @Override
+  protected synchronized void allocateContainer(RMContainer rmContainer,
+                                                boolean launchedOnNode) {
+    super.allocateContainer(rmContainer, launchedOnNode);
+    Resource allocated = rmContainer.getAllocatedResource();
+    if (!Resources.isNone(allocated)) {
+      // check for satisfied preemption request and update bookkeeping
+      FSAppAttempt app =
+          appIdToAppMap.get(rmContainer.getApplicationAttemptId());
+      if (app != null) {
+        Resource reserved = resourcesPreemptedForApp.get(app);
+        Resource fulfilled = Resources.componentwiseMin(reserved, allocated);
+        Resources.subtractFrom(reserved, fulfilled);
+        Resources.subtractFrom(totalResourcesPreempted, fulfilled);
+        if (Resources.isNone(reserved)) {
+          // No more preempted containers
+          resourcesPreemptedForApp.remove(app);
+          appIdToAppMap.remove(rmContainer.getApplicationAttemptId());
+        }
+      }
+    } else {
+      LOG.error("Allocated empty container" + rmContainer.getContainerId());
+    }
+  }
+
+  /**
+   * Release an allocated container on this node.
+   * It also releases from the reservation list to trigger preemption
+   * allocations.
+   * @param containerId ID of container to be released.
+   * @param releasedByNode whether the release originates from a node update.
+   */
+  @Override
+  public synchronized void releaseContainer(ContainerId containerId,
+                                            boolean releasedByNode) {
+    RMContainer container = getContainer(containerId);
+    super.releaseContainer(containerId, releasedByNode);
+    if (container != null) {
+      containersForPreemption.remove(container);
+    }

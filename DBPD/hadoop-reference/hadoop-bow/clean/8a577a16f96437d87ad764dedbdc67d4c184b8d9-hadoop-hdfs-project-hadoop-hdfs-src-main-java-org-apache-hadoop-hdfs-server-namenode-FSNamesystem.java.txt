HDFS-4150.  Update the inode in the block map when a snapshotted file or a snapshot file is deleted. Contributed by Jing Zhao


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1406763 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.server.blockmanagement.BlockCollection;
+import org.apache.hadoop.hdfs.server.namenode.INode.BlocksMapINodeUpdateEntry;
-    int start = 0;
-    int end = 0;
-    List<Block> toDeleteList = blocks.getToDeleteList();
-    while (start < toDeleteList.size()) {
-      end = BLOCK_DELETION_INCREMENT + start;
-      end = end > toDeleteList.size() ? toDeleteList.size() : end;
+    Iterator<Map.Entry<Block, BlocksMapINodeUpdateEntry>> iter = blocks
+        .iterator();
+    while (iter.hasNext()) {
-        for (int i = start; i < end; i++) {
-          blockManager.removeBlock(toDeleteList.get(i));
+        for (int numberToHandle = BLOCK_DELETION_INCREMENT; iter.hasNext()
+            && numberToHandle > 0; numberToHandle--) {
+          Map.Entry<Block, BlocksMapINodeUpdateEntry> entry = iter.next();
+          updateBlocksMap(entry);
-      start = end;
+    }
+  }
+  
+  /**
+   * Update the blocksMap for a given block.
+   * 
+   * @param entry
+   *          The update entry containing both the block and its new INode. The
+   *          block should be removed from the blocksMap if the INode is null,
+   *          otherwise the INode for the block will be updated in the
+   *          blocksMap.
+   */
+  private void updateBlocksMap(
+      Map.Entry<Block, BlocksMapINodeUpdateEntry> entry) {
+    Block block = entry.getKey();
+    BlocksMapINodeUpdateEntry value = entry.getValue();
+    if (value == null) {
+      blockManager.removeBlock(block);
+    } else {
+      BlockCollection toDelete = value.getToDelete();
+      BlockInfo originalBlockInfo = blockManager.getStoredBlock(block);
+      // The FSDirectory tree and the blocksMap share the same INode reference.
+      // Thus we use "==" to check if the INode for the block belongs to the
+      // current file (instead of the INode from a snapshot file).
+      if (originalBlockInfo != null
+          && toDelete == originalBlockInfo.getBlockCollection()) {
+        blockManager.addBlockCollection(originalBlockInfo,
+            value.getToReplace());
+      }
-    for (Block b : blocks.getToDeleteList()) {
+    Iterator<Map.Entry<Block, BlocksMapINodeUpdateEntry>> blockIter = 
+        blocks.iterator();
+    while (blockIter.hasNext()) {
+      Map.Entry<Block, BlocksMapINodeUpdateEntry> entry = blockIter.next();
+      Block b = entry.getKey();
-      blockManager.removeBlock(b);
+      updateBlocksMap(entry);
+

Merge commit '456e901a4c5c639267ee87b8e5f1319f256d20c2' (HDFS-6407. Add sorting and pagination in the datanode tab of the NN Web UI. Contributed by Haohui Mai.) into HDFS-7285-merge

+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMApp;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.ResourceLimits;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.ResourceScheduler;
-import org.apache.hadoop.yarn.util.resource.Resources;
-import org.apache.hadoop.yarn.util.resource.ResourceCalculator;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CSAssignment;
-import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMApp;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.LeafQueue;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.SchedulingMode;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.allocator.ContainerAllocator;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.allocator.RegularContainerAllocator;
+import org.apache.hadoop.yarn.util.resource.DefaultResourceCalculator;
+import org.apache.hadoop.yarn.util.resource.ResourceCalculator;
+import org.apache.hadoop.yarn.util.resource.Resources;
+
+import com.google.common.annotations.VisibleForTesting;
-
+  private ResourceCalculator rc = new DefaultResourceCalculator();
+
+  private ResourceScheduler scheduler;
+  
+  private ContainerAllocator containerAllocator;
+
+    this(applicationAttemptId, user, queue, activeUsersManager, rmContext,
+        Priority.newInstance(0));
+  }
+
+  public FiCaSchedulerApp(ApplicationAttemptId applicationAttemptId,
+      String user, Queue queue, ActiveUsersManager activeUsersManager,
+      RMContext rmContext, Priority appPriority) {
+    setPriority(appPriority);
+
+    scheduler = rmContext.getScheduler();
+
+    if (scheduler.getResourceCalculator() != null) {
+      rc = scheduler.getResourceCalculator();
+    }
+    
+    containerAllocator = new RegularContainerAllocator(this, rc, rmContext);
-        new RMContainerFinishedEvent(
-            containerId,
-            containerStatus, 
-            event)
-        );
-    LOG.info("Completed container: " + rmContainer.getContainerId() + 
-        " in state: " + rmContainer.getState() + " event:" + event);
+        new RMContainerFinishedEvent(containerId, containerStatus, event));
+  public boolean unreserve(Priority priority,
+      FiCaSchedulerNode node, RMContainer rmContainer) {
+    // Done with the reservation?
+    if (unreserve(node, priority)) {
+      node.unreserveResource(this);
+
+      // Update reserved metrics
+      queue.getMetrics().unreserveResource(getUser(),
+          rmContainer.getContainer().getResource());
+      return true;
+    }
+    return false;
+  }
+
+  @VisibleForTesting
-  public synchronized void addPreemptContainer(ContainerId cont){
+  public synchronized void addPreemptContainer(ContainerId cont) {
+  public void reserve(Priority priority,
+      FiCaSchedulerNode node, RMContainer rmContainer, Container container) {
+    // Update reserved metrics if this is the first reservation
+    if (rmContainer == null) {
+      queue.getMetrics().reserveResource(
+          getUser(), container.getResource());
+    }
+    // Inform the application
+    rmContainer = super.reserve(node, priority, rmContainer, container);
+
+    // Update the node
+    node.reserveResource(this, priority, rmContainer);
+  }
+
+  @VisibleForTesting
+  public RMContainer findNodeToUnreserve(Resource clusterResource,
+      FiCaSchedulerNode node, Priority priority,
+      Resource minimumUnreservedResource) {
+    // need to unreserve some other container first
+    NodeId idToUnreserve =
+        getNodeIdToUnreserve(priority, minimumUnreservedResource,
+            rc, clusterResource);
+    if (idToUnreserve == null) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("checked to see if could unreserve for app but nothing "
+            + "reserved that matches for this app");
+      }
+      return null;
+    }
+    FiCaSchedulerNode nodeToUnreserve =
+        ((CapacityScheduler) scheduler).getNode(idToUnreserve);
+    if (nodeToUnreserve == null) {
+      LOG.error("node to unreserve doesn't exist, nodeid: " + idToUnreserve);
+      return null;
+    }
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("unreserving for app: " + getApplicationId()
+        + " on nodeId: " + idToUnreserve
+        + " in order to replace reserved application and place it on node: "
+        + node.getNodeID() + " needing: " + minimumUnreservedResource);
+    }
+
+    // headroom
+    Resources.addTo(getHeadroom(), nodeToUnreserve
+        .getReservedContainer().getReservedResource());
+
+    return nodeToUnreserve.getReservedContainer();
+  }
+
+  public LeafQueue getCSLeafQueue() {
+    return (LeafQueue)queue;
+  }
+  
+  public CSAssignment assignContainers(Resource clusterResource,
+      FiCaSchedulerNode node, ResourceLimits currentResourceLimits,
+      SchedulingMode schedulingMode, RMContainer reservedContainer) {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("pre-assignContainers for application "
+          + getApplicationId());
+      showRequests();
+    }
+
+    synchronized (this) {
+      return containerAllocator.assignContainers(clusterResource, node,
+          schedulingMode, currentResourceLimits, reservedContainer);
+    }
+  }

HDDS-726. Ozone Client should update SCM to move the container out of allocation path in case a write transaction fails. Contributed by Shashikant Banerjee.

+import org.apache.hadoop.hdds.protocol.DatanodeDetails;
-import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.Result;
+import org.apache.hadoop.hdds.scm.container.ContainerID;
+import org.apache.hadoop.hdds.scm.container.common.helpers.ExcludeList;
+import org.apache.hadoop.hdds.scm.pipeline.PipelineID;
+import org.apache.hadoop.ozone.client.OzoneClientUtils;
-import org.apache.hadoop.hdds.scm.container.common.helpers
-    .StorageContainerException;
-import java.util.Optional;
+import java.util.Collection;
-
+  private ExcludeList excludeList;
+    this.excludeList = new ExcludeList();
-        boolean retryFailure = checkForRetryFailure(ioe);
-        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)
-            || retryFailure) {
+        Throwable t = checkForException(ioe);
+        if (t != null) {
-          handleException(current, currentStreamIndex, retryFailure);
+          handleException(current, currentStreamIndex, t);
+   * @param pipelineId id of the associated pipeline
-  private void discardPreallocatedBlocks(long containerID) {
+  private void discardPreallocatedBlocks(long containerID,
+      PipelineID pipelineId) {
-        if (streamEntry.getBlockID().getContainerID()
-            == containerID && streamEntry.getCurrentPosition() == 0) {
+        if (((pipelineId != null && streamEntry.getPipeline().getId()
+            .equals(pipelineId)) || (containerID != -1
+            && streamEntry.getBlockID().getContainerID() == containerID))
+            && streamEntry.getCurrentPosition() == 0) {
-   * @param retryFailure if true the xceiverClient needs to be invalidated in
-   *                     the client cache.
+   * @param exception actual exception that occurred
-      int streamIndex, boolean retryFailure) throws IOException {
+      int streamIndex, Throwable exception) throws IOException {
+    boolean retryFailure = checkForRetryFailure(exception);
+    boolean closedContainerException = false;
+    if (!retryFailure) {
+      closedContainerException = checkIfContainerIsClosed(exception);
+    }
+    PipelineID pipelineId = null;
+    LOG.warn("Encountered exception {}", exception);
+    LOG.info(
+        "The last committed block length is {}, uncommitted data length is {}",
+        totalSuccessfulFlushedData, bufferedDataLen);
+    Preconditions.checkArgument(bufferedDataLen <= streamBufferMaxSize);
+    long containerId = streamEntry.getBlockID().getContainerID();
+    Collection<DatanodeDetails> failedServers = streamEntry.getFailedServers();
+    Preconditions.checkNotNull(failedServers);
+    if (!failedServers.isEmpty()) {
+      excludeList.addDatanodes(failedServers);
+    }
+    if (checkIfContainerIsClosed(exception)) {
+      excludeList.addConatinerId(ContainerID.valueof(containerId));
+    } else if (retryFailure || exception instanceof TimeoutException) {
+      pipelineId = streamEntry.getPipeline().getId();
+      excludeList.addPipeline(pipelineId);
+    }
-    // discard subsequent pre allocated blocks from the streamEntries list
-    // from the closed container
-    discardPreallocatedBlocks(streamEntry.getBlockID().getContainerID());
-  }
-  private boolean checkIfContainerIsClosed(IOException ioe) {
-    if (ioe.getCause() != null) {
-      return checkForException(ioe, ContainerNotOpenException.class) || Optional
-          .of(ioe.getCause())
-          .filter(e -> e instanceof StorageContainerException)
-          .map(e -> (StorageContainerException) e)
-          .filter(sce -> sce.getResult() == Result.CLOSED_CONTAINER_IO)
-          .isPresent();
+    if (closedContainerException) {
+      // discard subsequent pre allocated blocks from the streamEntries list
+      // from the closed container
+      discardPreallocatedBlocks(streamEntry.getBlockID().getContainerID(),
+          null);
+    } else {
+      // In case there is timeoutException or Watch for commit happening over
+      // majority or the client connection failure to the leader in the
+      // pipeline, just discard all the preallocated blocks on this pipeline.
+      // Next block allocation will happen with excluding this specific pipeline
+      // This will ensure if 2 way commit happens , it cannot span over multiple
+      // blocks
+      discardPreallocatedBlocks(-1, pipelineId);
-    return false;
-  private boolean checkForRetryFailure(IOException ioe) {
-    return checkForException(ioe, RaftRetryFailureException.class,
-        AlreadyClosedException.class);
+  private boolean checkForRetryFailure(Throwable t) {
+    return t instanceof RaftRetryFailureException
+        || t instanceof AlreadyClosedException;
-  private boolean checkForException(IOException ioe, Class... classes) {
+  private boolean checkIfContainerIsClosed(Throwable t) {
+    return t instanceof ContainerNotOpenException;
+  }
+
+  private Throwable checkForException(IOException ioe) {
-      for (Class cls : classes) {
+      for (Class<? extends Exception> cls : OzoneClientUtils
+          .getExceptionList()) {
-          return true;
+          return t;
-    return false;
-  }
-
-  private boolean checkIfTimeoutException(IOException ioe) {
-    if (ioe.getCause() != null) {
-      return Optional.of(ioe.getCause())
-          .filter(e -> e instanceof TimeoutException).isPresent();
-    } else {
-      return false;
-    }
+    return null;
-    OmKeyLocationInfo subKeyInfo = omClient.allocateBlock(keyArgs, openID);
+    OmKeyLocationInfo subKeyInfo =
+        omClient.allocateBlock(keyArgs, openID, excludeList);
+        Collection<DatanodeDetails> failedServers = entry.getFailedServers();
+
+        // failed servers can be null in case there is no data written in the
+        // stream
+        if (failedServers != null && !failedServers.isEmpty()) {
+          excludeList.addDatanodes(failedServers);
+        }
-        boolean retryFailure = checkForRetryFailure(ioe);
-        if (checkIfContainerIsClosed(ioe) || checkIfTimeoutException(ioe)
-            || retryFailure) {
+        Throwable t = checkForException(ioe);
+        if (t != null) {
-          handleException(entry, streamIndex, retryFailure);
+          handleException(entry, streamIndex, t);
+  @VisibleForTesting
+  public ExcludeList getExcludeList() {
+    return excludeList;
+  }
+

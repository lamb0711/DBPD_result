HDDS-1365. Fix error handling in KeyValueContainerCheck. Contributed by Supratim Deka.

-   * fast checks are basic and do not look inside the metadata files.
-   * Or into the structures on disk. These checks can be done on Open
-   * containers as well without concurrency implications
+   * Run basic integrity checks on container metadata.
+   * These checks do not look inside the metadata files.
+   * Applicable for OPEN containers.
+   *
+   * @return true : corruption detected, false : no corruption.
+   */
+  public boolean fastCheck() {
+    boolean corruption = false;
+    try {
+      basicChecks();
+
+    } catch (IOException e) {
+      handleCorruption(e);
+      corruption = true;
+    }
+
+    return corruption;
+  }
+
+  /**
-  public KvCheckError fastCheck() {
+  private void basicChecks() throws IOException {
-    KvCheckError error;
-    LOG.trace("Running fast check for container {};", containerID);
+    LOG.trace("Running basic checks for container {};", containerID);
-    error = loadContainerData();
-    if (error != KvCheckError.ERROR_NONE) {
-      return error;
-    }
+    loadContainerData();
-    error = checkLayout();
-    if (error != KvCheckError.ERROR_NONE) {
-      return error;
-    }
-
-    error = checkContainerFile();
-
-    return error;
+    checkLayout();
+    checkContainerFile();
-   * @return void
+   * @return true : corruption detected, false : no corruption.
-  public KvCheckError fullCheck() {
-    /**
+  public boolean fullCheck() {
+    boolean corruption = false;
-     */
-    KvCheckError error;
+    try {
+      basicChecks();
+      checkBlockDB();
-    error = fastCheck();
-    if (error != KvCheckError.ERROR_NONE) {
-
-      LOG.trace("fastCheck failed, aborting full check for Container {}",
-          containerID);
-      return error;
+    } catch (IOException e) {
+      handleCorruption(e);
+      corruption = true;
-    error = checkBlockDB();
-
-    return error;
+    return corruption;
-   *
-   * @return error code or ERROR_NONE
-  private KvCheckError checkLayout() {
-    boolean success;
-    KvCheckError error = KvCheckError.ERROR_NONE;
+  private void checkLayout() throws IOException {
-    try {
-      checkDirPath(metadataPath);
-    } catch (IOException ie) {
-      error = KvCheckError.METADATA_PATH_ACCESS;
-      handleCorruption(ie.getMessage(), error, ie);
-      return error;
-    }
+    checkDirPath(metadataPath);
-    String chunksPath = onDiskContainerData.getChunksPath();
-    try {
-      checkDirPath(chunksPath);
-    } catch (IOException ie) {
-      error = KvCheckError.CHUNKS_PATH_ACCESS;
-      handleCorruption(ie.getMessage(), error, ie);
-      return error;
-    }
-
-    return error;
+    String chunksPath = onDiskContainerData.getChunksPath();
+    checkDirPath(chunksPath);
-    boolean success = true;
-        success = false;
+        throw new IOException(errStr);
-    } catch (Exception e) {
-      throw new IOException("Generic exception checking dir ["
-          + path + "]", e);
-    try {
-      String[] ls = dirPath.list();
-      if (ls == null) {
-        // null result implies operation failed
-        success = false;
-        errStr = "null listing for directory [" + path + "]";
-      }
-    } catch (Exception e) {
-      throw new IOException("Exception listing dir [" + path + "]", e);
-    }
-
-    if (!success) {
-      Preconditions.checkState(errStr != null);
+    String[] ls = dirPath.list();
+    if (ls == null) {
+      // null result implies operation failed
+      errStr = "null listing for directory [" + path + "]";
-  private KvCheckError checkContainerFile() {
+  private void checkContainerFile() throws IOException {
-    KvCheckError error = KvCheckError.ERROR_NONE;
-    KvCheckAction next;
-    try {
-      ContainerUtils.verifyChecksum(onDiskContainerData);
-    } catch (Exception e) {
-      error = KvCheckError.CONTAINERDATA_CKSUM;
-      handleCorruption("Container File Checksum mismatch", error, e);
-      return error;
-    }
+    ContainerUtils.verifyChecksum(onDiskContainerData);
-      error = KvCheckError.CONTAINERDATA_TYPE;
-      handleCorruption(errStr, error, null);
-      return error; // Abort if we do not know the type of Container
+      throw new IOException(errStr);
-      error = KvCheckError.CONTAINERDATA_ID;
-      next = handleCorruption(errStr, error, null);
-      if (next == KvCheckAction.ABORT) {
-        return error;
-      } // else continue checking other data elements
+      throw new IOException(errStr);
-      error = KvCheckError.CONTAINERDATA_DBTYPE;
-      handleCorruption(errStr, error, null);
-      return error;
+      throw new IOException(errStr);
-      error = KvCheckError.CONTAINERDATA_METADATA_PATH;
-      next = handleCorruption(errStr, error, null);
-      if (next == KvCheckAction.ABORT) {
-        return error;
-      }
+      throw new IOException(errStr);
-
-    return error;
-  private KvCheckError checkBlockDB() {
+  private void checkBlockDB() throws IOException {
-    KvCheckError error;
-    try {
-      dbFile = KeyValueContainerLocationUtil
-          .getContainerDBFile(metaDir, containerID);
+    dbFile = KeyValueContainerLocationUtil
+        .getContainerDBFile(metaDir, containerID);
-      if (!dbFile.exists() || !dbFile.canRead()) {
-
-        String dbFileErrorMsg = "Unable to access DB File [" + dbFile.toString()
-            + "] for Container [" + containerID + "] metadata path ["
-            + metadataPath + "]";
-        error = KvCheckError.DB_ACCESS;
-        handleCorruption(dbFileErrorMsg, error, null);
-        return error;
-      }
-    } catch (Exception e) {
-      String dbFileErrorMessage =
-          "Exception when initializing DBFile" + "with metadatapath ["
-              + metadataPath + "] for Container [" + containerID
-              + "]";
-      error = KvCheckError.DB_ACCESS;
-      handleCorruption(dbFileErrorMessage, error, e);
-      return error;
+    if (!dbFile.exists() || !dbFile.canRead()) {
+      String dbFileErrorMsg = "Unable to access DB File [" + dbFile.toString()
+          + "] for Container [" + containerID + "] metadata path ["
+          + metadataPath + "]";
+      throw new IOException(dbFileErrorMsg);
+
+
+    MetadataStore db = BlockUtils
+        .getDB(onDiskContainerData, checkConfig);
-    try {
-      MetadataStore db = BlockUtils
-          .getDB(onDiskContainerData, checkConfig);
-      error = iterateBlockDB(db);
-    } catch (Exception e) {
-      error = KvCheckError.DB_ITERATOR;
-      handleCorruption("Block DB Iterator aborted", error, e);
-      return error;
-    }
-
-    return error;
+    iterateBlockDB(db);
-  private KvCheckError iterateBlockDB(MetadataStore db)
+  private void iterateBlockDB(MetadataStore db)
-    KvCheckError error = KvCheckError.ERROR_NONE;
-        try {
-          chunkFile = ChunkUtils
-              .getChunkFile(onDiskContainerData,
-                  ChunkInfo.getFromProtoBuf(chunk));
-        } catch (Exception e) {
-          error = KvCheckError.MISSING_CHUNK_FILE;
-          handleCorruption("Unable to access chunk path", error, e);
-          return error;
-        }
+        chunkFile = ChunkUtils.getChunkFile(onDiskContainerData,
+            ChunkInfo.getFromProtoBuf(chunk));
-          error = KvCheckError.MISSING_CHUNK_FILE;
-
-            error = KvCheckError.ERROR_NONE;
-            handleCorruption("Missing chunk file", error, null);
-            return error;
+            String errorStr = "Missing chunk file "
+                + chunkFile.getAbsolutePath();
+            throw new IOException(errorStr);
-
-    return error;
-  private KvCheckError loadContainerData() {
-    KvCheckError error = KvCheckError.ERROR_NONE;
+  private void loadContainerData() throws IOException {
-    try {
-      onDiskContainerData = (KeyValueContainerData) ContainerDataYaml
-          .readContainerFile(containerFile);
-    } catch (IOException e) {
-      error = KvCheckError.FILE_LOAD;
-      handleCorruption("Unable to load Container File", error, e);
-    }
-
-    return error;
+    onDiskContainerData = (KeyValueContainerData) ContainerDataYaml
+        .readContainerFile(containerFile);
-  private KvCheckAction handleCorruption(String reason,
-      KvCheckError error, Exception e) {
-
-    // XXX HDDS-1201 need to implement corruption handling/reporting
-
+  private void handleCorruption(IOException e) {
-        "Corruption detected in container: [" + containerID + "] reason: ["
-            + reason + "] error code: [" + error + "]";
-    String logMessage = null;
-
-    StackTraceElement[] stackeElems = Thread.currentThread().getStackTrace();
-    String caller =
-        "Corruption reported from Source File: [" + stackeElems[2].getFileName()
-            + "] Line: [" + stackeElems[2].getLineNumber() + "]";
-
-    if (e != null) {
-      logMessage = errStr + " exception: [" + e.getMessage() + "]";
-      e.printStackTrace();
-    } else {
-      logMessage = errStr;
-    }
-
-    LOG.error(caller);
+        "Corruption detected in container: [" + containerID + "] ";
+    String logMessage = errStr + "Exception: [" + e.getMessage() + "]";
-
-    return KvCheckAction.ABORT;
-  }
-
-  /**
-   * Pre-defined error codes for Container Metadata check.
-   */
-  public enum KvCheckError {
-    ERROR_NONE,
-    FILE_LOAD, // unable to load container metafile
-    METADATA_PATH_ACCESS, // metadata path is not accessible
-    CHUNKS_PATH_ACCESS, // chunks path is not accessible
-    CONTAINERDATA_ID, // bad Container-ID stored in Container file
-    CONTAINERDATA_METADATA_PATH, // bad metadata path in Container file
-    CONTAINERDATA_CHUNKS_PATH, // bad chunks path in Container file
-    CONTAINERDATA_CKSUM, // container file checksum mismatch
-    CONTAINERDATA_TYPE, // container file incorrect type of Container
-    CONTAINERDATA_DBTYPE, // unknown DB Type specified in Container File
-    DB_ACCESS, // unable to load Metastore DB
-    DB_ITERATOR, // unable to create block iterator for Metastore DB
-    MISSING_CHUNK_FILE // chunk file not found
-  }
-
-  private enum KvCheckAction {
-    CONTINUE, // Continue with remaining checks on the corrupt Container
-    ABORT     // Abort checks for the container

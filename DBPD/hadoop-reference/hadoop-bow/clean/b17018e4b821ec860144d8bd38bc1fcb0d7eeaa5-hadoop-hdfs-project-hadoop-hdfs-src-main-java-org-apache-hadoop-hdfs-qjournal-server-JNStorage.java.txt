HDFS-3693. JNStorage should read its storage info even before a writer becomes active. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1365794 13f79535-47bb-0310-9956-ffa450edef68

+import com.google.common.base.Preconditions;
+
-  private boolean lazyInitted = false;
+  private StorageState state;
+   * @throws IOException 
-  protected JNStorage(File logDir, StorageErrorReporter errorReporter) {
+  protected JNStorage(File logDir, StorageErrorReporter errorReporter) throws IOException {
+    
+    analyzeStorage();
-  void analyzeStorage(NamespaceInfo nsInfo) throws IOException {
-    if (lazyInitted) {
-      checkConsistentNamespace(nsInfo);
-      return;
-    }
-    
-    StorageState state = sd.analyzeStorage(StartupOption.REGULAR, this);
-    switch (state) {
-    case NON_EXISTENT:
-    case NOT_FORMATTED:
+  public void formatIfNecessary(NamespaceInfo nsInfo) throws IOException {
+    if (state == StorageState.NOT_FORMATTED ||
+        state == StorageState.NON_EXISTENT) {
-      // In the NORMAL case below, analyzeStorage() has already locked the
-      // directory for us. But in the case that we format it, we have to
-      // lock it here.
-      // The directory is unlocked in close() when the node shuts down.
-      sd.lock();
-      break;
-    case NORMAL:
-      // Storage directory is already locked by analyzeStorage() - no
-      // need to lock it here.
-      readProperties(sd);
-      checkConsistentNamespace(nsInfo);
-      break;
+      analyzeStorage();
+      assert state == StorageState.NORMAL :
+        "Unexpected state after formatting: " + state;
+    } else {
+      Preconditions.checkState(state == StorageState.NORMAL,
+          "Unhandled storage state in %s: %s", this, state);
+      assert getNamespaceID() != 0;
-    default:
-      LOG.warn("TODO: unhandled state for storage dir " + sd + ": " + state);
+      checkConsistentNamespace(nsInfo);
-    lazyInitted  = true;
+  }
+
+  private void analyzeStorage() throws IOException {
+    this.state = sd.analyzeStorage(StartupOption.REGULAR, this);
+    if (state == StorageState.NORMAL) {
+      readProperties(sd);
+    }

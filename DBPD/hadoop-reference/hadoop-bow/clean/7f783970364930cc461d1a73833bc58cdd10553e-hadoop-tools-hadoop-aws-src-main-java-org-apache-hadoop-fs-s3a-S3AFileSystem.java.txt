Revert "HADOOP-14556. S3A to support Delegation Tokens."

This reverts commit d7152332b32a575c3a92e3f4c44b95e58462528d.

-import java.util.Optional;
-import org.apache.hadoop.fs.s3a.auth.RoleModel;
-import org.apache.hadoop.fs.s3a.auth.delegation.AWSPolicyProvider;
-import org.apache.hadoop.fs.s3a.auth.delegation.EncryptionSecretOperations;
-import org.apache.hadoop.fs.s3a.auth.delegation.EncryptionSecrets;
-import org.apache.hadoop.fs.s3a.auth.delegation.S3ADelegationTokens;
-import org.apache.hadoop.fs.s3a.auth.delegation.AbstractS3ATokenIdentifier;
-import org.apache.hadoop.security.token.Token;
+import static org.apache.commons.lang3.StringUtils.isNotBlank;
-import static org.apache.hadoop.fs.s3a.auth.RolePolicies.STATEMENT_ALLOW_SSE_KMS_RW;
-import static org.apache.hadoop.fs.s3a.auth.RolePolicies.allowS3Operations;
-import static org.apache.hadoop.fs.s3a.auth.delegation.S3ADelegationTokens.TokenIssuingPolicy.NoTokensAvailable;
-import static org.apache.hadoop.fs.s3a.auth.delegation.S3ADelegationTokens.hasDelegationTokenBinding;
-import static org.apache.hadoop.io.IOUtils.cleanupWithLogger;
-public class S3AFileSystem extends FileSystem implements StreamCapabilities,
-    AWSPolicyProvider {
+public class S3AFileSystem extends FileSystem implements StreamCapabilities {
-
-  /**
-   * This must never be null; until initialized it just declares that there
-   * is no encryption.
-   */
-  private EncryptionSecrets encryptionSecrets = new EncryptionSecrets();
+  private S3AEncryptionMethods serverSideEncryptionAlgorithm;
-  /** Delegation token integration; non-empty when DT support is enabled. */
-  private Optional<S3ADelegationTokens> delegationTokens = Optional.empty();
-
-  /** Principal who created the FS; recorded during initialization. */
-  private UserGroupInformation owner;
-
+    setUri(name);
-    // patch the Hadoop security providers
-    // look for delegation token support early.
-    boolean delegationTokensEnabled = hasDelegationTokenBinding(conf);
-    if (delegationTokensEnabled) {
-      LOG.debug("Using delegation tokens");
-    }
-    // set the URI, this will do any fixup of the URI to remove secrets,
-    // canonicalize.
-    setUri(name, delegationTokensEnabled);
-    super.initialize(uri, conf);
+    super.initialize(name, conf);
-
-      // look for encryption data
-      // DT Bindings may override this
-      setEncryptionSecrets(new EncryptionSecrets(
-          getEncryptionAlgorithm(bucket, conf),
-          getServerSideEncryptionKey(bucket, getConf())));
-
-      invoker = new Invoker(new S3ARetryPolicy(getConf()), onRetry);
-      instrumentation = new S3AInstrumentation(uri);
+      instrumentation = new S3AInstrumentation(name);
-      owner = UserGroupInformation.getCurrentUser();
-      username = owner.getShortUserName();
+      username = UserGroupInformation.getCurrentUser().getShortUserName();
+
+      Class<? extends S3ClientFactory> s3ClientFactoryClass = conf.getClass(
+          S3_CLIENT_FACTORY_IMPL, DEFAULT_S3_CLIENT_FACTORY_IMPL,
+          S3ClientFactory.class);
+
+      credentials = createAWSCredentialProviderSet(name, conf);
+      s3 = ReflectionUtils.newInstance(s3ClientFactoryClass, conf)
+          .createS3Client(name, bucket, credentials);
+      invoker = new Invoker(new S3ARetryPolicy(getConf()), onRetry);
-      // creates the AWS client, including overriding auth chain if
-      // the FS came with a DT
-      // this may do some patching of the configuration (e.g. setting
-      // the encryption algorithms)
-      bindAWSClient(name, delegationTokensEnabled);
-
+      serverSideEncryptionAlgorithm = getEncryptionAlgorithm(bucket, conf);
-  /**
-   * Set up the client bindings.
-   * If delegation tokens are enabled, the FS first looks for a DT
-   * ahead of any other bindings;.
-   * If there is a DT it uses that to do the auth
-   * and switches to the DT authenticator automatically (and exclusively)
-   * @param name URI of the FS
-   * @param dtEnabled are delegation tokens enabled?
-   * @throws IOException failure.
-   */
-  private void bindAWSClient(URI name, boolean dtEnabled) throws IOException {
-    Configuration conf = getConf();
-    credentials = null;
-    String uaSuffix = "";
-
-    if (dtEnabled) {
-      // Delegation support.
-      // Create and start the DT integration.
-      // Then look for an existing DT for this bucket, switch to authenticating
-      // with it if so.
-
-      LOG.debug("Using delegation tokens");
-      S3ADelegationTokens tokens = new S3ADelegationTokens();
-      this.delegationTokens = Optional.of(tokens);
-      tokens.bindToFileSystem(getCanonicalUri(), this);
-      tokens.init(conf);
-      tokens.start();
-      // switch to the DT provider and bypass all other configured
-      // providers.
-      if (tokens.isBoundToDT()) {
-        // A DT was retrieved.
-        LOG.debug("Using existing delegation token");
-        // and use the encryption settings from that client, whatever they were
-      } else {
-        LOG.debug("No delegation token for this instance");
-      }
-      // Get new credential chain
-      credentials = tokens.getCredentialProviders();
-      // and any encryption secrets which came from a DT
-      tokens.getEncryptionSecrets()
-          .ifPresent(this::setEncryptionSecrets);
-      // and update the UA field with any diagnostics provided by
-      // the DT binding.
-      uaSuffix = tokens.getUserAgentField();
-    } else {
-      // DT support is disabled, so create the normal credential chain
-      credentials = createAWSCredentialProviderSet(name, conf);
-    }
-    LOG.debug("Using credential provider {}", credentials);
-    Class<? extends S3ClientFactory> s3ClientFactoryClass = conf.getClass(
-        S3_CLIENT_FACTORY_IMPL, DEFAULT_S3_CLIENT_FACTORY_IMPL,
-        S3ClientFactory.class);
-
-    s3 = ReflectionUtils.newInstance(s3ClientFactoryClass, conf)
-        .createS3Client(getUri(), bucket, credentials, uaSuffix);
-  }
-
-  /**
-   * Set the encryption secrets for requests.
-   * @param secrets secrets
-   */
-  protected void setEncryptionSecrets(final EncryptionSecrets secrets) {
-    this.encryptionSecrets = secrets;
-  }
-
-  /**
-   * Get the encryption secrets.
-   * This potentially sensitive information and must be treated with care.
-   * @return the current encryption secrets.
-   */
-  public EncryptionSecrets getEncryptionSecrets() {
-    return encryptionSecrets;
-  }
-
-   * Set the URI field through {@link S3xLoginHelper} and
-   * optionally {@link #canonicalizeUri(URI)}
+   * Set the URI field through {@link S3xLoginHelper}.
-   * @param fsUri filesystem URI.
-   * @param canonicalize true if the URI should be canonicalized.
+   * @param uri filesystem URI.
-  protected void setUri(URI fsUri, boolean canonicalize) {
-    URI u = S3xLoginHelper.buildFSURI(fsUri);
-    this.uri = canonicalize ? u : canonicalizeUri(u);
+  protected void setUri(URI uri) {
+    this.uri = S3xLoginHelper.buildFSURI(uri);
-  /**
-   * Get the canonical URI.
-   * @return the canonical URI of this FS.
-   */
-  public URI getCanonicalUri() {
-    return uri;
-  }
-
-  @VisibleForTesting
-    return 0;
+    return Constants.S3A_DEFAULT_PORT;
-    return encryptionSecrets.getEncryptionMethod();
+    return serverSideEncryptionAlgorithm;
-  /**
-   * Override the base canonicalization logic and relay to
-   * {@link S3xLoginHelper#canonicalizeUri(URI, int)}.
-   * This allows for the option of changing this logic for better DT handling.
-   * @param rawUri raw URI.
-   * @return the canonical URI to use in delegation tokens and file context.
-   */
-                getServerSideEncryptionAlgorithm(),
-                encryptionSecrets.getEncryptionKey()),
+                serverSideEncryptionAlgorithm,
+                getServerSideEncryptionKey(bucket, getConf())),
-  @Retries.RetryTranslated
+  @Retries.RetryRaw
-    return once("getObjectMetadata", path.toString(),
-        () ->
-          // this always does a full HEAD to the object
-          getObjectMetadata(pathToKey(path)));
-  }
-
-  /**
-   * Get all the headers of the object of a path, if the object exists.
-   * @param path path to probe
-   * @return an immutable map of object headers.
-   * @throws IOException failure of the query
-   */
-  @Retries.RetryTranslated
-  public Map<String, Object> getObjectHeaders(Path path) throws IOException {
-    LOG.debug("getObjectHeaders({})", path);
-    checkNotClosed();
-    incrementReadOperations();
-    return getObjectMetadata(path).getRawMetadata();
+    return getObjectMetadata(pathToKey(path));
-    generateSSECustomerKey().ifPresent(request::setSSECustomerKey);
+    if(S3AEncryptionMethods.SSE_C.equals(serverSideEncryptionAlgorithm) &&
+        isNotBlank(getServerSideEncryptionKey(bucket, getConf()))){
+      request.setSSECustomerKey(generateSSECustomerKey());
+    }
-   * Get the owner of this FS: who created it?
-   * @return the owner of the FS.
-   */
-  public UserGroupInformation getOwner() {
-    return owner;
-  }
-
-  /**
-      cleanupWithLogger(LOG, delegationTokens.orElse(null));
-   * Get the delegation token support for this filesystem;
-   * not null iff delegation support is enabled.
-   * @return the token support, or an empty option.
-   */
-  @VisibleForTesting
-  public Optional<S3ADelegationTokens> getDelegationTokens() {
-    return delegationTokens;
-  }
-
-  /**
-   * Return a service name iff delegation tokens are enabled and the
-   * token binding is issuing delegation tokens.
-   * @return the canonical service name or null
+   * Override getCanonicalServiceName because we don't support token in S3A.
-    // this could all be done in map statements, but it'd be harder to
-    // understand and maintain.
-    // Essentially: no DTs, no canonical service name.
-    if (!delegationTokens.isPresent()) {
-      return null;
-    }
-    // DTs present: ask the binding if it is willing to
-    // serve tokens (or fail noisily).
-    S3ADelegationTokens dt = delegationTokens.get();
-    return dt.getTokenIssuingPolicy() != NoTokensAvailable
-        ? dt.getCanonicalServiceName()
-        : null;
-  }
-
-  /**
-   * Get a delegation token if the FS is set up for them.
-   * If the user already has a token, it is returned,
-   * <i>even if it has expired</i>.
-   * @param renewer the account name that is allowed to renew the token.
-   * @return the delegation token or null
-   * @throws IOException IO failure
-   */
-  @Override
-  public Token<AbstractS3ATokenIdentifier> getDelegationToken(String renewer)
-      throws IOException {
-    entryPoint(Statistic.INVOCATION_GET_DELEGATION_TOKEN);
-    LOG.debug("Delegation token requested");
-    if (delegationTokens.isPresent()) {
-      return delegationTokens.get().getBoundOrNewDT(encryptionSecrets);
-    } else {
-      // Delegation token support is not set up
-      LOG.debug("Token support is not enabled");
-      return null;
-    }
-  }
-
-  /**
-   * Build the AWS policy for restricted access to the resources needed
-   * by this bucket.
-   * The policy generated includes S3 access, S3Guard access
-   * if needed, and KMS operations.
-   * @param access access level desired.
-   * @return a policy for use in roles
-   */
-  @Override
-  public List<RoleModel.Statement> listAWSPolicyRules(
-      final Set<AccessLevel> access) {
-    if (access.isEmpty()) {
-      return Collections.emptyList();
-    }
-    List<RoleModel.Statement> statements = new ArrayList<>(
-        allowS3Operations(bucket,
-            access.contains(AccessLevel.WRITE)
-                || access.contains(AccessLevel.ADMIN)));
-
-    // no attempt is made to qualify KMS access; there's no
-    // way to predict read keys, and not worried about granting
-    // too much encryption access.
-    statements.add(STATEMENT_ALLOW_SSE_KMS_RW);
-
-    // add any metastore policies
-    if (metadataStore instanceof AWSPolicyProvider) {
-      statements.addAll(
-          ((AWSPolicyProvider) metadataStore).listAWSPolicyRules(access));
-    }
-    return statements;
+    // Does not support Token
+    return null;
-  /**
-   * Set the optional parameters when initiating the request (encryption,
-   * headers, storage, etc).
-   * @param request request to patch.
-   */
-      InitiateMultipartUploadRequest request) {
-    generateSSEAwsKeyParams().ifPresent(request::setSSEAwsKeyManagementParams);
-    generateSSECustomerKey().ifPresent(request::setSSECustomerKey);
+      InitiateMultipartUploadRequest req) {
+    switch (serverSideEncryptionAlgorithm) {
+    case SSE_KMS:
+      req.setSSEAwsKeyManagementParams(generateSSEAwsKeyParams());
+      break;
+    case SSE_C:
+      if (isNotBlank(getServerSideEncryptionKey(bucket, getConf()))) {
+        //at the moment, only supports copy using the same key
+        req.setSSECustomerKey(generateSSECustomerKey());
+      }
+      break;
+    default:
+    }
-    generateSSECustomerKey().ifPresent(request::setSSECustomerKey);
+    switch (serverSideEncryptionAlgorithm) {
+    case SSE_C:
+      if (isNotBlank(getServerSideEncryptionKey(bucket, getConf()))) {
+        request.setSSECustomerKey(generateSSECustomerKey());
+      }
+      break;
+    default:
+    }
-    switch (getServerSideEncryptionAlgorithm()) {
+    switch (serverSideEncryptionAlgorithm) {
-      generateSSEAwsKeyParams().ifPresent(
-          copyObjectRequest::setSSEAwsKeyManagementParams);
+      copyObjectRequest.setSSEAwsKeyManagementParams(
+          generateSSEAwsKeyParams()
+      );
-      generateSSECustomerKey().ifPresent(customerKey -> {
+      if (isNotBlank(getServerSideEncryptionKey(bucket, getConf()))) {
+        //at the moment, only supports copy using the same key
+        SSECustomerKey customerKey = generateSSECustomerKey();
-      });
+      }
-    generateSSEAwsKeyParams().ifPresent(request::setSSEAwsKeyManagementParams);
-    generateSSECustomerKey().ifPresent(request::setSSECustomerKey);
+    switch (serverSideEncryptionAlgorithm) {
+    case SSE_KMS:
+      request.setSSEAwsKeyManagementParams(generateSSEAwsKeyParams());
+      break;
+    case SSE_C:
+      if (isNotBlank(getServerSideEncryptionKey(bucket, getConf()))) {
+        request.setSSECustomerKey(generateSSECustomerKey());
+      }
+      break;
+    default:
+    }
-    final S3AEncryptionMethods algorithm
-        = getServerSideEncryptionAlgorithm();
-    if (S3AEncryptionMethods.SSE_S3.equals(algorithm)) {
-      metadata.setSSEAlgorithm(algorithm.getMethod());
+    if (S3AEncryptionMethods.SSE_S3.equals(serverSideEncryptionAlgorithm)) {
+      metadata.setSSEAlgorithm(serverSideEncryptionAlgorithm.getMethod());
-   * Create the AWS SDK structure used to configure SSE,
-   * if the encryption secrets contain the information/settings for this.
-   * @return an optional set of KMS Key settings
+   * Create the AWS SDK structure used to configure SSE, based on the
+   * configuration.
+   * @return an instance of the class, which main contain the encryption key
-  private Optional<SSEAwsKeyManagementParams> generateSSEAwsKeyParams() {
-    return EncryptionSecretOperations.createSSEAwsKeyManagementParams(
-        encryptionSecrets);
+  @Retries.OnceExceptionsSwallowed
+  private SSEAwsKeyManagementParams generateSSEAwsKeyParams() {
+    //Use specified key, otherwise default to default master aws/s3 key by AWS
+    SSEAwsKeyManagementParams sseAwsKeyManagementParams =
+        new SSEAwsKeyManagementParams();
+    String encryptionKey = getServerSideEncryptionKey(bucket, getConf());
+    if (isNotBlank(encryptionKey)) {
+      sseAwsKeyManagementParams = new SSEAwsKeyManagementParams(encryptionKey);
+    }
+    return sseAwsKeyManagementParams;
-   * Create the SSE-C structure for the AWS SDK, if the encryption secrets
-   * contain the information/settings for this.
+   * Create the SSE-C structure for the AWS SDK.
-   * @return an optional customer key.
+   * @return the customer key.
-  private Optional<SSECustomerKey> generateSSECustomerKey() {
-    return EncryptionSecretOperations.createSSECustomerKey(
-        encryptionSecrets);
+  @Retries.OnceExceptionsSwallowed
+  private SSECustomerKey generateSSECustomerKey() {
+    SSECustomerKey customerKey = new SSECustomerKey(
+        getServerSideEncryptionKey(bucket, getConf()));
+    return customerKey;
-    if (getServerSideEncryptionAlgorithm() != null) {
+    if (serverSideEncryptionAlgorithm != null) {
-          .append(getServerSideEncryptionAlgorithm())
+          .append(serverSideEncryptionAlgorithm)
-    sb.append(", delegation tokens=")
-        .append(delegationTokens.map(Objects::toString).orElse("disabled"));
-      ObjectMetadata headers = getObjectMetadata(path);
-      String eTag = headers.getETag();
-      return eTag != null ? new EtagChecksum(eTag) : null;
+      return once("getFileChecksum", path.toString(),
+          () -> {
+            // this always does a full HEAD to the object
+            ObjectMetadata headers = getObjectMetadata(path);
+            String eTag = headers.getETag();
+            return eTag != null ? new EtagChecksum(eTag) : null;
+          });

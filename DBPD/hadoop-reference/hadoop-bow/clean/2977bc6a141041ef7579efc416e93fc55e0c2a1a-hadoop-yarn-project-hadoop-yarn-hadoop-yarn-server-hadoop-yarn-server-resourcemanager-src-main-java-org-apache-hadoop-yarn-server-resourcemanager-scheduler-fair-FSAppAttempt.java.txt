YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)

-import java.text.DecimalFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.common.PendingAsk;
+import java.text.DecimalFormat;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
-      SchedulerRequestKey schedulerKey, ResourceRequest request,
+      SchedulerRequestKey schedulerKey, PendingAsk pendingAsk,
-      if (getTotalRequiredResources(schedulerKey) <= 0) {
+      if (getOutstandingAsksCount(schedulerKey) <= 0) {
-        container = createContainer(node, request.getCapability(),
+        container = createContainer(node, pendingAsk.getPerAllocationResource(),
-          type, node, schedulerKey, request, container);
+          type, node, schedulerKey, container);
-  private boolean reserve(ResourceRequest request, FSSchedulerNode node,
+  private boolean reserve(Resource perAllocationResource, FSSchedulerNode node,
-            createContainer(node, request.getCapability(),
+            createContainer(node, perAllocationResource,
-   * @param request
-   *     The ResourceRequest we're trying to satisfy.
+   * @param pendingAsk
+   *     The {@link PendingAsk} we're trying to satisfy.
-      FSSchedulerNode node, ResourceRequest request, NodeType type,
+      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,
-    Resource capability = request.getCapability();
+    Resource capability = pendingAsk.getPerAllocationResource();
-          allocate(type, node, schedulerKey, request,
+          allocate(type, node, schedulerKey, pendingAsk,
-    if (isReservable(capability) &&
-        reserve(request, node, reservedContainer, type, schedulerKey)) {
+    if (isReservable(capability) && reserve(
+        pendingAsk.getPerAllocationResource(), node, reservedContainer, type,
+        schedulerKey)) {
-            getName() + ",at priority " +  request.getPriority());
+            getName() + ",at priority " +  schedulerKey.getPriority());
-  private boolean hasNodeOrRackLocalRequests(SchedulerRequestKey schedulerKey) {
-    return getResourceRequests(schedulerKey).size() > 1;
-  }
-
-      List<ResourceRequest> ask = appSchedulingInfo.getAllResourceRequests();
-      if (ask.isEmpty() || !getQueue().canRunAppAM(
-          ask.get(0).getCapability())) {
+      // Return true if we have not ask, or queue is not be able to run app's AM
+      PendingAsk ask = appSchedulingInfo.getNextPendingAsk();
+      if (ask.getCount() == 0 || !getQueue().canRunAppAM(
+          ask.getPerAllocationResource())) {
+
+      // TODO (wandga): All logics in this method should be added to
+      // SchedulerPlacement#canDelayTo which is independent from scheduler.
+      // Scheduler can choose to use various/pluggable delay-scheduling
+      // implementation.
-        ResourceRequest rackLocalRequest = getResourceRequest(schedulerKey,
+        PendingAsk rackLocalPendingAsk = getPendingAsk(schedulerKey,
-        ResourceRequest localRequest = getResourceRequest(schedulerKey,
+        PendingAsk nodeLocalPendingAsk = getPendingAsk(schedulerKey,
-        if (localRequest != null && !localRequest.getRelaxLocality()) {
+        if (nodeLocalPendingAsk.getCount() > 0
+            && !appSchedulingInfo.canDelayTo(schedulerKey,
+            node.getNodeName())) {
-              + localRequest);
+              + nodeLocalPendingAsk);
-        if (rackLocalRequest != null && rackLocalRequest.getNumContainers() != 0
-            && localRequest != null && localRequest.getNumContainers() != 0) {
+        if (rackLocalPendingAsk.getCount() > 0
+            && nodeLocalPendingAsk.getCount() > 0) {
-          return assignContainer(node, localRequest, NodeType.NODE_LOCAL,
+          return assignContainer(node, nodeLocalPendingAsk, NodeType.NODE_LOCAL,
-        if (rackLocalRequest != null && !rackLocalRequest.getRelaxLocality()) {
+        if (!appSchedulingInfo.canDelayTo(schedulerKey, node.getRackName())) {
-        if (rackLocalRequest != null && rackLocalRequest.getNumContainers() != 0
+        if (rackLocalPendingAsk.getCount() > 0
-          return assignContainer(node, rackLocalRequest, NodeType.RACK_LOCAL,
+          return assignContainer(node, rackLocalPendingAsk, NodeType.RACK_LOCAL,
-        ResourceRequest offSwitchRequest = getResourceRequest(schedulerKey,
+        PendingAsk offswitchAsk = getPendingAsk(schedulerKey,
-        if (offSwitchRequest != null && !offSwitchRequest.getRelaxLocality()) {
+        if (!appSchedulingInfo.canDelayTo(schedulerKey, ResourceRequest.ANY)) {
-        if (offSwitchRequest != null
-            && offSwitchRequest.getNumContainers() != 0) {
-          if (!hasNodeOrRackLocalRequests(schedulerKey) || allowedLocality
-              .equals(NodeType.OFF_SWITCH)) {
+        if (offswitchAsk.getCount() > 0) {
+          if (getSchedulingPlacementSet(schedulerKey).getUniqueLocationAsks()
+              <= 1 || allowedLocality.equals(NodeType.OFF_SWITCH)) {
-            return assignContainer(node, offSwitchRequest, NodeType.OFF_SWITCH,
+            return assignContainer(node, offswitchAsk, NodeType.OFF_SWITCH,
-    ResourceRequest anyRequest = getResourceRequest(key, ResourceRequest.ANY);
-    ResourceRequest rackRequest = getResourceRequest(key, node.getRackName());
-    ResourceRequest nodeRequest = getResourceRequest(key, node.getNodeName());
+    PendingAsk offswitchAsk = getPendingAsk(key, ResourceRequest.ANY);
+    Resource resource = offswitchAsk.getPerAllocationResource();
+    boolean hasRequestForOffswitch =
+        offswitchAsk.getCount() > 0;
+    boolean hasRequestForRack = getOutstandingAsksCount(key,
+        node.getRackName()) > 0;
+    boolean hasRequestForNode = getOutstandingAsksCount(key,
+        node.getNodeName()) > 0;
-        anyRequest != null && anyRequest.getNumContainers() > 0 &&
-        // If locality relaxation is turned off at *-level, there must be a
-        // non-zero request for the node's rack:
-        (anyRequest.getRelaxLocality() ||
-        (rackRequest != null && rackRequest.getNumContainers() > 0)) &&
-        // If locality relaxation is turned off at rack-level, there must be a
-        // non-zero request at the node:
-        (rackRequest == null || rackRequest.getRelaxLocality() ||
-        (nodeRequest != null && nodeRequest.getNumContainers() > 0)) &&
-        // The requested container must be able to fit on the node:
-        Resources.lessThanOrEqual(RESOURCE_CALCULATOR, null,
-        anyRequest.getCapability(), node.getRMNode().getTotalCapability()))) {
+        hasRequestForOffswitch &&
+            // If locality relaxation is turned off at *-level, there must be a
+            // non-zero request for the node's rack:
+            (appSchedulingInfo.canDelayTo(key, ResourceRequest.ANY) ||
+                (hasRequestForRack)) &&
+            // If locality relaxation is turned off at rack-level,
+            // there must be a non-zero request at the node:
+            (!hasRequestForRack || appSchedulingInfo.canDelayTo(key,
+                node.getRackName()) || (hasRequestForNode)) &&
+            // The requested container must be able to fit on the node:
+            Resources.lessThanOrEqual(RESOURCE_CALCULATOR, null,
+                resource,
+                node.getRMNode().getTotalCapability()))) {
-    } else if (!getQueue().fitsInMaxShare(anyRequest.getCapability())) {
+    } else if (!getQueue().fitsInMaxShare(resource)) {
-        updateAMDiagnosticMsg(anyRequest.getCapability(),
+        updateAMDiagnosticMsg(resource,
-  ResourceRequest getNextResourceRequest() {
-    return appSchedulingInfo.getNextResourceRequest();
-  }
-
-        ResourceRequest r = getResourceRequest(k, ResourceRequest.ANY);
-        if (r != null) {
-          Resources.multiplyAndAddTo(demand, r.getCapability(),
-              r.getNumContainers());
+        PendingAsk pendingAsk = getPendingAsk(k, ResourceRequest.ANY);
+        if (pendingAsk.getCount() > 0) {
+          Resources.multiplyAndAddTo(demand,
+              pendingAsk.getPerAllocationResource(),
+              pendingAsk.getCount());
-        List<ResourceRequest> ask = appSchedulingInfo.getAllResourceRequests();
-        updateAMDiagnosticMsg(ask.get(0).getCapability(), " exceeds maximum "
-            + "AM resource allowed).");
+        PendingAsk amAsk = appSchedulingInfo.getNextPendingAsk();
+        updateAMDiagnosticMsg(amAsk.getPerAllocationResource(),
+            " exceeds maximum AM resource allowed).");

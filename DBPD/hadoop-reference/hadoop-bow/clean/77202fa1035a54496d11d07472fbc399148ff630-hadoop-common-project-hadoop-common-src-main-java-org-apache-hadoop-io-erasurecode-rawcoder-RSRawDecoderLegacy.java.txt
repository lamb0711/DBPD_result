HADOOP-13010. Refactor raw erasure coders. Contributed by Kai Zheng

-import org.apache.hadoop.io.erasurecode.rawcoder.util.CoderUtil;
+import org.apache.hadoop.io.erasurecode.ErasureCoderOptions;
-public class RSRawDecoderLegacy extends AbstractRawErasureDecoder {
+public class RSRawDecoderLegacy extends RawErasureDecoder {
-  public RSRawDecoderLegacy(int numDataUnits, int numParityUnits) {
-    super(numDataUnits, numParityUnits);
-    if (numDataUnits + numParityUnits >= RSUtil.GF.getFieldSize()) {
+  public RSRawDecoderLegacy(ErasureCoderOptions coderOptions) {
+    super(coderOptions);
+    if (getNumAllUnits() >= RSUtil.GF.getFieldSize()) {
-    this.errSignature = new int[numParityUnits];
-    this.primitivePower = RSUtil.getPrimitivePower(numDataUnits,
-        numParityUnits);
+    this.errSignature = new int[getNumParityUnits()];
+    this.primitivePower = RSUtil.getPrimitivePower(getNumDataUnits(),
+        getNumParityUnits());
-  protected void doDecode(byte[][] inputs, int[] inputOffsets,
-                          int dataLen, int[] erasedIndexes,
-                          byte[][] outputs, int[] outputOffsets) {
+  protected void doDecode(ByteArrayDecodingState decodingState) {
+    int dataLen = decodingState.decodeLength;
+    CoderUtil.resetOutputBuffers(decodingState.outputs,
+        decodingState.outputOffsets, dataLen);
+
-        CoderUtil.getErasedOrNotToReadIndexes(inputs);
+        CoderUtil.getNullIndexes(decodingState.inputs);
-    for (int outputIdx = 0, i = 0; i < erasedIndexes.length; i++) {
+    for (int outputIdx = 0, i = 0;
+         i < decodingState.erasedIndexes.length; i++) {
-        if (erasedIndexes[i] == erasedOrNotToReadIndexes[j]) {
+        if (decodingState.erasedIndexes[i] == erasedOrNotToReadIndexes[j]) {
-          adjustedByteArrayOutputsParameter[j] = resetBuffer(
-                  outputs[outputIdx], outputOffsets[outputIdx], dataLen);
-          adjustedOutputOffsets[j] = outputOffsets[outputIdx];
+          adjustedByteArrayOutputsParameter[j] = CoderUtil.resetBuffer(
+              decodingState.outputs[outputIdx],
+              decodingState.outputOffsets[outputIdx], dataLen);
+          adjustedOutputOffsets[j] = decodingState.outputOffsets[outputIdx];
-        adjustedByteArrayOutputsParameter[i] = resetBuffer(
+        adjustedByteArrayOutputsParameter[i] = CoderUtil.resetBuffer(
-    doDecodeImpl(inputs, inputOffsets, dataLen, erasedOrNotToReadIndexes,
+    doDecodeImpl(decodingState.inputs, decodingState.inputOffsets,
+        dataLen, erasedOrNotToReadIndexes,
-  protected void doDecode(ByteBuffer[] inputs, int[] erasedIndexes,
-                          ByteBuffer[] outputs) {
-    ByteBuffer validInput = CoderUtil.findFirstValidInput(inputs);
-    int dataLen = validInput.remaining();
+  protected void doDecode(ByteBufferDecodingState decodingState) {
+    int dataLen = decodingState.decodeLength;
+    CoderUtil.resetOutputBuffers(decodingState.outputs, dataLen);
-        CoderUtil.getErasedOrNotToReadIndexes(inputs);
+        CoderUtil.getNullIndexes(decodingState.inputs);
-    for (int outputIdx = 0, i = 0; i < erasedIndexes.length; i++) {
+    for (int outputIdx = 0, i = 0;
+         i < decodingState.erasedIndexes.length; i++) {
-        if (erasedIndexes[i] == erasedOrNotToReadIndexes[j]) {
+        if (decodingState.erasedIndexes[i] == erasedOrNotToReadIndexes[j]) {
-          adjustedDirectBufferOutputsParameter[j] =
-              resetBuffer(outputs[outputIdx++], dataLen);
+          adjustedDirectBufferOutputsParameter[j] = CoderUtil.resetBuffer(
+              decodingState.outputs[outputIdx++], dataLen);
-        adjustedDirectBufferOutputsParameter[i] = resetBuffer(buffer, dataLen);
+        adjustedDirectBufferOutputsParameter[i] =
+            CoderUtil.resetBuffer(buffer, dataLen);
-    doDecodeImpl(inputs, erasedOrNotToReadIndexes,
+    doDecodeImpl(decodingState.inputs, erasedOrNotToReadIndexes,

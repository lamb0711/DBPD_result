YARN-6255. Refactor yarn-native-services framework. Contributed by Jian He

-import com.codahale.metrics.Metric;
-import com.codahale.metrics.MetricRegistry;
+import org.apache.hadoop.metrics2.lib.DefaultMetricsSystem;
+import org.apache.hadoop.metrics2.lib.MutableGaugeInt;
-import org.apache.hadoop.yarn.api.records.impl.pb.ContainerPBImpl;
-import org.apache.slider.api.ClusterDescriptionKeys;
-import org.apache.slider.api.ClusterDescriptionOperations;
-import org.apache.slider.api.ResourceKeys;
+import org.apache.slider.api.proto.Messages;
+import org.apache.slider.api.resource.Application;
+import org.apache.slider.api.resource.ApplicationState;
+import org.apache.slider.api.resource.Component;
-import org.apache.slider.common.tools.ConfigHelper;
-import org.apache.slider.core.conf.AggregateConf;
-import org.apache.slider.core.conf.ConfTree;
-import org.apache.slider.core.conf.ConfTreeOperations;
-import org.apache.slider.core.conf.MapOperations;
-import org.apache.slider.core.persist.AggregateConfSerDeser;
-import org.apache.slider.core.persist.ConfTreeSerDeser;
-import org.apache.slider.server.appmaster.management.LongGauge;
+import org.apache.slider.server.appmaster.metrics.SliderMetrics;
-import java.util.Collections;
+import static org.apache.hadoop.metrics2.lib.Interns.info;
-import static org.apache.slider.api.RoleKeys.*;
-import static org.apache.slider.providers.docker.DockerKeys.DEFAULT_DOCKER_USE_PRIVILEGED;
-import static org.apache.slider.providers.docker.DockerKeys.DOCKER_IMAGE;
-import static org.apache.slider.providers.docker.DockerKeys.DOCKER_USE_PRIVILEGED;
+import static org.apache.slider.api.resource.ApplicationState.STARTED;
-  /**
-   * The definition of the instance. Flexing updates the resources section
-   * This is used as a synchronization point on activities that update
-   * the CD, and also to update some of the structures that
-   * feed in to the CD
-   */
-  private AggregateConf instanceDefinition;
+  private Application app;
-  /**
-   * Time the instance definition snapshots were created
-   */
-  private long snapshotTime;
-
-  /**
-   * Snapshot of the instance definition. This is fully
-   * resolved.
-   */
-  private AggregateConf instanceDefinitionSnapshot;
-
-  /**
-   * Snapshot of the raw instance definition; unresolved and
-   * without any patch of an AM into it.
-   */
-  private AggregateConf unresolvedInstanceDefinition;
-
-  /**
-   * snapshot of resources as of last update time
-   */
-  private ConfTreeOperations resourcesSnapshot;
-  private ConfTreeOperations appConfSnapshot;
-  private ConfTreeOperations internalsSnapshot;
-
-  /**
-   * This is the status, the live model
-   */
-  private ClusterDescription clusterStatus = new ClusterDescription();
-
-  /**
-   * Metadata provided by the AM for use in filling in status requests
-   */
-  private Map<String, String> applicationInfo;
-
-  /**
-   * Client properties created via the provider -static for the life
-   * of the application
-   */
-  private Map<String, String> clientProperties = new HashMap<>();
-   * The master node.
-   */
-  private RoleInstance appMasterNode;
-
-  /**
-  
-  /**
-   * Counter for completed containers ( complete denotes successful or failed )
-   */
-  private final LongGauge completedContainerCount = new LongGauge();
-
-  /**
-   *   Count of failed containers
-   */
-  private final LongGauge failedContainerCount = new LongGauge();
-
-  /**
-   * # of started containers
-   */
-  private final LongGauge startedContainers = new LongGauge();
-
-  /**
-   * # of containers that failed to start 
-   */
-  private final LongGauge startFailedContainerCount = new LongGauge();
-
-  /**
-   * Track the number of surplus containers received and discarded
-   */
-  private final LongGauge surplusContainers = new LongGauge();
-
-  /**
-   * Track the number of requested containers.
-   * Important: this does not include AA requests which are yet to be issued.
-   */
-  private final LongGauge outstandingContainerRequests = new LongGauge();
-  private final Set<ContainerId> surplusNodes = new HashSet<>();
+  private final Set<ContainerId> surplusContainers = new HashSet<>();
-
+  private SliderMetrics appMetrics;
-
-    // register any metrics
-    register(MetricsConstants.CONTAINERS_OUTSTANDING_REQUESTS, outstandingContainerRequests);
-    register(MetricsConstants.CONTAINERS_SURPLUS, surplusContainers);
-    register(MetricsConstants.CONTAINERS_STARTED, startedContainers);
-    register(MetricsConstants.CONTAINERS_COMPLETED, completedContainerCount);
-    register(MetricsConstants.CONTAINERS_FAILED, failedContainerCount);
-    register(MetricsConstants.CONTAINERS_START_FAILED, startFailedContainerCount);
-  }
-
-  private void register(String name, Metric counter) {
-    this.metricsAndMonitoring.getMetrics().register(
-        MetricRegistry.name(AppState.class, name), counter);
-  }
-
-  public long getFailedCountainerCount() {
-    return failedContainerCount.getCount();
-  }
-
-  /**
-   * Increment the count
-   */
-  public void incFailedCountainerCount() {
-    failedContainerCount.inc();
-  }
-
-  public long getStartFailedCountainerCount() {
-    return startFailedContainerCount.getCount();
-  }
-
-  /**
-   * Increment the count and return the new value
-   */
-  public void incStartedCountainerCount() {
-    startedContainers.inc();
-  }
-
-  public long getStartedCountainerCount() {
-    return startedContainers.getCount();
-  }
-
-  /**
-   * Increment the count and return the new value
-   */
-  public void incStartFailedCountainerCount() {
-    startFailedContainerCount.inc();
-  }
-
-  public AtomicInteger getCompletionOfNodeNotInLiveListEvent() {
-    return completionOfNodeNotInLiveListEvent;
-  }
-
-  public AtomicInteger getCompletionOfUnknownContainerEvent() {
-    return completionOfUnknownContainerEvent;
-  protected Map<String, ProviderRole> getRoleMap() {
-    return roles;
-  }
-  public Map<Integer, ProviderRole> getRolePriorityMap() {
-    return rolePriorityMap;
-  }
-   * <p>
-   *   Calls to {@link #refreshClusterStatus()} trigger a
-   *   refresh of this field.
-   * <p>
-  public synchronized ClusterDescription getClusterStatus() {
-    return clusterStatus;
-  }
-
-  @VisibleForTesting
-  protected synchronized void setClusterStatus(ClusterDescription clusterDesc) {
-    this.clusterStatus = clusterDesc;
-  }
-
-  /**
-   * Set the instance definition -this also builds the (now obsolete)
-   * cluster specification from it.
-   * 
-   * Important: this is for early binding and must not be used after the build
-   * operation is complete. 
-   * @param definition initial definition
-   * @throws BadConfigException
-   */
-  public synchronized void setInitialInstanceDefinition(AggregateConf definition)
-      throws BadConfigException, IOException {
-    log.debug("Setting initial instance definition");
-    // snapshot the definition
-    AggregateConfSerDeser serDeser = new AggregateConfSerDeser();
-
-    unresolvedInstanceDefinition = serDeser.fromInstance(definition);
-    
-    this.instanceDefinition = serDeser.fromInstance(definition);
-    onInstanceDefinitionUpdated();
-  }
-
-  public synchronized AggregateConf getInstanceDefinition() {
-    return instanceDefinition;
+  public synchronized Application getClusterStatus() {
+    return app;
-  public ConfTreeOperations getResourcesSnapshot() {
-    return resourcesSnapshot;
-  }
-
-  public ConfTreeOperations getAppConfSnapshot() {
-    return appConfSnapshot;
-  }
-
-  public ConfTreeOperations getInternalsSnapshot() {
-    return internalsSnapshot;
-  }
-
-  public long getSnapshotTime() {
-    return snapshotTime;
-  }
-
-  public synchronized AggregateConf getInstanceDefinitionSnapshot() {
-    return instanceDefinitionSnapshot;
-  }
-
-  public AggregateConf getUnresolvedInstanceDefinition() {
-    return unresolvedInstanceDefinition;
-  }
-    publishedProviderConf = binding.publishedProviderConf;
-    applicationInfo = binding.applicationInfo != null ? binding.applicationInfo
-                        : new HashMap<String, String>();
-
-    clientProperties = new HashMap<>();
-
-    Set<String> confKeys = ConfigHelper.sortedConfigKeys(publishedProviderConf);
-
-    //  Add the -site configuration properties
-    for (String key : confKeys) {
-      String val = publishedProviderConf.get(key);
-      clientProperties.put(key, val);
-    }
-
-    setInitialInstanceDefinition(binding.instanceDefinition);
+    this.app = binding.application;
+    appMetrics = SliderMetrics.register(app.getName(),
+        "Metrics for service");
+    appMetrics
+        .tag("type", "Metrics type [component or service]", "service");
+    appMetrics
+        .tag("appId", "Application id for service", app.getId());
-    ConfTreeOperations resources = instanceDefinition.getResourceOperations();
-
-    Set<String> roleNames = resources.getComponentNames();
-    for (String name : roleNames) {
+    int priority = 1;
+    for (Component component : app.getComponents()) {
+      String name = component.getName();
-      if (hasUniqueNames(resources, name)) {
-        log.info("Skipping group {}", name);
+      if (component.getUniqueComponentSupport()) {
+        log.info("Skipping group " + name + ", as it's unique component");
-      // this is a new value
-      log.info("Adding role {}", name);
-      MapOperations resComponent = resources.getComponent(name);
-      ProviderRole dynamicRole = createDynamicProviderRole(name, resComponent);
+      log.info("Adding component: " + name);
+      ProviderRole dynamicRole =
+          createComponent(name, name, component, priority++);
-    //set the livespan
-    MapOperations globalResOpts = instanceDefinition.getResourceOperations().getGlobalOptions();
-
-    startTimeThreshold = globalResOpts.getOptionInt(
-        InternalKeys.INTERNAL_CONTAINER_FAILURE_SHORTLIFE,
-        InternalKeys.DEFAULT_INTERNAL_CONTAINER_FAILURE_SHORTLIFE);
-
-    failureThreshold = globalResOpts.getOptionInt(
-        CONTAINER_FAILURE_THRESHOLD,
+    org.apache.slider.api.resource.Configuration conf = app.getConfiguration();
+    startTimeThreshold =
+        conf.getPropertyLong(InternalKeys.INTERNAL_CONTAINER_FAILURE_SHORTLIFE,
+            InternalKeys.DEFAULT_INTERNAL_CONTAINER_FAILURE_SHORTLIFE);
+    failureThreshold = (int) conf.getPropertyLong(CONTAINER_FAILURE_THRESHOLD,
-    nodeFailureThreshold = globalResOpts.getOptionInt(
-        NODE_FAILURE_THRESHOLD,
+    nodeFailureThreshold = (int) conf.getPropertyLong(NODE_FAILURE_THRESHOLD,
-    initClusterStatus();
-
-    roleHistory.register(metricsAndMonitoring);
-
+    app.setState(STARTED);
-  public void initClusterStatus() {
-    //copy into cluster status. 
-    ClusterDescription status = ClusterDescription.copy(clusterStatusTemplate);
-    status.state = STATE_CREATED;
-    MapOperations infoOps = new MapOperations("info", status.info);
-    infoOps.mergeWithoutOverwrite(applicationInfo);
-    SliderUtils.addBuildInfo(infoOps, "status");
+  //TODO WHY do we need to create the component for AM ?
+  public ProviderRole createComponent(String name, String group,
+      Component component, int priority) throws BadConfigException {
-    long now = now();
-    status.setInfoTime(StatusKeys.INFO_LIVE_TIME_HUMAN,
-                              StatusKeys.INFO_LIVE_TIME_MILLIS,
-                              now);
-    SliderUtils.setInfoTime(infoOps,
-        StatusKeys.INFO_LIVE_TIME_HUMAN,
-        StatusKeys.INFO_LIVE_TIME_MILLIS,
-        now);
-    if (0 == status.createTime) {
-      status.createTime = now;
-      SliderUtils.setInfoTime(infoOps,
-          StatusKeys.INFO_CREATE_TIME_HUMAN,
-          StatusKeys.INFO_CREATE_TIME_MILLIS,
-          now);
-    }
-    status.state = STATE_LIVE;
+    org.apache.slider.api.resource.Configuration conf =
+        component.getConfiguration();
+    long placementTimeout = conf.getPropertyLong(PLACEMENT_ESCALATE_DELAY,
+        DEFAULT_PLACEMENT_ESCALATE_DELAY_SECONDS);
+    long placementPolicy = conf.getPropertyLong(COMPONENT_PLACEMENT_POLICY,
+        PlacementPolicy.DEFAULT);
+    int threshold = (int) conf
+        .getPropertyLong(NODE_FAILURE_THRESHOLD, nodeFailureThreshold);
+    ProviderRole newRole =
+        new ProviderRole(name, group, priority, (int)placementPolicy, threshold,
+            placementTimeout, "", component);
-      //set the app state to this status
-    setClusterStatus(status);
-  }
-
-  /**
-   * Build a dynamic provider role
-   * @param name name of role
-   * @return a new provider role
-   * @throws BadConfigException bad configuration
-   */
-  public ProviderRole createDynamicProviderRole(String name, MapOperations component)
-      throws BadConfigException {
-    return createDynamicProviderRole(name, name, component);
-  }
-
-  /**
-   * Build a dynamic provider role
-   * @param name name of role
-   * @param group group of role
-   * @return a new provider role
-   * @throws BadConfigException bad configuration
-   */
-  public ProviderRole createDynamicProviderRole(String name, String group, MapOperations component)
-      throws BadConfigException {
-    String priOpt = component.getMandatoryOption(COMPONENT_PRIORITY);
-    int priority = SliderUtils.parseAndValidate(
-        "value of " + name + " " + COMPONENT_PRIORITY, priOpt, 0, 1, -1);
-
-    String placementOpt = component.getOption(COMPONENT_PLACEMENT_POLICY,
-        Integer.toString(PlacementPolicy.DEFAULT));
-
-    int placement = SliderUtils.parseAndValidate(
-        "value of " + name + " " + COMPONENT_PLACEMENT_POLICY, placementOpt, 0, 0, -1);
-
-    int placementTimeout = component.getOptionInt(PLACEMENT_ESCALATE_DELAY,
-            DEFAULT_PLACEMENT_ESCALATE_DELAY_SECONDS);
-
-    ProviderRole newRole = new ProviderRole(name,
-        group,
-        priority,
-        placement,
-        getNodeFailureThresholdForRole(group),
-        placementTimeout,
-        component.getOption(YARN_LABEL_EXPRESSION, DEF_YARN_LABEL_EXPRESSION));
-    log.info("New {} ", newRole);
+    log.info("Created a new role " + newRole);
-  /**
-   * Actions to perform when an instance definition is updated
-   * Currently: 
-   * <ol>
-   *   <li>
-   *     resolve the configuration
-   *   </li>
-   *   <li>
-   *     update the cluster spec derivative
-   *   </li>
-   * </ol>
-   *  
-   * @throws BadConfigException
-   */
-  private synchronized void onInstanceDefinitionUpdated()
-      throws BadConfigException, IOException {
-
-    log.debug("Instance definition updated");
-    //note the time 
-    snapshotTime = now();
-
-    for (String component : instanceDefinition.getResourceOperations().getComponentNames()) {
-      instanceDefinition.getAppConfOperations().getOrAddComponent(component);
+  public synchronized void updateComponents(
+      Messages.FlexComponentRequestProto requestProto)
+      throws BadConfigException {
+    for (Component component : app.getComponents()) {
+      if (component.getName().equals(requestProto.getName())) {
+        component
+            .setNumberOfContainers((long) requestProto.getNumberOfContainers());
+      }
-
-    // resolve references if not already done
-    instanceDefinition.resolve();
-
-    // force in the AM desired state values
-    ConfTreeOperations resources = instanceDefinition.getResourceOperations();
-
-    if (resources.getComponent(SliderKeys.COMPONENT_AM) != null) {
-      resources.setComponentOpt(
-          SliderKeys.COMPONENT_AM, COMPONENT_INSTANCES, "1");
-    }
-
-
-    //snapshot all three sectons
-    resourcesSnapshot = ConfTreeOperations.fromInstance(instanceDefinition.getResources());
-    appConfSnapshot = ConfTreeOperations.fromInstance(instanceDefinition.getAppConf());
-    internalsSnapshot = ConfTreeOperations.fromInstance(instanceDefinition.getInternal());
-    //build a new aggregate from the snapshots
-    instanceDefinitionSnapshot = new AggregateConf(resourcesSnapshot.confTree,
-                                                   appConfSnapshot.confTree,
-                                                   internalsSnapshot.confTree);
-    instanceDefinitionSnapshot.setName(instanceDefinition.getName());
-
-    clusterStatusTemplate = ClusterDescriptionOperations.buildFromInstanceDefinition(
-          instanceDefinition);
-
-    // Add the -site configuration properties
-    for (Map.Entry<String, String> prop : clientProperties.entrySet()) {
-      clusterStatusTemplate.clientProperties.put(prop.getKey(), prop.getValue());
-    }
-
-  }
-
-  /**
-   * The resource configuration is updated -review and update state.
-   * @param resources updated resources specification
-   * @return a list of any dynamically added provider roles
-   * (purely for testing purposes)
-   */
-  @VisibleForTesting
-  public synchronized List<ProviderRole> updateResourceDefinitions(ConfTree resources)
-      throws BadConfigException, IOException {
-    log.debug("Updating resources to {}", resources);
-    // snapshot the (possibly unresolved) values
-    ConfTreeSerDeser serDeser = new ConfTreeSerDeser();
-    unresolvedInstanceDefinition.setResources(
-        serDeser.fromInstance(resources));
-    // assign another copy under the instance definition for resolving
-    // and then driving application size
-    instanceDefinition.setResources(serDeser.fromInstance(resources));
-    onInstanceDefinitionUpdated();
-
-    // propagate the role table
-    Map<String, Map<String, String>> updated = resources.components;
-    getClusterStatus().roles = SliderUtils.deepClone(updated);
-    getClusterStatus().updateTime = now();
-    return buildRoleRequirementsFromResources();
+    //TODO update cluster description
+    buildRoleRequirementsFromResources();
-  private List<ProviderRole> buildRoleRequirementsFromResources() throws BadConfigException {
+  private List<ProviderRole> buildRoleRequirementsFromResources()
+      throws BadConfigException {
-
-    ConfTreeOperations resources =
-        instanceDefinition.getResourceOperations();
-
+    // component name -> number of containers
+
-      int desiredInstanceCount = getDesiredInstanceCount(resources, roleGroup);
+      Component component = roleStatus.getProviderRole().component;
+      int desiredInstanceCount = component.getNumberOfContainers().intValue();
-      if (hasUniqueNames(resources, roleGroup)) {
+      if (component.getUniqueComponentSupport()) {
-        roleStatus.setDesired(newDesired);
+        setDesiredContainers(roleStatus, newDesired);
-    Set<String> roleNames = resources.getComponentNames();
-    for (String name : roleNames) {
+
+    List<RoleStatus> list = new ArrayList<>(getRoleStatusMap().values());
+    for (RoleStatus roleStatus : list) {
+      String name = roleStatus.getName();
+      Component component = roleStatus.getProviderRole().component;
-      if (hasUniqueNames(resources, name)) {
+      if (component.getUniqueComponentSupport()) {
-        int desiredInstanceCount = getDesiredInstanceCount(resources, name);
+        int desiredInstanceCount = component.getNumberOfContainers().intValue();
-          int priority = resources.getComponentOptInt(name, COMPONENT_PRIORITY, i);
+          int priority = roleStatus.getPriority();
-          MapOperations component = resources.getComponent(name,
-              Collections.singletonMap(COMPONENT_PRIORITY,
-                  Integer.toString(newPriority)));
-          if (component == null) {
-            throw new BadConfigException("Component is null for name = " + name
-                + ", newPriority =" + newPriority);
-          }
-          ProviderRole dynamicRole = createDynamicProviderRole(newName, name, component);
-          RoleStatus roleStatus = buildRole(dynamicRole);
-          roleStatus.setDesired(1);
-          log.info("New role {}", roleStatus);
+          ProviderRole dynamicRole =
+              createComponent(newName, name, component, newPriority);
+          RoleStatus newRole = buildRole(dynamicRole);
+          incDesiredContainers(newRole);
+          log.info("New role {}", newRole);
-            roleHistory.addNewRole(roleStatus);
+            roleHistory.addNewRole(newRole);
-        MapOperations component = resources.getComponent(name);
-        ProviderRole dynamicRole = createDynamicProviderRole(name, component);
-        RoleStatus roleStatus = buildRole(dynamicRole);
-        roleStatus.setDesired(getDesiredInstanceCount(resources, name));
-        log.info("New role {}", roleStatus);
+        ProviderRole dynamicRole =
+            createComponent(name, name, component, roleStatus.getPriority());
+        RoleStatus newRole = buildRole(dynamicRole);
+        incDesiredContainers(roleStatus,
+            component.getNumberOfContainers().intValue());
+        log.info("New role {}", newRole);
-          roleHistory.addNewRole(roleStatus);
+          roleHistory.addNewRole(newRole);
-   * Get the desired instance count of a role, rejecting negative values
-   * @param resources resource map
-   * @param roleGroup role group
-   * @return the instance count
-   * @throws BadConfigException if the count is negative
-   */
-  private int getDesiredInstanceCount(ConfTreeOperations resources,
-      String roleGroup) throws BadConfigException {
-    int desiredInstanceCount =
-      resources.getComponentOptInt(roleGroup, COMPONENT_INSTANCES, 0);
-
-    if (desiredInstanceCount < 0) {
-      log.error("Role {} has negative desired instances : {}", roleGroup,
-          desiredInstanceCount);
-      throw new BadConfigException(
-          "Negative instance count (%) requested for component %s",
-          desiredInstanceCount, roleGroup);
-    }
-    return desiredInstanceCount;
-  }
-
-  private Boolean hasUniqueNames(ConfTreeOperations resources, String group) {
-    MapOperations component = resources.getComponent(group);
-    if (component == null) {
-      log.info("Component was null for {} when checking unique names", group);
-      return Boolean.FALSE;
-    }
-    return component.getOptionBool(UNIQUE_NAMES, Boolean.FALSE);
-  }
-
-  /**
-      role.setResourceRequirements(
-          buildResourceRequirements(role, recordFactory.newResource()));
+      role.setResourceRequirements(buildResourceRequirements(role));
-
-  /**
-   * build up the special master node, which lives
-   * in the live node set but has a lifecycle bonded to the AM
-   * @param containerId the AM master
-   * @param host hostname
-   * @param amPort port
-   * @param nodeHttpAddress http address: may be null
-   */
-  public void buildAppMasterNode(ContainerId containerId,
-                                 String host,
-                                 int amPort,
-                                 String nodeHttpAddress) {
-    Container container = new ContainerPBImpl();
-    container.setId(containerId);
-    NodeId nodeId = NodeId.newInstance(host, amPort);
-    container.setNodeId(nodeId);
-    container.setNodeHttpAddress(nodeHttpAddress);
-    RoleInstance am = new RoleInstance(container);
-    am.role = SliderKeys.COMPONENT_AM;
-    am.group = SliderKeys.COMPONENT_AM;
-    am.roleId = SliderKeys.ROLE_AM_PRIORITY_INDEX;
-    am.createTime =now();
-    am.startTime = am.createTime;
-    appMasterNode = am;
-    //it is also added to the set of live nodes
-    getLiveContainers().put(containerId, am);
-    putOwnedContainer(containerId, am);
-
-    // patch up the role status
-    RoleStatus roleStatus = roleStatusMap.get(SliderKeys.ROLE_AM_PRIORITY_INDEX);
-    roleStatus.setDesired(1);
-    roleStatus.incActual();
-    roleStatus.incStarted();
-  }
-
-  /**
-   * Note that the master node has been launched,
-   * though it isn't considered live until any forked
-   * processes are running. It is NOT registered with
-   * the role history -the container is incomplete
-   * and it will just cause confusion
-   */
-  public void noteAMLaunched() {
-    getLiveContainers().put(appMasterNode.getContainerId(), appMasterNode);
-  }
-
-  /**
-   * AM declares ourselves live in the cluster description.
-   * This is meant to be triggered from the callback
-   * indicating the spawned process is up and running.
-   */
-  public void noteAMLive() {
-    appMasterNode.state = STATE_LIVE;
-  }
-
-  /**
-   * Get a deep clone of the role status list. Concurrent events may mean this
-   * list (or indeed, some of the role status entries) may be inconsistent
-   * @return a snapshot of the role status entries
-   */
-  public List<RoleStatus> cloneRoleStatusList() {
-    Collection<RoleStatus> statuses = roleStatusMap.values();
-    List<RoleStatus> statusList = new ArrayList<>(statuses.size());
-    try {
-      for (RoleStatus status : statuses) {
-        statusList.add((RoleStatus)(status.clone()));
-      }
-    } catch (CloneNotSupportedException e) {
-      log.warn("Unexpected cloning failure: {}", e, e);
-    }
-    return statusList;
-  }
-
-    RoleStatus role = lookupRoleStatus(instance.roleId);
-    role.incReleasing();
+    incPendingContainers(role);
-      incrementRequestCount(role);
-    incrementRequestCount(role);
-  /**
-   * Increment the request count of a role.
-   * <p>
-   *   Also updates application state counters
-   * @param role role being requested.
-   */
-  protected void incrementRequestCount(RoleStatus role) {
-    role.incRequested();
-    incOutstandingContainerRequests();
+  private void incPendingContainers(RoleStatus role) {
+    role.getComponentMetrics().containersPending.incr();
+    appMetrics.containersPending.incr();
-  /**
-   * Inc #of outstanding requests.
-   */
-  private void incOutstandingContainerRequests() {
-     outstandingContainerRequests.inc();
+  private void decPendingContainers(RoleStatus role) {
+    decPendingContainers(role, 1);
-  /**
-   * Decrement the number of outstanding requests. This never goes below zero.
-   */
-  private void decOutstandingContainerRequests() {
-    synchronized (outstandingContainerRequests) {
-      if (outstandingContainerRequests.getCount() > 0) {
-        // decrement but never go below zero
-        outstandingContainerRequests.dec();
-      }
+  private void decPendingContainers(RoleStatus role, int n) {
+    role.getComponentMetrics().containersPending.decr(n);;
+    appMetrics.containersPending.decr(n);
+  }
+
+
+  private void incRunningContainers(RoleStatus role) {
+    role.getComponentMetrics().containersRunning.incr();;
+    appMetrics.containersRunning.incr();
+  }
+
+  private void decRunningContainers(RoleStatus role) {
+    role.getComponentMetrics().containersRunning.decr();;
+    appMetrics.containersRunning.decr();
+  }
+
+  private void setDesiredContainers(RoleStatus role, int n) {
+    role.getComponentMetrics().containersDesired.set(n);
+    appMetrics.containersDesired.set(n);
+  }
+
+  private void incDesiredContainers(RoleStatus role) {
+    role.getComponentMetrics().containersDesired.incr();
+    appMetrics.containersDesired.incr();
+  }
+
+  private void incDesiredContainers(RoleStatus role, int n) {
+    role.getComponentMetrics().containersDesired.incr(n);
+    appMetrics.containersDesired.incr(n);
+  }
+
+  private void incCompletedContainers(RoleStatus role) {
+    role.getComponentMetrics().containersCompleted.incr();
+    appMetrics.containersCompleted.incr();
+  }
+
+  private void incFailedContainers(RoleStatus role, ContainerOutcome outcome) {
+    role.getComponentMetrics().containersFailed.incr();
+    appMetrics.containersFailed.incr();
+    switch (outcome) {
+    case Preempted:
+      appMetrics.containersPreempted.incr();
+      role.getComponentMetrics().containersPreempted.incr();
+      break;
+    case Failed:
+      appMetrics.failedSinceLastThreshold.incr();
+      break;
+    default:
+      break;
-
-  /**
-   * Get the value of a YARN requirement (cores, RAM, etc).
-   * These are returned as integers, but there is special handling of the 
-   * string {@link ResourceKeys#YARN_RESOURCE_MAX}, which triggers
-   * the return of the maximum value.
-   * @param group component to get from
-   * @param option option name
-   * @param defVal default value
-   * @param maxVal value to return if the max val is requested
-   * @return parsed value
-   * @throws NumberFormatException if the role could not be parsed.
-   */
-  private int getResourceRequirement(ConfTreeOperations resources,
-                                     String group,
-                                     String option,
-                                     int defVal,
-                                     int maxVal) {
-
-    String val = resources.getComponentOpt(group, option,
-        Integer.toString(defVal));
-    Integer intVal;
-    if (YARN_RESOURCE_MAX.equals(val)) {
-      intVal = maxVal;
-    } else {
-      intVal = Integer.decode(val);
-    }
-    return intVal;
-  }
-
-   * @param capability capability to set up. A new one may be created
-  public Resource buildResourceRequirements(RoleStatus role, Resource capability) {
+  public Resource buildResourceRequirements(RoleStatus role) {
-    String group = role.getGroup();
-    ConfTreeOperations resources = getResourcesSnapshot();
-    int cores = getResourceRequirement(resources,
-                                       group,
-                                       YARN_CORES,
-                                       DEF_YARN_CORES,
-                                       containerMaxCores);
-    capability.setVirtualCores(cores);
-    int ram = getResourceRequirement(resources, group,
-                                     YARN_MEMORY,
-                                     DEF_YARN_MEMORY,
-                                     containerMaxMemory);
-    capability.setMemory(ram);
-    log.debug("Component {} has RAM={}, vCores ={}", name, ram, cores);
+    Component component = role.getProviderRole().component;
+    if (component == null) {
+      // this is for AM container
+      // TODO why do we need to create the component for AM ?
+      return Resource.newInstance(1, 512);
+    }
+    int cores = Math.min(containerMaxCores, component.getResource().getCpus());
+    if (cores <= 0) {
+      cores = DEF_YARN_CORES;
+    }
+    long mem = Math.min(containerMaxMemory,
+        Long.parseLong(component.getResource().getMemory()));
+    if (mem <= 0) {
+      mem = DEF_YARN_MEMORY;
+    }
+    Resource capability = Resource.newInstance(mem, cores);
+    log.debug("Component {} has RAM={}, vCores ={}", name, mem, cores);
-    incStartedCountainerCount();
-    RoleStatus roleStatus = lookupRoleStatus(instance.roleId);
-    roleStatus.incStarted();
-    incFailedCountainerCount();
-    incStartFailedCountainerCount();
-      roleStatus.noteFailed(true, text, ContainerOutcome.Failed);
+      roleStatus.noteFailed(text);
+      incFailedContainers(roleStatus, ContainerOutcome.Failed);
-  public synchronized NodeCompletionResult onCompletedNode(ContainerStatus status) {
+  public synchronized NodeCompletionResult onCompletedContainer(
+      ContainerStatus status) {
-      long releasing = roleStatus.decReleasing();
-      long actual = roleStatus.decActual();
-      long completedCount = roleStatus.incCompleted();
-      log.info("decrementing role count for role {} to {}; releasing={}, completed={}",
+      decRunningContainers(roleStatus);
+      incCompletedContainers(roleStatus);
+      log.info("decrementing role count for role {} to {}; completed={}",
-          actual,
-          releasing,
-          completedCount);
+          roleStatus.getComponentMetrics().containersRunning.value(),
+          roleStatus.getComponentMetrics().containersCompleted.value());
-    } else if (surplusNodes.remove(containerId)) {
+    } else if (surplusContainers.remove(containerId)) {
-        //it was active, move it to failed 
-        incFailedCountainerCount();
+        RoleStatus roleStatus = lookupRoleStatus(roleInstance.roleId);
+        incFailedContainers(roleStatus, result.outcome);
-          RoleStatus roleStatus = lookupRoleStatus(roleId);
-          roleStatus.decActual();
+          RoleStatus roleStatus = lookupRoleStatus(roleInstance.roleId);
+          decRunningContainers(roleStatus);
-          roleStatus.noteFailed(shortLived, message, result.outcome);
-          long failed = roleStatus.getFailed();
+          roleStatus.noteFailed(message);
+          incFailedContainers(roleStatus, result.outcome);
+          long failed =
+              roleStatus.getComponentMetrics().containersFailed.value();
-      actual += role.getActual();
+      actual += role.getRunning();
+
-  public ClusterDescription refreshClusterStatus() {
-    return refreshClusterStatus(null);
-  }
+  public synchronized Application refreshClusterStatus() {
-  /**
-   * Update the cluster description with the current application state
-   * @param providerStatus status from the provider for the cluster info section
-   */
-  public synchronized ClusterDescription refreshClusterStatus(Map<String, String> providerStatus) {
+    //TODO replace ClusterDescription with Application + related statistics
+    //TODO build container stats
+    app.setState(ApplicationState.STARTED);
+    return app;
+/*
+    return app;
+
-    if (providerStatus != null) {
-      for (Map.Entry<String, String> entry : providerStatus.entrySet()) {
-        cd.setInfo(entry.getKey(), entry.getValue());
-      }
-    }
+
-
-      if (hasUniqueNames(instanceDefinition.getResourceOperations(),
-          role.getGroup())) {
-        cd.setRoleOpt(rolename, COMPONENT_PRIORITY, role.getPriority());
-        cd.setRoleOpt(rolename, ROLE_GROUP, role.getGroup());
-        MapOperations groupOptions = instanceDefinition.getResourceOperations()
-            .getComponent(role.getGroup());
-        SliderUtils.mergeMapsIgnoreDuplicateKeys(cd.getRole(rolename),
-            groupOptions.options);
-      }
-      String prefix = instanceDefinition.getAppConfOperations()
-          .getComponentOpt(role.getGroup(), ROLE_PREFIX, null);
-      if (SliderUtils.isSet(prefix)) {
-        cd.setRoleOpt(rolename, ROLE_PREFIX, SliderUtils.trimPrefix(prefix));
-      }
-      String dockerImage = instanceDefinition.getAppConfOperations()
-          .getComponentOpt(role.getGroup(), DOCKER_IMAGE, null);
-      if (SliderUtils.isSet(dockerImage)) {
-        cd.setRoleOpt(rolename, DOCKER_IMAGE, dockerImage);
-        Boolean dockerUsePrivileged = instanceDefinition.getAppConfOperations()
-            .getComponentOptBool(role.getGroup(), DOCKER_USE_PRIVILEGED,
-                DEFAULT_DOCKER_USE_PRIVILEGED);
-        cd.setRoleOpt(rolename, DOCKER_USE_PRIVILEGED, dockerUsePrivileged);
-      }
-    return cd;
+    return cd;*/
-  /**
-   * Get the live statistics map
-   * @return a map of statistics values, defined in the {@link StatusKeys}
-   * keylist.
-   */
-  protected Map<String, Integer> getLiveStatistics() {
-    Map<String, Integer> sliderstats = new HashMap<>();
-    sliderstats.put(StatusKeys.STATISTICS_CONTAINERS_LIVE,
-        liveNodes.size());
-    sliderstats.put(StatusKeys.STATISTICS_CONTAINERS_COMPLETED,
-        completedContainerCount.intValue());
-    sliderstats.put(StatusKeys.STATISTICS_CONTAINERS_FAILED,
-        failedContainerCount.intValue());
-    sliderstats.put(StatusKeys.STATISTICS_CONTAINERS_STARTED,
-        startedContainers.intValue());
-    sliderstats.put(StatusKeys.STATISTICS_CONTAINERS_START_FAILED,
-         startFailedContainerCount.intValue());
-    sliderstats.put(StatusKeys.STATISTICS_CONTAINERS_SURPLUS,
-        surplusContainers.intValue());
-    sliderstats.put(StatusKeys.STATISTICS_CONTAINERS_UNKNOWN_COMPLETED,
-        completionOfUnknownContainerEvent.get());
-    return sliderstats;
-  }
-    log.debug("in reviewRequestAndReleaseNodes()");
+    log.info("in reviewRequestAndReleaseNodes()");
-        SliderExitCodes.EXIT_DEPLOYMENT_FAILED,
-          FinalApplicationStatus.FAILED, ErrorStrings.E_UNSTABLE_CLUSTER +
-        " - failed with component %s failed 'recently' %d times (%d in startup);" +
-        " threshold is %d - last failure: %s",
-          role.getName(),
-        role.getFailed(),
-        role.getStartFailed(),
-          threshold,
-        role.getFailureMessage());
+          SliderExitCodes.EXIT_DEPLOYMENT_FAILED, FinalApplicationStatus.FAILED,
+          ErrorStrings.E_UNSTABLE_CLUSTER
+              + " - failed with component %s failed 'recently' %d times;"
+              + " threshold is %d - last failure: %s", role.getName(),
+          role.getFailedRecently(), threshold, role.getFailureMessage());
-    ConfTreeOperations resources =
-        instanceDefinition.getResourceOperations();
-    return resources.getComponentOptInt(roleStatus.getGroup(),
-        CONTAINER_FAILURE_THRESHOLD,
-        failureThreshold);
+    return (int) roleStatus.getProviderRole().component.getConfiguration()
+        .getPropertyLong(CONTAINER_FAILURE_THRESHOLD,
+            DEFAULT_CONTAINER_FAILURE_THRESHOLD);
-  /**
-   * Get the node failure threshold for a specific role, falling back to
-   * the global one if not
-   * @param roleGroup role group
-   * @return the threshold for failures
-   */
-  private int getNodeFailureThresholdForRole(String roleGroup) {
-    ConfTreeOperations resources =
-        instanceDefinition.getResourceOperations();
-    return resources.getComponentOptInt(roleGroup,
-                                        NODE_FAILURE_THRESHOLD,
-                                        nodeFailureThreshold);
-  }
-      log.info("Resetting failure count of {}; was {}",
-               roleStatus.getName(),
+      log.info("Resetting failure count of {}; was {}", roleStatus.getName(),
+
+    log.info("review one role " + role.getName());
-        role.setPendingAntiAffineRequests(pending);
+        //TODO
+        role.setAAPending((int)pending);
-      long outstandingRequests = role.getRequested() + role.getPendingAntiAffineRequests();
+      long outstandingRequests = role.getPending() + role.getAAPending();
-
-        role.cancel(toCancel);
+        decPendingContainers(role, toCancel);
-      if (role.getPendingAntiAffineRequests() > 0) {
+      if (role.getAAPending() > 0) {
-        role.setPendingAntiAffineRequests(0);
+        role.setAAPending(0);
-   * Find a container running on a specific host -looking
-   * into the node ID to determine this.
-   *
-   * @param node node
-   * @param roleId role the container must be in
-   * @return a container or null if there are no containers on this host
-   * that can be released.
-   */
-  private RoleInstance findRoleInstanceOnHost(NodeInstance node, int roleId) {
-    Collection<RoleInstance> targets = cloneOwnedContainerList();
-    String hostname = node.hostname;
-    for (RoleInstance ri : targets) {
-      if (hostname.equals(RoleHistoryUtils.hostnameOf(ri.container))
-                         && ri.roleId == roleId
-        && containersBeingReleased.get(ri.getContainerId()) == null) {
-        return ri;
-      }
-    }
-    return null;
-  }
-
-  /**
-  public synchronized void onContainersAllocated(List<Container> allocatedContainers,
-                                    List<ContainerAssignment> assignments,
-                                    List<AbstractRMOperation> operations) {
-    assignments.clear();
-    operations.clear();
+  public synchronized void onContainersAllocated(
+      List<Container> allocatedContainers,
+      List<ContainerAssignment> assignments,
+      List<AbstractRMOperation> operations) {
-    log.debug("onContainersAllocated(): Total containers allocated = {}", ordered.size());
+    log.info("onContainersAllocated(): Total containers allocated = {}", ordered.size());
-
-      //dec requested count
-      role.decRequested();
+      decPendingContainers(role);
-      final long allocated = role.incActual();
+      MutableGaugeInt containersRunning = role.getComponentMetrics().containersRunning;
+      final long allocated = containersRunning.value();
+      incRunningContainers(role);
-        surplusNodes.add(cid);
-        surplusContainers.inc();
-        //and, as we aren't binding it to role, dec that role's actual count
-        role.decActual();
+        surplusContainers.add(cid);
+        role.getComponentMetrics().surplusContainers.incr();
+        containersRunning.decr();
-
-        // Allocation being accepted -so decrement the number of outstanding requests
-        decOutstandingContainerRequests();
-
-        log.info("Assigning role {} to container" +
-                 " {}," +
-                 " on {}:{},",
-                 roleName,
-                 cid,
-                 nodeId.getHost(),
-                 nodeId.getPort());
+        log.info("Assigning role {} to container" + " {}," + " on {}:{},",
+            roleName, cid, nodeId.getHost(), nodeId.getPort());
-          if (role.getPendingAntiAffineRequests() > 0) {
+          if (role.getAAPending() > 0) {
-              role.decPendingAntiAffineRequests();
+              role.decAAPending();
-    clusterStatus.setInfo(StatusKeys.INFO_CONTAINERS_AM_RESTART,
-                               Integer.toString(liveContainers.size()));
+    app.setNumberOfRunningContainers((long)liveContainers.size());
-    RoleStatus role =
-      lookupRoleStatus(roleId);
+    RoleStatus role = lookupRoleStatus(roleId);
-    role.incActual();
+    incRunningContainers(role);
-    sb.append(", startedContainers=").append(startedContainers);
-    sb.append(", startFailedContainerCount=").append(startFailedContainerCount);
-    sb.append(", surplusContainers=").append(surplusContainers);
-    sb.append(", failedContainerCount=").append(failedContainerCount);
-    sb.append(", outstanding non-AA Container Requests=")
-        .append(outstandingContainerRequests);

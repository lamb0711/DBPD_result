YARN-5906. Update AppSchedulingInfo to use SchedulingPlacementSet. Contributed by Wangda Tan.

-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentSkipListMap;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-import org.apache.commons.collections.IteratorUtils;
-import org.apache.hadoop.yarn.server.resourcemanager.nodelabels.RMNodeLabelsManager;
-import org.apache.hadoop.yarn.server.resourcemanager.scheduler.placement.PlacementSet;
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.placement.LocalitySchedulingPlacementSet;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentSkipListMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
-  final Map<SchedulerRequestKey, Map<String, ResourceRequest>>
-      resourceRequestMap = new ConcurrentHashMap<>();
+  final Map<SchedulerRequestKey, SchedulingPlacementSet<SchedulerNode>>
+      schedulerKeyToPlacementSets = new ConcurrentHashMap<>();
-    resourceRequestMap.clear();
+    schedulerKeyToPlacementSets.clear();
-  private void decrementSchedulerKeyReference(
+  public void decrementSchedulerKeyReference(
+    if (null == requests || requests.isEmpty()) {
+      return false;
+    }
+
-    boolean anyResourcesUpdated = false;
+    boolean offswitchResourcesUpdated = false;
-      // Update resource requests
+
+      // A map to group resource requests and dedup
+      Map<SchedulerRequestKey, Map<String, ResourceRequest>> dedupRequests =
+          new HashMap<>();
+
+      // Group resource request by schedulerRequestKey and resourceName
-        String resourceName = request.getResourceName();
+        if (!dedupRequests.containsKey(schedulerKey)) {
+          dedupRequests.put(schedulerKey, new HashMap<>());
+        }
+        dedupRequests.get(schedulerKey).put(request.getResourceName(), request);
+      }
-        // Update node labels if required
-        updateNodeLabels(request);
+      // Update scheduling placement set
+      for (Map.Entry<SchedulerRequestKey, Map<String, ResourceRequest>> entry : dedupRequests.entrySet()) {
+        SchedulerRequestKey schedulerRequestKey = entry.getKey();
-        Map<String, ResourceRequest> asks =
-            this.resourceRequestMap.get(schedulerKey);
-        if (asks == null) {
-          asks = new ConcurrentHashMap<>();
-          this.resourceRequestMap.put(schedulerKey, asks);
+        if (!schedulerKeyToPlacementSets.containsKey(schedulerRequestKey)) {
+          schedulerKeyToPlacementSets.put(schedulerRequestKey,
+              new LocalitySchedulingPlacementSet<>(this));
-        // Increment number of containers if recovering preempted resources
-        ResourceRequest lastRequest = asks.get(resourceName);
-        if (recoverPreemptedRequestForAContainer && lastRequest != null) {
-          request.setNumContainers(lastRequest.getNumContainers() + 1);
-        }
+        // Update placement set
+        ResourceRequestUpdateResult pendingAmountChanges =
+            schedulerKeyToPlacementSets.get(schedulerRequestKey)
+                .updateResourceRequests(
+                    entry.getValue().values(),
+                    recoverPreemptedRequestForAContainer);
-        // Update asks
-        asks.put(resourceName, request);
-
-        if (resourceName.equals(ResourceRequest.ANY)) {
-          //update the applications requested labels set
-          requestedPartitions.add(request.getNodeLabelExpression() == null
-              ? RMNodeLabelsManager.NO_LABEL :
-                  request.getNodeLabelExpression());
-
-          anyResourcesUpdated = true;
-
-          // Update pendingResources
-          updatePendingResources(lastRequest, request, schedulerKey,
+        if (null != pendingAmountChanges) {
+          updatePendingResources(
+              pendingAmountChanges.getLastAnyResourceRequest(),
+              pendingAmountChanges.getNewResourceRequest(), schedulerRequestKey,
+          offswitchResourcesUpdated = true;
-      return anyResourcesUpdated;
+
+      return offswitchResourcesUpdated;
-  private void updateNodeLabels(ResourceRequest request) {
-    SchedulerRequestKey schedulerKey = SchedulerRequestKey.create(request);
-    String resourceName = request.getResourceName();
-    if (resourceName.equals(ResourceRequest.ANY)) {
-      ResourceRequest previousAnyRequest =
-          getResourceRequest(schedulerKey, resourceName);
+  public void addRequestedPartition(String partition) {
+    requestedPartitions.add(partition);
+  }
-      // When there is change in ANY request label expression, we should
-      // update label for all resource requests already added of same
-      // priority as ANY resource request.
-      if ((null == previousAnyRequest)
-          || hasRequestLabelChanged(previousAnyRequest, request)) {
-        Map<String, ResourceRequest> resourceRequest =
-            getResourceRequests(schedulerKey);
-        if (resourceRequest != null) {
-          for (ResourceRequest r : resourceRequest.values()) {
-            if (!r.getResourceName().equals(ResourceRequest.ANY)) {
-              r.setNodeLabelExpression(request.getNodeLabelExpression());
-            }
-          }
-        }
-      }
-    } else {
-      ResourceRequest anyRequest =
-          getResourceRequest(schedulerKey, ResourceRequest.ANY);
-      if (anyRequest != null) {
-        request.setNodeLabelExpression(anyRequest.getNodeLabelExpression());
-      }
-    }
+  public void decPendingResource(String partition, Resource toDecrease) {
+    queue.decPendingResource(partition, toDecrease);
+    appResourceUsage.decPending(partition, toDecrease);
+  @SuppressWarnings("unchecked")
-    return resourceRequestMap.get(schedulerKey);
+    SchedulingPlacementSet ps = schedulerKeyToPlacementSets.get(schedulerKey);
+    if (null != ps) {
+      return ps.getResourceRequests();
+    }
+    return Collections.emptyMap();
-      for (Map<String, ResourceRequest> r : resourceRequestMap.values()) {
-        ret.addAll(r.values());
+      for (SchedulingPlacementSet ps : schedulerKeyToPlacementSets.values()) {
+        ret.addAll(ps.getResourceRequests().values());
-      Map<String, ResourceRequest> nodeRequests =
-          resourceRequestMap.get(schedulerKey);
-      return (nodeRequests == null) ? null : nodeRequests.get(resourceName);
+      SchedulingPlacementSet ps =
+          schedulerKeyToPlacementSets.get(schedulerKey);
+      return (ps == null) ? null : ps.getResourceRequest(resourceName);
-    for (ResourceRequest rr:
-        resourceRequestMap.get(schedulerKeys.firstKey()).values()) {
-      return rr;
+    SchedulingPlacementSet<SchedulerNode> ps = schedulerKeyToPlacementSets.get(
+        schedulerKeys.firstKey());
+    if (null != ps) {
+      for (ResourceRequest rr : ps.getResourceRequests().values()) {
+        return rr;
+      }
+
+      ResourceRequest request,
-      ResourceRequest request;
-      if (type == NodeType.NODE_LOCAL) {
-        request = resourceRequestMap.get(schedulerKey).get(node.getNodeName());
-      } else if (type == NodeType.RACK_LOCAL) {
-        request = resourceRequestMap.get(schedulerKey).get(node.getRackName());
-      } else{
-        request = resourceRequestMap.get(schedulerKey).get(ResourceRequest.ANY);
-      }
-      return allocate(type, node, schedulerKey, request, containerAllocated);
-    } finally {
-      writeLock.unlock();
-    }
-  }
-
-  /**
-   * Resources have been allocated to this application by the resource
-   * scheduler. Track them.
-   * @param type Node Type
-   * @param node SchedulerNode
-   * @param schedulerKey SchedulerRequestKey
-   * @param request ResourceRequest
-   * @param containerAllocated Container Allocated
-   * @return List of ResourceRequests
-   */
-  public List<ResourceRequest> allocate(NodeType type,
-      SchedulerNode node, SchedulerRequestKey schedulerKey,
-      ResourceRequest request, Container containerAllocated) {
-    try {
-      writeLock.lock();
-      List<ResourceRequest> resourceRequests = new ArrayList<>();
-      if (type == NodeType.NODE_LOCAL) {
-        allocateNodeLocal(node, schedulerKey, request, resourceRequests);
-      } else if (type == NodeType.RACK_LOCAL) {
-        allocateRackLocal(node, schedulerKey, request, resourceRequests);
-      } else{
-        allocateOffSwitch(request, resourceRequests, schedulerKey);
-      }
-        updateMetricsForAllocatedContainer(request, type, containerAllocated);
+        updateMetricsForAllocatedContainer(type, containerAllocated);
-      return resourceRequests;
+
+      return schedulerKeyToPlacementSets.get(schedulerKey).allocate(type, node,
+          request);
-  /**
-   * The {@link ResourceScheduler} is allocating data-local resources to the
-   * application.
-   */
-  private void allocateNodeLocal(SchedulerNode node,
-      SchedulerRequestKey schedulerKey, ResourceRequest nodeLocalRequest,
-      List<ResourceRequest> resourceRequests) {
-    // Update future requirements
-    decResourceRequest(node.getNodeName(), schedulerKey, nodeLocalRequest);
-
-    ResourceRequest rackLocalRequest = resourceRequestMap.get(schedulerKey).get(
-        node.getRackName());
-    decResourceRequest(node.getRackName(), schedulerKey, rackLocalRequest);
-
-    ResourceRequest offRackRequest = resourceRequestMap.get(schedulerKey).get(
-        ResourceRequest.ANY);
-    decrementOutstanding(offRackRequest, schedulerKey);
-
-    // Update cloned NodeLocal, RackLocal and OffRack requests for recovery
-    resourceRequests.add(cloneResourceRequest(nodeLocalRequest));
-    resourceRequests.add(cloneResourceRequest(rackLocalRequest));
-    resourceRequests.add(cloneResourceRequest(offRackRequest));
+  public List<ResourceRequest> allocate(NodeType type,
+      SchedulerNode node, SchedulerRequestKey schedulerKey,
+      Container containerAllocated) {
+    return allocate(type, node, schedulerKey, null, containerAllocated);
-  private void decResourceRequest(String resourceName,
-      SchedulerRequestKey schedulerKey, ResourceRequest request) {
-    request.setNumContainers(request.getNumContainers() - 1);
-    if (request.getNumContainers() == 0) {
-      resourceRequestMap.get(schedulerKey).remove(resourceName);
-    }
-  }
-
-  /**
-   * The {@link ResourceScheduler} is allocating data-local resources to the
-   * application.
-   */
-  private void allocateRackLocal(SchedulerNode node,
-      SchedulerRequestKey schedulerKey, ResourceRequest rackLocalRequest,
-      List<ResourceRequest> resourceRequests) {
-    // Update future requirements
-    decResourceRequest(node.getRackName(), schedulerKey, rackLocalRequest);
-    
-    ResourceRequest offRackRequest = resourceRequestMap.get(schedulerKey).get(
-        ResourceRequest.ANY);
-    decrementOutstanding(offRackRequest, schedulerKey);
-
-    // Update cloned RackLocal and OffRack requests for recovery
-    resourceRequests.add(cloneResourceRequest(rackLocalRequest));
-    resourceRequests.add(cloneResourceRequest(offRackRequest));
-  }
-
-  /**
-   * The {@link ResourceScheduler} is allocating data-local resources to the
-   * application.
-   */
-  private void allocateOffSwitch(ResourceRequest offSwitchRequest,
-      List<ResourceRequest> resourceRequests,
-      SchedulerRequestKey schedulerKey) {
-    // Update future requirements
-    decrementOutstanding(offSwitchRequest, schedulerKey);
-    // Update cloned OffRack requests for recovery
-    resourceRequests.add(cloneResourceRequest(offSwitchRequest));
-  }
-
-  private void decrementOutstanding(ResourceRequest offSwitchRequest,
-      SchedulerRequestKey schedulerKey) {
-    int numOffSwitchContainers = offSwitchRequest.getNumContainers() - 1;
-
-    // Do not remove ANY
-    offSwitchRequest.setNumContainers(numOffSwitchContainers);
-    
-    // Do we have any outstanding requests?
-    // If there is nothing, we need to deactivate this application
-    if (numOffSwitchContainers == 0) {
-      decrementSchedulerKeyReference(schedulerKey);
-      checkForDeactivation();
-    }
-    
-    appResourceUsage.decPending(offSwitchRequest.getNodeLabelExpression(),
-        offSwitchRequest.getCapability());
-    queue.decPendingResource(offSwitchRequest.getNodeLabelExpression(),
-        offSwitchRequest.getCapability());
-  }
-
-  private void checkForDeactivation() {
+  public void checkForDeactivation() {
-      for (Map<String, ResourceRequest> asks : resourceRequestMap.values()) {
-        ResourceRequest request = asks.get(ResourceRequest.ANY);
-        if (request != null) {
+      for (SchedulingPlacementSet ps : schedulerKeyToPlacementSets.values()) {
+        ResourceRequest request = ps.getResourceRequest(ResourceRequest.ANY);
+        if (request != null && request.getNumContainers() > 0) {
-      for (Map<String, ResourceRequest> asks : resourceRequestMap.values()) {
-        ResourceRequest request = asks.get(ResourceRequest.ANY);
-        if (request != null) {
+      for (SchedulingPlacementSet ps : schedulerKeyToPlacementSets.values()) {
+        ResourceRequest request = ps.getResourceRequest(ResourceRequest.ANY);
+        if (request != null && request.getNumContainers() > 0) {
-  public ResourceRequest cloneResourceRequest(ResourceRequest request) {
-    ResourceRequest newRequest = ResourceRequest.newBuilder()
-        .priority(request.getPriority())
-        .allocationRequestId(request.getAllocationRequestId())
-        .resourceName(request.getResourceName())
-        .capability(request.getCapability())
-        .numContainers(1)
-        .relaxLocality(request.getRelaxLocality())
-        .nodeLabelExpression(request.getNodeLabelExpression()).build();
-    return newRequest;
-  }
-
-      ResourceRequest r = resourceRequestMap.get(schedulerKey).get(
-          ResourceRequest.ANY);
-      if (r == null || r.getNumContainers() <= 0) {
+      SchedulingPlacementSet ps = schedulerKeyToPlacementSets.get(schedulerKey);
+      if (null == ps) {
-      if (type == NodeType.RACK_LOCAL || type == NodeType.NODE_LOCAL) {
-        r = resourceRequestMap.get(schedulerKey).get(node.getRackName());
-        if (r == null || r.getNumContainers() <= 0) {
-          return false;
-        }
-        if (type == NodeType.NODE_LOCAL) {
-          r = resourceRequestMap.get(schedulerKey).get(node.getNodeName());
-          if (r == null || r.getNumContainers() <= 0) {
-            return false;
-          }
-        }
-      }
-
-      return true;
+      return ps.canAllocate(type, node);
-  public void updateMetricsForAllocatedContainer(
-      ResourceRequest request, NodeType type, Container containerAllocated) {
-    try {
-      writeLock.lock();
-      QueueMetrics metrics = queue.getMetrics();
-      if (pending) {
-        // once an allocation is done we assume the application is
-        // running from scheduler's POV.
-        pending = false;
-        metrics.runAppAttempt(applicationId, user);
-      }
-
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("allocate: applicationId=" + applicationId + " container="
-            + containerAllocated.getId() + " host=" + containerAllocated
-            .getNodeId().toString() + " user=" + user + " resource=" + request
-            .getCapability() + " type=" + type);
-      }
-      metrics.allocateResources(user, 1, request.getCapability(), true);
-      metrics.incrNodeTypeAggregations(user, type);
-    } finally {
-      writeLock.unlock();
+  private void updateMetricsForAllocatedContainer(
+    NodeType type, Container containerAllocated) {
+    QueueMetrics metrics = queue.getMetrics();
+    if (pending) {
+      // once an allocation is done we assume the application is
+      // running from scheduler's POV.
+      pending = false;
+      metrics.runAppAttempt(applicationId, user);
+
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("allocate: applicationId=" + applicationId + " container="
+          + containerAllocated.getId() + " host=" + containerAllocated
+          .getNodeId().toString() + " user=" + user + " resource="
+          + containerAllocated.getResource() + " type="
+          + type);
+    }
+    metrics.allocateResources(user, 1, containerAllocated.getResource(),
+        true);
+    metrics.incrNodeTypeAggregations(user, type);
-  // TODO, need update this when we support global scheduling
-    return new SchedulingPlacementSet<N>() {
-      @Override
-      @SuppressWarnings("unchecked")
-      public Iterator<N> getPreferredNodeIterator(
-          PlacementSet<N> clusterPlacementSet) {
-        return IteratorUtils.singletonIterator(
-            clusterPlacementSet.getAllNodes().values().iterator().next());
-      }
-
-      @Override
-      public ResourceRequestUpdateResult updateResourceRequests(
-          List<ResourceRequest> requests,
-          boolean recoverPreemptedRequestForAContainer) {
-        return null;
-      }
-
-      @Override
-      public Map<String, ResourceRequest> getResourceRequests() {
-        return null;
-      }
-
-      @Override
-      public ResourceRequest getResourceRequest(String resourceName,
-          SchedulerRequestKey requestKey) {
-        return null;
-      }
-
-      @Override
-      public List<ResourceRequest> allocate(NodeType type, SchedulerNode node,
-          ResourceRequest request) {
-        return null;
-      }
-
-      @Override
-      public Map<NodeId, N> getAllNodes() {
-        return null;
-      }
-
-      @Override
-      public long getVersion() {
-        return 0;
-      }
-
-      @Override
-      public String getPartition() {
-        return null;
-      }
-    };
+    return (SchedulingPlacementSet<N>) schedulerKeyToPlacementSets.get(
+        schedulerkey);

HDFS-11888. Ozone: SCM: use state machine for open containers allocated for key/blocks. Contributed by Xiaoyu Yao.

+import com.google.common.base.Preconditions;
+import org.apache.hadoop.scm.container.common.helpers.ContainerInfo;
+import org.apache.hadoop.scm.container.common.helpers.BlockContainerInfo;
-  private final MetadataStore openContainerStore;
-  private Map<String, Long> openContainers;
+  // Track all containers owned by block service.
+  private final MetadataStore containerStore;
+
+  private Map<OzoneProtos.LifeCycleState,
+      Map<String, BlockContainerInfo>> containers;
-    openContainerStore = MetadataStoreBuilder.newBuilder()
+    containerStore = MetadataStoreBuilder.newBuilder()
-    openContainers = new ConcurrentHashMap<>();
-    loadOpenContainers();
+    loadAllocatedContainers();
-   * Load open containers from persistent store.
+   * Load allocated containers from persistent store.
-  private void loadOpenContainers() throws IOException {
+  private void loadAllocatedContainers() throws IOException {
+    // Pre-allocate empty map entry by state to avoid null check
+    containers = new ConcurrentHashMap<>();
+    for (OzoneProtos.LifeCycleState state :
+        OzoneProtos.LifeCycleState.values()) {
+      containers.put(state, new ConcurrentHashMap());
+    }
-      openContainerStore.iterate(null, (key, value) -> {
+      containerStore.iterate(null, (key, value) -> {
-          openContainers.put(containerName, containerUsed);
-          LOG.debug("Loading open container: {} used : {}", containerName,
-              containerUsed);
+          ContainerInfo containerInfo =
+              containerManager.getContainer(containerName);
+          // TODO: remove the container from block manager's container DB
+          // Most likely the allocated container is timeout and cleaned up
+          // by SCM, we should clean up correspondingly instead of just skip it.
+          if (containerInfo == null) {
+            LOG.warn("Container {} allocated by block service" +
+                "can't be found in SCM", containerName);
+            return true;
+          }
+          Map<String, BlockContainerInfo> containersByState =
+              containers.get(containerInfo.getState());
+          containersByState.put(containerName,
+              new BlockContainerInfo(containerInfo, containerUsed));
+          LOG.debug("Loading allocated container: {} used : {} state: {}",
+              containerName, containerUsed, containerInfo.getState());
-          LOG.warn("Failed loading open container, continue next...");
+          LOG.warn("Failed loading allocated container, continue next...");
-   * Pre-provision specified count of containers for block creation.
-   * @param count - number of containers to create.
-   * @return list of container names created.
+   * Pre allocate specified count of containers for block creation.
+   * @param count - number of containers to allocate.
+   * @return list of container names allocated.
-  private List<String> provisionContainers(int count) throws IOException {
+  private List<String> allocateContainers(int count) throws IOException {
+        ContainerInfo containerInfo = null;
-          Pipeline pipeline = containerManager.allocateContainer(
+          containerInfo = containerManager.allocateContainer(
-          if (pipeline == null) {
+          if (containerInfo == null) {
-        openContainers.put(containerName, 0L);
-        openContainerStore.put(DFSUtil.string2Bytes(containerName),
+        Map<String, BlockContainerInfo> containersByState =
+            containers.get(OzoneProtos.LifeCycleState.ALLOCATED);
+        Preconditions.checkNotNull(containersByState);
+        containersByState.put(containerName,
+            new BlockContainerInfo(containerInfo, 0));
+        containerStore.put(DFSUtil.string2Bytes(containerName),
+   * Filter container by states and size.
+   * @param state the state of the container.
+   * @param size the minimal available size of the container
+   * @return allocated containers satisfy both state and size.
+   */
+  private List <String> filterContainers(OzoneProtos.LifeCycleState state,
+      long size) {
+    Map<String, BlockContainerInfo> containersByState =
+        this.containers.get(state);
+    return containersByState.entrySet().parallelStream()
+        .filter(e -> ((e.getValue().getAllocated() + size < containerSize)))
+        .map(e -> e.getKey())
+        .collect(Collectors.toList());
+  }
+
+  private BlockContainerInfo getContainer(OzoneProtos.LifeCycleState state,
+      String name) {
+    Map<String, BlockContainerInfo> containersByState = this.containers.get(state);
+    return containersByState.get(name);
+  }
+
+  // Relies on the caller such as allocateBlock() to hold the lock
+  // to ensure containers map consistent.
+  private void updateContainer(OzoneProtos.LifeCycleState oldState, String name,
+      OzoneProtos.LifeCycleState newState) {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Update container {} from state {} to state {}",
+          name, oldState, newState);
+    }
+    Map<String, BlockContainerInfo> containersInOldState =
+        this.containers.get(oldState);
+    BlockContainerInfo containerInfo = containersInOldState.get(name);
+    Preconditions.checkNotNull(containerInfo);
+    containersInOldState.remove(name);
+    Map<String, BlockContainerInfo> containersInNewState =
+        this.containers.get(newState);
+    containersInNewState.put(name, containerInfo);
+  }
+
+  // Refresh containers that have been allocated.
+  // We may not need to track all the states, just the creating/open/close
+  // should be enough for now.
+  private void refreshContainers() {
+    Map<String, BlockContainerInfo> containersByState =
+        this.containers.get(OzoneProtos.LifeCycleState.ALLOCATED);
+    for (String containerName: containersByState.keySet()) {
+      try {
+        ContainerInfo containerInfo =
+            containerManager.getContainer(containerName);
+        if (containerInfo == null) {
+          // TODO: clean up containers that has been deleted on SCM but
+          // TODO: still in ALLOCATED state in block manager.
+          LOG.debug("Container {} allocated by block service" +
+              "can't be found in SCM", containerName);
+          continue;
+        }
+        if (containerInfo.getState() == OzoneProtos.LifeCycleState.OPEN) {
+          updateContainer(OzoneProtos.LifeCycleState.ALLOCATED, containerName,
+              containerInfo.getState());
+        }
+        // TODO: check containers in other state and refresh as needed.
+        // TODO: ALLOCATED container that is timeout and DELETED. (unit test)
+        // TODO: OPEN container that is CLOSE.
+      } catch (IOException ex) {
+        LOG.debug("Failed to get container info for: {}", containerName);
+      }
+    }
+   }
+
+  /**
-    boolean createContainer;
-    Pipeline pipeline;
+    boolean createContainer = false;
+      refreshContainers();
-      if (openContainers.size() == 0) {
-        try {
-          candidates = provisionContainers(containerProvisionBatchSize);
-        } catch (IOException ex) {
-          throw new SCMException("Unable to allocate container for the block",
-              FAILED_TO_ALLOCATE_CONTAINER);
-        }
-          createContainer = true;
-      } else {
-        candidates = openContainers.entrySet().parallelStream()
-            .filter(e -> (e.getValue() + size < containerSize))
-            .map(e -> e.getKey())
-            .collect(Collectors.toList());
-        createContainer = false;
-      }
-
+      candidates = filterContainers(OzoneProtos.LifeCycleState.OPEN, size);
-        try {
-          candidates = provisionContainers(containerProvisionBatchSize);
-        } catch (IOException ex) {
-          throw new SCMException("Unable to allocate container for the block",
-              FAILED_TO_ALLOCATE_CONTAINER);
+        candidates = filterContainers(OzoneProtos.LifeCycleState.ALLOCATED,
+            size);
+        if (candidates.size() == 0) {
+          try {
+            candidates = allocateContainers(containerProvisionBatchSize);
+          } catch (IOException ex) {
+            LOG.error("Unable to allocate container for the block.");
+            throw new SCMException("Unable to allocate container for the block",
+                FAILED_TO_ALLOCATE_CONTAINER);
+          }
+        }
+        // now we should have some candidates in ALLOCATE state
+        if (candidates.size() == 0) {
+          throw new SCMException("Fail to find any container to allocate block " +
+              "of size " + size + ".", FAILED_TO_FIND_CONTAINER_WITH_SAPCE);
-      if (candidates.size() == 0) {
-        throw new SCMException("Fail to find any container to allocate block " +
-            "of size " + size + ".", FAILED_TO_FIND_CONTAINER_WITH_SAPCE);
-      }
-
+      // Candidates list now should include only ALLOCATE or OPEN containers
-      pipeline = containerManager.getContainer(containerName);
-      if (pipeline == null) {
+      ContainerInfo containerInfo =
+          containerManager.getContainer(containerName);
+      if (containerInfo == null) {
+      if (LOG.isDebugEnabled()) {
+        LOG.debug("Candidate {} state {}", containerName,
+            containerInfo.getState());
+      }
+      // Container must be either OPEN or ALLOCATE state
+      if (containerInfo.getState() == OzoneProtos.LifeCycleState.ALLOCATED) {
+        createContainer = true;
+      }
+
-          .setKey(blockKey).setPipeline(pipeline)
+          .setKey(blockKey).setPipeline(containerInfo.getPipeline())
-      if (pipeline.getMachines().size() > 0) {
+      if (containerInfo.getPipeline().getMachines().size() > 0) {
-        Long newUsed = openContainers.get(containerName) + size;
-        openContainers.put(containerName, newUsed);
-        openContainerStore.put(DFSUtil.string2Bytes(containerName),
-            DFSUtil.string2Bytes(Long.toString(newUsed)));
+        BlockContainerInfo containerInfoUpdate =
+            getContainer(containerInfo.getState(), containerName);
+        Preconditions.checkNotNull(containerInfoUpdate);
+        containerInfoUpdate.addAllocated(size);
+        containerStore.put(DFSUtil.string2Bytes(containerName),
+            DFSUtil.string2Bytes(Long.toString(containerInfoUpdate.getAllocated())));
+        if (createContainer) {
+          OzoneProtos.LifeCycleState newState =
+              containerManager.updateContainerState(containerName,
+              OzoneProtos.LifeCycleEvent.BEGIN_CREATE);
+          updateContainer(containerInfo.getState(), containerName, newState);
+        }
-      return containerManager.getContainer(
-          DFSUtil.bytes2String(containerBytes));
+      String containerName = DFSUtil.bytes2String(containerBytes);
+      ContainerInfo containerInfo = containerManager.getContainer(
+          containerName);
+      if (containerInfo == null) {
+          LOG.debug("Container {} allocated by block service" +
+              "can't be found in SCM", containerName);
+          throw new SCMException("Unable to find container for the block",
+              SCMException.ResultCodes.FAILED_TO_FIND_CONTAINER);
+      }
+      return containerInfo.getPipeline();
+      // TODO: track the block size info so that we can reclaim the container
+      // TODO: used space when the block is deleted.
-      containerManager.getContainer(DFSUtil.bytes2String(containerBytes));
-    if (openContainerStore != null) {
-      openContainerStore.close();
+    if (containerStore != null) {
+      containerStore.close();
-    return openContainers.size();
+    return containers.get(OzoneProtos.LifeCycleState.OPEN).size();

Merge trunk into HA branch


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1196458 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.yarn.api.records.ContainerId;
-    if (!hasAccess(QueueACL.SUBMIT_JOB, userUgi)) {
+    if (!hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {
-          " jobs to queue " + getQueuePath());
+          " applications to queue " + getQueuePath());
-        Resource userLimit = 
-          computeUserLimit(application, clusterResource, Resources.none());
-        setUserResourceLimit(application, userLimit);
+        computeAndSetUserResourceLimit(application, clusterResource);
-          userLimit = 
+          Resource userLimit = 
-                application.getUser(), assignedResource);
+                application, assignedResource);
-  private void setUserResourceLimit(SchedulerApp application, 
-      Resource resourceLimit) {
-    application.setAvailableResourceLimit(resourceLimit);
-    metrics.setAvailableResourcesToUser(application.getUser(), resourceLimit);
+  private void computeAndSetUserResourceLimit(SchedulerApp application, 
+      Resource clusterResource) {
+    Resource userLimit = 
+        computeUserLimit(application, clusterResource, Resources.none());
+    application.setAvailableResourceLimit(userLimit);
+    metrics.setAvailableResourcesToUser(application.getUser(), 
+        application.getHeadroom());
-    Container container = 
-          BuilderUtils.newContainer(this.recordFactory,
-              application.getApplicationAttemptId(),
-              application.getNewContainerId(),
-              node.getNodeID(), node.getHttpAddress(), 
-              capability, priority);
+
+    NodeId nodeId = node.getRMNode().getNodeID();
+    ContainerId containerId = BuilderUtils.newContainerId(application
+        .getApplicationAttemptId(), application.getNewContainerId());
+    ContainerToken containerToken = null;
-      ContainerToken containerToken = 
-          this.recordFactory.newRecordInstance(ContainerToken.class);
-      NodeId nodeId = container.getNodeId();
-      ContainerTokenIdentifier tokenidentifier = new ContainerTokenIdentifier(
-          container.getId(), nodeId.toString(), container.getResource());
-      containerToken.setIdentifier(
-          ByteBuffer.wrap(tokenidentifier.getBytes()));
-      containerToken.setKind(ContainerTokenIdentifier.KIND.toString());
-      containerToken.setPassword(
-          ByteBuffer.wrap(
-              containerTokenSecretManager.createPassword(tokenidentifier))
-          );
-      // RPC layer client expects ip:port as service for tokens
-      InetSocketAddress addr = NetUtils.createSocketAddr(nodeId.getHost(),
-          nodeId.getPort());
-      containerToken.setService(addr.getAddress().getHostAddress() + ":"
-          + addr.getPort());
-      container.setContainerToken(containerToken);
+      ContainerTokenIdentifier tokenIdentifier = new ContainerTokenIdentifier(
+          containerId, nodeId.toString(), capability);
+      containerToken = BuilderUtils.newContainerToken(nodeId, ByteBuffer
+          .wrap(containerTokenSecretManager
+              .createPassword(tokenIdentifier)), tokenIdentifier);
+    // Create the container
+    Container container = BuilderUtils.newContainer(containerId, nodeId,
+        node.getRMNode().getHttpAddress(), capability, priority,
+        containerToken);
+
-            application.getUser(), container.getResource());
+            application, container.getResource());
-      String userName, Resource resource) {
+      SchedulerApp application, Resource resource) {
+    String userName = application.getUser();
-    
+    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());
-      String userName, Resource resource) {
+      SchedulerApp application, Resource resource) {
+    String userName = application.getUser();
-    
+    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());
+      
+    // Update queue properties
+    
+    // Update application properties
+    for (SchedulerApp application : activeApplications) {
+      computeAndSetUserResourceLimit(application, clusterResource);
+    }
-      Resources.createResource((int)queueLimit);
+      Resources.createResource(roundUp((int)queueLimit));
-        Resources.subtractFrom(resourceLimit, usedResources));
+      Resources.subtractFrom(resourceLimit, usedResources));
-      allocateResource(clusterResource, application.getUser(), container.getResource());
+      allocateResource(clusterResource, application, container.getResource());

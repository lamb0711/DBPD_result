HDFS-4953. Enable HDFS local reads via mmap. Contributed by Colin Patrick McCabe.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1515906 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.fs.ZeroCopyCursor;
+      this.totalZeroCopyBytesRead = 0;
+      this.totalZeroCopyBytesRead = rhs.getTotalZeroCopyBytesRead();
+    
+    /**
+     * @return The total number of zero-copy bytes read.
+     */
+    public long getTotalZeroCopyBytesRead() {
+      return totalZeroCopyBytesRead;
+    }
+
+    void addZeroCopyBytes(long amt) {
+      this.totalBytesRead += amt;
+      this.totalLocalBytesRead += amt;
+      this.totalShortCircuitBytesRead += amt;
+      this.totalZeroCopyBytesRead += amt;
+    }
+
+    private long totalZeroCopyBytesRead;
+
+  synchronized void readZeroCopy(HdfsZeroCopyCursor zcursor, int toRead)
+      throws IOException {
+    assert(toRead > 0);
+    if (((blockReader == null) || (blockEnd == -1)) &&
+          (pos < getFileLength())) {
+      /*
+       * If we don't have a blockReader, or the one we have has no more bytes
+       * left to read, we call seekToBlockSource to get a new blockReader and
+       * recalculate blockEnd.  Note that we assume we're not at EOF here
+       * (we check this above).
+       */
+      if ((!seekToBlockSource(pos)) || (blockReader == null)) {
+        throw new IOException("failed to allocate new BlockReader " +
+            "at position " + pos);
+      }
+    }
+    long curPos = pos;
+    boolean canSkipChecksums = zcursor.getSkipChecksums();
+    long blockLeft = blockEnd - curPos + 1;
+    if (zcursor.getAllowShortReads()) {
+      if (blockLeft < toRead) {
+        toRead = (int)blockLeft;
+      }
+    }
+    if (canSkipChecksums && (toRead <= blockLeft)) {
+      long blockStartInFile = currentLocatedBlock.getStartOffset();
+      long blockPos = curPos - blockStartInFile;
+      if (blockReader.readZeroCopy(zcursor,
+            currentLocatedBlock, blockPos, toRead,
+            dfsClient.getMmapManager())) {
+        if (DFSClient.LOG.isDebugEnabled()) {
+          DFSClient.LOG.debug("readZeroCopy read " + toRead + " bytes from " +
+              "offset " + curPos + " via the zero-copy read path.  " +
+              "blockEnd = " + blockEnd);
+        }
+        readStatistics.addZeroCopyBytes(toRead);
+        seek(pos + toRead);
+        return;
+      }
+    }
+    /*
+     * Slow path reads.
+     *
+     * readStatistics will be updated when we call back into this
+     * stream's read methods.
+     */
+    long prevBlockEnd = blockEnd;
+    int slowReadAmount = zcursor.readViaSlowPath(toRead);
+    if (DFSClient.LOG.isDebugEnabled()) {
+      DFSClient.LOG.debug("readZeroCopy read " + slowReadAmount + " bytes " +
+          "from offset " + curPos + " via the fallback read path.  " +
+          "prevBlockEnd = " + prevBlockEnd + ", blockEnd = " + blockEnd +
+          ", canSkipChecksums = " + canSkipChecksums);
+    }
+  }
+
+  @Override
+  public ZeroCopyCursor createZeroCopyCursor() 
+      throws IOException, UnsupportedOperationException {
+    return new HdfsZeroCopyCursor(this,
+        dfsClient.getConf().skipShortCircuitChecksums);
+  }

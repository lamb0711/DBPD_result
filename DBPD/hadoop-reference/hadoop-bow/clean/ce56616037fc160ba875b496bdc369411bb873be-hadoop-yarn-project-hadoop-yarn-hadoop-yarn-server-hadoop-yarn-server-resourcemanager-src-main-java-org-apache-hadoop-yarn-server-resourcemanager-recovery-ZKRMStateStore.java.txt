YARN-1776. Fixed DelegationToken renewal to survive RM failover. Contributed by Zhijie Shen

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580154 13f79535-47bb-0310-9956-ffa450edef68

+    addStoreOrUpdateOps(
+        opList, rmDTIdentifier, renewDate, latestSequenceNumber, false);
+    doMultiWithRetries(opList);
+  }
+
+  @Override
+  protected synchronized void removeRMDelegationTokenState(
+      RMDelegationTokenIdentifier rmDTIdentifier) throws Exception {
+    ArrayList<Op> opList = new ArrayList<Op>();
+    String nodeRemovePath =
+        getNodePath(delegationTokensRootPath, DELEGATION_TOKEN_PREFIX
+            + rmDTIdentifier.getSequenceNumber());
+    if (LOG.isDebugEnabled()) {
+      LOG.debug("Removing RMDelegationToken_"
+          + rmDTIdentifier.getSequenceNumber());
+    }
+    if (zkClient.exists(nodeRemovePath, true) != null) {
+      opList.add(Op.delete(nodeRemovePath, -1));
+    } else {
+      LOG.info("Attempted to delete a non-existing znode " + nodeRemovePath);
+    }
+    doMultiWithRetries(opList);
+  }
+
+  @Override
+  protected void updateRMDelegationTokenAndSequenceNumberInternal(
+      RMDelegationTokenIdentifier rmDTIdentifier, Long renewDate,
+      int latestSequenceNumber) throws Exception {
+    ArrayList<Op> opList = new ArrayList<Op>();
+    String nodeRemovePath =
+        getNodePath(delegationTokensRootPath, DELEGATION_TOKEN_PREFIX
+            + rmDTIdentifier.getSequenceNumber());
+    if (zkClient.exists(nodeRemovePath, true) == null) {
+      // in case znode doesn't exist
+      addStoreOrUpdateOps(
+          opList, rmDTIdentifier, renewDate, latestSequenceNumber, false);
+      LOG.info("Attempted to update a non-existing znode " + nodeRemovePath);
+    } else {
+      // in case znode exists
+      addStoreOrUpdateOps(
+          opList, rmDTIdentifier, renewDate, latestSequenceNumber, true);
+    }
+    doMultiWithRetries(opList);
+  }
+
+  private void addStoreOrUpdateOps(ArrayList<Op> opList,
+      RMDelegationTokenIdentifier rmDTIdentifier, Long renewDate,
+      int latestSequenceNumber, boolean isUpdate) throws Exception {
-        LOG.debug("Storing RMDelegationToken_" +
+        LOG.debug((isUpdate ? "Storing " : "Updating ") + "RMDelegationToken_" +
-      opList.add(Op.create(nodeCreatePath, tokenOs.toByteArray(), zkAcl,
-          CreateMode.PERSISTENT));
+      if (isUpdate) {
+        opList.add(Op.setData(nodeCreatePath, tokenOs.toByteArray(), -1));
+      } else {
+        opList.add(Op.create(nodeCreatePath, tokenOs.toByteArray(), zkAcl,
+            CreateMode.PERSISTENT));
+      }
-        LOG.debug("Storing " + dtSequenceNumberPath +
+        LOG.debug((isUpdate ? "Storing " : "Updating ") + dtSequenceNumberPath +
-
-    doMultiWithRetries(opList);
-  }
-
-  @Override
-  protected synchronized void removeRMDelegationTokenState(
-      RMDelegationTokenIdentifier rmDTIdentifier) throws Exception {
-    String nodeRemovePath =
-        getNodePath(delegationTokensRootPath, DELEGATION_TOKEN_PREFIX
-            + rmDTIdentifier.getSequenceNumber());
-    if (LOG.isDebugEnabled()) {
-      LOG.debug("Removing RMDelegationToken_"
-          + rmDTIdentifier.getSequenceNumber());
-    }
-    deleteWithRetries(nodeRemovePath, -1);
-    deleteWithRetries(nodeRemovePath, -1);
+    if (zkClient.exists(nodeRemovePath, true) != null) {
+      doMultiWithRetries(Op.delete(nodeRemovePath, -1));
+    } else {
+      LOG.info("Attempted to delete a non-existing znode " + nodeRemovePath);
+    }
-  private void deleteWithRetries(final String path, final int version)
-      throws Exception {
-    try {
-      doMultiWithRetries(Op.delete(path, version));
-    } catch (KeeperException.NoNodeException nne) {
-      // We tried to delete a node that doesn't exist
-      if (LOG.isDebugEnabled()) {
-        LOG.debug("Attempted to delete a non-existing znode " + path);
-      }
-    }
-  }
-

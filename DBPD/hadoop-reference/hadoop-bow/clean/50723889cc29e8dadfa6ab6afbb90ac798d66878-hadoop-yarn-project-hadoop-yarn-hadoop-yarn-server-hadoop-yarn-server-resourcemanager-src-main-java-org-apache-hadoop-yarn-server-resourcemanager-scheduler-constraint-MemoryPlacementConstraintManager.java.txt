YARN-7778. Merging of placement constraints defined at different levels. Contributed by Weiwei Yang.

+import java.util.List;
+import java.util.ArrayList;
+import org.apache.hadoop.yarn.api.resource.PlacementConstraints;
+  public PlacementConstraint getMultilevelConstraint(ApplicationId appId,
+      Set<String> sourceTags, PlacementConstraint schedulingRequestConstraint) {
+    List<PlacementConstraint> constraints = new ArrayList<>();
+    // Add scheduling request-level constraint.
+    if (schedulingRequestConstraint != null) {
+      constraints.add(schedulingRequestConstraint);
+    }
+    // Add app-level constraint if appId is given.
+    if (appId != null && sourceTags != null
+        && !sourceTags.isEmpty()) {
+      constraints.add(getConstraint(appId, sourceTags));
+    }
+    // Add global constraint.
+    if (sourceTags != null && !sourceTags.isEmpty()) {
+      constraints.add(getGlobalConstraint(sourceTags));
+    }
+
+    // Remove all null or duplicate constraints.
+    List<PlacementConstraint.AbstractConstraint> allConstraints =
+        constraints.stream()
+            .filter(placementConstraint -> placementConstraint != null
+            && placementConstraint.getConstraintExpr() != null)
+            .map(PlacementConstraint::getConstraintExpr)
+            .distinct()
+            .collect(Collectors.toList());
+
+    // Compose an AND constraint
+    // When merge request(RC), app(AC) and global constraint(GC),
+    // we do a merge on them with CC=AND(GC, AC, RC) and returns a
+    // composite AND constraint. Subsequently we check if CC could
+    // be satisfied. This ensures that every level of constraint
+    // is satisfied.
+    PlacementConstraint.And andConstraint = PlacementConstraints.and(
+        allConstraints.toArray(new PlacementConstraint
+            .AbstractConstraint[allConstraints.size()]));
+    return andConstraint.build();
+  }
+
+  @Override

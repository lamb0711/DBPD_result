YARN-5611. Provide an API to update lifetime of an application. Contributed by Rohith Sharma K S

+import org.apache.hadoop.yarn.api.protocolrecords.UpdateApplicationTimeoutsRequest;
+import org.apache.hadoop.yarn.api.protocolrecords.UpdateApplicationTimeoutsResponse;
+import org.apache.hadoop.yarn.api.records.ApplicationTimeoutType;
-    UserGroupInformation callerUGI;
-    try {
-      callerUGI = UserGroupInformation.getCurrentUser();
-    } catch (IOException ie) {
-      LOG.info("Error getting UGI ", ie);
-      RMAuditLogger.logFailure("UNKNOWN", AuditConstants.UPDATE_APP_PRIORITY,
-          "UNKNOWN", "ClientRMService", "Error getting UGI", applicationId);
-      throw RPCUtil.getRemoteException(ie);
-    }
-    RMApp application = this.rmContext.getRMApps().get(applicationId);
-    if (application == null) {
-      RMAuditLogger.logFailure(callerUGI.getUserName(),
-          AuditConstants.UPDATE_APP_PRIORITY, "UNKNOWN", "ClientRMService",
-          "Trying to update priority of an absent application", applicationId);
-      throw new ApplicationNotFoundException(
-          "Trying to update priority of an absent application "
-          + applicationId);
-    }
-
-    if (!checkAccess(callerUGI, application.getUser(),
-        ApplicationAccessType.MODIFY_APP, application)) {
-      RMAuditLogger.logFailure(callerUGI.getShortUserName(),
-          AuditConstants.UPDATE_APP_PRIORITY,
-          "User doesn't have permissions to "
-              + ApplicationAccessType.MODIFY_APP.toString(), "ClientRMService",
-          AuditConstants.UNAUTHORIZED_USER, applicationId);
-      throw RPCUtil.getRemoteException(new AccessControlException("User "
-          + callerUGI.getShortUserName() + " cannot perform operation "
-          + ApplicationAccessType.MODIFY_APP.name() + " on " + applicationId));
-    }
+    UserGroupInformation callerUGI =
+        getCallerUgi(applicationId, AuditConstants.UPDATE_APP_PRIORITY);
+    RMApp application = verifyUserAccessForRMApp(applicationId, callerUGI,
+        AuditConstants.UPDATE_APP_PRIORITY);
+  @Override
+  public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(
+      UpdateApplicationTimeoutsRequest request)
+      throws YarnException, IOException {
+
+    ApplicationId applicationId = request.getApplicationId();
+    Map<ApplicationTimeoutType, String> applicationTimeouts =
+        request.getApplicationTimeouts();
+
+    UserGroupInformation callerUGI =
+        getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);
+    RMApp application = verifyUserAccessForRMApp(applicationId, callerUGI,
+        AuditConstants.UPDATE_APP_TIMEOUTS);
+
+    if (applicationTimeouts.isEmpty()) {
+      String message =
+          "At least one ApplicationTimeoutType should be configured"
+              + " for updating timeouts.";
+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),
+          AuditConstants.UPDATE_APP_TIMEOUTS, "UNKNOWN", "ClientRMService",
+          message, applicationId);
+      throw RPCUtil.getRemoteException(message);
+    }
+
+    UpdateApplicationTimeoutsResponse response = recordFactory
+        .newRecordInstance(UpdateApplicationTimeoutsResponse.class);
+
+    RMAppState state = application.getState();
+    if (!EnumSet
+        .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)
+        .contains(state)) {
+      if (COMPLETED_APP_STATES.contains(state)) {
+        // If Application is in any of the final states, update timeout
+        // can be skipped rather throwing exception.
+        RMAuditLogger.logSuccess(callerUGI.getShortUserName(),
+            AuditConstants.UPDATE_APP_TIMEOUTS, "ClientRMService",
+            applicationId);
+        return response;
+      }
+      String msg =
+          "Application is in " + state + " state can not update timeout.";
+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),
+          AuditConstants.UPDATE_APP_TIMEOUTS, "UNKNOWN", "ClientRMService",
+          msg);
+      throw RPCUtil.getRemoteException(msg);
+    }
+
+    try {
+      rmAppManager.updateApplicationTimeout(application, applicationTimeouts);
+    } catch (YarnException ex) {
+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),
+          AuditConstants.UPDATE_APP_TIMEOUTS, "UNKNOWN", "ClientRMService",
+          ex.getMessage());
+      throw RPCUtil.getRemoteException(ex);
+    }
+
+    RMAuditLogger.logSuccess(callerUGI.getShortUserName(),
+        AuditConstants.UPDATE_APP_TIMEOUTS, "ClientRMService", applicationId);
+    return response;
+  }
+
+  private UserGroupInformation getCallerUgi(ApplicationId applicationId,
+      String operation) throws YarnException {
+    UserGroupInformation callerUGI;
+    try {
+      callerUGI = UserGroupInformation.getCurrentUser();
+    } catch (IOException ie) {
+      LOG.info("Error getting UGI ", ie);
+      RMAuditLogger.logFailure("UNKNOWN", operation, "UNKNOWN",
+          "ClientRMService", "Error getting UGI", applicationId);
+      throw RPCUtil.getRemoteException(ie);
+    }
+    return callerUGI;
+  }
+
+  private RMApp verifyUserAccessForRMApp(ApplicationId applicationId,
+      UserGroupInformation callerUGI, String operation) throws YarnException {
+    RMApp application = this.rmContext.getRMApps().get(applicationId);
+    if (application == null) {
+      RMAuditLogger.logFailure(callerUGI.getUserName(), operation, "UNKNOWN",
+          "ClientRMService",
+          "Trying to " + operation + " of an absent application",
+          applicationId);
+      throw new ApplicationNotFoundException("Trying to " + operation
+          + " of an absent application " + applicationId);
+    }
+
+    if (!checkAccess(callerUGI, application.getUser(),
+        ApplicationAccessType.MODIFY_APP, application)) {
+      RMAuditLogger.logFailure(callerUGI.getShortUserName(), operation,
+          "User doesn't have permissions to "
+              + ApplicationAccessType.MODIFY_APP.toString(),
+          "ClientRMService", AuditConstants.UNAUTHORIZED_USER, applicationId);
+      throw RPCUtil.getRemoteException(new AccessControlException("User "
+          + callerUGI.getShortUserName() + " cannot perform operation "
+          + ApplicationAccessType.MODIFY_APP.name() + " on " + applicationId));
+    }
+    return application;
+  }
+

HDFS-9494. Parallel optimization of DFSStripedOutputStream#flushAllInternals. Contributed by Gao Rui.

+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CompletionService;
+import java.util.concurrent.ExecutorCompletionService;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
-  /** Size of each striping cell, must be a multiple of bytesPerChecksum */
+  // Size of each striping cell, must be a multiple of bytesPerChecksum.
+  private ExecutorService flushAllExecutor;
+  private CompletionService<Void> flushAllExecutorCompletionService;
+    flushAllExecutor = Executors.newFixedThreadPool(numAllBlocks);
+    flushAllExecutorCompletionService = new
+        ExecutorCompletionService<>(flushAllExecutor);
-  private void handleStreamerFailure(String err, Exception e)
+  private void handleCurrentStreamerFailure(String err, Exception e)
-    LOG.warn("Failed: " + err + ", " + this, e);
-    getCurrentStreamer().getErrorState().setInternalError();
-    getCurrentStreamer().close(true);
-    checkStreamers();
+    handleStreamerFailure(err, e, getCurrentStreamer());
+  }
+
+  private void handleStreamerFailure(String err, Exception e,
+      StripedDataStreamer streamer) throws IOException {
+    LOG.warn("Failed: " + err + ", " + this, e);
+    streamer.getErrorState().setInternalError();
+    streamer.close(true);
+    checkStreamers();
+    currentPackets[streamer.getIndex()] = null;
-        handleStreamerFailure("offset=" + offset + ", length=" + len, e);
+        handleCurrentStreamerFailure("offset=" + offset + ", length=" + len, e);
-            handleStreamerFailure("force=" + force, e);
+            handleCurrentStreamerFailure("force=" + force, e);
-        handleStreamerFailure("oldBytes=" + oldBytes + ", len=" + len, e);
+        handleCurrentStreamerFailure("oldBytes=" + oldBytes + ", len=" + len,
+            e);
+      // shutdown executor of flushAll tasks
+      flushAllExecutor.shutdownNow();
-          handleStreamerFailure("enqueueAllCurrentPackets, i=" + i, e);
+          handleCurrentStreamerFailure("enqueueAllCurrentPackets, i=" + i, e);
+    Map<Future<Void>, Integer> flushAllFuturesMap = new HashMap<>();
+    Future<Void> future = null;
-          flushInternal();
-        } catch(Exception e) {
-          handleStreamerFailure("flushInternal " + s, e);
+          final long toWaitFor = flushInternalWithoutWaitingAck();
+          future = flushAllExecutorCompletionService.submit(
+              new Callable<Void>() {
+                @Override
+                public Void call() throws Exception {
+                  s.waitForAckedSeqno(toWaitFor);
+                  return null;
+                }
+              });
+          flushAllFuturesMap.put(future, i);
+        } catch (Exception e) {
+          handleCurrentStreamerFailure("flushInternal " + s, e);
+    for (int i = 0; i < flushAllFuturesMap.size(); i++) {
+      try {
+        future = flushAllExecutorCompletionService.take();
+        future.get();
+      } catch (InterruptedException ie) {
+        throw DFSUtilClient.toInterruptedIOException(
+            "Interrupted during waiting all streamer flush, ", ie);
+      } catch (ExecutionException ee) {
+        LOG.warn(
+            "Caught ExecutionException while waiting all streamer flush, ", ee);
+        StripedDataStreamer s = streamers.get(flushAllFuturesMap.get(future));
+        handleStreamerFailure("flushInternal " + s,
+            (Exception) ee.getCause(), s);
+      }
+    }

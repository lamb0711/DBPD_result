YARN-7010. Federation: routing REST invocations transparently to multiple RMs (part 2 - getApps). (Contributed by Giovanni Matteo Fumarola via curino)

+import java.util.ArrayList;
+import java.util.HashMap;
+import org.apache.hadoop.yarn.api.records.YarnApplicationState;
+import org.apache.hadoop.yarn.server.resourcemanager.webapp.dao.AppInfo;
+import org.apache.hadoop.yarn.server.resourcemanager.webapp.dao.AppsInfo;
+import org.apache.hadoop.yarn.server.uam.UnmanagedApplicationManager;
+  private final static String PARTIAL_REPORT = "Partial Report ";
+
-}
+  /**
+   * Merges a list of AppInfo grouping by ApplicationId. Our current policy
+   * is to merge the application reports from the reacheable SubClusters.
+   * Via configuration parameter, we decide whether to return applications
+   * for which the primary AM is missing or to omit them.
+   *
+   * @param appsInfo a list of AppInfo to merge
+   * @param returnPartialResult if the merge AppsInfo should contain partial
+   *          result or not
+   * @return the merged AppsInfo
+   */
+  public static AppsInfo mergeAppsInfo(ArrayList<AppInfo> appsInfo,
+      boolean returnPartialResult) {
+    AppsInfo allApps = new AppsInfo();
+
+    Map<String, AppInfo> federationAM = new HashMap<String, AppInfo>();
+    Map<String, AppInfo> federationUAMSum = new HashMap<String, AppInfo>();
+    for (AppInfo a : appsInfo) {
+      // Check if this AppInfo is an AM
+      if (a.getAMHostHttpAddress() != null) {
+        // Insert in the list of AM
+        federationAM.put(a.getAppId(), a);
+        // Check if there are any UAM found before
+        if (federationUAMSum.containsKey(a.getAppId())) {
+          // Merge the current AM with the found UAM
+          mergeAMWithUAM(a, federationUAMSum.get(a.getAppId()));
+          // Remove the sum of the UAMs
+          federationUAMSum.remove(a.getAppId());
+        }
+        // This AppInfo is an UAM
+      } else {
+        if (federationAM.containsKey(a.getAppId())) {
+          // Merge the current UAM with its own AM
+          mergeAMWithUAM(federationAM.get(a.getAppId()), a);
+        } else if (federationUAMSum.containsKey(a.getAppId())) {
+          // Merge the current UAM with its own UAM and update the list of UAM
+          federationUAMSum.put(a.getAppId(),
+              mergeUAMWithUAM(federationUAMSum.get(a.getAppId()), a));
+        } else {
+          // Insert in the list of UAM
+          federationUAMSum.put(a.getAppId(), a);
+        }
+      }
+    }
+
+    // Check the remaining UAMs are depending or not from federation
+    for (AppInfo a : federationUAMSum.values()) {
+      if (returnPartialResult || (a.getName() != null
+          && !(a.getName().startsWith(UnmanagedApplicationManager.APP_NAME)
+              || a.getName().startsWith(PARTIAL_REPORT)))) {
+        federationAM.put(a.getAppId(), a);
+      }
+    }
+
+    allApps.addAll(new ArrayList<AppInfo>(federationAM.values()));
+    return allApps;
+  }
+
+  private static AppInfo mergeUAMWithUAM(AppInfo uam1, AppInfo uam2) {
+    AppInfo partialReport = new AppInfo();
+    partialReport.setAppId(uam1.getAppId());
+    partialReport.setName(PARTIAL_REPORT + uam1.getAppId());
+    // We pick the status of the first uam
+    partialReport.setState(uam1.getState());
+    // Merge the newly partial AM with UAM1 and then with UAM2
+    mergeAMWithUAM(partialReport, uam1);
+    mergeAMWithUAM(partialReport, uam2);
+    return partialReport;
+  }
+
+  private static void mergeAMWithUAM(AppInfo am, AppInfo uam) {
+    am.setPreemptedResourceMB(
+        am.getPreemptedResourceMB() + uam.getPreemptedResourceMB());
+    am.setPreemptedResourceVCores(
+        am.getPreemptedResourceVCores() + uam.getPreemptedResourceVCores());
+    am.setNumNonAMContainerPreempted(am.getNumNonAMContainerPreempted()
+        + uam.getNumNonAMContainerPreempted());
+    am.setNumAMContainerPreempted(
+        am.getNumAMContainerPreempted() + uam.getNumAMContainerPreempted());
+    am.setPreemptedMemorySeconds(
+        am.getPreemptedMemorySeconds() + uam.getPreemptedMemorySeconds());
+    am.setPreemptedVcoreSeconds(
+        am.getPreemptedVcoreSeconds() + uam.getPreemptedVcoreSeconds());
+
+    if (am.getState() == YarnApplicationState.RUNNING
+        && uam.getState() == am.getState()) {
+
+      am.getResourceRequests().addAll(uam.getResourceRequests());
+
+      am.setAllocatedMB(am.getAllocatedMB() + uam.getAllocatedMB());
+      am.setAllocatedVCores(am.getAllocatedVCores() + uam.getAllocatedVCores());
+      am.setReservedMB(am.getReservedMB() + uam.getReservedMB());
+      am.setReservedVCores(am.getReservedVCores() + uam.getReservedMB());
+      am.setRunningContainers(
+          am.getRunningContainers() + uam.getRunningContainers());
+      am.setMemorySeconds(am.getMemorySeconds() + uam.getMemorySeconds());
+      am.setVcoreSeconds(am.getVcoreSeconds() + uam.getVcoreSeconds());
+    }
+  }
+}

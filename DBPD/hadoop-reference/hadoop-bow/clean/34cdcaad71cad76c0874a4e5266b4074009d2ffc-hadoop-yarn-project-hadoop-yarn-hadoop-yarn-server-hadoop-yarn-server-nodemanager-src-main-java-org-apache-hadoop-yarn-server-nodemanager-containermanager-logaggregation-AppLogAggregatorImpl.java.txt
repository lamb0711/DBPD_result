YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.

+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+import org.apache.hadoop.classification.InterfaceAudience.Private;
+import org.apache.hadoop.yarn.api.records.LogAggregationContext;
+import org.apache.hadoop.yarn.logaggregation.LogAggregationUtils;
+import org.apache.hadoop.yarn.server.nodemanager.Context;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+
-  private static final String TMP_FILE_SUFFIX = ".tmp";
+  private final LogAggregationContext logAggregationContext;
+  private final Context context;
-  private LogWriter writer = null;
+  private final Map<ContainerId, ContainerLogAggregator> containerLogAggregators =
+      new HashMap<ContainerId, ContainerLogAggregator>();
-      DeletionService deletionService, Configuration conf, ApplicationId appId,
-      UserGroupInformation userUgi, LocalDirsHandlerService dirsHandler,
-      Path remoteNodeLogFileForApp,
+      DeletionService deletionService, Configuration conf,
+      ApplicationId appId, UserGroupInformation userUgi,
+      LocalDirsHandlerService dirsHandler, Path remoteNodeLogFileForApp,
-      Map<ApplicationAccessType, String> appAcls) {
+      Map<ApplicationAccessType, String> appAcls,
+      LogAggregationContext logAggregationContext,
+      Context context) {
+    this.logAggregationContext = logAggregationContext;
+    this.context = context;
-  private void uploadLogsForContainer(ContainerId containerId) {
-
+  private void uploadLogsForContainers() {
-    // Lazy creation of the writer
-    if (this.writer == null) {
-      LOG.info("Starting aggregate log-file for app " + this.applicationId
-          + " at " + this.remoteNodeTmpLogFileForApp);
-      try {
-        this.writer =
-            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,
-                this.userUgi);
-        //Write ACLs once when and if the writer is created.
-        this.writer.writeApplicationACLs(appAcls);
-        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());
-      } catch (IOException e) {
-        LOG.error("Cannot create writer for app " + this.applicationId
-            + ". Disabling log-aggregation for this app.", e);
-        this.logAggregationDisabled = true;
-        return;
+    // Create a set of Containers whose logs will be uploaded in this cycle.
+    // It includes:
+    // a) all containers in pendingContainers: those containers are finished
+    //    and satisfy the retentionPolicy.
+    // b) some set of running containers: For all the Running containers,
+    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,
+    // so simply set wasContainerSuccessful as true to
+    // bypass FAILED_CONTAINERS check and find the running containers 
+    // which satisfy the retentionPolicy.
+    Set<ContainerId> pendingContainerInThisCycle = new HashSet<ContainerId>();
+    this.pendingContainers.drainTo(pendingContainerInThisCycle);
+    Set<ContainerId> finishedContainers =
+        new HashSet<ContainerId>(pendingContainerInThisCycle);
+    if (this.context.getApplications().get(this.appId) != null) {
+      for (ContainerId container : this.context.getApplications()
+        .get(this.appId).getContainers().keySet()) {
+        if (shouldUploadLogs(container, true)) {
+          pendingContainerInThisCycle.add(container);
+        }
-    LOG.info("Uploading logs for container " + containerId
-        + ". Current good log dirs are "
-        + StringUtils.join(",", dirsHandler.getLogDirs()));
-    LogKey logKey = new LogKey(containerId);
-    LogValue logValue =
-        new LogValue(dirsHandler.getLogDirs(), containerId,
-          userUgi.getShortUserName());
+    LogWriter writer = null;
-      this.writer.append(logKey, logValue);
-    } catch (IOException e) {
-      LOG.error("Couldn't upload logs for " + containerId
-          + ". Skipping this container.");
+      try {
+        writer =
+            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,
+              this.userUgi);
+        // Write ACLs once when the writer is created.
+        writer.writeApplicationACLs(appAcls);
+        writer.writeApplicationOwner(this.userUgi.getShortUserName());
+
+      } catch (IOException e1) {
+        LOG.error("Cannot create writer for app " + this.applicationId
+            + ". Skip log upload this time. ");
+        return;
+      }
+
+      boolean uploadedLogsInThisCycle = false;
+      for (ContainerId container : pendingContainerInThisCycle) {
+        ContainerLogAggregator aggregator = null;
+        if (containerLogAggregators.containsKey(container)) {
+          aggregator = containerLogAggregators.get(container);
+        } else {
+          aggregator = new ContainerLogAggregator(container);
+          containerLogAggregators.put(container, aggregator);
+        }
+        Set<Path> uploadedFilePathsInThisCycle =
+            aggregator.doContainerLogAggregation(writer);
+        if (uploadedFilePathsInThisCycle.size() > 0) {
+          uploadedLogsInThisCycle = true;
+        }
+        this.delService.delete(this.userUgi.getShortUserName(), null,
+          uploadedFilePathsInThisCycle
+            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));
+
+        // This container is finished, and all its logs have been uploaded,
+        // remove it from containerLogAggregators.
+        if (finishedContainers.contains(container)) {
+          containerLogAggregators.remove(container);
+        }
+      }
+
+      if (writer != null) {
+        writer.close();
+      }
+
+      final Path renamedPath = logAggregationContext == null ||
+          logAggregationContext.getRollingIntervalSeconds() <= 0
+              ? remoteNodeLogFileForApp : new Path(
+                remoteNodeLogFileForApp.getParent(),
+                remoteNodeLogFileForApp.getName() + "_"
+                    + System.currentTimeMillis());
+
+      final boolean rename = uploadedLogsInThisCycle;
+      try {
+        userUgi.doAs(new PrivilegedExceptionAction<Object>() {
+          @Override
+          public Object run() throws Exception {
+            FileSystem remoteFS = FileSystem.get(conf);
+            if (remoteFS.exists(remoteNodeTmpLogFileForApp)
+                && rename) {
+              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);
+            }
+            return null;
+          }
+        });
+      } catch (Exception e) {
+        LOG.error(
+          "Failed to move temporary log file to final location: ["
+              + remoteNodeTmpLogFileForApp + "] to ["
+              + renamedPath + "]", e);
+      }
+    } finally {
+      if (writer != null) {
+        writer.close();
+      }
-    ContainerId containerId;
-
-          wait(THREAD_SLEEP_TIME);
+          if (this.logAggregationContext != null && this.logAggregationContext
+              .getRollingIntervalSeconds() > 0) {
+            wait(this.logAggregationContext.getRollingIntervalSeconds() * 1000);
+            if (this.appFinishing.get() || this.aborted.get()) {
+              break;
+            }
+            uploadLogsForContainers();
+          } else {
+            wait(THREAD_SLEEP_TIME);
+          }
-    // Application is finished. Finish pending-containers
-    while ((containerId = this.pendingContainers.poll()) != null) {
-      uploadLogsForContainer(containerId);
-    }
+    // App is finished, upload the container logs.
+    uploadLogsForContainers();
-
-    if (this.writer != null) {
-      this.writer.close();
-      LOG.info("Finished aggregate log-file for app " + this.applicationId);
-    }
-
-    try {
-      userUgi.doAs(new PrivilegedExceptionAction<Object>() {
-        @Override
-        public Object run() throws Exception {
-          FileSystem remoteFS = FileSystem.get(conf);
-          remoteFS.rename(remoteNodeTmpLogFileForApp, remoteNodeLogFileForApp);
-          return null;
-        }
-      });
-    } catch (Exception e) {
-      LOG.error("Failed to move temporary log file to final location: ["
-          + remoteNodeTmpLogFileForApp + "] to [" + remoteNodeLogFileForApp
-          + "]", e);
-    }
-        (remoteNodeLogFileForApp.getName() + TMP_FILE_SUFFIX));
+      (remoteNodeLogFileForApp.getName() + LogAggregationUtils.TMP_FILE_SUFFIX));
+  // TODO: The condition: containerId.getId() == 1 to determine an AM container
+  // is not always true.
+
+  @Private
+  @VisibleForTesting
+  public synchronized void doLogAggregationOutOfBand() {
+    LOG.info("Do OutOfBand log aggregation");
+    this.notifyAll();
+  }
+
+  private class ContainerLogAggregator {
+    private final ContainerId containerId;
+    private Set<String> uploadedFileMeta =
+        new HashSet<String>();
+    
+    public ContainerLogAggregator(ContainerId containerId) {
+      this.containerId = containerId;
+    }
+
+    public Set<Path> doContainerLogAggregation(LogWriter writer) {
+      LOG.info("Uploading logs for container " + containerId
+          + ". Current good log dirs are "
+          + StringUtils.join(",", dirsHandler.getLogDirs()));
+      final LogKey logKey = new LogKey(containerId);
+      final LogValue logValue =
+          new LogValue(dirsHandler.getLogDirs(), containerId,
+            userUgi.getShortUserName(), logAggregationContext,
+            this.uploadedFileMeta);
+      try {
+        writer.append(logKey, logValue);
+      } catch (Exception e) {
+        LOG.error("Couldn't upload logs for " + containerId
+            + ". Skipping this container.");
+        return new HashSet<Path>();
+      }
+      this.uploadedFileMeta.addAll(logValue
+        .getCurrentUpLoadedFileMeta());
+      // if any of the previous uploaded logs have been deleted,
+      // we need to remove them from alreadyUploadedLogs
+      Iterable<String> mask =
+          Iterables.filter(uploadedFileMeta, new Predicate<String>() {
+            @Override
+            public boolean apply(String next) {
+              return logValue.getAllExistingFilesMeta().contains(next);
+            }
+          });
+
+      this.uploadedFileMeta = Sets.newHashSet(mask);
+      return logValue.getCurrentUpLoadedFilesPath();
+    }
+  }

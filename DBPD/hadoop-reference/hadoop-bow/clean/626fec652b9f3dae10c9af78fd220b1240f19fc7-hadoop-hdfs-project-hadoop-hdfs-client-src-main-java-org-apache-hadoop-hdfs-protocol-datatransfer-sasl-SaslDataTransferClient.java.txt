HDFS-13699. Add DFSClient sending handshake token to DataNode, and allow DataNode overwrite downstream QOP. Contributed by Chen Liang.

+import static org.apache.hadoop.hdfs.client.HdfsClientConfigKeys.DFS_ENCRYPT_DATA_OVERWRITE_DOWNSTREAM_NEW_QOP_KEY;
+import com.google.common.annotations.VisibleForTesting;
+import java.io.ByteArrayInputStream;
+import javax.crypto.SecretKey;
+import javax.security.sasl.Sasl;
+import org.apache.hadoop.security.token.SecretManager;
+  // Store the most recent successfully negotiated QOP,
+  // for testing purpose only
+  private String targetQOP;
+
-        underlyingIn, encryptionKey, accessToken, datanodeId);
+        underlyingIn, encryptionKey, accessToken, datanodeId, null);
+    return socketSend(socket, underlyingOut, underlyingIn, encryptionKeyFactory,
+        accessToken, datanodeId, null);
+  }
+
+  public IOStreamPair socketSend(
+      Socket socket, OutputStream underlyingOut, InputStream underlyingIn,
+      DataEncryptionKeyFactory encryptionKeyFactory,
+      Token<BlockTokenIdentifier> accessToken, DatanodeID datanodeId,
+      SecretKey secretKey)
+      throws IOException {
-        underlyingIn, encryptionKeyFactory, accessToken, datanodeId);
+        underlyingIn, encryptionKeyFactory, accessToken, datanodeId,
+        secretKey);
+    return checkTrustAndSend(addr, underlyingOut, underlyingIn,
+        encryptionKeyFactory, accessToken, datanodeId, null);
+  }
+
+  private IOStreamPair checkTrustAndSend(
+      InetAddress addr, OutputStream underlyingOut, InputStream underlyingIn,
+      DataEncryptionKeyFactory encryptionKeyFactory,
+      Token<BlockTokenIdentifier> accessToken, DatanodeID datanodeId,
+      SecretKey secretKey)
+      throws IOException {
-    LOG.debug("SASL encryption trust check: localHostTrusted = {}, "
+    LOG.info("SASL encryption trust check: localHostTrusted = {}, "
-
-      DataEncryptionKey encryptionKey = encryptionKeyFactory
-          .newDataEncryptionKey();
+      DataEncryptionKey encryptionKey =
+          encryptionKeyFactory.newDataEncryptionKey();
-          datanodeId);
+          datanodeId, secretKey);
-      Token<BlockTokenIdentifier> accessToken, DatanodeID datanodeId)
+      Token<BlockTokenIdentifier> accessToken, DatanodeID datanodeId,
+      SecretKey secretKey)
-          encryptionKey);
+          encryptionKey, accessToken, secretKey);
-      return getSaslStreams(addr, underlyingOut, underlyingIn, accessToken);
+      return getSaslStreams(addr, underlyingOut, underlyingIn,
+          accessToken, secretKey);
-      OutputStream underlyingOut,
-      InputStream underlyingIn, DataEncryptionKey encryptionKey)
+      OutputStream underlyingOut, InputStream underlyingIn,
+      DataEncryptionKey encryptionKey,
+      Token<BlockTokenIdentifier> accessToken,
+      SecretKey secretKey)
+    if (secretKey != null) {
+      LOG.debug("DataNode overwriting downstream QOP" +
+          saslProps.get(Sasl.QOP));
+      byte[] newSecret =  SecretManager.createPassword(saslProps.get(Sasl.QOP)
+          .getBytes(Charsets.UTF_8), secretKey);
+      accessToken.setDNHandshakeSecret(newSecret);
+    }
-        saslProps, callbackHandler);
+        saslProps, callbackHandler, accessToken);
+  @VisibleForTesting
+  public String getTargetQOP() {
+    return targetQOP;
+  }
+
-      Token<BlockTokenIdentifier> accessToken)
+      Token<BlockTokenIdentifier> accessToken,
+      SecretKey secretKey)
+    // secretKey != null only happens when this is called by DN
+    // sending to downstream DN. If called from client, this will be null,
+    // as there is no key for client to generate mac instance.
+    // So that, if a different QOP is desired for inter-DN communication,
+    // the check below will use new QOP to create a secret, which includes
+    // the new QOP.
+    if (secretKey != null) {
+      String newQOP = conf
+          .get(DFS_ENCRYPT_DATA_OVERWRITE_DOWNSTREAM_NEW_QOP_KEY);
+      if (newQOP != null) {
+        saslProps.put(Sasl.QOP, newQOP);
+      }
+      LOG.debug("DataNode overwriting downstream QOP " +
+          saslProps.get(Sasl.QOP));
+      byte[] newSecret = SecretManager.createPassword(
+          saslProps.get(Sasl.QOP).getBytes(Charsets.UTF_8), secretKey);
+      accessToken.setDNHandshakeSecret(newSecret);
+    }
+    targetQOP = saslProps.get(Sasl.QOP);
-        saslProps, callbackHandler);
+        saslProps, callbackHandler, accessToken);
-      Map<String, String> saslProps,
-      CallbackHandler callbackHandler) throws IOException {
+      Map<String, String> saslProps, CallbackHandler callbackHandler,
+      Token<BlockTokenIdentifier> accessToken) throws IOException {
-      sendSaslMessage(out, new byte[0]);
+      // The handshake secret can be null, this happens when client is running
+      // a new version but the cluster does not have this feature. In which case
+      // there will be no encrypted secret sent from NN.
+      byte[] handshakeSecret = accessToken.getDnHandshakeSecret();
+      if (handshakeSecret == null || handshakeSecret.length == 0) {
+        LOG.debug("Handshake secret is null, sending without "
+            + "handshake secret.");
+        sendSaslMessage(out, new byte[0]);
+      } else {
+        LOG.debug("Sending handshake secret.");
+        BlockTokenIdentifier identifier = new BlockTokenIdentifier();
+        identifier.readFields(new DataInputStream(
+            new ByteArrayInputStream(accessToken.getIdentifier())));
+        String bpid = identifier.getBlockPoolId();
+        sendSaslMessageHandshakeSecret(out, new byte[0], handshakeSecret, bpid);
+      }

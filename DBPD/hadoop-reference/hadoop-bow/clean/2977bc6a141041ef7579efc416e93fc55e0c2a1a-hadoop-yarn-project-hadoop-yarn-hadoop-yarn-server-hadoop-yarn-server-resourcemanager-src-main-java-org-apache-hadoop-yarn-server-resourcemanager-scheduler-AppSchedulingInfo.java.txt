YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)

+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.SchedulingMode;
+
+import org.apache.hadoop.yarn.server.resourcemanager.scheduler.common.PendingAsk;
-import java.util.Collections;
-  @SuppressWarnings("unchecked")
-  public Map<String, ResourceRequest> getResourceRequests(
-      SchedulerRequestKey schedulerKey) {
-    SchedulingPlacementSet ps = schedulerKeyToPlacementSets.get(schedulerKey);
-    if (null != ps) {
-      return ps.getResourceRequests();
-    }
-    return Collections.emptyMap();
-  }
-
+  /**
+   * Used by REST API to fetch ResourceRequest
+   * @return All pending ResourceRequests.
+   */
-  public ResourceRequest getResourceRequest(SchedulerRequestKey schedulerKey,
+  public SchedulingPlacementSet getFirstSchedulingPlacementSet() {
+    try {
+      readLock.lock();
+      for (SchedulerRequestKey key : schedulerKeys.keySet()) {
+        SchedulingPlacementSet ps = schedulerKeyToPlacementSets.get(key);
+        if (null != ps) {
+          return ps;
+        }
+      }
+      return null;
+    } finally {
+      readLock.unlock();
+    }
+
+  }
+
+  public PendingAsk getNextPendingAsk() {
+    try {
+      readLock.lock();
+      SchedulerRequestKey firstRequestKey = schedulerKeys.firstKey();
+      return getPendingAsk(firstRequestKey, ResourceRequest.ANY);
+    } finally {
+      readLock.unlock();
+    }
+
+  }
+
+  public PendingAsk getPendingAsk(SchedulerRequestKey schedulerKey) {
+    return getPendingAsk(schedulerKey, ResourceRequest.ANY);
+  }
+
+  public PendingAsk getPendingAsk(SchedulerRequestKey schedulerKey,
-      SchedulingPlacementSet ps =
-          schedulerKeyToPlacementSets.get(schedulerKey);
-      return (ps == null) ? null : ps.getResourceRequest(resourceName);
+      SchedulingPlacementSet ps = schedulerKeyToPlacementSets.get(schedulerKey);
+      return (ps == null) ? PendingAsk.ZERO : ps.getPendingAsk(resourceName);
-  public Resource getResource(SchedulerRequestKey schedulerKey) {
-    try {
-      this.readLock.lock();
-      ResourceRequest request =
-          getResourceRequest(schedulerKey, ResourceRequest.ANY);
-      return (request == null) ? null : request.getCapability();
-    } finally {
-      this.readLock.unlock();
-    }
-  }
-
-  /**
-   * Method to return the next resource request to be serviced.
-   *
-   * In the initial implementation, we just pick any {@link ResourceRequest}
-   * corresponding to the highest priority.
-   *
-   * @return next {@link ResourceRequest} to allocate resources for.
-   */
-  @Unstable
-  public synchronized ResourceRequest getNextResourceRequest() {
-    SchedulingPlacementSet<SchedulerNode> ps = schedulerKeyToPlacementSets.get(
-        schedulerKeys.firstKey());
-    if (null != ps) {
-      for (ResourceRequest rr : ps.getResourceRequests().values()) {
-        return rr;
-      }
-    }
-
-    return null;
-  }
-
-   * application (user) or the system
+   * application (user) or the system.
-      ResourceRequest request,
-      return schedulerKeyToPlacementSets.get(schedulerKey)
-          .allocate(schedulerKey, type, node, request);
+      return schedulerKeyToPlacementSets.get(schedulerKey).allocate(
+          schedulerKey, type, node);
-  public List<ResourceRequest> allocate(NodeType type,
-      SchedulerNode node, SchedulerRequestKey schedulerKey,
-      Container containerAllocated) {
-    return allocate(type, node, schedulerKey, null, containerAllocated);
-  }
-
-        ResourceRequest request = ps.getResourceRequest(ResourceRequest.ANY);
-        if (request != null && request.getNumContainers() > 0) {
-          oldMetrics.decrPendingResources(user, request.getNumContainers(),
-              request.getCapability());
-          newMetrics.incrPendingResources(user, request.getNumContainers(),
-              request.getCapability());
+        PendingAsk ask = ps.getPendingAsk(ResourceRequest.ANY);
+        if (ask.getCount() > 0) {
+          oldMetrics.decrPendingResources(user, ask.getCount(),
+              ask.getPerAllocationResource());
+          newMetrics.incrPendingResources(user, ask.getCount(),
+              ask.getPerAllocationResource());
-          Resource delta = Resources.multiply(request.getCapability(),
-              request.getNumContainers());
+          Resource delta = Resources.multiply(ask.getPerAllocationResource(),
+              ask.getCount());
-          queue.decPendingResource(request.getNodeLabelExpression(), delta);
-          newQueue.incPendingResource(request.getNodeLabelExpression(), delta);
+          queue.decPendingResource(
+              ps.getPrimaryRequestedNodePartition(), delta);
+          newQueue.incPendingResource(
+              ps.getPrimaryRequestedNodePartition(), delta);
-        ResourceRequest request = ps.getResourceRequest(ResourceRequest.ANY);
-        if (request != null && request.getNumContainers() > 0) {
-          metrics.decrPendingResources(user, request.getNumContainers(),
-              request.getCapability());
+        PendingAsk ask = ps.getPendingAsk(ResourceRequest.ANY);
+        if (ask.getCount() > 0) {
+          metrics.decrPendingResources(user, ask.getCount(),
+              ask.getPerAllocationResource());
-              request.getNodeLabelExpression(),
-              Resources.multiply(request.getCapability(),
-                  request.getNumContainers()));
+              ps.getPrimaryRequestedNodePartition(),
+              Resources.multiply(ask.getPerAllocationResource(),
+                  ask.getCount()));
+
+  /**
+   * Can delay to next?.
+   *
+   * @param schedulerKey schedulerKey
+   * @param resourceName resourceName
+   *
+   * @return If request exists, return {relaxLocality}
+   *         Otherwise, return true.
+   */
+  public boolean canDelayTo(
+      SchedulerRequestKey schedulerKey, String resourceName) {
+    try {
+      this.readLock.lock();
+      SchedulingPlacementSet ps =
+          schedulerKeyToPlacementSets.get(schedulerKey);
+      return (ps == null) || ps.canDelayTo(resourceName);
+    } finally {
+      this.readLock.unlock();
+    }
+  }
+
+  public boolean acceptNodePartition(SchedulerRequestKey schedulerKey,
+      String nodePartition, SchedulingMode schedulingMode) {
+    try {
+      this.readLock.lock();
+      SchedulingPlacementSet ps =
+          schedulerKeyToPlacementSets.get(schedulerKey);
+      return (ps != null) && ps.acceptNodePartition(nodePartition,
+          schedulingMode);
+    } finally {
+      this.readLock.unlock();
+    }
+  }

Merge trunk into HA branch.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1215367 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.mapreduce.JobID;
+import org.apache.hadoop.tools.rumen.datatypes.*;
-  String jobID;
-  String user;
+  JobID jobID;
+  UserName user;
-  String queue = null;
+  QueueName queue = null;
-  String jobName = null;
+  JobName jobName = null;
-  private Properties jobProperties = new Properties();
+  private JobProperties jobProperties = new JobProperties();
-    this.jobProperties = conf;
+    this.jobProperties = new JobProperties(conf);
-  public Properties getJobProperties() {
+  public JobProperties getJobProperties() {
-  @SuppressWarnings("unused")
-  public String getUser() {
+  public UserName getUser() {
-    this.user = user;
+    this.user = new UserName(user);
-  public String getJobID() {
+  public JobID getJobID() {
-    this.jobID = jobID;
+    this.jobID = JobID.forName(jobID);
-  public String getQueue() {
+  public QueueName getQueue() {
-    this.queue = queue;
+    this.queue = new QueueName(queue);
-  public String getJobName() {
+  public JobName getJobName() {
-    this.jobName = jobName;
+    this.jobName = new JobName(jobName);
-  private void compareJobProperties(Properties prop1, Properties prop2,
+  private void compareJobProperties(JobProperties jprop1, JobProperties jprop2,
-    if (prop1 == null && prop2 == null) {
+    if (jprop1 == null && jprop2 == null) {
-    if (prop1 == null || prop2 == null) {
-      throw new DeepInequalityException(eltname + " miscompared [null]", 
+    if (jprop1 == null || jprop2 == null) {
+      throw new DeepInequalityException(eltname + " miscompared", 
+    Properties prop1 = jprop1.getValue();
+    Properties prop2 = jprop2.getValue();
+    
-      Object v1 = entry.getValue();
-      Object v2 = prop2.get(entry.getKey());
-      if (v1 == null || v2 == null || !v1.equals(v2)) {
-        throw new DeepInequalityException(
-          eltname + " miscompared for value of key : " 
-            + entry.getKey().toString(), 
-          new TreePath(loc, eltname));
-      }
+      String v1 = entry.getValue().toString();
+      String v2 = prop2.get(entry.getKey()).toString();
+      compare1(v1, v2, new TreePath(loc, eltname), "key:" + entry.getKey());
+  private void compare1(DataType<String> c1, DataType<String> c2, TreePath loc, 
+                        String eltname) 
+  throws DeepInequalityException {
+    if (c1 == null && c2 == null) {
+      return;
+    }
+
+    if (c1 == null || c2 == null) {
+      throw new DeepInequalityException(eltname + " miscompared", 
+                                        new TreePath(loc, eltname));
+    }
+    TreePath dtPath = new TreePath(loc, eltname);
+    
+    if (!c1.getClass().getName().equals(c2.getClass().getName())) {
+      throw new DeepInequalityException(eltname + " miscompared", 
+                                        new TreePath(dtPath, "class"));
+    }
+    
+    compare1(c1.getValue(), c2.getValue(), dtPath, "value");
+  }
+  
-    compare1(jobID, other.jobID, loc, "jobID");
+    compare1(jobID.toString(), other.jobID.toString(), loc, "jobID");

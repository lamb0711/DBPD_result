HDFS-5121.  Add RPCs for creating and manipulating cache pools.  (Contributed by Colin Patrick McCabe)

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1519841 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.hdfs.protocol.AlreadyBeingCreatedException;
+import org.apache.hadoop.hdfs.protocol.CachePoolInfo;
+import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.InvalidPoolNameError;
+import org.apache.hadoop.hdfs.protocol.AddPathCacheDirectiveException.PoolWritePermissionDeniedError;
+import org.apache.hadoop.hdfs.protocol.RemovePathCacheEntryException.RemovePermissionDeniedException;
+   * Cache pools, sorted by name.
+   */
+  private final TreeMap<String, CachePool> cachePools =
+      new TreeMap<String, CachePool>();
+
+  /**
-        PathCacheDirective directive) {
+        PathCacheDirective directive, FSPermissionChecker pc) {
+    CachePool pool = cachePools.get(directive.getPool());
+    if (pool == null) {
+      LOG.info("addDirective " + directive + ": pool not found.");
+      return new Fallible<PathCacheEntry>(
+          new InvalidPoolNameError(directive));
+    }
+    if (!pc.checkWritePermission(pool.getOwnerName(),
+        pool.getGroupName(), pool.getMode())) {
+      LOG.info("addDirective " + directive + ": write permission denied.");
+      return new Fallible<PathCacheEntry>(
+          new PoolWritePermissionDeniedError(directive));
+    }
+      LOG.info("addDirective " + directive + ": validation failed.");
+      LOG.info("addDirective " + directive + ": there is an " +
+          "existing directive " + existing);
+    LOG.info("addDirective " + directive + ": added cache directive "
+        + directive);
-      List<PathCacheDirective> directives) {
+      List<PathCacheDirective> directives, FSPermissionChecker pc) {
-      results.add(addDirective(directive));
+      results.add(addDirective(directive, pc));
-  private synchronized Fallible<Long> removeEntry(long entryId) {
+  private synchronized Fallible<Long> removeEntry(long entryId,
+        FSPermissionChecker pc) {
+      LOG.info("removeEntry " + entryId + ": invalid non-positive entry ID.");
+      LOG.info("removeEntry " + entryId + ": entry not found.");
+    CachePool pool = cachePools.get(existing.getDirective().getPool());
+    if (pool == null) {
+      LOG.info("removeEntry " + entryId + ": pool not found for directive " +
+        existing.getDirective());
+      return new Fallible<Long>(
+          new UnexpectedRemovePathCacheEntryException(entryId));
+    }
+    if (!pc.isSuperUser()) {
+      if (!pc.checkWritePermission(pool.getOwnerName(),
+          pool.getGroupName(), pool.getMode())) {
+        LOG.info("removeEntry " + entryId + ": write permission denied to " +
+            "pool " + pool + " for entry " + existing);
+        return new Fallible<Long>(
+            new RemovePermissionDeniedException(entryId));
+      }
+    }
+    
+      LOG.warn("removeEntry " + entryId + ": failed to find existing entry " +
+          existing + " in entriesByDirective");
-  public synchronized List<Fallible<Long>> removeEntries(List<Long> entryIds) {
+  public synchronized List<Fallible<Long>> removeEntries(List<Long> entryIds,
+      FSPermissionChecker pc) {
-      results.add(removeEntry(entryId));
+      results.add(removeEntry(entryId, pc));
+
+  /**
+   * Create a cache pool.
+   * 
+   * Only the superuser should be able to call this function.
+   *
+   * @param info
+   *          The info for the cache pool to create.
+   */
+  public synchronized void addCachePool(CachePoolInfo info)
+      throws IOException {
+    String poolName = info.getPoolName();
+    if (poolName.isEmpty()) {
+      throw new IOException("invalid empty cache pool name");
+    }
+    CachePool pool = cachePools.get(poolName);
+    if (pool != null) {
+      throw new IOException("cache pool " + poolName + " already exists.");
+    }
+    CachePool cachePool = new CachePool(poolName,
+      info.getOwnerName(), info.getGroupName(), info.getMode(),
+      info.getWeight());
+    cachePools.put(poolName, cachePool);
+    LOG.info("created new cache pool " + cachePool);
+  }
+
+  /**
+   * Modify a cache pool.
+   * 
+   * Only the superuser should be able to call this function.
+   *
+   * @param info
+   *          The info for the cache pool to modify.
+   */
+  public synchronized void modifyCachePool(CachePoolInfo info)
+      throws IOException {
+    String poolName = info.getPoolName();
+    if (poolName.isEmpty()) {
+      throw new IOException("invalid empty cache pool name");
+    }
+    CachePool pool = cachePools.get(poolName);
+    if (pool == null) {
+      throw new IOException("cache pool " + poolName + " does not exist.");
+    }
+    StringBuilder bld = new StringBuilder();
+    String prefix = "";
+    if (info.getOwnerName() != null) {
+      pool.setOwnerName(info.getOwnerName());
+      bld.append(prefix).
+        append("set owner to ").append(info.getOwnerName());
+      prefix = "; ";
+    }
+    if (info.getGroupName() != null) {
+      pool.setGroupName(info.getGroupName());
+      bld.append(prefix).
+        append("set group to ").append(info.getGroupName());
+      prefix = "; ";
+    }
+    if (info.getMode() != null) {
+      pool.setMode(info.getMode());
+      bld.append(prefix).
+        append(String.format("set mode to 0%3o", info.getMode()));
+      prefix = "; ";
+    }
+    if (info.getWeight() != null) {
+      pool.setWeight(info.getWeight());
+      bld.append(prefix).
+        append("set weight to ").append(info.getWeight());
+      prefix = "; ";
+    }
+    if (prefix.isEmpty()) {
+      bld.append("no changes.");
+    }
+    LOG.info("modified " + poolName + "; " + bld.toString());
+  }
+
+  /**
+   * Remove a cache pool.
+   * 
+   * Only the superuser should be able to call this function.
+   *
+   * @param poolName
+   *          The name for the cache pool to remove.
+   */
+  public synchronized void removeCachePool(String poolName)
+      throws IOException {
+    CachePool pool = cachePools.remove(poolName);
+    if (pool == null) {
+      throw new IOException("can't remove nonexistent cache pool " + poolName);
+    }
+  }
+
+  public synchronized List<CachePoolInfo>
+      listCachePools(FSPermissionChecker pc, String prevKey,
+          int maxRepliesPerRequest) {
+    final int MAX_PREALLOCATED_REPLIES = 16;
+    ArrayList<CachePoolInfo> results = 
+        new ArrayList<CachePoolInfo>(Math.min(MAX_PREALLOCATED_REPLIES,
+            maxRepliesPerRequest));
+    SortedMap<String, CachePool> tailMap = cachePools.tailMap(prevKey, false);
+    for (Entry<String, CachePool> cur : tailMap.entrySet()) {
+      results.add(cur.getValue().getInfo(pc));
+    }
+    return results;
+  }

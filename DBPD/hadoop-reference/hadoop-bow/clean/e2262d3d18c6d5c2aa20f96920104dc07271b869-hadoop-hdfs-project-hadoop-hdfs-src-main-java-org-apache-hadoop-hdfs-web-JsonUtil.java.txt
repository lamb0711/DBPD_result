HDFS-6565. Use jackson instead jetty json in hdfs-client. Contributed by Akira AJISAKA.

-import org.apache.hadoop.hdfs.protocol.BlockStoragePolicy;
-import org.mortbay.util.ajax.JSON;
+import org.codehaus.jackson.map.ObjectMapper;
+import org.codehaus.jackson.map.ObjectReader;
-  /** Convert a Token[] to a JSON array. */
-  private static Object[] toJsonArray(final Token<? extends TokenIdentifier>[] array
-      ) throws IOException {
-    if (array == null) {
-      return null;
-    } else if (array.length == 0) {
-      return EMPTY_OBJECT_ARRAY;
-    } else {
-      final Object[] a = new Object[array.length];
-      for(int i = 0; i < array.length; i++) {
-        a[i] = toJsonMap(array[i]);
-      }
-      return a;
-    }
-  }
-
-  /** Convert a token object to a JSON string. */
-  public static String toJsonString(final Token<? extends TokenIdentifier>[] tokens
-      ) throws IOException {
-    if (tokens == null) {
-      return null;
-    }
-
-    final Map<String, Object> m = new TreeMap<String, Object>();
-    m.put(Token.class.getSimpleName(), toJsonArray(tokens));
-    return toJsonString(Token.class.getSimpleName() + "s", m);
-  }
-
-  /** Convert an Object[] to a List<Token<?>>.  */
-  private static List<Token<?>> toTokenList(final Object[] objects) throws IOException {
-    if (objects == null) {
-      return null;
-    } else if (objects.length == 0) {
-      return Collections.emptyList();
-    } else {
-      final List<Token<?>> list = new ArrayList<Token<?>>(objects.length);
-      for(int i = 0; i < objects.length; i++) {
-        list.add(toToken((Map<?, ?>)objects[i]));
-      }
-      return list;
-    }
-  }
-
-  /** Convert a JSON map to a List<Token<?>>. */
-  public static List<Token<?>> toTokenList(final Map<?, ?> json) throws IOException {
-    if (json == null) {
-      return null;
-    }
-
-    final Map<?, ?> m = (Map<?, ?>)json.get(Token.class.getSimpleName() + "s");
-    return toTokenList((Object[])m.get(Token.class.getSimpleName()));
-  }
-
-    return JSON.toString(m);
+    ObjectMapper mapper = new ObjectMapper();
+    try {
+      return mapper.writeValueAsString(m);
+    } catch (IOException ignored) {
+    }
+    return null;
-    return includeType ? toJsonString(FileStatus.class, m): JSON.toString(m);
+    ObjectMapper mapper = new ObjectMapper();
+    try {
+      return includeType ?
+          toJsonString(FileStatus.class, m) : mapper.writeValueAsString(m);
+    } catch (IOException ignored) {
+    }
+    return null;
-    final long len = (Long) m.get("length");
+    final long len = ((Number) m.get("length")).longValue();
-    final long aTime = (Long) m.get("accessTime");
-    final long mTime = (Long) m.get("modificationTime");
-    final long blockSize = (Long) m.get("blockSize");
+    final long aTime = ((Number) m.get("accessTime")).longValue();
+    final long mTime = ((Number) m.get("modificationTime")).longValue();
+    final long blockSize = ((Number) m.get("blockSize")).longValue();
-    final short replication = (short) (long) (Long) m.get("replication");
-    final long fileId = m.containsKey("fileId") ? (Long) m.get("fileId")
-        : INodeId.GRANDFATHER_INODE_ID;
-    Long childrenNumLong = (Long) m.get("childrenNum");
-    final int childrenNum = (childrenNumLong == null) ? -1
-            : childrenNumLong.intValue();
+    final short replication = ((Number) m.get("replication")).shortValue();
+    final long fileId = m.containsKey("fileId") ?
+        ((Number) m.get("fileId")).longValue() : INodeId.GRANDFATHER_INODE_ID;
+    final int childrenNum = getInt(m, "childrenNum", -1);
-        (byte) (long) (Long) m.get("storagePolicy") :
-          BlockStoragePolicySuite.ID_UNSPECIFIED;
+        (byte) ((Number) m.get("storagePolicy")).longValue() :
+        BlockStoragePolicySuite.ID_UNSPECIFIED;
-    final long blockId = (Long)m.get("blockId");
-    final long numBytes = (Long)m.get("numBytes");
-    final long generationStamp = (Long)m.get("generationStamp");
+    final long blockId = ((Number) m.get("blockId")).longValue();
+    final long numBytes = ((Number) m.get("numBytes")).longValue();
+    final long generationStamp =
+        ((Number) m.get("generationStamp")).longValue();
-    return (int) (long) (Long) value;
+    return ((Number) value).intValue();
-    return (Long) value;
+    return ((Number) value).longValue();
+  static List<?> getList(Map<?, ?> m, String key) {
+    Object list = m.get(key);
+    if (list instanceof List<?>) {
+      return (List<?>) list;
+    } else {
+      return null;
+    }
+  }
+
-        (int)(long)(Long)m.get("infoPort"),
+        ((Number) m.get("infoPort")).intValue(),
-        (int)(long)(Long)m.get("ipcPort"),
+        ((Number) m.get("ipcPort")).intValue(),
-  private static DatanodeInfo[] toDatanodeInfoArray(final Object[] objects) 
+  private static DatanodeInfo[] toDatanodeInfoArray(final List<?> objects)
-    } else if (objects.length == 0) {
+    } else if (objects.isEmpty()) {
-      final DatanodeInfo[] array = new DatanodeInfo[objects.length];
-      for(int i = 0; i < array.length; i++) {
-        array[i] = toDatanodeInfo((Map<?, ?>) objects[i]);
+      final DatanodeInfo[] array = new DatanodeInfo[objects.size()];
+      int i = 0;
+      for (Object object : objects) {
+        array[i++] = toDatanodeInfo((Map<?, ?>) object);
-        (Object[])m.get("locations"));
-    final long startOffset = (Long)m.get("startOffset");
+        getList(m, "locations"));
+    final long startOffset = ((Number) m.get("startOffset")).longValue();
-        (Object[])m.get("cachedLocations"));
+        getList(m, "cachedLocations"));
-  /** Convert an Object[] to a List of LocatedBlock. */
-  private static List<LocatedBlock> toLocatedBlockList(final Object[] objects
-      ) throws IOException {
+  /** Convert an List of Object to a List of LocatedBlock. */
+  private static List<LocatedBlock> toLocatedBlockList(
+      final List<?> objects) throws IOException {
-    } else if (objects.length == 0) {
+    } else if (objects.isEmpty()) {
-      final List<LocatedBlock> list = new ArrayList<LocatedBlock>(objects.length);
-      for(int i = 0; i < objects.length; i++) {
-        list.add(toLocatedBlock((Map<?, ?>)objects[i]));
+      final List<LocatedBlock> list = new ArrayList<>(objects.size());
+      for (Object object : objects) {
+        list.add(toLocatedBlock((Map<?, ?>) object));
-    final long fileLength = (Long)m.get("fileLength");
+    final long fileLength = ((Number) m.get("fileLength")).longValue();
-        (Object[])m.get("locatedBlocks"));
+        getList(m, "locatedBlocks"));
-    final long length = (Long)m.get("length");
-    final long fileCount = (Long)m.get("fileCount");
-    final long directoryCount = (Long)m.get("directoryCount");
-    final long quota = (Long)m.get("quota");
-    final long spaceConsumed = (Long)m.get("spaceConsumed");
-    final long spaceQuota = (Long)m.get("spaceQuota");
+    final long length = ((Number) m.get("length")).longValue();
+    final long fileCount = ((Number) m.get("fileCount")).longValue();
+    final long directoryCount = ((Number) m.get("directoryCount")).longValue();
+    final long quota = ((Number) m.get("quota")).longValue();
+    final long spaceConsumed = ((Number) m.get("spaceConsumed")).longValue();
+    final long spaceQuota = ((Number) m.get("spaceQuota")).longValue();
-    final int length = (int)(long)(Long)m.get("length");
+    final int length = ((Number) m.get("length")).intValue();
-    m.put("entries", status.getEntries());
+
+    final List<String> stringEntries = new ArrayList<>();
+    for (AclEntry entry : status.getEntries()) {
+      stringEntries.add(entry.toString());
+    }
+    m.put("entries", stringEntries);
+
-    return JSON.toString(finalMap);
+
+    ObjectMapper mapper = new ObjectMapper();
+    try {
+      return mapper.writeValueAsString(finalMap);
+    } catch (IOException ignored) {
+    }
+    return null;
-    final Object[] entries = (Object[]) m.get("entries");
+    final List<?> entries = (List<?>) m.get("entries");
-    for (int i = 0; i < entries.length; i++) {
-      AclEntry aclEntry = AclEntry.parseAclEntry((String) entries[i], true);
+    for (Object entry : entries) {
+      AclEntry aclEntry = AclEntry.parseAclEntry((String) entry, true);
-    return JSON.toString(finalMap);
+    ObjectMapper mapper = new ObjectMapper();
+    return mapper.writeValueAsString(finalMap);
-    String ret = JSON.toString(names);
+    ObjectMapper mapper = new ObjectMapper();
+    String ret = mapper.writeValueAsString(names);
-    return JSON.toString(finalMap);
+    return mapper.writeValueAsString(finalMap);
-  
+
-    
-    return toXAttrMap((Object[])json.get("XAttrs"));
+    return toXAttrMap(getList(json, "XAttrs"));
-    final Object[] xattrs = (Object[]) JSON.parse(namesInJson);
+    ObjectReader reader = new ObjectMapper().reader(List.class);
+    final List<Object> xattrs = reader.readValue(namesInJson);
-    for (int i = 0; i < xattrs.length; i++) {
-        names.add((String) (xattrs[i]));
+    for (Object xattr : xattrs) {
+      names.add((String) xattr);
-  private static Map<String, byte[]> toXAttrMap(final Object[] objects) 
+  private static Map<String, byte[]> toXAttrMap(final List<?> objects)
-    } else if (objects.length == 0) {
+    } else if (objects.isEmpty()) {
-      for(int i = 0; i < objects.length; i++) {
-        Map<?, ?> m = (Map<?, ?>) objects[i];
+      for (Object object : objects) {
+        Map<?, ?> m = (Map<?, ?>) object;

HDFS-2731. Add command to bootstrap the Standby Node's name directories from the Active NameNode. Contributed by Todd Lipcon.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1299807 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
+import org.apache.hadoop.hdfs.server.namenode.ha.BootstrapStandby;
-
-    if (!conf.getBoolean(DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY, 
-                         DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_DEFAULT)) {
-      throw new IOException("The option " + DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
-                             + " is set to false for this filesystem, so it "
-                             + "cannot be formatted. You will need to set "
-                             + DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY +" parameter "
-                             + "to true in order to format this filesystem");
-    }
+    checkAllowFormat(conf);
-    for(Iterator<URI> it = dirsToFormat.iterator(); it.hasNext();) {
-      File curDir = new File(it.next().getPath());
-      // Its alright for a dir not to exist, or to exist (properly accessible)
-      // and be completely empty.
-      if (!curDir.exists() ||
-          (curDir.isDirectory() && FileUtil.listFiles(curDir).length == 0))
-        continue;
-      if (isConfirmationNeeded) {
-        if (!confirmPrompt("Re-format filesystem in " + curDir + " ?")) {
-          System.err.println("Format aborted in "+ curDir);
-          return true;
-        }
-      }
+    if (!confirmFormat(dirsToFormat, isConfirmationNeeded, true)) {
+      return true; // aborted
+  /**
+   * Check whether the given storage directories already exist.
+   * If running in interactive mode, will prompt the user for each
+   * directory to allow them to format anyway. Otherwise, returns
+   * false, unless 'force' is specified.
+   * 
+   * @param dirsToFormat the dirs to check
+   * @param force format regardless of whether dirs exist
+   * @param interactive prompt the user when a dir exists
+   * @return true if formatting should proceed
+   * @throws IOException
+   */
+  public static boolean confirmFormat(Collection<URI> dirsToFormat,
+      boolean force, boolean interactive)
+      throws IOException {
+    for(Iterator<URI> it = dirsToFormat.iterator(); it.hasNext();) {
+      File curDir = new File(it.next().getPath());
+      // Its alright for a dir not to exist, or to exist (properly accessible)
+      // and be completely empty.
+      if (!curDir.exists() ||
+          (curDir.isDirectory() && FileUtil.listFiles(curDir).length == 0))
+        continue;
+      if (force) { // Don't confirm, always format.
+        System.err.println(
+            "Storage directory exists in " + curDir + ". Formatting anyway.");
+        continue;
+      }
+      if (!interactive) { // Don't ask - always don't format
+        System.err.println(
+            "Running in non-interactive mode, and image appears to exist in " +
+            curDir + ". Not formatting.");
+        return false;
+      }
+      if (!confirmPrompt("Re-format filesystem in " + curDir + " ?")) {
+        System.err.println("Format aborted in " + curDir);
+        return false;
+      }
+    }
+    return true;
+  }
+
+  public static void checkAllowFormat(Configuration conf) throws IOException {
+    if (!conf.getBoolean(DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY, 
+        DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_DEFAULT)) {
+      throw new IOException("The option " + DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
+                + " is set to false for this filesystem, so it "
+                + "cannot be formatted. You will need to set "
+                + DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY +" parameter "
+                + "to true in order to format this filesystem");
+    }
+  }
+
-      StartupOption.IMPORT.getName() + "]");
+      StartupOption.IMPORT.getName() + "] | [" +
+      StartupOption.BOOTSTRAPSTANDBY.getName() + "]");
-      } else
+      } else if (StartupOption.BOOTSTRAPSTANDBY.getName().equalsIgnoreCase(cmd)) {
+        startOpt = StartupOption.BOOTSTRAPSTANDBY;
+        return startOpt;
+      } else {
+      }
+      case BOOTSTRAPSTANDBY:
+        String toolArgs[] = Arrays.copyOfRange(argv, 1, argv.length);
+        int rc = BootstrapStandby.run(toolArgs, conf);
+        System.exit(rc);
+        return null; // avoid warning

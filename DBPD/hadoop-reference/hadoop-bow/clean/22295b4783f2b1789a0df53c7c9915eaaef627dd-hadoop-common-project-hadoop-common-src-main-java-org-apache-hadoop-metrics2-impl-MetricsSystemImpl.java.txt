Merge branch 'trunk' into HDFS-6581

+
+  // The callback list is used by register(Callback callback), while
+  // the callback map is used by register(String name, String desc, T sink)
+  private final Map<String, Callback> namedCallbacks;
+
+    namedCallbacks = Maps.newHashMap();
+    for (Callback cb : namedCallbacks.values()) cb.preStart();
+    for (Callback cb : namedCallbacks.values()) cb.postStart();
+    for (Callback cb : namedCallbacks.values()) cb.preStop();
+    for (Callback cb : namedCallbacks.values()) cb.postStop();
-    register(new AbstractCallback() {
+    register(name, new AbstractCallback() {
+    if (namedCallbacks.containsKey(name)) {
+      namedCallbacks.remove(name);
+    }
-    register(new AbstractCallback() {
+    register(name, new AbstractCallback() {
-    callbacks.add((Callback) Proxy.newProxyInstance(
-        callback.getClass().getClassLoader(), new Class<?>[] { Callback.class },
-        new InvocationHandler() {
+    callbacks.add((Callback) getProxyForCallback(callback));
+  }
+
+  private synchronized void register(String name, final Callback callback) {
+    namedCallbacks.put(name, (Callback) getProxyForCallback(callback));
+  }
+
+  private Object getProxyForCallback(final Callback callback) {
+    return Proxy.newProxyInstance(callback.getClass().getClassLoader(),
+        new Class<?>[] { Callback.class }, new InvocationHandler() {
-              LOG.warn("Caught exception in callback "+ method.getName(), e);
+              LOG.warn("Caught exception in callback " + method.getName(), e);
-        }));
+        });
+    namedCallbacks.clear();

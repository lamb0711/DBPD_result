HDFS-12180. Ozone: Corona: Add stats and progress bar to corona. Contributed by  Nandakumar.

+  private static final String NUM_OF_THREADS = "numOfThreads";
+  private static final String NUM_OF_THREADS_DEFAULT = "10";
-  private static final int NUM_OF_THREADS_DEFAULT = 10;
-
+  private boolean completed = false;
+  private boolean exception = false;
+  private String numOfThreads;
+  private AtomicLong volumeCreationTime;
+  private AtomicLong bucketCreationTime;
+  private AtomicLong keyCreationTime;
+  private AtomicLong keyWriteTime;
+
+  private AtomicLong totalBytesWritten;
+
+    volumeCreationTime = new AtomicLong();
+    bucketCreationTime = new AtomicLong();
+    keyCreationTime = new AtomicLong();
+    keyWriteTime = new AtomicLong();
+    totalBytesWritten = new AtomicLong();
-    processor = Executors.newFixedThreadPool(NUM_OF_THREADS_DEFAULT);
+    LOG.info("Number of Threads: " + numOfThreads);
+    processor = Executors.newFixedThreadPool(Integer.parseInt(numOfThreads));
-      LOG.info("Number of Volumes: {}.", numOfBuckets);
+      LOG.info("Number of Volumes: {}.", numOfVolumes);
+      Thread progressbar = getProgressBarThread();
+      LOG.info("Starting progress bar Thread.");
+      progressbar.start();
+      completed = true;
+      progressbar.join();
+    OptionBuilder.withDescription("number of threads to be launched " +
+        "for the run");
+    Option optNumOfThreads = OptionBuilder.create(NUM_OF_THREADS);
+
+    OptionBuilder.withArgName("value");
+    OptionBuilder.hasArg();
+    options.addOption(optNumOfThreads);
+    numOfThreads = cmdLine.hasOption(NUM_OF_THREADS) ?
+        cmdLine.getOptionValue(NUM_OF_THREADS) : NUM_OF_THREADS_DEFAULT;
+
+    System.out.println("-numOfThreads <value>           "
+        + "number of threads to be launched for the run.");
+      long start = System.nanoTime();
+      volumeCreationTime.getAndAdd(System.nanoTime() - start);
+          long start = System.nanoTime();
+          bucketCreationTime.getAndAdd(System.nanoTime() - start);
+              long keyCreateStart = System.nanoTime();
+              keyCreationTime.getAndAdd(System.nanoTime() - keyCreateStart);
+              long keyWriteStart = System.nanoTime();
+              keyWriteTime.getAndAdd(System.nanoTime() - keyWriteStart);
+              totalBytesWritten.getAndAdd(value.length);
+              exception = true;
+          exception = true;
-    Runtime.getRuntime().addShutdownHook(new Thread() {
-      public void run() {
-        printStats(System.out);
+    Runtime.getRuntime().addShutdownHook(
+        new Thread(() -> printStats(System.out)));
+  }
+
+  private Thread getProgressBarThread() {
+    long maxValue = Integer.parseInt(numOfVolumes) *
+        Integer.parseInt(numOfBuckets) *
+        Integer.parseInt(numOfKeys);
+    Thread progressBarThread = new Thread(
+        new ProgressBar(System.out, maxValue));
+    progressBarThread.setName("ProgressBar");
+    return progressBarThread;
+  }
+
+  private class ProgressBar implements Runnable {
+
+    private final long refreshInterval = 1000L;
+
+    private PrintStream stream;
+    private long maxValue;
+
+    ProgressBar(PrintStream stream, long maxValue) {
+      this.stream = stream;
+      this.maxValue = maxValue;
+    }
+
+    @Override
+    public void run() {
+      try {
+        stream.println();
+        long keys;
+        while((keys = numberOfKeysAdded.get()) < maxValue) {
+          print(keys);
+          if(completed) {
+            break;
+          }
+          Thread.sleep(refreshInterval);
+        }
+        if(exception) {
+          stream.println();
+          stream.println("Incomplete termination, " +
+              "check log for exception.");
+        } else {
+          print(maxValue);
+        }
+        stream.println();
+      } catch (InterruptedException e) {
-    });
+    }
+
+    /**
+     * Given current value prints the progress bar.
+     *
+     * @param currentValue
+     */
+    private void print(long currentValue) {
+      stream.print('\r');
+      double percent = 100.0 * currentValue / maxValue;
+      StringBuilder sb = new StringBuilder();
+      sb.append(" " + String.format("%.2f", percent) + "% |");
+
+      for (int i = 0; i <= percent; i++) {
+        sb.append('â–ˆ');
+      }
+      for (int j = 0; j < 100 - percent; j++) {
+        sb.append(' ');
+      }
+      sb.append("|  ");
+      sb.append(currentValue + "/" + maxValue);
+      long timeInSec = TimeUnit.SECONDS.convert(
+          System.nanoTime() - startTime, TimeUnit.NANOSECONDS);
+      String timeToPrint = String.format("%d:%02d:%02d", timeInSec / 3600,
+          (timeInSec % 3600) / 60, timeInSec % 60);
+      sb.append(" Time: " + timeToPrint);
+      stream.print(sb);
+    }
-    long timeInSec = TimeUnit.SECONDS.convert(
-        System.nanoTime() - startTime, TimeUnit.NANOSECONDS);
-    String timeToPrint = timeInSec < 60 ? timeInSec + " seconds" :
-        TimeUnit.MINUTES.convert(timeInSec, TimeUnit.SECONDS) + " minuites";
+    int threadCount = Integer.parseInt(numOfThreads);
+
+    long endTime = System.nanoTime() - startTime;
+    String execTime = String.format("%02d:%02d:%02d",
+        TimeUnit.NANOSECONDS.toHours(endTime),
+        TimeUnit.NANOSECONDS.toMinutes(endTime) -
+            TimeUnit.HOURS.toMinutes(
+                TimeUnit.NANOSECONDS.toHours(endTime)),
+        TimeUnit.NANOSECONDS.toSeconds(endTime) -
+            TimeUnit.MINUTES.toSeconds(
+                TimeUnit.NANOSECONDS.toMinutes(endTime)));
+
+    long volumeTime = volumeCreationTime.longValue();
+    String prettyVolumeTime = String.format("%02d:%02d:%02d:%02d",
+        TimeUnit.NANOSECONDS.toHours(volumeTime),
+        TimeUnit.NANOSECONDS.toMinutes(volumeTime) -
+            TimeUnit.HOURS.toMinutes(
+                TimeUnit.NANOSECONDS.toHours(volumeTime)),
+        TimeUnit.NANOSECONDS.toSeconds(volumeTime) -
+            TimeUnit.MINUTES.toSeconds(
+                TimeUnit.NANOSECONDS.toMinutes(volumeTime)),
+        TimeUnit.NANOSECONDS.toMillis(volumeTime) -
+            TimeUnit.SECONDS.toMillis(
+                TimeUnit.NANOSECONDS.toSeconds(volumeTime)));
+
+    long bucketTime = bucketCreationTime.longValue() / threadCount;
+    String prettyBucketTime = String.format("%02d:%02d:%02d:%02d",
+        TimeUnit.NANOSECONDS.toHours(bucketTime),
+        TimeUnit.NANOSECONDS.toMinutes(bucketTime) -
+            TimeUnit.HOURS.toMinutes(
+                TimeUnit.NANOSECONDS.toHours(bucketTime)),
+        TimeUnit.NANOSECONDS.toSeconds(bucketTime) -
+            TimeUnit.MINUTES.toSeconds(
+                TimeUnit.NANOSECONDS.toMinutes(bucketTime)),
+        TimeUnit.NANOSECONDS.toMillis(bucketTime) -
+            TimeUnit.SECONDS.toMillis(
+                TimeUnit.NANOSECONDS.toSeconds(bucketTime)));
+
+    long totalKeyCreationTime = keyCreationTime.longValue() / threadCount;
+    String prettyKeyCreationTime = String.format("%02d:%02d:%02d:%02d",
+        TimeUnit.NANOSECONDS.toHours(totalKeyCreationTime),
+        TimeUnit.NANOSECONDS.toMinutes(totalKeyCreationTime) -
+            TimeUnit.HOURS.toMinutes(
+                TimeUnit.NANOSECONDS.toHours(totalKeyCreationTime)),
+        TimeUnit.NANOSECONDS.toSeconds(totalKeyCreationTime) -
+            TimeUnit.MINUTES.toSeconds(
+                TimeUnit.NANOSECONDS.toMinutes(totalKeyCreationTime)),
+        TimeUnit.NANOSECONDS.toMillis(totalKeyCreationTime) -
+            TimeUnit.SECONDS.toMillis(
+                TimeUnit.NANOSECONDS.toSeconds(totalKeyCreationTime)));
+
+    long totalKeyWriteTime = keyWriteTime.longValue() / threadCount;
+    String prettyKeyWriteTime = String.format("%02d:%02d:%02d:%02d",
+        TimeUnit.NANOSECONDS.toHours(totalKeyWriteTime),
+        TimeUnit.NANOSECONDS.toMinutes(totalKeyWriteTime) -
+            TimeUnit.HOURS.toMinutes(
+                TimeUnit.NANOSECONDS.toHours(totalKeyWriteTime)),
+        TimeUnit.NANOSECONDS.toSeconds(totalKeyWriteTime) -
+            TimeUnit.MINUTES.toSeconds(
+                TimeUnit.NANOSECONDS.toMinutes(totalKeyWriteTime)),
+        TimeUnit.NANOSECONDS.toMillis(totalKeyWriteTime) -
+            TimeUnit.SECONDS.toMillis(
+                TimeUnit.NANOSECONDS.toSeconds(totalKeyWriteTime)));
+
+    out.println();
-    out.println("Execution time: " + timeToPrint);
+    out.println("Time spent in volume creation: " + prettyVolumeTime);
+    out.println("Time spent in bucket creation: " + prettyBucketTime);
+    out.println("Time spent in key creation: " + prettyKeyCreationTime);
+    out.println("Time spent in writing keys: " + prettyKeyWriteTime);
+    out.println("Total bytes written: " + totalBytesWritten);
+    out.println("Total Execution time: " + execTime);

HDFS-8734. Erasure Coding: fix one cell need two packets. Contributed by Walter Su.

+  private final DFSPacket[] currentPackets; // current Packet of each streamer
+    currentPackets = new DFSPacket[streamers.size()];
-  private synchronized StripedDataStreamer setCurrentStreamer(int i) {
-    streamer = streamers.get(i);
+  private synchronized StripedDataStreamer setCurrentStreamer(int newIdx)
+      throws IOException {
+    // backup currentPacket for current streamer
+    int oldIdx = streamers.indexOf(streamer);
+    if (oldIdx >= 0) {
+      currentPackets[oldIdx] = currentPacket;
+    }
+
+    streamer = streamers.get(newIdx);
+    currentPacket = currentPackets[newIdx];
+
-  /**
-   * Generate packets from a given buffer. This is only used for streamers
-   * writing parity blocks.
-   *
-   * @param byteBuffer the given buffer to generate packets
-   * @param checksumBuf the checksum buffer
-   * @return packets generated
-   * @throws IOException
-   */
-  private List<DFSPacket> generatePackets(
-      ByteBuffer byteBuffer, byte[] checksumBuf) throws IOException{
-    List<DFSPacket> packets = new ArrayList<>();
-    assert byteBuffer.hasArray();
-    getDataChecksum().calculateChunkedSums(byteBuffer.array(), 0,
-        byteBuffer.remaining(), checksumBuf, 0);
-    int ckOff = 0;
-    while (byteBuffer.remaining() > 0) {
-      DFSPacket p = createPacket(packetSize, chunksPerPacket,
-          getCurrentStreamer().getBytesCurBlock(),
-          getCurrentStreamer().getAndIncCurrentSeqno(), false);
-      int maxBytesToPacket = p.getMaxChunks() * bytesPerChecksum;
-      int toWrite = byteBuffer.remaining() > maxBytesToPacket ?
-          maxBytesToPacket: byteBuffer.remaining();
-      int chunks = (toWrite - 1) / bytesPerChecksum + 1;
-      int ckLen = chunks * getChecksumSize();
-      p.writeChecksum(checksumBuf, ckOff, ckLen);
-      ckOff += ckLen;
-      p.writeData(byteBuffer, toWrite);
-      getCurrentStreamer().incBytesCurBlock(toWrite);
-      p.incNumChunks(chunks);
-      packets.add(p);
-    }
-    return packets;
-  }
-
-
-        // cell is full and current packet has not been enqueued,
-        if (cellFull && currentPacket != null) {
-          enqueueCurrentPacketFull();
-        }
-        for (DFSPacket p : generatePackets(buffer, checksumBuf)) {
-          getCurrentStreamer().waitAndQueuePacket(p);
+        DataChecksum sum = getDataChecksum();
+        sum.calculateChunkedSums(buffer.array(), 0, len, checksumBuf, 0);
+        for (int i = 0; i < len; i += sum.getBytesPerChecksum()) {
+          int chunkLen = Math.min(sum.getBytesPerChecksum(), len - i);
+          int ckOffset = i / sum.getBytesPerChecksum() * getChecksumSize();
+          super.writeChunk(buffer.array(), i, chunkLen, checksumBuf, ckOffset,
+              getChecksumSize());
-        endBlock();
-        if (currentPacket != null) {
-          enqueueCurrentPacket();
-        }
+        // if the last stripe is incomplete, generate and write parity cells
+        writeParityCellsForLastStripe();
+        enqueueAllCurrentPackets();
-      // if the last stripe is incomplete, generate and write parity cells
-      writeParityCellsForLastStripe();
-
+
+  private void enqueueAllCurrentPackets() throws IOException {
+    int idx = streamers.indexOf(getCurrentStreamer());
+    for(int i = 0; i < streamers.size(); i++) {
+      setCurrentStreamer(i);
+      if (currentPacket != null) {
+        enqueueCurrentPacket();
+      }
+    }
+    setCurrentStreamer(idx);
+  }

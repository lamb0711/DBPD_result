Merge trunk into HA branch.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1207490 13f79535-47bb-0310-9956-ffa450edef68

- * script configured via the {@link CommonConfigurationKeys#NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY}
+ * script configured via the
+ * {@link CommonConfigurationKeys#NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY} option.
+ * <p/>
+ * It contains a static class <code>RawScriptBasedMapping</code> that performs
+ * the work: reading the configuration parameters, executing any defined
+ * script, handling errors and such like. The outer
+ * class extends {@link CachedDNSToSwitchMapping} to cache the delegated
+ * queries.
+ * <p/>
+ * This DNS mapper's {@link #isSingleSwitch()} predicate returns
+ * true if and only if a script is defined.
-public final class ScriptBasedMapping extends CachedDNSToSwitchMapping 
-implements Configurable
-{
-  public ScriptBasedMapping() {
-    super(new RawScriptBasedMapping());
-  }
+public final class ScriptBasedMapping extends CachedDNSToSwitchMapping {
+   * Create an instance with the default configuration.
+   * </p>
+   * Calling {@link #setConf(Configuration)} will trigger a
+   * re-evaluation of the configuration settings and so be used to
+   * set up the mapping script.
+   *
+   */
+  public ScriptBasedMapping() {
+    super(new RawScriptBasedMapping());
+  }
+
+  /**
-  @Override
-  public Configuration getConf() {
-    return ((RawScriptBasedMapping)rawMapping).getConf();
+  /**
+   * Get the cached mapping and convert it to its real type
+   * @return the inner raw script mapping.
+   */
+  private RawScriptBasedMapping getRawMapping() {
+    return (RawScriptBasedMapping)rawMapping;
+  public Configuration getConf() {
+    return getRawMapping().getConf();
+  }
+
+  /**
+   * {@inheritDoc}
+   * <p/>
+   * This will get called in the superclass constructor, so a check is needed
+   * to ensure that the raw mapping is defined before trying to relaying a null
+   * configuration.
+   * @param conf
+   */
+  @Override
-    ((RawScriptBasedMapping)rawMapping).setConf(conf);
+    super.setConf(conf);
+    getRawMapping().setConf(conf);
-      implements DNSToSwitchMapping {
+      extends AbstractDNSToSwitchMapping {
-    private Configuration conf;
-    private static Log LOG =
+    private static final Log LOG =
-     * Set the configuration and
-     * @param conf extract the configuration parameters of interest
+     * Set the configuration and extract the configuration parameters of interest
+     * @param conf the new configuration
+    @Override
-      this.scriptName = conf.get(SCRIPT_FILENAME_KEY);
-      this.maxArgs = conf.getInt(SCRIPT_ARG_COUNT_KEY, DEFAULT_ARG_COUNT);
-      this.conf = conf;
-    }
-
-    /**
-     * Get the configuration
-     * @return the configuration
-     */
-    public Configuration getConf () {
-      return conf;
+      super.setConf(conf);
+      if (conf != null) {
+        scriptName = conf.get(SCRIPT_FILENAME_KEY);
+        maxArgs = conf.getInt(SCRIPT_ARG_COUNT_KEY, DEFAULT_ARG_COUNT);
+      } else {
+        scriptName = null;
+        maxArgs = 0;
+      }
-    List <String> m = new ArrayList<String>(names.size());
-    
-    if (names.isEmpty()) {
-      return m;
-    }
+      List<String> m = new ArrayList<String>(names.size());
-    if (scriptName == null) {
-      for (int i = 0; i < names.size(); i++) {
-        m.add(NetworkTopology.DEFAULT_RACK);
+      if (names.isEmpty()) {
+        return m;
-      return m;
-    }
-    
-    String output = runResolveCommand(names);
-    if (output != null) {
-      StringTokenizer allSwitchInfo = new StringTokenizer(output);
-      while (allSwitchInfo.hasMoreTokens()) {
-        String switchInfo = allSwitchInfo.nextToken();
-        m.add(switchInfo);
+
+      if (scriptName == null) {
+        for (String name : names) {
+          m.add(NetworkTopology.DEFAULT_RACK);
+        }
+        return m;
-      
-      if (m.size() != names.size()) {
-        // invalid number of entries returned by the script
-        LOG.error("Script " + scriptName + " returned "
-            + Integer.toString(m.size()) + " values when "
-            + Integer.toString(names.size()) + " were expected.");
+
+      String output = runResolveCommand(names);
+      if (output != null) {
+        StringTokenizer allSwitchInfo = new StringTokenizer(output);
+        while (allSwitchInfo.hasMoreTokens()) {
+          String switchInfo = allSwitchInfo.nextToken();
+          m.add(switchInfo);
+        }
+
+        if (m.size() != names.size()) {
+          // invalid number of entries returned by the script
+          LOG.error("Script " + scriptName + " returned "
+              + Integer.toString(m.size()) + " values when "
+              + Integer.toString(names.size()) + " were expected.");
+          return null;
+        }
+      } else {
+        // an error occurred. return null to signify this.
+        // (exn was already logged in runResolveCommand)
-    } else {
-      // an error occurred. return null to signify this.
-      // (exn was already logged in runResolveCommand)
-      return null;
+
+      return m;
-    
-    return m;
-  }
-            cmdList.toArray(new String[0]), dir);
+            cmdList.toArray(new String[cmdList.size()]), dir);
-          allOutput.append(s.getOutput() + " ");
+          allOutput.append(s.getOutput()).append(" ");
+
+    /**
+     * Declare that the mapper is single-switched if a script was not named
+     * in the configuration.
+     * @return true iff there is no script
+     */
+    @Override
+    public boolean isSingleSwitch() {
+      return scriptName == null;
+    }

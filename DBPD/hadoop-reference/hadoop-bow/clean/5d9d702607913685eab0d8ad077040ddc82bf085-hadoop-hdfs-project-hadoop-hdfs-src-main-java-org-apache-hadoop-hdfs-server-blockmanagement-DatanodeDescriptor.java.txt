HDFS-4987. Namenode changes to track multiple storages per datanode.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1518087 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.hadoop.hdfs.server.protocol.DatanodeStorage;
-  private volatile BlockInfo blockList = null;
-  private int numBlocks = 0;
+  private final Map<String, DatanodeStorageInfo> storageMap = 
+      new HashMap<String, DatanodeStorageInfo>();
+
-   * Add datanode to the block.
-   * Add block to the head of the list of blocks belonging to the data-node.
+   * Add data-node to the block. Add block to the head of the list of blocks
+   * belonging to the data-node.
-  public boolean addBlock(BlockInfo b) {
-    if(!b.addNode(this))
-      return false;
-    // add to the head of the data-node list
-    blockList = b.listInsert(blockList, this);
-    numBlocks++;
-    return true;
-  }
-  
-  /**
-   * Remove block from the list of blocks belonging to the data-node.
-   * Remove datanode from the block.
-   */
-  public boolean removeBlock(BlockInfo b) {
-    blockList = b.listRemove(blockList, this);
-    if ( b.removeNode(this) ) {
-      numBlocks--;
-      return true;
-    } else {
-      return false;
+  public boolean addBlock(String storageID, BlockInfo b) {
+    DatanodeStorageInfo s = getStorageInfo(storageID);
+    if (s != null) {
+      return s.addBlock(b);
+    return false;
+  }
+
+  DatanodeStorageInfo getStorageInfo(String storageID) {
+    return storageMap.get(storageID);
+  }
+  public Collection<DatanodeStorageInfo> getStorageInfos() {
+    return storageMap.values();
-   * Move block to the head of the list of blocks belonging to the data-node.
-   * @return the index of the head of the blockList
+   * Remove block from the list of blocks belonging to the data-node. Remove
+   * data-node from the block.
-  int moveBlockToHead(BlockInfo b, int curIndex, int headIndex) {
-    blockList = b.moveBlockToHead(blockList, this, curIndex, headIndex);
-    return curIndex;
+  boolean removeBlock(BlockInfo b) {
+    int index = b.findStorageInfo(this);
+    DatanodeStorageInfo s = b.getStorageInfo(index);
+    if (s != null) {
+      return s.removeBlock(b);
+    }
+    return false;
+  }
+  
+  /**
+   * Remove block from the list of blocks belonging to the data-node. Remove
+   * data-node from the block.
+   */
+  boolean removeBlock(String storageID, BlockInfo b) {
+    DatanodeStorageInfo s = getStorageInfo(storageID);
+    if (s != null) {
+      return s.removeBlock(b);
+    }
+    return false;
-    return blockList;
+    return getBlockIterator().next();
-    boolean done = removeBlock(oldBlock);
+    int index = oldBlock.findStorageInfo(this);
+    DatanodeStorageInfo s = oldBlock.getStorageInfo(index);
+    boolean done = s.removeBlock(oldBlock);
-    done = addBlock(newBlock);
+
+    done = s.addBlock(newBlock);
-    this.blockList = null;
-    return numBlocks;
+    // TODO: synchronization
+    int blocks = 0;
+    for (DatanodeStorageInfo entry : storageMap.values()) {
+      blocks += entry.numBlocks();
+    }
+    return blocks;
-  /**
-   * Iterates over the list of blocks belonging to the datanode.
-   */
-  public static class BlockIterator implements Iterator<BlockInfo> {
-    private BlockInfo current;
-    private DatanodeDescriptor node;
-      
-    BlockIterator(BlockInfo head, DatanodeDescriptor dn) {
-      this.current = head;
-      this.node = dn;
+  private static class BlockIterator implements Iterator<BlockInfo> {
+    private final int maxIndex;
+    private int index = 0;
+    private List<Iterator<BlockInfo>> iterators = new ArrayList<Iterator<BlockInfo>>();
+    
+    private BlockIterator(final Iterable<DatanodeStorageInfo> storages) {
+      for (DatanodeStorageInfo e : storages) {
+        iterators.add(e.getBlockIterator());
+      }
+      maxIndex = iterators.size() - 1;
+    }
+
+    private BlockIterator(final DatanodeStorageInfo storage) {
+      iterators.add(storage.getBlockIterator());
+      maxIndex = iterators.size() - 1;
-      return current != null;
+      update();
+      return iterators.get(index).hasNext();
-      BlockInfo res = current;
-      current = current.getNext(current.findDatanode(node));
-      return res;
+      update();
+      return iterators.get(index).next();
-
+    
-    public void remove()  {
-      throw new UnsupportedOperationException("Sorry. can't remove.");
+    public void remove() {
+      throw new UnsupportedOperationException("Remove unsupported.");
+    }
+    
+    private void update() {
+      while(index < maxIndex && !iterators.get(index).hasNext()) {
+        index++;
+      }
-  public Iterator<BlockInfo> getBlockIterator() {
-    return new BlockIterator(this.blockList, this);
+  Iterator<BlockInfo> getBlockIterator() {
+    return new BlockIterator(storageMap.values());
+  }
+  Iterator<BlockInfo> getBlockIterator(final String storageID) {
+    return new BlockIterator(storageMap.get(storageID));
+
+  DatanodeStorageInfo updateStorage(DatanodeStorage s) {
+    DatanodeStorageInfo storage = getStorageInfo(s.getStorageID());
+    if (storage == null) {
+      storage = new DatanodeStorageInfo(this, s);
+      storageMap.put(s.getStorageID(), storage);
+    } else {
+      storage.setState(s.getState());
+    }
+    return storage;
+  }

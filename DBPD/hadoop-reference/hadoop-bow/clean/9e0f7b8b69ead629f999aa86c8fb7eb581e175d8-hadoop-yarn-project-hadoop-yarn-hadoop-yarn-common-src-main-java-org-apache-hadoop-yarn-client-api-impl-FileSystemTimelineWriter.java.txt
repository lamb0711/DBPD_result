YARN-4680. TimerTasks leak in ATS V1.5 Writer. (Xuan Gong via
gtcarrera9)

+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
+import org.apache.hadoop.util.Time;
+    long timerTaskTTL = conf.getLong(
+        YarnConfiguration.TIMELINE_SERVICE_CLIENT_INTERNAL_TIMERS_TTL_SECS,
+        YarnConfiguration
+            .TIMELINE_SERVICE_CLIENT_INTERNAL_TIMERS_TTL_SECS_DEFAULT);
+
-        new LogFDsCache(flushIntervalSecs, cleanIntervalSecs, ttl);
+        new LogFDsCache(flushIntervalSecs, cleanIntervalSecs, ttl,
+            timerTaskTTL);
-      updateLastModifiedTime(System.currentTimeMillis());
+      updateLastModifiedTime(Time.monotonicNow());
-      updateLastModifiedTime(System.currentTimeMillis());
+      updateLastModifiedTime(Time.monotonicNow());
-      this.lastModifiedTime = System.currentTimeMillis();
+      this.lastModifiedTime = Time.monotonicNow();
-              (logPathToCreate.getName() + "_" + System.currentTimeMillis()));
+              (logPathToCreate.getName() + "_" + Time.monotonicNow()));
-    private Timer flushTimer;
-    private FlushTimerTask flushTimerTask;
-    private Timer cleanInActiveFDsTimer;
-    private CleanInActiveFDsTask cleanInActiveFDsTask;
+    private Timer flushTimer = null;
+    private Timer cleanInActiveFDsTimer = null;
+    private Timer monitorTaskTimer = null;
+    private volatile boolean timerTaskStarted = false;
+    private final ReentrantLock timerTaskLocker = new ReentrantLock();
+    private final long flushIntervalSecs;
+    private final long cleanIntervalSecs;
+    private final long timerTaskRetainTTL;
+    private volatile long timeStampOfLastWrite = Time.monotonicNow();
+    private final ReadLock timerTasksMonitorReadLock;
+    private final WriteLock timerTasksMonitorWriteLock;
-        long ttl) {
+        long ttl, long timerTaskRetainTTL) {
-      this.flushTimer =
-          new Timer(LogFDsCache.class.getSimpleName() + "FlushTimer",
-            true);
-      this.flushTimerTask = new FlushTimerTask();
-      this.flushTimer.schedule(flushTimerTask, flushIntervalSecs * 1000,
-          flushIntervalSecs * 1000);
-
-      this.cleanInActiveFDsTimer =
-          new Timer(LogFDsCache.class.getSimpleName() +
-            "cleanInActiveFDsTimer", true);
-      this.cleanInActiveFDsTask = new CleanInActiveFDsTask();
-      this.cleanInActiveFDsTimer.schedule(cleanInActiveFDsTask,
-          cleanIntervalSecs * 1000, cleanIntervalSecs * 1000);
+      this.flushIntervalSecs = flushIntervalSecs;
+      this.cleanIntervalSecs = cleanIntervalSecs;
+      long timerTaskRetainTTLVar = timerTaskRetainTTL * 1000;
+      if (timerTaskRetainTTLVar > this.ttl) {
+        this.timerTaskRetainTTL = timerTaskRetainTTLVar;
+      } else {
+        this.timerTaskRetainTTL = this.ttl + 2 * 60 * 1000;
+        LOG.warn("The specific " + YarnConfiguration
+            .TIMELINE_SERVICE_CLIENT_INTERNAL_TIMERS_TTL_SECS + " : "
+            + timerTaskRetainTTL + " is invalid, because it is less than or "
+            + "equal to " + YarnConfiguration
+            .TIMELINE_SERVICE_CLIENT_FD_RETAIN_SECS + " : " + ttl + ". Use "
+            + YarnConfiguration.TIMELINE_SERVICE_CLIENT_FD_RETAIN_SECS + " : "
+            + ttl + " + 120s instead.");
+      }
+      ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
+      this.timerTasksMonitorReadLock = lock.readLock();
+      this.timerTasksMonitorWriteLock = lock.writeLock();
-      long currentTimeStamp = System.currentTimeMillis();
+      long currentTimeStamp = Time.monotonicNow();
+    private class TimerMonitorTask extends TimerTask {
+      @Override
+      public void run() {
+        try {
+          timerTasksMonitorWriteLock.lock();
+          monitorTimerTasks();
+        } finally {
+          timerTasksMonitorWriteLock.unlock();
+        }
+      }
+    }
+
+    private void monitorTimerTasks() {
+      if (Time.monotonicNow() - this.timeStampOfLastWrite
+          >= this.timerTaskRetainTTL) {
+        cancelAndCloseTimerTasks();
+
+        timerTaskStarted = false;
+      } else {
+        if (this.monitorTaskTimer != null) {
+          this.monitorTaskTimer.schedule(new TimerMonitorTask(),
+              this.timerTaskRetainTTL);
+        }
+      }
+    }
+
-      flushTimer.cancel();
-      cleanInActiveFDsTimer.cancel();
+      cancelAndCloseTimerTasks();
+    }
+
+    private void cancelAndCloseTimerTasks() {
+      if (flushTimer != null) {
+        flushTimer.cancel();
+        flushTimer = null;
+      }
+
+      if (cleanInActiveFDsTimer != null) {
+        cleanInActiveFDsTimer.cancel();
+        cleanInActiveFDsTimer = null;
+      }
+
+      if (monitorTaskTimer != null) {
+        monitorTaskTimer.cancel();
+        monitorTaskTimer = null;
+      }
+      checkAndStartTimeTasks();
+      checkAndStartTimeTasks();
+      checkAndStartTimeTasks();
+
+    private void createAndStartTimerTasks() {
+      this.flushTimer =
+          new Timer(LogFDsCache.class.getSimpleName() + "FlushTimer",
+              true);
+      this.flushTimer.schedule(new FlushTimerTask(), flushIntervalSecs * 1000,
+          flushIntervalSecs * 1000);
+
+      this.cleanInActiveFDsTimer =
+          new Timer(LogFDsCache.class.getSimpleName()
+              + "cleanInActiveFDsTimer", true);
+      this.cleanInActiveFDsTimer.schedule(new CleanInActiveFDsTask(),
+          cleanIntervalSecs * 1000, cleanIntervalSecs * 1000);
+
+      this.monitorTaskTimer =
+          new Timer(LogFDsCache.class.getSimpleName() + "MonitorTimer",
+              true);
+      this.monitorTaskTimer.schedule(new TimerMonitorTask(),
+          this.timerTaskRetainTTL);
+    }
+
+    private void checkAndStartTimeTasks() {
+      try {
+        this.timerTasksMonitorReadLock.lock();
+        this.timeStampOfLastWrite = Time.monotonicNow();
+        if(!timerTaskStarted) {
+          try {
+            timerTaskLocker.lock();
+            if (!timerTaskStarted) {
+              createAndStartTimerTasks();
+              timerTaskStarted = true;
+            }
+          } finally {
+            timerTaskLocker.unlock();
+          }
+        }
+      } finally {
+        this.timerTasksMonitorReadLock.unlock();
+      }
+    }

HDDS-1317. KeyOutputStream#write throws ArrayIndexOutOfBoundsException when running RandomWrite MR examples. Contributed by Shashikant Banerjee.

+  /**
+   * Defines stream action while calling handleFlushOrClose.
+   */
+  enum StreamAction {
+    FLUSH, CLOSE, FULL
+  }
+
-        handleFlushOrClose(true);
-        currentStreamIndex += 1;
+        handleFlushOrClose(StreamAction.FULL);
-      closedContainerException = checkIfContainerIsClosed(exception);
+      closedContainerException = checkIfContainerIsClosed(t);
-        streamEntry.getTotalSuccessfulFlushedData();
+        streamEntry.getTotalAckDataLength();
-    LOG.warn("Encountered exception {}", exception);
-    LOG.info(
-        "The last committed block length is {}, uncommitted data length is {}",
+    LOG.warn("Encountered exception {}. The last committed block length is {}, "
+            + "uncommitted data length is {}", exception,
+    Preconditions.checkArgument(
+        streamEntry.getWrittenDataLength() - totalSuccessfulFlushedData
+            == bufferedDataLen);
-  private Throwable checkForException(IOException ioe) throws IOException {
+  public Throwable checkForException(IOException ioe) throws IOException {
-    return streamEntries.parallelStream().mapToLong(e -> e.getCurrentPosition())
+    return streamEntries.stream().mapToLong(e -> e.getCurrentPosition())
-    handleFlushOrClose(false);
+    handleFlushOrClose(StreamAction.FLUSH);
-   * Close or Flush the latest outputStream.
-   * @param close Flag which decides whether to call close or flush on the
+   * Close or Flush the latest outputStream depending upon the action.
+   * This function gets called when while write is going on, the current stream
+   * gets full or explicit flush or close request is made by client. when the
+   * stream gets full and we try to close the stream , we might end up hitting
+   * an exception in the exception handling path, we write the data residing in
+   * in the buffer pool to a new Block. In cases, as such, when the data gets
+   * written to new stream , it will be at max half full. In such cases, we
+   * should just write the data and not close the stream as the block won't be
+   * completely full.
+   * @param op Flag which decides whether to call close or flush on the
-  private void handleFlushOrClose(boolean close) throws IOException {
+  private void handleFlushOrClose(StreamAction op) throws IOException {
-          if (close) {
+          switch (op) {
+          case CLOSE:
-          } else {
+            break;
+          case FULL:
+            if (entry.getRemaining() == 0) {
+              entry.close();
+              currentStreamIndex++;
+            }
+            break;
+          case FLUSH:
+            break;
+          default:
+            throw new IOException("Invalid Operation");
-      handleFlushOrClose(true);
+      handleFlushOrClose(StreamAction.CLOSE);

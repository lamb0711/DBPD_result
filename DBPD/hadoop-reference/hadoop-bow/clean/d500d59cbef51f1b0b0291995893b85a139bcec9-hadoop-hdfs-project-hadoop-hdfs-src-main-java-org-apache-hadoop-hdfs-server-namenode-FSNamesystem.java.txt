Merging trunk to HDFS-2802 branch.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1416603 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.ha.HAServiceProtocol.HAServiceState;
-import org.apache.hadoop.hdfs.server.namenode.ha.ActiveState;
+import org.apache.hadoop.hdfs.server.namenode.snapshot.INodeDirectorySnapshottable;
+import org.apache.hadoop.hdfs.server.namenode.snapshot.Snapshot;
-        + " blocks = " + (totalInodes + totalBlocks) + " total");
+        + " blocks = " + (totalInodes + totalBlocks)
+        + " total filesystem objects");
-      final INode myFile = dir.getINode(src);
+      
+      final INodesInPath inodesInPath = dir.getINodesInPath(src);
+      final INode myFile = inodesInPath.getINode(0);
-        return prepareFileForWrite(
-            src, f, holder, clientMachine, clientNode, true);
+        return prepareFileForWrite(src, f, holder, clientMachine, clientNode,
+            true, inodesInPath.getLatestSnapshot());
-      boolean writeToEditLog) throws IOException {
+      boolean writeToEditLog, Snapshot latestSnapshot) throws IOException {
-    dir.replaceNode(src, file, cons);
+    dir.replaceNode(src, file, cons, latestSnapshot);
-      INodeFileUnderConstruction pendingFile = checkLease(src, clientName);
+      final INodeFileUnderConstruction pendingFile = checkLease(
+          src, clientName, dir.getINode(src));
-      final INodeFileUnderConstruction file = checkLease(src, clientName);
+      final INodeFileUnderConstruction file = checkLease(
+          src, clientName, dir.getINode(src));
-      INodeFileUnderConstruction file = checkLease(src, holder);
+      final INodesInPath inodesInPath = checkLease(src, holder);
+      final INodeFileUnderConstruction file
+          = (INodeFileUnderConstruction)inodesInPath.getINode(0); 
-  // make sure that we still have the lease on this file.
-  private INodeFileUnderConstruction checkLease(String src, String holder) 
+  /** make sure that we still have the lease on this file. */
+  private INodesInPath checkLease(String src, String holder) 
-    return checkLease(src, holder, dir.getINode(src));
+    final INodesInPath inodesInPath = dir.getINodesInPath(src);
+    checkLease(src, holder, inodesInPath.getINode(0));
+    return inodesInPath;
-    INodeFileUnderConstruction pendingFile;
+    final INodesInPath inodesInPath;
+    final INodeFileUnderConstruction pendingFile;
-      pendingFile = checkLease(src, holder);
+      inodesInPath = checkLease(src, holder);
+      pendingFile = (INodeFileUnderConstruction)inodesInPath.getINode(0); 
-    finalizeINodeFileUnderConstruction(src, pendingFile);
+    finalizeINodeFileUnderConstruction(src, pendingFile,
+        inodesInPath.getLatestSnapshot());
+      //NOTE: yes, this is bad!  it's assuming much lower level behavior
+      //      of rewriting the dst
-    HdfsFileStatus dinfo = dir.getFileInfo(dst, false);
-      unprotectedChangeLease(src, dst, dinfo);     // update lease with new filename
-    HdfsFileStatus dinfo = dir.getFileInfo(dst, false);
-    unprotectedChangeLease(src, dst, dinfo); // update lease with new filename
-      INodeFileUnderConstruction pendingFile  = checkLease(src, clientName);
+      final INodeFileUnderConstruction pendingFile  = checkLease(
+          src, clientName, dir.getINode(src));
+    final INodesInPath inodesInPath = dir.getINodesInPath(src);
-        = INodeFileUnderConstruction.valueOf(dir.getINode(src), src);
+        = INodeFileUnderConstruction.valueOf(inodesInPath.getINode(0), src);
-      finalizeINodeFileUnderConstruction(src, pendingFile);
+      finalizeINodeFileUnderConstruction(src, pendingFile,
+          inodesInPath.getLatestSnapshot());
-        finalizeINodeFileUnderConstruction(src, pendingFile);
+        finalizeINodeFileUnderConstruction(src, pendingFile,
+            inodesInPath.getLatestSnapshot());
-      INodeFileUnderConstruction pendingFile) 
+      INodeFileUnderConstruction pendingFile, Snapshot latestSnapshot) 
-    dir.replaceNode(src, pendingFile, newFile);
+    dir.replaceNode(src, pendingFile, newFile, latestSnapshot);
-        finalizeINodeFileUnderConstruction(src, pendingFile);
+        finalizeINodeFileUnderConstruction(src, pendingFile,
+            INodeDirectorySnapshottable.findLatestSnapshot(pendingFile));
-    if (state instanceof ActiveState) {
+    if (state.getServiceState() == HAServiceState.ACTIVE) {
-    } else if (state instanceof StandbyState) {
+    } else if (state.getServiceState() == HAServiceState.STANDBY) {
-  void unprotectedChangeLease(String src, String dst, HdfsFileStatus dinfo) {
-    String overwrite;
-    String replaceBy;
+  void unprotectedChangeLease(String src, String dst) {
-
-    boolean destinationExisted = true;
-    if (dinfo == null) {
-      destinationExisted = false;
-    }
-
-    if (destinationExisted && dinfo.isDir()) {
-      Path spath = new Path(src);
-      Path parent = spath.getParent();
-      if (parent.isRoot()) {
-        overwrite = parent.toString();
-      } else {
-        overwrite = parent.toString() + Path.SEPARATOR;
-      }
-      replaceBy = dst + Path.SEPARATOR;
-    } else {
-      overwrite = src;
-      replaceBy = dst;
-    }
-
-    leaseManager.changeLease(src, dst, overwrite, replaceBy);
+    leaseManager.changeLease(src, dst);
-      out.writeInt(leaseManager.countPath()); // write the size
-
-      for (Lease lease : leaseManager.getSortedLeases()) {
-        for(String path : lease.getPaths()) {
-          // verify that path exists in namespace
-          final INodeFileUnderConstruction cons;
-          try {
-            cons = INodeFileUnderConstruction.valueOf(dir.getINode(path), path);
-          } catch (UnresolvedLinkException e) {
-            throw new AssertionError("Lease files should reside on this FS");
-          }
-          FSImageSerialization.writeINodeUnderConstruction(out, cons, path);
-        }
+      Map<String, INodeFileUnderConstruction> nodes =
+          leaseManager.getINodesUnderConstruction();
+      out.writeInt(nodes.size()); // write the size    
+      for (Map.Entry<String, INodeFileUnderConstruction> entry
+           : nodes.entrySet()) {
+        FSImageSerialization.writeINodeUnderConstruction(
+            out, entry.getValue(), entry.getKey());

HDDS-1220. KeyManager#openKey should release the bucket lock before doing an allocateBlock. Contributed by Lokesh Jain.

-    AllocatedBlock allocatedBlock;
-    try {
-      allocatedBlock =
-          scmBlockClient.allocateBlock(scmBlockSize, keyInfo.getType(),
-              keyInfo.getFactor(), omId, excludeList);
-    } catch (SCMException ex) {
-      if (ex.getResult()
-          .equals(SCMException.ResultCodes.CHILL_MODE_EXCEPTION)) {
-        throw new OMException(ex.getMessage(), ResultCodes.SCM_IN_CHILL_MODE);
-      }
-      throw ex;
-    }
-    OmKeyLocationInfo.Builder builder = new OmKeyLocationInfo.Builder()
-        .setBlockID(new BlockID(allocatedBlock.getBlockID()))
-        .setLength(scmBlockSize)
-        .setOffset(0);
-    if (grpcBlockTokenEnabled) {
-      String remoteUser = getRemoteUser().getShortUserName();
-      builder.setToken(secretManager.generateToken(remoteUser,
-          allocatedBlock.getBlockID().toString(),
-          getAclForUser(remoteUser),
-          scmBlockSize));
-    }
-    OmKeyLocationInfo info = builder.build();
-    keyInfo.appendNewBlocks(Collections.singletonList(info));
+    List<OmKeyLocationInfo> locationInfos =
+        allocateBlock(keyInfo, excludeList, scmBlockSize);
+    keyInfo.appendNewBlocks(locationInfos);
-    return info;
+    return locationInfos.get(0);
+  }
+
+  private List<OmKeyLocationInfo> allocateBlock(OmKeyInfo keyInfo,
+      ExcludeList excludeList, long requestedSize) throws IOException {
+    int numBlocks = (int) ((requestedSize - 1) / scmBlockSize + 1);
+    List<OmKeyLocationInfo> locationInfos = new ArrayList<>(numBlocks);
+    while (requestedSize > 0) {
+      long allocateSize = Math.min(requestedSize, scmBlockSize);
+      AllocatedBlock allocatedBlock;
+      try {
+        allocatedBlock = scmBlockClient
+            .allocateBlock(allocateSize, keyInfo.getType(), keyInfo.getFactor(),
+                omId, excludeList);
+      } catch (SCMException ex) {
+        if (ex.getResult()
+            .equals(SCMException.ResultCodes.CHILL_MODE_EXCEPTION)) {
+          throw new OMException(ex.getMessage(), ResultCodes.SCM_IN_CHILL_MODE);
+        }
+        throw ex;
+      }
+      OmKeyLocationInfo.Builder builder = new OmKeyLocationInfo.Builder()
+          .setBlockID(new BlockID(allocatedBlock.getBlockID()))
+          .setLength(scmBlockSize)
+          .setOffset(0);
+      if (grpcBlockTokenEnabled) {
+        String remoteUser = getRemoteUser().getShortUserName();
+        builder.setToken(secretManager
+            .generateToken(remoteUser, allocatedBlock.getBlockID().toString(),
+                getAclForUser(remoteUser), scmBlockSize));
+      }
+      locationInfos.add(builder.build());
+      requestedSize -= allocateSize;
+    }
+    return locationInfos;
+    long requestedSize = Math.min(preallocateMax, args.getDataSize());
+    OmKeyInfo keyInfo;
+    String openKey;
+    long openVersion;
-      long requestedSize = Math.min(preallocateMax, args.getDataSize());
-      // requested size is not required but more like a optimization:
-      // SCM looks at the requested, if it 0, no block will be allocated at
-      // the point, if client needs more blocks, client can always call
-      // allocateBlock. But if requested size is not 0, OM will preallocate
-      // some blocks and piggyback to client, to save RPC calls.
-      while (requestedSize > 0) {
-        long allocateSize = Math.min(scmBlockSize, requestedSize);
-        AllocatedBlock allocatedBlock;
-        try {
-          allocatedBlock = scmBlockClient
-              .allocateBlock(allocateSize, type, factor, omId,
-                  new ExcludeList());
-        } catch (IOException ex) {
-          if (ex instanceof SCMException) {
-            if (((SCMException) ex).getResult()
-                .equals(SCMException.ResultCodes.CHILL_MODE_EXCEPTION)) {
-              throw new OMException(ex.getMessage(),
-                  ResultCodes.SCM_IN_CHILL_MODE);
-            }
-          }
-          throw ex;
-        }
-        OmKeyLocationInfo.Builder builder = new OmKeyLocationInfo.Builder()
-            .setBlockID(new BlockID(allocatedBlock.getBlockID()))
-            .setLength(allocateSize)
-            .setOffset(0);
-        if (grpcBlockTokenEnabled) {
-          String remoteUser = getRemoteUser().getShortUserName();
-          builder.setToken(secretManager.generateToken(remoteUser,
-              allocatedBlock.getBlockID().toString(),
-              getAclForUser(remoteUser),
-              scmBlockSize));
-        }
-
-        OmKeyLocationInfo subKeyInfo = builder.build();
-        locations.add(subKeyInfo);
-        requestedSize -= allocateSize;
-      }
-      OmKeyInfo keyInfo;
-      long openVersion;
-      String openKey = metadataManager.getOpenKey(
+      openKey = metadataManager.getOpenKey(
-      metadataManager.getOpenKeyTable().put(openKey, keyInfo);
-      return new OpenKeySession(currentTime, keyInfo, openVersion);
+
+    // requested size is not required but more like a optimization:
+    // SCM looks at the requested, if it 0, no block will be allocated at
+    // the point, if client needs more blocks, client can always call
+    // allocateBlock. But if requested size is not 0, OM will preallocate
+    // some blocks and piggyback to client, to save RPC calls.
+    if (requestedSize > 0) {
+      List<OmKeyLocationInfo> locationInfos =
+          allocateBlock(keyInfo, new ExcludeList(), requestedSize);
+      keyInfo.appendNewBlocks(locationInfos);
+    }
+    metadataManager.getOpenKeyTable().put(openKey, keyInfo);
+    return new OpenKeySession(currentTime, keyInfo, openVersion);

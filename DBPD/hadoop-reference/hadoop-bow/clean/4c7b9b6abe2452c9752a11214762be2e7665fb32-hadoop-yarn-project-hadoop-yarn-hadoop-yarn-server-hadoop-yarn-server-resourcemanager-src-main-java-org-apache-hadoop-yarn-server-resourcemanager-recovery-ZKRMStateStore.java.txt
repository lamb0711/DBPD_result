YARN-3385. Fixed a race-condition in ResourceManager's ZooKeeper based state-store to avoid crashing on duplicate deletes. Contributed by Zhihai Xu.

-    doMultiWithRetries(opList);
+    doDeleteMultiWithRetries(opList);
-    doMultiWithRetries(opList);
+    doStoreMultiWithRetries(opList);
-    ArrayList<Op> opList = new ArrayList<Op>();
+      ArrayList<Op> opList = new ArrayList<Op>();
+      doDeleteMultiWithRetries(opList);
-    doMultiWithRetries(opList);
-    doMultiWithRetries(opList);
+    doStoreMultiWithRetries(opList);
-      doMultiWithRetries(Op.delete(nodeRemovePath, -1));
+      doDeleteMultiWithRetries(Op.delete(nodeRemovePath, -1));
-  private synchronized void doMultiWithRetries(
+  private synchronized void doStoreMultiWithRetries(
-  private void doMultiWithRetries(final Op op) throws Exception {
-    doMultiWithRetries(Collections.singletonList(op));
+  private void doStoreMultiWithRetries(final Op op) throws Exception {
+    doStoreMultiWithRetries(Collections.singletonList(op));
+  }
+
+  /**
+   * Helper method that creates fencing node, executes the passed
+   * delete related operations and deletes the fencing node.
+   */
+  private synchronized void doDeleteMultiWithRetries(
+      final List<Op> opList) throws Exception {
+    final List<Op> execOpList = new ArrayList<Op>(opList.size() + 2);
+    execOpList.add(createFencingNodePathOp);
+    execOpList.addAll(opList);
+    execOpList.add(deleteFencingNodePathOp);
+    new ZKAction<Void>() {
+      @Override
+      public Void run() throws KeeperException, InterruptedException {
+        setHasDeleteNodeOp(true);
+        zkClient.multi(execOpList);
+        return null;
+      }
+    }.runWithRetries();
+  }
+
+  private void doDeleteMultiWithRetries(final Op op) throws Exception {
+    doDeleteMultiWithRetries(Collections.singletonList(op));
-    doMultiWithRetries(Op.create(path, data, acl, mode));
+    doStoreMultiWithRetries(Op.create(path, data, acl, mode));
-    doMultiWithRetries(Op.setData(path, data, version));
+    doStoreMultiWithRetries(Op.setData(path, data, version));
-    zkClient.delete(path, -1);
+
+    try {
+      zkClient.delete(path, -1);
+    } catch (KeeperException.NoNodeException nne) {
+      LOG.info("Node " + path + " doesn't exist to delete");
+    }
-          doMultiWithRetries(emptyOpList);
+          doStoreMultiWithRetries(emptyOpList);
+    private boolean hasDeleteNodeOp = false;
+    void setHasDeleteNodeOp(boolean hasDeleteOp) {
+      this.hasDeleteNodeOp = hasDeleteOp;
+    }
+          if (hasDeleteNodeOp && ke.code() == Code.NONODE) {
+            LOG.info("znode has already been deleted!");
+            return null;
+          }
+

HDFS-1623. High Availability Framework for HDFS NN. Contributed by Todd Lipcon, Aaron T. Myers, Eli Collins, Uma Maheswara Rao G, Bikas Saha, Suresh Srinivas, Jitendra Nath Pandey, Hari Mankude, Brandon Li, Sanjay Radia, Mingjie Lai, and Gregory Chanan


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296534 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.ha.HAServiceProtocol;
+import org.apache.hadoop.ha.HealthCheckFailedException;
+import org.apache.hadoop.ha.ServiceFailedException;
+import org.apache.hadoop.ha.proto.HAServiceProtocolProtos.HAServiceProtocolService;
+import org.apache.hadoop.ha.protocolPB.HAServiceProtocolPB;
+import org.apache.hadoop.ha.protocolPB.HAServiceProtocolServerSideTranslatorPB;
+
+import org.apache.hadoop.hdfs.server.namenode.NameNode.OperationCategory;
+import org.apache.hadoop.hdfs.server.protocol.HeartbeatResponse;
+import org.apache.hadoop.ipc.RpcPayloadHeader.RpcKind;
-  private final FSNamesystem namesystem;
+  protected final FSNamesystem namesystem;
+    
+    HAServiceProtocolServerSideTranslatorPB haServiceProtocolXlator = 
+        new HAServiceProtocolServerSideTranslatorPB(this);
+    BlockingService haPbService = HAServiceProtocolService
+        .newReflectiveBlockingService(haServiceProtocolXlator);
+      DFSUtil.addPBProtocol(conf, HAServiceProtocolPB.class, haPbService,
+          serviceRpcServer);
+    DFSUtil.addPBProtocol(conf, HAServiceProtocolPB.class, haPbService,
+        clientRpcServer);
-
+    namesystem.checkOperation(OperationCategory.READ);
+    namesystem.checkOperation(OperationCategory.UNCHECKED);
-    verifyRequest(registration);
-    if(!nn.isRole(NamenodeRole.NAMENODE))
-      throw new IOException("Only an ACTIVE node can invoke endCheckpoint.");
-
+  @Override // ClientProtocol
-  @Override
+  @Override // ClientProtocol, DatanodeProtocol
-    stateChangeLog.info("*DIR* NameNode.reportBadBlocks");
-    for (int i = 0; i < blocks.length; i++) {
-      ExtendedBlock blk = blocks[i].getBlock();
-      DatanodeInfo[] nodes = blocks[i].getLocations();
-      for (int j = 0; j < nodes.length; j++) {
-        DatanodeInfo dn = nodes[j];
-        namesystem.getBlockManager().findAndMarkBlockAsCorrupt(blk, dn,
-            "client machine reported it");
-      }
-    }
+    namesystem.reportBadBlocks(blocks);
-      boolean needLocation)
-  throws IOException {
+      boolean needLocation) throws IOException {
-  @Override
-  public long[] getStats() {
+  @Override // ClientProtocol
+  public long[] getStats() throws IOException {
+    namesystem.checkOperation(OperationCategory.READ);
-      throws IOException {
+  throws IOException {
+    namesystem.checkOperation(OperationCategory.UNCHECKED);
+    namesystem.checkOperation(OperationCategory.UNCHECKED);
-  public boolean restoreFailedStorage(String arg) 
-      throws AccessControlException {
+  public boolean restoreFailedStorage(String arg) throws IOException { 
+    namesystem.checkOperation(OperationCategory.UNCHECKED);
+    namesystem.checkOperation(OperationCategory.UNCHECKED);
+    namesystem.checkOperation(OperationCategory.UNCHECKED);
-  public long getTransactionID() {
+  public long getTransactionID() throws IOException {
+    namesystem.checkOperation(OperationCategory.CHECKPOINT);
-  @Override
+  @Override // NamenodeProtocol
+    namesystem.checkOperation(OperationCategory.READ);
+    namesystem.checkOperation(OperationCategory.WRITE);
+    namesystem.checkOperation(OperationCategory.READ);
+    namesystem.checkOperation(OperationCategory.UNCHECKED);
-	String[] cookieTab = new String[] { cookie };
+    String[] cookieTab = new String[] { cookie };
-   * @param bandwidth Blanacer bandwidth in bytes per second for all datanodes.
+   * @param bandwidth Balancer bandwidth in bytes per second for all datanodes.
+    namesystem.checkOperation(OperationCategory.UNCHECKED);
-  public DatanodeCommand[] sendHeartbeat(DatanodeRegistration nodeReg,
+  public HeartbeatResponse sendHeartbeat(DatanodeRegistration nodeReg,
-    if (nn.getFSImage().isUpgradeFinalized())
+    if (nn.getFSImage().isUpgradeFinalized() && !nn.isStandbyState())
-    namesystem.getBlockManager().blockReceivedAndDeleted(
+    namesystem.getBlockManager().processIncrementalBlockReport(
+  @Override // HAServiceProtocol
+  public synchronized void monitorHealth() 
+      throws HealthCheckFailedException, AccessControlException {
+    nn.monitorHealth();
+  }
+  
+  @Override // HAServiceProtocol
+  public synchronized void transitionToActive() 
+      throws ServiceFailedException, AccessControlException {
+    nn.transitionToActive();
+  }
+  
+  @Override // HAServiceProtocol
+  public synchronized void transitionToStandby() 
+      throws ServiceFailedException, AccessControlException {
+    nn.transitionToStandby();
+  }
+
+  @Override // HAServiceProtocol
+  public synchronized HAServiceState getServiceState() 
+      throws AccessControlException {
+    return nn.getServiceState();
+  }
+
+  @Override // HAServiceProtocol
+  public synchronized boolean readyToBecomeActive() 
+      throws ServiceFailedException, AccessControlException {
+    return nn.readyToBecomeActive();
+  }

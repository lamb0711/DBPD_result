YARN-6232. Update resource usage and preempted resource calculations to take into account all resource types. Contributed by Varun Vasudev.

+import org.apache.hadoop.yarn.api.records.ResourceInformation;
+import org.apache.hadoop.yarn.server.resourcemanager.RMServerUtils;
+import java.util.Map;
+
+
-      long finishTime, long memorySeconds, long vcoreSeconds,
-      long preemptedMemorySeconds, long preemptedVcoreSeconds) {
+      long finishTime, Map<String, Long> resourceSecondsMap,
+      Map<String, Long> preemptedResourceSecondsMap) {
-    attemptStateData.setMemorySeconds(memorySeconds);
-    attemptStateData.setVcoreSeconds(vcoreSeconds);
-    attemptStateData.setPreemptedMemorySeconds(preemptedMemorySeconds);
-    attemptStateData.setPreemptedVcoreSeconds(preemptedVcoreSeconds);
+    attemptStateData.setMemorySeconds(RMServerUtils
+        .getOrDefault(resourceSecondsMap,
+            ResourceInformation.MEMORY_MB.getName(), 0L));
+    attemptStateData.setVcoreSeconds(RMServerUtils
+        .getOrDefault(resourceSecondsMap, ResourceInformation.VCORES.getName(),
+            0L));
+    attemptStateData.setPreemptedMemorySeconds(RMServerUtils
+        .getOrDefault(preemptedResourceSecondsMap,
+            ResourceInformation.MEMORY_MB.getName(), 0L));
+    attemptStateData.setPreemptedVcoreSeconds(RMServerUtils
+        .getOrDefault(preemptedResourceSecondsMap,
+            ResourceInformation.VCORES.getName(), 0L));
+    attemptStateData.setResourceSecondsMap(resourceSecondsMap);
+    attemptStateData
+        .setPreemptedResourceSecondsMap(preemptedResourceSecondsMap);
-      Credentials attemptTokens, long startTime, long memorySeconds,
-      long vcoreSeconds, long preemptedMemorySeconds,
-      long preemptedVcoreSeconds) {
-    return newInstance(attemptId, masterContainer, attemptTokens,
-        startTime, null, "N/A", "", null, ContainerExitStatus.INVALID, 0,
-        memorySeconds, vcoreSeconds,
-        preemptedMemorySeconds, preemptedVcoreSeconds);
-    }
+      Credentials attemptTokens, long startTime,
+      Map<String, Long> resourceSeondsMap,
+      Map<String, Long> preemptedResourceSecondsMap) {
+    return newInstance(attemptId, masterContainer, attemptTokens, startTime,
+        null, "N/A", "", null, ContainerExitStatus.INVALID, 0,
+        resourceSeondsMap, preemptedResourceSecondsMap);
+  }
+
+  /**
+   * Get the aggregated number of resources preempted that the application has
+   * allocated times the number of seconds the application has been running.
+   *
+   * @return map containing the resource name and aggregated preempted
+   * resource-seconds
+   */
+  @Public
+  @Unstable
+  public abstract Map<String, Long> getResourceSecondsMap();
+
+  /**
+   * Set the aggregated number of resources that the application has
+   * allocated times the number of seconds the application has been running.
+   *
+   * @param resourceSecondsMap map containing the resource name and aggregated
+   *                           resource-seconds
+   */
+  @Public
+  @Unstable
+  public abstract void setResourceSecondsMap(
+      Map<String, Long> resourceSecondsMap);
+
+  /**
+   * Get the aggregated number of resources preempted that the application has
+   * allocated times the number of seconds the application has been running.
+   *
+   * @return map containing the resource name and aggregated preempted
+   * resource-seconds
+   */
+  @Public
+  @Unstable
+  public abstract Map<String, Long> getPreemptedResourceSecondsMap();
+
+  /**
+   * Set the aggregated number of resources preempted that the application has
+   * allocated times the number of seconds the application has been running.
+   *
+   * @param preemptedResourceSecondsMap map containing the resource name and
+   *                                    aggregated preempted resource-seconds
+   */
+  @Public
+  @Unstable
+  public abstract void setPreemptedResourceSecondsMap(
+      Map<String, Long> preemptedResourceSecondsMap);

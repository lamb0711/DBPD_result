HDDS-1234. Iterate the OM DB snapshot and populate the recon container DB. Contributed by Aravindan Vijayan.

+import java.io.IOException;
+import java.time.Instant;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import javax.ws.rs.WebApplicationException;
+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;
+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;
+import org.apache.hadoop.ozone.recon.api.types.ContainerKeyPrefix;
+import org.apache.hadoop.ozone.recon.api.types.KeyMetadata;
+import org.apache.hadoop.ozone.recon.recovery.ReconOMMetadataManager;
+import org.apache.hadoop.ozone.recon.spi.ContainerDBServiceProvider;
+
+import com.google.inject.Inject;
+
+  @Inject
+  private ContainerDBServiceProvider containerDBServiceProvider;
+
+  @Inject
+  private ReconOMMetadataManager omMetadataManager;
+
-  public Response getKeysForContainer(@PathParam("id") String containerId) {
-    return Response.ok().build();
+  public Response getKeysForContainer(@PathParam("id") Long containerId) {
+    Map<String, KeyMetadata> keyMetadataMap = new HashMap<>();
+    try {
+      Map<ContainerKeyPrefix, Integer> containerKeyPrefixMap =
+          containerDBServiceProvider.getKeyPrefixesForContainer(containerId);
+
+      // Get set of Container-Key mappings for given containerId.
+      for (ContainerKeyPrefix containerKeyPrefix : containerKeyPrefixMap
+          .keySet()) {
+
+        // Directly calling get() on the Key table instead of iterating since
+        // only full keys are supported now. When we change to using a prefix
+        // of the key, this needs to change to prefix seek (TODO).
+        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(
+            containerKeyPrefix.getKeyPrefix());
+        if (null == omKeyInfo) {
+          continue;
+        }
+
+        // Filter keys by version.
+        List<Long> matchedVersions = omKeyInfo.getKeyLocationVersions()
+            .stream()
+            .filter(k -> (k.getVersion() == containerKeyPrefix.getKeyVersion()))
+            .mapToLong(OmKeyLocationInfoGroup::getVersion)
+            .boxed()
+            .collect(Collectors.toList());
+
+        String ozoneKey = omMetadataManager.getOzoneKey(
+            omKeyInfo.getVolumeName(),
+            omKeyInfo.getBucketName(),
+            omKeyInfo.getKeyName());
+        if (keyMetadataMap.containsKey(ozoneKey)) {
+          keyMetadataMap.get(ozoneKey).getVersions().addAll(matchedVersions);
+        } else {
+          KeyMetadata keyMetadata = new KeyMetadata();
+          keyMetadata.setBucket(omKeyInfo.getBucketName());
+          keyMetadata.setVolume(omKeyInfo.getVolumeName());
+          keyMetadata.setKey(omKeyInfo.getKeyName());
+          keyMetadata.setCreationTime(
+              Instant.ofEpochMilli(omKeyInfo.getCreationTime()));
+          keyMetadata.setModificationTime(
+              Instant.ofEpochMilli(omKeyInfo.getModificationTime()));
+          keyMetadata.setDataSize(omKeyInfo.getDataSize());
+          keyMetadata.setVersions(matchedVersions);
+          keyMetadataMap.put(ozoneKey, keyMetadata);
+        }
+      }
+    } catch (IOException ioEx) {
+      throw new WebApplicationException(ioEx,
+          Response.Status.INTERNAL_SERVER_ERROR);
+    }
+    return Response.ok(keyMetadataMap.values()).build();

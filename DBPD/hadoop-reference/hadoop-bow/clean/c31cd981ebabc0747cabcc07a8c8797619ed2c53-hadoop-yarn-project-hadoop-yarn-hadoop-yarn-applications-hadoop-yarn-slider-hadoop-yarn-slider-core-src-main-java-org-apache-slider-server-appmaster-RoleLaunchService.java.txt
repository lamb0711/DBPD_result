YARN-6255. Refactor yarn-native-services framework. Contributed by Jian He

-import com.google.common.base.Preconditions;
-import org.apache.hadoop.fs.Path;
-import org.apache.slider.common.SliderKeys;
+import org.apache.slider.api.resource.Application;
-import org.apache.slider.core.conf.AggregateConf;
-import org.apache.slider.core.conf.MapOperations;
-import org.apache.slider.server.services.workflow.WorkflowExecutorService;
+import org.apache.slider.server.services.workflow.WorkflowExecutorService;
-  /**
-   * Path in the launch filesystem that refers to a configuration directory
-   * -the interpretation of it is left to the Provider
-   */
-  private final Path generatedConfDirPath;
-  /**
-   * Path in the launch filesystem that refers to a temp directory
-   * which will be cleaned up at (some) time in the future
-   */
-  private final Path launcherTmpDirPath;
-   * @param generatedConfDirPath path in the FS for the generated dir
-   * @param launcherTmpDirPath path for a temporary data in the launch process
-  public RoleLaunchService(QueueAccess queueAccess,
-      ProviderService provider,
-      SliderFileSystem fs,
-      Path generatedConfDirPath,
-      Map<String, String> envVars,
-      Path launcherTmpDirPath) {
+  public RoleLaunchService(QueueAccess queueAccess, ProviderService provider,
+      SliderFileSystem fs, Map<String, String> envVars) {
-    this.generatedConfDirPath = generatedConfDirPath;
-    this.launcherTmpDirPath = launcherTmpDirPath;
-   * @param clusterSpec cluster spec to use for template
-      AggregateConf clusterSpec,
-      Credentials credentials) {
-    RoleStatus role = assignment.role;
-    String roleName = role.getName();
-    String roleGroup = role.getGroup();
-    // prelaunch safety check
-    Preconditions.checkArgument(provider.isSupportedRole(roleName));
+      Application application, Credentials credentials) {
-      new RoleLaunchService.RoleLauncher(assignment,
-         clusterSpec,
-         clusterSpec.getResourceOperations().getOrAddComponent(roleGroup),
-         clusterSpec.getAppConfOperations().getOrAddComponent(roleGroup),
-         credentials);
+        new RoleLaunchService.RoleLauncher(assignment, application,
+            credentials);
-    private final MapOperations resourceComponent;
-    private final MapOperations appComponent;
-    private final AggregateConf instanceDefinition;
+    public final Application application;
-    private Exception raisedException;
-        AggregateConf instanceDefinition,
-        MapOperations resourceComponent,
-        MapOperations appComponent,
+        Application application,
-
-      assert resourceComponent != null;
-      assert appComponent != null;
-      assert providerRole != null;
-      this.resourceComponent = resourceComponent;
-      this.appComponent = appComponent;
-      this.instanceDefinition = instanceDefinition;
-    }
+      this.application = application;
-    public Exception getRaisedException() {
-      return raisedException;
-        log.debug("Launching container {} into role {}",
-                  container.getId(),
-                  role.name);
+        log.info("Launching container {} into RoleName = {}, RoleGroup = {}",
+            container.getId(), role.name, role.group);
-        //now build up the configuration data
-        Path containerTmpDirPath =
-          new Path(launcherTmpDirPath, container.getId().toString());
-        provider.buildContainerLaunchContext(containerLauncher,
-            instanceDefinition,
-            container,
-            role,
-            fs,
-            generatedConfDirPath,
-            resourceComponent,
-            appComponent,
-            containerTmpDirPath);
+        provider.buildContainerLaunchContext(containerLauncher, application,
+            container, role, fs);
-        log.info("Starting container with command: {}",
-                 commandsAsString);
+        log.info("Starting container with command: {}", commandsAsString);
+        instance.providerRole = role;
-        instance.appVersion = instanceDefinition.getAppConfOperations()
-            .getGlobalOptions().get(SliderKeys.APP_VERSION);
-        int delay = appComponent.getOptionInt(
-            AgentKeys.KEY_CONTAINER_LAUNCH_DELAY, 0);
-        int maxDelay =
-            getConfig().getInt(YarnConfiguration.RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS,
-                               YarnConfiguration.DEFAULT_RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS);
+        long delay = role.component.getConfiguration()
+            .getPropertyLong(AgentKeys.KEY_CONTAINER_LAUNCH_DELAY, 0);
+        long maxDelay = getConfig()
+            .getLong(YarnConfiguration.RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS,
+                YarnConfiguration.DEFAULT_RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS);
-        log.info("Container launch delay for {} set to {} seconds",
-                 role.name, delay);
-        actionQueue.schedule(new ActionStartContainer("starting " + role.name,
-                                                      container,
-                                                      containerLauncher.completeContainerLaunch(),
-                                                      instance,
-                                                      delay,
-                                                      TimeUnit.SECONDS));
+        log.info("Container launch delay for {} set to {} seconds", role.name,
+            delay);
+        actionQueue.schedule(
+            new ActionStartContainer("starting " + role.name, container,
+                containerLauncher.completeContainerLaunch(), instance, delay,
+                TimeUnit.SECONDS));
-        log.error("Exception thrown while trying to start {}: {}",
-            role.name, e, e);
-        raisedException = e;
+        log.error("Exception thrown while trying to start " + role.name
+            + " container = " + container.getId() + " on host " + container
+            .getNodeId(), e);
-

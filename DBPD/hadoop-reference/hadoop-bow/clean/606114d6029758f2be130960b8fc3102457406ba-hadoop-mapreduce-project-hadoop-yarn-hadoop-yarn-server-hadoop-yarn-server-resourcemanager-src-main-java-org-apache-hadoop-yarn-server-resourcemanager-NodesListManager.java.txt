MAPREDUCE-3533. Add a channel between RM and AM to get information on nodes. Contributed by Bikas Saha. 


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1305230 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collection;
+import java.util.Collections;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.hadoop.yarn.event.EventHandler;
+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMApp;
+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMAppNodeUpdateEvent;
+import org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMAppNodeUpdateEvent.RMAppNodeUpdateType;
+import org.apache.hadoop.yarn.server.resourcemanager.rmnode.RMNode;
-public class NodesListManager extends AbstractService{
+public class NodesListManager extends AbstractService implements
+    EventHandler<NodesListManagerEvent> {
+  private Set<RMNode> unusableRMNodesConcurrentSet = Collections
+      .newSetFromMap(new ConcurrentHashMap<RMNode,Boolean>());
+  
+  private final RMContext rmContext;
-  public NodesListManager() {
+  public NodesListManager(RMContext rmContext) {
+    this.rmContext = rmContext;
+  
+  /**
+   * Provides the currently unusable nodes. Copies it into provided collection.
+   * @param unUsableNodes
+   *          Collection to which the unusable nodes are added
+   * @return number of unusable nodes added
+   */
+  public int getUnusableNodes(Collection<RMNode> unUsableNodes) {
+    unUsableNodes.addAll(unusableRMNodesConcurrentSet);
+    return unusableRMNodesConcurrentSet.size();
+  }
+
+  @Override
+  public void handle(NodesListManagerEvent event) {
+    RMNode eventNode = event.getNode();
+    switch (event.getType()) {
+    case NODE_UNUSABLE:
+      LOG.debug(eventNode + " reported unusable");
+      unusableRMNodesConcurrentSet.add(eventNode);
+      for(RMApp app: rmContext.getRMApps().values()) {
+        this.rmContext
+            .getDispatcher()
+            .getEventHandler()
+            .handle(
+                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,
+                    RMAppNodeUpdateType.NODE_UNUSABLE));
+      }
+      break;
+    case NODE_USABLE:
+      if (unusableRMNodesConcurrentSet.contains(eventNode)) {
+        LOG.debug(eventNode + " reported usable");
+        unusableRMNodesConcurrentSet.remove(eventNode);
+        for (RMApp app : rmContext.getRMApps().values()) {
+          this.rmContext
+              .getDispatcher()
+              .getEventHandler()
+              .handle(
+                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,
+                      RMAppNodeUpdateType.NODE_USABLE));
+        }
+      } else {
+        LOG.warn(eventNode
+            + " reported usable without first reporting unusable");
+      }
+      break;
+    default:
+      LOG.error("Ignoring invalid eventtype " + event.getType());
+    }
+  }

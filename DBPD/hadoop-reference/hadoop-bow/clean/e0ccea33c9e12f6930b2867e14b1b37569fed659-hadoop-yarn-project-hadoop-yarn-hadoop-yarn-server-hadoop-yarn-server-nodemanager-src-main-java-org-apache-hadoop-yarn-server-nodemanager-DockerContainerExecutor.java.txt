YARN-3288. Document and fix indentation in the DockerContainerExecutor code

-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Joiner;
-import com.google.common.base.Preconditions;
-import com.google.common.base.Strings;
+import static org.apache.hadoop.fs.CreateFlag.CREATE;
+import static org.apache.hadoop.fs.CreateFlag.OVERWRITE;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.PrintStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.regex.Pattern;
-import java.net.InetSocketAddress;
-import static org.apache.hadoop.fs.CreateFlag.CREATE;
-import static org.apache.hadoop.fs.CreateFlag.OVERWRITE;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
+import com.google.common.base.Strings;
- * This executor will launch a docker container and run the task inside the container.
+ * This executor will launch and run tasks inside Docker containers. It
+ * currently only supports simple authentication mode. It shares a lot of code
+ * with the DefaultContainerExecutor (and it may make sense to pull out those
+ * common pieces later).
-
-      .getLog(DockerContainerExecutor.class);
-  public static final String DOCKER_CONTAINER_EXECUTOR_SCRIPT = "docker_container_executor";
-  public static final String DOCKER_CONTAINER_EXECUTOR_SESSION_SCRIPT = "docker_container_executor_session";
+    .getLog(DockerContainerExecutor.class);
+  //The name of the script file that will launch the Docker containers
+  public static final String DOCKER_CONTAINER_EXECUTOR_SCRIPT =
+    "docker_container_executor";
+  //The name of the session script that the DOCKER_CONTAINER_EXECUTOR_SCRIPT
+  //launches in turn
+  public static final String DOCKER_CONTAINER_EXECUTOR_SESSION_SCRIPT =
+    "docker_container_executor_session";
-  // This validates that the image is a proper docker image and would not crash docker.
-  public static final String DOCKER_IMAGE_PATTERN = "^(([\\w\\.-]+)(:\\d+)*\\/)?[\\w\\.:-]+$";
-
+  //This validates that the image is a proper docker image and would not crash
+  //docker. The image name is not allowed to contain spaces. e.g.
+  //registry.somecompany.com:9999/containername:0.1 or
+  //containername:0.1 or
+  //containername
+  public static final String DOCKER_IMAGE_PATTERN =
+    "^(([\\w\\.-]+)(:\\d+)*\\/)?[\\w\\.:-]+$";
-    String auth = getConf().get(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION);
+    String auth =
+      getConf().get(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION);
-      throw new IllegalStateException("DockerContainerExecutor only works with simple authentication mode");
+      throw new IllegalStateException(
+        "DockerContainerExecutor only works with simple authentication mode");
-    String dockerExecutor = getConf().get(YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_EXEC_NAME,
+    String dockerExecutor = getConf().get(
+      YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_EXEC_NAME,
-      throw new IllegalStateException("Invalid docker exec path: " + dockerExecutor);
+      throw new IllegalStateException(
+        "Invalid docker exec path: " + dockerExecutor);
-                                          InetSocketAddress nmAddr, String user, String appId, String locId,
-                                          LocalDirsHandlerService dirsHandler)
+    InetSocketAddress nmAddr, String user, String appId, String locId,
+    LocalDirsHandlerService dirsHandler)
-
-    String tokenFn = String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);
+    String tokenFn =
+      String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT, locId);
-  public int launchContainer(Container container,
-                             Path nmPrivateContainerScriptPath, Path nmPrivateTokensPath,
-                             String userName, String appId, Path containerWorkDir,
-                             List<String> localDirs, List<String> logDirs) throws IOException {
+  public int launchContainer(Container container, Path
+    nmPrivateContainerScriptPath, Path nmPrivateTokensPath, String userName,
+    String appId, Path containerWorkDir, List<String> localDirs, List<String>
+    logDirs) throws IOException {
+    //Variables for the launch environment can be injected from the command-line
+    //while submitting the application
-        .get(YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_IMAGE_NAME);
+      .get(YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_IMAGE_NAME);
-    Preconditions.checkArgument(!Strings.isNullOrEmpty(containerImageName), "Container image must not be null");
+    Preconditions.checkArgument(!Strings.isNullOrEmpty(containerImageName),
+      "Container image must not be null");
-    Preconditions.checkArgument(saneDockerImage(containerImageName), "Image: " + containerImageName + " is not a proper docker image");
-    String dockerExecutor = getConf().get(YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_EXEC_NAME,
-        YarnConfiguration.NM_DEFAULT_DOCKER_CONTAINER_EXECUTOR_EXEC_NAME);
+    Preconditions.checkArgument(saneDockerImage(containerImageName), "Image: "
+      + containerImageName + " is not a proper docker image");
+    String dockerExecutor = getConf().get(
+      YarnConfiguration.NM_DOCKER_CONTAINER_EXECUTOR_EXEC_NAME,
+      YarnConfiguration.NM_DEFAULT_DOCKER_CONTAINER_EXECUTOR_EXEC_NAME);
-    String appIdStr =
-        ConverterUtils.toString(
-            containerId.getApplicationAttemptId().
-                getApplicationId());
+    String appIdStr = ConverterUtils.toString(
+      containerId.getApplicationAttemptId().getApplicationId());
-        YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);
+      YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR);
-        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);
+      new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);
-        new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);
+      new Path(containerWorkDir, ContainerLaunch.FINAL_CONTAINER_TOKENS_FILE);
-
-
-    String containerWorkDirMount = toMount(Collections.singletonList(containerWorkDir.toUri().getPath()));
+    String containerWorkDirMount = toMount(Collections.singletonList(
+      containerWorkDir.toUri().getPath()));
+    //Use docker run to launch the docker container. See man pages for
+    //docker-run
+    //--rm removes the container automatically once the container finishes
+    //--net=host allows the container to take on the host's network stack
+    //--name sets the Docker Container name to the YARN containerId string
+    //-v is used to bind mount volumes for local, log and work dirs.
-        .append(" ")
-        .append("run")
-        .append(" ")
-        .append("--rm --net=host")
-        .append(" ")
-        .append(" --name " + containerIdStr)
-        .append(localDirMount)
-        .append(logDirMount)
-        .append(containerWorkDirMount)
-        .append(" ")
-        .append(containerImageName)
-        .toString();
-    String dockerPidScript = "`" + dockerExecutor + " inspect --format {{.State.Pid}} " + containerIdStr + "`";
+      .append(" ")
+      .append("run")
+      .append(" ")
+      .append("--rm --net=host")
+      .append(" ")
+      .append(" --name " + containerIdStr)
+      .append(localDirMount)
+      .append(logDirMount)
+      .append(containerWorkDirMount)
+      .append(" ")
+      .append(containerImageName)
+      .toString();
+    //Get the pid of the process which has been launched as a docker container
+    //using docker inspect
+    String dockerPidScript = "`" + dockerExecutor +
+      " inspect --format {{.State.Pid}} " + containerIdStr + "`";
+
-    LocalWrapperScriptBuilder sb =
-      new UnixLocalWrapperScriptBuilder(containerWorkDir, commandStr, dockerPidScript);
+    LocalWrapperScriptBuilder sb = new UnixLocalWrapperScriptBuilder(
+      containerWorkDir, commandStr, dockerPidScript);
+      //Although the container was activated by ContainerLaunch before exec()
+      //was called, since then deactivateContainer() has been called.
-        LOG.debug("launchContainer: " + commandStr + " " + Joiner.on(" ").join(command));
+        LOG.debug("launchContainer: " + commandStr + " " +
+          Joiner.on(" ").join(command));
-          command,
-          new File(containerWorkDir.toUri().getPath()),
-          container.getLaunchContext().getEnvironment());      // sanitized env
+        command,
+        new File(containerWorkDir.toUri().getPath()),
+        container.getLaunchContext().getEnvironment());      // sanitized env
-  public void writeLaunchEnv(OutputStream out, Map<String, String> environment, Map<Path, List<String>> resources, List<String> command) throws IOException {
-    ContainerLaunch.ShellScriptBuilder sb = ContainerLaunch.ShellScriptBuilder.create();
+  /**
+   * Filter the environment variables that may conflict with the ones set in
+   * the docker image and write them out to an OutputStream.
+   */
+  public void writeLaunchEnv(OutputStream out, Map<String, String> environment,
+    Map<Path, List<String>> resources, List<String> command)
+    throws IOException {
+    ContainerLaunch.ShellScriptBuilder sb =
+      ContainerLaunch.ShellScriptBuilder.create();
+    //Remove environments that may conflict with the ones in Docker image.
+  //This class facilitates (only) the creation of platform-specific scripts that
+  //will be used to launch the containers
+  //TODO: This should be re-used from the DefaultContainerExecutor.
-    public void writeLocalWrapperScript(Path launchDst, Path pidFile) throws IOException {
+    public void writeLocalWrapperScript(Path launchDst, Path pidFile)
+      throws IOException {
-    protected abstract void writeLocalWrapperScript(Path launchDst, Path pidFile,
-                                                    PrintStream pout);
+    protected abstract void writeLocalWrapperScript(Path launchDst,
+      Path pidFile, PrintStream pout);
+  //TODO: This class too should be used from DefaultContainerExecutor.
-      extends LocalWrapperScriptBuilder {
+    extends LocalWrapperScriptBuilder {
-    public UnixLocalWrapperScriptBuilder(Path containerWorkDir, String dockerCommand, String dockerPidScript) {
+    public UnixLocalWrapperScriptBuilder(Path containerWorkDir,
+      String dockerCommand, String dockerPidScript) {
-                                        PrintStream pout) {
-
+      PrintStream pout) {
-        pout.println("echo "+ dockerPidScript +" > " + pidFile.toString() + ".tmp");
+        pout.println("echo "+ dockerPidScript +" > " + pidFile.toString()
+          + ".tmp");
-                           boolean createParent, String user) throws IOException {
+    boolean createParent, String user) throws IOException {
-      throws IOException {
+    throws IOException {
-        createDir(getUserCacheDir(new Path(localDir), user), userperms, true, user);
+        createDir(getUserCacheDir(new Path(localDir), user), userperms, true,
+          user);
-                              List<String> logDirs, String user) throws IOException {
+    List<String> logDirs, String user) throws IOException {
-                               String appId) throws IOException {
+    String appId) throws IOException {

HDFS-4877. Snapshot: fix the scenario where a directory is renamed under its prior descendant. Contributed by Jing Zhao.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490421 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Map;
-          counts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);
+          counts.get(Quota.DISKSPACE), false);
-      final BlocksMapUpdateInfo collectedBlocks, final List<INode> removedINodes)
+      final BlocksMapUpdateInfo collectedBlocks,
+      final List<INode> removedINodes, final boolean countDiffChange)
+    Map<INode, INode> priorCreated = null;
+    Map<INode, INode> priorDeleted = null;
+      // if there is a snapshot diff associated with prior, we need to record
+      // its original created and deleted list before deleting post
+      if (prior != null) {
+        DirectoryDiff priorDiff = this.getDiffs().getDiff(prior);
+        if (priorDiff != null && priorDiff.getSnapshot().equals(prior)) {
+          List<INode> cList = priorDiff.diff.getList(ListType.CREATED);
+          List<INode> dList = priorDiff.diff.getList(ListType.DELETED);
+          priorCreated = new HashMap<INode, INode>(cList.size());
+          for (INode cNode : cList) {
+            priorCreated.put(cNode, cNode);
+          }
+          priorDeleted = new HashMap<INode, INode>(dList.size());
+          for (INode dNode : dList) {
+            priorDeleted.put(dNode, dNode);
+          }
+        }
+      }
+      
-          collectedBlocks, removedINodes));
+          collectedBlocks, removedINodes, countDiffChange));
+      
+      // check priorDiff again since it may be created during the diff deletion
-          for (INode cNode : priorDiff.getChildrenDiff().getList(
-              ListType.CREATED)) {
-            counts.add(cNode.cleanSubtree(snapshot, null, collectedBlocks,
-                removedINodes));
+          if (priorCreated != null) {
+            // we only check the node originally in prior's created list
+            for (INode cNode : priorDiff.getChildrenDiff().getList(
+                ListType.CREATED)) {
+              if (priorCreated.containsKey(cNode)) {
+                counts.add(cNode.cleanSubtree(snapshot, null, collectedBlocks,
+                    removedINodes, countDiffChange));
+              }
+            }
+          
+          
-            counts.add(cleanDeletedINode(dNode, snapshot, prior,
-                collectedBlocks, removedINodes));
+            if (priorDeleted == null || !priorDeleted.containsKey(dNode)) {
+              counts.add(cleanDeletedINode(dNode, snapshot, prior,
+                  collectedBlocks, removedINodes, countDiffChange));
+            }
-        removedINodes));
+        removedINodes, priorDeleted, countDiffChange));
-  private static Quota.Counts cleanDeletedINode(INode inode, final Snapshot post, 
-      final Snapshot prior, final BlocksMapUpdateInfo collectedBlocks, 
-      final List<INode> removedINodes) throws QuotaExceededException {
+  private static Quota.Counts cleanDeletedINode(INode inode,
+      final Snapshot post, final Snapshot prior,
+      final BlocksMapUpdateInfo collectedBlocks,
+      final List<INode> removedINodes, final boolean countDiffChange) 
+      throws QuotaExceededException {
-          wn.cleanSubtree(post, prior, collectedBlocks, removedINodes);
+          wn.cleanSubtree(post, prior, collectedBlocks, removedINodes,
+              countDiffChange);
-            topNode.asFile(), collectedBlocks, removedINodes));
+            topNode.asFile(), collectedBlocks, removedINodes, countDiffChange));
+        ChildrenDiff priorChildrenDiff = null;
-            counts.add(priorDiff.diff.destroyCreatedList(sdir,
+            priorChildrenDiff = priorDiff.getChildrenDiff();
+            counts.add(priorChildrenDiff.destroyCreatedList(sdir,
+        
+          if (priorChildrenDiff != null
+              && priorChildrenDiff.search(ListType.DELETED,
+                  child.getLocalNameBytes()) != null) {
+            continue;
+          }
-        inode.cleanSubtree(snapshot, prior, collectedBlocks, removedINodes);
+        inode.cleanSubtree(snapshot, prior, collectedBlocks, removedINodes,
+            true);
-      inode.cleanSubtree(snapshot, prior, collectedBlocks, removedINodes);
+      inode.cleanSubtree(snapshot, prior, collectedBlocks, removedINodes, true);
+      Map<INode, INode> excludedNodes = null;
-              removedINodes);
+              removedINodes, true);
+          List<INode> dList = priorDiff.diff.getList(ListType.DELETED);
+          excludedNodes = new HashMap<INode, INode>(dList.size());
+          for (INode dNode : dList) {
+            excludedNodes.put(dNode, dNode);
+          }
+        if (excludedNodes != null && excludedNodes.containsKey(child)) {
+          continue;
+        }

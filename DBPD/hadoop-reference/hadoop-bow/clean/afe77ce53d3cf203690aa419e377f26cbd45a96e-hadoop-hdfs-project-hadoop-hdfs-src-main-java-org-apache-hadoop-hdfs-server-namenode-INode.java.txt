HDFS-4480. Eliminate the file snapshot circular linked list.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1444280 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
+import java.util.List;
-import org.apache.hadoop.hdfs.server.blockmanagement.BlockCollection;
-   * @param withLink whether the node is INodeWithLink
-   * @param withSnapshot whether the node is {@link INodeDirectoryWithSnapshot}
+   * @param withSnapshot whether the node has snapshots
-      long preferredBlockSize, int numBlocks, boolean withLink,
+      long preferredBlockSize, int numBlocks,
-      return withLink ? new INodeFileWithSnapshot(fileNode, null) : fileNode;
+      return withSnapshot ? new INodeFileWithSnapshot(fileNode) : fileNode;
-  public static class BlocksMapUpdateInfo implements
-      Iterable<Map.Entry<Block, BlocksMapINodeUpdateEntry>> {
-    private final Map<Block, BlocksMapINodeUpdateEntry> updateMap;
+  public static class BlocksMapUpdateInfo {
+    /**
+     * The list of blocks that need to be removed from blocksMap
+     */
+    private List<Block> toDeleteList;
+    
+    public BlocksMapUpdateInfo(List<Block> toDeleteList) {
+      this.toDeleteList = toDeleteList == null ? new ArrayList<Block>()
+          : toDeleteList;
+    }
-      updateMap = new HashMap<Block, BlocksMapINodeUpdateEntry>();
+      toDeleteList = new ArrayList<Block>();
-     * Add a to-be-deleted block. This block should belongs to a file without
-     * snapshots. We thus only need to put a block-null pair into the updateMap.
-     * 
+     * @return The list of blocks that need to be removed from blocksMap
+     */
+    public List<Block> getToDeleteList() {
+      return toDeleteList;
+    }
+    
+    /**
+     * Add a to-be-deleted block into the
+     * {@link BlocksMapUpdateInfo#toDeleteList}
-        updateMap.put(toDelete, null);
+        toDeleteList.add(toDelete);
-     * Add a given block, as well as its old and new BlockCollection
-     * information, into the updateMap.
-     * 
-     * @param toUpdateBlock
-     *          The given block
-     * @param entry
-     *          The BlocksMapINodeUpdateEntry instance containing both the
-     *          original BlockCollection of the given block and the new
-     *          BlockCollection of the given block for updating the blocksMap.
-     *          The new BlockCollection should be the INode of one of the
-     *          corresponding file's snapshot.
-     */
-    public void addUpdateBlock(Block toUpdateBlock,
-        BlocksMapINodeUpdateEntry entry) {
-      updateMap.put(toUpdateBlock, entry);
-    }
-
-    /**
-     * Clear {@link BlocksMapUpdateInfo#updateMap}
+     * Clear {@link BlocksMapUpdateInfo#toDeleteList}
-      updateMap.clear();
-    }
-
-    @Override
-    public Iterator<Map.Entry<Block, BlocksMapINodeUpdateEntry>> iterator() {
-      return updateMap.entrySet().iterator();
-    }
-  }
-  
-  /**
-   * When deleting a file with snapshot, we cannot directly remove its record
-   * from blocksMap. Instead, we should consider replacing the original record
-   * in blocksMap with INode of snapshot.
-   */
-  public static class BlocksMapINodeUpdateEntry {
-    /**
-     * The BlockCollection of the file to be deleted
-     */
-    private final BlockCollection toDelete;
-    /**
-     * The BlockCollection of the to-be-deleted file's snapshot
-     */
-    private final BlockCollection toReplace;
-
-    public BlocksMapINodeUpdateEntry(BlockCollection toDelete,
-        BlockCollection toReplace) {
-      this.toDelete = toDelete;
-      this.toReplace = toReplace;
-    }
-
-    public BlockCollection getToDelete() {
-      return toDelete;
-    }
-
-    public BlockCollection getToReplace() {
-      return toReplace;
+      toDeleteList.clear();

HDFS-12773. RBF: Improve State Store FS implementation. Contributed by Inigo Goiri.

-import static org.apache.hadoop.hdfs.server.federation.store.StateStoreUtils.getRecordClass;
+import static org.apache.hadoop.util.Time.monotonicNow;
+import static org.apache.hadoop.util.Time.now;
-import java.util.Collection;
-import java.util.LinkedList;
+import java.util.Map.Entry;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.hadoop.hdfs.server.federation.metrics.StateStoreMetrics;
+import org.apache.hadoop.hdfs.server.federation.store.StateStoreUtils;
+import org.apache.hadoop.util.Time;
+import com.google.common.annotations.VisibleForTesting;
+
- * {@link StateStoreDriver} implementation based on a local file.
+ * {@link StateStoreDriver} implementation based on files. In this approach, we
+ * use temporary files for the writes and renaming "atomically" to the final
+ * value. Instead of writing to the final location, it will go to a temporary
+ * one and then rename to the final destination.
+  /** File extension for temporary files. */
+  private static final String TMP_MARK = ".tmp";
+  /** We remove temporary files older than 10 seconds. */
+  private static final long OLD_TMP_RECORD_MS = TimeUnit.SECONDS.toMillis(10);
+  /** File pattern for temporary records: file.XYZ.tmp. */
+  private static final Pattern OLD_TMP_RECORD_PATTERN =
+      Pattern.compile(".+\\.(\\d+)\\.tmp");
+
-  /** Name of the file containing the data. */
-  private static final String DATA_FILE_NAME = "records.data";
-
-   * Lock reading records.
+   * Get the reader of a record for the file system.
-   * @param clazz Class of the record.
-   */
-  protected abstract <T extends BaseRecord> void lockRecordRead(Class<T> clazz);
-
-  /**
-   * Unlock reading records.
-   *
-   * @param clazz Class of the record.
-   */
-  protected abstract <T extends BaseRecord> void unlockRecordRead(
-      Class<T> clazz);
-
-  /**
-   * Lock writing records.
-   *
-   * @param clazz Class of the record.
-   */
-  protected abstract <T extends BaseRecord> void lockRecordWrite(
-      Class<T> clazz);
-
-  /**
-   * Unlock writing records.
-   *
-   * @param clazz Class of the record.
-   */
-  protected abstract <T extends BaseRecord> void unlockRecordWrite(
-      Class<T> clazz);
-
-  /**
-   * Get the reader for the file system.
-   *
-   * @param clazz Class of the record.
+   * @param path Path of the record to read.
+   * @return Reader for the record.
-      Class<T> clazz, String sub);
+      String path);
-   * Get the writer for the file system.
+   * Get the writer of a record for the file system.
-   * @param clazz Class of the record.
+   * @param path Path of the record to write.
+   * @return Writer for the record.
-      Class<T> clazz, String sub);
+      String path);
+   * Rename a file. This should be atomic.
+   *
+   * @param src Source name.
+   * @param dst Destination name.
+   * @return If the rename was successful.
+   */
+  protected abstract boolean rename(String src, String dst);
+
+  /**
+   * Remove a file.
+   *
+   * @param path Path for the file to remove
+   * @return If the file was removed.
+   */
+  protected abstract boolean remove(String path);
+
+  /**
+   * Get the children for a path.
+   *
+   * @param path Path to check.
+   * @return List of children.
+   */
+  protected abstract List<String> getChildren(String path);
+
+  /**
-        String dataFilePath = dataDirPath + "/" + DATA_FILE_NAME;
-        if (!exists(dataFilePath)) {
-          // Create empty file
-          List<T> emtpyList = new ArrayList<>();
-          if(!writeAll(emtpyList, recordClass)) {
-            LOG.error("Cannot create data file {}", dataFilePath);
-            return false;
-          }
-        }
-  /**
-   * Read all lines from a file and deserialize into the desired record type.
-   *
-   * @param reader Open handle for the file.
-   * @param clazz Record class to create.
-   * @param includeDates True if dateModified/dateCreated are serialized.
-   * @return List of records.
-   * @throws IOException
-   */
-  private <T extends BaseRecord> List<T> getAllFile(
-      BufferedReader reader, Class<T> clazz, boolean includeDates)
-          throws IOException {
-
-    List<T> ret = new ArrayList<T>();
-    String line;
-    while ((line = reader.readLine()) != null) {
-      if (!line.startsWith("#") && line.length() > 0) {
-        try {
-          T record = newRecord(line, clazz, includeDates);
-          ret.add(record);
-        } catch (Exception ex) {
-          LOG.error("Cannot parse line in data source file: {}", line, ex);
-        }
-      }
-    }
-    return ret;
-  }
-
-    return get(clazz, (String)null);
+    verifyDriverReady();
+    long start = monotonicNow();
+    StateStoreMetrics metrics = getMetrics();
+    List<T> ret = new ArrayList<>();
+    try {
+      String path = getPathForClass(clazz);
+      List<String> children = getChildren(path);
+      for (String child : children) {
+        String pathRecord = path + "/" + child;
+        if (child.endsWith(TMP_MARK)) {
+          LOG.debug("There is a temporary file {} in {}", child, path);
+          if (isOldTempRecord(child)) {
+            LOG.warn("Removing {} as it's an old temporary record", child);
+            remove(pathRecord);
+          }
+        } else {
+          T record = getRecord(pathRecord, clazz);
+          ret.add(record);
+        }
+      }
+    } catch (Exception e) {
+      if (metrics != null) {
+        metrics.addFailure(monotonicNow() - start);
+      }
+      String msg = "Cannot fetch records for " + clazz.getSimpleName();
+      LOG.error(msg, e);
+      throw new IOException(msg, e);
+    }
+
+    if (metrics != null) {
+      metrics.addRead(monotonicNow() - start);
+    }
+    return new QueryResult<T>(ret, getTime());
-  @Override
-  public <T extends BaseRecord> QueryResult<T> get(Class<T> clazz, String sub)
-      throws IOException {
-    verifyDriverReady();
-    BufferedReader reader = null;
-    lockRecordRead(clazz);
+  /**
+   * Check if a record is temporary and old.
+   *
+   * @param pathRecord Path for the record to check.
+   * @return If the record is temporary and old.
+   */
+  @VisibleForTesting
+  public static boolean isOldTempRecord(final String pathRecord) {
+    if (!pathRecord.endsWith(TMP_MARK)) {
+      return false;
+    }
+    // Extract temporary record creation time
+    Matcher m = OLD_TMP_RECORD_PATTERN.matcher(pathRecord);
+    if (m.find()) {
+      long time = Long.parseLong(m.group(1));
+      return now() - time > OLD_TMP_RECORD_MS;
+    }
+    return false;
+  }
+
+  /**
+   * Read a record from a file.
+   *
+   * @param path Path to the file containing the record.
+   * @param clazz Class of the record.
+   * @return Record read from the file.
+   * @throws IOException If the file cannot be read.
+   */
+  private <T extends BaseRecord> T getRecord(
+      final String path, final Class<T> clazz) throws IOException {
+    BufferedReader reader = getReader(path);
-      reader = getReader(clazz, sub);
-      List<T> data = getAllFile(reader, clazz, true);
-      return new QueryResult<T>(data, getTime());
-    } catch (Exception ex) {
-      LOG.error("Cannot fetch records {}", clazz.getSimpleName());
-      throw new IOException("Cannot read from data store " + ex.getMessage());
+      String line;
+      while ((line = reader.readLine()) != null) {
+        if (!line.startsWith("#") && line.length() > 0) {
+          try {
+            T record = newRecord(line, clazz, false);
+            return record;
+          } catch (Exception ex) {
+            LOG.error("Cannot parse line {} in file {}", line, path, ex);
+          }
+        }
+      }
-        try {
-          reader.close();
-        } catch (IOException e) {
-          LOG.error("Failed closing file", e);
-        }
+        reader.close();
-      unlockRecordRead(clazz);
+    throw new IOException("Cannot read " + path + " for record " +
+        clazz.getSimpleName());
-   * Overwrite the existing data with a new data set.
-   *
-   * @param records List of records to write.
-   * @param writer BufferedWriter stream to write to.
-   * @return If the records were succesfully written.
+   * Get the path for a record class.
+   * @param clazz Class of the record.
+   * @return Path for this record class.
-  private <T extends BaseRecord> boolean writeAllFile(
-      Collection<T> records, BufferedWriter writer) {
-
-    try {
-      for (BaseRecord record : records) {
-        try {
-          String data = serializeString(record);
-          writer.write(data);
-          writer.newLine();
-        } catch (IllegalArgumentException ex) {
-          LOG.error("Cannot write record {} to file", record, ex);
-        }
-      }
-      writer.flush();
-      return true;
-    } catch (IOException e) {
-      LOG.error("Cannot commit records to file", e);
-      return false;
+  private <T extends BaseRecord> String getPathForClass(final Class<T> clazz) {
+    String className = StateStoreUtils.getRecordName(clazz);
+    StringBuilder sb = new StringBuilder();
+    sb.append(getRootDir());
+    if (sb.charAt(sb.length() - 1) != '/') {
+      sb.append("/");
-  }
-
-  /**
-   * Overwrite the existing data with a new data set. Replaces all records in
-   * the data store for this record class. If all records in the data store are
-   * not successfully committed, this function must return false and leave the
-   * data store unchanged.
-   *
-   * @param records List of records to write. All records must be of type
-   *                recordClass.
-   * @param recordClass Class of record to replace.
-   * @return true if all operations were successful, false otherwise.
-   * @throws StateStoreUnavailableException
-   */
-  public <T extends BaseRecord> boolean writeAll(
-      Collection<T> records, Class<T> recordClass)
-          throws StateStoreUnavailableException {
-    verifyDriverReady();
-    lockRecordWrite(recordClass);
-    BufferedWriter writer = null;
-    try {
-      writer = getWriter(recordClass, null);
-      return writeAllFile(records, writer);
-    } catch (Exception e) {
-      LOG.error(
-          "Cannot add records to file for {}", recordClass.getSimpleName(), e);
-      return false;
-    } finally {
-      if (writer != null) {
-        try {
-          writer.close();
-        } catch (IOException e) {
-          LOG.error(
-              "Cannot close writer for {}", recordClass.getSimpleName(), e);
-        }
-      }
-      unlockRecordWrite(recordClass);
-    }
-  }
-
-  /**
-   * Get the data file name.
-   *
-   * @return Data file name.
-   */
-  protected String getDataFileName() {
-    return DATA_FILE_NAME;
+    sb.append(className);
+    return sb.toString();
-
-    @SuppressWarnings("unchecked")
-    Class<T> clazz = (Class<T>) getRecordClass(records.get(0).getClass());
-    QueryResult<T> result;
-    try {
-      result = get(clazz);
-    } catch (IOException e) {
-      return false;
-    }
-    Map<Object, T> writeList = new HashMap<>();
+    long start = monotonicNow();
+    StateStoreMetrics metrics = getMetrics();
-    // Write all of the existing records
-    for (T existingRecord : result.getRecords()) {
-      String key = existingRecord.getPrimaryKey();
-      writeList.put(key, existingRecord);
-    }
+    // Check if any record exists
+    Map<String, T> toWrite = new HashMap<>();
+    for (T record : records) {
+      Class<? extends BaseRecord> recordClass = record.getClass();
+      String path = getPathForClass(recordClass);
+      String primaryKey = getPrimaryKey(record);
+      String recordPath = path + "/" + primaryKey;
-    // Add inserts and updates, overwrite any existing values
-    for (T updatedRecord : records) {
-      try {
-        updatedRecord.validate();
-        String key = updatedRecord.getPrimaryKey();
-        if (writeList.containsKey(key) && allowUpdate) {
-          // Update
-          writeList.put(key, updatedRecord);
+      if (exists(recordPath)) {
+        if (allowUpdate) {
-          updatedRecord.setDateModified(this.getTime());
-        } else if (!writeList.containsKey(key)) {
-          // Insert
-          // Create/Mod timestamps are already initialized
-          writeList.put(key, updatedRecord);
+          record.setDateModified(this.getTime());
+          toWrite.put(recordPath, record);
-              updatedRecord);
+              recordPath);
+          if (metrics != null) {
+            metrics.addFailure(monotonicNow() - start);
+          }
+        } else  {
+          LOG.debug("Not updating {}", record);
-      } catch (IllegalArgumentException ex) {
-        LOG.error("Cannot write invalid record to State Store", ex);
-        return false;
+      } else {
+        toWrite.put(recordPath, record);
-    // Write all
-    boolean status = writeAll(writeList.values(), clazz);
-    return status;
+    // Write the records
+    boolean success = true;
+    for (Entry<String, T> entry : toWrite.entrySet()) {
+      String recordPath = entry.getKey();
+      String recordPathTemp = recordPath + "." + now() + TMP_MARK;
+      BufferedWriter writer = getWriter(recordPathTemp);
+      try {
+        T record = entry.getValue();
+        String line = serializeString(record);
+        writer.write(line);
+      } catch (IOException e) {
+        LOG.error("Cannot write {}", recordPathTemp, e);
+        success = false;
+      } finally {
+        if (writer != null) {
+          try {
+            writer.close();
+          } catch (IOException e) {
+            LOG.error("Cannot close the writer for {}", recordPathTemp);
+          }
+        }
+      }
+      // Commit
+      if (!rename(recordPathTemp, recordPath)) {
+        LOG.error("Failed committing record into {}", recordPath);
+        success = false;
+      }
+    }
+
+    long end = monotonicNow();
+    if (metrics != null) {
+      if (success) {
+        metrics.addWrite(end - start);
+      } else {
+        metrics.addFailure(end - start);
+      }
+    }
+    return success;
+    long start = Time.monotonicNow();
+    StateStoreMetrics metrics = getMetrics();
-      removed = recordsToRemove.size();
-      final List<T> newRecords = new LinkedList<>();
-      for (T record : existingRecords) {
-        if (!recordsToRemove.contains(record)) {
-          newRecords.add(record);
+      boolean success = true;
+      for (T recordToRemove : recordsToRemove) {
+        String path = getPathForClass(clazz);
+        String primaryKey = getPrimaryKey(recordToRemove);
+        String recordToRemovePath = path + "/" + primaryKey;
+        if (remove(recordToRemovePath)) {
+          removed++;
+        } else {
+          LOG.error("Cannot remove record {}", recordToRemovePath);
+          success = false;
-      if (!writeAll(newRecords, clazz)) {
-        throw new IOException(
-            "Cannot remove record " + clazz + " query " + query);
+      if (!success) {
+        LOG.error("Cannot remove records {} query {}", clazz, query);
+        if (metrics != null) {
+          metrics.addFailure(monotonicNow() - start);
+        }
+      if (metrics != null) {
+        metrics.addFailure(monotonicNow() - start);
+      }
+    if (removed > 0 && metrics != null) {
+      metrics.addRemove(monotonicNow() - start);
+    }
-    List<T> emptyList = new ArrayList<>();
-    boolean status = writeAll(emptyList, clazz);
-    return status;
+    long start = Time.monotonicNow();
+    StateStoreMetrics metrics = getMetrics();
+
+    boolean success = true;
+    String path = getPathForClass(clazz);
+    List<String> children = getChildren(path);
+    for (String child : children) {
+      String pathRecord = path + "/" + child;
+      if (!remove(pathRecord)) {
+        success = false;
+      }
+    }
+
+    if (metrics != null) {
+      long time = Time.monotonicNow() - start;
+      if (success) {
+        metrics.addRemove(time);
+      } else {
+        metrics.addFailure(time);
+      }
+    }
+    return success;

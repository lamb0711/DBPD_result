HDDS-1586. Allow Ozone RPC client to read with topology awareness. Contributed by Sammi Chen.

+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.Iterator;
+  private static final Logger LOG = LoggerFactory
+      .getLogger(Pipeline.class);
+  // nodes with ordered distance to client
+  private ThreadLocal<List<DatanodeDetails>> nodesInOrder = new ThreadLocal<>();
+  public DatanodeDetails getClosestNode() throws IOException {
+    if (nodesInOrder.get() == null || nodesInOrder.get().isEmpty()) {
+      LOG.debug("Nodes in order is empty, delegate to getFirstNode");
+      return getFirstNode();
+    }
+    return nodesInOrder.get().get(0);
+  }
+
+  public void setNodesInOrder(List<DatanodeDetails> nodes) {
+    nodesInOrder.set(nodes);
+  }
+
+  public List<DatanodeDetails> getNodesInOrder() {
+    if (nodesInOrder.get() == null || nodesInOrder.get().isEmpty()) {
+      LOG.debug("Nodes in order is empty, delegate to getNodes");
+      return getNodes();
+    }
+    return nodesInOrder.get();
+  }
+
+    // To save the message size on wire, only transfer the node order based on
+    // network topology
+    List<DatanodeDetails> nodes = nodesInOrder.get();
+    if (nodes != null && !nodes.isEmpty()) {
+      for (int i = 0; i < nodes.size(); i++) {
+        Iterator<DatanodeDetails> it = nodeStatus.keySet().iterator();
+        for (int j = 0; j < nodeStatus.keySet().size(); j++) {
+          if (it.next().equals(nodes.get(i))) {
+            builder.addMemberOrders(j);
+            break;
+          }
+        }
+      }
+      LOG.info("Serialize pipeline {} with nodesInOrder{ }", id.toString(),
+          nodes);
+    }
+        .setNodesInOrder(pipeline.getMemberOrdersList())
-
+    private List<Integer> nodeOrder = null;
+    private List<DatanodeDetails> nodesInOrder = null;
+      this.nodesInOrder = pipeline.nodesInOrder.get();
+    public Builder setNodesInOrder(List<Integer> orders) {
+      this.nodeOrder = orders;
+      return this;
+    }
+
-      return new Pipeline(id, type, factor, state, nodeStatus);
+      Pipeline pipeline = new Pipeline(id, type, factor, state, nodeStatus);
+
+      if (nodeOrder != null && !nodeOrder.isEmpty()) {
+        // This branch is for build from ProtoBuf
+        List<DatanodeDetails> nodesWithOrder = new ArrayList<>();
+        for(int i = 0; i < nodeOrder.size(); i++) {
+          int nodeIndex = nodeOrder.get(i);
+          Iterator<DatanodeDetails> it = nodeStatus.keySet().iterator();
+          while(it.hasNext() && nodeIndex >= 0) {
+            DatanodeDetails node = it.next();
+            if (nodeIndex == 0) {
+              nodesWithOrder.add(node);
+              break;
+            }
+            nodeIndex--;
+          }
+        }
+        LOG.info("Deserialize nodesInOrder {} in pipeline {}", nodesWithOrder,
+            id.toString());
+        pipeline.setNodesInOrder(nodesWithOrder);
+      } else if (nodesInOrder != null){
+        // This branch is for pipeline clone
+        pipeline.setNodesInOrder(nodesInOrder);
+      }
+      return pipeline;

YARN-5301. NM mount cpu cgroups failed on some systems
(Contributed by Miklos Szegedi via Daniel Templeton)

+import com.google.common.base.Joiner;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.util.Shell;
-import java.util.List;
+import java.util.HashSet;
+import java.util.Set;
+  private Map<String, Set<String>> parsedMtab;
+    this.parsedMtab = new HashMap<>();
-    if (enableCGroupMount) {
-      // nothing to do here - we support 'deferred' mounting of specific
-      // controllers - we'll populate the path for a given controller when an
-      // explicit mountCGroupController request is issued.
-      LOG.info("CGroup controller mounting enabled.");
-    } else {
-      // cluster admins are expected to have mounted controllers in specific
-      // locations - we'll attempt to figure out mount points
+    // Cluster admins may have some subsystems mounted in specific locations
+    // We'll attempt to figure out mount points. We do this even if we plan
+    // to mount cgroups into our own tree to control the path permissions or
+    // to mount subsystems that are not mounted previously.
+    // The subsystems for new and existing mount points have to match, and
+    // the same hierarchy will be mounted at each mount point with the same
+    // subsystem set.
-      Map<CGroupController, String> cPaths =
-          initializeControllerPathsFromMtab(mtabFile, this.cGroupPrefix);
-      // we want to do a bulk update without the paths changing concurrently
-      try {
-        rwLock.writeLock().lock();
-        controllerPaths = cPaths;
-      } finally {
-        rwLock.writeLock().unlock();
-      }
+    Map<String, Set<String>> newMtab;
+    Map<CGroupController, String> cPaths;
+    try {
+      // parse mtab
+      newMtab = parseMtab(mtabFile);
+
+      // find cgroup controller paths
+      cPaths = initializeControllerPathsFromMtab(newMtab);
+    } catch (IOException e) {
+      LOG.warn("Failed to initialize controller paths! Exception: " + e);
+      throw new ResourceHandlerException(
+          "Failed to initialize controller paths!");
+    }
+
+    // we want to do a bulk update without the paths changing concurrently
+    try {
+      rwLock.writeLock().lock();
+      controllerPaths = cPaths;
+      parsedMtab = newMtab;
+    } finally {
+      rwLock.writeLock().unlock();
-      String mtab, String cGroupPrefix) throws ResourceHandlerException {
-    try {
-      Map<String, List<String>> parsedMtab = parseMtab(mtab);
-      Map<CGroupController, String> ret = new HashMap<>();
+      Map<String, Set<String>> parsedMtab)
+      throws ResourceHandlerException {
+    Map<CGroupController, String> ret = new HashMap<>();
-      for (CGroupController controller : CGroupController.values()) {
-        String subsystemName = controller.getName();
-        String controllerPath = findControllerInMtab(subsystemName, parsedMtab);
+    for (CGroupController controller : CGroupController.values()) {
+      String subsystemName = controller.getName();
+      String controllerPath = findControllerInMtab(subsystemName, parsedMtab);
-        if (controllerPath != null) {
-          ret.put(controller, controllerPath);
-        } else {
-          LOG.warn("Controller not mounted but automount disabled: " +
-              subsystemName);
-        }
+      if (controllerPath != null) {
+        ret.put(controller, controllerPath);
-      return ret;
-    } catch (IOException e) {
-      LOG.warn("Failed to initialize controller paths! Exception: " + e);
-      throw new ResourceHandlerException(
-        "Failed to initialize controller paths!");
+    return ret;
-  private static Map<String, List<String>> parseMtab(String mtab)
+  @VisibleForTesting
+  static Map<String, Set<String>> parseMtab(String mtab)
-    Map<String, List<String>> ret = new HashMap<String, List<String>>();
+    Map<String, Set<String>> ret = new HashMap<>();
+    HashSet<String> validCgroups = new HashSet<>();
+    for (CGroupController controller : CGroupController.values()) {
+      validCgroups.add(controller.getName());
+    }
-            List<String> value = Arrays.asList(options.split(","));
-            ret.put(path, value);
+            Set<String> cgroupList =
+                new HashSet<>(Arrays.asList(options.split(",")));
+            // Collect the valid subsystem names
+            cgroupList.retainAll(validCgroups);
+            ret.put(path, cgroupList);
-      throw new IOException("Error while reading " + mtab, e);
+      if (Shell.LINUX) {
+        throw new IOException("Error while reading " + mtab, e);
+      } else {
+        // Ignore the error, if we are running on an os other than Linux
+        LOG.warn("Error while reading " + mtab, e);
+      }
-      Map<String, List<String>> entries) {
-    for (Map.Entry<String, List<String>> e : entries.entrySet()) {
+      Map<String, Set<String>> entries) {
+    for (Map.Entry<String, Set<String>> e : entries.entrySet()) {
-    String path = getControllerPath(controller);
+    if (cGroupMountPath == null) {
+      throw new ResourceHandlerException(
+          String.format("Cgroups mount path not specified in %s.",
+              YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_MOUNT_PATH));
+    }
+    String existingMountPath = getControllerPath(controller);
+    String requestedMountPath =
+        new File(cGroupMountPath, controller.getName()).getAbsolutePath();
-    if (path == null) {
+    if (existingMountPath == null ||
+        !requestedMountPath.equals(existingMountPath)) {
-        String hierarchy = cGroupPrefix;
-        StringBuffer controllerPath = new StringBuffer()
-            .append(cGroupMountPath).append('/').append(controller.getName());
-        StringBuffer cGroupKV = new StringBuffer()
-            .append(controller.getName()).append('=').append(controllerPath);
+        // If the controller was already mounted we have to mount it
+        // with the same options to clone the mount point otherwise
+        // the operation will fail
+        String mountOptions;
+        if (existingMountPath != null) {
+          mountOptions = Joiner.on(',')
+              .join(parsedMtab.get(existingMountPath));
+        } else {
+          mountOptions = controller.getName();
+        }
+
+        String cGroupKV =
+            mountOptions + "=" + requestedMountPath;
-        op.appendArgs(hierarchy, cGroupKV.toString());
+        op.appendArgs(cGroupPrefix, cGroupKV);
-              controllerPath);
+              requestedMountPath);
-        controllerPaths.put(controller, controllerPath.toString());
-
-        return;
+        controllerPaths.put(controller, requestedMountPath);
-      LOG.info("CGroup controller already mounted at: " + path);
-      return;
+      LOG.info("CGroup controller already mounted at: " + existingMountPath);
-    return new StringBuffer(cGroupPrefix).append("/")
-        .append(cGroupId).toString();
+    return cGroupPrefix + Path.SEPARATOR + cGroupId;
-    return new StringBuffer(getControllerPath(controller))
-        .append('/').append(cGroupPrefix).append("/")
-        .append(cGroupId).toString();
+    return getControllerPath(controller) + Path.SEPARATOR + cGroupPrefix
+        + Path.SEPARATOR + cGroupId;
-    return new StringBuffer(getPathForCGroup(controller, cGroupId))
-        .append('/').append(CGROUP_FILE_TASKS).toString();
+    return getPathForCGroup(controller, cGroupId)
+        + Path.SEPARATOR + CGROUP_FILE_TASKS;
-    return new StringBuffer(getPathForCGroup(controller, cGroupId))
-        .append('/').append(controller.getName()).append('.')
-        .append(param).toString();
+    return getPathForCGroup(controller, cGroupId)
+        + Path.SEPARATOR + controller.getName()
+        + "." + param;
-      // We are working with a pre-mounted contoller
-      // Make sure that Yarn cgroup hierarchy path exists
-      initializePreMountedCGroupController(controller);
+      String controllerPath = getControllerPath(controller);
+
+      if (controllerPath == null) {
+        throw new ResourceHandlerException(
+            String.format("Controller %s not mounted."
+                + " You either need to mount it with %s"
+                + " or mount cgroups before launching Yarn",
+                controller.getName(), YarnConfiguration.
+                NM_LINUX_CONTAINER_CGROUPS_MOUNT));
+      }
+
+    // We are working with a pre-mounted contoller
+    // Make sure that Yarn cgroup hierarchy path exists
+    initializePreMountedCGroupController(controller);
-  public void initializePreMountedCGroupController(CGroupController controller)
+  private void initializePreMountedCGroupController(CGroupController controller)
-    File rootHierarchy = new File(getControllerPath(controller));
+    String controllerPath = getControllerPath(controller);
+
+    if (controllerPath == null) {
+      throw new ResourceHandlerException(
+          String.format("Controller %s not mounted."
+                  + " You either need to mount it with %s"
+                  + " or mount cgroups before launching Yarn",
+              controller.getName(), YarnConfiguration.
+                  NM_LINUX_CONTAINER_CGROUPS_MOUNT));
+    }
+
+    File rootHierarchy = new File(controllerPath);
-    return new StringBuilder()
-        .append(errorMessage)
-        .append(" Subsystem:")
-        .append(subsystemName)
-        .append(" Mount points:")
-        .append(mtabFile)
-        .append(" User:")
-        .append(System.getProperty("user.name"))
-        .append(" Path: ")
-        .append(yarnCgroupPath)
-        .toString();
+    return String.format("%s Subsystem:%s Mount points:%s User:%s Path:%s ",
+        errorMessage, subsystemName, mtabFile, System.getProperty("user.name"),
+        yarnCgroupPath);
-  boolean checkAndDeleteCgroup(File cgf) throws InterruptedException {
+  private boolean checkAndDeleteCgroup(File cgf) throws InterruptedException {
-      LOG.warn("Unable to delete  " + cGroupPath +
-          ", tried to delete for " + deleteCGroupTimeout + "ms");
+      LOG.warn(String.format("Unable to delete  %s, tried to delete for %d ms",
+          cGroupPath, deleteCGroupTimeout));
-          "updateCGroupParam for path: " + cGroupParamPath + " with value " +
-              value);
+          String.format("updateCGroupParam for path: %s with value %s",
+              cGroupParamPath, value));
-      throw new ResourceHandlerException(new StringBuffer("Unable to write to ")
-          .append(cGroupParamPath).append(" with value: ").append(value)
-          .toString(), e);
+      throw new ResourceHandlerException(
+          String.format("Unable to write to %s with value: %s",
+              cGroupParamPath, value), e);
-              new StringBuffer("Unable to write to ")
-                  .append(cGroupParamPath).append(" with value: ").append(value)
-                  .toString());
+              String.format("PrintWriter unable to write to %s with value: %s",
+                  cGroupParamPath, value));
-          throw new ResourceHandlerException("Error while closing cgroup file" +
-              " " + cGroupParamPath);
+          throw new ResourceHandlerException(
+              String.format("Error while closing cgroup file %s",
+                  cGroupParamPath));

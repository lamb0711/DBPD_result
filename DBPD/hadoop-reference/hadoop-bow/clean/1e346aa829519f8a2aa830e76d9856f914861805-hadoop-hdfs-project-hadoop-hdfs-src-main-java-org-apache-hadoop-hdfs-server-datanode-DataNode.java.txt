HDFS-1971. Send block report from datanode to both active and standby namenodes. (sanjay, todd via suresh)


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208925 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collections;
-    private final Map<InetSocketAddress, BPOfferService> nameNodeThreads;
+    private final List<BPOfferService> offerServices;
-      nameNodeThreads = new HashMap<InetSocketAddress, BPOfferService>();
+      offerServices = new ArrayList<BPOfferService>();
-        // TODO(HA) when HDFS-1971 (dual BRs) is done, pass all of the NNs
-        // to BPOS
-        InetSocketAddress isa = nnList.get(0);
-        BPOfferService bpos = new BPOfferService(isa, DataNode.this);
-        nameNodeThreads.put(bpos.getNNSocketAddress(), bpos);
+        BPOfferService bpos = new BPOfferService(nnList, DataNode.this);
+        offerServices.add(bpos);
-    synchronized void addBlockPool(BPOfferService t) {
-      if (nameNodeThreads.get(t.getNNSocketAddress()) == null) {
-        throw new IllegalArgumentException(
-            "Unknown BPOfferService thread for namenode address:"
-                + t.getNNSocketAddress());
-      }
-      if (t.getBlockPoolId() == null) {
+    synchronized void addBlockPool(BPOfferService bpos) {
+      Preconditions.checkArgument(offerServices.contains(bpos),
+          "Unknown BPOS: %s", bpos);
+      if (bpos.getBlockPoolId() == null) {
-      bpMapping.put(t.getBlockPoolId(), t);
+      LOG.info("===> registering in bpmapping: " + bpos);
+      bpMapping.put(bpos.getBlockPoolId(), bpos);
-      BPOfferService[] bposArray = new BPOfferService[nameNodeThreads.values()
-          .size()];
-      return nameNodeThreads.values().toArray(bposArray);
+      BPOfferService[] bposArray = new BPOfferService[offerServices.size()];
+      return offerServices.toArray(bposArray);
-    
-    synchronized BPOfferService get(InetSocketAddress addr) {
-      return nameNodeThreads.get(addr);
-    }
-    
+        
+    // TODO(HA) would be good to kill this
+    synchronized BPOfferService get(InetSocketAddress addr) {
+      for (BPOfferService bpos : offerServices) {
+        if (bpos.containsNN(addr)) {
+          return bpos;
+        }
+      }
+      return null;
+    }
+
-      nameNodeThreads.remove(t.getNNSocketAddress());
+      offerServices.remove(t);
-                for (BPOfferService bpos : nameNodeThreads.values()) {
+                for (BPOfferService bpos : offerServices) {
+      throw new UnsupportedOperationException("TODO(HA)");
+/*
+ * TODO(HA)
+
-          for (InetSocketAddress nnaddr : nameNodeThreads.keySet()) {
+          for (InetSocketAddress nnaddr : offerServices.keySet()) {
-              toShutdown.add(nameNodeThreads.get(nnaddr));
+              toShutdown.add(offerServices.get(nnaddr));
-            if (!(nameNodeThreads.containsKey(nnaddr))) {
+            if (!(offerServices.containsKey(nnaddr))) {
-            nameNodeThreads.put(bpos.getNNSocketAddress(), bpos);
+            offerServices.put(bpos.getNNSocketAddress(), bpos);
+      */
+
+  /**
+   * Report a bad block which is hosted on the local DN.
+   */
-    BPOfferService bpos = blockPoolManager.get(block.getBlockPoolId());
-    if(bpos == null || bpos.bpNamenode == null) {
-      throw new IOException("cannot locate OfferService thread for bp="+block.getBlockPoolId());
-    }
+    BPOfferService bpos = getBPOSForBlock(block);
+
+  /**
+   * Report a bad block on another DN (eg if we received a corrupt replica
+   * from a remote host).
+   * @param srcDataNode the DN hosting the bad block
+   * @param block the block itself
+   */
+  public void reportRemoteBadBlock(DatanodeInfo srcDataNode, ExtendedBlock block)
+      throws IOException {
+    BPOfferService bpos = getBPOSForBlock(block);
+    bpos.reportRemoteBadBlock(srcDataNode, block);
+  }
+  
+  /**
+   * Return the BPOfferService instance corresponding to the given block.
+   * @param block
+   * @return the BPOS
+   * @throws IOException if no such BPOS can be found
+   */
+  private BPOfferService getBPOSForBlock(ExtendedBlock block)
+      throws IOException {
+    Preconditions.checkNotNull(block);
+    BPOfferService bpos = blockPoolManager.get(block.getBlockPoolId());
+    if (bpos == null) {
+      throw new IOException("cannot locate OfferService thread for bp="+
+          block.getBlockPoolId());
+    }
+    return bpos;
+  }
+
+
-   * @param mName
+   * @param mName - the name that the NN used
+    // TODO: all the BPs should have the same name as each other, they all come
+    // from getName() here! and the use cases only are in tests where they just
+    // call with getName(). So we could probably just make this method return
+    // the first BPOS's registration
+    // TODO(HA) this function doesn't make sense! used by upgrade code
+    // Should it return just the active one or simply return the BPService.
-      DatanodeProtocol nn = bpos.bpNamenode;
-      try {
-        nn.errorReport(bpos.bpRegistration, dpError, errMsgr);
-      } catch(IOException e) {
-        LOG.warn("Error reporting disk failure to NameNode", e);
-      }
+      bpos.trySendErrorReport(dpError, errMsgr);
+  
+  int getXmitsInProgress() {
+    return xmitsInProgress.get();
+  }
-    DatanodeProtocol nn = getBPNamenode(block.getBlockPoolId());
+    BPOfferService bpos = getBPOSForBlock(block);
-      nn.errorReport(bpReg, DatanodeProtocol.INVALID_BLOCK, errStr);
+      
+      bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK, errStr);
-      nn.reportBadBlocks(new LocatedBlock[]{
-          new LocatedBlock(block, new DatanodeInfo[] {
-              new DatanodeInfo(bpReg)})});
+      bpos.reportBadBlocks(block);
-    if(bpos == null || bpos.bpNamenode == null) {
+    if (bpos == null) {
-    return bpos.bpNamenode;
+    return bpos.getActiveNN();
+      // TODO: how does this work in HA??
-      if (bpos != null && bpos.bpThread != null) {
+      if (bpos != null) {

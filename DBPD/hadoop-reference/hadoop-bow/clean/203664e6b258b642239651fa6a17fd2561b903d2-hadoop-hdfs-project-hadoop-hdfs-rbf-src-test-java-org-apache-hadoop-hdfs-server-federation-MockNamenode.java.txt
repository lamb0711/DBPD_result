HDFS-14454. RBF: getContentSummary() should allow non-existing folders. Contributed by Inigo Goiri.

+import static java.util.Collections.emptySet;
+import static java.util.Collections.singletonList;
+import java.util.Collection;
+import java.util.Set;
+import java.util.Map.Entry;
+import org.apache.hadoop.fs.ContentSummary;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hdfs.server.federation.resolver.MembershipNamenodeResolver;
+import org.apache.hadoop.hdfs.server.federation.resolver.NamenodeStatusReport;
+import org.apache.hadoop.hdfs.server.federation.router.Router;
+      if (fs.get(src) == null) {
+        throw new FileNotFoundException("File does not exist " + src);
+      }
+      boolean createParent = (boolean)invocation.getArgument(4);
+      if (createParent) {
+        Path path = new Path(src).getParent();
+        while (!path.isRoot()) {
+          LOG.info("{} create parent {}", nsId, path);
+          fs.put(path.toString(), "DIRECTORY");
+          path = path.getParent();
+        }
+      }
+      boolean createParent = (boolean)invocation.getArgument(2);
+      if (createParent) {
+        Path path = new Path(src).getParent();
+        while (!path.isRoot()) {
+          LOG.info("{} mkdir parent {}", nsId, path);
+          fs.put(path.toString(), "DIRECTORY");
+          path = path.getParent();
+        }
+      }
+    when(mockNn.getContentSummary(anyString())).thenAnswer(invocation -> {
+      String src = getSrc(invocation);
+      LOG.info("{} getContentSummary({})", nsId, src);
+      if (fs.get(src) == null) {
+        throw new FileNotFoundException("File does not exist " + src);
+      }
+      if (!src.endsWith("/")) {
+        src += "/";
+      }
+      Map<String, String> files =
+          fs.subMap(src, src + Character.MAX_VALUE);
+      int numFiles = 0;
+      int numDirs = 0;
+      int length = 0;
+      for (Entry<String, String> entry : files.entrySet()) {
+        String file = entry.getKey();
+        if (file.substring(src.length()).indexOf('/') < 0) {
+          String type = entry.getValue();
+          if ("DIRECTORY".equals(type)) {
+            numDirs++;
+          } else if ("FILE".equals(type)) {
+            numFiles++;
+            length += 100;
+          }
+        }
+      }
+      return new ContentSummary.Builder()
+          .fileCount(numFiles)
+          .directoryCount(numDirs)
+          .length(length)
+          .erasureCodingPolicy("")
+          .build();
+    });
+
+  /**
+   * Register a set of NameNodes in a Router.
+   * @param router Router to register to.
+   * @param namenodes Set of NameNodes.
+   * @throws IOException If it cannot register them.
+   */
+  public static void registerSubclusters(Router router,
+      Collection<MockNamenode> namenodes) throws IOException {
+    registerSubclusters(singletonList(router), namenodes, emptySet());
+  }
+
+  /**
+   * Register a set of NameNodes in a set of Routers.
+   * @param routers Set of Routers.
+   * @param namenodes Set of NameNodes.
+   * @param unavailableSubclusters Set of unavailable subclusters.
+   * @throws IOException If it cannot register them.
+   */
+  public static void registerSubclusters(List<Router> routers,
+      Collection<MockNamenode> namenodes,
+      Set<String> unavailableSubclusters) throws IOException {
+
+    for (final Router router : routers) {
+      MembershipNamenodeResolver resolver =
+          (MembershipNamenodeResolver) router.getNamenodeResolver();
+      for (final MockNamenode nn : namenodes) {
+        String nsId = nn.getNameserviceId();
+        String rpcAddress = "localhost:" + nn.getRPCPort();
+        String httpAddress = "localhost:" + nn.getHTTPPort();
+        NamenodeStatusReport report = new NamenodeStatusReport(
+            nsId, null, rpcAddress, rpcAddress, rpcAddress, httpAddress);
+        if (unavailableSubclusters.contains(nsId)) {
+          LOG.info("Register {} as UNAVAILABLE", nsId);
+          report.setRegistrationValid(false);
+        } else {
+          LOG.info("Register {} as ACTIVE", nsId);
+          report.setRegistrationValid(true);
+        }
+        report.setNamespaceInfo(new NamespaceInfo(0, nsId, nsId, 0));
+        resolver.registerNamenode(report);
+      }
+      resolver.loadCache(true);
+    }
+  }

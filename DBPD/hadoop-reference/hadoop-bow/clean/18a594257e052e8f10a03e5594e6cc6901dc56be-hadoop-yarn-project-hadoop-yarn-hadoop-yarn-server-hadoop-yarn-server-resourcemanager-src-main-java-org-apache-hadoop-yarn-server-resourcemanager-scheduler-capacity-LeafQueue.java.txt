YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan

-    this.activeUsersManager = new ActiveUsersManager(metrics);
-    this.minimumAllocationFactor = 
-        Resources.ratio(resourceCalculator, 
-            Resources.subtract(maximumAllocation, minimumAllocation), 
-            maximumAllocation);
-
-    float capacity = getCapacityFromConf();
-    float absoluteCapacity = parent.getAbsoluteCapacity() * capacity;
-
-    float maximumCapacity = 
-        (float)cs.getConfiguration().getMaximumCapacity(getQueuePath()) / 100;
-    float absoluteMaxCapacity = 
-        CSQueueUtils.computeAbsoluteMaximumCapacity(maximumCapacity, parent);
-
-    int userLimit = cs.getConfiguration().getUserLimit(getQueuePath());
-    float userLimitFactor = 
-      cs.getConfiguration().getUserLimitFactor(getQueuePath());
-
-    int maxApplications =
-        cs.getConfiguration().getMaximumApplicationsPerQueue(getQueuePath());
-    if (maxApplications < 0) {
-      int maxSystemApps = cs.getConfiguration().getMaximumSystemApplications();
-      maxApplications = (int)(maxSystemApps * absoluteCapacity);
-    }
-    maxApplicationsPerUser = 
-      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);
-
-    float maxAMResourcePerQueuePercent = cs.getConfiguration()
-        .getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());
-
-    QueueState state = cs.getConfiguration().getState(getQueuePath());
-
-    Map<AccessType, AccessControlList> acls = 
-      cs.getConfiguration().getAcls(getQueuePath());
-
-    setupQueueConfigs(cs.getClusterResource(), capacity, absoluteCapacity,
-        maximumCapacity, absoluteMaxCapacity, userLimit, userLimitFactor,
-        maxApplications, maxAMResourcePerQueuePercent, maxApplicationsPerUser,
-        state, acls, cs.getConfiguration().getNodeLocalityDelay(), accessibleLabels,
-        defaultLabelExpression, this.capacitiyByNodeLabels,
-        this.maxCapacityByNodeLabels,
-        cs.getConfiguration().getReservationContinueLook(),
-        cs.getConfiguration().getMaximumAllocationPerQueue(getQueuePath()));
+    this.activeUsersManager = new ActiveUsersManager(metrics); 
-  }
-  
-  // externalizing in method, to allow overriding
-  protected float getCapacityFromConf() {
-    return (float)scheduler.getConfiguration().getCapacity(getQueuePath()) / 100;
+    
+    setupQueueConfigs(cs.getClusterResource());
-  protected synchronized void setupQueueConfigs(
-      Resource clusterResource,
-      float capacity, float absoluteCapacity, 
-      float maximumCapacity, float absoluteMaxCapacity,
-      int userLimit, float userLimitFactor,
-      int maxApplications, float maxAMResourcePerQueuePercent,
-      int maxApplicationsPerUser, QueueState state,
-      Map<AccessType, AccessControlList> acls, int nodeLocalityDelay,
-      Set<String> labels, String defaultLabelExpression,
-      Map<String, Float> capacitieByLabel,
-      Map<String, Float> maximumCapacitiesByLabel, 
-      boolean revervationContinueLooking,
-      Resource maxAllocation) throws IOException {
-    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,
-        maximumCapacity, absoluteMaxCapacity, state, acls, labels,
-        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,
-        revervationContinueLooking, maxAllocation);
-    // Sanity check
-    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);
-    float absCapacity = getParent().getAbsoluteCapacity() * capacity;
-    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,
-        absoluteMaxCapacity);
+  protected synchronized void setupQueueConfigs(Resource clusterResource)
+      throws IOException {
+    super.setupQueueConfigs(clusterResource);
-    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);
+    updateHeadroomInfo(clusterResource,
+        queueCapacities.getAbsoluteMaximumCapacity());
-    this.absoluteCapacity = absCapacity;
+    CapacitySchedulerConfiguration conf = csContext.getConfiguration();
+    userLimit = conf.getUserLimit(getQueuePath());
+    userLimitFactor = conf.getUserLimitFactor(getQueuePath());
-    this.userLimit = userLimit;
-    this.userLimitFactor = userLimitFactor;
-
-    this.maxApplications = maxApplications;
-    this.maxAMResourcePerQueuePercent = maxAMResourcePerQueuePercent;
-    this.maxApplicationsPerUser = maxApplicationsPerUser;
+    maxApplications = conf.getMaximumApplicationsPerQueue(getQueuePath());
+    if (maxApplications < 0) {
+      int maxSystemApps = conf.getMaximumSystemApplications();
+      maxApplications =
+          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());
+    }
+    maxApplicationsPerUser = 
+      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);
+    
+    maxAMResourcePerQueuePercent =
+        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());
-    this.nodeLocalityDelay = nodeLocalityDelay;
+    nodeLocalityDelay = conf.getNodeLocalityDelay();
-    if (labels != null) {
-      for (String s : labels) {
+    if (accessibleLabels != null) {
+      for (String s : accessibleLabels) {
-        "capacity = " + capacity +
+        "capacity = " + queueCapacities.getCapacity() +
-        "asboluteCapacity = " + absoluteCapacity +
+        "asboluteCapacity = " + queueCapacities.getAbsoluteCapacity() +
-        "maxCapacity = " + maximumCapacity +
+        "maxCapacity = " + queueCapacities.getMaximumCapacity() +
-        "absoluteMaxCapacity = " + absoluteMaxCapacity +
+        "absoluteMaxCapacity = " + queueCapacities.getAbsoluteMaximumCapacity() +
-        "usedCapacity = " + usedCapacity +
+        "usedCapacity = " + queueCapacities.getUsedCapacity() +
-        "capacity=" + capacity + ", " + 
-        "absoluteCapacity=" + absoluteCapacity + ", " + 
+        "capacity=" + queueCapacities.getCapacity() + ", " + 
+        "absoluteCapacity=" + queueCapacities.getAbsoluteCapacity() + ", " + 
-    setupQueueConfigs(
-        clusterResource,
-        newlyParsedLeafQueue.capacity, newlyParsedLeafQueue.absoluteCapacity, 
-        newlyParsedLeafQueue.maximumCapacity, 
-        newlyParsedLeafQueue.absoluteMaxCapacity, 
-        newlyParsedLeafQueue.userLimit, newlyParsedLeafQueue.userLimitFactor, 
-        newlyParsedLeafQueue.maxApplications,
-        newlyParsedLeafQueue.maxAMResourcePerQueuePercent,
-        newlyParsedLeafQueue.getMaxApplicationsPerUser(),
-        newlyParsedLeafQueue.state, newlyParsedLeafQueue.acls,
-        newlyParsedLeafQueue.getNodeLocalityDelay(),
-        newlyParsedLeafQueue.accessibleLabels,
-        newlyParsedLeafQueue.defaultLabelExpression,
-        newlyParsedLeafQueue.capacitiyByNodeLabels,
-        newlyParsedLeafQueue.maxCapacityByNodeLabels,
-        newlyParsedLeafQueue.reservationsContinueLooking,
-        newlyParsedLeafQueue.getMaximumAllocation());
+    setupQueueConfigs(clusterResource);
-        if (potentialNewWithoutReservedCapacity <= absoluteMaxCapacity) {
+        if (potentialNewWithoutReservedCapacity <= queueCapacities
+            .getAbsoluteMaximumCapacity()) {
-                + potentialNewWithoutReservedCapacity + " ( " + " max-capacity: "
-                + absoluteMaxCapacity + ")");
+                + potentialNewWithoutReservedCapacity + " ( "
+                + " max-capacity: "
+                + queueCapacities.getAbsoluteMaximumCapacity() + ")");
-      if (potentialNewCapacity > getAbsoluteMaximumCapacityByNodeLabel(label) + 1e-4) {
+      if (potentialNewCapacity > queueCapacities
+          .getAbsoluteMaximumCapacity(label) + 1e-4) {
-            + " max-capacity: " + absoluteMaxCapacity + ")");
+            + " max-capacity: " + queueCapacities.getAbsoluteMaximumCapacity()
+            + ")");
-                      getAbsoluteCapacityByNodeLabel(firstLabel),
+                      queueCapacities.getAbsoluteCapacity(firstLabel),
-              absoluteCapacity, minimumAllocation);
+              queueCapacities.getAbsoluteCapacity(), minimumAllocation);
-    
-       absoluteCapacityResource = Resources.multiplyAndNormalizeUp( 
-          resourceCalculator,
-          clusterResource, 
-          absoluteCapacity, minimumAllocation);
-       
+    absoluteCapacityResource =
+        Resources.multiplyAndNormalizeUp(resourceCalculator, clusterResource,
+            queueCapacities.getAbsoluteCapacity(), minimumAllocation);
-    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);
+    updateHeadroomInfo(clusterResource,
+        queueCapacities.getAbsoluteMaximumCapacity());
-
-  @Override
-  public float getAbsActualCapacity() {
-    //? Is this actually used by anything at present?
-    //  There is a findbugs warning -re lastClusterResource (now excluded),
-    //  when this is used, verify that the access is mt correct and remove
-    //  the findbugs exclusion if possible
-    if (Resources.lessThanOrEqual(resourceCalculator, lastClusterResource,
-        lastClusterResource, Resources.none())) {
-      return absoluteCapacity;
-    }
-
-    Resource resourceRespectLabels =
-        labelManager == null ? lastClusterResource : labelManager
-            .getQueueResource(queueName, accessibleLabels, lastClusterResource);
-    float absActualCapacity =
-        Resources.divide(resourceCalculator, lastClusterResource,
-            resourceRespectLabels, lastClusterResource);
-    
-    return absActualCapacity > absoluteCapacity ? absoluteCapacity
-        : absActualCapacity;
-  }
-    this.capacity = capacity;
+    queueCapacities.setCapacity(capacity);
-    this.absoluteCapacity = absoluteCapacity;
+    queueCapacities.setAbsoluteCapacity(absoluteCapacity);

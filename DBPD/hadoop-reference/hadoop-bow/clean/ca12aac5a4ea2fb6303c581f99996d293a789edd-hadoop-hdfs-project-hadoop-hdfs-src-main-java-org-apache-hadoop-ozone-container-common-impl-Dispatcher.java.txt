HDFS-11126. Ozone: Add small file support RPC. Contributed by Anu Engineer.

+import com.google.protobuf.ByteString;
+import org.apache.hadoop.ozone.container.common.helpers.FileUtils;
-import org.apache.hadoop.scm.container.common.helpers.Pipeline;
+import org.apache.hadoop.scm.container.common.helpers.Pipeline;
+import java.util.LinkedList;
+import java.util.List;
-
+    if ((cmdType == Type.PutSmallFile) ||
+        (cmdType == Type.GetSmallFile)) {
+      return smallFileHandler(msg);
+    }
+
+  private ContainerCommandResponseProto smallFileHandler(
+      ContainerCommandRequestProto msg) throws IOException {
+    switch (msg.getCmdType()) {
+    case PutSmallFile:
+      return handlePutSmallFile(msg);
+    case GetSmallFile:
+      return handleGetSmallFile(msg);
+    default:
+      return ContainerUtils.unsupportedRequest(msg);
+    }
+  }
+
-    if(!msg.hasPutKey()){
+    if (!msg.hasPutKey()) {
-    if(!msg.hasGetKey()){
+    if (!msg.hasGetKey()) {
-    if(!msg.hasDeleteKey()){
+    if (!msg.hasDeleteKey()) {
+  /**
+   * Handles writing a chunk and associated key using single RPC.
+   *
+   * @param msg - Message.
+   * @return ContainerCommandResponseProto
+   * @throws IOException
+   */
+  private ContainerCommandResponseProto handlePutSmallFile(
+      ContainerCommandRequestProto msg) throws IOException {
+
+    if (!msg.hasPutSmallFile()) {
+      LOG.debug("Malformed put small file request. trace ID: {}",
+          msg.getTraceID());
+      return ContainerUtils.malformedRequest(msg);
+    }
+
+    Pipeline pipeline =
+        Pipeline.getFromProtoBuf(msg.getPutSmallFile().getKey().getPipeline());
+    Preconditions.checkNotNull(pipeline);
+    KeyData keyData = KeyData.getFromProtoBuf(msg.getPutSmallFile().getKey()
+        .getKeyData());
+    ChunkInfo chunkInfo = ChunkInfo.getFromProtoBuf(msg.getPutSmallFile()
+        .getChunkInfo());
+    byte[] data = msg.getPutSmallFile().getData().toByteArray();
+
+    this.containerManager.getChunkManager().writeChunk(pipeline, keyData
+        .getKeyName(), chunkInfo, data);
+    List<ContainerProtos.ChunkInfo> chunks = new LinkedList<>();
+    chunks.add(chunkInfo.getProtoBufMessage());
+    keyData.setChunks(chunks);
+    this.containerManager.getKeyManager().putKey(pipeline, keyData);
+    return FileUtils.getPutFileResponse(msg);
+  }
+
+  /**
+   * Handles getting a data stream using a key. This helps in reducing the RPC
+   * overhead for small files.
+   *
+   * @param msg - ContainerCommandRequestProto
+   * @return ContainerCommandResponseProto
+   */
+  private ContainerCommandResponseProto handleGetSmallFile(
+      ContainerCommandRequestProto msg) throws IOException {
+    ByteString dataBuf = ByteString.EMPTY;
+    if (!msg.hasGetSmallFile()) {
+      LOG.debug("Malformed get small file request. trace ID: {}",
+          msg.getTraceID());
+      return ContainerUtils.malformedRequest(msg);
+    }
+    Pipeline pipeline =
+        Pipeline.getFromProtoBuf(msg.getGetSmallFile().getKey().getPipeline());
+    Preconditions.checkNotNull(pipeline);
+    KeyData keyData = KeyData.getFromProtoBuf(msg.getGetSmallFile()
+        .getKey().getKeyData());
+    KeyData data = this.containerManager.getKeyManager().getKey(keyData);
+    ContainerProtos.ChunkInfo c = null;
+    for (ContainerProtos.ChunkInfo chunk : data.getChunks()) {
+      ByteString current =
+          ByteString.copyFrom(this.containerManager.getChunkManager().readChunk(
+              pipeline, keyData.getKeyName(), ChunkInfo.getFromProtoBuf(
+                  chunk)));
+      dataBuf = dataBuf.concat(current);
+      c = chunk;
+    }
+
+    return FileUtils.getGetSmallFileResponse(msg, dataBuf.toByteArray(),
+        ChunkInfo.getFromProtoBuf(c));
+  }
+

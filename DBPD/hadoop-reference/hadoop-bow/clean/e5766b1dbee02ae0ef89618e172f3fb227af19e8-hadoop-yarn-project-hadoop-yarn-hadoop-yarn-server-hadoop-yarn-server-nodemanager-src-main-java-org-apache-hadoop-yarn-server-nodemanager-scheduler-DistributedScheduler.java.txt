YARN-5113. Refactoring and other clean-up for distributed scheduling. (Konstantinos Karanasos via asuresh)

-import org.apache.hadoop.yarn.server.api.protocolrecords.DistSchedAllocateRequest;
-import org.apache.hadoop.yarn.server.api.protocolrecords.DistSchedAllocateResponse;
-import org.apache.hadoop.yarn.server.api.protocolrecords.DistSchedRegisterResponse;
-import org.apache.hadoop.yarn.api.protocolrecords
-    .FinishApplicationMasterRequest;
-import org.apache.hadoop.yarn.api.protocolrecords
-    .FinishApplicationMasterResponse;
-import org.apache.hadoop.yarn.api.protocolrecords
-    .RegisterApplicationMasterRequest;
-import org.apache.hadoop.yarn.api.protocolrecords
-    .RegisterApplicationMasterResponse;
+import org.apache.hadoop.yarn.server.api.protocolrecords.DistributedSchedulingAllocateRequest;
+import org.apache.hadoop.yarn.server.api.protocolrecords.DistributedSchedulingAllocateResponse;
+import org.apache.hadoop.yarn.server.api.protocolrecords.RegisterDistributedSchedulingAMResponse;
+import org.apache.hadoop.yarn.api.protocolrecords.FinishApplicationMasterRequest;
+import org.apache.hadoop.yarn.api.protocolrecords.FinishApplicationMasterResponse;
+import org.apache.hadoop.yarn.api.protocolrecords.RegisterApplicationMasterRequest;
+import org.apache.hadoop.yarn.api.protocolrecords.RegisterApplicationMasterResponse;
-import org.apache.hadoop.yarn.server.nodemanager.amrmproxy
-    .AMRMProxyApplicationContext;
+import org.apache.hadoop.yarn.server.nodemanager.amrmproxy.AMRMProxyApplicationContext;
-import org.apache.hadoop.yarn.server.nodemanager.security
-    .NMTokenSecretManagerInNM;
+import org.apache.hadoop.yarn.server.nodemanager.security.NMTokenSecretManagerInNM;
- * <p>The LocalScheduler runs on the NodeManager and is modelled as an
+ * <p>The DistributedScheduler runs on the NodeManager and is modeled as an
- * following :</p>
+ * following:</p>
- *   <code>ClusterManager</code> running on the ResourceManager to aid in making
- *   Scheduling scheduling decisions</li>
+ *   <code>ClusterMonitor</code> running on the ResourceManager to aid in making
+ *   distributed scheduling decisions.</li>
- *   containers for the opportunistic resource outstandingOpReqs</li>
+ *   containers for the outstanding OPPORTUNISTIC container requests.</li>
-public final class LocalScheduler extends AbstractRequestInterceptor {
+public final class DistributedScheduler extends AbstractRequestInterceptor {
-  static class DistSchedulerParams {
+  static class DistributedSchedulerParams {
-      .getLogger(LocalScheduler.class);
+      .getLogger(DistributedScheduler.class);
-  // Currently just used to keep track of allocated Containers
-  // Can be used for reporting stats later
+  // Currently just used to keep track of allocated containers.
+  // Can be used for reporting stats later.
-  private DistSchedulerParams appParams = new DistSchedulerParams();
-  private final OpportunisticContainerAllocator.ContainerIdCounter containerIdCounter =
-      new OpportunisticContainerAllocator.ContainerIdCounter();
+  private DistributedSchedulerParams appParams =
+      new DistributedSchedulerParams();
+  private final OpportunisticContainerAllocator.ContainerIdCounter
+      containerIdCounter =
+          new OpportunisticContainerAllocator.ContainerIdCounter();
-  // ResourceRequests (ask)
+  // ResourceRequest (ask).
-   * @throws YarnException
-   * @throws IOException
+   * @throws YarnException YarnException
+   * @throws IOException IOException
-   * @throws YarnException
-   * @throws IOException
+   * @throws YarnException YarnException
+   * @throws IOException IOException
-    DistSchedAllocateRequest distRequest =
-        RECORD_FACTORY.newRecordInstance(DistSchedAllocateRequest.class);
+    DistributedSchedulingAllocateRequest distRequest = RECORD_FACTORY
+        .newRecordInstance(DistributedSchedulingAllocateRequest.class);
-   * @param response
-   * @param nmTokens
-   * @param allocatedContainers
-      DistSchedRegisterResponse registerResponse) {
-    appParams.minResource = registerResponse.getMinAllocatableCapabilty();
-    appParams.maxResource = registerResponse.getMaxAllocatableCapabilty();
+      RegisterDistributedSchedulingAMResponse registerResponse) {
+    appParams.minResource = registerResponse.getMinContainerResource();
+    appParams.maxResource = registerResponse.getMaxContainerResource();
-        registerResponse.getIncrAllocatableCapabilty();
+        registerResponse.getIncrContainerResource();
-   * (Priority, ResourceName, Capability) and adds it the outstanding
+   * (Priority, ResourceName, Capability) and adds to the outstanding
-   * a give Priority and Capability
-   * @param resourceAsks
+   * a give Priority and Capability.
+   *
+   * @param resourceAsks the list with the {@link ResourceRequest}s
-   * outstanding OPPORTUNISTIC ResourceRequest
-   * @param capability
-   * @param allocatedContainers
+   * outstanding OPPORTUNISTIC ResourceRequest.
-  public void matchAllocationToOutstandingRequest(Resource capability,
+  private void matchAllocationToOutstandingRequest(Resource capability,
-  public DistSchedRegisterResponse
+  public RegisterDistributedSchedulingAMResponse
-              throws YarnException, IOException {
+      throws YarnException, IOException {
-    DistSchedRegisterResponse dsResp = getNextInterceptor()
+    RegisterDistributedSchedulingAMResponse dsResp = getNextInterceptor()
-  public DistSchedAllocateResponse allocateForDistributedScheduling(
-      DistSchedAllocateRequest request) throws YarnException, IOException {
+  public DistributedSchedulingAllocateResponse allocateForDistributedScheduling(
+      DistributedSchedulingAllocateRequest request)
+      throws YarnException, IOException {
-    PartitionedResourceRequests partitionedAsks = partitionAskList(
-        request.getAllocateRequest().getAskList());
+    PartitionedResourceRequests partitionedAsks =
+        partitionAskList(request.getAllocateRequest().getAskList());
+
-    DistSchedAllocateResponse dsResp =
+    DistributedSchedulingAllocateResponse dsResp =

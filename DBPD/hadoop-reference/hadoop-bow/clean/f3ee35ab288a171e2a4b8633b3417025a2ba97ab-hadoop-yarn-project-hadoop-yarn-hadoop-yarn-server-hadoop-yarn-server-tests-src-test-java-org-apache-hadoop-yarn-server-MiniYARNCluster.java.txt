Merge r1555021 through r1556550 from trunk.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1556552 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.hadoop.yarn.server.resourcemanager.RMFatalEvent;
+  private int failoverTimeout;
+    failoverTimeout = conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,
+        YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);
+    conf.setBoolean(YarnConfiguration.IS_MINI_YARN_CLUSTER, true);
+      if (!useFixedPorts) {
+        if (HAUtil.isHAEnabled(conf)) {
+          setHARMConfiguration(i, conf);
+        } else {
+          setNonHARMConfiguration(conf);
+        }
+      }
+  private void setNonHARMConfiguration(Configuration conf) {
+    String hostname = MiniYARNCluster.getHostname();
+    conf.set(YarnConfiguration.RM_ADDRESS, hostname + ":0");
+    conf.set(YarnConfiguration.RM_ADMIN_ADDRESS, hostname + ":0");
+    conf.set(YarnConfiguration.RM_SCHEDULER_ADDRESS, hostname + ":0");
+    conf.set(YarnConfiguration.RM_RESOURCE_TRACKER_ADDRESS, hostname + ":0");
+    WebAppUtils.setRMWebAppHostnameAndPort(conf, hostname, 0);
+  }
+
+  private void setHARMConfiguration(final int index, Configuration conf) {
+    String hostname = MiniYARNCluster.getHostname();
+    for (String confKey : YarnConfiguration.RM_SERVICES_ADDRESS_CONF_KEYS) {
+      conf.set(HAUtil.addSuffix(confKey, rmIds[index]), hostname + ":0");
+    }
+  }
+
+  private synchronized void initResourceManager(int index, Configuration conf) {
+    if (HAUtil.isHAEnabled(conf)) {
+      conf.set(YarnConfiguration.RM_HA_ID, rmIds[index]);
+    }
+    resourceManagers[index].init(conf);
+    resourceManagers[index].getRMContext().getDispatcher().register(
+        RMAppAttemptEventType.class,
+        new EventHandler<RMAppAttemptEvent>() {
+          public void handle(RMAppAttemptEvent event) {
+            if (event instanceof RMAppAttemptRegistrationEvent) {
+              appMasters.put(event.getApplicationAttemptId(),
+                  event.getTimestamp());
+            } else if (event instanceof RMAppAttemptUnregistrationEvent) {
+              appMasters.remove(event.getApplicationAttemptId());
+            }
+          }
+        });
+  }
+
+  private synchronized void startResourceManager(final int index) {
+    try {
+      Thread rmThread = new Thread() {
+        public void run() {
+          resourceManagers[index].start();
+        }
+      };
+      rmThread.setName("RM-" + index);
+      rmThread.start();
+      int waitCount = 0;
+      while (resourceManagers[index].getServiceState() == STATE.INITED
+          && waitCount++ < 60) {
+        LOG.info("Waiting for RM to start...");
+        Thread.sleep(1500);
+      }
+      if (resourceManagers[index].getServiceState() != STATE.STARTED) {
+        // RM could have failed.
+        throw new IOException(
+            "ResourceManager failed to start. Final state is "
+                + resourceManagers[index].getServiceState());
+      }
+    } catch (Throwable t) {
+      throw new YarnRuntimeException(t);
+    }
+    LOG.info("MiniYARN ResourceManager address: " +
+        getConfig().get(YarnConfiguration.RM_ADDRESS));
+    LOG.info("MiniYARN ResourceManager web address: " +
+        WebAppUtils.getRMWebAppURLWithoutScheme(getConfig()));
+  }
+
+  @InterfaceAudience.Private
+  @VisibleForTesting
+  public synchronized void stopResourceManager(int index) {
+    if (resourceManagers[index] != null) {
+      resourceManagers[index].stop();
+      resourceManagers[index] = null;
+    }
+  }
+
+  @InterfaceAudience.Private
+  @VisibleForTesting
+  public synchronized void restartResourceManager(int index)
+      throws InterruptedException {
+    if (resourceManagers[index] != null) {
+      resourceManagers[index].stop();
+      resourceManagers[index] = null;
+    }
+    Configuration conf = getConfig();
+    resourceManagers[index] = new ResourceManager();
+    initResourceManager(index, getConfig());
+    startResourceManager(index);
+  }
+
-   * In a HA cluster, go through all the RMs and find the Active RM. If none
-   * of them are active, wait upto 5 seconds for them to transition to Active.
+   * In a HA cluster, go through all the RMs and find the Active RM. In a
+   * non-HA cluster, return the index of the only RM.
-   * In an non-HA cluster, return the index of the only RM.
-   *
-   * @return index of the active RM or -1 if none of them transition to
-   * active even after 5 seconds of waiting
+   * @return index of the active RM or -1 if none of them turn active
-    int numRetriesForRMBecomingActive = 5;
+    int numRetriesForRMBecomingActive = failoverTimeout / 100;
+        if (resourceManagers[i] == null) {
+          continue;
+        }
-        Thread.sleep(1000);
+        Thread.sleep(100);
-        : this.resourceManagers[getActiveRMIndex()];
+        : this.resourceManagers[activeRMIndex];
-    private void setNonHARMConfiguration(Configuration conf) {
-      String hostname = MiniYARNCluster.getHostname();
-      conf.set(YarnConfiguration.RM_ADDRESS, hostname + ":0");
-      conf.set(YarnConfiguration.RM_ADMIN_ADDRESS, hostname + ":0");
-      conf.set(YarnConfiguration.RM_SCHEDULER_ADDRESS, hostname + ":0");
-      conf.set(YarnConfiguration.RM_RESOURCE_TRACKER_ADDRESS, hostname + ":0");
-      WebAppUtils.setRMWebAppHostnameAndPort(conf, hostname, 0);
-    }
-
-    private void setHARMConfiguration(Configuration conf) {
-      String hostname = MiniYARNCluster.getHostname();
-      for (String confKey : YarnConfiguration.RM_SERVICES_ADDRESS_CONF_KEYS) {
-        for (String id : HAUtil.getRMHAIds(conf)) {
-          conf.set(HAUtil.addSuffix(confKey, id), hostname + ":0");
-        }
-      }
-    }
-
-      conf.setBoolean(YarnConfiguration.IS_MINI_YARN_CLUSTER, true);
-
-      if (!useFixedPorts) {
-        if (HAUtil.isHAEnabled(conf)) {
-          setHARMConfiguration(conf);
-        } else {
-          setNonHARMConfiguration(conf);
-        }
-      }
-      if (HAUtil.isHAEnabled(conf)) {
-        conf.set(YarnConfiguration.RM_HA_ID, rmIds[index]);
-      }
-      resourceManagers[index].init(conf);
-      resourceManagers[index].getRMContext().getDispatcher().register
-          (RMAppAttemptEventType.class,
-          new EventHandler<RMAppAttemptEvent>() {
-            public void handle(RMAppAttemptEvent event) {
-              if (event instanceof RMAppAttemptRegistrationEvent) {
-                appMasters.put(event.getApplicationAttemptId(), event.getTimestamp());
-              } else if (event instanceof RMAppAttemptUnregistrationEvent) {
-                appMasters.remove(event.getApplicationAttemptId());
-              }
-            }
-          });
+      initResourceManager(index, conf);
-      try {
-        new Thread() {
-          public void run() {
-            resourceManagers[index].start();
-          }
-        }.start();
-        int waitCount = 0;
-        while (resourceManagers[index].getServiceState() == STATE.INITED
-            && waitCount++ < 60) {
-          LOG.info("Waiting for RM to start...");
-          Thread.sleep(1500);
-        }
-        if (resourceManagers[index].getServiceState() != STATE.STARTED) {
-          // RM could have failed.
-          throw new IOException(
-              "ResourceManager failed to start. Final state is "
-                  + resourceManagers[index].getServiceState());
-        }
-        super.serviceStart();
-      } catch (Throwable t) {
-        throw new YarnRuntimeException(t);
-      }
+      startResourceManager(index);
+      super.serviceStart();
-      super.serviceStop();
+      super.serviceStop();

YARN-3745. SerializedException should also try to instantiate internal
exception with the default constructor. Contributed by Lavkesh Lahngir.

-  private static <T extends Throwable> T instantiateException(
-      Class<? extends T> cls, String message, Throwable cause) {
+  private static <T extends Throwable> T instantiateExceptionImpl(
+      String message, Class<? extends T> cls, Throwable cause)
+      throws NoSuchMethodException, InstantiationException,
+      IllegalAccessException, InvocationTargetException {
+    cn =
+        cls.getConstructor(message == null ? new Class[0]
+            : new Class[] {String.class});
+    cn.setAccessible(true);
+    ex = message == null ? cn.newInstance() : cn.newInstance(message);
+    ex.initCause(cause);
+    return ex;
+  }
+
+  private static <T extends Throwable> T instantiateException(
+      Class<? extends T> cls, String message, Throwable cause) {
+    T ex = null;
-      cn = cls.getConstructor(String.class);
-      cn.setAccessible(true);
-      ex = cn.newInstance(message);
-      ex.initCause(cause);
+      // Try constructor with String argument, if it fails, try default.
+      try {
+        ex = instantiateExceptionImpl(message, cls, cause);
+      } catch (NoSuchMethodException e) {
+        ex = instantiateExceptionImpl(null, cls, cause);
+      }

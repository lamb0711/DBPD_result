HADOOP-16818. ABFS: Combine append+flush calls for blockblob & appendblob


Contributed by Ishani Ahuja.
+  private boolean supportAppendWithFlush;
+  private boolean appendBlob;
-      final boolean disableOutputStreamFlush) {
+      final boolean disableOutputStreamFlush,
+      final boolean supportAppendWithFlush,
+      final boolean appendBlob) {
+    this.disableOutputStreamFlush = disableOutputStreamFlush;
+    this.supportAppendWithFlush = supportAppendWithFlush;
+    this.appendBlob = appendBlob;
-
-        writeCurrentBufferToService();
+        writeCurrentBufferToService(false, false);
-    writeCurrentBufferToService();
-    flushWrittenBytesToService(isClose);
+    writeAndFlushWrittenBytesToService(isClose);
-    writeCurrentBufferToService();
+    writeCurrentBufferToService(true, false);
-  private synchronized void writeCurrentBufferToService() throws IOException {
+  private synchronized void writeCurrentBufferToService(final boolean flush, final boolean isClose) throws IOException {
+    if (this.appendBlob) {
+        client.append(path, offset, bytes, 0,
+            bytesLength, flush, isClose);
+        lastTotalAppendOffset += bytesLength;
+        if (flush) {
+          lastFlushOffset = lastTotalAppendOffset;
+        }
+        return;
+    }
+
+          if (flush) {
+            /* Append with Flush enabled should happen
+             * when all the data which was supposed to be
+             * appended has been sent and finished.
+             */
+            while(lastTotalAppendOffset <  lastFlushOffset);
+          }
-                  bytesLength);
+              bytesLength, flush, isClose);
-    writeOperations.add(new WriteOperation(job, offset, bytesLength));
+    writeOperations.add(new WriteOperation(job, offset, bytesLength, flush));
-
-    flushWrittenBytesToServiceInternal(position, false, isClose);
+    shrinkWriteOperationQueue();
+  }
+
+  private synchronized void completeExistingTasks() throws IOException {
+    for (WriteOperation writeOperation : writeOperations) {
+      try {
+        writeOperation.task.get();
+      } catch (Exception ex) {
+        if (ex.getCause() instanceof AbfsRestOperationException) {
+          if (((AbfsRestOperationException) ex.getCause()).getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {
+            throw new FileNotFoundException(ex.getMessage());
+          }
+        }
+        if (ex.getCause() instanceof AzureBlobFileSystemException) {
+          ex = (AzureBlobFileSystemException) ex.getCause();
+        }
+        lastError = new IOException(ex);
+        throw lastError;
+      }
+    }
+    shrinkWriteOperationQueue();
+  }
+
+  private synchronized void writeAndFlushWrittenBytesToService(boolean isClose) throws IOException {
+    completeExistingTasks();
+    writeCurrentBufferToService(supportAppendWithFlush, isClose);
+    completeExistingTasks();
+    if (this.lastTotalAppendOffset > this.lastFlushOffset) {
+      flushWrittenBytesToServiceInternal(position, false, isClose);
+    }
+        if (writeOperations.peek().isFlush) {
+          lastFlushOffset = lastTotalAppendOffset;
+        }
+    private final boolean isFlush;
-    WriteOperation(final Future<Void> task, final long startOffset, final long length) {
+    WriteOperation(final Future<Void> task, final long startOffset, final long length, final boolean flush) {
+      this.isFlush = flush;

HDFS-7888. Change DFSOutputStream and DataStreamer for convenience of subclassing. Contributed by Li Bo

-import java.net.Socket;
-  private final DFSClient dfsClient;
-  private final ByteArrayManager byteArrayManager;
+  protected final DFSClient dfsClient;
+  protected final ByteArrayManager byteArrayManager;
-  private volatile boolean closed = false;
+  protected volatile boolean closed = false;
-  private final String src;
-  private final long fileId;
-  private final long blockSize;
-  private final int bytesPerChecksum;
+  protected final String src;
+  protected final long fileId;
+  protected final long blockSize;
+  protected final int bytesPerChecksum;
-  private DFSPacket currentPacket = null;
-  private DataStreamer streamer;
-  private int packetSize = 0; // write packet size, not including the header.
-  private int chunksPerPacket = 0;
-  private long lastFlushOffset = 0; // offset when flush was invoked
+  protected DFSPacket currentPacket = null;
+  protected DataStreamer streamer;
+  protected int packetSize = 0; // write packet size, not including the header.
+  protected int chunksPerPacket = 0;
+  protected long lastFlushOffset = 0; // offset when flush was invoked
-  private boolean shouldSyncBlock = false; // force blocks to disk upon close
-  private final AtomicReference<CachingStrategy> cachingStrategy;
+  protected boolean shouldSyncBlock = false; // force blocks to disk upon close
+  protected final AtomicReference<CachingStrategy> cachingStrategy;
-  private DFSPacket createPacket(int packetSize, int chunksPerPkt, long offsetInBlock,
+  protected DFSPacket createPacket(int packetSize, int chunksPerPkt, long offsetInBlock,
-  private DFSOutputStream(DFSClient dfsClient, String src, HdfsFileStatus stat,
+  protected DFSOutputStream(DFSClient dfsClient, String src, HdfsFileStatus stat,
-  private void computePacketChunkSize(int psize, int csize) {
+  protected void computePacketChunkSize(int psize, int csize) {
-      // If the reopened file did not end at chunk boundary and the above
-      // write filled up its partial chunk. Tell the summer to generate full 
-      // crc chunks from now on.
-      if (streamer.getAppendChunk() &&
-          streamer.getBytesCurBlock() % bytesPerChecksum == 0) {
-        streamer.setAppendChunk(false);
-        resetChecksumBufSize();
-      }
+      adjustChunkBoundary();
-      if (!streamer.getAppendChunk()) {
-        int psize = Math.min((int)(blockSize-streamer.getBytesCurBlock()),
-            dfsClient.getConf().writePacketSize);
-        computePacketChunkSize(psize, bytesPerChecksum);
-      }
-      //
-      // if encountering a block boundary, send an empty packet to 
-      // indicate the end of block and reset bytesCurBlock.
-      //
-      if (streamer.getBytesCurBlock() == blockSize) {
-        currentPacket = createPacket(0, 0, streamer.getBytesCurBlock(),
-            streamer.getAndIncCurrentSeqno(), true);
-        currentPacket.setSyncBlock(shouldSyncBlock);
-        streamer.waitAndQueuePacket(currentPacket);
-        currentPacket = null;
-        streamer.setBytesCurBlock(0);
-        lastFlushOffset = 0;
-      }
+      endBlock();
+    }
+  }
+
+  /**
+   * If the reopened file did not end at chunk boundary and the above
+   * write filled up its partial chunk. Tell the summer to generate full
+   * crc chunks from now on.
+   */
+  protected void adjustChunkBoundary() {
+    if (streamer.getAppendChunk() &&
+        streamer.getBytesCurBlock() % bytesPerChecksum == 0) {
+      streamer.setAppendChunk(false);
+      resetChecksumBufSize();
+    }
+
+    if (!streamer.getAppendChunk()) {
+      int psize = Math.min((int)(blockSize- streamer.getBytesCurBlock()),
+          dfsClient.getConf().writePacketSize);
+      computePacketChunkSize(psize, bytesPerChecksum);
+    }
+  }
+
+  /**
+   * if encountering a block boundary, send an empty packet to
+   * indicate the end of block and reset bytesCurBlock.
+   *
+   * @throws IOException
+   */
+  protected void endBlock() throws IOException {
+    if (streamer.getBytesCurBlock() == blockSize) {
+      currentPacket = createPacket(0, 0, streamer.getBytesCurBlock(),
+          streamer.getAndIncCurrentSeqno(), true);
+      currentPacket.setSyncBlock(shouldSyncBlock);
+      streamer.waitAndQueuePacket(currentPacket);
+      currentPacket = null;
+      streamer.setBytesCurBlock(0);
+      lastFlushOffset = 0;
-  private void flushInternal() throws IOException {
+  protected void flushInternal() throws IOException {
-  private synchronized void start() {
+  protected synchronized void start() {
-  private void closeThreads(boolean force) throws IOException {
+  protected void closeThreads(boolean force) throws IOException {
-  private synchronized void closeImpl() throws IOException {
+  protected synchronized void closeImpl() throws IOException {
-      if (currentPacket != null) { 
+      if (currentPacket != null) {
-  private void completeFile(ExtendedBlock last) throws IOException {
+  protected void completeFile(ExtendedBlock last) throws IOException {

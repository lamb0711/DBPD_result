HDDS-935. Avoid creating an already created container on a datanode in case of disk removal followed by datanode restart. Contributed by Shashikant Banerjee.

+import org.apache.commons.io.IOUtils;
+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.
+    ContainerIdSetProto;
+import java.util.Set;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.io.FileOutputStream;
+import java.io.FileInputStream;
+import java.io.OutputStream;
+
+
+  // keeps track of the containers created per pipeline
+  private final Set<Long> createContainerSet;
+    this.createContainerSet = new ConcurrentSkipListSet<>();
-  private long loadSnapshot(SingleFileSnapshotInfo snapshot) {
+  private long loadSnapshot(SingleFileSnapshotInfo snapshot)
+      throws IOException {
-      TermIndex empty = TermIndex.newTermIndex(0,
-          RaftServerConstants.INVALID_LOG_INDEX);
-      LOG.info("The snapshot info is null." +
-          "Setting the last applied index to:" + empty);
+      TermIndex empty =
+          TermIndex.newTermIndex(0, RaftServerConstants.INVALID_LOG_INDEX);
+      LOG.info(
+          "The snapshot info is null." + "Setting the last applied index to:"
+              + empty);
+    final File snapshotFile = snapshot.getFile().getPath().toFile();
-        SimpleStateMachineStorage.getTermIndexFromSnapshotFile(
-            snapshot.getFile().getPath().toFile());
+        SimpleStateMachineStorage.getTermIndexFromSnapshotFile(snapshotFile);
+
+    // initialize the dispatcher with snapshot so that it build the missing
+    // container list
+    try (FileInputStream fin = new FileInputStream(snapshotFile)) {
+      byte[] containerIds = IOUtils.toByteArray(fin);
+      ContainerProtos.ContainerIdSetProto proto =
+          ContainerProtos.ContainerIdSetProto.parseFrom(containerIds);
+      // read the created containers list from the snapshot file and add it to
+      // the createContainerSet here.
+      // createContainerSet will further grow as and when containers get created
+      createContainerSet.addAll(proto.getContainerIdList());
+      dispatcher.buildMissingContainerSet(createContainerSet);
+    }
+  /**
+   * As a part of taking snapshot with Ratis StateMachine, it will persist
+   * the existing container set in the snapshotFile.
+   * @param out OutputStream mapped to the Ratis snapshot file
+   * @throws IOException
+   */
+  public void persistContainerSet(OutputStream out) throws IOException {
+    ContainerIdSetProto.Builder builder = ContainerIdSetProto.newBuilder();
+    builder.addAllContainerId(createContainerSet);
+    // TODO : while snapshot is being taken, deleteContainer call should not
+    // should not happen. Lock protection will be required if delete
+    // container happens outside of Ratis.
+    IOUtils.write(builder.build().toByteArray(), out);
+  }
+
-        //persist open container info to snapshot later.
-        snapshotFile.createNewFile();
+        boolean created = snapshotFile.createNewFile();
+        if (!created) {
+          throw new IOException("Failed to create ratis snapshot file");
+        }
+        try (FileOutputStream fos = new FileOutputStream(snapshotFile)) {
+          persistContainerSet(fos);
+        }
+            .setCreateContainerSet(createContainerSet)
+      if (cmdType == Type.WriteChunk || cmdType ==Type.PutSmallFile) {
+        builder.setCreateContainerSet(createContainerSet);
+      }

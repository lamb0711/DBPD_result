YARN-6550. Capture launch_container.sh logs to a separate log file. (Suma Shivaprasad via wangda)

Change-Id: I0ee0b1bb459437432a22cf68861a6354f0decabb

+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+  private static final String CONTAINER_PRE_LAUNCH_PREFIX = "prelaunch";
+  public static final String CONTAINER_PRE_LAUNCH_STDOUT = CONTAINER_PRE_LAUNCH_PREFIX + ".out";
+  public static final String CONTAINER_PRE_LAUNCH_STDERR = CONTAINER_PRE_LAUNCH_PREFIX + ".err";
+
+
-    var =  var.replace(ApplicationConstants.CLASS_PATH_SEPARATOR,
+    var = var.replace(ApplicationConstants.CLASS_PATH_SEPARATOR,
-    for(String logDir : logDirs) {
+    for (String logDir : logDirs) {
+   *
-    LOG.warn(diagnosticInfo.toString());
+    LOG.warn("Container launch failed : " + diagnosticInfo.toString());
+    FileSystem fileSystem = null;
+    long tailSizeInBytes =
+        conf.getLong(YarnConfiguration.NM_CONTAINER_STDERR_BYTES,
+            YarnConfiguration.DEFAULT_NM_CONTAINER_STDERR_BYTES);
+
+    // Append container prelaunch stderr to diagnostics
+    try {
+      fileSystem = FileSystem.getLocal(conf).getRaw();
+      FileStatus preLaunchErrorFileStatus = fileSystem
+          .getFileStatus(new Path(containerLogDir, ContainerLaunch.CONTAINER_PRE_LAUNCH_STDERR));
+
+      Path errorFile = preLaunchErrorFileStatus.getPath();
+      long fileSize = preLaunchErrorFileStatus.getLen();
+
+      diagnosticInfo.append("Error file: ")
+          .append(ContainerLaunch.CONTAINER_PRE_LAUNCH_STDERR).append(".\n");
+      ;
+
+      byte[] tailBuffer = tailFile(errorFile, fileSize, tailSizeInBytes);
+      diagnosticInfo.append("Last ").append(tailSizeInBytes)
+          .append(" bytes of ").append(errorFile.getName()).append(" :\n")
+          .append(new String(tailBuffer, StandardCharsets.UTF_8));
+    } catch (IOException e) {
+      LOG.error("Failed to get tail of the container's prelaunch error log file", e);
+    }
+
+    // Append container stderr to diagnostics
-    FSDataInputStream errorFileIS = null;
+
-      FileSystem fileSystem = FileSystem.getLocal(conf).getRaw();
+      if (fileSystem == null) {
+        fileSystem = FileSystem.getLocal(conf).getRaw();
+      }
-        long tailSizeInBytes =
-            conf.getLong(YarnConfiguration.NM_CONTAINER_STDERR_BYTES,
-                YarnConfiguration.DEFAULT_NM_CONTAINER_STDERR_BYTES);
-        long startPosition =
-            (fileSize < tailSizeInBytes) ? 0 : fileSize - tailSizeInBytes;
-        int bufferSize =
-            (int) ((fileSize < tailSizeInBytes) ? fileSize : tailSizeInBytes);
-        byte[] tailBuffer = new byte[bufferSize];
-        errorFileIS = fileSystem.open(errorFile);
-        errorFileIS.readFully(startPosition, tailBuffer);
-
+        byte[] tailBuffer = tailFile(errorFile, fileSize, tailSizeInBytes);
+
-    } finally {
-      IOUtils.cleanupWithLogger(LOG, errorFileIS);
-
+  private byte[] tailFile(Path filePath, long fileSize, long tailSizeInBytes) throws IOException {
+    FSDataInputStream errorFileIS = null;
+    FileSystem fileSystem = FileSystem.getLocal(conf).getRaw();
+    try {
+      long startPosition =
+          (fileSize < tailSizeInBytes) ? 0 : fileSize - tailSizeInBytes;
+      int bufferSize =
+          (int) ((fileSize < tailSizeInBytes) ? fileSize : tailSizeInBytes);
+      byte[] tailBuffer = new byte[bufferSize];
+      errorFileIS = fileSystem.open(filePath);
+      errorFileIS.readFully(startPosition, tailBuffer);
+      return tailBuffer;
+    } finally {
+      IOUtils.cleanupWithLogger(LOG, errorFileIS);
+    }
+  }
+
+    protected static final String ENV_PRELAUNCH_STDOUT = "PRELAUNCH_OUT";
+    protected static final String ENV_PRELAUNCH_STDERR = "PRELAUNCH_ERR";
+
+    private boolean redirectStdOut = false;
+    private boolean redirectStdErr = false;
+
+    /**
+     * Set stdout for the shell script
+     * @param stdoutDir stdout must be an absolute path
+     * @param stdOutFile stdout file name
+     * @throws IOException thrown when stdout path is not absolute
+     */
+    public final void stdout(Path stdoutDir, String stdOutFile) throws IOException {
+      if (!stdoutDir.isAbsolute()) {
+        throw new IOException("Stdout path must be absolute");
+      }
+      redirectStdOut = true;
+      setStdOut(new Path(stdoutDir, stdOutFile));
+    }
+
+    /**
+     * Set stderr for the shell script
+     * @param stderrDir stderr must be an absolute path
+     * @param stdErrFile stderr file name
+     * @throws IOException thrown when stderr path is not absolute
+     */
+    public final void stderr(Path stderrDir, String stdErrFile) throws IOException {
+      if (!stderrDir.isAbsolute()) {
+        throw new IOException("Stdout path must be absolute");
+      }
+      redirectStdErr = true;
+      setStdErr(new Path(stderrDir, stdErrFile));
+    }
+
+    protected abstract void setStdOut(Path stdout) throws IOException;
+
+    protected abstract void setStdErr(Path stdout) throws IOException;
+
+    public abstract void echo(String echoStr) throws IOException;
+
-    protected final void line(String... command) {
+    protected final void buildCommand(String... command) {
+    }
+
+    protected final void linebreak(String... command) {
+    protected final void line(String... command) {
+      buildCommand(command);
+      linebreak();
+    }
+
+
+    boolean doRedirectStdOut() {
+      return redirectStdOut;
+    }
+
+    boolean doRedirectStdErr() {
+      return redirectStdErr;
+    }
+
-
-      line("if [ $hadoop_shell_errorcode -ne 0 ]");
+      line("if [[ \"$hadoop_shell_errorcode\" -ne 0 ]]");
-    public UnixShellScriptBuilder(){
+    public UnixShellScriptBuilder() {
-      errorCheck();
-    public void whitelistedEnv(String key, String value) {
+    public void whitelistedEnv(String key, String value) throws IOException {
-    public void env(String key, String value) {
+    public void setStdOut(final Path stdout) throws IOException {
+      line("export ", ENV_PRELAUNCH_STDOUT, "=\"", stdout.toString(), "\"");
+      // tee is needed for DefaultContainerExecutor error propagation to stdout
+      // Close stdout of subprocess to prevent it from writing to the stdout file
+      line("exec >\"${" + ENV_PRELAUNCH_STDOUT + "}\"");
+    }
+
+    @Override
+    public void setStdErr(final Path stderr) throws IOException {
+      line("export ", ENV_PRELAUNCH_STDERR, "=\"", stderr.toString(), "\"");
+      // tee is needed for DefaultContainerExecutor error propagation to stderr
+      // Close stdout of subprocess to prevent it from writing to the stdout file
+      line("exec 2>\"${" + ENV_PRELAUNCH_STDERR + "}\"");
+    }
+
+    @Override
+    public void env(String key, String value) throws IOException {
+    public void echo(final String echoStr) throws IOException {
+      line("echo \"" + echoStr + "\"");
+    }
+
+    @Override
-      errorCheck();
-    protected void mkdir(Path path) {
+    protected void mkdir(Path path) throws IOException {
-      errorCheck();
+    //Dummy implementation
+    @Override
+    protected void setStdOut(final Path stdout) throws IOException {
+    }
+
+    //Dummy implementation
+    @Override
+    protected void setStdErr(final Path stderr) throws IOException {
+    }
+
+    public void echo(final String echoStr) throws IOException {
+      lineWithLenCheck("@echo \"", echoStr, "\"");
+    }
+
+    @Override

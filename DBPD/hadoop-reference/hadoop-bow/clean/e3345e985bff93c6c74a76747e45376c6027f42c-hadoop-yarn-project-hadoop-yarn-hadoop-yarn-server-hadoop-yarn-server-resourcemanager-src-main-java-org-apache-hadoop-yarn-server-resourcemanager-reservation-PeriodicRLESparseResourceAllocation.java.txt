Revert "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem."

This reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.

-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.NavigableMap;
-import java.util.TreeMap;
-
-import org.apache.hadoop.yarn.conf.YarnConfiguration;
-import org.apache.hadoop.yarn.util.resource.ResourceCalculator;
+
-import com.google.common.annotations.VisibleForTesting;
-
- * This data structure stores a periodic {@link RLESparseResourceAllocation}.
+ * This data structure stores a periodic RLESparseResourceAllocation.
-public class PeriodicRLESparseResourceAllocation
-    extends RLESparseResourceAllocation {
+public class PeriodicRLESparseResourceAllocation extends
+    RLESparseResourceAllocation {
-  private static final Logger LOG =
-      LoggerFactory.getLogger(PeriodicRLESparseResourceAllocation.class);
+  private static final Logger LOG = LoggerFactory
+      .getLogger(PeriodicRLESparseResourceAllocation.class);
-   * @param resourceCalculator {@link ResourceCalculator} the resource
-   *          calculator to use.
+   * @param rleVector {@link RLESparseResourceAllocation} with the run-length
+              encoded data.
-      ResourceCalculator resourceCalculator, Long timePeriod) {
-    super(resourceCalculator);
+      RLESparseResourceAllocation rleVector, Long timePeriod) {
+    super(rleVector.getCumulative(), rleVector.getResourceCalculator());
-   * @param resourceCalculator {@link ResourceCalculator} the resource
-   *          calculator to use..
-   */
-  public PeriodicRLESparseResourceAllocation(
-      ResourceCalculator resourceCalculator) {
-    this(resourceCalculator,
-        YarnConfiguration.DEFAULT_RM_RESERVATION_SYSTEM_MAX_PERIODICITY);
-  }
-
-  /**
-   * Constructor.
-   *
-   *          encoded data.
-   * @param timePeriod Time period in milliseconds.
+              encoded data.
-  @VisibleForTesting
-      RLESparseResourceAllocation rleVector, Long timePeriod) {
-    super(rleVector.getCumulative(), rleVector.getResourceCalculator());
-    this.timePeriod = timePeriod;
-
-    // make sure the PeriodicRLE is zero-based, and handles wrap-around
-    long delta = (getEarliestStartTime() % timePeriod - getEarliestStartTime());
-    shift(delta);
-
-    List<Long> toRemove = new ArrayList<>();
-    Map<Long, Resource> toAdd = new TreeMap<>();
-
-    for (Map.Entry<Long, Resource> entry : cumulativeCapacity.entrySet()) {
-      if (entry.getKey() > timePeriod) {
-        toRemove.add(entry.getKey());
-        if (entry.getValue() != null) {
-          toAdd.put(timePeriod, entry.getValue());
-          long prev = entry.getKey() % timePeriod;
-          toAdd.put(prev, this.getCapacityAtTime(prev));
-          toAdd.put(0L, entry.getValue());
-        }
-      }
-    }
-    for (Long l : toRemove) {
-      cumulativeCapacity.remove(l);
-    }
-    cumulativeCapacity.putAll(toAdd);
+      RLESparseResourceAllocation rleVector) {
+    this(rleVector, 86400000L);
-   * @param interval {@link ReservationInterval} to which the specified resource
-   *          is to be added.
+   * @param interval {@link ReservationInterval} to which the specified
+   *          resource is to be added.
-  public boolean addInterval(ReservationInterval interval, Resource resource) {
+  public boolean addInterval(ReservationInterval interval,
+      Resource resource) {
-
-      LOG.info("Cannot set capacity beyond end time: " + timePeriod + " was ("
-          + interval.toString() + ")");
+      LOG.info("Cannot set capacity beyond end time: " + timePeriod);
-  /**
+   /**
-  public boolean removeInterval(ReservationInterval interval,
-      Resource resource) {
+  public boolean removeInterval(
+      ReservationInterval interval, Resource resource) {
-    // TODO revesit decrementing endTime
-    if (!Resources.fitsIn(resource, getMinimumCapacityInInterval(
-        new ReservationInterval(startTime, endTime - 1)))) {
+    if (!Resources.fitsIn(
+        resource, super.getMinimumCapacityInInterval(interval))) {
-   * @param tick UTC time base from which offsets are specified for finding the
-   *          maximum capacity.
-   * @param period periodic offset at which capacities are evaluated.
+   * @param tick UTC time base from which offsets are specified for finding
+   *          the maximum capacity.
+   * @param period periodic offset at which capacities are evaluted.
-      maxResource = super.getMaximumPeriodicCapacity(tick % timePeriod, period);
+      maxResource =
+          super.getMaximumPeriodicCapacity(tick % timePeriod, period);
-  @Override
-  public RLESparseResourceAllocation getRangeOverlapping(long start, long end) {
-    NavigableMap<Long, Resource> unrolledMap = new TreeMap<>();
-    readLock.lock();
-    try {
-      long relativeStart = (start >= 0) ? start % timePeriod : 0;
-      NavigableMap<Long, Resource> cumulativeMap = this.getCumulative();
-      Long previous = cumulativeMap.floorKey(relativeStart);
-      previous = (previous != null) ? previous : 0;
-      for (long i = 0; i <= (end - start) / timePeriod; i++) {
-        for (Map.Entry<Long, Resource> e : cumulativeMap.entrySet()) {
-          long curKey = e.getKey() + (i * timePeriod);
-          if (curKey >= previous && (start + curKey - relativeStart) <= end) {
-            unrolledMap.put(curKey, e.getValue());
-          }
-        }
-      }
-      RLESparseResourceAllocation rle =
-          new RLESparseResourceAllocation(unrolledMap, getResourceCalculator());
-      rle.shift(start - relativeStart);
-      return rle;
-    } finally {
-      readLock.unlock();
-    }
-  }
-

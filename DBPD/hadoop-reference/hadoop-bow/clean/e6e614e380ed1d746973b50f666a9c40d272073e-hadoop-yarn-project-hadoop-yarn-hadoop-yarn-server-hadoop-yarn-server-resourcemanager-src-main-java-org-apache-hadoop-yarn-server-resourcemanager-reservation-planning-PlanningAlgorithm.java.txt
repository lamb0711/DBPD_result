YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).

+import org.apache.hadoop.yarn.server.resourcemanager.reservation.PeriodicRLESparseResourceAllocation;
-        computeJobAllocation(plan, reservationId, adjustedContract, user);
+            computeJobAllocation(plan, reservationId, adjustedContract, user);
+
+    long period = Long.parseLong(contract.getRecurrenceExpression());
+
+    // Make allocation periodic if request is periodic
+    if (contract.getRecurrenceExpression() != null) {
+      if (period > 0) {
+        allocation =
+            new PeriodicRLESparseResourceAllocation(allocation, period);
+      }
+    }
-          "The planning algorithm could not find a valid allocation"
-              + " for your request");
+              "The planning algorithm could not find a valid allocation"
+                      + " for your request");
+
+
-        allocationsToPaddedMap(allocation, jobArrival, jobDeadline);
+        allocationsToPaddedMap(allocation, jobArrival, jobDeadline, period);
-            findEarliestTime(mapAllocations), // Earliest start time
-            findLatestTime(mapAllocations), // Latest end time
+            adjustedContract.getArrival(), adjustedContract.getDeadline(),
-  private Map<ReservationInterval, Resource>
-      allocationsToPaddedMap(RLESparseResourceAllocation allocation,
-          long jobArrival, long jobDeadline) {
-
-    // Allocate
-    Map<ReservationInterval, Resource> mapAllocations =
-        allocation.toIntervalMap();
+  private Map<ReservationInterval, Resource> allocationsToPaddedMap(
+      RLESparseResourceAllocation allocation, long jobArrival, long jobDeadline,
+      long period) {
-    // Pad at the beginning
-    long earliestStart = findEarliestTime(mapAllocations);
-    if (jobArrival < earliestStart) {
-      mapAllocations.put(new ReservationInterval(jobArrival, earliestStart),
-          zeroResource);
+    if (period > 0) {
+      if ((jobDeadline - jobArrival) >= period) {
+        allocation.addInterval(new ReservationInterval(0L, period),
+            zeroResource);
+      }
+      jobArrival = jobArrival % period;
+      jobDeadline = jobDeadline % period;
+
+      if (jobArrival <= jobDeadline) {
+        allocation.addInterval(new ReservationInterval(0, jobArrival),
+            zeroResource);
+        allocation.addInterval(new ReservationInterval(jobDeadline, period),
+            zeroResource);
+      } else {
+        allocation.addInterval(new ReservationInterval(jobDeadline, jobArrival),
+            zeroResource);
+      }
+    } else {
+      // Pad at the beginning
+      long earliestStart = findEarliestTime(allocation.toIntervalMap());
+      if (jobArrival < earliestStart) {
+        allocation.addInterval(
+            new ReservationInterval(jobArrival, earliestStart), zeroResource);
+      }
+
+      // Pad at the beginning
+      long latestEnd = findLatestTime(allocation.toIntervalMap());
+      if (latestEnd < jobDeadline) {
+        allocation.addInterval(new ReservationInterval(latestEnd, jobDeadline),
+            zeroResource);
+      }
-
-    // Pad at the beginning
-    long latestEnd = findLatestTime(mapAllocations);
-    if (latestEnd < jobDeadline) {
-      mapAllocations.put(new ReservationInterval(latestEnd, jobDeadline),
-          zeroResource);
-    }
-
-    return mapAllocations;
-
+    return allocation.toIntervalMap();

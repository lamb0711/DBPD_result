HDFS-4611. Update FSImage for INodeReference.


git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1463332 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.DataInputStream;
-import java.io.DataOutputStream;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.util.HashMap;
+import java.util.Map;
-import org.apache.hadoop.hdfs.server.namenode.FSDirectory;
+import org.apache.hadoop.hdfs.server.namenode.INodeReference;
-import org.apache.hadoop.hdfs.server.namenode.snapshot.Snapshot.Root;
+import org.apache.hadoop.hdfs.tools.snapshot.SnapshotDiff;
+import com.google.common.base.Preconditions;
+
-
-   * @param out The {@link DataOutputStream} to write.
+   * @param out The {@link DataOutput} to write.
-      DataOutputStream out) throws IOException {
+      DataOutput out) throws IOException {
-    for (Snapshot ss : snapshots) {
-      // write the snapshot
-      ss.write(out);
+    for (Snapshot s : snapshots) {
+      // write the snapshot id
+      out.writeInt(s.getId());
-   * @param out The {@link DataOutputStream} to write.
+   * @param out The {@link DataOutput} to write.
-      final DataOutputStream out) throws IOException {
+      final DataOutput out, ReferenceMap referenceMap) throws IOException {
-        list.get(i).write(out);
+        list.get(i).write(out, referenceMap);
-      final DataOutputStream out) throws IOException {
+      final DataOutput out, final ReferenceMap referenceMap
+      ) throws IOException {
-        ((INodeDirectoryWithSnapshot)dir).getDiffs(): null, out);
+        ((INodeDirectoryWithSnapshot)dir).getDiffs(): null, out, referenceMap);
-      final DataOutputStream out) throws IOException {
+      final DataOutput out) throws IOException {
-        ((FileWithSnapshot)file).getDiffs(): null, out);
+        ((FileWithSnapshot)file).getDiffs(): null, out, null);
-  public static FileDiffList loadFileDiffList(DataInputStream in,
+  public static FileDiffList loadFileDiffList(DataInput in,
-  private static FileDiff loadFileDiff(FileDiff posterior, DataInputStream in,
+  private static FileDiff loadFileDiff(FileDiff posterior, DataInput in,
-    Snapshot snapshot = findSnapshot(FSImageSerialization.readString(in),
-        loader.getFSDirectoryInLoading());
+    final Snapshot snapshot = loader.getSnapshot(in);
-   * @param in The {@link DataInputStream} to read.
+   * @param in The {@link DataInput} to read.
-      DataInputStream in) throws IOException {
+      DataInput in) throws IOException {
-      byte[] createdNodeName = new byte[in.readShort()];
-      in.readFully(createdNodeName);
+      byte[] createdNodeName = FSImageSerialization.readLocalName(in);
-   * @param in The {@link DataInputStream} to read.
+   * @param in The {@link DataInput} to read.
-      List<INode> createdList, DataInputStream in, FSImageFormat.Loader loader)
+      List<INode> createdList, DataInput in, FSImageFormat.Loader loader)
-   * @param in The {@link DataInputStream} instance to read.
+   * @param in The {@link DataInput} instance to read.
-      DataInputStream in, FSImageFormat.Loader loader) throws IOException {
+      DataInput in, FSImageFormat.Loader loader) throws IOException {
-      Snapshot ss = loadSnapshot(snapshottableParent, in, loader);
-      snapshottableParent.addSnapshot(ss);
+      final Snapshot s = loader.getSnapshot(in);
+      s.getRoot().setParent(snapshottableParent);
+      snapshottableParent.addSnapshot(s);
-   * Load a {@link Snapshot} from fsimage.
-   * @param parent The directory that the snapshot belongs to.
-   * @param in The {@link DataInputStream} instance to read.
-   * @param loader The {@link Loader} instance that this loading procedure is 
-   *               using.
-   * @return The snapshot.
-   */
-  private static Snapshot loadSnapshot(INodeDirectorySnapshottable parent,
-      DataInputStream in, FSImageFormat.Loader loader) throws IOException {
-    int snapshotId = in.readInt();
-    final INode root = loader.loadINodeWithLocalName(false, in);
-    return new Snapshot(snapshotId, root.asDirectory(), parent);
-  }
-  
-  /**
-   * @param in The {@link DataInputStream} instance to read.
+   * @param in The {@link DataInput} instance to read.
-      DataInputStream in, FSImageFormat.Loader loader) throws IOException {
+      DataInput in, FSImageFormat.Loader loader) throws IOException {
-   * Use the given full path to a {@link Root} directory to find the
-   * associated snapshot.
-   */
-  private static Snapshot findSnapshot(String sRootFullPath, FSDirectory fsdir)
-      throws IOException {
-    // find the root
-    INode root = fsdir.getINode(sRootFullPath);
-    INodeDirectorySnapshottable snapshotRoot = INodeDirectorySnapshottable
-        .valueOf(root.getParent(), root.getParent().getFullPathName());
-    // find the snapshot
-    return snapshotRoot.getSnapshot(root.getLocalNameBytes());
-  }
-  
-  /**
-   * @param in The {@link DataInputStream} to read.
+   * @param in The {@link DataInput} to read.
-      Snapshot snapshot, DataInputStream in, FSImageFormat.Loader loader)
+      Snapshot snapshot, DataInput in, FSImageFormat.Loader loader)
-   * @param in The {@link DataInputStream} instance to read.
+   * @param in The {@link DataInput} instance to read.
-      INodeDirectoryWithSnapshot parent, DataInputStream in,
+      INodeDirectoryWithSnapshot parent, DataInput in,
-    Snapshot snapshot = findSnapshot(FSImageSerialization.readString(in),
-        loader.getFSDirectoryInLoading());
+    final Snapshot snapshot = loader.getSnapshot(in);
+
+  /** A reference with a fixed id for fsimage serialization. */
+  private static class INodeReferenceWithId extends INodeReference {
+    final long id;
+
+    private INodeReferenceWithId(WithCount parent, INode referred, long id) {
+      super(parent, referred);
+      this.id = id;
+    }
+    
+    /** @return the reference id. */
+    private long getReferenceId() {
+      return id;
+    }
+  }
+
+  /** A reference map for fsimage serialization. */
+  public static class ReferenceMap {
+    private final Map<Long, INodeReference.WithCount> referenceMap
+        = new HashMap<Long, INodeReference.WithCount>();
+    private long referenceId = 0;
+
+    public void writeINodeReferenceWithCount(INodeReference.WithCount withCount,
+        DataOutput out, boolean writeUnderConstruction) throws IOException {
+      final INode referred = withCount.getReferredINode();
+      final boolean firstReferred = !(referred instanceof INodeReferenceWithId);
+      out.writeBoolean(firstReferred);
+
+      if (firstReferred) {
+        FSImageSerialization.saveINode2Image(referred, out,
+            writeUnderConstruction, this);
+        final long id = ++referenceId;
+        referenceMap.put(id, withCount);
+
+        final INodeReferenceWithId withId = new INodeReferenceWithId(
+            withCount, referred, id);
+        withCount.setReferredINode(withId);
+        referred.setParentReference(withId);
+      } else {
+        final long id = ((INodeReferenceWithId)referred).getReferenceId();
+        Preconditions.checkState(referenceMap.containsKey(id));
+        out.writeLong(id);
+      }
+    }
+    
+    public INodeReference.WithCount loadINodeReferenceWithCount(
+        boolean isSnapshotINode, DataInput in, FSImageFormat.Loader loader
+        ) throws IOException {
+      final boolean firstReferred = in.readBoolean();
+
+      final INodeReference.WithCount withCount;
+      if (firstReferred) {
+        final INode referred = loader.loadINodeWithLocalName(isSnapshotINode, in);
+        withCount = new INodeReference.WithCount(null, referred);
+        referenceMap.put(++referenceId, withCount);
+      } else {
+        final long id = in.readLong();
+        withCount = referenceMap.get(id);
+        withCount.incrementReferenceCount();
+      }
+      return withCount;
+    }
+    
+    public void removeAllINodeReferenceWithId() {
+      for(INodeReference.WithCount withCount : referenceMap.values()) {
+        final INodeReference ref = withCount.getReferredINode().asReference();
+        final INode referred = ref.getReferredINode();
+        withCount.setReferredINode(referred);
+        referred.setParentReference(withCount);
+        ref.clear();
+      }
+      referenceMap.clear();
+    }
+  }

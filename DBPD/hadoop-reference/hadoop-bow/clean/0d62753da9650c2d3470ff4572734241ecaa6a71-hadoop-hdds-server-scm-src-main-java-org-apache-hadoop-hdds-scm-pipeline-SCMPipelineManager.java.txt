HDDS-1128. Create stateful manager class for the pipeline creation scheduling.

Signed-off-by: Nanda kumar <nanda@apache.org>

+import org.apache.hadoop.hdds.scm.ScmConfigKeys;
+import org.apache.hadoop.utils.Scheduler;
+import java.util.concurrent.TimeUnit;
-  private final MetadataStore pipelineStore;
+  private final BackgroundPipelineCreator backgroundPipelineCreator;
+  private Scheduler scheduler;
+  private MetadataStore pipelineStore;
+  private final Configuration conf;
+    this.conf = conf;
+    // TODO: See if thread priority needs to be set for these threads
+    scheduler = new Scheduler("RatisPipelineUtilsThread", false, 1);
+    this.backgroundPipelineCreator =
+        new BackgroundPipelineCreator(this, scheduler, conf);
-  public void finalizePipeline(PipelineID pipelineId) throws IOException {
-    lock.writeLock().lock();
-    try {
-      stateManager.finalizePipeline(pipelineId);
-      Set<ContainerID> containerIDs = stateManager.getContainers(pipelineId);
-      for (ContainerID containerID : containerIDs) {
-        eventPublisher.fireEvent(SCMEvents.CLOSE_CONTAINER, containerID);
-      }
-    } finally {
-      lock.writeLock().unlock();
-    }
-  }
-
-  @Override
+  /**
+   * Finalizes pipeline in the SCM. Removes pipeline and makes rpc call to
+   * destroy pipeline on the datanodes immediately or after timeout based on the
+   * value of onTimeout parameter.
+   *
+   * @param pipeline        - Pipeline to be destroyed
+   * @param onTimeout       - if true pipeline is removed and destroyed on
+   *                        datanodes after timeout
+   * @throws IOException
+   */
-  public void removePipeline(PipelineID pipelineID) throws IOException {
-    lock.writeLock().lock();
-    try {
-      pipelineStore.delete(pipelineID.getProtobuf().toByteArray());
-      Pipeline pipeline = stateManager.removePipeline(pipelineID);
-      nodeManager.removePipeline(pipeline);
-      metrics.incNumPipelineDestroyed();
-    } catch (IOException ex) {
-      metrics.incNumPipelineDestroyFailed();
-      throw ex;
-    } finally {
-      lock.writeLock().unlock();
+  public void finalizeAndDestroyPipeline(Pipeline pipeline, boolean onTimeout)
+      throws IOException {
+    LOG.info("destroying pipeline:{}", pipeline);
+    finalizePipeline(pipeline.getId());
+    if (onTimeout) {
+      long pipelineDestroyTimeoutInMillis =
+          conf.getTimeDuration(ScmConfigKeys.OZONE_SCM_PIPELINE_DESTROY_TIMEOUT,
+              ScmConfigKeys.OZONE_SCM_PIPELINE_DESTROY_TIMEOUT_DEFAULT,
+              TimeUnit.MILLISECONDS);
+      scheduler.schedule(() -> destroyPipeline(pipeline),
+          pipelineDestroyTimeoutInMillis, TimeUnit.MILLISECONDS, LOG,
+          String.format("Destroy pipeline failed for pipeline:%s", pipeline));
+    } else {
+      destroyPipeline(pipeline);
+  /**
+   * Schedules a fixed interval job to create pipelines.
+   */
+  @Override
+  public void startPipelineCreator() {
+    backgroundPipelineCreator.startFixedIntervalPipelineCreator();
+  }
+
+  /**
+   * Triggers pipeline creation after the specified time.
+   */
+  @Override
+  public void triggerPipelineCreation() {
+    backgroundPipelineCreator.triggerPipelineCreation();
+  }
+
+  /**
+   * Moves the pipeline to CLOSED state and sends close container command for
+   * all the containers in the pipeline.
+   *
+   * @param pipelineId - ID of the pipeline to be moved to CLOSED state.
+   * @throws IOException
+   */
+  private void finalizePipeline(PipelineID pipelineId) throws IOException {
+    lock.writeLock().lock();
+    try {
+      stateManager.finalizePipeline(pipelineId);
+      Set<ContainerID> containerIDs = stateManager.getContainers(pipelineId);
+      for (ContainerID containerID : containerIDs) {
+        eventPublisher.fireEvent(SCMEvents.CLOSE_CONTAINER, containerID);
+      }
+    } finally {
+      lock.writeLock().unlock();
+    }
+  }
+
+  /**
+   * Removes pipeline from SCM. Sends ratis command to destroy pipeline on all
+   * the datanodes for ratis pipelines.
+   *
+   * @param pipeline        - Pipeline to be destroyed
+   * @throws IOException
+   */
+  private void destroyPipeline(Pipeline pipeline) throws IOException {
+    RatisPipelineUtils.destroyPipeline(pipeline, conf);
+    // remove the pipeline from the pipeline manager
+    removePipeline(pipeline.getId());
+    triggerPipelineCreation();
+  }
+
+  /**
+   * Removes the pipeline from the db and pipeline state map.
+   *
+   * @param pipelineId - ID of the pipeline to be removed
+   * @throws IOException
+   */
+  private void removePipeline(PipelineID pipelineId) throws IOException {
+    lock.writeLock().lock();
+    try {
+      pipelineStore.delete(pipelineId.getProtobuf().toByteArray());
+      Pipeline pipeline = stateManager.removePipeline(pipelineId);
+      nodeManager.removePipeline(pipeline);
+      metrics.incNumPipelineDestroyed();
+    } catch (IOException ex) {
+      metrics.incNumPipelineDestroyFailed();
+      throw ex;
+    } finally {
+      lock.writeLock().unlock();
+    }
+  }
+
-    if (pipelineFactory != null) {
-      pipelineFactory.close();
+    if (scheduler != null) {
+      scheduler.close();
+      scheduler = null;
+      pipelineStore = null;

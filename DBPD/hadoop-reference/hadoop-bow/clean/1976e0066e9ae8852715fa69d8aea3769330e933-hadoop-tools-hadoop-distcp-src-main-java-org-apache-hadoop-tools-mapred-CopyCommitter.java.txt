HADOOP-15209. DistCp to eliminate needless deletion of files under already-deleted directories.
Contributed by Steve Loughran.

-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.apache.hadoop.tools.DistCpConstants.*;
+
-  private static final Log LOG = LogFactory.getLog(CopyCommitter.class);
+  private static final Logger LOG =
+      LoggerFactory.getLogger(CopyCommitter.class);
+      } else if (conf.get(CONF_LABEL_TRACK_MISSING) != null) {
+        // save missing information to a directory
+        trackMissing(conf);
-  // This method deletes "extra" files from the target, if they're not
-  // available at the source.
+  /**
+   * Track all the missing files by saving the listings to the tracking
+   * directory.
+   * This is the same as listing phase of the
+   * {@link #deleteMissing(Configuration)} operation.
+   * @param conf configuration to read options from, and for FS instantiation.
+   * @throws IOException IO failure
+   */
+  private void trackMissing(Configuration conf) throws IOException {
+    // destination directory for all output files
+    Path trackDir = new Path(
+        conf.get(DistCpConstants.CONF_LABEL_TRACK_MISSING));
+
+    // where is the existing source listing?
+    Path sourceListing = new Path(
+        conf.get(DistCpConstants.CONF_LABEL_LISTING_FILE_PATH));
+    LOG.info("Tracking file changes to directory {}", trackDir);
+
+    // the destination path is under the track directory
+    Path sourceSortedListing = new Path(trackDir,
+        DistCpConstants.SOURCE_SORTED_FILE);
+    LOG.info("Source listing {}", sourceSortedListing);
+
+    DistCpUtils.sortListing(conf, sourceListing, sourceSortedListing);
+
+    // Similarly, create the listing of target-files. Sort alphabetically.
+    // target listing will be deleted after the sort
+    Path targetListing = new Path(trackDir, TARGET_LISTING_FILE);
+    Path sortedTargetListing = new Path(trackDir, TARGET_SORTED_FILE);
+    // list the target
+    listTargetFiles(conf, targetListing, sortedTargetListing);
+    LOG.info("Target listing {}", sortedTargetListing);
+
+    targetListing.getFileSystem(conf).delete(targetListing, false);
+  }
+
+  /**
+   * Deletes "extra" files and directories from the target, if they're not
+   * available at the source.
+   * @param conf configuration to read options from, and for FS instantiation.
+   * @throws IOException IO failure
+   */
+    long listingStart = System.currentTimeMillis();
-    Path sortedSourceListing = DistCpUtils.sortListing(clusterFS, conf, sourceListing);
+    Path sortedSourceListing = DistCpUtils.sortListing(conf, sourceListing);
-    CopyListing target = new GlobbedCopyListing(new Configuration(conf), null);
+    Path sortedTargetListing = new Path(targetListing.toString() + "_sorted");
-    List<Path> targets = new ArrayList<Path>(1);
-    Path targetFinalPath = new Path(conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));
-    targets.add(targetFinalPath);
-    Path resultNonePath = Path.getPathWithoutSchemeAndAuthority(targetFinalPath)
-        .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)
-        ? DistCpConstants.RAW_NONE_PATH : DistCpConstants.NONE_PATH;
-    //
-    // Set up options to be the same from the CopyListing.buildListing's perspective,
-    // so to collect similar listings as when doing the copy
-    //
-    DistCpOptions options = new DistCpOptions.Builder(targets, resultNonePath)
-        .withOverwrite(overwrite)
-        .withSyncFolder(syncFolder)
-        .build();
-    DistCpContext distCpContext = new DistCpContext(options);
-    distCpContext.setTargetPathExists(targetPathExists);
-
-    target.buildListing(targetListing, distCpContext);
-    Path sortedTargetListing = DistCpUtils.sortListing(clusterFS, conf, targetListing);
+    Path targetFinalPath = listTargetFiles(conf,
+        targetListing, sortedTargetListing);
+    long deletionStart = System.currentTimeMillis();
+    LOG.info("Listing completed in {}",
+        formatDuration(deletionStart - listingStart));
+
+    long filesDeleted = 0;
+    long missingDeletes = 0;
+    long failedDeletes = 0;
+    long skippedDeletes = 0;
+    long deletedDirectories = 0;
+    // this is an arbitrary constant.
+    final DeletedDirTracker tracker = new DeletedDirTracker(1000);
-      FileSystem targetFS = targetFinalPath.getFileSystem(conf);
+      final FileSystem targetFS = targetFinalPath.getFileSystem(conf);
+      boolean showProgress;
+        Path targetEntry = trgtFileStatus.getPath();
+        LOG.debug("Comparing {} and {}",
+            srcFileStatus.getPath(), targetEntry);
-        // Target doesn't exist at source. Delete.
-        boolean result = targetFS.delete(trgtFileStatus.getPath(), true)
-            || !targetFS.exists(trgtFileStatus.getPath());
-        if (result) {
-          LOG.info("Deleted " + trgtFileStatus.getPath() + " - Missing at source");
-          deletedEntries++;
+        // Target doesn't exist at source. Try to delete it.
+        if (tracker.shouldDelete(trgtFileStatus)) {
+          showProgress = true;
+          try {
+            if (targetFS.delete(targetEntry, true)) {
+              // the delete worked. Unless the file is actually missing, this is the
+              LOG.info("Deleted " + targetEntry + " - missing at source");
+              deletedEntries++;
+              if (trgtFileStatus.isDirectory()) {
+                deletedDirectories++;
+              } else {
+                filesDeleted++;
+              }
+            } else {
+              // delete returned false.
+              // For all the filestores which implement the FS spec properly,
+              // this means "the file wasn't there".
+              // so track but don't worry about it.
+              LOG.info("delete({}) returned false ({})",
+                  targetEntry, trgtFileStatus);
+              missingDeletes++;
+            }
+          } catch (IOException e) {
+            if (!ignoreFailures) {
+              throw e;
+            } else {
+              // failed to delete, but ignoring errors. So continue
+              LOG.info("Failed to delete {}, ignoring exception {}",
+                  targetEntry, e.toString());
+              LOG.debug("Failed to delete {}", targetEntry, e);
+              // count and break out the loop
+              failedDeletes++;
+            }
+          }
-          throw new IOException("Unable to delete " + trgtFileStatus.getPath());
+          LOG.debug("Skipping deletion of {}", targetEntry);
+          skippedDeletes++;
+          showProgress = false;
-        taskAttemptContext.progress();
-        taskAttemptContext.setStatus("Deleting missing files from target. [" +
-            targetReader.getPosition() * 100 / totalLen + "%]");
+        if (showProgress) {
+          // update progress if there's been any FS IO/files deleted.
+          taskAttemptContext.progress();
+          taskAttemptContext.setStatus("Deleting removed files from target. [" +
+              targetReader.getPosition() * 100 / totalLen + "%]");
+        }
+      // if the FS toString() call prints statistics, they get logged here
+      LOG.info("Completed deletion of files from {}", targetFS);
-    LOG.info("Deleted " + deletedEntries + " from target: " + targets.get(0));
+    long deletionEnd = System.currentTimeMillis();
+    long deletedFileCount = deletedEntries - deletedDirectories;
+    LOG.info("Deleted from target: files: {} directories: {};"
+            + " skipped deletions {}; deletions already missing {};"
+            + " failed deletes {}",
+        deletedFileCount, deletedDirectories, skippedDeletes,
+        missingDeletes, failedDeletes);
+    LOG.info("Number of tracked deleted directories {}", tracker.size());
+    LOG.info("Duration of deletions: {}",
+        formatDuration(deletionEnd - deletionStart));
+    LOG.info("Total duration of deletion operation: {}",
+        formatDuration(deletionEnd - listingStart));
+  }
+
+  /**
+   * Take a duration and return a human-readable duration of
+   * hours:minutes:seconds.millis.
+   * @param duration to process
+   * @return a string for logging.
+   */
+  private String formatDuration(long duration) {
+
+    long seconds = duration > 0 ? (duration / 1000) : 0;
+    long minutes = (seconds / 60);
+    long hours = (minutes / 60);
+    return String.format("%d:%02d:%02d.%03d",
+        hours, minutes % 60, seconds % 60, duration % 1000);
+  }
+
+  /**
+   * Build a listing of the target files, sorted and unsorted.
+   * @param conf configuration to work with
+   * @param targetListing target listing
+   * @param sortedTargetListing sorted version of the listing
+   * @return the target path of the operation
+   * @throws IOException IO failure.
+   */
+  private Path listTargetFiles(final Configuration conf,
+      final Path targetListing,
+      final Path sortedTargetListing) throws IOException {
+    CopyListing target = new GlobbedCopyListing(new Configuration(conf), null);
+    Path targetFinalPath = new Path(
+        conf.get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));
+    List<Path> targets = new ArrayList<>(1);
+    targets.add(targetFinalPath);
+    Path resultNonePath = Path.getPathWithoutSchemeAndAuthority(targetFinalPath)
+        .toString().startsWith(DistCpConstants.HDFS_RESERVED_RAW_DIRECTORY_NAME)
+        ? DistCpConstants.RAW_NONE_PATH
+        : DistCpConstants.NONE_PATH;
+    //
+    // Set up options to be the same from the CopyListing.buildListing's
+    // perspective, so to collect similar listings as when doing the copy
+    //
+    DistCpOptions options = new DistCpOptions.Builder(targets, resultNonePath)
+        .withOverwrite(overwrite)
+        .withSyncFolder(syncFolder)
+        .build();
+    DistCpContext distCpContext = new DistCpContext(options);
+    distCpContext.setTargetPathExists(targetPathExists);
+
+    target.buildListing(targetListing, distCpContext);
+    DistCpUtils.sortListing(conf, targetListing, sortedTargetListing);
+    return targetFinalPath;

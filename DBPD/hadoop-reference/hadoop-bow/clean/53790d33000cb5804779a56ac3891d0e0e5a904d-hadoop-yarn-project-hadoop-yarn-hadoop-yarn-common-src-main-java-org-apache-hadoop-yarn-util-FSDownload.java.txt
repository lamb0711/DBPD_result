YARN-1771. Reduce the number of NameNode operations during localization of
public resources using a cache. Contributed by Sangjin Lee



git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1577391 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.util.concurrent.Futures;
+
+  private final LoadingCache<Path,Future<FileStatus>> statCache;
+    this(files, ugi, conf, destDirPath, resource, null);
+  }
+
+  public FSDownload(FileContext files, UserGroupInformation ugi, Configuration conf,
+      Path destDirPath, LocalResource resource,
+      LoadingCache<Path,Future<FileStatus>> statCache) {
+    this.statCache = statCache;
-   * Returns a boolean to denote whether a cache file is visible to all(public)
-   * or not
-   * @param conf
-   * @param uri
-   * @return true if the path in the uri is visible to all, false otherwise
-   * @throws IOException
+   * Creates the cache loader for the status loading cache. This should be used
+   * to create an instance of the status cache that is passed into the
+   * FSDownload constructor.
-  private static boolean isPublic(FileSystem fs, Path current) throws IOException {
-    current = fs.makeQualified(current);
-    //the leaf level file should be readable by others
-    if (!checkPublicPermsForAll(fs, current, FsAction.READ_EXECUTE, FsAction.READ)) {
-      return false;
-    }
-    return ancestorsHaveExecutePermissions(fs, current.getParent());
+  public static CacheLoader<Path,Future<FileStatus>>
+      createStatusCacheLoader(final Configuration conf) {
+    return new CacheLoader<Path,Future<FileStatus>>() {
+      public Future<FileStatus> load(Path path) {
+        try {
+          FileSystem fs = path.getFileSystem(conf);
+          return Futures.immediateFuture(fs.getFileStatus(path));
+        } catch (Throwable th) {
+          // report failures so it can be memoized
+          return Futures.immediateFailedFuture(th);
+        }
+      }
+    };
-  private static boolean checkPublicPermsForAll(FileSystem fs, Path current, 
-      FsAction dir, FsAction file) 
-    throws IOException {
-    return checkPublicPermsForAll(fs, fs.getFileStatus(current), dir, file);
+  /**
+   * Returns a boolean to denote whether a cache file is visible to all (public)
+   * or not
+   *
+   * @return true if the path in the current path is visible to all, false
+   * otherwise
+   */
+  @VisibleForTesting
+  static boolean isPublic(FileSystem fs, Path current, FileStatus sStat,
+      LoadingCache<Path,Future<FileStatus>> statCache) throws IOException {
+    current = fs.makeQualified(current);
+    //the leaf level file should be readable by others
+    if (!checkPublicPermsForAll(fs, sStat, FsAction.READ_EXECUTE, FsAction.READ)) {
+      return false;
+    }
+    return ancestorsHaveExecutePermissions(fs, current.getParent(), statCache);
-    
+
-  private static boolean ancestorsHaveExecutePermissions(FileSystem fs, Path path)
-    throws IOException {
+  private static boolean ancestorsHaveExecutePermissions(FileSystem fs,
+      Path path, LoadingCache<Path,Future<FileStatus>> statCache)
+      throws IOException {
-      if (!checkPermissionOfOther(fs, current, FsAction.EXECUTE)) {
+      if (!checkPermissionOfOther(fs, current, FsAction.EXECUTE, statCache)) {
-      FsAction action) throws IOException {
-    FileStatus status = fs.getFileStatus(path);
+      FsAction action, LoadingCache<Path,Future<FileStatus>> statCache)
+      throws IOException {
+    FileStatus status = getFileStatus(fs, path, statCache);
-  
+  /**
+   * Obtains the file status, first by checking the stat cache if it is
+   * available, and then by getting it explicitly from the filesystem. If we got
+   * the file status from the filesystem, it is added to the stat cache.
+   *
+   * The stat cache is expected to be managed by callers who provided it to
+   * FSDownload.
+   */
+  private static FileStatus getFileStatus(final FileSystem fs, final Path path,
+      LoadingCache<Path,Future<FileStatus>> statCache) throws IOException {
+    // if the stat cache does not exist, simply query the filesystem
+    if (statCache == null) {
+      return fs.getFileStatus(path);
+    }
+
+    try {
+      // get or load it from the cache
+      return statCache.get(path).get();
+    } catch (ExecutionException e) {
+      Throwable cause = e.getCause();
+      // the underlying exception should normally be IOException
+      if (cause instanceof IOException) {
+        throw (IOException)cause;
+      } else {
+        throw new IOException(cause);
+      }
+    } catch (InterruptedException e) { // should not happen
+      Thread.currentThread().interrupt();
+      throw new IOException(e);
+    }
+  }
+
-      if (!isPublic(sourceFs, sCopy)) {
+      if (!isPublic(sourceFs, sCopy, sStat, statCache)) {
-    
-    sourceFs.copyToLocalFile(sCopy, dCopy);
+
+    FileUtil.copy(sourceFs, sStat, FileSystem.getLocal(conf), dCopy, false,
+        true, conf);

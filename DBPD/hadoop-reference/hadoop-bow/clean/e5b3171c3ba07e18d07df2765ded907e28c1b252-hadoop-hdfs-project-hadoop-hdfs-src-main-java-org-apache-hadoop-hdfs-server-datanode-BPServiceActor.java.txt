HDFS-5494. Fix findbugs warnings for HDFS-2832.

git-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1540924 13f79535-47bb-0310-9956-ffa450edef68

-      pendingIncrementalBRperStorage = Maps.newConcurrentMap();
+      pendingIncrementalBRperStorage = Maps.newHashMap();
-   * Report received blocks and delete hints to the Namenode
+   * Report received blocks and delete hints to the Namenode for each
+   * storage.
+   *
-    // For each storage, check if there are newly received blocks and if
-    // so then send an incremental report to the NameNode.
-    for (Map.Entry<String, PerStoragePendingIncrementalBR> entry :
-        pendingIncrementalBRperStorage.entrySet()) {
-      final String storageUuid = entry.getKey();
-      final PerStoragePendingIncrementalBR perStorageMap = entry.getValue();
-      ReceivedDeletedBlockInfo[] receivedAndDeletedBlockArray = null;
-      // TODO: We can probably use finer-grained synchronization now.
-      synchronized (pendingIncrementalBRperStorage) {
+
+    // Generate a list of the pending reports for each storage under the lock
+    Map<String, ReceivedDeletedBlockInfo[]> blockArrays = Maps.newHashMap();
+    synchronized (pendingIncrementalBRperStorage) {
+      for (Map.Entry<String, PerStoragePendingIncrementalBR> entry :
+           pendingIncrementalBRperStorage.entrySet()) {
+        final String storageUuid = entry.getKey();
+        final PerStoragePendingIncrementalBR perStorageMap = entry.getValue();
+        ReceivedDeletedBlockInfo[] receivedAndDeletedBlockArray = null;
+
+          blockArrays.put(storageUuid, receivedAndDeletedBlockArray);
+    }
-      if (receivedAndDeletedBlockArray != null) {
-        StorageReceivedDeletedBlocks[] report = { new StorageReceivedDeletedBlocks(
-            storageUuid, receivedAndDeletedBlockArray) };
-        boolean success = false;
-        try {
-          bpNamenode.blockReceivedAndDeleted(bpRegistration, bpos.getBlockPoolId(),
-              report);
-          success = true;
-        } finally {
+    // Send incremental block reports to the Namenode outside the lock
+    for (Map.Entry<String, ReceivedDeletedBlockInfo[]> entry :
+         blockArrays.entrySet()) {
+      final String storageUuid = entry.getKey();
+      final ReceivedDeletedBlockInfo[] rdbi = entry.getValue();
+
+      StorageReceivedDeletedBlocks[] report = { new StorageReceivedDeletedBlocks(
+          storageUuid, rdbi) };
+      boolean success = false;
+      try {
+        bpNamenode.blockReceivedAndDeleted(bpRegistration,
+            bpos.getBlockPoolId(), report);
+        success = true;
+      } finally {
+        if (!success) {
-            if (!success) {
-              // If we didn't succeed in sending the report, put all of the
-              // blocks back onto our queue, but only in the case where we
-              // didn't put something newer in the meantime.
-              perStorageMap.putMissingBlockInfos(receivedAndDeletedBlockArray);
-              pendingReceivedRequests += perStorageMap.getBlockInfoCount();
-            }
+            // If we didn't succeed in sending the report, put all of the
+            // blocks back onto our queue, but only in the case where we
+            // didn't put something newer in the meantime.
+            PerStoragePendingIncrementalBR perStorageMap =
+                pendingIncrementalBRperStorage.get(storageUuid);
+            perStorageMap.putMissingBlockInfos(rdbi);
+            pendingReceivedRequests += perStorageMap.getBlockInfoCount();

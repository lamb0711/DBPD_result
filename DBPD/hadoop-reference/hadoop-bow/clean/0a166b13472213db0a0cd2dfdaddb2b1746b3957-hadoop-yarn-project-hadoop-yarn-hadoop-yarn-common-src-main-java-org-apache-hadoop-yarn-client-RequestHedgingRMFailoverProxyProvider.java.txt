YARN-5711. Propogate exceptions back to client when using hedging RM failover provider.

-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.io.retry.MultiException;
-import org.apache.hadoop.io.retry.RetryPolicy;
-import org.apache.hadoop.io.retry.RetryProxy;
-import org.apache.hadoop.util.concurrent.HadoopExecutors;
-import org.apache.hadoop.yarn.conf.HAUtil;
-import org.apache.hadoop.yarn.conf.YarnConfiguration;
-
+import java.util.concurrent.ExecutionException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.io.retry.RetryPolicy;
+import org.apache.hadoop.io.retry.RetryProxy;
+import org.apache.hadoop.util.concurrent.HadoopExecutors;
+import org.apache.hadoop.yarn.conf.HAUtil;
+import org.apache.hadoop.yarn.conf.YarnConfiguration;
+
- * retry the corresponding target. It assumes the in an HA setup, there will
- * be only one Active, and the active should respond faster than any configured
+ * retry the corresponding target. It assumes the in an HA setup, there will be
+ * only one Active, and the active should respond faster than any configured
-      T proxy = RMProxy.<T>getProxy(conf, protocol, rmAddress);
+      T proxy = RMProxy.<T> getProxy(conf, protocol, rmAddress);
-      LOG.error("Unable to create proxy to the ResourceManager " + HAUtil
-          .getRMHAId(conf), ioe);
+      LOG.error("Unable to create proxy to the ResourceManager "
+          + HAUtil.getRMHAId(conf), ioe);
+    private Throwable extraRootException(Exception ex) {
+      Throwable rootCause = ex;
+      if (ex instanceof ExecutionException) {
+        Throwable cause = ex.getCause();
+        if (cause instanceof InvocationTargetException) {
+          rootCause = cause.getCause();
+        }
+      }
+      return rootCause;
+    }
+
-    public Object invoke(Object proxy, final Method method,
-        final Object[] args) throws Throwable {
+    public Object invoke(Object proxy, final Method method, final Object[] args)
+        throws Throwable {
-        return invokeMethod(nonRetriableProxy.get(successfulProxy), method, args);
+        return invokeMethod(nonRetriableProxy.get(successfulProxy), method,
+            args);
-        int numAttempts = 0;
-            @Override public Object call() throws Exception {
+            @Override
+            public Object call() throws Exception {
-          numAttempts++;
-        Map<String, Exception> badResults = new HashMap<>();
-        while (numAttempts > 0) {
-          Future<Object> callResultFuture = completionService.take();
-          String pInfo = proxyMap.get(callResultFuture).proxyInfo;
-          Object retVal;
-          try {
-            retVal = callResultFuture.get();
-            successfulProxy = pInfo;
-            LOG.info("Invocation successful on [" + pInfo + "]");
-            return retVal;
-          } catch (Exception ex) {
-            LOG.warn("Invocation returned exception on " + "[" + pInfo + "]");
-            badResults.put(pInfo, ex);
-            numAttempts--;
-          }
+        Future<Object> callResultFuture = completionService.take();
+        String pInfo = proxyMap.get(callResultFuture).proxyInfo;
+        successfulProxy = pInfo;
+        Object retVal;
+        try {
+          retVal = callResultFuture.get();
+          LOG.info("Invocation successful on [" + pInfo + "]");
+          return retVal;
+        } catch (Exception ex) {
+          // Throw exception from first responding RM so that clients can handle
+          // appropriately
+          Throwable rootCause = extraRootException(ex);
+          LOG.warn("Invocation returned exception: " + rootCause.toString()
+              + " on " + "[" + pInfo + "], so propagating back to caller.");
+          throw rootCause;
-        // At this point we should have All bad results (Exceptions)
-        // Or should have returned with successful result.
-        if (badResults.size() == 1) {
-          throw badResults.values().iterator().next();
-        } else {
-          throw new MultiException(badResults);
-        }
